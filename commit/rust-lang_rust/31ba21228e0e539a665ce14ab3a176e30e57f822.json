{"sha": "31ba21228e0e539a665ce14ab3a176e30e57f822", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYmEyMTIyOGUwZTUzOWE2NjVjZTE0YWIzYTE3NmUzMGU1N2Y4MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T10:54:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T10:54:50Z"}, "message": "Auto merge of #23436 - Manishearth:rollup, r=Manishearth\n\nr? @Manishearth", "tree": {"sha": "df74635628ec08ddfb86c9815296e7db428fcd8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df74635628ec08ddfb86c9815296e7db428fcd8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ba21228e0e539a665ce14ab3a176e30e57f822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ba21228e0e539a665ce14ab3a176e30e57f822", "html_url": "https://github.com/rust-lang/rust/commit/31ba21228e0e539a665ce14ab3a176e30e57f822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ba21228e0e539a665ce14ab3a176e30e57f822/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883551b1d739993dffcba01ee9ea3237cf406d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/883551b1d739993dffcba01ee9ea3237cf406d9a", "html_url": "https://github.com/rust-lang/rust/commit/883551b1d739993dffcba01ee9ea3237cf406d9a"}, {"sha": "dcec88cca3f4688241872e21d5a08f339f938879", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcec88cca3f4688241872e21d5a08f339f938879", "html_url": "https://github.com/rust-lang/rust/commit/dcec88cca3f4688241872e21d5a08f339f938879"}], "stats": {"total": 3753, "additions": 1851, "deletions": 1902}, "files": [{"sha": "f92fc653e0ef32719d45f95e5a842d85e8d3bece", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -64,7 +64,7 @@ Read [\"Installing Rust\"] from [The Book].\n    # Choose one based on platform:\n    $ pacman -S mingw-w64-i686-toolchain\n    $ pacman -S mingw-w64-x86_64-toolchain\n-   \n+\n    $ pacman -S base-devel\n    ```\n "}, {"sha": "e5866094ee84f7b181fc0de2f8c86d4210c5f881", "filename": "mk/cfg/x86_64-unknown-linux-gnu.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-linux-gnu.mk?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -25,4 +25,3 @@ CFG_LDPATH_x86_64-unknown-linux-gnu :=\n CFG_RUN_x86_64-unknown-linux-gnu=$(2)\n CFG_RUN_TARG_x86_64-unknown-linux-gnu=$(call CFG_RUN_x86_64-unknown-linux-gnu,,$(2))\n CFG_GNU_TRIPLE_x86_64-unknown-linux-gnu := x86_64-unknown-linux-gnu\n-"}, {"sha": "4ded8a7916b9ba4d386d61f3d5198fffc5109063", "filename": "mk/prepare.mk", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -221,5 +221,3 @@ prepare-maybe-clean-$(1):\n \n \n endef\n-\n-"}, {"sha": "b419c0bbe8ebe4e5f7169fe4d27ab068e6912bab", "filename": "mk/util.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/mk%2Futil.mk", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/mk%2Futil.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Futil.mk?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ else\n endif\n \n S := $(CFG_SRC_DIR)\n-"}, {"sha": "1ea3c7d7bd9d87924cab902b7c69fa34238752e0", "filename": "src/doc/grammar.md", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -290,7 +290,7 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n \n # Items and attributes\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ## Items\n \n@@ -301,7 +301,7 @@ item : mod_item | fn_item | type_item | struct_item | enum_item\n \n ### Type Parameters\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Modules\n \n@@ -338,35 +338,35 @@ path_item : ident | \"mod\" ;\n \n ### Functions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Generic functions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Unsafety\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ##### Unsafe functions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ##### Unsafe blocks\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Diverging functions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Type definitions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Structures\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Constant items\n \n@@ -382,15 +382,15 @@ static_item : \"static\" ident ':' type '=' expr ';' ;\n \n #### Mutable statics\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Traits\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Implementations\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### External blocks\n \n@@ -401,11 +401,11 @@ extern_block : [ foreign_fn ] * ;\n \n ## Visibility and Privacy\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Re-exporting and Visibility\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ## Attributes\n \n@@ -420,19 +420,19 @@ meta_seq : meta_item [ ',' meta_seq ] ? ;\n \n ## Statements\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Declaration statements\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n A _declaration statement_ is one that introduces one or more *names* into the\n enclosing statement block. The declared names may denote new slots or new\n items.\n \n #### Item declarations\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n An _item declaration statement_ has a syntactic form identical to an\n [item](#items) declaration within a module. Declaring an item &mdash; a\n@@ -450,35 +450,35 @@ init : [ '=' ] expr ;\n \n ### Expression statements\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ## Expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Lvalues, rvalues and temporaries\n \n-**FIXME:** grammar?  \n+**FIXME:** grammar?\n \n #### Moved and copied types\n \n-**FIXME:** Do we want to capture this in the grammar as different productions? \n+**FIXME:** Do we want to capture this in the grammar as different productions?\n \n ### Literal expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Path expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Tuple expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Unit expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Structure expressions\n \n@@ -527,7 +527,7 @@ idx_expr : expr '[' expr ']' ;\n \n ### Unary operator expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Binary operator expressions\n \n@@ -537,31 +537,31 @@ binop_expr : expr binop expr ;\n \n #### Arithmetic operators\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Bitwise operators\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Lazy boolean operators\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Comparison operators\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Type cast expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Assignment expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Compound assignment expressions\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Operator precedence\n \n@@ -680,49 +680,49 @@ return_expr : \"return\" expr ? ;\n \n # Type system\n \n-**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already? \n+**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already?\n \n ## Types\n \n ### Primitive types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Machine types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n #### Machine-dependent integer types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Textual types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Tuple types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Array, and Slice types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Structure types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Enumerated types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Pointer types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Function types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Closure types\n \n@@ -739,23 +739,23 @@ bound := path | lifetime\n \n ### Object types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Type parameters\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ### Self types\n \n-**FIXME:** grammar? \n+**FIXME:** grammar?\n \n ## Type kinds\n \n **FIXME:** this this probably not relevant to the grammar...\n \n # Memory and concurrency models\n \n-**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already? \n+**FIXME:** is this entire chapter relevant here? Or should it all have been covered by some production already?\n \n ## Memory model\n "}, {"sha": "51280e58854761e0f8ae80f6311e064963c628b8", "filename": "src/doc/intro.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -140,7 +140,7 @@ right at home if you've used tools like [Bundler](http://bundler.io/),\n [npm](https://www.npmjs.org/), or [pip](https://pip.pypa.io/en/latest/).\n There's no `Makefile`s or endless `autotools` output here. (Rust's tooling does\n [play nice with external libraries written in those\n-tools](http://crates.io/native-build.html), if you need to.)\n+tools](http://doc.crates.io/build-script.html), if you need to.)\n \n Enough about tools, let's talk code!\n "}, {"sha": "eae2bf1925a99622c2f8b8f2486270da30d96897", "filename": "src/doc/not_found.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Fnot_found.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Fnot_found.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnot_found.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -63,4 +63,3 @@ function populate_rust_search() {\n populate_site_search();\n populate_rust_search();\n </script>\n-"}, {"sha": "3fae49bfc6d3ef23e166d125b9a8ea8f409ec2cc", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1961,16 +1961,18 @@ module through the rules above. It essentially allows public access into the\n re-exported item. For example, this program is valid:\n \n ```\n-pub use self::implementation as api;\n+pub use self::implementation::api;\n \n mod implementation {\n-    pub fn f() {}\n+    pub mod api {\n+        pub fn f() {}\n+    }\n }\n \n # fn main() {}\n ```\n \n-This means that any external crate referencing `implementation::f` would\n+This means that any external crate referencing `implementation::api::f` would\n receive a privacy violation, while the path `api::f` would be allowed.\n \n When re-exporting a private item, it can be thought of as allowing the \"privacy"}, {"sha": "5d0f314e8c62ec5556b804303a7ef7884647c793", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -49,7 +49,7 @@ languages.\n \n A *vector* is a dynamic or \"growable\" array, implemented as the standard\n library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n-later). Vectors always allocate their data on the heap. Vectors are to slices \n+later). Vectors always allocate their data on the heap. Vectors are to slices\n what `String` is to `&str`. You can create them with the `vec!` macro:\n \n ```{rust}"}, {"sha": "f6f6046b9b458367045dc12350613a223ec6eeaa", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -551,9 +551,9 @@ module, we now have a `phrases::japanese::hello()` function and a\n `phrases::japanese::farewells::goodbye()`. Our internal organization doesn't\n define our external interface.\n \n-Here we have a `pub use` for each function we want to bring into the \n+Here we have a `pub use` for each function we want to bring into the\n `japanese` scope. We could alternatively use the wildcard syntax to include\n-everything from `greetings` into the current scope: `pub use self::greetings::*`. \n+everything from `greetings` into the current scope: `pub use self::greetings::*`.\n \n What about the `self`? Well, by default, `use` declarations are absolute paths,\n starting from your crate root. `self` makes that path relative to your current"}, {"sha": "8e5b3b6a7f0afa2f25c1b7938de9cf525d9ecd45", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -306,23 +306,23 @@ println!(\"{}\", x + y);\n Here's the same explanation, in raw text:\n \n > First, we set `x` to five:\n-> \n+>\n > ```text\n > let x = 5;\n > # let y = 6;\n > # println!(\"{}\", x + y);\n > ```\n-> \n+>\n > Next, we set `y` to six:\n-> \n+>\n > ```text\n > # let x = 5;\n > let y = 6;\n > # println!(\"{}\", x + y);\n > ```\n-> \n+>\n > Finally, we print the sum of `x` and `y`:\n-> \n+>\n > ```text\n > # let x = 5;\n > # let y = 6;\n@@ -521,4 +521,3 @@ This sets a few different options, with a logo, favicon, and a root URL.\n - `--html-before-content FILE`: includes the contents of FILE directly after\n   `<body>`, before the rendered content (including the search bar).\n - `--html-after-content FILE`: includes the contents of FILE after all the rendered content.\n-"}, {"sha": "20b0ffc1b286200c751e294ad684787f3c6ad49e", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -543,4 +543,3 @@ The `extern` makes this function adhere to the C calling convention, as\n discussed above in \"[Foreign Calling\n Conventions](ffi.html#foreign-calling-conventions)\". The `no_mangle`\n attribute turns off Rust's name mangling, so that it is easier to link to.\n-"}, {"sha": "0ca42c3b12db2d4282bfaae449ee6508b8357b0c", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -61,15 +61,15 @@ struct Circle {\n \n impl Circle {\n     fn reference(&self) {\n-       println!(\"taking self by reference!\"); \n+       println!(\"taking self by reference!\");\n     }\n \n     fn mutable_reference(&mut self) {\n-       println!(\"taking self by mutable reference!\"); \n+       println!(\"taking self by mutable reference!\");\n     }\n \n     fn takes_ownership(self) {\n-       println!(\"taking ownership of self!\"); \n+       println!(\"taking ownership of self!\");\n     }\n }\n ```"}, {"sha": "a7794814156e63fd330d21713d219cff2d7fd550", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -95,7 +95,7 @@ However, the common case is that it is more efficient to use static dispatch,\n and one can always have a thin statically-dispatched wrapper function that does\n a dynamic dispatch, but not vice versa, meaning static calls are more flexible.\n The standard library tries to be statically dispatched where possible for this\n-reason. \n+reason.\n \n ## Dynamic dispatch\n "}, {"sha": "537e100d7d830354782734de580653d90733dae2", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1,7 +1,7 @@\n % Testing\n \n > Program testing can be a very effective way to show the presence of bugs, but\n-> it is hopelessly inadequate for showing their absence. \n+> it is hopelessly inadequate for showing their absence.\n >\n > Edsger W. Dijkstra, \"The Humble Programmer\" (1972)\n \n@@ -308,7 +308,7 @@ extern crate adder;\n #[test]\n fn it_works() {\n     assert_eq!(4, adder::add_two(2));\n-}   \n+}\n ```\n \n This looks similar to our previous tests, but slightly different. We now have"}, {"sha": "86fa779cced5fe81f02fb8eb2f417a5c2209955a", "filename": "src/etc/featureck.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Ffeatureck.py", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Ffeatureck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ffeatureck.py?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -242,4 +242,3 @@\n for line in lines:\n     print \"* \" + line\n print\n-"}, {"sha": "4e489df7dd75a76412e4e417751845fbb7f41153", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -340,4 +340,4 @@ def extract_length_and_data_ptr_from_std_vec(vec_val):\n     unique_ptr_val = vec_ptr_val[first_field(vec_ptr_val)]\n     data_ptr = unique_ptr_val[first_field(unique_ptr_val)]\n     assert data_ptr.type.code == gdb.TYPE_CODE_PTR\n-    return (length, data_ptr)\n\\ No newline at end of file\n+    return (length, data_ptr)"}, {"sha": "e36e6abde9178dd6b5c1515ff6d4a7a33854f9d1", "filename": "src/etc/mingw-fix-include/README.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Fmingw-fix-include%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Fmingw-fix-include%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmingw-fix-include%2FREADME.txt?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1,6 +1,6 @@\n The purpose of these headers is to fix issues with mingw v4.0, as described in #9246.\n \n-This works by adding this directory to GCC include search path before mingw system headers directories, \n+This works by adding this directory to GCC include search path before mingw system headers directories,\n so we can intercept their inclusions and add missing definitions without having to modify files in mingw/include.\n \n Once mingw fixes all 3 issues mentioned in #9246, this directory and all references to it from rust/mk/* may be removed."}, {"sha": "e86f7fb58a4656330ebdfab5e75d72f86f5e9af9", "filename": "src/etc/third-party/COPYING.RUNTIME", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Fthird-party%2FCOPYING.RUNTIME", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fetc%2Fthird-party%2FCOPYING.RUNTIME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fthird-party%2FCOPYING.RUNTIME?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -70,4 +70,3 @@ consistent with the licensing of the Independent Modules.\n The availability of this Exception does not imply any general\n presumption that third-party software is unaffected by the copyleft\n requirements of the license of GCC.\n-"}, {"sha": "b0628303b6601e39e3092647649306783e7446f4", "filename": "src/grammar/check.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fgrammar%2Fcheck.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fgrammar%2Fcheck.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fcheck.sh?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -50,4 +50,3 @@ else\n     printf \"failed. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n     exit 1\n fi\n-"}, {"sha": "8befb0579c3a64de42dedceb5b83b915286a5246", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -94,7 +94,7 @@ use heap::deallocate;\n /// With simple pipes, without `Arc`, a copy would have to be made for each\n /// task.\n ///\n-/// ```rust\n+/// ```\n /// use std::sync::Arc;\n /// use std::thread;\n ///"}, {"sha": "451237d75969c8cb409ad485e66cda16eb74e321", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -64,7 +64,7 @@ use core::raw::TraitObject;\n ///\n /// The following two examples are equivalent:\n ///\n-/// ```rust\n+/// ```\n /// #![feature(box_syntax)]\n /// use std::boxed::HEAP;\n ///"}, {"sha": "437289982927dc29c6acec1f4a1e8746afe6c872", "filename": "src/libbacktrace/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.am?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -6,12 +6,12 @@\n # met:\n \n #     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n+#     notice, this list of conditions and the following disclaimer.\n \n #     (2) Redistributions in binary form must reproduce the above copyright\n #     notice, this list of conditions and the following disclaimer in\n #     the documentation and/or other materials provided with the\n-#     distribution.  \n+#     distribution.\n \n #     (3) The name of the author may not be used to\n #     endorse or promote products derived from this software without"}, {"sha": "93ccec2dbf92f4f6753fa62d75979d62719ef319", "filename": "src/libbacktrace/Makefile.in", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.in?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -23,12 +23,12 @@\n # met:\n \n #     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n+#     notice, this list of conditions and the following disclaimer.\n \n #     (2) Redistributions in binary form must reproduce the above copyright\n #     notice, this list of conditions and the following disclaimer in\n #     the documentation and/or other materials provided with the\n-#     distribution.  \n+#     distribution.\n \n #     (3) The name of the author may not be used to\n #     endorse or promote products derived from this software without\n@@ -117,10 +117,10 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n \t$(btest_SOURCES)\n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n+MULTISRCTOP =\n+MULTIBUILDTOP =\n+MULTIDIRS =\n+MULTISUBDIR =\n MULTIDO = true\n MULTICLEAN = true\n ETAGS = etags\n@@ -362,7 +362,7 @@ config.h: stamp-h1\n stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n \t@rm -f stamp-h1\n \tcd $(top_builddir) && $(SHELL) ./config.status config.h\n-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n \t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n \trm -f stamp-h1\n \ttouch $@\n@@ -380,7 +380,7 @@ clean-noinstLTLIBRARIES:\n \t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n \t  rm -f \"$${dir}/so_locations\"; \\\n \tdone\n-libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) \n+libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES)\n \t$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)\n \n clean-checkPROGRAMS:\n@@ -391,7 +391,7 @@ clean-checkPROGRAMS:\n \tlist=`for p in $$list; do echo \"$$p\"; done | sed 's/$(EXEEXT)$$//'`; \\\n \techo \" rm -f\" $$list; \\\n \trm -f $$list\n-btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) \n+btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES)\n \t@rm -f btest$(EXEEXT)\n \t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n "}, {"sha": "4aa85d050fd179681c419d9dad91984f7afdb3f4", "filename": "src/libbacktrace/alloc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Falloc.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Falloc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Falloc.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "b31fa64c798c8e4aae266fd735d5328194168133", "filename": "src/libbacktrace/atomic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fatomic.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fatomic.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fatomic.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "28488167c4e2b9f94944eebb1ae73af1c7fdcd16", "filename": "src/libbacktrace/backtrace-supported.h.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace-supported.h.in?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "4b90357df5f806f46159ec9a71ae450d4199a156", "filename": "src/libbacktrace/backtrace.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbacktrace.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "3f77093f767edc092cf8e4108f49495fc54c61b6", "filename": "src/libbacktrace/backtrace.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.h?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "a1818f1ef8311bf602e6cde217e3cac0f1dbd861", "filename": "src/libbacktrace/btest.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbtest.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbtest.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission.\n@@ -460,7 +460,7 @@ f23 (int f1line, int f2line)\n \t\t       (unsigned int) bdata.index, j + 1);\n \t      bdata.failed = 1;\n \t    }\n-\t}      \n+\t}\n \n       check (\"test3\", 0, all, f3line, \"f23\", &bdata.failed);\n       check (\"test3\", 1, all, f2line, \"f22\", &bdata.failed);"}, {"sha": "d5e08d93f6c3063f4f7e3937fa0230edd9a5275d", "filename": "src/libbacktrace/configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15153,4 +15153,3 @@ if test -n \"$ac_unrecognized_opts\" && test \"$enable_option_checking\" != no; then\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts\" >&5\n $as_echo \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2;}\n fi\n-"}, {"sha": "d661c7b2560fca6acd60cbc67c804938509004ee", "filename": "src/libbacktrace/configure.ac", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -6,13 +6,13 @@\n # met:\n \n #     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n+#     notice, this list of conditions and the following disclaimer.\n \n #     (2) Redistributions in binary form must reproduce the above copyright\n #     notice, this list of conditions and the following disclaimer in\n #     the documentation and/or other materials provided with the\n-#     distribution.  \n-    \n+#     distribution.\n+\n #     (3) The name of the author may not be used to\n #     endorse or promote products derived from this software without\n #     specific prior written permission."}, {"sha": "5ecae711792e294d2cb16c686ca163e53b1bbe2c", "filename": "src/libbacktrace/dwarf.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fdwarf.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission.\n@@ -1241,7 +1241,7 @@ add_unit_ranges (struct backtrace_state *state, uintptr_t base_address,\n \n static int\n find_address_ranges (struct backtrace_state *state, uintptr_t base_address,\n-\t\t     struct dwarf_buf *unit_buf, \n+\t\t     struct dwarf_buf *unit_buf,\n \t\t     const unsigned char *dwarf_str, size_t dwarf_str_size,\n \t\t     const unsigned char *dwarf_ranges,\n \t\t     size_t dwarf_ranges_size,\n@@ -1599,7 +1599,7 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n \n   if (!advance (line_buf, hdrlen))\n     return 0;\n-  \n+\n   hdr->min_insn_len = read_byte (&hdr_buf);\n   if (hdr->version < 4)\n     hdr->max_ops_per_insn = 1;\n@@ -1608,7 +1608,7 @@ read_line_header (struct backtrace_state *state, struct unit *u,\n \n   /* We don't care about default_is_stmt.  */\n   read_byte (&hdr_buf);\n-  \n+\n   hdr->line_base = read_sbyte (&hdr_buf);\n   hdr->line_range = read_byte (&hdr_buf);\n "}, {"sha": "5fc74add05c1814174ffdeb07842df72c9e0b1ba", "filename": "src/libbacktrace/elf.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Felf.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Felf.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "f45cccff71306f3926cc50065eeddcf6c0dbefc1", "filename": "src/libbacktrace/fileline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Ffileline.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffileline.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "3736622e67739cf97ea710b95a4fdbd66fbb9921", "filename": "src/libbacktrace/hashtab.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fhashtab.h", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fhashtab.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fhashtab.h?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1,4 +1,4 @@\n-/* An expandable hash tables datatype.  \n+/* An expandable hash tables datatype.\n    Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n@@ -61,7 +61,7 @@ typedef int (*htab_eq) (const void *, const void *);\n /* Cleanup function called whenever a live element is removed from\n    the hash table.  */\n typedef void (*htab_del) (void *);\n-  \n+\n /* Function called by htab_traverse for each live element.  The first\n    arg is the slot of the element (which can be passed to htab_clear_slot\n    if desired), the second arg is the auxiliary pointer handed to"}, {"sha": "a13c775b628737d4ffb60f15cde3b241fa27af8c", "filename": "src/libbacktrace/internal.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finternal.h?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "84f5be9249e7caae28e6c16faccaba9f84096f12", "filename": "src/libbacktrace/ltmain.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fltmain.sh?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -8633,4 +8633,3 @@ build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n # sh-indentation:2\n # End:\n # vi:sw=2\n-"}, {"sha": "1c691b02e7cfa6db80eedcf817d2d31a1d080c96", "filename": "src/libbacktrace/mmap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fmmap.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmap.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "8b8f124da9a6d729a89116ab5af0d0585c0aa7d1", "filename": "src/libbacktrace/mmapio.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fmmapio.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fmmapio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmapio.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "f8fdbdc85acb4f6c1cde3144650674cce3760231", "filename": "src/libbacktrace/nounwind.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fnounwind.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fnounwind.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fnounwind.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "7f1c35ab9707d0ce2165a7ba899fea0f3043f83c", "filename": "src/libbacktrace/posix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fposix.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fposix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fposix.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "70e347f62c290fefd8480f4436b28ffd0da1cbfc", "filename": "src/libbacktrace/print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fprint.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fprint.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fprint.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "e373b61de2e6c8c7f43c38f595ecd6e0da13fb00", "filename": "src/libbacktrace/read.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fread.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fread.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fread.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "dd70f831de74a5c5f85e5903ad9320b91de82556", "filename": "src/libbacktrace/simple.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fsimple.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fsimple.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsimple.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "bef47bd1a0f541494c1d3cdc8237261de97dea73", "filename": "src/libbacktrace/state.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fstate.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Fstate.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstate.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "e5e8421b3a994c0cbfe4a0d6163380bfab23f12d", "filename": "src/libbacktrace/unknown.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Funknown.c", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibbacktrace%2Funknown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Funknown.c?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -7,13 +7,13 @@ modification, are permitted provided that the following conditions are\n met:\n \n     (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n+    notice, this list of conditions and the following disclaimer.\n \n     (2) Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n-    distribution.  \n-    \n+    distribution.\n+\n     (3) The name of the author may not be used to\n     endorse or promote products derived from this software without\n     specific prior written permission."}, {"sha": "90fbe04d3482f9f73fbcea9d4c1d90bea4cb4207", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -133,7 +133,7 @@ static FALSE: bool = false;\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::collections::BitVec;\n ///\n /// let mut bv = BitVec::from_elem(10, false);"}, {"sha": "4bedbdeb368769a4b2565a184f4168ec85dfb0ec", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -129,7 +129,7 @@ impl<T> ToOwned for T where T: Clone {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::borrow::Cow;\n ///\n /// fn abs_all(input: &mut Cow<[i32]>) {"}, {"sha": "1deb08ad0d1c4f99a849505e4e877d634e58c6f1", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -422,7 +422,7 @@ use string;\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::fmt;\n ///\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));"}, {"sha": "4993994d46beecbbf8dafe5da007ff3eb018426f", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -136,7 +136,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [5, 4, 1, 3, 2];\n     /// v.sort_by(|a, b| a.cmp(b));\n     /// assert!(v == [1, 2, 3, 4, 5]);\n@@ -162,7 +162,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut a = [1, 2, 3, 4, 5];\n     /// let b = vec![6, 7, 8];\n     /// let num_moved = a.move_from(b, 0, 3);\n@@ -284,7 +284,7 @@ pub trait SliceExt {\n     /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n     /// `[3,4]`):\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v = &[1, 2, 3, 4];\n     /// for win in v.windows(2) {\n     ///     println!(\"{:?}\", win);\n@@ -307,7 +307,7 @@ pub trait SliceExt {\n     /// Print the slice two elements at a time (i.e. `[1,2]`,\n     /// `[3,4]`, `[5]`):\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v = &[1, 2, 3, 4, 5];\n     /// for win in v.chunks(2) {\n     ///     println!(\"{:?}\", win);\n@@ -398,7 +398,7 @@ pub trait SliceExt {\n     /// uniquely determined position; the second and third are not\n     /// found; the fourth could match any position in `[1,4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let s = s.as_slice();\n     ///\n@@ -533,7 +533,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n@@ -553,7 +553,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [1, 2, 3, 4, 5, 6];\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n@@ -582,7 +582,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [1, 2, 3];\n     /// v.reverse();\n     /// assert!(v == [3, 2, 1]);\n@@ -614,7 +614,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n@@ -625,7 +625,7 @@ pub trait SliceExt {\n     ///\n     /// Iterating through permutations one by one.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n@@ -642,7 +642,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2];\n     ///\n@@ -662,7 +662,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort();\n@@ -684,7 +684,7 @@ pub trait SliceExt {\n     /// uniquely determined position; the second and third are not\n     /// found; the fourth could match any position in `[1,4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let s = s.as_slice();\n     ///\n@@ -711,7 +711,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: &mut [_] = &mut [0, 1, 2];\n     /// v.next_permutation();\n     /// let b: &mut [_] = &mut [0, 2, 1];\n@@ -731,7 +731,7 @@ pub trait SliceExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: &mut [_] = &mut [1, 0, 2];\n     /// v.prev_permutation();\n     /// let b: &mut [_] = &mut [0, 2, 1];"}, {"sha": "b2273646b959e6fc0018ee6536cddecf1bc0a272", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -911,7 +911,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert!(\"banana\".ends_with(\"nana\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "d2bc98096f647ba258390c4fbc8317ab55286c29", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -138,7 +138,7 @@ impl String {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::str::Utf8Error;\n     ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n@@ -164,7 +164,7 @@ impl String {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let input = b\"Hello \\xF0\\x90\\x80World\";\n     /// let output = String::from_utf8_lossy(input);\n     /// assert_eq!(output, \"Hello \\u{FFFD}World\");\n@@ -296,7 +296,7 @@ impl String {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// // \ud834\udd1emusic\n     /// let mut v = &mut [0xD834, 0xDD1E, 0x006d, 0x0075,\n     ///                   0x0073, 0x0069, 0x0063];\n@@ -324,7 +324,7 @@ impl String {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// // \ud834\udd1emus<invalid>ic<invalid>\n     /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n     ///           0x0073, 0xDD1E, 0x0069, 0x0063,"}, {"sha": "404179bd4849702344f67cfc17220ed19a59ed12", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -633,7 +633,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut vec = vec!(1, 2);\n     /// vec.push(3);\n     /// assert_eq!(vec, [1, 2, 3]);\n@@ -671,7 +671,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut vec = vec![1, 2, 3];\n     /// assert_eq!(vec.pop(), Some(3));\n     /// assert_eq!(vec, [1, 2]);"}, {"sha": "aefcad49a58834b411f1dc6ee0d8423f7cdb263f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -201,7 +201,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -224,7 +224,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -258,7 +258,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -513,7 +513,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -536,7 +536,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -824,7 +824,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -849,7 +849,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -949,7 +949,7 @@ impl<T> VecDeque<T> {\n     /// Panics if `i` is greater than ringbuf's length\n     ///\n     /// # Examples\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -1151,7 +1151,7 @@ impl<T> VecDeque<T> {\n     /// Returns `None` if `i` is out of bounds.\n     ///\n     /// # Examples\n-    /// ```rust\n+    /// ```\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();"}, {"sha": "910cf805f39985b9bc809a7ad0b2dcdb186bf753", "filename": "src/libcore/default.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -164,4 +164,3 @@ default_impl! { i64, 0 }\n \n default_impl! { f32, 0.0f32 }\n default_impl! { f64, 0.0f64 }\n-"}, {"sha": "19cd34cdb0933e71f0a9470d9d6dae718146d6f2", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -107,4 +107,3 @@ impl<'a, A, F> Drop for Finallyalizer<'a, A, F> where F: FnMut(&mut A) {\n         (self.dtor)(self.mutate);\n     }\n }\n-"}, {"sha": "6dcae9879a0d0fd5da3f30e61823e1e472153327", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -216,7 +216,7 @@ macro_rules! writeln {\n ///\n /// Match arms:\n ///\n-/// ```rust\n+/// ```\n /// fn foo(x: Option<int>) {\n ///     match x {\n ///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n@@ -229,7 +229,7 @@ macro_rules! writeln {\n ///\n /// Iterators:\n ///\n-/// ```rust\n+/// ```\n /// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n ///     for i in std::iter::count(0, 1) {\n ///         if 3*i < i { panic!(\"u32 overflow\"); }"}, {"sha": "1b866501b8ea1a3d0fb62d347f1af1af990ddabf", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -310,15 +310,15 @@ impl<T:?Sized> MarkerTrait for T { }\n ///\n /// Therefore, we can model a method like this as follows:\n ///\n-/// ```rust\n+/// ```\n /// use std::marker::PhantomFn;\n /// trait Even : PhantomFn<Self> { }\n /// ```\n ///\n /// Another equivalent, but clearer, option would be to use\n /// `MarkerTrait`:\n ///\n-/// ```rust\n+/// ```\n /// use std::marker::MarkerTrait;\n /// trait Even : MarkerTrait { }\n /// ```"}, {"sha": "551f97ead12d8262f1f2f30860ea91a410e9eb74", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -251,7 +251,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n /// `self`, allowing it to be returned:\n ///\n-/// ```rust\n+/// ```\n /// use std::mem;\n /// # struct Buffer<T> { buf: Vec<T> }\n /// impl<T> Buffer<T> {"}, {"sha": "ae1b5f65eeb52575cf30acd04ecbeb1ca8ce78d9", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -281,7 +281,7 @@ impl Float for f32 {\n \n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ```rust\n+    /// ```\n     /// use core::num::Float;\n     ///\n     /// let x = 1.65f32;"}, {"sha": "4a73c1e8fcf45415849f0c0e3af32497818e35f4", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -288,7 +288,7 @@ impl Float for f64 {\n \n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ```rust\n+    /// ```\n     /// use core::num::Float;\n     ///\n     /// let x = 1.65f64;"}, {"sha": "b3adef53dabeebc8a7a03ed478fb691dd7ed28d6", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ macro_rules! assert_approx_eq {\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n }\n-"}, {"sha": "a77f97096005497034ab6c7c578d50da97dc1d84", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -84,7 +84,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0b01001100u8;\n@@ -99,7 +99,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0b01001100u8;\n@@ -118,7 +118,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0b0101000u16;\n@@ -134,7 +134,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0b0101000u16;\n@@ -150,7 +150,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -167,7 +167,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -183,7 +183,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -200,7 +200,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -223,7 +223,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -246,7 +246,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -269,7 +269,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -291,7 +291,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// assert_eq!(5u16.checked_add(65530), Some(65535));\n@@ -305,7 +305,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n@@ -319,7 +319,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// assert_eq!(5u8.checked_mul(51), Some(255));\n@@ -333,7 +333,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// assert_eq!((-127i8).checked_div(-1), Some(127));\n@@ -371,7 +371,7 @@ pub trait Int\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::num::Int;\n     ///\n     /// assert_eq!(2.pow(4), 16);"}, {"sha": "6324e8fa874439bf54d850809716a54146753534", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -78,7 +78,7 @@ use fmt;\n /// A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n /// out of scope, and therefore `main` prints `Dropping!`.\n ///\n-/// ```rust\n+/// ```\n /// struct HasDrop;\n ///\n /// impl Drop for HasDrop {\n@@ -162,7 +162,7 @@ macro_rules! forward_ref_binop {\n /// A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n /// calling `add`, and therefore, `main` prints `Adding!`.\n ///\n-/// ```rust\n+/// ```\n /// use std::ops::Add;\n ///\n /// #[derive(Copy)]\n@@ -216,7 +216,7 @@ add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n /// A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n /// calling `sub`, and therefore, `main` prints `Subtracting!`.\n ///\n-/// ```rust\n+/// ```\n /// use std::ops::Sub;\n ///\n /// #[derive(Copy)]\n@@ -270,7 +270,7 @@ sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n /// A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n /// calling `mul`, and therefore, `main` prints `Multiplying!`.\n ///\n-/// ```rust\n+/// ```\n /// use std::ops::Mul;\n ///\n /// #[derive(Copy)]"}, {"sha": "455c68d4319d670ae952fd374a0da4b307b65a4b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -897,7 +897,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Here is an example which increments every integer in a vector,\n     /// checking for overflow:\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::u16;\n     ///\n     /// let v = vec!(1, 2);"}, {"sha": "fee8caa04c47b3b7965f51f0a8eeabcb66dced8b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -896,7 +896,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Here is an example which increments every integer in a vector,\n     /// checking for overflow:\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::u32;\n     ///\n     /// let v = vec!(1, 2);"}, {"sha": "b1576c0d37739b179f77f4c0450ed0d3c714c8be", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1449,7 +1449,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::slice;\n ///\n /// // manifest a slice out of thin air!\n@@ -1492,7 +1492,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::slice;\n ///\n /// // manifest a slice out of thin air!"}, {"sha": "bd46b093b76b000177f4a4b5016ff8c6fd5e2002", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -140,7 +140,7 @@ impl FromStr for bool {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::str::FromStr;\n     ///\n     /// assert_eq!(FromStr::from_str(\"true\"), Ok(true));\n@@ -151,7 +151,7 @@ impl FromStr for bool {\n     /// Note, in many cases, the StrExt::parse() which is based on\n     /// this FromStr::from_str() is more proper.\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"true\".parse(), Ok(true));\n     /// assert_eq!(\"false\".parse(), Ok(false));\n     /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n@@ -1186,7 +1186,7 @@ mod traits {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// assert_eq!(&s[0 .. 1], \"L\");\n     ///"}, {"sha": "c99fb8c197d834bb7815910085b729cf2870777f", "filename": "src/libcoretest/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcoretest%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibcoretest%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fintrinsics.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -28,4 +28,3 @@ fn test_typeid_unsized_types() {\n     assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());\n     assert!(TypeId::of::<X>() != TypeId::of::<Y>());\n }\n-"}, {"sha": "695c71c73eded0f14773c417e8659fb1806c5d74", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -25,7 +25,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(staged_api)]\n #![feature(unique)]\n@@ -35,13 +34,33 @@\n extern crate libc;\n \n use libc::{c_void, size_t, c_int};\n+use std::fmt;\n use std::ops::Deref;\n use std::ptr::Unique;\n use std::slice;\n \n+#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub struct Error {\n+    _unused: (),\n+}\n+\n+impl Error {\n+    fn new() -> Error {\n+        Error {\n+            _unused: (),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"decompression error\".fmt(f)\n+    }\n+}\n+\n pub struct Bytes {\n     ptr: Unique<u8>,\n-    len: uint,\n+    len: usize,\n }\n \n impl Deref for Bytes {\n@@ -78,55 +97,56 @@ const LZ_NORM: c_int = 0x80;  // LZ with 128 probes, \"normal\"\n const TINFL_FLAG_PARSE_ZLIB_HEADER: c_int = 0x1; // parse zlib header and adler32 checksum\n const TDEFL_WRITE_ZLIB_HEADER: c_int = 0x01000; // write zlib header and adler32 checksum\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n+fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Bytes {\n     unsafe {\n-        let mut outsz : size_t = 0;\n+        let mut outsz: size_t = 0;\n         let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n                                              bytes.len() as size_t,\n                                              &mut outsz,\n                                              flags);\n-        if !res.is_null() {\n-            let res = Unique::new(res as *mut u8);\n-            Some(Bytes { ptr: res, len: outsz as uint })\n-        } else {\n-            None\n+        assert!(!res.is_null());\n+        Bytes {\n+            ptr: Unique::new(res as *mut u8),\n+            len: outsz as usize,\n         }\n     }\n }\n \n /// Compress a buffer, without writing any sort of header on the output.\n-pub fn deflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n+pub fn deflate_bytes(bytes: &[u8]) -> Bytes {\n     deflate_bytes_internal(bytes, LZ_NORM)\n }\n \n /// Compress a buffer, using a header that zlib can understand.\n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n+pub fn deflate_bytes_zlib(bytes: &[u8]) -> Bytes {\n     deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n }\n \n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<Bytes> {\n+fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Result<Bytes,Error> {\n     unsafe {\n-        let mut outsz : size_t = 0;\n+        let mut outsz: size_t = 0;\n         let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n                                                bytes.len() as size_t,\n                                                &mut outsz,\n                                                flags);\n         if !res.is_null() {\n-            let res = Unique::new(res as *mut u8);\n-            Some(Bytes { ptr: res, len: outsz as uint })\n+            Ok(Bytes {\n+                ptr: Unique::new(res as *mut u8),\n+                len: outsz as usize,\n+            })\n         } else {\n-            None\n+            Err(Error::new())\n         }\n     }\n }\n \n /// Decompress a buffer, without parsing any sort of header on the input.\n-pub fn inflate_bytes(bytes: &[u8]) -> Option<Bytes> {\n+pub fn inflate_bytes(bytes: &[u8]) -> Result<Bytes,Error> {\n     inflate_bytes_internal(bytes, 0)\n }\n \n /// Decompress a buffer that starts with a zlib header.\n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<Bytes> {\n+pub fn inflate_bytes_zlib(bytes: &[u8]) -> Result<Bytes,Error> {\n     inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n }\n \n@@ -140,7 +160,7 @@ mod tests {\n     #[test]\n     fn test_flate_round_trip() {\n         let mut r = rand::thread_rng();\n-        let mut words = vec!();\n+        let mut words = vec![];\n         for _ in 0..20 {\n             let range = r.gen_range(1, 10);\n             let v = r.gen_iter::<u8>().take(range).collect::<Vec<u8>>();\n@@ -153,8 +173,8 @@ mod tests {\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n-            let cmp = deflate_bytes(&input).expect(\"deflation failed\");\n-            let out = inflate_bytes(&cmp).expect(\"inflation failed\");\n+            let cmp = deflate_bytes(&input);\n+            let out = inflate_bytes(&cmp).unwrap();\n             debug!(\"{} bytes deflated to {} ({:.1}% size)\",\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n@@ -164,9 +184,9 @@ mod tests {\n \n     #[test]\n     fn test_zlib_flate() {\n-        let bytes = vec!(1, 2, 3, 4, 5);\n-        let deflated = deflate_bytes(&bytes).expect(\"deflation failed\");\n-        let inflated = inflate_bytes(&deflated).expect(\"inflation failed\");\n+        let bytes = vec![1, 2, 3, 4, 5];\n+        let deflated = deflate_bytes(&bytes);\n+        let inflated = inflate_bytes(&deflated).unwrap();\n         assert_eq!(&*inflated, &*bytes);\n     }\n }"}, {"sha": "82c54004e99752a25fce167bac6a9fd930104d11", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -3298,7 +3298,7 @@ pub mod consts {\n             pub const MAP_DENYWRITE : c_int = 0x0800;\n             pub const MAP_EXECUTABLE : c_int = 0x01000;\n             pub const MAP_LOCKED : c_int = 0x02000;\n-            pub const MAP_NONRESERVE : c_int = 0x04000;\n+            pub const MAP_NORESERVE : c_int = 0x04000;\n             pub const MAP_POPULATE : c_int = 0x08000;\n             pub const MAP_NONBLOCK : c_int = 0x010000;\n             pub const MAP_STACK : c_int = 0x020000;\n@@ -3325,7 +3325,7 @@ pub mod consts {\n             pub const MAP_DENYWRITE : c_int = 0x02000;\n             pub const MAP_EXECUTABLE : c_int = 0x04000;\n             pub const MAP_LOCKED : c_int = 0x08000;\n-            pub const MAP_NONRESERVE : c_int = 0x0400;\n+            pub const MAP_NORESERVE : c_int = 0x0400;\n             pub const MAP_POPULATE : c_int = 0x010000;\n             pub const MAP_NONBLOCK : c_int = 0x020000;\n             pub const MAP_STACK : c_int = 0x040000;"}, {"sha": "c634a46888e56e5d5529a0d061a244f3030849de", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -175,7 +175,6 @@\n #![feature(int_uint)]\n #![feature(core)]\n #![feature(std_misc)]\n-#![feature(io)]\n \n use std::boxed;\n use std::cell::RefCell;"}, {"sha": "80eb1601035a89c20faa3357541a3cd412d5947c", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -197,4 +197,3 @@ macro_rules! log_enabled {\n         ::log::mod_enabled(lvl, module_path!())\n     })\n }\n-"}, {"sha": "3180f03cfd3c2ee2d4c60efb78c8d8591a2e1c69", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -59,7 +59,7 @@ impl Rand for Exp1 {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{Exp, IndependentSample};\n ///"}, {"sha": "8eaac203fb4ad22ffdfbc3e1c40dfdc18bdf1e45", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -39,7 +39,7 @@ use super::{IndependentSample, Sample, Exp};\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{IndependentSample, Gamma};\n ///\n@@ -186,7 +186,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{ChiSquared, IndependentSample};\n ///\n@@ -243,7 +243,7 @@ impl IndependentSample<f64> for ChiSquared {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{FisherF, IndependentSample};\n ///\n@@ -287,7 +287,7 @@ impl IndependentSample<f64> for FisherF {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{StudentT, IndependentSample};\n ///"}, {"sha": "a46709932e2de72afe7f6fa11b68a3ab31d6bd31", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -93,7 +93,7 @@ pub struct Weighted<T> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{Weighted, WeightedChoice, IndependentSample};\n ///"}, {"sha": "d07964624bf582e94941d0800dcc4aee7d3db9fb", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -75,7 +75,7 @@ impl Rand for StandardNormal {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{Normal, IndependentSample};\n ///\n@@ -123,7 +123,7 @@ impl IndependentSample<f64> for Normal {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n /// use std::rand::distributions::{LogNormal, IndependentSample};\n ///"}, {"sha": "4086e149e7866fee68b6e4143257eba4ba68cc8b", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -35,7 +35,7 @@ use distributions::{Sample, IndependentSample};\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand::distributions::{IndependentSample, Range};\n ///\n /// fn main() {"}, {"sha": "5e52a176c9e16db2a344629d5adb9a4c3d74fcd8", "filename": "src/librand/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -148,7 +148,7 @@ pub trait Rng : Sized {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut v = [0; 13579];\n@@ -183,7 +183,7 @@ pub trait Rng : Sized {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -228,7 +228,7 @@ pub trait Rng : Sized {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -246,7 +246,7 @@ pub trait Rng : Sized {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -260,7 +260,7 @@ pub trait Rng : Sized {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let s: String = thread_rng().gen_ascii_chars().take(10).collect();\n@@ -296,7 +296,7 @@ pub trait Rng : Sized {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -359,7 +359,7 @@ pub trait SeedableRng<Seed>: Rng {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n     /// let seed: &[_] = &[1, 2, 3, 4];\n@@ -374,7 +374,7 @@ pub trait SeedableRng<Seed>: Rng {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n     /// let seed: &[_] = &[1, 2, 3, 4];\n@@ -478,7 +478,8 @@ impl Rand for XorShiftRng {\n /// `[0,1)`.\n ///\n /// # Examples\n-/// ```rust\n+///\n+/// ```\n /// use std::rand::{random, Open01};\n ///\n /// let Open01(val) = random::<Open01<f32>>();\n@@ -495,7 +496,7 @@ pub struct Open01<F>(pub F);\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand::{random, Closed01};\n ///\n /// let Closed01(val) = random::<Closed01<f32>>();"}, {"sha": "81e65da37fc5f34701cda91c16a612aaccccf607", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -102,7 +102,7 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R> + Default>\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand::{Rng, SeedableRng, StdRng};\n /// use std::rand::reseeding::{Reseeder, ReseedingRng};\n ///"}, {"sha": "9b364768208ebfabbb333cdf84d36b7b697af1fb", "filename": "src/librustc/README.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.txt?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -40,7 +40,7 @@ crates is preferable):\n   driver that orchestrates all the other passes and various other bits\n   of miscellany. In general it contains code that runs towards the\n   end of the compilation process.\n-  \n+\n Roughly speaking the \"order\" of the three crates is as follows:\n \n     libsyntax -> librustc -> librustc_trans"}, {"sha": "70303bb3410b71cbdbc61c19d4a76cd8eeb8e38b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -132,4 +132,3 @@ register_diagnostics! {\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }\n-"}, {"sha": "e466dc8a3a0181db8a7a3b99983fdffe748e5ea4", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -784,8 +784,8 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                        csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n-                    Some(inflated) => return Ok(MetadataVec(inflated)),\n-                    None => {}\n+                    Ok(inflated) => return Ok(MetadataVec(inflated)),\n+                    Err(_) => {}\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);"}, {"sha": "d1a946d933f142fae19c0b351a437475f4c3b564", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -963,4 +963,3 @@ fn parse_region_bounds_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n         }\n     }\n }\n-"}, {"sha": "ac6524dad805792385953260aac1d9c850ed84ec", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -124,4 +124,3 @@ impl<'a, 'ast> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast>\n     fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.source(edge) }\n     fn target(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.target(edge) }\n }\n-"}, {"sha": "f9bdc5dc313f4af4ca8a6f99ebf5fbf45d91c653", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -96,4 +96,3 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_infer(_) | ty::ty_err => None,\n     }\n }\n-"}, {"sha": "b9025d01068cc9fc76c2cb7eeb011ad5ea807cc6", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -112,4 +112,3 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n         }\n     }\n }\n-"}, {"sha": "a92c960cd3aa14906aa01729c2e9babf29f013d5", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -153,4 +153,3 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         self.higher_ranked_sub(a, b)\n     }\n }\n-"}, {"sha": "a57ea3759de9b3bb2967be9670ab164b3f2ed0c7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1635,4 +1635,3 @@ impl<'tcx> UserString<'tcx> for Upvar {\n         format!(\"captured outer variable in an `{}` closure\", kind)\n     }\n }\n-"}, {"sha": "6b66d7227d300d00ca6e4280ebf7ea778b69d18c", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -535,7 +535,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n /// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n /// that the definition of `Foo` has some clues:\n ///\n-/// ```rust\n+/// ```\n /// trait Foo {\n ///     type FooT : Bar<BarT=i32>\n /// }"}, {"sha": "88b721ce958622c7b345dbe53c7c88b9e1b389b4", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -568,5 +568,3 @@ impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n         write!(f, \"MismatchedProjectionTypes(..)\")\n     }\n }\n-\n-"}, {"sha": "1069d1282eab1e9f5b37ab7998f3d6bf7f3823b3", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> TypeWalker<'tcx> {\n     ///\n     /// Example: Imagine you are walking `Foo<Bar<int>, uint>`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut iter: TypeWalker = ...;\n     /// iter.next(); // yields Foo\n     /// iter.next(); // yields Bar<int>"}, {"sha": "aec8ac38a5ad3a48fc94aff7b690e14c32576621", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -324,4 +324,3 @@ impl<'a> ArchiveBuilder<'a> {\n         Ok(())\n     }\n }\n-"}, {"sha": "a56621ff97ea541cba2cd0e500a2ce471d4ef5d1", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -32,4 +32,3 @@ pub fn opts() -> TargetOptions {\n         .. Default::default()\n     }\n }\n-"}, {"sha": "dcf1a12f2c9ad762dd6f1b84cc0227e473d88c9b", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -27,4 +27,3 @@ pub fn opts() -> TargetOptions {\n         .. Default::default()\n     }\n }\n-"}, {"sha": "0f2ab32be2431e059a37eeec09adb539ba7bbcef", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -30,4 +30,3 @@ pub fn opts() -> TargetOptions {\n         .. Default::default()\n     }\n }\n-"}, {"sha": "e62300098f678bb6d26d8d80b2a2c8f06a40b5b7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -14,16 +14,17 @@\n //! any imports resolved.\n \n use {DefModifiers, PUBLIC, IMPORTABLE};\n-use ImportDirective;\n-use ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use ImportResolution;\n+use resolve_imports::ImportDirective;\n+use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n+use resolve_imports::ImportResolution;\n use Module;\n use ModuleKind::*;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n+use {names_to_string, module_to_string};\n use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n-use Shadowable;\n+use resolve_imports::Shadowable;\n use TypeNsDef;\n \n use self::DuplicateCheckingMode::*;\n@@ -371,8 +372,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n             ItemExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(item.id).iter() {\n+                if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     let def_id = DefId { krate: crate_id, node: 0 };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent.downgrade(), name);\n@@ -382,7 +382,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                               false,\n                                                               true));\n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n+                            module_to_string(&*external_module));\n                     self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n                     parent.external_module_children.borrow_mut()\n                           .insert(name, external_module.clone());\n@@ -400,7 +400,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             Some(def_id),\n                                             NormalModuleKind,\n                                             false,\n-                                            item.vis == ast::Public,\n+                                            is_public,\n                                             sp);\n \n                 name_bindings.get_module()\n@@ -432,8 +432,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let name_bindings =\n-                    self.add_child(name, parent, ForbidDuplicateTypesAndModules,\n-                                   sp);\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n                 name_bindings.define_type(DefTy(local_def(item.id), false), sp,\n                                           modifiers);\n@@ -517,7 +516,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             Some(local_def(item.id)),\n                                             TraitModuleKind,\n                                             false,\n-                                            item.vis == ast::Public,\n+                                            is_public,\n                                             sp);\n                 let module_parent = name_bindings.get_module();\n \n@@ -636,8 +635,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                            name: Name,\n                            new_parent: &Rc<Module>) {\n         debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {:?}\",\n-               vis);\n+                external crate) building external def {}, priv {:?}\",\n+               final_ident, vis);\n         let is_public = vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let is_exported = is_public && match new_parent.def_id.get() {\n@@ -667,7 +666,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n               Some(_) | None => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n-                        {}\", final_ident);\n+                        {} {}\", final_ident, is_public);\n                 let parent_link = self.get_parent_link(new_parent, name);\n \n                 child_name_bindings.define_module(parent_link,\n@@ -838,7 +837,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Builds the reduced graph rooted at the given external module.\n     fn populate_external_module(&mut self, module: &Rc<Module>) {\n         debug!(\"(populating external module) attempting to populate {}\",\n-               self.module_to_string(&**module));\n+               module_to_string(&**module));\n \n         let def_id = match module.def_id.get() {\n             None => {\n@@ -904,18 +903,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         match subclass {\n             SingleImport(target, _) => {\n-                debug!(\"(building import directive) building import \\\n-                        directive: {}::{}\",\n-                       self.names_to_string(&module_.imports.borrow().last().unwrap().\n-                                                             module_path),\n+                debug!(\"(building import directive) building import directive: {}::{}\",\n+                       names_to_string(&module_.imports.borrow().last().unwrap().module_path),\n                        token::get_name(target));\n \n-                let mut import_resolutions = module_.import_resolutions\n-                                                    .borrow_mut();\n+                let mut import_resolutions = module_.import_resolutions.borrow_mut();\n                 match import_resolutions.get_mut(&target) {\n                     Some(resolution) => {\n-                        debug!(\"(building import directive) bumping \\\n-                                reference\");\n+                        debug!(\"(building import directive) bumping reference\");\n                         resolution.outstanding_references += 1;\n \n                         // the source of this name is different now"}, {"sha": "c586faae6e886dd32f5c398085c401904fe3fa41", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -24,7 +24,9 @@ register_diagnostics! {\n     E0258, // import conflicts with existing submodule\n     E0259, // an extern crate has already been imported into this module\n     E0260, // name conflicts with an external crate that has been imported into this module\n-    E0317 // user-defined types or type parameters cannot shadow the primitive types\n+    E0317, // user-defined types or type parameters cannot shadow the primitive types\n+    E0364, // item is private\n+    E0365  // item is private\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "67e9f71551a22ed57a556a2b24c201cefa4f0904", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 98, "deletions": 1043, "changes": 1141, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -38,7 +38,6 @@ use self::PatternBindingMode::*;\n use self::Namespace::*;\n use self::NamespaceResult::*;\n use self::NameDefinition::*;\n-use self::ImportDirectiveSubclass::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n@@ -98,13 +97,18 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::usize;\n \n+use resolve_imports::{Target, ImportDirective, ImportResolution};\n+use resolve_imports::Shadowable;\n+\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n \n mod check_unused;\n mod record_exports;\n mod build_reduced_graph;\n+mod resolve_imports;\n \n #[derive(Copy)]\n struct BindingInfo {\n@@ -253,13 +257,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     }\n }\n \n-/// Contains data for specific types of import directives.\n-#[derive(Copy,Debug)]\n-enum ImportDirectiveSubclass {\n-    SingleImport(Name /* target */, Name /* source */),\n-    GlobImport\n-}\n-\n type ErrorMessage = Option<(Span, String)>;\n \n enum ResolveResult<T> {\n@@ -366,144 +363,6 @@ impl Rib {\n     }\n }\n \n-/// Whether an import can be shadowed by another import.\n-#[derive(Debug,PartialEq,Clone,Copy)]\n-enum Shadowable {\n-    Always,\n-    Never\n-}\n-\n-/// One import directive.\n-#[derive(Debug)]\n-struct ImportDirective {\n-    module_path: Vec<Name>,\n-    subclass: ImportDirectiveSubclass,\n-    span: Span,\n-    id: NodeId,\n-    is_public: bool, // see note in ImportResolution about how to use this\n-    shadowable: Shadowable,\n-}\n-\n-impl ImportDirective {\n-    fn new(module_path: Vec<Name> ,\n-           subclass: ImportDirectiveSubclass,\n-           span: Span,\n-           id: NodeId,\n-           is_public: bool,\n-           shadowable: Shadowable)\n-           -> ImportDirective {\n-        ImportDirective {\n-            module_path: module_path,\n-            subclass: subclass,\n-            span: span,\n-            id: id,\n-            is_public: is_public,\n-            shadowable: shadowable,\n-        }\n-    }\n-}\n-\n-/// The item that an import resolves to.\n-#[derive(Clone,Debug)]\n-struct Target {\n-    target_module: Rc<Module>,\n-    bindings: Rc<NameBindings>,\n-    shadowable: Shadowable,\n-}\n-\n-impl Target {\n-    fn new(target_module: Rc<Module>,\n-           bindings: Rc<NameBindings>,\n-           shadowable: Shadowable)\n-           -> Target {\n-        Target {\n-            target_module: target_module,\n-            bindings: bindings,\n-            shadowable: shadowable,\n-        }\n-    }\n-}\n-\n-/// An ImportResolution represents a particular `use` directive.\n-#[derive(Debug)]\n-struct ImportResolution {\n-    /// Whether this resolution came from a `use` or a `pub use`. Note that this\n-    /// should *not* be used whenever resolution is being performed, this is\n-    /// only looked at for glob imports statements currently. Privacy testing\n-    /// occurs during a later phase of compilation.\n-    is_public: bool,\n-\n-    // The number of outstanding references to this name. When this reaches\n-    // zero, outside modules can count on the targets being correct. Before\n-    // then, all bets are off; future imports could override this name.\n-    outstanding_references: uint,\n-\n-    /// The value that this `use` directive names, if there is one.\n-    value_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the value target\n-    /// being non-none\n-    value_id: NodeId,\n-\n-    /// The type that this `use` directive names, if there is one.\n-    type_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the type target\n-    /// being non-none\n-    type_id: NodeId,\n-}\n-\n-impl ImportResolution {\n-    fn new(id: NodeId, is_public: bool) -> ImportResolution {\n-        ImportResolution {\n-            type_id: id,\n-            value_id: id,\n-            outstanding_references: 0,\n-            value_target: None,\n-            type_target: None,\n-            is_public: is_public,\n-        }\n-    }\n-\n-    fn target_for_namespace(&self, namespace: Namespace)\n-                                -> Option<Target> {\n-        match namespace {\n-            TypeNS  => self.type_target.clone(),\n-            ValueNS => self.value_target.clone(),\n-        }\n-    }\n-\n-    fn id(&self, namespace: Namespace) -> NodeId {\n-        match namespace {\n-            TypeNS  => self.type_id,\n-            ValueNS => self.value_id,\n-        }\n-    }\n-\n-    fn shadowable(&self, namespace: Namespace) -> Shadowable {\n-        let target = self.target_for_namespace(namespace);\n-        if target.is_none() {\n-            return Shadowable::Always;\n-        }\n-\n-        target.unwrap().shadowable\n-    }\n-\n-    fn set_target_and_id(&mut self,\n-                         namespace: Namespace,\n-                         target: Option<Target>,\n-                         id: NodeId) {\n-        match namespace {\n-            TypeNS  => {\n-                self.type_target = target;\n-                self.type_id = id;\n-            }\n-            ValueNS => {\n-                self.value_target = target;\n-                self.value_id = id;\n-            }\n-        }\n-    }\n-}\n-\n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n enum ParentLink {\n@@ -855,6 +714,19 @@ impl NameBindings {\n             None\n         }\n     }\n+\n+    fn is_public(&self, namespace: Namespace) -> bool {\n+        match namespace {\n+            TypeNS  => {\n+                let type_def = self.type_def.borrow();\n+                type_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+            }\n+            ValueNS => {\n+                let value_def = self.value_def.borrow();\n+                value_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+            }\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -963,7 +835,6 @@ enum FallbackChecks {\n     OnlyTraitAndStatics\n }\n \n-\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n            ast_map: &'a ast_map::Map<'tcx>,\n@@ -1023,151 +894,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    // Import resolution\n-    //\n-    // This is a fixed-point algorithm. We resolve imports until our efforts\n-    // are stymied by an unresolved import; then we bail out of the current\n-    // module and continue. We terminate successfully once no more imports\n-    // remain or unsuccessfully when no forward progress in resolving imports\n-    // is made.\n-\n-    /// Resolves all imports for the crate. This method performs the fixed-\n-    /// point iteration.\n-    fn resolve_imports(&mut self) {\n-        let mut i = 0;\n-        let mut prev_unresolved_imports = 0;\n-        loop {\n-            debug!(\"(resolving imports) iteration {}, {} imports left\",\n-                   i, self.unresolved_imports);\n-\n-            let module_root = self.graph_root.get_module();\n-            self.resolve_imports_for_module_subtree(module_root.clone());\n-\n-            if self.unresolved_imports == 0 {\n-                debug!(\"(resolving imports) success\");\n-                break;\n-            }\n-\n-            if self.unresolved_imports == prev_unresolved_imports {\n-                self.report_unresolved_imports(module_root);\n-                break;\n-            }\n-\n-            i += 1;\n-            prev_unresolved_imports = self.unresolved_imports;\n-        }\n-    }\n-\n-    /// Attempts to resolve imports for the given module and all of its\n-    /// submodules.\n-    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n-        debug!(\"(resolving imports for module subtree) resolving {}\",\n-               self.module_to_string(&*module_));\n-        let orig_module = replace(&mut self.current_module, module_.clone());\n-        self.resolve_imports_for_module(module_.clone());\n-        self.current_module = orig_module;\n-\n-        build_reduced_graph::populate_module_if_necessary(self, &module_);\n-        for (_, child_node) in &*module_.children.borrow() {\n-            match child_node.get_module_if_available() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    self.resolve_imports_for_module_subtree(child_module);\n-                }\n-            }\n-        }\n-\n-        for (_, child_module) in &*module_.anonymous_children.borrow() {\n-            self.resolve_imports_for_module_subtree(child_module.clone());\n-        }\n-    }\n-\n-    /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self, module: Rc<Module>) {\n-        if module.all_imports_resolved() {\n-            debug!(\"(resolving imports for module) all imports resolved for \\\n-                   {}\",\n-                   self.module_to_string(&*module));\n-            return;\n-        }\n-\n-        let imports = module.imports.borrow();\n-        let import_count = imports.len();\n-        while module.resolved_import_count.get() < import_count {\n-            let import_index = module.resolved_import_count.get();\n-            let import_directive = &(*imports)[import_index];\n-            match self.resolve_import_for_module(module.clone(),\n-                                                 import_directive) {\n-                Failed(err) => {\n-                    let (span, help) = match err {\n-                        Some((span, msg)) => (span, format!(\". {}\", msg)),\n-                        None => (import_directive.span, String::new())\n-                    };\n-                    let msg = format!(\"unresolved import `{}`{}\",\n-                                      self.import_path_to_string(\n-                                          &import_directive.module_path,\n-                                          import_directive.subclass),\n-                                      help);\n-                    self.resolve_error(span, &msg[..]);\n-                }\n-                Indeterminate => break, // Bail out. We'll come around next time.\n-                Success(()) => () // Good. Continue.\n-            }\n-\n-            module.resolved_import_count\n-                  .set(module.resolved_import_count.get() + 1);\n-        }\n-    }\n-\n-    fn names_to_string(&self, names: &[Name]) -> String {\n-        let mut first = true;\n-        let mut result = String::new();\n-        for name in names {\n-            if first {\n-                first = false\n-            } else {\n-                result.push_str(\"::\")\n-            }\n-            result.push_str(&token::get_name(*name));\n-        };\n-        result\n-    }\n-\n-    fn path_names_to_string(&self, path: &Path, depth: usize) -> String {\n-        let names: Vec<ast::Name> = path.segments[..path.segments.len()-depth]\n-                                        .iter()\n-                                        .map(|seg| seg.identifier.name)\n-                                        .collect();\n-        self.names_to_string(&names[..])\n-    }\n-\n-    fn import_directive_subclass_to_string(&mut self,\n-                                        subclass: ImportDirectiveSubclass)\n-                                        -> String {\n-        match subclass {\n-            SingleImport(_, source) => {\n-                token::get_name(source).to_string()\n-            }\n-            GlobImport => \"*\".to_string()\n-        }\n-    }\n-\n-    fn import_path_to_string(&mut self,\n-                          names: &[Name],\n-                          subclass: ImportDirectiveSubclass)\n-                          -> String {\n-        if names.is_empty() {\n-            self.import_directive_subclass_to_string(subclass)\n-        } else {\n-            (format!(\"{}::{}\",\n-                     self.names_to_string(names),\n-                     self.import_directive_subclass_to_string(\n-                         subclass))).to_string()\n-        }\n-    }\n-\n     #[inline]\n     fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n         if !self.make_glob_map {\n@@ -1191,102 +917,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    /// Attempts to resolve the given import. The return value indicates\n-    /// failure if we're certain the name does not exist, indeterminate if we\n-    /// don't know whether the name exists at the moment due to other\n-    /// currently-unresolved imports, or success if we know the name exists.\n-    /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import_for_module(&mut self,\n-                                 module_: Rc<Module>,\n-                                 import_directive: &ImportDirective)\n-                                 -> ResolveResult<()> {\n-        let mut resolution_result = Failed(None);\n-        let module_path = &import_directive.module_path;\n-\n-        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(&module_path[..]),\n-               self.module_to_string(&*module_));\n-\n-        // First, resolve the module path for the directive, if necessary.\n-        let container = if module_path.len() == 0 {\n-            // Use the crate root.\n-            Some((self.graph_root.get_module(), LastMod(AllPublic)))\n-        } else {\n-            match self.resolve_module_path(module_.clone(),\n-                                           &module_path[..],\n-                                           DontUseLexicalScope,\n-                                           import_directive.span,\n-                                           ImportSearch) {\n-                Failed(err) => {\n-                    resolution_result = Failed(err);\n-                    None\n-                },\n-                Indeterminate => {\n-                    resolution_result = Indeterminate;\n-                    None\n-                }\n-                Success(container) => Some(container),\n-            }\n-        };\n-\n-        match container {\n-            None => {}\n-            Some((containing_module, lp)) => {\n-                // We found the module that the target is contained\n-                // within. Attempt to resolve the import within it.\n-\n-                match import_directive.subclass {\n-                    SingleImport(target, source) => {\n-                        resolution_result =\n-                            self.resolve_single_import(&*module_,\n-                                                       containing_module,\n-                                                       target,\n-                                                       source,\n-                                                       import_directive,\n-                                                       lp);\n-                    }\n-                    GlobImport => {\n-                        resolution_result =\n-                            self.resolve_glob_import(&*module_,\n-                                                     containing_module,\n-                                                     import_directive,\n-                                                     lp);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Decrement the count of unresolved imports.\n-        match resolution_result {\n-            Success(()) => {\n-                assert!(self.unresolved_imports >= 1);\n-                self.unresolved_imports -= 1;\n-            }\n-            _ => {\n-                // Nothing to do here; just return the error.\n-            }\n-        }\n-\n-        // Decrement the count of unresolved globs if necessary. But only if\n-        // the resolution result is indeterminate -- otherwise we'll stop\n-        // processing imports here. (See the loop in\n-        // resolve_imports_for_module.)\n-\n-        if !resolution_result.indeterminate() {\n-            match import_directive.subclass {\n-                GlobImport => {\n-                    assert!(module_.glob_count.get() >= 1);\n-                    module_.glob_count.set(module_.glob_count.get() - 1);\n-                }\n-                SingleImport(..) => {\n-                    // Ignore.\n-                }\n-            }\n-        }\n-\n-        return resolution_result;\n-    }\n-\n     fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n         NameBindings {\n             type_def: RefCell::new(Some(TypeNsDef {\n@@ -1299,604 +929,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn resolve_single_import(&mut self,\n-                             module_: &Module,\n-                             containing_module: Rc<Module>,\n-                             target: Name,\n-                             source: Name,\n-                             directive: &ImportDirective,\n-                             lp: LastPrivate)\n-                                 -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n-                `{}` id {}, last private {:?}\",\n-               token::get_name(target),\n-               self.module_to_string(&*containing_module),\n-               token::get_name(source),\n-               self.module_to_string(module_),\n-               directive.id,\n-               lp);\n-\n-        let lp = match lp {\n-            LastMod(lp) => lp,\n-            LastImport {..} => {\n-                self.session\n-                    .span_bug(directive.span,\n-                              \"not expecting Import here, must be LastMod\")\n-            }\n-        };\n-\n-        // We need to resolve both namespaces for this to succeed.\n-        //\n-\n-        let mut value_result = UnknownResult;\n-        let mut type_result = UnknownResult;\n-\n-        // Search for direct children of the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n-\n-        match containing_module.children.borrow().get(&source) {\n-            None => {\n-                // Continue.\n-            }\n-            Some(ref child_name_bindings) => {\n-                if child_name_bindings.defined_in_namespace(ValueNS) {\n-                    debug!(\"(resolving single import) found value binding\");\n-                    value_result = BoundResult(containing_module.clone(),\n-                                               (*child_name_bindings).clone());\n-                }\n-                if child_name_bindings.defined_in_namespace(TypeNS) {\n-                    debug!(\"(resolving single import) found type binding\");\n-                    type_result = BoundResult(containing_module.clone(),\n-                                              (*child_name_bindings).clone());\n-                }\n-            }\n-        }\n-\n-        // Unless we managed to find a result in both namespaces (unlikely),\n-        // search imports as well.\n-        let mut value_used_reexport = false;\n-        let mut type_used_reexport = false;\n-        match (value_result.clone(), type_result.clone()) {\n-            (BoundResult(..), BoundResult(..)) => {} // Continue.\n-            _ => {\n-                // If there is an unresolved glob at this point in the\n-                // containing module, bail out. We don't know enough to be\n-                // able to resolve this import.\n-\n-                if containing_module.glob_count.get() > 0 {\n-                    debug!(\"(resolving single import) unresolved glob; \\\n-                            bailing out\");\n-                    return Indeterminate;\n-                }\n-\n-                // Now search the exported imports within the containing module.\n-                match containing_module.import_resolutions.borrow().get(&source) {\n-                    None => {\n-                        debug!(\"(resolving single import) no import\");\n-                        // The containing module definitely doesn't have an\n-                        // exported import with the name in question. We can\n-                        // therefore accurately report that the names are\n-                        // unbound.\n-\n-                        if value_result.is_unknown() {\n-                            value_result = UnboundResult;\n-                        }\n-                        if type_result.is_unknown() {\n-                            type_result = UnboundResult;\n-                        }\n-                    }\n-                    Some(import_resolution)\n-                            if import_resolution.outstanding_references == 0 => {\n-\n-                        fn get_binding(this: &mut Resolver,\n-                                       import_resolution: &ImportResolution,\n-                                       namespace: Namespace,\n-                                       source: &Name)\n-                                    -> NamespaceResult {\n-\n-                            // Import resolutions must be declared with \"pub\"\n-                            // in order to be exported.\n-                            if !import_resolution.is_public {\n-                                return UnboundResult;\n-                            }\n-\n-                            match import_resolution.\n-                                    target_for_namespace(namespace) {\n-                                None => {\n-                                    return UnboundResult;\n-                                }\n-                                Some(Target {\n-                                    target_module,\n-                                    bindings,\n-                                    shadowable: _\n-                                }) => {\n-                                    debug!(\"(resolving single import) found \\\n-                                            import in ns {:?}\", namespace);\n-                                    let id = import_resolution.id(namespace);\n-                                    // track used imports and extern crates as well\n-                                    this.used_imports.insert((id, namespace));\n-                                    this.record_import_use(id, *source);\n-                                    match target_module.def_id.get() {\n-                                        Some(DefId{krate: kid, ..}) => {\n-                                            this.used_crates.insert(kid);\n-                                        },\n-                                        _ => {}\n-                                    }\n-                                    return BoundResult(target_module, bindings);\n-                                }\n-                            }\n-                        }\n-\n-                        // The name is an import which has been fully\n-                        // resolved. We can, therefore, just follow it.\n-                        if value_result.is_unknown() {\n-                            value_result = get_binding(self,\n-                                                       import_resolution,\n-                                                       ValueNS,\n-                                                       &source);\n-                            value_used_reexport = import_resolution.is_public;\n-                        }\n-                        if type_result.is_unknown() {\n-                            type_result = get_binding(self,\n-                                                      import_resolution,\n-                                                      TypeNS,\n-                                                      &source);\n-                            type_used_reexport = import_resolution.is_public;\n-                        }\n-\n-                    }\n-                    Some(_) => {\n-                        // If containing_module is the same module whose import we are resolving\n-                        // and there it has an unresolved import with the same name as `source`,\n-                        // then the user is actually trying to import an item that is declared\n-                        // in the same scope\n-                        //\n-                        // e.g\n-                        // use self::submodule;\n-                        // pub mod submodule;\n-                        //\n-                        // In this case we continue as if we resolved the import and let the\n-                        // check_for_conflicts_between_imports_and_items call below handle\n-                        // the conflict\n-                        match (module_.def_id.get(),  containing_module.def_id.get()) {\n-                            (Some(id1), Some(id2)) if id1 == id2  => {\n-                                if value_result.is_unknown() {\n-                                    value_result = UnboundResult;\n-                                }\n-                                if type_result.is_unknown() {\n-                                    type_result = UnboundResult;\n-                                }\n-                            }\n-                            _ =>  {\n-                                // The import is unresolved. Bail out.\n-                                debug!(\"(resolving single import) unresolved import; \\\n-                                        bailing out\");\n-                                return Indeterminate;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If we didn't find a result in the type namespace, search the\n-        // external modules.\n-        let mut value_used_public = false;\n-        let mut type_used_public = false;\n-        match type_result {\n-            BoundResult(..) => {}\n-            _ => {\n-                match containing_module.external_module_children.borrow_mut()\n-                                       .get(&source).cloned() {\n-                    None => {} // Continue.\n-                    Some(module) => {\n-                        debug!(\"(resolving single import) found external \\\n-                                module\");\n-                        // track the module as used.\n-                        match module.def_id.get() {\n-                            Some(DefId{krate: kid, ..}) => { self.used_crates.insert(kid); },\n-                            _ => {}\n-                        }\n-                        let name_bindings =\n-                            Rc::new(Resolver::create_name_bindings_from_module(\n-                                module));\n-                        type_result = BoundResult(containing_module.clone(),\n-                                                  name_bindings);\n-                        type_used_public = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // We've successfully resolved the import. Write the results in.\n-        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let import_resolution = &mut (*import_resolutions)[target];\n-        {\n-            let mut check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n-                let namespace_name = match namespace {\n-                    TypeNS => \"type\",\n-                    ValueNS => \"value\",\n-                };\n-\n-                match *result {\n-                    BoundResult(ref target_module, ref name_bindings) => {\n-                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n-                               namespace_name,\n-                               name_bindings.def_for_namespace(namespace));\n-                        self.check_for_conflicting_import(\n-                            &import_resolution.target_for_namespace(namespace),\n-                            directive.span,\n-                            target,\n-                            namespace);\n-\n-                        self.check_that_import_is_importable(\n-                            &**name_bindings,\n-                            directive.span,\n-                            target,\n-                            namespace);\n-\n-                        let target = Some(Target::new(target_module.clone(),\n-                                                      name_bindings.clone(),\n-                                                      directive.shadowable));\n-                        import_resolution.set_target_and_id(namespace, target, directive.id);\n-                        import_resolution.is_public = directive.is_public;\n-                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n-                    }\n-                    UnboundResult => { /* Continue. */ }\n-                    UnknownResult => {\n-                        panic!(\"{:?} result should be known at this point\", namespace_name);\n-                    }\n-                }\n-            };\n-            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n-            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n-        }\n-\n-        self.check_for_conflicts_between_imports_and_items(\n-            module_,\n-            import_resolution,\n-            directive.span,\n-            target);\n-\n-        if value_result.is_unbound() && type_result.is_unbound() {\n-            let msg = format!(\"There is no `{}` in `{}`\",\n-                              token::get_name(source),\n-                              self.module_to_string(&*containing_module));\n-            return Failed(Some((directive.span, msg)));\n-        }\n-        let value_used_public = value_used_reexport || value_used_public;\n-        let type_used_public = type_used_reexport || type_used_public;\n-\n-        assert!(import_resolution.outstanding_references >= 1);\n-        import_resolution.outstanding_references -= 1;\n-\n-        // record what this import resolves to for later uses in documentation,\n-        // this may resolve to either a value or a type, but for documentation\n-        // purposes it's good enough to just favor one over the other.\n-        let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n-            (def, if value_used_public { lp } else { DependsOn(def.def_id()) })\n-        });\n-        let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n-            (def, if type_used_public { lp } else { DependsOn(def.def_id()) })\n-        });\n-\n-        let import_lp = LastImport {\n-            value_priv: value_def_and_priv.map(|(_, p)| p),\n-            value_used: Used,\n-            type_priv: type_def_and_priv.map(|(_, p)| p),\n-            type_used: Used\n-        };\n-\n-        if let Some((def, _)) = value_def_and_priv {\n-            self.def_map.borrow_mut().insert(directive.id, PathResolution {\n-                base_def: def,\n-                last_private: import_lp,\n-                depth: 0\n-            });\n-        }\n-        if let Some((def, _)) = type_def_and_priv {\n-            self.def_map.borrow_mut().insert(directive.id, PathResolution {\n-                base_def: def,\n-                last_private: import_lp,\n-                depth: 0\n-            });\n-        }\n-\n-        debug!(\"(resolving single import) successfully resolved import\");\n-        return Success(());\n-    }\n-\n-    // Resolves a glob import. Note that this function cannot fail; it either\n-    // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid). containing_module is the module we are\n-    // actually importing, i.e., `foo` in `use foo::*`.\n-    fn resolve_glob_import(&mut self,\n-                           module_: &Module,\n-                           containing_module: Rc<Module>,\n-                           import_directive: &ImportDirective,\n-                           lp: LastPrivate)\n-                           -> ResolveResult<()> {\n-        let id = import_directive.id;\n-        let is_public = import_directive.is_public;\n-\n-        // This function works in a highly imperative manner; it eagerly adds\n-        // everything it can to the list of import resolutions of the module\n-        // node.\n-        debug!(\"(resolving glob import) resolving glob import {}\", id);\n-\n-        // We must bail out if the node has unresolved imports of any kind\n-        // (including globs).\n-        if !(*containing_module).all_imports_resolved() {\n-            debug!(\"(resolving glob import) target module has unresolved \\\n-                    imports; bailing out\");\n-            return Indeterminate;\n-        }\n-\n-        assert_eq!(containing_module.glob_count.get(), 0);\n-\n-        // Add all resolved imports from the containing module.\n-        let import_resolutions = containing_module.import_resolutions.borrow();\n-        for (ident, target_import_resolution) in &*import_resolutions {\n-            debug!(\"(resolving glob import) writing module resolution \\\n-                    {} into `{}`\",\n-                   token::get_name(*ident),\n-                   self.module_to_string(module_));\n-\n-            if !target_import_resolution.is_public {\n-                debug!(\"(resolving glob import) nevermind, just kidding\");\n-                continue\n-            }\n-\n-            // Here we merge two import resolutions.\n-            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            match import_resolutions.get_mut(ident) {\n-                Some(dest_import_resolution) => {\n-                    // Merge the two import resolutions at a finer-grained\n-                    // level.\n-\n-                    match target_import_resolution.value_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref value_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution.value_target,\n-                                                              import_directive.span,\n-                                                              *ident,\n-                                                              ValueNS);\n-                            dest_import_resolution.value_target = Some(value_target.clone());\n-                        }\n-                    }\n-                    match target_import_resolution.type_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref type_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution.type_target,\n-                                                              import_directive.span,\n-                                                              *ident,\n-                                                              TypeNS);\n-                            dest_import_resolution.type_target = Some(type_target.clone());\n-                        }\n-                    }\n-                    dest_import_resolution.is_public = is_public;\n-                    continue;\n-                }\n-                None => {}\n-            }\n-\n-            // Simple: just copy the old import resolution.\n-            let mut new_import_resolution = ImportResolution::new(id, is_public);\n-            new_import_resolution.value_target =\n-                target_import_resolution.value_target.clone();\n-            new_import_resolution.type_target =\n-                target_import_resolution.type_target.clone();\n-\n-            import_resolutions.insert(*ident, new_import_resolution);\n-        }\n-\n-        // Add all children from the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n-\n-        for (&name, name_bindings) in &*containing_module.children.borrow() {\n-            self.merge_import_resolution(module_,\n-                                         containing_module.clone(),\n-                                         import_directive,\n-                                         name,\n-                                         name_bindings.clone());\n-\n-        }\n-\n-        // Add external module children from the containing module.\n-        for (&name, module) in &*containing_module.external_module_children.borrow() {\n-            let name_bindings =\n-                Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n-            self.merge_import_resolution(module_,\n-                                         containing_module.clone(),\n-                                         import_directive,\n-                                         name,\n-                                         name_bindings);\n-        }\n-\n-        // Record the destination of this import\n-        if let Some(did) = containing_module.def_id.get() {\n-            self.def_map.borrow_mut().insert(id, PathResolution {\n-                base_def: DefMod(did),\n-                last_private: lp,\n-                depth: 0\n-            });\n-        }\n-\n-        debug!(\"(resolving glob import) successfully resolved import\");\n-        return Success(());\n-    }\n-\n-    fn merge_import_resolution(&mut self,\n-                               module_: &Module,\n-                               containing_module: Rc<Module>,\n-                               import_directive: &ImportDirective,\n-                               name: Name,\n-                               name_bindings: Rc<NameBindings>) {\n-        let id = import_directive.id;\n-        let is_public = import_directive.is_public;\n-\n-        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(name).get().unwrap_or_else(\n-            |vacant_entry| {\n-                // Create a new import resolution from this child.\n-                vacant_entry.insert(ImportResolution::new(id, is_public))\n-            });\n-\n-        debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n-               to `{}`\",\n-               &token::get_name(name),\n-               self.module_to_string(&*containing_module),\n-               self.module_to_string(module_));\n-\n-        // Merge the child item into the import resolution.\n-        {\n-            let mut merge_child_item = |namespace| {\n-                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n-                    let namespace_name = match namespace {\n-                        TypeNS => \"type\",\n-                        ValueNS => \"value\",\n-                    };\n-                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n-                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n-                        let msg = format!(\"a {} named `{}` has already been imported \\\n-                                           in this module\",\n-                                          namespace_name,\n-                                          &token::get_name(name));\n-                        span_err!(self.session, import_directive.span, E0251, \"{}\", msg);\n-                    } else {\n-                        let target = Target::new(containing_module.clone(),\n-                                                 name_bindings.clone(),\n-                                                 import_directive.shadowable);\n-                        dest_import_resolution.set_target_and_id(namespace,\n-                                                                 Some(target),\n-                                                                 id);\n-                    }\n-                }\n-            };\n-            merge_child_item(ValueNS);\n-            merge_child_item(TypeNS);\n-        }\n-\n-        dest_import_resolution.is_public = is_public;\n-\n-        self.check_for_conflicts_between_imports_and_items(\n-            module_,\n-            dest_import_resolution,\n-            import_directive.span,\n-            name);\n-    }\n-\n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicting_import(&mut self,\n-                                    target: &Option<Target>,\n-                                    import_span: Span,\n-                                    name: Name,\n-                                    namespace: Namespace) {\n-        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               &token::get_name(name),\n-               target.is_some());\n-\n-        match *target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                let msg = format!(\"a {} named `{}` has already been imported \\\n-                                   in this module\",\n-                                  match namespace {\n-                                    TypeNS => \"type\",\n-                                    ValueNS => \"value\",\n-                                  },\n-                                  &token::get_name(name));\n-                span_err!(self.session, import_span, E0252, \"{}\", &msg[..]);\n-            }\n-            Some(_) | None => {}\n-        }\n-    }\n-\n-    /// Checks that an import is actually importable\n-    fn check_that_import_is_importable(&mut self,\n-                                       name_bindings: &NameBindings,\n-                                       import_span: Span,\n-                                       name: Name,\n-                                       namespace: Namespace) {\n-        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n-            let msg = format!(\"`{}` is not directly importable\",\n-                              token::get_name(name));\n-            span_err!(self.session, import_span, E0253, \"{}\", &msg[..]);\n-        }\n-    }\n-\n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicts_between_imports_and_items(&mut self,\n-                                                     module: &Module,\n-                                                     import_resolution:\n-                                                     &ImportResolution,\n-                                                     import_span: Span,\n-                                                     name: Name) {\n-        // First, check for conflicts between imports and `extern crate`s.\n-        if module.external_module_children\n-                 .borrow()\n-                 .contains_key(&name) {\n-            match import_resolution.type_target {\n-                Some(ref target) if target.shadowable != Shadowable::Always => {\n-                    let msg = format!(\"import `{0}` conflicts with imported \\\n-                                       crate in this module \\\n-                                       (maybe you meant `use {0}::*`?)\",\n-                                      &token::get_name(name));\n-                    span_err!(self.session, import_span, E0254, \"{}\", &msg[..]);\n-                }\n-                Some(_) | None => {}\n-            }\n-        }\n-\n-        // Check for item conflicts.\n-        let children = module.children.borrow();\n-        let name_bindings = match children.get(&name) {\n-            None => {\n-                // There can't be any conflicts.\n-                return\n-            }\n-            Some(ref name_bindings) => (*name_bindings).clone(),\n-        };\n-\n-        match import_resolution.value_target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref value) = *name_bindings.value_def.borrow() {\n-                    span_err!(self.session, import_span, E0255,\n-                              \"import `{}` conflicts with value in this module\",\n-                              &token::get_name(name));\n-                    if let Some(span) = value.value_span {\n-                        self.session.span_note(span, \"conflicting value here\");\n-                    }\n-                }\n-            }\n-            Some(_) | None => {}\n-        }\n-\n-        match import_resolution.type_target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref ty) = *name_bindings.type_def.borrow() {\n-                    let (what, note) = if ty.module_def.is_some() {\n-                        (\"existing submodule\", \"note conflicting module here\")\n-                    } else {\n-                        (\"type in this module\", \"note conflicting type here\")\n-                    };\n-                    span_err!(self.session, import_span, E0256,\n-                              \"import `{}` conflicts with {}\",\n-                              &token::get_name(name), what);\n-                    if let Some(span) = ty.type_span {\n-                        self.session.span_note(span, note);\n-                    }\n-                }\n-            }\n-            Some(_) | None => {}\n-        }\n-    }\n-\n     /// Checks that the names of external crates don't collide with other\n     /// external crates.\n     fn check_for_conflicts_between_external_crates(&self,\n@@ -1964,18 +996,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               false) {\n                 Failed(None) => {\n                     let segment_name = token::get_name(name);\n-                    let module_name = self.module_to_string(&*search_module);\n+                    let module_name = module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[..] {\n                         span.hi = span.lo + Pos::from_usize(segment_name.len());\n \n                         match search_parent_externals(name,\n                                                      &self.current_module) {\n                             Some(module) => {\n-                                let path_str = self.names_to_string(module_path);\n-                                let target_mod_str = self.module_to_string(&*module);\n+                                let path_str = names_to_string(module_path);\n+                                let target_mod_str = module_to_string(&*module);\n                                 let current_mod_str =\n-                                    self.module_to_string(&*self.current_module);\n+                                    module_to_string(&*self.current_module);\n \n                                 let prefix = if target_mod_str == current_mod_str {\n                                     \"self::\".to_string()\n@@ -2066,8 +1098,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         assert!(module_path_len > 0);\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n-               self.names_to_string(module_path),\n-               self.module_to_string(&*module_));\n+               names_to_string(module_path),\n+               module_to_string(&*module_));\n \n         // Resolve the module prefix, if any.\n         let module_prefix_result = self.resolve_module_prefix(module_.clone(),\n@@ -2078,7 +1110,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         match module_prefix_result {\n             Failed(None) => {\n-                let mpath = self.names_to_string(module_path);\n+                let mpath = names_to_string(module_path);\n                 let mpath = &mpath[..];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n@@ -2161,7 +1193,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 namespace {:?} in `{}`\",\n                token::get_name(name),\n                namespace,\n-               self.module_to_string(&*module_));\n+               module_to_string(&*module_));\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n@@ -2398,7 +1430,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 break\n             }\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n-                   self.module_to_string(&*containing_module));\n+                   module_to_string(&*containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed(None),\n                 Some(new_module) => {\n@@ -2409,7 +1441,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n-               self.module_to_string(&*containing_module));\n+               module_to_string(&*containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n     }\n@@ -2429,7 +1461,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                &token::get_name(name),\n-               self.module_to_string(&*module_));\n+               module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n@@ -2583,15 +1615,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                token::get_name(name),\n-                               self.module_to_string(&*orig_module));\n+                               module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n                                        token::get_name(name),\n-                                       self.module_to_string(&*orig_module));\n+                                       module_to_string(&*orig_module));\n                             }\n                             Some(module_) => {\n                                 self.current_module = module_;\n@@ -2970,7 +2002,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 self.resolve_error(trait_path.span,\n                     &format!(\"`{}` is not a trait\",\n-                             self.path_names_to_string(trait_path, path_depth)));\n+                             path_names_to_string(trait_path, path_depth)));\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n@@ -2981,7 +2013,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         } else {\n             let msg = format!(\"use of undeclared trait name `{}`\",\n-                              self.path_names_to_string(trait_path, path_depth));\n+                              path_names_to_string(trait_path, path_depth));\n             self.resolve_error(trait_path.span, &msg);\n             Err(())\n         }\n@@ -3097,7 +2129,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n-                let path_str = self.path_names_to_string(&trait_ref.path, 0);\n+                let path_str = path_names_to_string(&trait_ref.path, 0);\n                 self.resolve_error(span,\n                                     &format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n@@ -3279,7 +2311,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n                                 (id {}) = {:?}\",\n-                               self.path_names_to_string(path, 0),\n+                               path_names_to_string(path, 0),\n                                ty.id, def);\n                         self.record_def(ty.id, def);\n                     }\n@@ -3294,7 +2326,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         };\n \n                         let msg = format!(\"use of undeclared {} `{}`\", kind,\n-                                          self.path_names_to_string(path, 0));\n+                                          path_names_to_string(path, 0));\n                         self.resolve_error(ty.span, &msg[..]);\n                     }\n                 }\n@@ -3465,7 +2497,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n-                                              self.path_names_to_string(path, 0));\n+                                              path_names_to_string(path, 0));\n                             self.resolve_error(path.span, &msg[..]);\n                         }\n                     }\n@@ -3718,7 +2750,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared type or module `{}`\",\n-                                          self.names_to_string(&module_path));\n+                                          names_to_string(&module_path));\n                         (span, msg)\n                     }\n                 };\n@@ -3778,7 +2810,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(&module_path[..]));\n+                                          names_to_string(&module_path[..]));\n                         (span, msg)\n                     }\n                 };\n@@ -3998,7 +3030,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if let Some(binding) = module.children.borrow().get(&name) {\n                 if let Some(DefMethod(did, _)) = binding.def_for_namespace(ValueNS) {\n                     if is_static_method(self, did) {\n-                        return StaticMethod(self.path_names_to_string(&path, 0))\n+                        return StaticMethod(path_names_to_string(&path, 0))\n                     }\n                     if self.current_trait_ref.is_some() {\n                         return TraitItem;\n@@ -4013,7 +3045,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((trait_did, ref trait_ref)) = self.current_trait_ref {\n             if let Some(&did) = self.trait_item_map.get(&(name, trait_did)) {\n                 if is_static_method(self, did) {\n-                    return TraitMethod(self.path_names_to_string(&trait_ref.path, 0));\n+                    return TraitMethod(path_names_to_string(&trait_ref.path, 0));\n                 } else {\n                     return TraitItem;\n                 }\n@@ -4105,7 +3137,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(path_res) = resolution {\n                     // Check if struct variant\n                     if let DefVariant(_, _, true) = path_res.base_def {\n-                        let path_name = self.path_names_to_string(path, 0);\n+                        let path_name = path_names_to_string(path, 0);\n                         self.resolve_error(expr.span,\n                                 &format!(\"`{}` is a struct variant name, but \\\n                                           this expression \\\n@@ -4123,7 +3155,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     } else {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n-                               self.path_names_to_string(path, 0));\n+                               path_names_to_string(path, 0));\n \n                         // Partial resolutions will need the set of traits in scope,\n                         // so they can be completed during typeck.\n@@ -4140,7 +3172,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // (The pattern matching def_tys where the id is in self.structs\n                     // matches on regular structs while excluding tuple- and enum-like\n                     // structs, which wouldn't result in this error.)\n-                    let path_name = self.path_names_to_string(path, 0);\n+                    let path_name = path_names_to_string(path, 0);\n                     let type_res = self.with_no_errors(|this| {\n                         this.resolve_path(expr.id, path, 0, TypeNS, false)\n                     });\n@@ -4227,7 +3259,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n                         let msg = format!(\"`{}` does not name a structure\",\n-                                          self.path_names_to_string(path, 0));\n+                                          path_names_to_string(path, 0));\n                         self.resolve_error(path.span, &msg[..]);\n                     }\n                 }\n@@ -4417,36 +3449,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // hit.\n     //\n \n-    /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_string(&self, module: &Module) -> String {\n-        let mut names = Vec::new();\n-\n-        fn collect_mod(names: &mut Vec<ast::Name>, module: &Module) {\n-            match module.parent_link {\n-                NoParentLink => {}\n-                ModuleParentLink(ref module, name) => {\n-                    names.push(name);\n-                    collect_mod(names, &*module.upgrade().unwrap());\n-                }\n-                BlockParentLink(ref module, _) => {\n-                    // danger, shouldn't be ident?\n-                    names.push(special_idents::opaque.name);\n-                    collect_mod(names, &*module.upgrade().unwrap());\n-                }\n-            }\n-        }\n-        collect_mod(&mut names, module);\n-\n-        if names.len() == 0 {\n-            return \"???\".to_string();\n-        }\n-        self.names_to_string(&names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>())\n-    }\n-\n     #[allow(dead_code)]   // useful for debugging\n     fn dump_module(&mut self, module_: Rc<Module>) {\n-        debug!(\"Dump of module `{}`:\", self.module_to_string(&*module_));\n+        debug!(\"Dump of module `{}`:\", module_to_string(&*module_));\n \n         debug!(\"Children:\");\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n@@ -4480,6 +3485,56 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n }\n \n+\n+fn names_to_string(names: &[Name]) -> String {\n+    let mut first = true;\n+    let mut result = String::new();\n+    for name in names {\n+        if first {\n+            first = false\n+        } else {\n+            result.push_str(\"::\")\n+        }\n+        result.push_str(&token::get_name(*name));\n+    };\n+    result\n+}\n+\n+fn path_names_to_string(path: &Path, depth: usize) -> String {\n+    let names: Vec<ast::Name> = path.segments[..path.segments.len()-depth]\n+                                    .iter()\n+                                    .map(|seg| seg.identifier.name)\n+                                    .collect();\n+    names_to_string(&names[..])\n+}\n+\n+/// A somewhat inefficient routine to obtain the name of a module.\n+fn module_to_string(module: &Module) -> String {\n+    let mut names = Vec::new();\n+\n+    fn collect_mod(names: &mut Vec<ast::Name>, module: &Module) {\n+        match module.parent_link {\n+            NoParentLink => {}\n+            ModuleParentLink(ref module, name) => {\n+                names.push(name);\n+                collect_mod(names, &*module.upgrade().unwrap());\n+            }\n+            BlockParentLink(ref module, _) => {\n+                // danger, shouldn't be ident?\n+                names.push(special_idents::opaque.name);\n+                collect_mod(names, &*module.upgrade().unwrap());\n+            }\n+        }\n+    }\n+    collect_mod(&mut names, module);\n+\n+    if names.len() == 0 {\n+        return \"???\".to_string();\n+    }\n+    names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())\n+}\n+\n+\n pub struct CrateMap {\n     pub def_map: DefMap,\n     pub freevars: RefCell<FreevarMap>,\n@@ -4507,7 +3562,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     build_reduced_graph::build_reduced_graph(&mut resolver, krate);\n     session.abort_if_errors();\n \n-    resolver.resolve_imports();\n+    resolve_imports::resolve_imports(&mut resolver);\n     session.abort_if_errors();\n \n     record_exports::record(&mut resolver);"}, {"sha": "e953b6398f9c08e6eab61bfc34e807b28c92e740", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -22,6 +22,7 @@ use {Module, NameBindings, Resolver};\n use Namespace::{self, TypeNS, ValueNS};\n \n use build_reduced_graph;\n+use module_to_string;\n \n use rustc::middle::def::Export;\n use syntax::ast;\n@@ -60,19 +61,19 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for local module `{}`\",\n-                       self.module_to_string(&*module_));\n+                       module_to_string(&*module_));\n             }\n             None => {\n                 // Record exports for the root module.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for root module `{}`\",\n-                       self.module_to_string(&*module_));\n+                       module_to_string(&*module_));\n             }\n             Some(_) => {\n                 // Bail out.\n                 debug!(\"(recording exports for module subtree) not recording \\\n                         exports for `{}`\",\n-                       self.module_to_string(&*module_));\n+                       module_to_string(&*module_));\n                 return;\n             }\n         }\n@@ -133,13 +134,13 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n     fn add_exports_for_module(&mut self,\n                               exports: &mut Vec<Export>,\n                               module_: &Module) {\n-        for (name, importresolution) in &*module_.import_resolutions.borrow() {\n-            if !importresolution.is_public {\n+        for (name, import_resolution) in &*module_.import_resolutions.borrow() {\n+            if !import_resolution.is_public {\n                 continue\n             }\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n-                match importresolution.target_for_namespace(ns) {\n+                match import_resolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\",\n                                token::get_name(*name));"}, {"sha": "737ec71cab3da09273b69f94d3653d37674e91eb", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "added", "additions": 1021, "deletions": 0, "changes": 1021, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,1021 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::ImportDirectiveSubclass::*;\n+\n+use {PUBLIC, IMPORTABLE};\n+use Module;\n+use Namespace::{self, TypeNS, ValueNS};\n+use NameBindings;\n+use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n+use NamespaceResult;\n+use NameSearchType;\n+use ResolveResult;\n+use Resolver;\n+use UseLexicalScopeFlag;\n+use {names_to_string, module_to_string};\n+\n+use build_reduced_graph;\n+\n+use rustc::middle::def::*;\n+use rustc::middle::privacy::*;\n+\n+use syntax::ast::{DefId, NodeId, Name};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token;\n+use syntax::codemap::Span;\n+\n+use std::mem::replace;\n+use std::rc::Rc;\n+\n+\n+/// Contains data for specific types of import directives.\n+#[derive(Copy,Debug)]\n+pub enum ImportDirectiveSubclass {\n+    SingleImport(Name /* target */, Name /* source */),\n+    GlobImport\n+}\n+\n+/// Whether an import can be shadowed by another import.\n+#[derive(Debug,PartialEq,Clone,Copy)]\n+pub enum Shadowable {\n+    Always,\n+    Never\n+}\n+\n+/// One import directive.\n+#[derive(Debug)]\n+pub struct ImportDirective {\n+    pub module_path: Vec<Name>,\n+    pub subclass: ImportDirectiveSubclass,\n+    pub span: Span,\n+    pub id: NodeId,\n+    pub is_public: bool, // see note in ImportResolution about how to use this\n+    pub shadowable: Shadowable,\n+}\n+\n+impl ImportDirective {\n+    pub fn new(module_path: Vec<Name> ,\n+           subclass: ImportDirectiveSubclass,\n+           span: Span,\n+           id: NodeId,\n+           is_public: bool,\n+           shadowable: Shadowable)\n+           -> ImportDirective {\n+        ImportDirective {\n+            module_path: module_path,\n+            subclass: subclass,\n+            span: span,\n+            id: id,\n+            is_public: is_public,\n+            shadowable: shadowable,\n+        }\n+    }\n+}\n+\n+/// The item that an import resolves to.\n+#[derive(Clone,Debug)]\n+pub struct Target {\n+    pub target_module: Rc<Module>,\n+    pub bindings: Rc<NameBindings>,\n+    pub shadowable: Shadowable,\n+}\n+\n+impl Target {\n+    pub fn new(target_module: Rc<Module>,\n+           bindings: Rc<NameBindings>,\n+           shadowable: Shadowable)\n+           -> Target {\n+        Target {\n+            target_module: target_module,\n+            bindings: bindings,\n+            shadowable: shadowable,\n+        }\n+    }\n+}\n+\n+/// An ImportResolution represents a particular `use` directive.\n+#[derive(Debug)]\n+pub struct ImportResolution {\n+    /// Whether this resolution came from a `use` or a `pub use`. Note that this\n+    /// should *not* be used whenever resolution is being performed. Privacy\n+    /// testing occurs during a later phase of compilation.\n+    pub is_public: bool,\n+\n+    // The number of outstanding references to this name. When this reaches\n+    // zero, outside modules can count on the targets being correct. Before\n+    // then, all bets are off; future imports could override this name.\n+    // Note that this is usually either 0 or 1 - shadowing is forbidden the only\n+    // way outstanding_references is > 1 in a legal program is if the name is\n+    // used in both namespaces.\n+    pub outstanding_references: uint,\n+\n+    /// The value that this `use` directive names, if there is one.\n+    pub value_target: Option<Target>,\n+    /// The source node of the `use` directive leading to the value target\n+    /// being non-none\n+    pub value_id: NodeId,\n+\n+    /// The type that this `use` directive names, if there is one.\n+    pub type_target: Option<Target>,\n+    /// The source node of the `use` directive leading to the type target\n+    /// being non-none\n+    pub type_id: NodeId,\n+}\n+\n+impl ImportResolution {\n+    pub fn new(id: NodeId, is_public: bool) -> ImportResolution {\n+        ImportResolution {\n+            type_id: id,\n+            value_id: id,\n+            outstanding_references: 0,\n+            value_target: None,\n+            type_target: None,\n+            is_public: is_public,\n+        }\n+    }\n+\n+    pub fn target_for_namespace(&self, namespace: Namespace)\n+                                -> Option<Target> {\n+        match namespace {\n+            TypeNS  => self.type_target.clone(),\n+            ValueNS => self.value_target.clone(),\n+        }\n+    }\n+\n+    pub fn id(&self, namespace: Namespace) -> NodeId {\n+        match namespace {\n+            TypeNS  => self.type_id,\n+            ValueNS => self.value_id,\n+        }\n+    }\n+\n+    pub fn shadowable(&self, namespace: Namespace) -> Shadowable {\n+        let target = self.target_for_namespace(namespace);\n+        if target.is_none() {\n+            return Shadowable::Always;\n+        }\n+\n+        target.unwrap().shadowable\n+    }\n+\n+    pub fn set_target_and_id(&mut self,\n+                         namespace: Namespace,\n+                         target: Option<Target>,\n+                         id: NodeId) {\n+        match namespace {\n+            TypeNS  => {\n+                self.type_target = target;\n+                self.type_id = id;\n+            }\n+            ValueNS => {\n+                self.value_target = target;\n+                self.value_id = id;\n+            }\n+        }\n+    }\n+}\n+\n+\n+struct ImportResolver<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n+    // Import resolution\n+    //\n+    // This is a fixed-point algorithm. We resolve imports until our efforts\n+    // are stymied by an unresolved import; then we bail out of the current\n+    // module and continue. We terminate successfully once no more imports\n+    // remain or unsuccessfully when no forward progress in resolving imports\n+    // is made.\n+\n+    /// Resolves all imports for the crate. This method performs the fixed-\n+    /// point iteration.\n+    fn resolve_imports(&mut self) {\n+        let mut i = 0;\n+        let mut prev_unresolved_imports = 0;\n+        loop {\n+            debug!(\"(resolving imports) iteration {}, {} imports left\",\n+                   i, self.resolver.unresolved_imports);\n+\n+            let module_root = self.resolver.graph_root.get_module();\n+            self.resolve_imports_for_module_subtree(module_root.clone());\n+\n+            if self.resolver.unresolved_imports == 0 {\n+                debug!(\"(resolving imports) success\");\n+                break;\n+            }\n+\n+            if self.resolver.unresolved_imports == prev_unresolved_imports {\n+                self.resolver.report_unresolved_imports(module_root);\n+                break;\n+            }\n+\n+            i += 1;\n+            prev_unresolved_imports = self.resolver.unresolved_imports;\n+        }\n+    }\n+\n+    /// Attempts to resolve imports for the given module and all of its\n+    /// submodules.\n+    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n+        debug!(\"(resolving imports for module subtree) resolving {}\",\n+               module_to_string(&*module_));\n+        let orig_module = replace(&mut self.resolver.current_module, module_.clone());\n+        self.resolve_imports_for_module(module_.clone());\n+        self.resolver.current_module = orig_module;\n+\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n+        for (_, child_node) in &*module_.children.borrow() {\n+            match child_node.get_module_if_available() {\n+                None => {\n+                    // Nothing to do.\n+                }\n+                Some(child_module) => {\n+                    self.resolve_imports_for_module_subtree(child_module);\n+                }\n+            }\n+        }\n+\n+        for (_, child_module) in &*module_.anonymous_children.borrow() {\n+            self.resolve_imports_for_module_subtree(child_module.clone());\n+        }\n+    }\n+\n+    /// Attempts to resolve imports for the given module only.\n+    fn resolve_imports_for_module(&mut self, module: Rc<Module>) {\n+        if module.all_imports_resolved() {\n+            debug!(\"(resolving imports for module) all imports resolved for \\\n+                   {}\",\n+                   module_to_string(&*module));\n+            return;\n+        }\n+\n+        let imports = module.imports.borrow();\n+        let import_count = imports.len();\n+        while module.resolved_import_count.get() < import_count {\n+            let import_index = module.resolved_import_count.get();\n+            let import_directive = &(*imports)[import_index];\n+            match self.resolve_import_for_module(module.clone(),\n+                                                 import_directive) {\n+                ResolveResult::Failed(err) => {\n+                    let (span, help) = match err {\n+                        Some((span, msg)) => (span, format!(\". {}\", msg)),\n+                        None => (import_directive.span, String::new())\n+                    };\n+                    let msg = format!(\"unresolved import `{}`{}\",\n+                                      import_path_to_string(\n+                                          &import_directive.module_path,\n+                                          import_directive.subclass),\n+                                      help);\n+                    self.resolver.resolve_error(span, &msg[..]);\n+                }\n+                ResolveResult::Indeterminate => break, // Bail out. We'll come around next time.\n+                ResolveResult::Success(()) => () // Good. Continue.\n+            }\n+\n+            module.resolved_import_count\n+                  .set(module.resolved_import_count.get() + 1);\n+        }\n+    }\n+\n+    /// Attempts to resolve the given import. The return value indicates\n+    /// failure if we're certain the name does not exist, indeterminate if we\n+    /// don't know whether the name exists at the moment due to other\n+    /// currently-unresolved imports, or success if we know the name exists.\n+    /// If successful, the resolved bindings are written into the module.\n+    fn resolve_import_for_module(&mut self,\n+                                 module_: Rc<Module>,\n+                                 import_directive: &ImportDirective)\n+                                 -> ResolveResult<()> {\n+        let mut resolution_result = ResolveResult::Failed(None);\n+        let module_path = &import_directive.module_path;\n+\n+        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n+               names_to_string(&module_path[..]),\n+               module_to_string(&*module_));\n+\n+        // First, resolve the module path for the directive, if necessary.\n+        let container = if module_path.len() == 0 {\n+            // Use the crate root.\n+            Some((self.resolver.graph_root.get_module(), LastMod(AllPublic)))\n+        } else {\n+            match self.resolver.resolve_module_path(module_.clone(),\n+                                                    &module_path[..],\n+                                                    UseLexicalScopeFlag::DontUseLexicalScope,\n+                                                    import_directive.span,\n+                                                    NameSearchType::ImportSearch) {\n+                ResolveResult::Failed(err) => {\n+                    resolution_result = ResolveResult::Failed(err);\n+                    None\n+                },\n+                ResolveResult::Indeterminate => {\n+                    resolution_result = ResolveResult::Indeterminate;\n+                    None\n+                }\n+                ResolveResult::Success(container) => Some(container),\n+            }\n+        };\n+\n+        match container {\n+            None => {}\n+            Some((containing_module, lp)) => {\n+                // We found the module that the target is contained\n+                // within. Attempt to resolve the import within it.\n+\n+                match import_directive.subclass {\n+                    SingleImport(target, source) => {\n+                        resolution_result =\n+                            self.resolve_single_import(&module_,\n+                                                       containing_module,\n+                                                       target,\n+                                                       source,\n+                                                       import_directive,\n+                                                       lp);\n+                    }\n+                    GlobImport => {\n+                        resolution_result =\n+                            self.resolve_glob_import(&module_,\n+                                                     containing_module,\n+                                                     import_directive,\n+                                                     lp);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Decrement the count of unresolved imports.\n+        match resolution_result {\n+            ResolveResult::Success(()) => {\n+                assert!(self.resolver.unresolved_imports >= 1);\n+                self.resolver.unresolved_imports -= 1;\n+            }\n+            _ => {\n+                // Nothing to do here; just return the error.\n+            }\n+        }\n+\n+        // Decrement the count of unresolved globs if necessary. But only if\n+        // the resolution result is indeterminate -- otherwise we'll stop\n+        // processing imports here. (See the loop in\n+        // resolve_imports_for_module).\n+\n+        if !resolution_result.indeterminate() {\n+            match import_directive.subclass {\n+                GlobImport => {\n+                    assert!(module_.glob_count.get() >= 1);\n+                    module_.glob_count.set(module_.glob_count.get() - 1);\n+                }\n+                SingleImport(..) => {\n+                    // Ignore.\n+                }\n+            }\n+        }\n+\n+        return resolution_result;\n+    }\n+\n+    fn resolve_single_import(&mut self,\n+                             module_: &Module,\n+                             target_module: Rc<Module>,\n+                             target: Name,\n+                             source: Name,\n+                             directive: &ImportDirective,\n+                             lp: LastPrivate)\n+                             -> ResolveResult<()> {\n+        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n+                `{}` id {}, last private {:?}\",\n+               token::get_name(target),\n+               module_to_string(&*target_module),\n+               token::get_name(source),\n+               module_to_string(module_),\n+               directive.id,\n+               lp);\n+\n+        let lp = match lp {\n+            LastMod(lp) => lp,\n+            LastImport {..} => {\n+                self.resolver.session\n+                    .span_bug(directive.span,\n+                              \"not expecting Import here, must be LastMod\")\n+            }\n+        };\n+\n+        // We need to resolve both namespaces for this to succeed.\n+        //\n+\n+        let mut value_result = UnknownResult;\n+        let mut type_result = UnknownResult;\n+\n+        // Search for direct children of the containing module.\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n+\n+        match target_module.children.borrow().get(&source) {\n+            None => {\n+                // Continue.\n+            }\n+            Some(ref child_name_bindings) => {\n+                // pub_err makes sure we don't give the same error twice.\n+                let mut pub_err = false;\n+                if child_name_bindings.defined_in_namespace(ValueNS) {\n+                    debug!(\"(resolving single import) found value binding\");\n+                    value_result = BoundResult(target_module.clone(),\n+                                               (*child_name_bindings).clone());\n+                    if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n+                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n+                        pub_err = true;\n+                    }\n+                }\n+                if child_name_bindings.defined_in_namespace(TypeNS) {\n+                    debug!(\"(resolving single import) found type binding\");\n+                    type_result = BoundResult(target_module.clone(),\n+                                              (*child_name_bindings).clone());\n+                    if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n+                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Unless we managed to find a result in both namespaces (unlikely),\n+        // search imports as well.\n+        let mut value_used_reexport = false;\n+        let mut type_used_reexport = false;\n+        match (value_result.clone(), type_result.clone()) {\n+            (BoundResult(..), BoundResult(..)) => {} // Continue.\n+            _ => {\n+                // If there is an unresolved glob at this point in the\n+                // containing module, bail out. We don't know enough to be\n+                // able to resolve this import.\n+\n+                if target_module.glob_count.get() > 0 {\n+                    debug!(\"(resolving single import) unresolved glob; \\\n+                            bailing out\");\n+                    return ResolveResult::Indeterminate;\n+                }\n+\n+                // Now search the exported imports within the containing module.\n+                match target_module.import_resolutions.borrow().get(&source) {\n+                    None => {\n+                        debug!(\"(resolving single import) no import\");\n+                        // The containing module definitely doesn't have an\n+                        // exported import with the name in question. We can\n+                        // therefore accurately report that the names are\n+                        // unbound.\n+\n+                        if value_result.is_unknown() {\n+                            value_result = UnboundResult;\n+                        }\n+                        if type_result.is_unknown() {\n+                            type_result = UnboundResult;\n+                        }\n+                    }\n+                    Some(import_resolution)\n+                            if import_resolution.outstanding_references == 0 => {\n+\n+                        fn get_binding(this: &mut Resolver,\n+                                       import_resolution: &ImportResolution,\n+                                       namespace: Namespace,\n+                                       source: &Name)\n+                                    -> NamespaceResult {\n+\n+                            // Import resolutions must be declared with \"pub\"\n+                            // in order to be exported.\n+                            if !import_resolution.is_public {\n+                                return UnboundResult;\n+                            }\n+\n+                            match import_resolution.target_for_namespace(namespace) {\n+                                None => {\n+                                    return UnboundResult;\n+                                }\n+                                Some(Target {\n+                                    target_module,\n+                                    bindings,\n+                                    shadowable: _\n+                                }) => {\n+                                    debug!(\"(resolving single import) found \\\n+                                            import in ns {:?}\", namespace);\n+                                    let id = import_resolution.id(namespace);\n+                                    // track used imports and extern crates as well\n+                                    this.used_imports.insert((id, namespace));\n+                                    this.record_import_use(id, *source);\n+                                    match target_module.def_id.get() {\n+                                        Some(DefId{krate: kid, ..}) => {\n+                                            this.used_crates.insert(kid);\n+                                        },\n+                                        _ => {}\n+                                    }\n+                                    return BoundResult(target_module, bindings);\n+                                }\n+                            }\n+                        }\n+\n+                        // The name is an import which has been fully\n+                        // resolved. We can, therefore, just follow it.\n+                        if value_result.is_unknown() {\n+                            value_result = get_binding(self.resolver,\n+                                                       import_resolution,\n+                                                       ValueNS,\n+                                                       &source);\n+                            value_used_reexport = import_resolution.is_public;\n+                        }\n+                        if type_result.is_unknown() {\n+                            type_result = get_binding(self.resolver,\n+                                                      import_resolution,\n+                                                      TypeNS,\n+                                                      &source);\n+                            type_used_reexport = import_resolution.is_public;\n+                        }\n+\n+                    }\n+                    Some(_) => {\n+                        // If target_module is the same module whose import we are resolving\n+                        // and there it has an unresolved import with the same name as `source`,\n+                        // then the user is actually trying to import an item that is declared\n+                        // in the same scope\n+                        //\n+                        // e.g\n+                        // use self::submodule;\n+                        // pub mod submodule;\n+                        //\n+                        // In this case we continue as if we resolved the import and let the\n+                        // check_for_conflicts_between_imports_and_items call below handle\n+                        // the conflict\n+                        match (module_.def_id.get(),  target_module.def_id.get()) {\n+                            (Some(id1), Some(id2)) if id1 == id2  => {\n+                                if value_result.is_unknown() {\n+                                    value_result = UnboundResult;\n+                                }\n+                                if type_result.is_unknown() {\n+                                    type_result = UnboundResult;\n+                                }\n+                            }\n+                            _ =>  {\n+                                // The import is unresolved. Bail out.\n+                                debug!(\"(resolving single import) unresolved import; \\\n+                                        bailing out\");\n+                                return ResolveResult::Indeterminate;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut value_used_public = false;\n+        let mut type_used_public = false;\n+\n+        // If we didn't find a result in the type namespace, search the\n+        // external modules.\n+        match type_result {\n+            BoundResult(..) => {}\n+            _ => {\n+                match target_module.external_module_children.borrow_mut().get(&source).cloned() {\n+                    None => {} // Continue.\n+                    Some(module) => {\n+                        debug!(\"(resolving single import) found external module\");\n+                        // track the module as used.\n+                        match module.def_id.get() {\n+                            Some(DefId{krate: kid, ..}) => {\n+                                self.resolver.used_crates.insert(kid);\n+                            }\n+                            _ => {}\n+                        }\n+                        let name_bindings =\n+                            Rc::new(Resolver::create_name_bindings_from_module(module));\n+                        type_result = BoundResult(target_module.clone(), name_bindings);\n+                        type_used_public = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // We've successfully resolved the import. Write the results in.\n+        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+        let import_resolution = &mut (*import_resolutions)[target];\n+\n+        {\n+            let mut check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n+                let namespace_name = match namespace {\n+                    TypeNS => \"type\",\n+                    ValueNS => \"value\",\n+                };\n+\n+                match *result {\n+                    BoundResult(ref target_module, ref name_bindings) => {\n+                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n+                               namespace_name,\n+                               name_bindings.def_for_namespace(namespace));\n+                        self.check_for_conflicting_import(\n+                            &import_resolution.target_for_namespace(namespace),\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        self.check_that_import_is_importable(\n+                            &**name_bindings,\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        let target = Some(Target::new(target_module.clone(),\n+                                                      name_bindings.clone(),\n+                                                      directive.shadowable));\n+                        import_resolution.set_target_and_id(namespace, target, directive.id);\n+                        import_resolution.is_public = directive.is_public;\n+                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n+                    }\n+                    UnboundResult => { /* Continue. */ }\n+                    UnknownResult => {\n+                        panic!(\"{:?} result should be known at this point\", namespace_name);\n+                    }\n+                }\n+            };\n+            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n+            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n+        }\n+\n+        self.check_for_conflicts_between_imports_and_items(\n+            module_,\n+            import_resolution,\n+            directive.span,\n+            target);\n+\n+        if value_result.is_unbound() && type_result.is_unbound() {\n+            let msg = format!(\"There is no `{}` in `{}`\",\n+                              token::get_name(source),\n+                              module_to_string(&target_module));\n+            return ResolveResult::Failed(Some((directive.span, msg)));\n+        }\n+        let value_used_public = value_used_reexport || value_used_public;\n+        let type_used_public = type_used_reexport || type_used_public;\n+\n+        assert!(import_resolution.outstanding_references >= 1);\n+        import_resolution.outstanding_references -= 1;\n+\n+        // Record what this import resolves to for later uses in documentation,\n+        // this may resolve to either a value or a type, but for documentation\n+        // purposes it's good enough to just favor one over the other.\n+        let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n+            let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n+            (def, if value_used_public { lp } else { DependsOn(def.def_id()) })\n+        });\n+        let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n+            let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n+            (def, if type_used_public { lp } else { DependsOn(def.def_id()) })\n+        });\n+\n+        let import_lp = LastImport {\n+            value_priv: value_def_and_priv.map(|(_, p)| p),\n+            value_used: Used,\n+            type_priv: type_def_and_priv.map(|(_, p)| p),\n+            type_used: Used\n+        };\n+\n+        if let Some((def, _)) = value_def_and_priv {\n+            self.resolver.def_map.borrow_mut().insert(directive.id, PathResolution {\n+                base_def: def,\n+                last_private: import_lp,\n+                depth: 0\n+            });\n+        }\n+        if let Some((def, _)) = type_def_and_priv {\n+            self.resolver.def_map.borrow_mut().insert(directive.id, PathResolution {\n+                base_def: def,\n+                last_private: import_lp,\n+                depth: 0\n+            });\n+        }\n+\n+        debug!(\"(resolving single import) successfully resolved import\");\n+        return ResolveResult::Success(());\n+    }\n+\n+    // Resolves a glob import. Note that this function cannot fail; it either\n+    // succeeds or bails out (as importing * from an empty module or a module\n+    // that exports nothing is valid). target_module is the module we are\n+    // actually importing, i.e., `foo` in `use foo::*`.\n+    fn resolve_glob_import(&mut self,\n+                           module_: &Module,\n+                           target_module: Rc<Module>,\n+                           import_directive: &ImportDirective,\n+                           lp: LastPrivate)\n+                           -> ResolveResult<()> {\n+        let id = import_directive.id;\n+        let is_public = import_directive.is_public;\n+\n+        // This function works in a highly imperative manner; it eagerly adds\n+        // everything it can to the list of import resolutions of the module\n+        // node.\n+        debug!(\"(resolving glob import) resolving glob import {}\", id);\n+\n+        // We must bail out if the node has unresolved imports of any kind\n+        // (including globs).\n+        if !(*target_module).all_imports_resolved() {\n+            debug!(\"(resolving glob import) target module has unresolved \\\n+                    imports; bailing out\");\n+            return ResolveResult::Indeterminate;\n+        }\n+\n+        assert_eq!(target_module.glob_count.get(), 0);\n+\n+        // Add all resolved imports from the containing module.\n+        let import_resolutions = target_module.import_resolutions.borrow();\n+        for (ident, target_import_resolution) in &*import_resolutions {\n+            debug!(\"(resolving glob import) writing module resolution \\\n+                    {} into `{}`\",\n+                   token::get_name(*ident),\n+                   module_to_string(module_));\n+\n+            if !target_import_resolution.is_public {\n+                debug!(\"(resolving glob import) nevermind, just kidding\");\n+                continue\n+            }\n+\n+            // Here we merge two import resolutions.\n+            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+            match import_resolutions.get_mut(ident) {\n+                Some(dest_import_resolution) => {\n+                    // Merge the two import resolutions at a finer-grained\n+                    // level.\n+\n+                    match target_import_resolution.value_target {\n+                        None => {\n+                            // Continue.\n+                        }\n+                        Some(ref value_target) => {\n+                            self.check_for_conflicting_import(&dest_import_resolution.value_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              ValueNS);\n+                            dest_import_resolution.value_target = Some(value_target.clone());\n+                        }\n+                    }\n+                    match target_import_resolution.type_target {\n+                        None => {\n+                            // Continue.\n+                        }\n+                        Some(ref type_target) => {\n+                            self.check_for_conflicting_import(&dest_import_resolution.type_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              TypeNS);\n+                            dest_import_resolution.type_target = Some(type_target.clone());\n+                        }\n+                    }\n+                    dest_import_resolution.is_public = is_public;\n+                    continue;\n+                }\n+                None => {}\n+            }\n+\n+            // Simple: just copy the old import resolution.\n+            let mut new_import_resolution = ImportResolution::new(id, is_public);\n+            new_import_resolution.value_target =\n+                target_import_resolution.value_target.clone();\n+            new_import_resolution.type_target =\n+                target_import_resolution.type_target.clone();\n+\n+            import_resolutions.insert(*ident, new_import_resolution);\n+        }\n+\n+        // Add all children from the containing module.\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n+\n+        for (&name, name_bindings) in &*target_module.children.borrow() {\n+            self.merge_import_resolution(module_,\n+                                         target_module.clone(),\n+                                         import_directive,\n+                                         name,\n+                                         name_bindings.clone());\n+\n+        }\n+\n+        // Add external module children from the containing module.\n+        for (&name, module) in &*target_module.external_module_children.borrow() {\n+            let name_bindings =\n+                Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n+            self.merge_import_resolution(module_,\n+                                         target_module.clone(),\n+                                         import_directive,\n+                                         name,\n+                                         name_bindings);\n+        }\n+\n+        // Record the destination of this import\n+        if let Some(did) = target_module.def_id.get() {\n+            self.resolver.def_map.borrow_mut().insert(id, PathResolution {\n+                base_def: DefMod(did),\n+                last_private: lp,\n+                depth: 0\n+            });\n+        }\n+\n+        debug!(\"(resolving glob import) successfully resolved import\");\n+        return ResolveResult::Success(());\n+    }\n+\n+    fn merge_import_resolution(&mut self,\n+                               module_: &Module,\n+                               containing_module: Rc<Module>,\n+                               import_directive: &ImportDirective,\n+                               name: Name,\n+                               name_bindings: Rc<NameBindings>) {\n+        let id = import_directive.id;\n+        let is_public = import_directive.is_public;\n+\n+        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+        let dest_import_resolution = import_resolutions.entry(name).get().unwrap_or_else(\n+            |vacant_entry| {\n+                // Create a new import resolution from this child.\n+                vacant_entry.insert(ImportResolution::new(id, is_public))\n+            });\n+\n+        debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n+               to `{}`\",\n+               &token::get_name(name),\n+               module_to_string(&*containing_module),\n+               module_to_string(module_));\n+\n+        // Merge the child item into the import resolution.\n+        {\n+            let mut merge_child_item = |namespace| {\n+                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                    let namespace_name = match namespace {\n+                        TypeNS => \"type\",\n+                        ValueNS => \"value\",\n+                    };\n+                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n+                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n+                        let msg = format!(\"a {} named `{}` has already been imported \\\n+                                           in this module\",\n+                                          namespace_name,\n+                                          &token::get_name(name));\n+                        span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n+                    } else {\n+                        let target = Target::new(containing_module.clone(),\n+                                                 name_bindings.clone(),\n+                                                 import_directive.shadowable);\n+                        dest_import_resolution.set_target_and_id(namespace,\n+                                                                 Some(target),\n+                                                                 id);\n+                    }\n+                }\n+            };\n+            merge_child_item(ValueNS);\n+            merge_child_item(TypeNS);\n+        }\n+\n+        dest_import_resolution.is_public = is_public;\n+\n+        self.check_for_conflicts_between_imports_and_items(\n+            module_,\n+            dest_import_resolution,\n+            import_directive.span,\n+            name);\n+    }\n+\n+    /// Checks that imported names and items don't have the same name.\n+    fn check_for_conflicting_import(&mut self,\n+                                    target: &Option<Target>,\n+                                    import_span: Span,\n+                                    name: Name,\n+                                    namespace: Namespace) {\n+        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n+               &token::get_name(name),\n+               target.is_some());\n+\n+        match *target {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n+                let msg = format!(\"a {} named `{}` has already been imported \\\n+                                   in this module\",\n+                                  match namespace {\n+                                    TypeNS => \"type\",\n+                                    ValueNS => \"value\",\n+                                  },\n+                                  &token::get_name(name));\n+                span_err!(self.resolver.session, import_span, E0252, \"{}\", &msg[..]);\n+            }\n+            Some(_) | None => {}\n+        }\n+    }\n+\n+    /// Checks that an import is actually importable\n+    fn check_that_import_is_importable(&mut self,\n+                                       name_bindings: &NameBindings,\n+                                       import_span: Span,\n+                                       name: Name,\n+                                       namespace: Namespace) {\n+        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n+            let msg = format!(\"`{}` is not directly importable\",\n+                              token::get_name(name));\n+            span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n+        }\n+    }\n+\n+    /// Checks that imported names and items don't have the same name.\n+    fn check_for_conflicts_between_imports_and_items(&mut self,\n+                                                     module: &Module,\n+                                                     import_resolution:\n+                                                     &ImportResolution,\n+                                                     import_span: Span,\n+                                                     name: Name) {\n+        // First, check for conflicts between imports and `extern crate`s.\n+        if module.external_module_children\n+                 .borrow()\n+                 .contains_key(&name) {\n+            match import_resolution.type_target {\n+                Some(ref target) if target.shadowable != Shadowable::Always => {\n+                    let msg = format!(\"import `{0}` conflicts with imported \\\n+                                       crate in this module \\\n+                                       (maybe you meant `use {0}::*`?)\",\n+                                      &token::get_name(name));\n+                    span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n+                }\n+                Some(_) | None => {}\n+            }\n+        }\n+\n+        // Check for item conflicts.\n+        let children = module.children.borrow();\n+        let name_bindings = match children.get(&name) {\n+            None => {\n+                // There can't be any conflicts.\n+                return\n+            }\n+            Some(ref name_bindings) => (*name_bindings).clone(),\n+        };\n+\n+        match import_resolution.value_target {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n+                if let Some(ref value) = *name_bindings.value_def.borrow() {\n+                    span_err!(self.resolver.session, import_span, E0255,\n+                              \"import `{}` conflicts with value in this module\",\n+                              &token::get_name(name));\n+                    if let Some(span) = value.value_span {\n+                        self.resolver.session.span_note(span, \"conflicting value here\");\n+                    }\n+                }\n+            }\n+            Some(_) | None => {}\n+        }\n+\n+        match import_resolution.type_target {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n+                if let Some(ref ty) = *name_bindings.type_def.borrow() {\n+                    let (what, note) = if ty.module_def.is_some() {\n+                        (\"existing submodule\", \"note conflicting module here\")\n+                    } else {\n+                        (\"type in this module\", \"note conflicting type here\")\n+                    };\n+                    span_err!(self.resolver.session, import_span, E0256,\n+                              \"import `{}` conflicts with {}\",\n+                              &token::get_name(name), what);\n+                    if let Some(span) = ty.type_span {\n+                        self.resolver.session.span_note(span, note);\n+                    }\n+                }\n+            }\n+            Some(_) | None => {}\n+        }\n+    }\n+}\n+\n+fn import_path_to_string(names: &[Name],\n+                         subclass: ImportDirectiveSubclass)\n+                         -> String {\n+    if names.is_empty() {\n+        import_directive_subclass_to_string(subclass)\n+    } else {\n+        (format!(\"{}::{}\",\n+                 names_to_string(names),\n+                 import_directive_subclass_to_string(subclass))).to_string()\n+    }\n+}\n+\n+fn import_directive_subclass_to_string(subclass: ImportDirectiveSubclass) -> String {\n+    match subclass {\n+        SingleImport(_, source) => {\n+            token::get_name(source).to_string()\n+        }\n+        GlobImport => \"*\".to_string()\n+    }\n+}\n+\n+pub fn resolve_imports(resolver: &mut Resolver) {\n+    let mut import_resolver = ImportResolver {\n+        resolver: resolver,\n+    };\n+    import_resolver.resolve_imports();\n+}"}, {"sha": "34a23f3efac42c3011bbb2773d05f58f01aea631", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -626,12 +626,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                  e))\n                 }\n \n-                let bc_data_deflated = match flate::deflate_bytes(&bc_data[..]) {\n-                    Some(compressed) => compressed,\n-                    None => sess.fatal(&format!(\"failed to compress bytecode \\\n-                                                 from {}\",\n-                                                 bc_filename.display()))\n-                };\n+                let bc_data_deflated = flate::deflate_bytes(&bc_data[..]);\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,"}, {"sha": "a3ab863c4eca475e026792ccb6ec0e1ff066cad6", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -95,8 +95,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                             (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)];\n \n                         match flate::inflate_bytes(compressed_data) {\n-                            Some(inflated) => inflated,\n-                            None => {\n+                            Ok(inflated) => inflated,\n+                            Err(_) => {\n                                 sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n                                                    name))\n                             }\n@@ -111,8 +111,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                 // the object must be in the old, pre-versioning format, so simply\n                 // inflate everything and let LLVM decide if it can make sense of it\n                     match flate::inflate_bytes(bc_encoded) {\n-                        Some(bc) => bc,\n-                        None => {\n+                        Ok(bc) => bc,\n+                        Err(_) => {\n                             sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n                                                name))\n                         }"}, {"sha": "e9f58ec53dfb31ded8ddb81313fe06c4ff9ce634", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -2974,10 +2974,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let mut compressed = encoder::metadata_encoding_version.to_vec();\n-    compressed.push_all(&match flate::deflate_bytes(&metadata) {\n-        Some(compressed) => compressed,\n-        None => cx.sess().fatal(\"failed to compress metadata\"),\n-    });\n+    compressed.push_all(&flate::deflate_bytes(&metadata));\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[..]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\","}, {"sha": "cf36ec1f3ed96f49954a1ec836a582ae23c6460c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -253,7 +253,7 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Translates an adapter that implements the `Fn` trait for a fn\n /// pointer. This is basically the equivalent of something like:\n ///\n-/// ```rust\n+/// ```\n /// impl<'a> Fn(&'a int) -> &'a int for fn(&int) -> &int {\n ///     extern \"rust-abi\" fn call(&self, args: (&'a int,)) -> &'a int {\n ///         (*self)(args.0)"}, {"sha": "c1bc7219ad8253942eb826dcdbbc22aa739ac9b4", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -259,4 +259,3 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n     Some(bcx)\n }\n-"}, {"sha": "6dd566797970e5aa820675ee245706d293a424b7", "filename": "src/librustc_trans/trans/llrepr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fllrepr.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -34,5 +34,3 @@ impl LlvmRepr for ValueRef {\n         ccx.tn().val_to_string(*self)\n     }\n }\n-\n-"}, {"sha": "32f91a175f3c3eed8d9eb73355aea543127124a8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -248,5 +248,3 @@ fn self_type_matches_expected_vid<'a,'tcx>(\n         _ => None,\n     }\n }\n-\n-"}, {"sha": "17fc2aad286ea35f5d59441d4f3f1712e30584af", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -556,5 +556,3 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }\n }\n-\n-"}, {"sha": "963be9aa2e2d2b0cb77e2320f19796e5ebdb2c1e", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -302,4 +302,3 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }\n-"}, {"sha": "396d060de9e9017d40282758553a4f84ca6a0f9e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -181,4 +181,3 @@ register_diagnostics! {\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }\n-"}, {"sha": "ac1ff29e7f5455407c9eecd35e1dc4c46c2cc493", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1350,4 +1350,3 @@ fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n         (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n     }\n }\n-"}, {"sha": "d2385702a73d2c2c35fc85453890a3c56f7be2c5", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -111,4 +111,3 @@ impl fmt::Display for ItemType {\n         self.to_static_str().fmt(f)\n     }\n }\n-"}, {"sha": "dd85e40e64548e19b4571c86ec4ec1111bad4401", "filename": "src/librustdoc/html/static/Heuristica-LICENSE.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2FHeuristica-LICENSE.txt", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2FHeuristica-LICENSE.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FHeuristica-LICENSE.txt?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1,7 +1,7 @@\n Copyright 1989, 1991 Adobe Systems Incorporated. All rights reserved.\n Utopia is either a registered trademark or trademark of Adobe Systems\n Incorporated in the United States and/or other countries. Used under\n-license. \n+license.\n \n Copyright 2006 Han The Thanh, Vntopia font family, http://vntex.sf.net\n \n@@ -26,7 +26,7 @@ with others.\n \n The OFL allows the licensed fonts to be used, studied, modified and\n redistributed freely as long as they are not sold by themselves. The\n-fonts, including any derivative works, can be bundled, embedded, \n+fonts, including any derivative works, can be bundled, embedded,\n redistributed and/or sold with any software provided that any reserved\n names are not used by derivative works. The fonts and derivatives,\n however, cannot be released under any other type of license. The"}, {"sha": "07542572e33bdc15739d047cc3b72da24d71ccef", "filename": "src/librustdoc/html/static/SourceCodePro-LICENSE.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-LICENSE.txt", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-LICENSE.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceCodePro-LICENSE.txt?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,7 +18,7 @@ with others.\n \n The OFL allows the licensed fonts to be used, studied, modified and\n redistributed freely as long as they are not sold by themselves. The\n-fonts, including any derivative works, can be bundled, embedded, \n+fonts, including any derivative works, can be bundled, embedded,\n redistributed and/or sold with any software provided that any reserved\n names are not used by derivative works. The fonts and derivatives,\n however, cannot be released under any other type of license. The"}, {"sha": "b77d653ad4f0dd68026dc96e5b1be332a56e6bd9", "filename": "src/librustdoc/html/static/SourceSerifPro-LICENSE.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceSerifPro-LICENSE.txt", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceSerifPro-LICENSE.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2FSourceSerifPro-LICENSE.txt?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,7 +18,7 @@ with others.\n \n The OFL allows the licensed fonts to be used, studied, modified and\n redistributed freely as long as they are not sold by themselves. The\n-fonts, including any derivative works, can be bundled, embedded, \n+fonts, including any derivative works, can be bundled, embedded,\n redistributed and/or sold with any software provided that any reserved\n names are not used by derivative works. The fonts and derivatives,\n however, cannot be released under any other type of license. The"}, {"sha": "06b3c4e42d6334c3f7e962dd6aa12de0c1ff1198", "filename": "src/librustdoc/html/static/playpen.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fplaypen.js", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fplaypen.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fplaypen.js?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -25,4 +25,3 @@\n         });\n     }\n }());\n-"}, {"sha": "1f8d45a007d2b19864febe22d2780bf3198c6188", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -31,7 +31,7 @@ impl ToHex for [u8] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// extern crate serialize;\n     /// use serialize::hex::ToHex;\n     ///\n@@ -100,7 +100,7 @@ impl FromHex for str {\n     ///\n     /// This converts a string literal to hexadecimal and back.\n     ///\n-    /// ```rust\n+    /// ```\n     /// extern crate serialize;\n     /// use serialize::hex::{FromHex, ToHex};\n     ///"}, {"sha": "df703b3e43e32768e40a2ba60fc961b96b8aa4c5", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -12,4 +12,3 @@\n \n #![doc(primitive = \"bool\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-"}, {"sha": "4b6fbe01f760bbe0b19b85d22f21a34b6561f55a", "filename": "src/libstd/env.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -41,7 +41,7 @@ use sys::os as os_imp;\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// // We assume that we are in a valid directory.\n@@ -58,7 +58,7 @@ pub fn current_dir() -> io::Result<PathBuf> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n /// use std::path::Path;\n ///\n@@ -102,7 +102,7 @@ pub struct VarsOs { inner: os_imp::Env }\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// // We will iterate through the references to the element returned by\n@@ -125,7 +125,7 @@ pub fn vars() -> Vars {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// // We will iterate through the references to the element returned by\n@@ -166,7 +166,7 @@ impl Iterator for VarsOs {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// let key = \"HOME\";\n@@ -188,7 +188,7 @@ pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// let key = \"HOME\";\n@@ -246,7 +246,7 @@ impl Error for VarError {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// let key = \"KEY\";\n@@ -282,7 +282,7 @@ pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// let key = \"PATH\";\n@@ -326,7 +326,7 @@ pub struct JoinPathsError {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n /// use std::path::PathBuf;\n ///\n@@ -374,7 +374,7 @@ impl Error for JoinPathsError {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// match env::home_dir() {\n@@ -416,7 +416,7 @@ pub fn temp_dir() -> PathBuf {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// match env::current_exe() {\n@@ -481,7 +481,7 @@ pub struct ArgsOs { inner: os_imp::Args }\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// // Prints each argument on a separate line\n@@ -503,7 +503,7 @@ pub fn args() -> Args {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::env;\n ///\n /// // Prints each argument on a separate line"}, {"sha": "ba89b3a0ea63f8b0e365a07ea6275d0beb258839", "filename": "src/libstd/fs/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -473,7 +473,7 @@ pub fn rename<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::fs;\n ///\n /// fs::copy(\"foo.txt\", \"bar.txt\");\n@@ -540,7 +540,7 @@ pub fn read_link<P: AsPath>(path: P) -> io::Result<PathBuf> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::fs;\n ///\n /// fs::create_dir(\"/some/dir\");\n@@ -576,7 +576,7 @@ pub fn create_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::fs;\n ///\n /// fs::remove_dir(\"/some/dir\");\n@@ -627,7 +627,7 @@ pub fn remove_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::io;\n /// use std::fs::{self, PathExt, DirEntry};\n /// use std::path::Path;"}, {"sha": "73dcf058e4512b0695caea1f419abf2f289a9fc7", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -118,15 +118,16 @@ impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n /// `BufWriter` keeps an in memory buffer of data and writes it to the\n /// underlying `Write` in large, infrequent batches.\n ///\n-/// This writer will be flushed when it is dropped.\n+/// The buffer will be written out when the writer is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n }\n \n-/// An error returned by `into_inner` which indicates whether a flush error\n-/// happened or not.\n+/// An error returned by `into_inner` which combines an error that\n+/// happened while writing out the buffer, and the buffered writer object\n+/// which may be used to recover from the condition.\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoInnerError<W>(W, Error);\n@@ -155,7 +156,7 @@ impl<W: Write> BufWriter<W> {\n             match self.inner.as_mut().unwrap().write(&self.buf[written..]) {\n                 Ok(0) => {\n                     ret = Err(Error::new(ErrorKind::WriteZero,\n-                                         \"failed to flush\", None));\n+                                         \"failed to write the buffered data\", None));\n                     break;\n                 }\n                 Ok(n) => written += n,\n@@ -190,7 +191,7 @@ impl<W: Write> BufWriter<W> {\n \n     /// Unwraps this `BufWriter`, returning the underlying writer.\n     ///\n-    /// The buffer is flushed before returning the writer.\n+    /// The buffer is written out before returning the writer.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n         match self.flush_buf() {\n@@ -239,14 +240,14 @@ impl<W: Write> Drop for BufWriter<W> {\n impl<W> IntoInnerError<W> {\n     /// Returns the error which caused the call to `into_inner` to fail.\n     ///\n-    /// This error was returned when attempting to flush the internal buffer.\n+    /// This error was returned when attempting to write the internal buffer.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn error(&self) -> &Error { &self.1 }\n \n-    /// Returns the underlying `BufWriter` instance which generated the error.\n+    /// Returns the buffered writer instance which generated the error.\n     ///\n-    /// The returned object can be used to retry a flush or re-inspect the\n-    /// buffer.\n+    /// The returned object can be used for error recovery, such as\n+    /// re-inspecting the buffer.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> W { self.0 }\n }\n@@ -273,7 +274,7 @@ impl<W> fmt::Display for IntoInnerError<W> {\n /// Wraps a Writer and buffers output to it, flushing whenever a newline\n /// (`0x0a`, `'\\n'`) is detected.\n ///\n-/// This writer will be flushed when it is dropped.\n+/// The buffer will be written out when the writer is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LineWriter<W> {\n     inner: BufWriter<W>,\n@@ -307,7 +308,7 @@ impl<W: Write> LineWriter<W> {\n \n     /// Unwraps this `LineWriter`, returning the underlying writer.\n     ///\n-    /// The internal buffer is flushed before returning the writer.\n+    /// The internal buffer is written out before returning the writer.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n         self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n@@ -364,7 +365,7 @@ impl<W: Read> Read for InternalBufWriter<W> {\n /// call. A `BufStream` keeps in memory buffers of data, making large,\n /// infrequent calls to `read` and `write` on the underlying `Read+Write`.\n ///\n-/// The output half will be flushed when this stream is dropped.\n+/// The output buffer will be written out when this stream is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufStream<S> {\n     inner: BufReader<InternalBufWriter<S>>\n@@ -410,8 +411,8 @@ impl<S: Read + Write> BufStream<S> {\n \n     /// Unwraps this `BufStream`, returning the underlying stream.\n     ///\n-    /// The internal buffer is flushed before returning the stream. Any leftover\n-    /// data in the read buffer is lost.\n+    /// The internal write buffer is written out before returning the stream.\n+    /// Any leftover data in the read buffer is lost.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n         let BufReader { inner: InternalBufWriter(w), buf } = self.inner;"}, {"sha": "d1231f549bb41ca979fdff10c38fdd9f446680ba", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -363,7 +363,7 @@ pub trait Write {\n     ///\n     /// It is considered an error if not all bytes could be written due to\n     /// I/O errors or EOF being reached.\n-    #[unstable(feature = \"io\", reason = \"waiting for RFC 950\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn flush(&mut self) -> Result<()>;\n \n     /// Attempts to write an entire buffer into this write."}, {"sha": "e1ef30627948d4a19f5e20977351d093b0a7e4e3", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -182,7 +182,7 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::fmt;\n     ///\n     /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n@@ -205,7 +205,7 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let path: &'static str = env!(\"PATH\");\n     /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n     /// ```\n@@ -224,7 +224,7 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n     /// println!(\"the secret key might be: {:?}\", key);\n     /// ```\n@@ -372,7 +372,7 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// mod test {\n     ///     pub fn foo() {\n     ///         assert!(module_path!().ends_with(\"test\"));\n@@ -395,7 +395,7 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let my_directory = if cfg!(windows) {\n     ///     \"windows-specific-directory\"\n     /// } else {"}, {"sha": "82a48a72499b62bb18d46810380c24f5f80b4201", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -34,7 +34,7 @@ use vec::Vec;\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::old_io::{BufferedReader, File};\n ///\n /// let file = File::open(&Path::new(\"message.txt\"));\n@@ -137,7 +137,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::old_io::{BufferedWriter, File};\n ///\n /// let file = File::create(&Path::new(\"message.txt\")).unwrap();\n@@ -323,7 +323,7 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::{BufferedStream, File};\n ///"}, {"sha": "ff3af380b7d6a4378d2232cf85157bf8c5f29958", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -176,7 +176,7 @@ impl File {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::old_io::File;\n     ///\n     /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n@@ -195,7 +195,7 @@ impl File {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// # #![allow(unused_must_use)]\n     /// use std::old_io::File;\n     ///\n@@ -286,7 +286,7 @@ impl File {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::fs;\n ///\n@@ -317,7 +317,7 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/file/path.txt\");\n@@ -359,7 +359,7 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::fs;\n ///\n@@ -387,7 +387,7 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::fs;\n ///\n@@ -437,7 +437,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io;\n /// use std::old_io::fs;\n@@ -508,7 +508,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io;\n /// use std::old_io::fs;\n@@ -532,7 +532,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::fs;\n ///\n@@ -556,7 +556,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::old_io::fs::PathExtensions;\n /// use std::old_io::fs;\n /// use std::old_io;"}, {"sha": "72774334c13b093af2d55ad0e07c73020d146333", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -56,7 +56,7 @@ impl Writer for Vec<u8> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::MemWriter;\n ///\n@@ -116,7 +116,7 @@ impl Writer for MemWriter {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::MemReader;\n ///\n@@ -246,7 +246,7 @@ impl<'a> Buffer for &'a [u8] {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::BufWriter;\n ///\n@@ -318,7 +318,7 @@ impl<'a> Seek for BufWriter<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// # #![allow(unused_must_use)]\n /// use std::old_io::BufReader;\n ///"}, {"sha": "15a80e34451f95ba569626fe44fab9cd6e8f2a22", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1410,7 +1410,7 @@ pub trait Buffer: Reader {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::old_io::BufReader;\n     ///\n     /// let mut reader = BufReader::new(b\"hello\\nworld\");"}, {"sha": "ad0e7a7284de48c2fb8fe47ddbbe2947b61a4ea1", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -52,7 +52,7 @@ impl UnixStream {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// # #![allow(unused_must_use)]\n     /// use std::old_io::net::pipe::UnixStream;\n     ///"}, {"sha": "b699b93f2b88c71344d26732eda99bb53609a928", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -142,7 +142,7 @@ impl StdinReader {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::old_io;\n     ///\n     /// let mut stdin = old_io::stdin();"}, {"sha": "65c62a99335220d5409934483f254316163c4884", "filename": "src/libstd/old_io/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -115,7 +115,7 @@ impl Timer {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n@@ -128,7 +128,7 @@ impl Timer {\n     /// ten_milliseconds.recv().unwrap();\n     /// ```\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n@@ -167,7 +167,7 @@ impl Timer {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n@@ -186,7 +186,7 @@ impl Timer {\n     /// ten_milliseconds.recv().unwrap();\n     /// ```\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///"}, {"sha": "46233a46ee556edd2463b119391c78a0d52b4f63", "filename": "src/libstd/os.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -132,7 +132,7 @@ pub const TMPBUF_SZ : uint = 1000;\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// // We assume that we are in a valid directory.\n@@ -152,7 +152,7 @@ pub fn getcwd() -> IoResult<Path> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// // We will iterate through the references to the element returned by os::env();\n@@ -188,7 +188,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// let key = \"HOME\";\n@@ -230,7 +230,7 @@ fn byteify(s: OsString) -> Vec<u8> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// let key = \"KEY\";\n@@ -270,7 +270,8 @@ pub fn unsetenv(n: &str) {\n /// environment variable.\n ///\n /// # Examples\n-/// ```rust\n+///\n+/// ```\n /// use std::os;\n ///\n /// let key = \"PATH\";\n@@ -302,7 +303,7 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n /// use std::old_path::Path;\n ///\n@@ -363,7 +364,7 @@ pub fn dll_filename(base: &str) -> String {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// match os::self_exe_name() {\n@@ -383,7 +384,7 @@ pub fn self_exe_name() -> Option<Path> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// match os::self_exe_path() {\n@@ -412,7 +413,7 @@ pub fn self_exe_path() -> Option<Path> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// match os::homedir() {\n@@ -501,7 +502,8 @@ pub fn tmpdir() -> Path {\n /// as is.\n ///\n /// # Examples\n-/// ```rust\n+///\n+/// ```\n /// use std::os;\n /// use std::old_path::Path;\n ///\n@@ -532,7 +534,8 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// whether the change was completed successfully or not.\n ///\n /// # Examples\n-/// ```rust\n+///\n+/// ```\n /// use std::os;\n /// use std::old_path::Path;\n ///\n@@ -553,7 +556,8 @@ pub fn errno() -> i32 {\n /// Return the string corresponding to an `errno()` value of `errnum`.\n ///\n /// # Examples\n-/// ```rust\n+///\n+/// ```\n /// use std::os;\n ///\n /// // Same as println!(\"{}\", last_os_error());\n@@ -749,7 +753,7 @@ extern \"system\" {\n /// See `String::from_utf8_lossy` for details.\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::os;\n ///\n /// // Prints each argument on a separate line"}, {"sha": "2d97d6513663713ae07599b9582d409bd2d3fcc7", "filename": "src/libstd/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -856,7 +856,7 @@ impl<'a> cmp::Ord for Components<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::path::PathBuf;\n ///\n /// let mut path = PathBuf::new(\"c:\\\\\");\n@@ -948,7 +948,7 @@ impl PathBuf {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::path::PathBuf;\n     ///\n     /// let mut buf = PathBuf::new(\"/\");\n@@ -1105,7 +1105,7 @@ impl AsOsStr for PathBuf {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::path::Path;\n ///\n /// let path = Path::new(\"/tmp/foo/bar.txt\");\n@@ -1210,7 +1210,7 @@ impl Path {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::path::Path;\n     ///\n     /// let path = Path::new(\"/foo/bar\");"}, {"sha": "69053252ed1de1e944d5ec6b69082910213b55a7", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -426,7 +426,7 @@ pub fn random<T: Rand>() -> T {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand::{thread_rng, sample};\n ///\n /// let mut rng = thread_rng();"}, {"sha": "42c153af03639909e9f36ea49862ba0ca8407ad0", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -25,7 +25,7 @@ use slice::SliceExt;\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand::{reader, Rng};\n /// use std::old_io::MemReader;\n ///"}, {"sha": "ebf4d3377499e99188b372b54ec5ff091ff6bc2a", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,7 +13,7 @@ use sync::{Mutex, Condvar};\n /// A barrier enables multiple tasks to synchronize the beginning\n /// of some computation.\n ///\n-/// ```rust\n+/// ```\n /// use std::sync::{Arc, Barrier};\n /// use std::thread;\n ///"}, {"sha": "1cbfbbf29278f1b03663400c2ea0fddc459c0a8a", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -46,7 +46,7 @@ use fmt;\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::sync::{Arc, Mutex};\n /// use std::thread;\n /// use std::sync::mpsc::channel;\n@@ -84,7 +84,7 @@ use fmt;\n ///\n /// To recover from a poisoned mutex:\n ///\n-/// ```rust\n+/// ```\n /// use std::sync::{Arc, Mutex};\n /// use std::thread;\n ///\n@@ -135,7 +135,7 @@ unsafe impl<T: Send> Sync for Mutex<T> { }\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::sync::{StaticMutex, MUTEX_INIT};\n ///\n /// static LOCK: StaticMutex = MUTEX_INIT;"}, {"sha": "258cf1d38a8ca887369ffb830f2aa6410386c584", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -26,7 +26,7 @@ use sync::{StaticMutex, MUTEX_INIT};\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::sync::{Once, ONCE_INIT};\n ///\n /// static START: Once = ONCE_INIT;"}, {"sha": "8a1946b86ab4a1ae3a9dda176e5f1359c81682a2", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -60,7 +60,7 @@ impl<'a> Drop for Sentinel<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::sync::TaskPool;\n /// use std::iter::AdditiveIterator;\n /// use std::sync::mpsc::channel;"}, {"sha": "a40b26c85bee1f5f4352345d5804e65e2afc648c", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -402,18 +402,18 @@ pub fn park() {\n /// the specified duration has been reached (may wake spuriously).\n ///\n /// The semantics of this function are equivalent to `park()` except that the\n-/// thread will be blocked for roughly no longer than dur. This method\n+/// thread will be blocked for roughly no longer than *duration*. This method\n /// should not be used for precise timing due to anomalies such as\n /// preemption or platform differences that may not cause the maximum\n-/// amount of time waited to be precisely dur\n+/// amount of time waited to be precisely *duration* long.\n ///\n /// See the module doc for more detail.\n #[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n-pub fn park_timeout(dur: Duration) {\n+pub fn park_timeout(duration: Duration) {\n     let thread = current();\n     let mut guard = thread.inner.lock.lock().unwrap();\n     if !*guard {\n-        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n+        let (g, _) = thread.inner.cvar.wait_timeout(guard, duration).unwrap();\n         guard = g;\n     }\n     *guard = false;\n@@ -502,11 +502,11 @@ impl Thread {\n     /// Deprecated: use module-level free function.\n     #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n-    pub fn park_timeout(dur: Duration) {\n+    pub fn park_timeout(duration: Duration) {\n         let thread = current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n         if !*guard {\n-            let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n+            let (g, _) = thread.inner.cvar.wait_timeout(guard, duration).unwrap();\n             guard = g;\n         }\n         *guard = false;"}, {"sha": "b53bb4bc75ee27425e4ee2c4f79e1cd1218092ab", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -37,7 +37,6 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n-#![feature(io)]\n #![feature(path_ext)]\n \n extern crate arena;"}, {"sha": "2a47a696b1cf2ad8745b1c92d9667973a5ed96f7", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -121,13 +121,11 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(&self.cx.path));\n \n-        if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n+        let i = if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n                 ast::ItemFn(_, ast::Unsafety::Unsafe, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n-                    diag.span_fatal(i.span,\n-                                    \"unsafe functions cannot be used for \\\n-                                     tests\");\n+                    diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\");\n                 }\n                 _ => {\n                     debug!(\"this is a test function\");\n@@ -142,9 +140,19 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     self.tests.push(i.ident);\n                     // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n+\n+                    // Make all tests public so we can call them from outside\n+                    // the module (note that the tests are re-exported and must\n+                    // be made public themselves to avoid privacy errors).\n+                    i.map(|mut i| {\n+                        i.vis = ast::Public;\n+                        i\n+                    })\n                 }\n             }\n-        }\n+        } else {\n+            i\n+        };\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things"}, {"sha": "89960d5d62f5b2d4367c29da2be457e45537a586", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -57,7 +57,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(int_uint)]\n-#![feature(io)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "02ddeea46bfc8ad14fcf5f20a0308fa93b5447cc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -42,7 +42,6 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n-#![feature(io)]\n #![feature(libc)]\n #![feature(set_stdio)]\n "}, {"sha": "917c2d2dfbe888e8a9e44c08851fbb7d491340a2", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -482,7 +482,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n ///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use unicode::str::Utf16Item::{ScalarValue, LoneSurrogate};\n ///\n /// // \ud834\udd1emus<invalid>ic<invalid>"}, {"sha": "7de08af314a5adc14b986990b838166382feef44", "filename": "src/rt/msvc/typeof.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Frt%2Fmsvc%2Ftypeof.h", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Frt%2Fmsvc%2Ftypeof.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmsvc%2Ftypeof.h?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -94,4 +94,3 @@ namespace msvc_typeof_impl {\n #endif\n \n #endif\n-"}, {"sha": "ee72707d3194e52584d8cb7f0df5fe971a95899f", "filename": "src/rt/valgrind/memcheck.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Frt%2Fvalgrind%2Fmemcheck.h", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Frt%2Fvalgrind%2Fmemcheck.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvalgrind%2Fmemcheck.h?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -1,4 +1,3 @@\n-\n /*\n    ----------------------------------------------------------------\n \n@@ -284,4 +283,3 @@ typedef\n                                     (zznbytes), 0, 0 )\n \n #endif\n-"}, {"sha": "28eae023d684b6186682116279b3965266e74323", "filename": "src/test/auxiliary/changing-crates-a2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -11,4 +11,3 @@\n #![crate_name = \"a\"]\n \n pub fn foo<T>() { println!(\"hello!\"); }\n-"}, {"sha": "93d8fd3da88fb0a04fae16938dfdc12533b6aaf3", "filename": "src/test/auxiliary/coherence-orphan-lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence-orphan-lib.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -11,4 +11,3 @@\n pub trait TheTrait<T> : ::std::marker::PhantomFn<T> {\n     fn the_fn(&self);\n }\n-"}, {"sha": "fe852e5d8eaee4c95df68851587fde0643bb912e", "filename": "src/test/auxiliary/default_type_params_xc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdefault_type_params_xc.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,4 +13,3 @@ pub struct Heap;\n pub struct FakeHeap;\n \n pub struct FakeVec<T, A = FakeHeap> { pub f: Option<(T,A)> }\n-"}, {"sha": "b231efa0fece4c3a6f82bcc029349254e5743079", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ fn no_op() { }\n pub const D : C<fn()> = C {\n     k: no_op as fn()\n };\n-"}, {"sha": "cf1953005ba44c241cecd2af2db5dbc0f0480971", "filename": "src/test/auxiliary/issue-12133-dylib2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-12133-dylib2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -14,4 +14,3 @@\n \n extern crate \"issue-12133-rlib\" as a;\n extern crate \"issue-12133-dylib\" as b;\n-"}, {"sha": "f1f16af6f0e3f5adea1260ff025c0b696df66382", "filename": "src/test/auxiliary/issue-13560-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -14,4 +14,3 @@\n \n #[macro_use] #[no_link] extern crate \"issue-13560-1\" as t1;\n #[macro_use] extern crate \"issue-13560-2\" as t2;\n-"}, {"sha": "b3b04b4a5ac13534824b834bff6100ab2d5c2193", "filename": "src/test/auxiliary/issue-16725.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-16725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-16725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16725.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -11,4 +11,3 @@\n extern {\n     fn bar();\n }\n-"}, {"sha": "2ffdddcc798ca8b28e94c686be7694a3e9986b43", "filename": "src/test/auxiliary/issue-5521.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-5521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue-5521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-5521.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -12,4 +12,3 @@\n use std::collections::HashMap;\n \n pub type map = Box<HashMap<uint, uint>>;\n-"}, {"sha": "c2acc514346150c8208fcb316731e009316ea146", "filename": "src/test/auxiliary/issue13213aux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13213aux.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -27,4 +27,3 @@ mod private {\n }\n \n pub static A: S = S { p: private::THREE };\n-"}, {"sha": "c118f7e4854fa762ed5962045da93f2dcfb1d7a7", "filename": "src/test/auxiliary/issue_3907.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3907.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,4 +13,3 @@ use std::marker::MarkerTrait;\n pub trait Foo : MarkerTrait {\n     fn bar();\n }\n-"}, {"sha": "e12af579c571d7c481b8b16c0916432d071c2fcd", "filename": "src/test/auxiliary/issue_5844_aux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_5844_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_5844_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_5844_aux.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,4 +13,3 @@ extern crate libc;\n extern \"C\" {\n     pub fn rand() -> libc::c_int;\n }\n-"}, {"sha": "04b56442d0b8fc7c3d094bd2973460eb7573e75c", "filename": "src/test/auxiliary/issue_8401.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_8401.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -24,4 +24,3 @@ fn foo<T>(t: &T) {\n     let b = B;\n     bar(unsafe { mem::transmute(&b as &A) }, t)\n }\n-"}, {"sha": "8c2546e76cfd4675eda28c4f2988955d3da15586", "filename": "src/test/auxiliary/issue_9123.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_9123.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_9123.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_9123.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ pub trait X {\n     }\n     fn dummy(&self) { }\n }\n-"}, {"sha": "d17e4afb5e8acb48e82ae930fd87afdd517fd81b", "filename": "src/test/auxiliary/issue_9188.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_9188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fissue_9188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_9188.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -21,4 +21,3 @@ pub fn foo<T>() -> &'static int {\n pub fn bar() -> &'static int {\n     foo::<int>()\n }\n-"}, {"sha": "82f182c04bd3899f716a96867e3a5da393c1dba3", "filename": "src/test/auxiliary/kinds_in_metadata.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fkinds_in_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fkinds_in_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fkinds_in_metadata.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -16,4 +16,3 @@\n #![crate_type=\"lib\"]\n \n pub fn f<T:Copy>() {}\n-"}, {"sha": "c5d4182eae6533d44a3f549b9274f384f044edd9", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -32,5 +32,3 @@ extern fn eh_personality() {}\n pub trait Copy : PhantomFn<Self> {\n     // Empty.\n }\n-\n-"}, {"sha": "3c0138a7077178c724cde33340d6122cdf22c065", "filename": "src/test/auxiliary/namespaced_enums.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ impl Foo {\n     pub fn foo() {}\n     pub fn bar(&self) {}\n }\n-"}, {"sha": "420151c471ea636a067c210738a8eeb4f690fc86", "filename": "src/test/auxiliary/plugin_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -32,4 +32,3 @@ pub fn registrar(_: &mut Registry) {\n     thread_local!(static FOO: RefCell<Option<Box<Any+Send>>> = RefCell::new(None));\n     FOO.with(|s| *s.borrow_mut() = Some(box Foo { foo: 10 } as Box<Any+Send>));\n }\n-"}, {"sha": "e60dbb290b079a6091c645a453b6889c0e19af6e", "filename": "src/test/auxiliary/privacy_reexport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -10,6 +10,6 @@\n \n pub use foo as bar;\n \n-mod foo {\n+pub mod foo {\n     pub fn frob() {}\n }"}, {"sha": "4419a5ae83cfab169c5929a24660335bed6bdce7", "filename": "src/test/auxiliary/pub_static_array.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fpub_static_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fpub_static_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpub_static_array.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub static ARRAY: &'static [u8] = &[1];"}, {"sha": "8d9b304aa51e0c783979b78fa57401688a4b1034", "filename": "src/test/auxiliary/struct_variant_privacy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fstruct_variant_privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fstruct_variant_privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_privacy.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -11,4 +11,3 @@\n enum Bar {\n     Baz { a: int }\n }\n-"}, {"sha": "beee83f9f7cd5eaa445a33ffda6cb5cc7b209d20", "filename": "src/test/auxiliary/trait_bounds_on_structs_and_enums_xc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_bounds_on_structs_and_enums_xc.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -21,4 +21,3 @@ pub enum Bar<T:Trait> {\n     BBar(T),\n     CBar(uint),\n }\n-"}, {"sha": "85f49b4bb7fad0a1e744cd48fa10f45e91a91481", "filename": "src/test/auxiliary/weak-lang-items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -34,4 +34,3 @@ pub fn foo() {\n mod std {\n     pub use core::{option, fmt};\n }\n-"}, {"sha": "4549bd719c65e15618646725a20e17df4ef108fe", "filename": "src/test/auxiliary/where_clauses_xc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fwhere_clauses_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fwhere_clauses_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fwhere_clauses_xc.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -27,4 +27,3 @@ impl<T> Equal for T where T: Eq {\n pub fn equal<T>(x: &T, y: &T) -> bool where T: Eq {\n     x == y\n }\n-"}, {"sha": "5556ee6971c4a6728de4f17998ade8e033ebf0ca", "filename": "src/test/auxiliary/xcrate_struct_aliases.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fxcrate_struct_aliases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fxcrate_struct_aliases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_struct_aliases.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -14,4 +14,3 @@ pub struct S {\n }\n \n pub type S2 = S;\n-"}, {"sha": "538abf00a67037a99c8db482d2924e7eeb377e3e", "filename": "src/test/auxiliary/xcrate_unit_struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -36,4 +36,3 @@ pub enum EnumWithVariants {\n     EnumVariant,\n     EnumVariantArg(int)\n }\n-"}, {"sha": "915cb077787ea41c05330ce1185ce497633afac0", "filename": "src/test/compile-fail/associated-types-coherence-failure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -57,4 +57,3 @@ pub trait ToOwned {\n \n \n fn main() {}\n-"}, {"sha": "0d68b960f31356d2227f227ced2ff65ff402a2f8", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -22,5 +22,5 @@ impl Foo for isize {\n \n pub fn main() {\n     let x: isize = Foo::<A=usize>::bar();\n-    //~^ERROR unexpected binding of associated item in expression path\n+    //~^ ERROR unexpected binding of associated item in expression path\n }"}, {"sha": "5c36e3356a5c026c8d3175fc64d567eae3355179", "filename": "src/test/compile-fail/associated-types-issue-17359.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-issue-17359.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ trait Trait : ::std::marker::MarkerTrait {\n impl Trait for isize {}  //~ ERROR missing: `Type`\n \n fn main() {}\n-"}, {"sha": "6425908672d12d3ee74a6d3dbffca2ab17870b6d", "filename": "src/test/compile-fail/bad-crate-id2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fbad-crate-id2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fbad-crate-id2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-crate-id2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -11,4 +11,3 @@\n extern crate \"#a\" as bar; //~ ERROR: invalid character `#` in crate name: `#a`\n \n fn main() {}\n-"}, {"sha": "c980e77df6f967c38a7f858e586bab4c857a44db", "filename": "src/test/compile-fail/borrowck-box-insensitivity.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-box-insensitivity.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -152,4 +152,3 @@ fn main() {\n     borrow_after_mut_borrow_nested();\n     mut_borrow_after_borrow_nested();\n }\n-"}, {"sha": "247a4fe89a501b4e2cfd189638ffcad9fd1c13b5", "filename": "src/test/compile-fail/borrowck-closures-unique-imm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique-imm.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -22,4 +22,3 @@ pub fn main() {\n     };\n     r()\n }\n-"}, {"sha": "13fd5fce95569590f09886fb4a1d2e69b0ad6e78", "filename": "src/test/compile-fail/borrowck-field-sensitivity.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-field-sensitivity.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -124,4 +124,3 @@ fn main() {\n     borrow_after_field_assign_after_uninit();\n     move_after_field_assign_after_uninit();\n }\n-"}, {"sha": "31ec5aea7f3a6e9912d91bbcd13224f69d1884d0", "filename": "src/test/compile-fail/borrowck-for-loop-correct-cmt-for-pattern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-correct-cmt-for-pattern.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -32,4 +32,3 @@ fn main() {\n     for &a in x.iter() {    //~ ERROR cannot move out\n     }\n }\n-"}, {"sha": "b79fc5b2bf622eb8fa252628374a8ff0cb6e48a5", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ fn main() {\n         vector[1] = 5;   //~ ERROR cannot borrow\n     }\n }\n-"}, {"sha": "8278b4fb971c300520ffde6534473ab6227b2a06", "filename": "src/test/compile-fail/borrowck-issue-14498.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-14498.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -62,4 +62,3 @@ fn main() {\n     borrow_in_field_from_var();\n     borrow_in_field_from_field();\n }\n-"}, {"sha": "d760f3db0c2cc9b85370bc03f11365d3d78c778b", "filename": "src/test/compile-fail/borrowck-let-suggestion.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ fn f() {\n fn main() {\n     f();\n }\n-"}, {"sha": "042b914ce41a49d0fccca3b5272d7fa8825a6c0f", "filename": "src/test/compile-fail/borrowck-multiple-captures.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -63,4 +63,3 @@ fn main() {\n     same_var_after_borrow();\n     same_var_after_move();\n }\n-"}, {"sha": "e35edca639e4535f18ff2e0fc4a3f69243507624", "filename": "src/test/compile-fail/borrowck-mutate-in-guard.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-mutate-in-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-mutate-in-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mutate-in-guard.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -30,4 +30,3 @@ fn foo() -> isize {\n fn main() {\n     foo();\n }\n-"}, {"sha": "021b3f38e0019d9d57441d93c24b89d011c6582d", "filename": "src/test/compile-fail/borrowck-object-lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -37,4 +37,3 @@ fn imm_owned_receiver(mut x: Box<Foo>) {\n }\n \n fn main() {}\n-"}, {"sha": "1bdc32b09750bd8162e6bbd1bf8af762b9b7c4c9", "filename": "src/test/compile-fail/borrowck-object-mutability.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -35,4 +35,3 @@ fn mut_owned_receiver(mut x: Box<Foo>) {\n }\n \n fn main() {}\n-"}, {"sha": "673c025e86345098b695e0d832673a7777d315ac", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -77,4 +77,3 @@ fn h() {\n }\n \n fn main() {}\n-"}, {"sha": "430f2fcc13a73c0a075cd0ae286739c9bbcb54ea", "filename": "src/test/compile-fail/borrowck-overloaded-index-and-overloaded-deref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -44,4 +44,3 @@ fn main() {\n }\n \n fn read(_: usize) { }\n-"}, {"sha": "c9cdeff9c7a17afa830f39a69cba68ed838abfc7", "filename": "src/test/compile-fail/borrowck-partial-reinit-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-partial-reinit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-partial-reinit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-partial-reinit-2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -31,4 +31,3 @@ fn main() {\n     stuff();\n     println!(\"Hello, world!\")\n }\n-"}, {"sha": "3eca850e493c7231687dddfe6ad84c54235dd696", "filename": "src/test/compile-fail/borrowck-unboxed-closures.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -26,4 +26,3 @@ fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n }\n \n fn main() {}\n-"}, {"sha": "e14df7329eac4129b76636606fee3be7551ce709", "filename": "src/test/compile-fail/borrowck-use-mut-borrow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-use-mut-borrow.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -94,4 +94,3 @@ fn main() {\n     field_deref_after_var_borrow();\n     field_deref_after_field_borrow();\n }\n-"}, {"sha": "490734d463da4ceb43eb37cde1f4fd966949d4fd", "filename": "src/test/compile-fail/closure-reform-bad.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ fn main() {\n     let f = |s: &str| println!(\"{}{}\", s, string);\n     call_bare(f)    //~ ERROR mismatched types\n }\n-"}, {"sha": "d60fb1d5d19669651b8ab45804a84efcd1196f56", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -24,4 +24,3 @@ pub fn main() {\n                         //~| expected &-ptr\n                         //~| found box\n }\n-"}, {"sha": "903365fb909f5d7de2741785336c79a3ed2acd40", "filename": "src/test/compile-fail/drop-with-active-borrows-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-with-active-borrows-1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -16,4 +16,3 @@ fn main() {\n         println!(\"{}\", *s);\n     }\n }\n-"}, {"sha": "7586bc61cd6d4e64e896c711a005a85ae8ad2a8d", "filename": "src/test/compile-fail/duplicate-parameter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fduplicate-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fduplicate-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-parameter.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,4 +13,3 @@ fn f(a: isize, a: isize) {}\n \n fn main() {\n }\n-"}, {"sha": "42b67337c64e58bccdbfdfc2890937a5b2532835", "filename": "src/test/compile-fail/duplicate-type-parameter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-type-parameter.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -36,4 +36,3 @@ impl<T,T> Qux<T,T> for Option<T> {}\n \n fn main() {\n }\n-"}, {"sha": "922e58698dd754e273fcec3315230b7c21ac29e1", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -26,4 +26,3 @@ impl<'a,'b> Foo<'a,'b> {\n }\n \n fn main() {}\n-"}, {"sha": "2553bdcbb273ef48cb3c5e33ff053cf2722a550d", "filename": "src/test/compile-fail/extern-with-type-bounds.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-with-type-bounds.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -28,4 +28,3 @@ extern \"rust-intrinsic\" {\n }\n \n fn main() {}\n-"}, {"sha": "a4524ccd9db08108f1e16dd397b5dac21fe34501", "filename": "src/test/compile-fail/feature-gate-advanced-slice-features.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ffeature-gate-advanced-slice-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ffeature-gate-advanced-slice-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-advanced-slice-features.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -16,4 +16,3 @@ fn main() {\n         [ 1, 2, xs.. ] => {}    // OK without feature gate\n     }\n }\n-"}, {"sha": "8f8b035f4a96b82b16ee2dd136df4005076f2637", "filename": "src/test/compile-fail/feature-gate-box-expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ffeature-gate-box-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ffeature-gate-box-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-box-expr.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ fn main() {\n     let x = box (HEAP) 'c'; //~ ERROR box expression syntax is experimental\n     println!(\"x: {}\", x);\n }\n-"}, {"sha": "7a0924d8adf1ba8fce115cfc36bbfb917e25f826", "filename": "src/test/compile-fail/feature-gate-start.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ffeature-gate-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ffeature-gate-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-start.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -10,4 +10,3 @@\n \n #[start]\n fn foo() {} //~ ERROR: a #[start] function is an experimental feature\n-"}, {"sha": "4163d531e870e9003046e676de9a7d6ea5898c89", "filename": "src/test/compile-fail/generic-no-mangle.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fgeneric-no-mangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fgeneric-no-mangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-no-mangle.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ fn foo<T>() {} //~ ERROR generic functions must be mangled\n \n #[no_mangle]\n extern fn foo<T>() {} //~ ERROR generic functions must be mangled\n-"}, {"sha": "3ca00fcb66ac16e1a51dbc48fa99feb96fa6a21d", "filename": "src/test/compile-fail/indexing-requires-a-uint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -23,4 +23,3 @@ fn main() {\n     bar::<isize>(i);  // i should not be re-coerced back to an isize\n     //~^ ERROR: mismatched types\n }\n-"}, {"sha": "14d22702db7a45d873bd41f8cb3c702d366f8813", "filename": "src/test/compile-fail/infinite-macro-expansion.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ macro_rules! recursive {\n fn main() {\n     recursive!()\n }\n-"}, {"sha": "e2fb0fa4f2fa518f7fe9280c959b417d052e0c4b", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -24,11 +24,11 @@ pub fn main() {\n     s.as_bytes()[3_usize];\n     s.as_bytes()[3];\n     s.as_bytes()[3u8];  //~ERROR the trait `core::ops::Index<u8>` is not implemented\n-    //~^ERROR the trait `core::ops::Index<u8>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<u8>` is not implemented\n     s.as_bytes()[3i8];  //~ERROR the trait `core::ops::Index<i8>` is not implemented\n-    //~^ERROR the trait `core::ops::Index<i8>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<i8>` is not implemented\n     s.as_bytes()[3u32]; //~ERROR the trait `core::ops::Index<u32>` is not implemented\n-    //~^ERROR the trait `core::ops::Index<u32>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<u32>` is not implemented\n     s.as_bytes()[3i32]; //~ERROR the trait `core::ops::Index<i32>` is not implemented\n-    //~^ERROR the trait `core::ops::Index<i32>` is not implemented\n+    //~^ ERROR the trait `core::ops::Index<i32>` is not implemented\n }"}, {"sha": "b83f0f73436cffe488e9f358ed532eec95f091e0", "filename": "src/test/compile-fail/intrinsic-return-address.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintrinsic-return-address.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -27,5 +27,3 @@ unsafe fn g() -> isize {\n }\n \n fn main() {}\n-\n-"}, {"sha": "3b0ea55cfa9c1550ae8927240c6b06098380dbb4", "filename": "src/test/compile-fail/issue-10536.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -29,4 +29,3 @@ pub fn main() {\n     // least throw a conventional error.\n     assert!({one! two});\n }\n-"}, {"sha": "7d8a1528aba36973a5cc86d395b82a716d36772c", "filename": "src/test/compile-fail/issue-11192.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-11192.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-11192.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11192.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -30,4 +30,3 @@ fn main() {\n     test(&*ptr);\n     //~^ ERROR: cannot borrow `*ptr` as immutable\n }\n-"}, {"sha": "2749438433d16fd150e063a693c7a5cb408e3a48", "filename": "src/test/compile-fail/issue-11593.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-11593.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-11593.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11593.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ impl private_trait_xc::Foo for Bar {}\n //~^ ERROR: trait `Foo` is private\n \n fn main() {}\n-"}, {"sha": "a6dbe954ec0aca714e14c2c5b4891fe0d824ad70", "filename": "src/test/compile-fail/issue-11844.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11844.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ fn main() {\n         None => panic!()\n     }\n }\n-"}, {"sha": "f0f4bf5ca71bb611031a86f871bdf974ce923717", "filename": "src/test/compile-fail/issue-12041.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -21,4 +21,3 @@ fn main() {\n         }\n     });\n }\n-"}, {"sha": "41cd38630013891204a37132626df3a426ed795e", "filename": "src/test/compile-fail/issue-12612.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12612.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ mod test {\n }\n \n fn main() {}\n-"}, {"sha": "f845eba406041be1106adbd4dd19a4eafffdb61b", "filename": "src/test/compile-fail/issue-13407.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-13407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-13407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13407.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod A {\n+    struct C;\n+}\n+\n+fn main() {\n+    A::C = 1;\n+    //~^ ERROR: illegal left-hand side expression\n+    //~| ERROR: mismatched types\n+}"}, {"sha": "53d1486288984477a2afe57140c08c1459a7a5bf", "filename": "src/test/compile-fail/issue-13446.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -16,4 +16,3 @@\n static VEC: [u32; 256] = vec!();\n \n fn main() {}\n-"}, {"sha": "c87dcb8ae79b21119b3b01b4ccd13b1afa1d4949", "filename": "src/test/compile-fail/issue-14092.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -11,4 +11,3 @@\n fn fn1(0: Box) {} //~ ERROR: wrong number of type arguments: expected 1, found 0\n \n fn main() {}\n-"}, {"sha": "4954c95fcd1f2ec307c4e997102ad1966024cc2c", "filename": "src/test/compile-fail/issue-16149.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -19,4 +19,3 @@ fn main() {\n         _ => false\n     };\n }\n-"}, {"sha": "ba369734daa47abd55b3b4444353e9eaa793dc96", "filename": "src/test/compile-fail/issue-16338.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ fn main() {\n     //~| expected &-ptr\n     //~| found struct `core::raw::Slice`\n }\n-"}, {"sha": "67fcd820429ce5d6f309f525de8dc200f7f10501", "filename": "src/test/compile-fail/issue-16725.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16725.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -16,4 +16,3 @@ fn main() {\n     unsafe { foo::bar(); }\n     //~^ ERROR: function `bar` is private\n }\n-"}, {"sha": "b525d5f64fc9a9d9237671479d313ff72727f030", "filename": "src/test/compile-fail/issue-16922.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-16922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16922.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::any::Any;\n+\n+fn foo<T: Any>(value: &T) -> Box<Any> {\n+    Box::new(value) as Box<Any>\n+    //~^ ERROR: cannot infer an appropriate lifetime\n+}\n+\n+fn main() {\n+    let _ = foo(&5);\n+}"}, {"sha": "6ee869d65a8f20f2078550262a1d73f25d8b4ace", "filename": "src/test/compile-fail/issue-17718-const-bad-values.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ const C2: &'static mut usize = &mut S;\n //~^^ ERROR: references in constants may only refer to immutable values\n \n fn main() {}\n-"}, {"sha": "8c2c52e6fad41d701f98eff466cebee1d5b708f0", "filename": "src/test/compile-fail/issue-18919.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-18919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-18919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18919.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+type FuncType<'f> = Fn(&isize) -> isize + 'f;\n+\n+fn ho_func(f: Option<FuncType>) {\n+    //~^ ERROR: the trait `core::marker::Sized` is not implemented for the type\n+}\n+\n+fn main() {}"}, {"sha": "9dbca997341fc24168a1aa0d5ddf8f09a0740517", "filename": "src/test/compile-fail/issue-19982.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-19982.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-19982.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19982.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+struct Foo;\n+\n+impl Fn<(&(),)> for Foo { } //~ ERROR missing lifetime specifier\n+\n+fn main() {}"}, {"sha": "e4bedbbb7e1e54d4b4c25f718304954a0f82b4a3", "filename": "src/test/compile-fail/issue-20225.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+struct Foo;\n+\n+impl<'a, T> Fn<(&'a T,)> for Foo {\n+  type Output = ();\n+\n+  extern \"rust-call\" fn call(&self, (_,): (T,)) {}\n+  //~^ ERROR: has an incompatible type for trait: expected &-ptr\n+}\n+\n+fn main() {}"}, {"sha": "33e00f9a823ca11391bb076f2cb913b8512cb25f", "filename": "src/test/compile-fail/issue-20261.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    for (ref i,) in [].iter() { //~ ERROR: type mismatch resolving\n+        i.clone();\n+        //~^ ERROR: the type of this value must be known in this context\n+        //~| ERROR: reached the recursion limit while auto-dereferencing\n+    }\n+}"}, {"sha": "cb322f00723d289dcd58609ba96bf21cc7ede6c5", "filename": "src/test/compile-fail/issue-20714.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-20714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-20714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20714.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct G;\n+\n+fn main() {\n+    let g = G(); //~ ERROR: expected function, found `G`\n+}"}, {"sha": "c744dff0c04d46231f9b5385f317e061c87aa73e", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ struct bar { x: bar }\n \n fn main() {\n }\n-"}, {"sha": "a3d90a00d038ec14a4d2e218e20b167ddc8b88df", "filename": "src/test/compile-fail/issue-3907.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3907.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -28,4 +28,3 @@ fn main() {\n     };\n     s.bar();\n }\n-"}, {"sha": "02e5b9b092197f94b08fe0a7452081a22002fe78", "filename": "src/test/compile-fail/issue-5844.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-5844.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-5844.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5844.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ extern crate issue_5844_aux;\n fn main () {\n     issue_5844_aux::rand(); //~ ERROR: requires unsafe\n }\n-"}, {"sha": "40c3d96bc9a119fb9eaf2bc3b5a5790df8d87d89", "filename": "src/test/compile-fail/issue-7607-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7607-1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ impl Fo { //~ ERROR use of undeclared type name `Fo`\n }\n \n fn main() {}\n-"}, {"sha": "9abd8c9e3fcda2acfa5c6b16255dcff546913d20", "filename": "src/test/compile-fail/issue-8767.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8767.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ impl B { //~ ERROR use of undeclared type name `B`\n \n fn main() {\n }\n-"}, {"sha": "d5bfe3d16925c70b1b76a3ac8390c3a18fef64a4", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -80,4 +80,3 @@ fn test<'a,T,U:Copy>(_: &'a isize) {\n \n pub fn main() {\n }\n-"}, {"sha": "bf2a209c4c48ed01a16223d5f0eaa474fef7a4eb", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ fn main() {\n     bar(move|| foo(x));\n     //~^ ERROR `core::marker::Send` is not implemented\n }\n-"}, {"sha": "1fa7284f6b5dcab6e7a2726173b2c2ed7f34c427", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -37,4 +37,3 @@ fn i(_x: isize) -> &isize { //~ ERROR missing lifetime specifier\n }\n \n fn main() {}\n-"}, {"sha": "8343f718902dc02f7ec291d1b69812b7bd906d3b", "filename": "src/test/compile-fail/linkage3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage3.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ extern {\n fn main() {\n     println!(\"{:?}\", foo);\n }\n-"}, {"sha": "13ee3f163616e8ccf207d9f283bed3fbebd30a4b", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -19,7 +19,7 @@ extern crate libc;\n \n pub use extern_foo as x;\n extern {\n-    fn extern_foo();\n+    pub fn extern_foo();\n }\n \n struct Foo; //~ ERROR: struct is never used"}, {"sha": "171dedd5b2e5881ce5422307c2ee7188666d1e04", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -60,4 +60,3 @@ fn main() {\n       let n = 1_isize << std::isize::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n       let n = 1_usize << std::usize::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n }\n-"}, {"sha": "44a36f215f3d4c6e8c2100e0954635da8674e1de", "filename": "src/test/compile-fail/lint-stability3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -22,4 +22,3 @@ use lint_stability::*;\n fn main() {\n     macro_test_arg_nested!(deprecated_text);\n }\n-"}, {"sha": "517be0eb8acd9e6c869ec244338fb05bb67d33e9", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -40,4 +40,3 @@ fn main() {\n \n     let _ = Something { X: 0 };\n }\n-"}, {"sha": "abf0ed420e7a26c59cf03009f84cdcaae0e8364d", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -29,4 +29,3 @@ fn main() {\n     //~^^ ERROR unresolved name `a::bar`\n     b::bar();\n }\n-"}, {"sha": "0469a9d1cc859fd57c89674df4b50007a4d403b2", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -28,4 +28,3 @@ fn main() {\n     a::bar(); //~ ERROR unresolved name `a::bar`\n     b::bar();\n }\n-"}, {"sha": "c251ce6a3c834960942f371f538b704cb7e6294b", "filename": "src/test/compile-fail/manual-link-bad-form.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-form.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-form.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-form.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,5 +13,3 @@\n \n fn main() {\n }\n-\n-"}, {"sha": "5ab073c33bcb310e15588af7249852e143f069c8", "filename": "src/test/compile-fail/manual-link-bad-kind.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmanual-link-bad-kind.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,4 +13,3 @@\n \n fn main() {\n }\n-"}, {"sha": "c1d4551fd9ec44784fc594ab5a763320508b0eb0", "filename": "src/test/compile-fail/method-ambig-two-traits-cross-crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-ambig-two-traits-cross-crate.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -19,4 +19,3 @@ trait me2 {\n }\n impl me2 for usize { fn me(&self) -> usize { *self } }\n fn main() { 1_usize.me(); } //~ ERROR E0034\n-"}, {"sha": "b13d4250ee958574256c4493c0e3416099a35fb1", "filename": "src/test/compile-fail/method-missing-call.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-missing-call.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -40,4 +40,3 @@ fn main() {\n               .filter_map; //~ ERROR attempted to take value of method `filter_map` on type\n               //~^ HELP maybe a `()` to call it is missing\n }\n-"}, {"sha": "73982fa2811a0871d2713fdddb82921a73de1395", "filename": "src/test/compile-fail/mut-cross-borrowing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmut-cross-borrowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fmut-cross-borrowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-cross-borrowing.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -16,4 +16,3 @@ fn main() {\n     let mut x: Box<_> = box 3;\n     f(x)    //~ ERROR mismatched types\n }\n-"}, {"sha": "36356cb7d527e2442b1bfdccdf7ca520acc1bc49", "filename": "src/test/compile-fail/object-safety-by-value-self-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self-use.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -26,4 +26,3 @@ fn use_bar(t: Box<Bar>) {\n }\n \n fn main() { }\n-"}, {"sha": "bc18b52a0c1c9e3f8fdfd0f65994e4e2e0daf464", "filename": "src/test/compile-fail/opt-in-copy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fopt-in-copy.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -30,4 +30,3 @@ impl Copy for IWantToCopyThisToo {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n \n fn main() {}\n-"}, {"sha": "c4019fa22097a92391cb533d7fd144df0101eefa", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -31,4 +31,3 @@ fn main() {\n     };\n     drop(s(3))  //~ ERROR cannot use call notation\n }\n-"}, {"sha": "da2a97b0ca8abb4bb999f2693b367033b3d685ca", "filename": "src/test/compile-fail/pattern-bindings-after-at.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -23,4 +23,3 @@ fn main() {\n         _ => ()\n     }\n }\n-"}, {"sha": "0b7886842b49e002cf60699b42561cde22118ff1", "filename": "src/test/compile-fail/pattern-ident-path-generics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fpattern-ident-path-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fpattern-ident-path-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-ident-path-generics.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -14,4 +14,3 @@ fn main() {\n         Some(_) => {}\n     }\n }\n-"}, {"sha": "67dccb4c93e1ac0e6bb4fb6ed89610f2fe7a6923", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -27,10 +27,6 @@ mod bar {\n \n     // can't publicly re-export private items\n     pub use self::baz::{foo, bar};\n-    //~^ ERROR: function `bar` is private\n-\n-    pub use self::private::ppriv;\n-    //~^ ERROR: function `ppriv` is private\n \n     pub struct A;\n     impl A {\n@@ -61,10 +57,8 @@ mod bar {\n             fn bar2(&self) {}\n         }\n \n-        // both of these are re-exported by `bar`, but only one should be\n-        // validly re-exported\n         pub fn foo() {}\n-        fn bar() {}\n+        pub fn bar() {}\n     }\n \n     extern {\n@@ -92,10 +86,6 @@ mod bar {\n         pub fn gpub() {}\n         fn gpriv() {}\n     }\n-\n-    mod private {\n-        fn ppriv() {}\n-    }\n }\n \n pub fn gpub() {}\n@@ -142,13 +132,13 @@ mod foo {\n \n         ::bar::baz::foo(); //~ ERROR: function `foo` is inaccessible\n                            //~^ NOTE: module `baz` is private\n-        ::bar::baz::bar(); //~ ERROR: function `bar` is private\n+        ::bar::baz::bar(); //~ ERROR: function `bar` is inaccessible\n     }\n \n     fn test2() {\n         use bar::baz::{foo, bar};\n         //~^ ERROR: function `foo` is inaccessible\n-        //~^^ ERROR: function `bar` is private\n+        //~^^ ERROR: function `bar` is inaccessible\n         foo();\n         bar();\n     }"}, {"sha": "b73c283fa515e3527f1a745893876a2d2f5d49be", "filename": "src/test/compile-fail/region-bound-on-closure-outlives-call.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-bound-on-closure-outlives-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-bound-on-closure-outlives-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bound-on-closure-outlives-call.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -13,4 +13,3 @@ fn call_rec<F>(mut f: F) -> usize where F: FnMut(usize) -> usize {\n }\n \n fn main() {}\n-"}, {"sha": "1e615be9d6acc57a452f69059a0cda171c0697dc", "filename": "src/test/compile-fail/region-object-lifetime-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -26,4 +26,3 @@ fn borrowed_receiver_same_lifetime<'a>(x: &'a Foo) -> &'a () {\n \n #[rustc_error]\n fn main() {} //~ ERROR compilation successful\n-"}, {"sha": "e011b8f56972be4d1818665aeaf7021ed3dfdafc", "filename": "src/test/compile-fail/region-object-lifetime-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -21,4 +21,3 @@ fn borrowed_receiver_different_lifetimes<'a,'b>(x: &'a Foo) -> &'b () {\n }\n \n fn main() {}\n-"}, {"sha": "84dd97643a107ab88370cd4eaf1dee394d3873ca", "filename": "src/test/compile-fail/region-object-lifetime-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-3.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -26,4 +26,3 @@ fn borrowed_receiver_related_lifetimes<'a,'b>(x: &'a (Foo+'b)) -> &'a () {\n \n #[rustc_error]\n fn main() {} //~ ERROR compilation successful\n-"}, {"sha": "0a68e7f1076caffab8c67f7fec2c567d046f88cd", "filename": "src/test/compile-fail/region-object-lifetime-4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-4.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -23,4 +23,3 @@ fn borrowed_receiver_related_lifetimes2<'a,'b>(x: &'a (Foo+'b)) -> &'b () {\n }\n \n fn main() {}\n-"}, {"sha": "26aad0e33b1b4ff3da1b3c7e339df1a83fd72983", "filename": "src/test/compile-fail/region-object-lifetime-5.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-5.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -22,4 +22,3 @@ fn owned_receiver(x: Box<Foo>) -> &'static () {\n }\n \n fn main() {}\n-"}, {"sha": "5db9a01c01286760b8e5c6c6fd9c68365e8f02d5", "filename": "src/test/compile-fail/regionck-unboxed-closure-lifetimes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ fn main() {\n         f = move |a: isize, b: isize| { a + b + *c_ref };\n     }\n }\n-"}, {"sha": "f80b0ffa5aadf09eb20cc9447601b900dc949f3c", "filename": "src/test/compile-fail/regions-close-associated-type-into-object.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -84,4 +84,3 @@ fn meh1<'a, T: Iter>(v: &'a T) -> Box<X+'a>\n }\n \n fn main() {}\n-"}, {"sha": "4c831a2b65953d15aae100091a9ca609251646dd", "filename": "src/test/compile-fail/regions-close-object-into-object-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -25,4 +25,3 @@ fn f<'a, T:'static, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n }\n \n fn main() {}\n-"}, {"sha": "b723efff3c902e182d6140d1045c7bcf3018bbb3", "filename": "src/test/compile-fail/regions-close-object-into-object-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -24,4 +24,3 @@ fn h<'a, T, U>(v: Box<A<U>+'static>) -> Box<X+'static> {\n }\n \n fn main() {}\n-"}, {"sha": "9b311588bb1ea7275312ead2b05331dc1efaca0b", "filename": "src/test/compile-fail/regions-close-object-into-object-4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -23,4 +23,3 @@ fn i<'a, T, U>(v: Box<A<U>+'a>) -> Box<X+'static> {\n }\n \n fn main() {}\n-"}, {"sha": "f3b5ccabe79eb7afef291eea61b5b03b2e599f17", "filename": "src/test/compile-fail/regions-close-object-into-object-5.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -27,4 +27,3 @@ fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n }\n \n fn main() {}\n-"}, {"sha": "7324d4a4a0ed624e314b3ed46eb80c90ac9576b3", "filename": "src/test/compile-fail/regions-close-param-into-object.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -37,4 +37,3 @@ fn p4<'a,T>(v: Box<T>) -> Box<X+'a>\n }\n \n fn main() {}\n-"}, {"sha": "af3ee7f353731c13141ce7b07fdcad5cf5d69d84", "filename": "src/test/compile-fail/resolve-conflict-extern-crate-vs-extern-crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-extern-crate-vs-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-extern-crate-vs-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-extern-crate-vs-extern-crate.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -12,4 +12,3 @@ extern crate std;\n //~^ ERROR an external crate named `std` has already been imported\n \n fn main(){}\n-"}, {"sha": "0c601a81178b3ad28fcc71a301491f016ead71b6", "filename": "src/test/compile-fail/resolve-conflict-import-vs-extern-crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-import-vs-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-import-vs-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-import-vs-extern-crate.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -12,4 +12,3 @@ use std::slice as std; //~ ERROR import `std` conflicts with imported crate\n \n fn main() {\n }\n-"}, {"sha": "10afe82f2ef0fc65a347623e92b95ba81b4601b7", "filename": "src/test/compile-fail/resolve-conflict-import-vs-import.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-import-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-import-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-import-vs-import.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -14,4 +14,3 @@ use std::mem::transmute;\n \n fn main() {\n }\n-"}, {"sha": "e685353592f52cd8684777fbcc56529dc19a4555", "filename": "src/test/compile-fail/resolve-conflict-item-vs-extern-crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-extern-crate.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -12,4 +12,3 @@ fn std() {}    //~ ERROR the name `std` conflicts with an external crate\n \n fn main() {\n }\n-"}, {"sha": "1edf815ecaeca402f5b6be30fef47213f07d8dec", "filename": "src/test/compile-fail/resolve-conflict-item-vs-import.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ fn transmute() {}\n \n fn main() {\n }\n-"}, {"sha": "fd4dce51fc8dbe17e9b6ee4db8002c92928a4f29", "filename": "src/test/compile-fail/resolve-unknown-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-unknown-trait.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ impl SomeNonExistentTrait for isize {}\n \n fn f<T:SomeNonExistentTrait>() {}\n //~^ ERROR use of undeclared trait name `SomeNonExistentTrait`\n-"}, {"sha": "e847d3324169ce7a5d17cdbecdf837afd224fe8d", "filename": "src/test/compile-fail/shadowing-in-the-same-pattern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fshadowing-in-the-same-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fshadowing-in-the-same-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowing-in-the-same-pattern.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ fn f((a, a): (isize, isize)) {} //~ ERROR identifier `a` is bound more than once\n fn main() {\n     let (a, a) = (1, 1);    //~ ERROR identifier `a` is bound more than once\n }\n-"}, {"sha": "422cf630429ca85c835c3bb1f9ce309f8e9b388f", "filename": "src/test/compile-fail/static-array-across-crate.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fstatic-array-across-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fstatic-array-across-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-array-across-crate.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:pub_static_array.rs\n+\n+extern crate \"pub_static_array\" as array;\n+\n+use array::ARRAY;\n+\n+static X: &'static u8 = &ARRAY[0];\n+//~^ ERROR: cannot refer to the interior of another static, use a constant\n+\n+pub fn main() {}"}, {"sha": "b8be7d0cdc20a59aa6f03d8e2d2beaba82c4a41f", "filename": "src/test/compile-fail/struct-variant-privacy-xc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-variant-privacy-xc.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ fn f(b: struct_variant_privacy::Bar) { //~ ERROR enum `Bar` is private\n }\n \n fn main() {}\n-"}, {"sha": "02c4f3d5d5268fd5fcc46ee291c0372d336ce88f", "filename": "src/test/compile-fail/structure-constructor-type-mismatch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -62,4 +62,3 @@ fn main() {\n         y: 10,\n     };\n }\n-"}, {"sha": "1fd711ca4fb2c4eb898df30eaacf112ae0307693", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -14,4 +14,3 @@ fn main() {\n     TraitNotAStruct{ value: 0 };\n     //~^ ERROR: use of trait `TraitNotAStruct` as a struct constructor [E0159]\n }\n-"}, {"sha": "217540415a7dd185c3b7f2c42f417729cfe29416", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -32,4 +32,3 @@ struct ZipIterator<T, U> {\n }\n \n fn main() {}\n-"}, {"sha": "e126a3040e99277741f5910c278787d49216d29b", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,7 +15,7 @@ trait Foo {\n // This should emit the less confusing error, not the more confusing one.\n \n fn foo(_x: Foo + Send) {\n-    //~^ERROR the trait `core::marker::Sized` is not implemented\n+    //~^ ERROR the trait `core::marker::Sized` is not implemented\n }\n \n fn main() { }"}, {"sha": "d39b7e15edc34e9d2f7e2b20839c9258ee62882f", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-locals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -25,4 +25,3 @@ fn main() {\n     let baz: Foo<usize> = panic!();\n     //~^ ERROR not implemented\n }\n-"}, {"sha": "d93c9bafaef27c36c205a5e933f106810aac50f1", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-static.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-static.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -23,4 +23,3 @@ static X: Foo<usize> = Foo {\n \n fn main() {\n }\n-"}, {"sha": "5f95a7ca6e20455ba2959975c8228334fbee5ebd", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-xc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -22,4 +22,3 @@ fn kaboom(y: Bar<f32>) {}\n \n fn main() {\n }\n-"}, {"sha": "840787022e65cc736d40a70d35087032bdc81e7e", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-xc1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-xc1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -23,4 +23,3 @@ fn main() {\n     //~^ ERROR not implemented\n     let _ = bar;\n }\n-"}, {"sha": "ce0a7d3bb36cf1bca80b0de8ba253f9450c2335d", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -66,4 +66,3 @@ impl PolyTrait<Foo<usize>> for Struct {\n \n fn main() {\n }\n-"}, {"sha": "9ba017e150e6112a1f1c3f4db1f2d6da1d7188e3", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -28,4 +28,3 @@ fn main() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let s: Box<Trait<&'static str>> = Box::new(Struct { person: person });\n }\n-"}, {"sha": "918589b8fd3ac0f665d45b57e716d26f8234ff61", "filename": "src/test/compile-fail/transmute-different-sizes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -25,5 +25,3 @@ unsafe fn g<T>(x: &T) {\n }\n \n fn main() {}\n-\n-"}, {"sha": "71e9113603a6061a50e20fa57dd62ae06cc7022f", "filename": "src/test/compile-fail/type-params-in-different-spaces-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-2.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -29,4 +29,3 @@ trait B<T>: Tr<T> {\n \n fn main() {\n }\n-"}, {"sha": "3ad1e9ab538dbac58c286d07977659f9bf429d63", "filename": "src/test/compile-fail/type-params-in-different-spaces-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-3.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ trait Tr : Sized {\n }\n \n fn main() {}\n-"}, {"sha": "5d2b5fa52db41b29910a9952974f2c2258f12358", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -63,4 +63,3 @@ fn main() {\n     };\n     println!(\"{} {}\", bar.foo(2), bar.bar(2));\n }\n-"}, {"sha": "8e60064beca170487a7b0834d63e90d86f62d4e6", "filename": "src/test/compile-fail/ufcs-qpath-self-mismatch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-self-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-self-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-self-mismatch.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -18,4 +18,3 @@ fn main() {\n     <i32 as Add<i32>>::add(1, 2u32);\n     //~^ ERROR mismatched types\n }\n-"}, {"sha": "b195a932acaa63d21e6a304fb1d5202d39d10896", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ type Typedef = isize;\n fn g<F:Typedef(isize) -> isize>(x: F) {} //~ ERROR `Typedef` is not a trait\n \n fn main() {}\n-"}, {"sha": "55156e28cd703e3e33b75ebf58028076a9e01fdd", "filename": "src/test/compile-fail/unboxed-closure-sugar-not-used-on-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-not-used-on-fn.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ fn bar2<T>(x: &T) where T: Fn<()> {\n }\n \n fn main() { }\n-"}, {"sha": "1e36c47c0973b443b5104abcf31245495554a81f", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct-1.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -22,4 +22,3 @@ fn bar() {\n }\n \n fn main() { }\n-"}, {"sha": "f50d91a4ddd9faf571eed087af1e867f1d394942", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -20,4 +20,3 @@ fn foo(b: Box<Bar()>) {\n }\n \n fn main() { }\n-"}, {"sha": "e6e18d996b9e2e7adce47d19f41e49daa46c2204", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -17,4 +17,3 @@ fn f<F:Trait(isize) -> isize>(x: F) {}\n //~| ERROR no associated type `Output`\n \n fn main() {}\n-"}, {"sha": "92e6affa4c2027f4dd28f9fa80664a3c9cf96c73", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -35,4 +35,3 @@ fn main() {\n     //~^ ERROR not implemented\n     //~| ERROR not implemented\n }\n-"}, {"sha": "226b516e09db26730b5b64e9aec3234f33fd2315", "filename": "src/test/compile-fail/unboxed-closures-infer-explicit-call-too-early.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -15,4 +15,3 @@ fn main() {\n     let () = zero.call_mut(());\n     //~^ ERROR we have not yet inferred what kind of closure it is\n }\n-"}, {"sha": "7c5ea031596563b71a8868e7dfed7f4b5ea7c10d", "filename": "src/test/compile-fail/unboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -29,4 +29,3 @@ fn main() {\n \n     tick2(); //~ ERROR cannot borrow\n }\n-"}, {"sha": "1a52e22419eb46c6c59a61b2f505ec0c235d00c2", "filename": "src/test/compile-fail/unboxed-closures-static-call-wrong-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba21228e0e539a665ce14ab3a176e30e57f822/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs?ref=31ba21228e0e539a665ce14ab3a176e30e57f822", "patch": "@@ -16,4 +16,3 @@ fn main() {\n     let mut_ = to_fn_mut(|x| x);\n     mut_.call((0, )); //~ ERROR does not implement any method in scope named `call`\n }\n-"}]}