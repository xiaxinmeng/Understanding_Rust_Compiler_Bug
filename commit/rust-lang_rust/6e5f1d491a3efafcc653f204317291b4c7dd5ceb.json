{"sha": "6e5f1d491a3efafcc653f204317291b4c7dd5ceb", "node_id": "C_kwDOAAsO6NoAKDZlNWYxZDQ5MWEzZWZhZmNjNjUzZjIwNDMxNzI5MWI0YzdkZDVjZWI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-05T05:12:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-05T05:12:58Z"}, "message": "Rollup merge of #98854 - kadiwa4:rustc_hir_pretty_clean_up_borrowing, r=oli-obk\n\nclean up the borrowing in rustc_hir_pretty\n\nA whole lot of the `&`s and `ref`s were redundant. I hope doing this in one big commit is fine, because all of the changes are pretty self-contained.\n\n`@rustbot` label: +C-cleanup", "tree": {"sha": "613cb5d320e6d0be377a97aaeb43a441bb89edc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/613cb5d320e6d0be377a97aaeb43a441bb89edc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5f1d491a3efafcc653f204317291b4c7dd5ceb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiw8haCRBK7hj4Ov3rIwAA2sQIAD5rQH3C1PZ6lzYnOZizQlHc\n7qb+cG113c6u+fH8vUwUll/dcm8uGzO174HCB7TkIFaIoPKiXMZMbccSN8JuHKO4\n3rWAx2ALVutFc4iyoIPM6dRZ8RTbwavHfmnnsfILpK2avzIJdH8MtSaa+BSzqm5k\nxi6b0Z2FpSNIAKkkHNl9DVMuQI2uPb6aR1gpu1J1jCjU+N8zaQDtcLe0Xha7TBJ2\nnZdfHFhfmflXTGccAEHQFVB9I3XwtViB4+DJaT1U95BA/7CyNeAl9rlXR1bjKhL0\nIHT9v/sK/XqTycZsH7qbcGT9iBvTSh62a/lwoK6uKiqdQlP+agnCZUvAh3bFi0M=\n=zy9Q\n-----END PGP SIGNATURE-----\n", "payload": "tree 613cb5d320e6d0be377a97aaeb43a441bb89edc3\nparent 7702c50ea51650bc173368f635ce868820b484c7\nparent 46ccde4408ebbab3bae249072bb486b9b25d9e96\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656997978 +0530\ncommitter GitHub <noreply@github.com> 1656997978 +0530\n\nRollup merge of #98854 - kadiwa4:rustc_hir_pretty_clean_up_borrowing, r=oli-obk\n\nclean up the borrowing in rustc_hir_pretty\n\nA whole lot of the `&`s and `ref`s were redundant. I hope doing this in one big commit is fine, because all of the changes are pretty self-contained.\n\n`@rustbot` label: +C-cleanup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5f1d491a3efafcc653f204317291b4c7dd5ceb", "html_url": "https://github.com/rust-lang/rust/commit/6e5f1d491a3efafcc653f204317291b4c7dd5ceb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5f1d491a3efafcc653f204317291b4c7dd5ceb/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7702c50ea51650bc173368f635ce868820b484c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7702c50ea51650bc173368f635ce868820b484c7", "html_url": "https://github.com/rust-lang/rust/commit/7702c50ea51650bc173368f635ce868820b484c7"}, {"sha": "46ccde4408ebbab3bae249072bb486b9b25d9e96", "url": "https://api.github.com/repos/rust-lang/rust/commits/46ccde4408ebbab3bae249072bb486b9b25d9e96", "html_url": "https://github.com/rust-lang/rust/commit/46ccde4408ebbab3bae249072bb486b9b25d9e96"}], "stats": {"total": 545, "additions": 264, "deletions": 281}, "files": [{"sha": "50acb0270b0bee7fe6199c2f2feff4d928710d6c", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 264, "deletions": 281, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/6e5f1d491a3efafcc653f204317291b4c7dd5ceb/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5f1d491a3efafcc653f204317291b4c7dd5ceb/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=6e5f1d491a3efafcc653f204317291b4c7dd5ceb", "patch": "@@ -59,7 +59,7 @@ impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::ForeignItem(id) => state.print_foreign_item(self.foreign_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat),\n+            Nested::BodyParamPat(id, i) => state.print_pat(self.body(id).params[i].pat),\n         }\n     }\n }\n@@ -74,37 +74,37 @@ pub struct State<'a> {\n impl<'a> State<'a> {\n     pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n-            Node::Param(a) => self.print_param(&a),\n-            Node::Item(a) => self.print_item(&a),\n-            Node::ForeignItem(a) => self.print_foreign_item(&a),\n+            Node::Param(a) => self.print_param(a),\n+            Node::Item(a) => self.print_item(a),\n+            Node::ForeignItem(a) => self.print_foreign_item(a),\n             Node::TraitItem(a) => self.print_trait_item(a),\n             Node::ImplItem(a) => self.print_impl_item(a),\n-            Node::Variant(a) => self.print_variant(&a),\n-            Node::AnonConst(a) => self.print_anon_const(&a),\n-            Node::Expr(a) => self.print_expr(&a),\n-            Node::Stmt(a) => self.print_stmt(&a),\n-            Node::PathSegment(a) => self.print_path_segment(&a),\n-            Node::Ty(a) => self.print_type(&a),\n-            Node::TypeBinding(a) => self.print_type_binding(&a),\n-            Node::TraitRef(a) => self.print_trait_ref(&a),\n-            Node::Pat(a) => self.print_pat(&a),\n-            Node::Arm(a) => self.print_arm(&a),\n+            Node::Variant(a) => self.print_variant(a),\n+            Node::AnonConst(a) => self.print_anon_const(a),\n+            Node::Expr(a) => self.print_expr(a),\n+            Node::Stmt(a) => self.print_stmt(a),\n+            Node::PathSegment(a) => self.print_path_segment(a),\n+            Node::Ty(a) => self.print_type(a),\n+            Node::TypeBinding(a) => self.print_type_binding(a),\n+            Node::TraitRef(a) => self.print_trait_ref(a),\n+            Node::Pat(a) => self.print_pat(a),\n+            Node::Arm(a) => self.print_arm(a),\n             Node::Infer(_) => self.word(\"_\"),\n             Node::Block(a) => {\n                 // Containing cbox, will be closed by print-block at `}`.\n                 self.cbox(INDENT_UNIT);\n                 // Head-ibox, will be closed by print-block after `{`.\n                 self.ibox(0);\n-                self.print_block(&a)\n+                self.print_block(a);\n             }\n-            Node::Lifetime(a) => self.print_lifetime(&a),\n+            Node::Lifetime(a) => self.print_lifetime(a),\n             Node::GenericParam(_) => panic!(\"cannot print Node::GenericParam\"),\n             Node::Field(_) => panic!(\"cannot print Node::Field\"),\n             // These cases do not carry enough information in the\n             // `hir_map` to reconstruct their full structure for pretty\n             // printing.\n             Node::Ctor(..) => panic!(\"cannot print isolated Ctor\"),\n-            Node::Local(a) => self.print_local_decl(&a),\n+            Node::Local(a) => self.print_local_decl(a),\n             Node::Crate(..) => panic!(\"cannot print Crate\"),\n         }\n     }\n@@ -266,7 +266,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr<'_>]) {\n-        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span);\n     }\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n@@ -287,9 +287,9 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n         match ty.kind {\n-            hir::TyKind::Slice(ref ty) => {\n+            hir::TyKind::Slice(ty) => {\n                 self.word(\"[\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.word(\"]\");\n             }\n             hir::TyKind::Ptr(ref mt) => {\n@@ -304,23 +304,16 @@ impl<'a> State<'a> {\n             hir::TyKind::Never => {\n                 self.word(\"!\");\n             }\n-            hir::TyKind::Tup(ref elts) => {\n+            hir::TyKind::Tup(elts) => {\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, ty| s.print_type(&ty));\n+                self.commasep(Inconsistent, elts, |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            hir::TyKind::BareFn(ref f) => {\n-                self.print_ty_fn(\n-                    f.abi,\n-                    f.unsafety,\n-                    &f.decl,\n-                    None,\n-                    &f.generic_params,\n-                    f.param_names,\n-                );\n+            hir::TyKind::BareFn(f) => {\n+                self.print_ty_fn(f.abi, f.unsafety, f.decl, None, f.generic_params, f.param_names);\n             }\n             hir::TyKind::OpaqueDef(..) => self.word(\"/*impl Trait*/\"),\n             hir::TyKind::Path(ref qpath) => self.print_qpath(qpath, false),\n@@ -344,9 +337,9 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime);\n                 }\n             }\n-            hir::TyKind::Array(ref ty, ref length) => {\n+            hir::TyKind::Array(ty, ref length) => {\n                 self.word(\"[\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.word(\"; \");\n                 self.print_array_length(length);\n                 self.word(\"]\");\n@@ -373,7 +366,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(self.attrs(item.hir_id()));\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, ref arg_names, ref generics) => {\n+            hir::ForeignItemKind::Fn(decl, arg_names, generics) => {\n                 self.head(\"\");\n                 self.print_fn(\n                     decl,\n@@ -392,14 +385,14 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end() // end the outer fn box\n             }\n-            hir::ForeignItemKind::Static(ref t, m) => {\n+            hir::ForeignItemKind::Static(t, m) => {\n                 self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n-                self.print_type(&t);\n+                self.print_type(t);\n                 self.word(\";\");\n                 self.end(); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -442,7 +435,7 @@ impl<'a> State<'a> {\n     ) {\n         self.word_space(\"type\");\n         self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         if let Some(bounds) = bounds {\n             self.print_bounds(\":\", bounds);\n         }\n@@ -463,7 +456,7 @@ impl<'a> State<'a> {\n     ) {\n         self.head(\"type\");\n         self.print_ident(item.ident);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         self.end(); // end the inner ibox\n \n         self.print_where_clause(generics);\n@@ -494,7 +487,7 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            hir::ItemKind::Use(ref path, kind) => {\n+            hir::ItemKind::Use(path, kind) => {\n                 self.head(\"use\");\n                 self.print_path(path, false);\n \n@@ -513,14 +506,14 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            hir::ItemKind::Static(ref ty, m, expr) => {\n+            hir::ItemKind::Static(ty, m, expr) => {\n                 self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.space();\n                 self.end(); // end the head-ibox\n \n@@ -529,11 +522,11 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n-            hir::ItemKind::Const(ref ty, expr) => {\n+            hir::ItemKind::Const(ty, expr) => {\n                 self.head(\"const\");\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.space();\n                 self.end(); // end the head-ibox\n \n@@ -542,10 +535,10 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n-            hir::ItemKind::Fn(ref sig, ref param_names, body) => {\n+            hir::ItemKind::Fn(ref sig, param_names, body) => {\n                 self.head(\"\");\n                 self.print_fn(\n-                    &sig.decl,\n+                    sig.decl,\n                     sig.header,\n                     Some(item.ident.name),\n                     param_names,\n@@ -578,22 +571,22 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::GlobalAsm(ref asm) => {\n+            hir::ItemKind::GlobalAsm(asm) => {\n                 self.head(\"global_asm!\");\n                 self.print_inline_asm(asm);\n                 self.end()\n             }\n-            hir::ItemKind::TyAlias(ref ty, ref generics) => {\n-                self.print_item_type(item, &generics, |state| {\n+            hir::ItemKind::TyAlias(ty, generics) => {\n+                self.print_item_type(item, generics, |state| {\n                     state.word_space(\"=\");\n-                    state.print_type(&ty);\n+                    state.print_type(ty);\n                 });\n             }\n             hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n-                self.print_item_type(item, &opaque_ty.generics, |state| {\n+                self.print_item_type(item, opaque_ty.generics, |state| {\n                     let mut real_bounds = Vec::with_capacity(opaque_ty.bounds.len());\n-                    for b in opaque_ty.bounds.iter() {\n-                        if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                    for b in opaque_ty.bounds {\n+                        if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n                             state.space();\n                             state.word_space(\"for ?\");\n                             state.print_trait_ref(&ptr.trait_ref);\n@@ -604,73 +597,73 @@ impl<'a> State<'a> {\n                     state.print_bounds(\"= impl\", real_bounds);\n                 });\n             }\n-            hir::ItemKind::Enum(ref enum_definition, ref params) => {\n+            hir::ItemKind::Enum(ref enum_definition, params) => {\n                 self.print_enum_def(enum_definition, params, item.ident.name, item.span);\n             }\n-            hir::ItemKind::Struct(ref struct_def, ref generics) => {\n+            hir::ItemKind::Struct(ref struct_def, generics) => {\n                 self.head(\"struct\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n-            hir::ItemKind::Union(ref struct_def, ref generics) => {\n+            hir::ItemKind::Union(ref struct_def, generics) => {\n                 self.head(\"union\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n-            hir::ItemKind::Impl(hir::Impl {\n+            hir::ItemKind::Impl(&hir::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 constness,\n                 defaultness_span: _,\n-                ref generics,\n+                generics,\n                 ref of_trait,\n-                ref self_ty,\n+                self_ty,\n                 items,\n             }) => {\n                 self.head(\"\");\n-                self.print_defaultness(*defaultness);\n-                self.print_unsafety(*unsafety);\n+                self.print_defaultness(defaultness);\n+                self.print_unsafety(unsafety);\n                 self.word_nbsp(\"impl\");\n \n                 if !generics.params.is_empty() {\n-                    self.print_generic_params(&generics.params);\n+                    self.print_generic_params(generics.params);\n                     self.space();\n                 }\n \n-                if *constness == hir::Constness::Const {\n+                if constness == hir::Constness::Const {\n                     self.word_nbsp(\"const\");\n                 }\n \n                 if let hir::ImplPolarity::Negative(_) = polarity {\n                     self.word(\"!\");\n                 }\n \n-                if let Some(ref t) = of_trait {\n+                if let Some(t) = of_trait {\n                     self.print_trait_ref(t);\n                     self.space();\n                     self.word_space(\"for\");\n                 }\n \n-                self.print_type(&self_ty);\n+                self.print_type(self_ty);\n                 self.print_where_clause(generics);\n \n                 self.space();\n                 self.bopen();\n                 self.print_inner_attributes(attrs);\n-                for impl_item in *items {\n+                for impl_item in items {\n                     self.ann.nested(self, Nested::ImplItem(impl_item.id));\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, trait_items) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, generics, bounds, trait_items) => {\n                 self.head(\"\");\n                 self.print_is_auto(is_auto);\n                 self.print_unsafety(unsafety);\n                 self.word_nbsp(\"trait\");\n                 self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n+                self.print_generic_params(generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                for b in bounds {\n+                    if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -687,14 +680,14 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            hir::ItemKind::TraitAlias(generics, bounds) => {\n                 self.head(\"trait\");\n                 self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n+                self.print_generic_params(generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                for b in bounds {\n+                    if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -714,7 +707,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_ref(&mut self, t: &hir::TraitRef<'_>) {\n-        self.print_path(&t.path, false)\n+        self.print_path(t.path, false);\n     }\n \n     fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam<'_>]) {\n@@ -726,8 +719,8 @@ impl<'a> State<'a> {\n     }\n \n     fn print_poly_trait_ref(&mut self, t: &hir::PolyTraitRef<'_>) {\n-        self.print_formal_generic_params(&t.bound_generic_params);\n-        self.print_trait_ref(&t.trait_ref)\n+        self.print_formal_generic_params(t.bound_generic_params);\n+        self.print_trait_ref(&t.trait_ref);\n     }\n \n     pub fn print_enum_def(\n@@ -739,10 +732,10 @@ impl<'a> State<'a> {\n     ) {\n         self.head(\"enum\");\n         self.print_name(name);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         self.print_where_clause(generics);\n         self.space();\n-        self.print_variants(&enum_definition.variants, span)\n+        self.print_variants(enum_definition.variants, span);\n     }\n \n     pub fn print_variants(&mut self, variants: &[hir::Variant<'_>], span: rustc_span::Span) {\n@@ -776,15 +769,15 @@ impl<'a> State<'a> {\n         print_finalizer: bool,\n     ) {\n         self.print_name(name);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         match struct_def {\n             hir::VariantData::Tuple(..) | hir::VariantData::Unit(..) => {\n                 if let hir::VariantData::Tuple(..) = struct_def {\n                     self.popen();\n                     self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n                         s.maybe_print_comment(field.span.lo());\n                         s.print_outer_attributes(s.attrs(field.hir_id));\n-                        s.print_type(&field.ty)\n+                        s.print_type(field.ty);\n                     });\n                     self.pclose();\n                 }\n@@ -807,7 +800,7 @@ impl<'a> State<'a> {\n                     self.print_outer_attributes(self.attrs(field.hir_id));\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n-                    self.print_type(&field.ty);\n+                    self.print_type(field.ty);\n                     self.word(\",\");\n                 }\n \n@@ -819,7 +812,7 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &hir::Variant<'_>) {\n         self.head(\"\");\n         let generics = hir::Generics::empty();\n-        self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n+        self.print_struct(&v.data, generics, v.ident.name, v.span, false);\n         if let Some(ref d) = v.disr_expr {\n             self.space();\n             self.word_space(\"=\");\n@@ -834,7 +827,7 @@ impl<'a> State<'a> {\n         arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n-        self.print_fn(&m.decl, m.header, Some(ident.name), generics, arg_names, body_id)\n+        self.print_fn(m.decl, m.header, Some(ident.name), generics, arg_names, body_id);\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem<'_>) {\n@@ -843,28 +836,23 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ti.span.lo());\n         self.print_outer_attributes(self.attrs(ti.hir_id()));\n         match ti.kind {\n-            hir::TraitItemKind::Const(ref ty, default) => {\n-                self.print_associated_const(ti.ident, &ty, default);\n+            hir::TraitItemKind::Const(ty, default) => {\n+                self.print_associated_const(ti.ident, ty, default);\n             }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref arg_names)) => {\n-                self.print_method_sig(ti.ident, sig, &ti.generics, arg_names, None);\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(arg_names)) => {\n+                self.print_method_sig(ti.ident, sig, ti.generics, arg_names, None);\n                 self.word(\";\");\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 self.head(\"\");\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &[], Some(body));\n+                self.print_method_sig(ti.ident, sig, ti.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n             }\n-            hir::TraitItemKind::Type(ref bounds, ref default) => {\n-                self.print_associated_type(\n-                    ti.ident,\n-                    &ti.generics,\n-                    Some(bounds),\n-                    default.as_ref().map(|ty| &**ty),\n-                );\n+            hir::TraitItemKind::Type(bounds, default) => {\n+                self.print_associated_type(ti.ident, ti.generics, Some(bounds), default);\n             }\n         }\n         self.ann.post(self, AnnNode::SubItem(ti.hir_id()))\n@@ -877,19 +865,19 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(self.attrs(ii.hir_id()));\n \n         match ii.kind {\n-            hir::ImplItemKind::Const(ref ty, expr) => {\n-                self.print_associated_const(ii.ident, &ty, Some(expr));\n+            hir::ImplItemKind::Const(ty, expr) => {\n+                self.print_associated_const(ii.ident, ty, Some(expr));\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 self.head(\"\");\n-                self.print_method_sig(ii.ident, sig, &ii.generics, &[], Some(body));\n+                self.print_method_sig(ii.ident, sig, ii.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n             }\n-            hir::ImplItemKind::TyAlias(ref ty) => {\n-                self.print_associated_type(ii.ident, &ii.generics, None, Some(ty));\n+            hir::ImplItemKind::TyAlias(ty) => {\n+                self.print_associated_type(ii.ident, ii.generics, None, Some(ty));\n             }\n         }\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id()))\n@@ -904,28 +892,28 @@ impl<'a> State<'a> {\n         decl(self);\n         self.end();\n \n-        if let Some(ref init) = init {\n+        if let Some(init) = init {\n             self.nbsp();\n             self.word_space(\"=\");\n-            self.print_expr(&init);\n+            self.print_expr(init);\n         }\n         self.end()\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt<'_>) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n-            hir::StmtKind::Local(ref loc) => {\n-                self.print_local(loc.init, |this| this.print_local_decl(&loc));\n+            hir::StmtKind::Local(loc) => {\n+                self.print_local(loc.init, |this| this.print_local_decl(loc));\n             }\n             hir::StmtKind::Item(item) => self.ann.nested(self, Nested::Item(item)),\n-            hir::StmtKind::Expr(ref expr) => {\n+            hir::StmtKind::Expr(expr) => {\n                 self.space_if_not_bol();\n-                self.print_expr(&expr);\n+                self.print_expr(expr);\n             }\n-            hir::StmtKind::Semi(ref expr) => {\n+            hir::StmtKind::Semi(expr) => {\n                 self.space_if_not_bol();\n-                self.print_expr(&expr);\n+                self.print_expr(expr);\n                 self.word(\";\");\n             }\n         }\n@@ -966,9 +954,9 @@ impl<'a> State<'a> {\n         for st in blk.stmts {\n             self.print_stmt(st);\n         }\n-        if let Some(ref expr) = blk.expr {\n+        if let Some(expr) = blk.expr {\n             self.space_if_not_bol();\n-            self.print_expr(&expr);\n+            self.print_expr(expr);\n             self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi()));\n         }\n         self.bclose_maybe_open(blk.span, close_box);\n@@ -979,21 +967,21 @@ impl<'a> State<'a> {\n         if let Some(els_inner) = els {\n             match els_inner.kind {\n                 // Another `else if` block.\n-                hir::ExprKind::If(ref i, ref then, ref e) => {\n+                hir::ExprKind::If(i, then, e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else if \");\n-                    self.print_expr_as_cond(&i);\n+                    self.print_expr_as_cond(i);\n                     self.space();\n-                    self.print_expr(&then);\n-                    self.print_else(e.as_ref().map(|e| &**e))\n+                    self.print_expr(then);\n+                    self.print_else(e);\n                 }\n                 // Final `else` block.\n-                hir::ExprKind::Block(ref b, _) => {\n+                hir::ExprKind::Block(b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else \");\n-                    self.print_block(&b)\n+                    self.print_block(b);\n                 }\n                 // Constraints would be great here!\n                 _ => {\n@@ -1048,7 +1036,7 @@ impl<'a> State<'a> {\n         if needs_par {\n             self.popen();\n         }\n-        if let hir::ExprKind::DropTemps(ref actual_expr) = expr.kind {\n+        if let hir::ExprKind::DropTemps(actual_expr) = expr.kind {\n             self.print_expr(actual_expr);\n         } else {\n             self.print_expr(expr);\n@@ -1114,7 +1102,7 @@ impl<'a> State<'a> {\n         &mut self,\n         qpath: &hir::QPath<'_>,\n         fields: &[hir::ExprField<'_>],\n-        wth: &Option<&hir::Expr<'_>>,\n+        wth: Option<&hir::Expr<'_>>,\n     ) {\n         self.print_qpath(qpath, true);\n         self.word(\"{\");\n@@ -1127,28 +1115,24 @@ impl<'a> State<'a> {\n                     s.print_ident(field.ident);\n                     s.word_space(\":\");\n                 }\n-                s.print_expr(&field.expr);\n+                s.print_expr(field.expr);\n                 s.end()\n             },\n             |f| f.span,\n         );\n-        match *wth {\n-            Some(ref expr) => {\n-                self.ibox(INDENT_UNIT);\n-                if !fields.is_empty() {\n-                    self.word(\",\");\n-                    self.space();\n-                }\n-                self.word(\"..\");\n-                self.print_expr(&expr);\n-                self.end();\n-            }\n-            _ => {\n-                if !fields.is_empty() {\n-                    self.word(\",\")\n-                }\n+        if let Some(expr) = wth {\n+            self.ibox(INDENT_UNIT);\n+            if !fields.is_empty() {\n+                self.word(\",\");\n+                self.space();\n             }\n+            self.word(\"..\");\n+            self.print_expr(expr);\n+            self.end();\n+        } else if !fields.is_empty() {\n+            self.word(\",\");\n         }\n+\n         self.word(\"}\");\n     }\n \n@@ -1249,27 +1233,26 @@ impl<'a> State<'a> {\n             Options(ast::InlineAsmOptions),\n         }\n \n-        let mut args =\n-            vec![AsmArg::Template(ast::InlineAsmTemplatePiece::to_string(&asm.template))];\n+        let mut args = vec![AsmArg::Template(ast::InlineAsmTemplatePiece::to_string(asm.template))];\n         args.extend(asm.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n         if !asm.options.is_empty() {\n             args.push(AsmArg::Options(asm.options));\n         }\n \n         self.popen();\n-        self.commasep(Consistent, &args, |s, arg| match arg {\n-            AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n-            AsmArg::Operand(op) => match op {\n-                hir::InlineAsmOperand::In { reg, expr } => {\n+        self.commasep(Consistent, &args, |s, arg| match *arg {\n+            AsmArg::Template(ref template) => s.print_string(template, ast::StrStyle::Cooked),\n+            AsmArg::Operand(op) => match *op {\n+                hir::InlineAsmOperand::In { reg, ref expr } => {\n                     s.word(\"in\");\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n                     s.space();\n                     s.print_expr(expr);\n                 }\n-                hir::InlineAsmOperand::Out { reg, late, expr } => {\n-                    s.word(if *late { \"lateout\" } else { \"out\" });\n+                hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n+                    s.word(if late { \"lateout\" } else { \"out\" });\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n@@ -1279,16 +1262,16 @@ impl<'a> State<'a> {\n                         None => s.word(\"_\"),\n                     }\n                 }\n-                hir::InlineAsmOperand::InOut { reg, late, expr } => {\n-                    s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                    s.word(if late { \"inlateout\" } else { \"inout\" });\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n                     s.space();\n                     s.print_expr(expr);\n                 }\n-                hir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n-                    s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                hir::InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                    s.word(if late { \"inlateout\" } else { \"inout\" });\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n@@ -1301,17 +1284,17 @@ impl<'a> State<'a> {\n                         None => s.word(\"_\"),\n                     }\n                 }\n-                hir::InlineAsmOperand::Const { anon_const } => {\n+                hir::InlineAsmOperand::Const { ref anon_const } => {\n                     s.word(\"const\");\n                     s.space();\n                     s.print_anon_const(anon_const);\n                 }\n-                hir::InlineAsmOperand::SymFn { anon_const } => {\n+                hir::InlineAsmOperand::SymFn { ref anon_const } => {\n                     s.word(\"sym_fn\");\n                     s.space();\n                     s.print_anon_const(anon_const);\n                 }\n-                hir::InlineAsmOperand::SymStatic { path, def_id: _ } => {\n+                hir::InlineAsmOperand::SymStatic { ref path, def_id: _ } => {\n                     s.word(\"sym_static\");\n                     s.space();\n                     s.print_qpath(path, true);\n@@ -1363,57 +1346,57 @@ impl<'a> State<'a> {\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match expr.kind {\n-            hir::ExprKind::Box(ref expr) => {\n+            hir::ExprKind::Box(expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n             }\n-            hir::ExprKind::Array(ref exprs) => {\n+            hir::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);\n             }\n             hir::ExprKind::ConstBlock(ref anon_const) => {\n                 self.print_expr_anon_const(anon_const);\n             }\n-            hir::ExprKind::Repeat(ref element, ref count) => {\n-                self.print_expr_repeat(&element, count);\n+            hir::ExprKind::Repeat(element, ref count) => {\n+                self.print_expr_repeat(element, count);\n             }\n-            hir::ExprKind::Struct(ref qpath, fields, ref wth) => {\n+            hir::ExprKind::Struct(qpath, fields, wth) => {\n                 self.print_expr_struct(qpath, fields, wth);\n             }\n-            hir::ExprKind::Tup(ref exprs) => {\n+            hir::ExprKind::Tup(exprs) => {\n                 self.print_expr_tup(exprs);\n             }\n-            hir::ExprKind::Call(ref func, ref args) => {\n-                self.print_expr_call(&func, args);\n+            hir::ExprKind::Call(func, args) => {\n+                self.print_expr_call(func, args);\n             }\n-            hir::ExprKind::MethodCall(ref segment, ref args, _) => {\n+            hir::ExprKind::MethodCall(segment, args, _) => {\n                 self.print_expr_method_call(segment, args);\n             }\n-            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, &lhs, &rhs);\n+            hir::ExprKind::Binary(op, lhs, rhs) => {\n+                self.print_expr_binary(op, lhs, rhs);\n             }\n-            hir::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, &expr);\n+            hir::ExprKind::Unary(op, expr) => {\n+                self.print_expr_unary(op, expr);\n             }\n-            hir::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, &expr);\n+            hir::ExprKind::AddrOf(k, m, expr) => {\n+                self.print_expr_addr_of(k, m, expr);\n             }\n             hir::ExprKind::Lit(ref lit) => {\n-                self.print_literal(&lit);\n+                self.print_literal(lit);\n             }\n-            hir::ExprKind::Cast(ref expr, ref ty) => {\n+            hir::ExprKind::Cast(expr, ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n-                self.print_expr_maybe_paren(&expr, prec);\n+                self.print_expr_maybe_paren(expr, prec);\n                 self.space();\n                 self.word_space(\"as\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n             }\n-            hir::ExprKind::Type(ref expr, ref ty) => {\n+            hir::ExprKind::Type(expr, ty) => {\n                 let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(&expr, prec);\n+                self.print_expr_maybe_paren(expr, prec);\n                 self.word_space(\":\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n             }\n-            hir::ExprKind::DropTemps(ref init) => {\n+            hir::ExprKind::DropTemps(init) => {\n                 // Print `{`:\n                 self.cbox(INDENT_UNIT);\n                 self.ibox(0);\n@@ -1431,25 +1414,25 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, true);\n             }\n-            hir::ExprKind::Let(hir::Let { pat, ty, init, .. }) => {\n-                self.print_let(pat, *ty, init);\n+            hir::ExprKind::Let(&hir::Let { pat, ty, init, .. }) => {\n+                self.print_let(pat, ty, init);\n             }\n-            hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e));\n+            hir::ExprKind::If(test, blk, elseopt) => {\n+                self.print_if(test, blk, elseopt);\n             }\n-            hir::ExprKind::Loop(ref blk, opt_label, _, _) => {\n+            hir::ExprKind::Loop(blk, opt_label, _, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n                 }\n                 self.head(\"loop\");\n-                self.print_block(&blk);\n+                self.print_block(blk);\n             }\n-            hir::ExprKind::Match(ref expr, arms, _) => {\n+            hir::ExprKind::Match(expr, arms, _) => {\n                 self.cbox(INDENT_UNIT);\n                 self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n-                self.print_expr_as_cond(&expr);\n+                self.print_expr_as_cond(expr);\n                 self.space();\n                 self.bopen();\n                 for arm in arms {\n@@ -1460,15 +1443,15 @@ impl<'a> State<'a> {\n             hir::ExprKind::Closure {\n                 capture_clause,\n                 bound_generic_params,\n-                ref fn_decl,\n+                fn_decl,\n                 body,\n                 fn_decl_span: _,\n                 movability: _,\n             } => {\n                 self.print_formal_generic_params(bound_generic_params);\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_closure_params(&fn_decl, body);\n+                self.print_closure_params(fn_decl, body);\n                 self.space();\n \n                 // This is a bare expression.\n@@ -1480,7 +1463,7 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n             }\n-            hir::ExprKind::Block(ref blk, opt_label) => {\n+            hir::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -1489,42 +1472,42 @@ impl<'a> State<'a> {\n                 self.cbox(INDENT_UNIT);\n                 // head-box, will be closed by print-block after `{`\n                 self.ibox(0);\n-                self.print_block(&blk);\n+                self.print_block(blk);\n             }\n-            hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            hir::ExprKind::Assign(lhs, rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(&lhs, prec + 1);\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word_space(\"=\");\n-                self.print_expr_maybe_paren(&rhs, prec);\n+                self.print_expr_maybe_paren(rhs, prec);\n             }\n-            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(&lhs, prec + 1);\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word(op.node.as_str());\n                 self.word_space(\"=\");\n-                self.print_expr_maybe_paren(&rhs, prec);\n+                self.print_expr_maybe_paren(rhs, prec);\n             }\n-            hir::ExprKind::Field(ref expr, ident) => {\n+            hir::ExprKind::Field(expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".\");\n                 self.print_ident(ident);\n             }\n-            hir::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX);\n+            hir::ExprKind::Index(expr, index) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\"[\");\n-                self.print_expr(&index);\n+                self.print_expr(index);\n                 self.word(\"]\");\n             }\n             hir::ExprKind::Path(ref qpath) => self.print_qpath(qpath, true),\n-            hir::ExprKind::Break(destination, ref opt_expr) => {\n+            hir::ExprKind::Break(destination, opt_expr) => {\n                 self.word(\"break\");\n                 if let Some(label) = destination.label {\n                     self.space();\n                     self.print_ident(label.ident);\n                 }\n-                if let Some(ref expr) = *opt_expr {\n+                if let Some(expr) = opt_expr {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n@@ -1536,20 +1519,20 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                 }\n             }\n-            hir::ExprKind::Ret(ref result) => {\n+            hir::ExprKind::Ret(result) => {\n                 self.word(\"return\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n-                    self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            hir::ExprKind::InlineAsm(ref asm) => {\n+            hir::ExprKind::InlineAsm(asm) => {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(asm);\n             }\n-            hir::ExprKind::Yield(ref expr, _) => {\n+            hir::ExprKind::Yield(expr, _) => {\n                 self.word_space(\"yield\");\n-                self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n+                self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n             }\n             hir::ExprKind::Err => {\n                 self.popen();\n@@ -1562,10 +1545,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &hir::Local<'_>) {\n-        self.print_pat(&loc.pat);\n-        if let Some(ref ty) = loc.ty {\n+        self.print_pat(loc.pat);\n+        if let Some(ty) = loc.ty {\n             self.word_space(\":\");\n-            self.print_type(&ty);\n+            self.print_type(ty);\n         }\n     }\n \n@@ -1596,8 +1579,8 @@ impl<'a> State<'a> {\n \n     pub fn print_qpath(&mut self, qpath: &hir::QPath<'_>, colons_before_params: bool) {\n         match *qpath {\n-            hir::QPath::Resolved(None, ref path) => self.print_path(path, colons_before_params),\n-            hir::QPath::Resolved(Some(ref qself), ref path) => {\n+            hir::QPath::Resolved(None, path) => self.print_path(path, colons_before_params),\n+            hir::QPath::Resolved(Some(qself), path) => {\n                 self.word(\"<\");\n                 self.print_type(qself);\n                 self.space();\n@@ -1627,11 +1610,11 @@ impl<'a> State<'a> {\n                     colons_before_params,\n                 )\n             }\n-            hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n+            hir::QPath::TypeRelative(qself, item_segment) => {\n                 // If we've got a compound-qualified-path, let's push an additional pair of angle\n                 // brackets, so that we pretty-print `<<A::B>::C>` as `<A::B>::C`, instead of just\n                 // `A::B::C` (since the latter could be ambiguous to the user)\n-                if let hir::TyKind::Path(hir::QPath::Resolved(None, _)) = &qself.kind {\n+                if let hir::TyKind::Path(hir::QPath::Resolved(None, _)) = qself.kind {\n                     self.print_type(qself);\n                 } else {\n                     self.word(\"<\");\n@@ -1663,7 +1646,7 @@ impl<'a> State<'a> {\n     ) {\n         if generic_args.parenthesized {\n             self.word(\"(\");\n-            self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(&ty));\n+            self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(ty));\n             self.word(\")\");\n \n             self.space_if_not_bol();\n@@ -1694,7 +1677,7 @@ impl<'a> State<'a> {\n                 start_or_comma(self);\n                 self.commasep(\n                     Inconsistent,\n-                    &generic_args.args,\n+                    generic_args.args,\n                     |s, generic_arg| match generic_arg {\n                         GenericArg::Lifetime(lt) if !elide_lifetimes => s.print_lifetime(lt),\n                         GenericArg::Lifetime(_) => {}\n@@ -1712,7 +1695,7 @@ impl<'a> State<'a> {\n                 self.word(\"..\");\n             }\n \n-            for binding in generic_args.bindings.iter() {\n+            for binding in generic_args.bindings {\n                 start_or_comma(self);\n                 self.print_type_binding(binding);\n             }\n@@ -1731,7 +1714,7 @@ impl<'a> State<'a> {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 self.word_space(\"=\");\n                 match term {\n-                    Term::Ty(ref ty) => self.print_type(ty),\n+                    Term::Ty(ty) => self.print_type(ty),\n                     Term::Const(ref c) => self.print_anon_const(c),\n                 }\n             }\n@@ -1748,7 +1731,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Binding(binding_mode, _, ident, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ident, sub) => {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n@@ -1764,33 +1747,33 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 self.print_ident(ident);\n-                if let Some(ref p) = *sub {\n+                if let Some(p) = sub {\n                     self.word(\"@\");\n-                    self.print_pat(&p);\n+                    self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref qpath, ref elts, ddpos) => {\n+            PatKind::TupleStruct(ref qpath, elts, ddpos) => {\n                 self.print_qpath(qpath, true);\n                 self.popen();\n                 if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n                     self.word(\"..\");\n                     if ddpos != elts.len() {\n                         self.word(\",\");\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p));\n                     }\n                 } else {\n-                    self.commasep(Inconsistent, &elts, |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 }\n                 self.pclose();\n             }\n             PatKind::Path(ref qpath) => {\n                 self.print_qpath(qpath, true);\n             }\n-            PatKind::Struct(ref qpath, ref fields, etc) => {\n+            PatKind::Struct(ref qpath, fields, etc) => {\n                 self.print_qpath(qpath, true);\n                 self.nbsp();\n                 self.word(\"{\");\n@@ -1800,14 +1783,14 @@ impl<'a> State<'a> {\n                 }\n                 self.commasep_cmnt(\n                     Consistent,\n-                    &fields,\n+                    fields,\n                     |s, f| {\n                         s.cbox(INDENT_UNIT);\n                         if !f.is_shorthand {\n                             s.print_ident(f.ident);\n                             s.word_nbsp(\":\");\n                         }\n-                        s.print_pat(&f.pat);\n+                        s.print_pat(f.pat);\n                         s.end()\n                     },\n                     |f| f.pat.span,\n@@ -1823,83 +1806,83 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"}\");\n             }\n-            PatKind::Or(ref pats) => {\n-                self.strsep(\"|\", true, Inconsistent, &pats, |s, p| s.print_pat(&p));\n+            PatKind::Or(pats) => {\n+                self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n             }\n-            PatKind::Tuple(ref elts, ddpos) => {\n+            PatKind::Tuple(elts, ddpos) => {\n                 self.popen();\n                 if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n                     self.word(\"..\");\n                     if ddpos != elts.len() {\n                         self.word(\",\");\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p));\n                     }\n                 } else {\n-                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                     if elts.len() == 1 {\n                         self.word(\",\");\n                     }\n                 }\n                 self.pclose();\n             }\n-            PatKind::Box(ref inner) => {\n+            PatKind::Box(inner) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n                 self.word(\"box \");\n                 if is_range_inner {\n                     self.popen();\n                 }\n-                self.print_pat(&inner);\n+                self.print_pat(inner);\n                 if is_range_inner {\n                     self.pclose();\n                 }\n             }\n-            PatKind::Ref(ref inner, mutbl) => {\n+            PatKind::Ref(inner, mutbl) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n                 self.word(\"&\");\n                 self.word(mutbl.prefix_str());\n                 if is_range_inner {\n                     self.popen();\n                 }\n-                self.print_pat(&inner);\n+                self.print_pat(inner);\n                 if is_range_inner {\n                     self.pclose();\n                 }\n             }\n-            PatKind::Lit(ref e) => self.print_expr(&e),\n-            PatKind::Range(ref begin, ref end, ref end_kind) => {\n+            PatKind::Lit(e) => self.print_expr(e),\n+            PatKind::Range(begin, end, end_kind) => {\n                 if let Some(expr) = begin {\n                     self.print_expr(expr);\n                 }\n-                match *end_kind {\n+                match end_kind {\n                     RangeEnd::Included => self.word(\"...\"),\n                     RangeEnd::Excluded => self.word(\"..\"),\n                 }\n                 if let Some(expr) = end {\n                     self.print_expr(expr);\n                 }\n             }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+            PatKind::Slice(before, slice, after) => {\n                 self.word(\"[\");\n-                self.commasep(Inconsistent, &before, |s, p| s.print_pat(&p));\n-                if let Some(ref p) = *slice {\n+                self.commasep(Inconsistent, before, |s, p| s.print_pat(p));\n+                if let Some(p) = slice {\n                     if !before.is_empty() {\n                         self.word_space(\",\");\n                     }\n                     if let PatKind::Wild = p.kind {\n                         // Print nothing.\n                     } else {\n-                        self.print_pat(&p);\n+                        self.print_pat(p);\n                     }\n                     self.word(\"..\");\n                     if !after.is_empty() {\n                         self.word_space(\",\");\n                     }\n                 }\n-                self.commasep(Inconsistent, &after, |s, p| s.print_pat(&p));\n+                self.commasep(Inconsistent, after, |s, p| s.print_pat(p));\n                 self.word(\"]\");\n             }\n         }\n@@ -1908,7 +1891,7 @@ impl<'a> State<'a> {\n \n     pub fn print_param(&mut self, arg: &hir::Param<'_>) {\n         self.print_outer_attributes(self.attrs(arg.hir_id));\n-        self.print_pat(&arg.pat);\n+        self.print_pat(arg.pat);\n     }\n \n     pub fn print_arm(&mut self, arm: &hir::Arm<'_>) {\n@@ -1920,32 +1903,32 @@ impl<'a> State<'a> {\n         self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n-        self.print_outer_attributes(&self.attrs(arm.hir_id));\n-        self.print_pat(&arm.pat);\n+        self.print_outer_attributes(self.attrs(arm.hir_id));\n+        self.print_pat(arm.pat);\n         self.space();\n         if let Some(ref g) = arm.guard {\n-            match g {\n+            match *g {\n                 hir::Guard::If(e) => {\n                     self.word_space(\"if\");\n-                    self.print_expr(&e);\n+                    self.print_expr(e);\n                     self.space();\n                 }\n-                hir::Guard::IfLet(hir::Let { pat, ty, init, .. }) => {\n+                hir::Guard::IfLet(&hir::Let { pat, ty, init, .. }) => {\n                     self.word_nbsp(\"if\");\n-                    self.print_let(pat, *ty, init);\n+                    self.print_let(pat, ty, init);\n                 }\n             }\n         }\n         self.word_space(\"=>\");\n \n         match arm.body.kind {\n-            hir::ExprKind::Block(ref blk, opt_label) => {\n+            hir::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n                 }\n                 // the block will close the pattern's ibox\n-                self.print_block_unclosed(&blk);\n+                self.print_block_unclosed(blk);\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::UserProvided) = blk.rules\n@@ -1955,7 +1938,7 @@ impl<'a> State<'a> {\n             }\n             _ => {\n                 self.end(); // close the ibox for the pattern\n-                self.print_expr(&arm.body);\n+                self.print_expr(arm.body);\n                 self.word(\",\");\n             }\n         }\n@@ -1978,13 +1961,13 @@ impl<'a> State<'a> {\n             self.nbsp();\n             self.print_name(name);\n         }\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n \n         self.popen();\n         let mut i = 0;\n         // Make sure we aren't supplied *both* `arg_names` and `body_id`.\n         assert!(arg_names.is_empty() || body_id.is_none());\n-        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+        self.commasep(Inconsistent, decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n             if let Some(arg_name) = arg_names.get(i) {\n                 s.word(arg_name.to_string());\n@@ -2011,7 +1994,7 @@ impl<'a> State<'a> {\n     fn print_closure_params(&mut self, decl: &hir::FnDecl<'_>, body_id: hir::BodyId) {\n         self.word(\"|\");\n         let mut i = 0;\n-        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+        self.commasep(Inconsistent, decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n \n             s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n@@ -2035,8 +2018,8 @@ impl<'a> State<'a> {\n         self.space_if_not_bol();\n         self.word_space(\"->\");\n         match decl.output {\n-            hir::FnRetTy::Return(ref ty) => {\n-                self.print_type(&ty);\n+            hir::FnRetTy::Return(ty) => {\n+                self.print_type(ty);\n                 self.maybe_print_comment(ty.span.lo());\n             }\n             hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n@@ -2107,20 +2090,20 @@ impl<'a> State<'a> {\n \n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {}\n-            GenericParamKind::Type { ref default, .. } => {\n+            GenericParamKind::Type { default, .. } => {\n                 if let Some(default) = default {\n                     self.space();\n                     self.word_space(\"=\");\n-                    self.print_type(&default)\n+                    self.print_type(default);\n                 }\n             }\n-            GenericParamKind::Const { ref ty, ref default } => {\n+            GenericParamKind::Const { ty, ref default } => {\n                 self.word_space(\":\");\n                 self.print_type(ty);\n-                if let Some(ref default) = default {\n+                if let Some(default) = default {\n                     self.space();\n                     self.word_space(\"=\");\n-                    self.print_anon_const(&default)\n+                    self.print_anon_const(default);\n                 }\n             }\n         }\n@@ -2143,19 +2126,19 @@ impl<'a> State<'a> {\n                 self.word_space(\",\");\n             }\n \n-            match predicate {\n+            match *predicate {\n                 hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     bound_generic_params,\n                     bounded_ty,\n                     bounds,\n                     ..\n                 }) => {\n                     self.print_formal_generic_params(bound_generic_params);\n-                    self.print_type(&bounded_ty);\n-                    self.print_bounds(\":\", *bounds);\n+                    self.print_type(bounded_ty);\n+                    self.print_bounds(\":\", bounds);\n                 }\n                 hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                    lifetime,\n+                    ref lifetime,\n                     bounds,\n                     ..\n                 }) => {\n@@ -2200,7 +2183,7 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &hir::MutTy<'_>, print_const: bool) {\n         self.print_mutability(mt.mutbl, print_const);\n-        self.print_type(&mt.ty)\n+        self.print_type(mt.ty);\n     }\n \n     pub fn print_fn_output(&mut self, decl: &hir::FnDecl<'_>) {\n@@ -2213,11 +2196,11 @@ impl<'a> State<'a> {\n         self.word_space(\"->\");\n         match decl.output {\n             hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n-            hir::FnRetTy::Return(ref ty) => self.print_type(&ty),\n+            hir::FnRetTy::Return(ty) => self.print_type(ty),\n         }\n         self.end();\n \n-        if let hir::FnRetTy::Return(ref output) = decl.output {\n+        if let hir::FnRetTy::Return(output) = decl.output {\n             self.maybe_print_comment(output.span.lo());\n         }\n     }\n@@ -2243,7 +2226,7 @@ impl<'a> State<'a> {\n                 asyncness: hir::IsAsync::NotAsync,\n             },\n             name,\n-            &generics,\n+            generics,\n             arg_names,\n             None,\n         );\n@@ -2312,7 +2295,7 @@ fn stmt_ends_with_semi(stmt: &hir::StmtKind<'_>) -> bool {\n     match *stmt {\n         hir::StmtKind::Local(_) => true,\n         hir::StmtKind::Item(_) => false,\n-        hir::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(&e),\n+        hir::StmtKind::Expr(e) => expr_requires_semi_to_be_stmt(e),\n         hir::StmtKind::Semi(..) => false,\n     }\n }\n@@ -2351,22 +2334,22 @@ fn contains_exterior_struct_lit(value: &hir::Expr<'_>) -> bool {\n     match value.kind {\n         hir::ExprKind::Struct(..) => true,\n \n-        hir::ExprKind::Assign(ref lhs, ref rhs, _)\n-        | hir::ExprKind::AssignOp(_, ref lhs, ref rhs)\n-        | hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(lhs, rhs, _)\n+        | hir::ExprKind::AssignOp(_, lhs, rhs)\n+        | hir::ExprKind::Binary(_, lhs, rhs) => {\n             // `X { y: 1 } + X { y: 2 }`\n-            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+            contains_exterior_struct_lit(lhs) || contains_exterior_struct_lit(rhs)\n         }\n-        hir::ExprKind::Unary(_, ref x)\n-        | hir::ExprKind::Cast(ref x, _)\n-        | hir::ExprKind::Type(ref x, _)\n-        | hir::ExprKind::Field(ref x, _)\n-        | hir::ExprKind::Index(ref x, _) => {\n+        hir::ExprKind::Unary(_, x)\n+        | hir::ExprKind::Cast(x, _)\n+        | hir::ExprKind::Type(x, _)\n+        | hir::ExprKind::Field(x, _)\n+        | hir::ExprKind::Index(x, _) => {\n             // `&X { y: 1 }, X { y: 1 }.y`\n-            contains_exterior_struct_lit(&x)\n+            contains_exterior_struct_lit(x)\n         }\n \n-        hir::ExprKind::MethodCall(.., ref exprs, _) => {\n+        hir::ExprKind::MethodCall(.., exprs, _) => {\n             // `X { y: 1 }.bar(...)`\n             contains_exterior_struct_lit(&exprs[0])\n         }"}]}