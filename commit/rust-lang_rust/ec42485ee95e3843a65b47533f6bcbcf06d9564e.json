{"sha": "ec42485ee95e3843a65b47533f6bcbcf06d9564e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNDI0ODVlZTk1ZTM4NDNhNjViNDc1MzNmNmJjYmNmMDZkOTU2NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-10T22:01:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-10T22:01:37Z"}, "message": "Auto merge of #73206 - Dylan-DPC:rollup-rha9g8q, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #72706 (Add windows group to triagebot)\n - #72789 (resolve: Do not suggest imports from the same module in which we are resolving)\n - #72890 (improper ctypes: normalize return types and transparent structs)\n - #72897 (normalize adt fields during structural match checking)\n - #73005 (Don't create impl candidates when obligation contains errors)\n - #73023 (Remove noisy suggestion of hash_map )\n - #73070 (Add regression test for const generic ICE in #72819)\n - #73157 (Don't lose empty `where` clause when pretty-printing)\n - #73184 (Reoder order in which MinGW libs are linked to fix recent breakage)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "fea644a4f3a339e82ff54e9171bb5689aac3c500", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fea644a4f3a339e82ff54e9171bb5689aac3c500"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec42485ee95e3843a65b47533f6bcbcf06d9564e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec42485ee95e3843a65b47533f6bcbcf06d9564e", "html_url": "https://github.com/rust-lang/rust/commit/ec42485ee95e3843a65b47533f6bcbcf06d9564e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec42485ee95e3843a65b47533f6bcbcf06d9564e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "449e8eaa286e407c9cd8cac655b77998fd53db6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/449e8eaa286e407c9cd8cac655b77998fd53db6b", "html_url": "https://github.com/rust-lang/rust/commit/449e8eaa286e407c9cd8cac655b77998fd53db6b"}, {"sha": "2b8f1eccaa138a2a4af61356231c33d7d93ed993", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8f1eccaa138a2a4af61356231c33d7d93ed993", "html_url": "https://github.com/rust-lang/rust/commit/2b8f1eccaa138a2a4af61356231c33d7d93ed993"}], "stats": {"total": 665, "additions": 350, "deletions": 315}, "files": [{"sha": "672ef108969e546a4ba310c0bea11438fcbaff63", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -362,7 +362,11 @@ impl Default for Generics {\n     fn default() -> Generics {\n         Generics {\n             params: Vec::new(),\n-            where_clause: WhereClause { predicates: Vec::new(), span: DUMMY_SP },\n+            where_clause: WhereClause {\n+                has_where_token: false,\n+                predicates: Vec::new(),\n+                span: DUMMY_SP,\n+            },\n             span: DUMMY_SP,\n         }\n     }\n@@ -371,6 +375,11 @@ impl Default for Generics {\n /// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n+    /// `true` if we ate a `where` token: this can happen\n+    /// if we parsed no predicates (e.g. `struct Foo where {}\n+    /// This allows us to accurately pretty-print\n+    /// in `nt_to_tokenstream`\n+    pub has_where_token: bool,\n     pub predicates: Vec<WherePredicate>,\n     pub span: Span,\n }"}, {"sha": "66b8d7f97f0ed44abda221d7dc2c804d6bb53d94", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -786,7 +786,7 @@ pub fn noop_visit_generics<T: MutVisitor>(generics: &mut Generics, vis: &mut T)\n }\n \n pub fn noop_visit_where_clause<T: MutVisitor>(wc: &mut WhereClause, vis: &mut T) {\n-    let WhereClause { predicates, span } = wc;\n+    let WhereClause { has_where_token: _, predicates, span } = wc;\n     visit_vec(predicates, |predicate| vis.visit_where_predicate(predicate));\n     vis.visit_span(span);\n }"}, {"sha": "8ff80df527ce7c64168c50619ae36d878847c9c6", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -2593,7 +2593,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause) {\n-        if where_clause.predicates.is_empty() {\n+        if where_clause.predicates.is_empty() && !where_clause.has_where_token {\n             return;\n         }\n \n@@ -2739,7 +2739,11 @@ impl<'a> State<'a> {\n         }\n         let generics = ast::Generics {\n             params: Vec::new(),\n-            where_clause: ast::WhereClause { predicates: Vec::new(), span: rustc_span::DUMMY_SP },\n+            where_clause: ast::WhereClause {\n+                has_where_token: false,\n+                predicates: Vec::new(),\n+                span: rustc_span::DUMMY_SP,\n+            },\n             span: rustc_span::DUMMY_SP,\n         };\n         let header = ast::FnHeader { unsafety, ext, ..ast::FnHeader::default() };"}, {"sha": "609feb6f259d6a9647de777421155b398b347340", "filename": "src/librustc_builtin_macros/deriving/generic/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fty.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -216,7 +216,11 @@ fn mk_ty_param(\n }\n \n fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n-    Generics { params, where_clause: ast::WhereClause { predicates: Vec::new(), span }, span }\n+    Generics {\n+        params,\n+        where_clause: ast::WhereClause { has_where_token: false, predicates: Vec::new(), span },\n+        span,\n+    }\n }\n \n /// Lifetimes and bounds on type parameters"}, {"sha": "cdb0eda645a48a4ea3ecd1c4c10cd266ae48fe8d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 60, "deletions": 40, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -6,7 +6,6 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::{is_range_literal, ExprKind, Node};\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n@@ -511,10 +510,6 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: &'static str, help: Option<&'static str> },\n }\n \n-fn is_zst<'tcx>(tcx: TyCtxt<'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n-    tcx.layout_of(tcx.param_env(did).and(ty)).map(|layout| layout.is_zst()).unwrap_or(false)\n-}\n-\n fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n         ty::FnPtr(_) => true,\n@@ -523,7 +518,7 @@ fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             for field in field_def.all_fields() {\n                 let field_ty =\n                     tcx.normalize_erasing_regions(ParamEnv::reveal_all(), field.ty(tcx, substs));\n-                if is_zst(tcx, field.did, field_ty) {\n+                if field_ty.is_zst(tcx, field.did) {\n                     continue;\n                 }\n \n@@ -653,32 +648,43 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             };\n                         }\n \n-                        // We can't completely trust repr(C) and repr(transparent) markings;\n-                        // make sure the fields are actually safe.\n-                        let mut all_phantom = true;\n-                        for field in &def.non_enum_variant().fields {\n-                            let field_ty = cx.normalize_erasing_regions(\n-                                ParamEnv::reveal_all(),\n-                                field.ty(cx, substs),\n-                            );\n-                            // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n-                            // PhantomData -- skip checking all ZST fields\n-                            if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n-                                continue;\n+                        if def.repr.transparent() {\n+                            // Can assume that only one field is not a ZST, so only check\n+                            // that field's type for FFI-safety.\n+                            if let Some(field) =\n+                                def.transparent_newtype_field(cx, self.cx.param_env)\n+                            {\n+                                let field_ty = cx.normalize_erasing_regions(\n+                                    self.cx.param_env,\n+                                    field.ty(cx, substs),\n+                                );\n+                                self.check_type_for_ffi(cache, field_ty)\n+                            } else {\n+                                FfiSafe\n                             }\n-                            let r = self.check_type_for_ffi(cache, field_ty);\n-                            match r {\n-                                FfiSafe => {\n-                                    all_phantom = false;\n-                                }\n-                                FfiPhantom(..) => {}\n-                                FfiUnsafe { .. } => {\n-                                    return r;\n+                        } else {\n+                            // We can't completely trust repr(C) markings; make sure the fields are\n+                            // actually safe.\n+                            let mut all_phantom = true;\n+                            for field in &def.non_enum_variant().fields {\n+                                let field_ty = cx.normalize_erasing_regions(\n+                                    self.cx.param_env,\n+                                    field.ty(cx, substs),\n+                                );\n+                                let r = self.check_type_for_ffi(cache, field_ty);\n+                                match r {\n+                                    FfiSafe => {\n+                                        all_phantom = false;\n+                                    }\n+                                    FfiPhantom(..) => {}\n+                                    FfiUnsafe { .. } => {\n+                                        return r;\n+                                    }\n                                 }\n                             }\n-                        }\n \n-                        if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n+                        }\n                     }\n                     AdtKind::Union => {\n                         if !def.repr.c() && !def.repr.transparent() {\n@@ -708,7 +714,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             );\n                             // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n                             // PhantomData -- skip checking all ZST fields.\n-                            if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n+                            if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n                                 continue;\n                             }\n                             let r = self.check_type_for_ffi(cache, field_ty);\n@@ -774,7 +780,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                 );\n                                 // repr(transparent) types are allowed to have arbitrary ZSTs, not\n                                 // just PhantomData -- skip checking all ZST fields.\n-                                if def.repr.transparent() && is_zst(cx, field.did, field_ty) {\n+                                if def.repr.transparent() && field_ty.is_zst(cx, field.did) {\n                                     continue;\n                                 }\n                                 let r = self.check_type_for_ffi(cache, field_ty);\n@@ -946,7 +952,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>, is_static: bool) {\n+    fn check_type_for_ffi_and_report_errors(\n+        &mut self,\n+        sp: Span,\n+        ty: Ty<'tcx>,\n+        is_static: bool,\n+        is_return_type: bool,\n+    ) {\n         // We have to check for opaque types before `normalize_erasing_regions`,\n         // which will replace opaque types with their underlying concrete type.\n         if self.check_for_opaque_ty(sp, ty) {\n@@ -957,19 +969,29 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         // it is only OK to use this function because extern fns cannot have\n         // any generic types right now:\n         let ty = self.cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-        // C doesn't really support passing arrays by value.\n-        // The only way to pass an array by value is through a struct.\n-        // So we first test that the top level isn't an array,\n-        // and then recursively check the types inside.\n+\n+        // C doesn't really support passing arrays by value - the only way to pass an array by value\n+        // is through a struct. So, first test that the top level isn't an array, and then\n+        // recursively check the types inside.\n         if !is_static && self.check_for_array_ty(sp, ty) {\n             return;\n         }\n \n+        // Don't report FFI errors for unit return types. This check exists here, and not in\n+        // `check_foreign_fn` (where it would make more sense) so that normalization has definitely\n+        // happened.\n+        if is_return_type && ty.is_unit() {\n+            return;\n+        }\n+\n         match self.check_type_for_ffi(&mut FxHashSet::default(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiPhantom(ty) => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, \"composed only of `PhantomData`\", None);\n             }\n+            // If `ty` is a `repr(transparent)` newtype, and the non-zero-sized type is a generic\n+            // argument, which after substitution, is `()`, then this branch can be hit.\n+            FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => return,\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n             }\n@@ -982,21 +1004,19 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n         for (input_ty, input_hir) in sig.inputs().iter().zip(decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n         }\n \n         if let hir::FnRetTy::Return(ref ret_hir) = decl.output {\n             let ret_ty = sig.output();\n-            if !ret_ty.is_unit() {\n-                self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty, false);\n-            }\n+            self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty, false, true);\n         }\n     }\n \n     fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n         let def_id = self.cx.tcx.hir().local_def_id(id);\n         let ty = self.cx.tcx.type_of(def_id);\n-        self.check_type_for_ffi_and_report_errors(span, ty, true);\n+        self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n }\n "}, {"sha": "caa1b4cb375fe03f44c8a4941058b874c35072e3", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -2390,6 +2390,29 @@ impl<'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n+\n+    /// `repr(transparent)` structs can have a single non-ZST field, this function returns that\n+    /// field.\n+    pub fn transparent_newtype_field(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Option<&FieldDef> {\n+        assert!(self.is_struct() && self.repr.transparent());\n+\n+        for field in &self.non_enum_variant().fields {\n+            let field_ty = tcx.normalize_erasing_regions(\n+                param_env,\n+                field.ty(tcx, InternalSubsts::identity_for_item(tcx, self.did)),\n+            );\n+\n+            if !field_ty.is_zst(tcx, self.did) {\n+                return Some(field);\n+            }\n+        }\n+\n+        None\n+    }\n }\n \n impl<'tcx> FieldDef {"}, {"sha": "7550be39d4ab0443673a7e4102195742a7666fb3", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -2186,6 +2186,11 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n     }\n+\n+    /// Is this a zero-sized type?\n+    pub fn is_zst(&'tcx self, tcx: TyCtxt<'tcx>, did: DefId) -> bool {\n+        tcx.layout_of(tcx.param_env(did).and(self)).map(|layout| layout.is_zst()).unwrap_or(false)\n+    }\n }\n \n /// Typed constant value."}, {"sha": "04b64d93c70dd2b2a4ff4ff5d79d0cf5da25eeb5", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -157,6 +157,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::Generics {\n             params,\n             where_clause: WhereClause {\n+                has_where_token: false,\n                 predicates: Vec::new(),\n                 span: self.prev_token.span.shrink_to_hi(),\n             },\n@@ -170,12 +171,16 @@ impl<'a> Parser<'a> {\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n     pub(super) fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n-        let mut where_clause =\n-            WhereClause { predicates: Vec::new(), span: self.prev_token.span.shrink_to_hi() };\n+        let mut where_clause = WhereClause {\n+            has_where_token: false,\n+            predicates: Vec::new(),\n+            span: self.prev_token.span.shrink_to_hi(),\n+        };\n \n         if !self.eat_keyword(kw::Where) {\n             return Ok(where_clause);\n         }\n+        where_clause.has_where_token = true;\n         let lo = self.prev_token.span;\n \n         // We are considering adding generics to the `where` keyword as an alternative higher-rank"}, {"sha": "bd2ce5a72e8d924e1a1d320aa2d4da5c2a5f9a41", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -629,6 +629,7 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         lookup_ident: Ident,\n         namespace: Namespace,\n+        parent_scope: &ParentScope<'a>,\n         start_module: Module<'a>,\n         crate_name: Ident,\n         filter_fn: FilterFn,\n@@ -655,7 +656,11 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // collect results based on the filter function\n-                if ident.name == lookup_ident.name && ns == namespace {\n+                // avoid suggesting anything from the same module in which we are resolving\n+                if ident.name == lookup_ident.name\n+                    && ns == namespace\n+                    && !ptr::eq(in_module, parent_scope.module)\n+                {\n                     let res = name_binding.res();\n                     if filter_fn(res) {\n                         // create the path\n@@ -680,7 +685,9 @@ impl<'a> Resolver<'a> {\n                                 Res::Def(DefKind::Ctor(..), did) => this.parent(did),\n                                 _ => res.opt_def_id(),\n                             };\n-                            candidates.push(ImportSuggestion { did, descr: res.descr(), path });\n+                            if candidates.iter().all(|v: &ImportSuggestion| v.did != did) {\n+                                candidates.push(ImportSuggestion { did, descr: res.descr(), path });\n+                            }\n                         }\n                     }\n                 }\n@@ -722,6 +729,7 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         lookup_ident: Ident,\n         namespace: Namespace,\n+        parent_scope: &ParentScope<'a>,\n         filter_fn: FilterFn,\n     ) -> Vec<ImportSuggestion>\n     where\n@@ -730,6 +738,7 @@ impl<'a> Resolver<'a> {\n         let mut suggestions = self.lookup_import_candidates_from_module(\n             lookup_ident,\n             namespace,\n+            parent_scope,\n             self.graph_root,\n             Ident::with_dummy_span(kw::Crate),\n             &filter_fn,\n@@ -754,6 +763,7 @@ impl<'a> Resolver<'a> {\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident,\n                         namespace,\n+                        parent_scope,\n                         crate_root,\n                         ident,\n                         &filter_fn,"}, {"sha": "ed7adefcb8c9e0a56985054fe9f0e92f0a44603e", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -212,7 +212,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         let ident = path.last().unwrap().ident;\n         let candidates = self\n             .r\n-            .lookup_import_candidates(ident, ns, is_expected)\n+            .lookup_import_candidates(ident, ns, &self.parent_scope, is_expected)\n             .drain(..)\n             .filter(|ImportSuggestion { did, .. }| {\n                 match (did, res.and_then(|res| res.opt_def_id())) {\n@@ -223,7 +223,8 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n             .collect::<Vec<_>>();\n         let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n         if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n-            let enum_candidates = self.r.lookup_import_candidates(ident, ns, is_enum_variant);\n+            let enum_candidates =\n+                self.r.lookup_import_candidates(ident, ns, &self.parent_scope, is_enum_variant);\n             let mut enum_candidates = enum_candidates\n                 .iter()\n                 .map(|suggestion| import_candidate_to_enum_paths(&suggestion))"}, {"sha": "61792e039c76ead953f6a911c7ef292b822992a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -2235,7 +2235,8 @@ impl<'a> Resolver<'a> {\n                             Res::Def(DefKind::Mod, _) => true,\n                             _ => false,\n                         };\n-                        let mut candidates = self.lookup_import_candidates(ident, TypeNS, is_mod);\n+                        let mut candidates =\n+                            self.lookup_import_candidates(ident, TypeNS, parent_scope, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n                             (c.path.segments.len(), pprust::path_to_string(&c.path))\n                         });"}, {"sha": "744f26239cada1acb91d0637a6303cb77b41f7a9", "filename": "src/librustc_target/spec/windows_gnu_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -20,9 +20,9 @@ pub fn opts() -> TargetOptions {\n     late_link_args.insert(\n         LinkerFlavor::Gcc,\n         vec![\n+            \"-lmsvcrt\".to_string(),\n             \"-lmingwex\".to_string(),\n             \"-lmingw32\".to_string(),\n-            \"-lmsvcrt\".to_string(),\n             // mingw's msvcrt is a weird hybrid import library and static library.\n             // And it seems that the linker fails to use import symbols from msvcrt\n             // that are required from functions in msvcrt in certain cases. For example"}, {"sha": "9045451056b1991d40965a24b3f7251bc48e09c3", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -331,6 +331,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<(), SelectionError<'tcx>> {\n         debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n+        // Essentially any user-written impl will match with an error type,\n+        // so creating `ImplCandidates` isn't useful. However, we might\n+        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized)\n+        // This helps us avoid overflow: see issue #72839\n+        // Since compilation is already guaranteed to fail, this is just\n+        // to try to show the 'nicest' possible errors to the user.\n+        if obligation.references_error() {\n+            return Ok(());\n+        }\n+\n         self.tcx().for_each_relevant_impl(\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),"}, {"sha": "7ebf30f61c0956f0a981f4ccdadd4f21607b199e", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -1104,6 +1104,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // who might care about this case, like coherence, should use\n         // that function).\n         if candidates.is_empty() {\n+            // If there's an error type, 'downgrade' our result from\n+            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n+            // emitting additional spurious errors, since we're guaranteed\n+            // to have emitted at least one.\n+            if stack.obligation.references_error() {\n+                debug!(\"no results for error type, treating as ambiguous\");\n+                return Ok(None);\n+            }\n             return Err(Unimplemented);\n         }\n "}, {"sha": "87ff667b6a09a735e4cc7d3f10ed3f81660e2012", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -251,7 +251,10 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n         // fields of ADT.\n         let tcx = self.tcx();\n         for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-            if field_ty.visit_with(self) {\n+            let ty = self.tcx().normalize_erasing_regions(ty::ParamEnv::empty(), field_ty);\n+            debug!(\"structural-match ADT: field_ty={:?}, ty={:?}\", field_ty, ty);\n+\n+            if ty.visit_with(self) {\n                 // found an ADT without structural-match; halt visiting!\n                 assert!(self.found.is_some());\n                 return true;"}, {"sha": "225593c3178a59994851da44de5d8eaaa69d641d", "filename": "src/test/ui/const-generics/issues/issue-72819-generic-in-const-eval.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #72819: ICE due to failure in resolving the const generic in `Arr`'s type\n+// bounds.\n+\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+struct Arr<const N: usize>\n+where Assert::<{N < usize::max_value() / 2}>: IsTrue,\n+//~^ ERROR constant expression depends on a generic parameter\n+{\n+}\n+\n+enum Assert<const CHECK: bool> {}\n+\n+trait IsTrue {}\n+\n+impl IsTrue for Assert<true> {}\n+\n+fn main() {\n+    let x: Arr<{usize::max_value()}> = Arr {};\n+}"}, {"sha": "a9f664d0ac8c5b6ffd12a9475627a6f6ced2a981", "filename": "src/test/ui/const-generics/issues/issue-72819-generic-in-const-eval.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,10 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-72819-generic-in-const-eval.rs:7:47\n+   |\n+LL | where Assert::<{N < usize::max_value() / 2}>: IsTrue,\n+   |                                               ^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error\n+"}, {"sha": "229c5c9e80ff8107b025ec0d993100af9673deb3", "filename": "src/test/ui/derived-errors/issue-31997-1.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -4,12 +4,10 @@ error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n LL |     let mut map = HashMap::new();\n    |                   ^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this struct\n    |\n LL | use std::collections::HashMap;\n    |\n-LL | use std::collections::hash_map::HashMap;\n-   |\n \n error: aborting due to previous error\n "}, {"sha": "990210ffb6b49b80a7395abc5668f851cfa676ba", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -16,9 +16,7 @@ LL |         Vec::new();\n    |         ^^^ not found in this scope\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider importing one of these items\n-   |\n-LL |     use std::prelude::v1::Vec;\n+help: consider importing this struct\n    |\n LL |     use std::vec::Vec;\n    |"}, {"sha": "087f4582b21c3b3db46753486e2e479980b3444e", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -11,8 +11,6 @@ fn main() {\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n     //~^ ERROR cycle detected\n-    //~| ERROR cycle detected\n-    //~| ERROR cycle detected\n     send(cycle2().clone());\n     //~^ ERROR cannot be sent between threads safely\n "}, {"sha": "679b26efe5933c7f4e11fc97abef838e0a80436d", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 9, "deletions": 179, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -36,37 +36,37 @@ LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n note: ...which requires computing type of `cycle2::{{opaque}}#0`...\n-  --> $DIR/auto-trait-leak.rs:22:16\n+  --> $DIR/auto-trait-leak.rs:20:16\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -84,178 +84,8 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error[E0391]: cycle detected when computing type of `cycle1::{{opaque}}#0`\n-  --> $DIR/auto-trait-leak.rs:12:16\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   |                ^^^^^^^^^^\n-   |\n-note: ...which requires borrow-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires type-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires computing type of `cycle2::{{opaque}}#0`...\n-  --> $DIR/auto-trait-leak.rs:22:16\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   |                ^^^^^^^^^^\n-note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires computing type of `cycle1::{{opaque}}#0`, completing the cycle\n-note: cycle used when checking item types in top-level module\n-  --> $DIR/auto-trait-leak.rs:1:1\n-   |\n-LL | / use std::cell::Cell;\n-LL | | use std::rc::Rc;\n-LL | |\n-LL | | fn send<T: Send>(_: T) {}\n-...  |\n-LL | |     Rc::new(String::from(\"foo\"))\n-LL | | }\n-   | |_^\n-\n-error[E0391]: cycle detected when computing type of `cycle1::{{opaque}}#0`\n-  --> $DIR/auto-trait-leak.rs:12:16\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   |                ^^^^^^^^^^\n-   |\n-note: ...which requires borrow-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires type-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n-note: ...which requires computing type of `cycle2::{{opaque}}#0`...\n-  --> $DIR/auto-trait-leak.rs:22:16\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   |                ^^^^^^^^^^\n-note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:22:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires computing type of `cycle1::{{opaque}}#0`, completing the cycle\n-note: cycle used when checking item types in top-level module\n-  --> $DIR/auto-trait-leak.rs:1:1\n-   |\n-LL | / use std::cell::Cell;\n-LL | | use std::rc::Rc;\n-LL | |\n-LL | | fn send<T: Send>(_: T) {}\n-...  |\n-LL | |     Rc::new(String::from(\"foo\"))\n-LL | | }\n-   | |_^\n-\n error[E0277]: `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n-  --> $DIR/auto-trait-leak.rs:16:5\n+  --> $DIR/auto-trait-leak.rs:14:5\n    |\n LL | fn send<T: Send>(_: T) {}\n    |            ---- required by this bound in `send`\n@@ -269,7 +99,7 @@ LL | fn cycle2() -> impl Clone {\n    = help: within `impl std::clone::Clone`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::string::String>`\n    = note: required because it appears within the type `impl std::clone::Clone`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0277, E0391.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "95939cf6b3840763eb7222ad818733a8344a820c", "filename": "src/test/ui/issues/issue-17546.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17546.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -30,11 +30,10 @@ LL |     use std::fmt::Result;\n    |\n LL |     use std::io::Result;\n    |\n-LL |     use std::prelude::v1::Result;\n-   |\n LL |     use std::result::Result;\n    |\n-     and 1 other candidate\n+LL |     use std::thread::Result;\n+   |\n \n error[E0573]: expected type, found variant `Result`\n   --> $DIR/issue-17546.rs:30:13\n@@ -48,11 +47,10 @@ LL | use std::fmt::Result;\n    |\n LL | use std::io::Result;\n    |\n-LL | use std::prelude::v1::Result;\n-   |\n LL | use std::result::Result;\n    |\n-     and 1 other candidate\n+LL | use std::thread::Result;\n+   |\n \n error[E0573]: expected type, found variant `NoResult`\n   --> $DIR/issue-17546.rs:35:15"}, {"sha": "6562d228409f3be683fec286d726c5a6b2303f5c", "filename": "src/test/ui/issues/issue-72839-error-overflow.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fissues%2Fissue-72839-error-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fissues%2Fissue-72839-error-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72839-error-overflow.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,19 @@\n+// Regression test for issue #72839\n+// Tests that we do not overflow during trait selection after\n+// a type error occurs\n+use std::ops::Rem;\n+trait Foo {}\n+struct MyStruct<T>(T);\n+\n+impl<T, U> Rem<MyStruct<T>> for MyStruct<U> where MyStruct<U>: Rem<MyStruct<T>> {\n+    type Output = u8;\n+    fn rem(self, _: MyStruct<T>) -> Self::Output {\n+        panic!()\n+    }\n+}\n+\n+fn main() {}\n+\n+fn foo() {\n+    if missing_var % 8 == 0 {} //~ ERROR cannot find\n+}"}, {"sha": "c4b6f90ca69a31725c34944fdee670e82fb21514", "filename": "src/test/ui/issues/issue-72839-error-overflow.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fissues%2Fissue-72839-error-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fissues%2Fissue-72839-error-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72839-error-overflow.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `missing_var` in this scope\n+  --> $DIR/issue-72839-error-overflow.rs:18:8\n+   |\n+LL |     if missing_var % 8 == 0 {}\n+   |        ^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "1e6a35ed479f690d495865ee92fb0d900eb611e0", "filename": "src/test/ui/lexical-scopes.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Flexical-scopes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Flexical-scopes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexical-scopes.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -3,11 +3,6 @@ error[E0574]: expected struct, variant or union type, found type parameter `T`\n    |\n LL |     let t = T { i: 0 };\n    |             ^ not a struct, variant or union type\n-   |\n-help: consider importing this struct instead\n-   |\n-LL | use T;\n-   |\n \n error[E0599]: no function or associated item named `f` found for type parameter `Foo` in the current scope\n   --> $DIR/lexical-scopes.rs:10:10"}, {"sha": "ebab41d143e675b2e37dcfd87144c5f45105859e", "filename": "src/test/ui/lint/lint-ctypes-66202.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-66202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Flint%2Flint-ctypes-66202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-ctypes-66202.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![deny(improper_ctypes)]\n+\n+// This test checks that return types are normalized before being checked for FFI-safety, and that\n+// transparent newtype wrappers are FFI-safe if the type being wrapped is FFI-safe.\n+\n+#[repr(transparent)]\n+pub struct W<T>(T);\n+\n+extern \"C\" {\n+    pub fn bare() -> ();\n+    pub fn normalize() -> <() as ToOwned>::Owned;\n+    pub fn transparent() -> W<()>;\n+}\n+\n+fn main() {}"}, {"sha": "3a8b82037310a41360207dce21544e9d56c80740", "filename": "src/test/ui/match/issue-72896.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fmatch%2Fissue-72896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fmatch%2Fissue-72896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-72896.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+trait EnumSetType {\n+    type Repr;\n+}\n+\n+enum Enum8 { }\n+impl EnumSetType for Enum8 {\n+    type Repr = u8;\n+}\n+\n+#[derive(PartialEq, Eq)]\n+struct EnumSet<T: EnumSetType> {\n+    __enumset_underlying: T::Repr,\n+}\n+\n+const CONST_SET: EnumSet<Enum8> = EnumSet { __enumset_underlying: 3 };\n+\n+fn main() {\n+    match CONST_SET {\n+        CONST_SET => { /* ok */ }\n+        _ => panic!(\"match fell through?\"),\n+    }\n+}"}, {"sha": "198b630c52c8fd96615f367970256fd3bc6896e3", "filename": "src/test/ui/no-implicit-prelude-nested.stderr", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-implicit-prelude-nested.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -15,35 +15,29 @@ error[E0404]: expected trait, found derive macro `Clone`\n LL |         impl Clone for Test {}\n    |              ^^^^^ not a trait\n    |\n-help: consider importing one of these items instead\n+help: consider importing this trait instead\n    |\n LL |         use std::clone::Clone;\n    |\n-LL |         use std::prelude::v1::Clone;\n-   |\n \n error[E0405]: cannot find trait `Iterator` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:13:14\n    |\n LL |         impl Iterator for Test {}\n    |              ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this trait\n    |\n LL |         use std::iter::Iterator;\n    |\n-LL |         use std::prelude::v1::Iterator;\n-   |\n \n error[E0405]: cannot find trait `ToString` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:14:14\n    |\n LL |         impl ToString for Test {}\n    |              ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n-   |\n-LL |         use std::prelude::v1::ToString;\n+help: consider importing this trait\n    |\n LL |         use std::string::ToString;\n    |\n@@ -60,12 +54,10 @@ error[E0425]: cannot find function `drop` in this scope\n LL |             drop(2)\n    |             ^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this function\n    |\n LL |         use std::mem::drop;\n    |\n-LL |         use std::prelude::v1::drop;\n-   |\n \n error[E0405]: cannot find trait `Add` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:23:10\n@@ -84,35 +76,29 @@ error[E0404]: expected trait, found derive macro `Clone`\n LL |     impl Clone for Test {}\n    |          ^^^^^ not a trait\n    |\n-help: consider importing one of these items instead\n+help: consider importing this trait instead\n    |\n LL |     use std::clone::Clone;\n    |\n-LL |     use std::prelude::v1::Clone;\n-   |\n \n error[E0405]: cannot find trait `Iterator` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:25:10\n    |\n LL |     impl Iterator for Test {}\n    |          ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this trait\n    |\n LL |     use std::iter::Iterator;\n    |\n-LL |     use std::prelude::v1::Iterator;\n-   |\n \n error[E0405]: cannot find trait `ToString` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:26:10\n    |\n LL |     impl ToString for Test {}\n    |          ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n-   |\n-LL |     use std::prelude::v1::ToString;\n+help: consider importing this trait\n    |\n LL |     use std::string::ToString;\n    |\n@@ -129,12 +115,10 @@ error[E0425]: cannot find function `drop` in this scope\n LL |         drop(2)\n    |         ^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this function\n    |\n LL |     use std::mem::drop;\n    |\n-LL |     use std::prelude::v1::drop;\n-   |\n \n error[E0405]: cannot find trait `Add` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:38:14\n@@ -153,35 +137,29 @@ error[E0404]: expected trait, found derive macro `Clone`\n LL |         impl Clone for Test {}\n    |              ^^^^^ not a trait\n    |\n-help: consider importing one of these items instead\n+help: consider importing this trait instead\n    |\n LL |         use std::clone::Clone;\n    |\n-LL |         use std::prelude::v1::Clone;\n-   |\n \n error[E0405]: cannot find trait `Iterator` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:40:14\n    |\n LL |         impl Iterator for Test {}\n    |              ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this trait\n    |\n LL |         use std::iter::Iterator;\n    |\n-LL |         use std::prelude::v1::Iterator;\n-   |\n \n error[E0405]: cannot find trait `ToString` in this scope\n   --> $DIR/no-implicit-prelude-nested.rs:41:14\n    |\n LL |         impl ToString for Test {}\n    |              ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n-   |\n-LL |         use std::prelude::v1::ToString;\n+help: consider importing this trait\n    |\n LL |         use std::string::ToString;\n    |\n@@ -198,12 +176,10 @@ error[E0425]: cannot find function `drop` in this scope\n LL |             drop(2)\n    |             ^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this function\n    |\n LL |         use std::mem::drop;\n    |\n-LL |         use std::prelude::v1::drop;\n-   |\n \n error: aborting due to 18 previous errors\n "}, {"sha": "36a9b65b7d1613d3d3ea683a197e226cac0dc4a0", "filename": "src/test/ui/no-implicit-prelude.stderr", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fno-implicit-prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fno-implicit-prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-implicit-prelude.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -15,35 +15,29 @@ error[E0404]: expected trait, found derive macro `Clone`\n LL | impl Clone for Test {}\n    |      ^^^^^ not a trait\n    |\n-help: consider importing one of these items instead\n+help: consider importing this trait instead\n    |\n LL | use std::clone::Clone;\n    |\n-LL | use std::prelude::v1::Clone;\n-   |\n \n error[E0405]: cannot find trait `Iterator` in this scope\n   --> $DIR/no-implicit-prelude.rs:12:6\n    |\n LL | impl Iterator for Test {}\n    |      ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this trait\n    |\n LL | use std::iter::Iterator;\n    |\n-LL | use std::prelude::v1::Iterator;\n-   |\n \n error[E0405]: cannot find trait `ToString` in this scope\n   --> $DIR/no-implicit-prelude.rs:13:6\n    |\n LL | impl ToString for Test {}\n    |      ^^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n-   |\n-LL | use std::prelude::v1::ToString;\n+help: consider importing this trait\n    |\n LL | use std::string::ToString;\n    |\n@@ -60,12 +54,10 @@ error[E0425]: cannot find function `drop` in this scope\n LL |     drop(2)\n    |     ^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this function\n    |\n LL | use std::mem::drop;\n    |\n-LL | use std::prelude::v1::drop;\n-   |\n \n error: aborting due to 6 previous errors\n "}, {"sha": "719555c092a7878c7c3a47c1ff2c7e96afcbcda9", "filename": "src/test/ui/proc-macro/empty-where-clause.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fproc-macro%2Fempty-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fproc-macro%2Fempty-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fempty-where-clause.rs?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,18 @@\n+// aux-build:test-macros.rs\n+\n+extern crate test_macros;\n+use test_macros::recollect_attr;\n+\n+#[recollect_attr]\n+struct FieldStruct where {\n+    field: MissingType1 //~ ERROR cannot find\n+}\n+\n+#[recollect_attr]\n+struct TupleStruct(MissingType2) where; //~ ERROR cannot find\n+\n+enum MyEnum where {\n+    Variant(MissingType3) //~ ERROR cannot find\n+}\n+\n+fn main() {}"}, {"sha": "192a2b30f0dcdfaea7e046906448b81289a019b0", "filename": "src/test/ui/proc-macro/empty-where-clause.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fproc-macro%2Fempty-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fproc-macro%2Fempty-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fempty-where-clause.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -0,0 +1,21 @@\n+error[E0412]: cannot find type `MissingType1` in this scope\n+  --> $DIR/empty-where-clause.rs:8:12\n+   |\n+LL |     field: MissingType1\n+   |            ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `MissingType2` in this scope\n+  --> $DIR/empty-where-clause.rs:12:20\n+   |\n+LL | struct TupleStruct(MissingType2) where;\n+   |                    ^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `MissingType3` in this scope\n+  --> $DIR/empty-where-clause.rs:15:13\n+   |\n+LL |     Variant(MissingType3)\n+   |             ^^^^^^^^^^^^ not found in this scope\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "6244ffc47a64bf19a306495b92328cd60f3ceabd", "filename": "src/test/ui/proc-macro/mixed-site-span.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fproc-macro%2Fmixed-site-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fproc-macro%2Fmixed-site-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmixed-site-span.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -27,10 +27,6 @@ LL | pass_dollar_crate!();\n    | ^^^^^^^^^^^^^^^^^^^^^ not found in `$crate`\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: consider importing this struct\n-   |\n-LL | use ItemUse;\n-   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "72dda94072962492f7f6f0322b96c99833e48f44", "filename": "src/test/ui/resolve/use_suggestion.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -10,25 +10,21 @@ error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n LL |     let x1 = HashMap::new();\n    |              ^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this struct\n    |\n LL | use std::collections::HashMap;\n    |\n-LL | use std::collections::hash_map::HashMap;\n-   |\n \n error[E0412]: cannot find type `HashMap` in this scope\n   --> $DIR/use_suggestion.rs:5:13\n    |\n LL |     let y1: HashMap;\n    |             ^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this struct\n    |\n LL | use std::collections::HashMap;\n    |\n-LL | use std::collections::hash_map::HashMap;\n-   |\n \n error[E0412]: cannot find type `GooMap` in this scope\n   --> $DIR/use_suggestion.rs:6:13"}, {"sha": "3f91760fe216b59c37beccfcd3a12df8f425e8e3", "filename": "src/test/ui/resolve/use_suggestion_placement.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -26,12 +26,10 @@ error[E0412]: cannot find type `HashMap` in this scope\n LL |     type Dict<K, V> = HashMap<K, V>;\n    |                       ^^^^^^^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this struct\n    |\n LL | use std::collections::HashMap;\n    |\n-LL | use std::collections::hash_map::HashMap;\n-   |\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0895bafb4d112afc772766e143e1d409e4a313c4", "filename": "triagebot.toml", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ec42485ee95e3843a65b47533f6bcbcf06d9564e/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ec42485ee95e3843a65b47533f6bcbcf06d9564e/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=ec42485ee95e3843a65b47533f6bcbcf06d9564e", "patch": "@@ -20,7 +20,7 @@ Hey LLVM ICE-breakers! This bug has been identified as a good\n [instructions] for tackling these sorts of bugs. Maybe take a look?\n Thanks! <3\n \n-[instructions]: https://rustc-dev-guide.rust-lang.org/ice-breaker/llvm.html\n+[instructions]: https://rustc-dev-guide.rust-lang.org/notification-groups/llvm.html\n \"\"\"\n label = \"ICEBreaker-LLVM\"\n \n@@ -32,10 +32,30 @@ Hey Cleanup Crew ICE-breakers! This bug has been identified as a good\n [instructions] for tackling these sorts of bugs. Maybe take a look?\n Thanks! <3\n \n-[instructions]: https://rustc-dev-guide.rust-lang.org/ice-breaker/cleanup-crew.html\n+[instructions]: https://rustc-dev-guide.rust-lang.org/notification-groups/cleanup-crew.html\n \"\"\"\n label = \"ICEBreaker-Cleanup-Crew\"\n \n+[ping.windows]\n+message = \"\"\"\\\n+Hey Windows Group! This bug has been identified as a good \"Windows candidate\".\n+In case it's useful, here are some [instructions] for tackling these sorts of\n+bugs. Maybe take a look?\n+Thanks! <3\n+[instructions]: https://rustc-dev-guide.rust-lang.org/notification-groups/windows.html\n+\"\"\"\n+label = \"O-windows\"\n+\n+[ping.arm]\n+message = \"\"\"\\\n+Hey ARM Group! This bug has been identified as a good \"ARM candidate\".\n+In case it's useful, here are some [instructions] for tackling these sorts of\n+bugs. Maybe take a look?\n+Thanks! <3\n+[instructions]: https://rustc-dev-guide.rust-lang.org/notification-groups/arm.html\n+\"\"\"\n+label = \"O-ARM\"\n+\n [prioritize]\n label = \"I-prioritize\"\n prioritize_on = [\"regression-from-stable-to-stable\", \"regression-from-stable-to-beta\", \"regression-from-stable-to-nightly\"]"}]}