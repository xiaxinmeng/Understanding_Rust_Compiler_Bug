{"sha": "964fb67a5fa1b99add4efb01a7dc2a02add4b071", "node_id": "C_kwDOAAsO6NoAKDk2NGZiNjdhNWZhMWI5OWFkZDRlZmIwMWE3ZGMyYTAyYWRkNGIwNzE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-20T03:56:36Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-04T18:05:58Z"}, "message": "Use fulfillment to check Drop impl compatibility", "tree": {"sha": "a26d44a8f94e8ba818d328ba8d4e41de99d6e9cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a26d44a8f94e8ba818d328ba8d4e41de99d6e9cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/964fb67a5fa1b99add4efb01a7dc2a02add4b071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/964fb67a5fa1b99add4efb01a7dc2a02add4b071", "html_url": "https://github.com/rust-lang/rust/commit/964fb67a5fa1b99add4efb01a7dc2a02add4b071", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/964fb67a5fa1b99add4efb01a7dc2a02add4b071/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eac35583d2ffb5ed9e564dee0822c9a244058ee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eac35583d2ffb5ed9e564dee0822c9a244058ee0", "html_url": "https://github.com/rust-lang/rust/commit/eac35583d2ffb5ed9e564dee0822c9a244058ee0"}], "stats": {"total": 342, "additions": 108, "deletions": 234}, "files": [{"sha": "5ba1ca1c807bce908450ca87d5c4b7d87ddc1e0e", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 91, "deletions": 233, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=964fb67a5fa1b99add4efb01a7dc2a02add4b071", "patch": "@@ -1,12 +1,14 @@\n // FIXME(@lcnr): Move this module out of `rustc_hir_analysis`.\n //\n // We don't do any drop checking during hir typeck.\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::IgnoreRegions;\n-use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n use crate::errors;\n use crate::hir::def_id::{DefId, LocalDefId};\n@@ -43,21 +45,20 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n         }\n     }\n     let dtor_self_type = tcx.type_of(drop_impl_did).subst_identity();\n-    let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.kind() {\n-        ty::Adt(adt_def, self_to_impl_substs) => {\n+        ty::Adt(adt_def, adt_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,\n                 drop_impl_did.expect_local(),\n                 adt_def.did(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n                 tcx,\n-                dtor_predicates,\n+                drop_impl_did.expect_local(),\n                 adt_def.did().expect_local(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )\n         }\n         _ => {\n@@ -78,9 +79,9 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     drop_impl_did: LocalDefId,\n     self_type_did: DefId,\n-    drop_impl_substs: SubstsRef<'tcx>,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let Err(arg) = tcx.uses_unique_generic_params(drop_impl_substs, IgnoreRegions::No) else {\n+    let Err(arg) = tcx.uses_unique_generic_params(adt_to_impl_substs, IgnoreRegions::No) else {\n         return Ok(())\n     };\n \n@@ -111,237 +112,94 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    dtor_predicates: ty::GenericPredicates<'tcx>,\n-    self_type_did: LocalDefId,\n-    self_to_impl_substs: SubstsRef<'tcx>,\n+    drop_impl_def_id: LocalDefId,\n+    adt_def_id: LocalDefId,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let mut result = Ok(());\n-\n-    // Here is an example, analogous to that from\n-    // `compare_impl_method`.\n-    //\n-    // Consider a struct type:\n-    //\n-    //     struct Type<'c, 'b:'c, 'a> {\n-    //         x: &'a Contents            // (contents are irrelevant;\n-    //         y: &'c Cell<&'b Contents>, //  only the bounds matter for our purposes.)\n-    //     }\n-    //\n-    // and a Drop impl:\n-    //\n-    //     impl<'z, 'y:'z, 'x:'y> Drop for P<'z, 'y, 'x> {\n-    //         fn drop(&mut self) { self.y.set(self.x); } // (only legal if 'x: 'y)\n-    //     }\n-    //\n-    // We start out with self_to_impl_substs, that maps the generic\n-    // parameters of Type to that of the Drop impl.\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n+    // Take the param-env of the adt and substitute the substs that show up in\n+    // the implementation's self type. This gives us the assumptions that the\n+    // self ty of the implementation is allowed to know just from it being a\n+    // well-formed adt, since that's all we're allowed to assume while proving\n+    // the Drop implementation is not specialized.\n     //\n-    //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n-    //\n-    // Applying this to the predicates (i.e., assumptions) provided by the item\n-    // definition yields the instantiated assumptions:\n-    //\n-    //     ['y : 'z]\n-    //\n-    // We then check all of the predicates of the Drop impl:\n-    //\n-    //     ['y:'z, 'x:'y]\n-    //\n-    // and ensure each is in the list of instantiated\n-    // assumptions. Here, `'y:'z` is present, but `'x:'y` is\n-    // absent. So we report an error that the Drop impl injected a\n-    // predicate that is not present on the struct definition.\n-\n-    // We can assume the predicates attached to struct/enum definition\n-    // hold.\n-    let generic_assumptions = tcx.predicates_of(self_type_did);\n-\n-    let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n-    let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n-\n-    debug!(?assumptions_in_impl_context, ?dtor_predicates.predicates);\n-\n-    let self_param_env = tcx.param_env(self_type_did);\n-\n-    // An earlier version of this code attempted to do this checking\n-    // via the traits::fulfill machinery. However, it ran into trouble\n-    // since the fulfill machinery merely turns outlives-predicates\n-    // 'a:'b and T:'b into region inference constraints. It is simpler\n-    // just to look for all the predicates directly.\n-\n-    assert_eq!(dtor_predicates.parent, None);\n-    for &(predicate, predicate_sp) in dtor_predicates.predicates {\n-        // (We do not need to worry about deep analysis of type\n-        // expressions etc because the Drop impls are already forced\n-        // to take on a structure that is roughly an alpha-renaming of\n-        // the generic parameters of the item definition.)\n-\n-        // This path now just checks *all* predicates via an instantiation of\n-        // the `SimpleEqRelation`, which simply forwards to the `relate` machinery\n-        // after taking care of anonymizing late bound regions.\n-        //\n-        // However, it may be more efficient in the future to batch\n-        // the analysis together via the fulfill (see comment above regarding\n-        // the usage of the fulfill machinery), rather than the\n-        // repeated `.iter().any(..)` calls.\n+    // We don't need to normalize this param-env or anything, since we're only\n+    // substituting it with free params, so no additional param-env normalization\n+    // can occur on top of what has been done in the param_env query itself.\n+    let param_env = ty::EarlyBinder(tcx.param_env(adt_def_id))\n+        .subst(tcx, adt_to_impl_substs)\n+        .with_constness(tcx.constness(drop_impl_def_id));\n+\n+    for (pred, span) in tcx.predicates_of(drop_impl_def_id).instantiate_identity(tcx) {\n+        let normalize_cause = traits::ObligationCause::misc(span, adt_def_id);\n+        let pred = ocx.normalize(&normalize_cause, param_env, pred);\n+        let cause = traits::ObligationCause::new(span, adt_def_id, traits::DropImpl);\n+        ocx.register_obligation(traits::Obligation::new(tcx, cause, param_env, pred));\n+    }\n \n-        // This closure is a more robust way to check `Predicate` equality\n-        // than simple `==` checks (which were the previous implementation).\n-        // It relies on `ty::relate` for `TraitPredicate`, `ProjectionPredicate`,\n-        // `ConstEvaluatable` and `TypeOutlives` (which implement the Relate trait),\n-        // while delegating on simple equality for the other `Predicate`.\n-        // This implementation solves (Issue #59497) and (Issue #58311).\n-        // It is unclear to me at the moment whether the approach based on `relate`\n-        // could be extended easily also to the other `Predicate`.\n-        let predicate_matches_closure = |p: Predicate<'tcx>| {\n-            let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            let predicate = predicate.kind();\n-            let p = p.kind();\n-            match (predicate.skip_binder(), p.skip_binder()) {\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::ConstEvaluatable(a),\n-                    ty::PredicateKind::ConstEvaluatable(b),\n-                ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_a,\n-                        lt_a,\n-                    ))),\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_b,\n-                        lt_b,\n-                    ))),\n-                ) => {\n-                    relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n-                        && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()\n-                }\n-                (ty::PredicateKind::WellFormed(arg_a), ty::PredicateKind::WellFormed(arg_b)) => {\n-                    relator.relate(predicate.rebind(arg_a), p.rebind(arg_b)).is_ok()\n-                }\n-                _ => predicate == p,\n+    // All of the custom error reporting logic is to preserve parity with the old\n+    // error messages.\n+    //\n+    // They can probably get removed with better treatment of the new `DropImpl`\n+    // obligation cause code, and perhaps some custom logic in `report_region_errors`.\n+\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        let mut root_predicates = FxHashSet::default();\n+        for error in errors {\n+            let root_predicate = error.root_obligation.predicate;\n+            if root_predicates.insert(root_predicate) {\n+                let item_span = tcx.def_span(adt_def_id);\n+                let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+                guar = Some(\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        error.root_obligation.cause.span,\n+                        E0367,\n+                        \"`Drop` impl requires `{root_predicate}` \\\n+                        but the {self_descr} it is implemented for does not\",\n+                    )\n+                    .span_note(item_span, \"the implementor must specify the same requirement\")\n+                    .emit(),\n+                );\n             }\n-        };\n-\n-        if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n-            let item_span = tcx.def_span(self_type_did);\n-            let self_descr = tcx.def_descr(self_type_did.to_def_id());\n-            let reported = struct_span_err!(\n-                tcx.sess,\n-                predicate_sp,\n-                E0367,\n-                \"`Drop` impl requires `{predicate}` but the {self_descr} it is implemented for does not\",\n-            )\n-            .span_note(item_span, \"the implementor must specify the same requirement\")\n-            .emit();\n-            result = Err(reported);\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    result\n-}\n-\n-/// This is an implementation of the [`TypeRelation`] trait with the\n-/// aim of simply comparing for equality (without side-effects).\n-///\n-/// It is not intended to be used anywhere else other than here.\n-pub(crate) struct SimpleEqRelation<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> SimpleEqRelation<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> SimpleEqRelation<'tcx> {\n-        SimpleEqRelation { tcx, param_env }\n-    }\n-}\n-\n-impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"dropck::SimpleEqRelation\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        // Here we ignore variance because we require drop impl's types\n-        // to be *exactly* the same as to the ones in the struct definition.\n-        self.relate(a, b)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"SimpleEqRelation::tys(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_tys(self, a, b)\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"SimpleEqRelation::regions(a={:?}, b={:?})\", a, b);\n-\n-        // We can just equate the regions because LBRs have been\n-        // already anonymized.\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            // I'm not sure is this `TypeError` is the right one, but\n-            // it should not matter as it won't be checked (the dropck\n-            // will emit its own, more informative and higher-level errors\n-            // in case anything goes wrong).\n-            Err(TypeError::RegionsPlaceholderMismatch)\n+    let errors = ocx.infcx.resolve_regions(&OutlivesEnvironment::new(param_env));\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        for error in errors {\n+            let item_span = tcx.def_span(adt_def_id);\n+            let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+            let outlives = match error {\n+                RegionResolutionError::ConcreteFailure(_, a, b) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::GenericBoundFailure(_, generic, r) => {\n+                    format!(\"{generic}: {r}\")\n+                }\n+                RegionResolutionError::SubSupConflict(_, _, _, a, _, b, _) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::UpperBoundUniverseConflict(a, _, _, _, b) => {\n+                    format!(\"{b}: {a}\", a = tcx.mk_re_var(a))\n+                }\n+            };\n+            guar = Some(\n+                struct_span_err!(\n+                    tcx.sess,\n+                    error.origin().span(),\n+                    E0367,\n+                    \"`Drop` impl requires `{outlives}` \\\n+                    but the {self_descr} it is implemented for does not\",\n+                )\n+                .span_note(item_span, \"the implementor must specify the same requirement\")\n+                .emit(),\n+            );\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        b: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_consts(self, a, b)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"SimpleEqRelation::binders({:?}: {:?}\", a, b);\n-\n-        // Anonymizing the LBRs is necessary to solve (Issue #59497).\n-        // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_bound_vars(a);\n-        let anon_b = self.tcx.anonymize_bound_vars(b);\n-        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n-\n-        Ok(a)\n-    }\n+    Ok(())\n }"}, {"sha": "8482ae2aa38c81f7645036c9d044aac9513ac020", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=964fb67a5fa1b99add4efb01a7dc2a02add4b071", "patch": "@@ -102,6 +102,17 @@ pub enum RegionResolutionError<'tcx> {\n     ),\n }\n \n+impl<'tcx> RegionResolutionError<'tcx> {\n+    pub fn origin(&self) -> &SubregionOrigin<'tcx> {\n+        match self {\n+            RegionResolutionError::ConcreteFailure(origin, _, _)\n+            | RegionResolutionError::GenericBoundFailure(origin, _, _)\n+            | RegionResolutionError::SubSupConflict(_, _, origin, _, _, _, _)\n+            | RegionResolutionError::UpperBoundUniverseConflict(_, _, _, origin, _) => origin,\n+        }\n+    }\n+}\n+\n struct RegionAndOrigin<'tcx> {\n     region: Region<'tcx>,\n     origin: SubregionOrigin<'tcx>,"}, {"sha": "8366567c2c3649c15ebaf372f145ee53631bcac9", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=964fb67a5fa1b99add4efb01a7dc2a02add4b071", "patch": "@@ -444,6 +444,10 @@ pub enum ObligationCauseCode<'tcx> {\n     AscribeUserTypeProvePredicate(Span),\n \n     RustCall,\n+\n+    /// Obligations to prove that a `std::ops::Drop` impl is not stronger than\n+    /// the ADT it's being implemented for.\n+    DropImpl,\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "37beb31a7a4c017882c9165f9c0600801a7b76e0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/964fb67a5fa1b99add4efb01a7dc2a02add4b071/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=964fb67a5fa1b99add4efb01a7dc2a02add4b071", "patch": "@@ -2790,7 +2790,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::LetElse\n             | ObligationCauseCode::BinOp { .. }\n             | ObligationCauseCode::AscribeUserTypeProvePredicate(..)\n-            | ObligationCauseCode::RustCall => {}\n+            | ObligationCauseCode::RustCall\n+            | ObligationCauseCode::DropImpl => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}]}