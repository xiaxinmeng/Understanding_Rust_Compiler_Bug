{"sha": "5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNmRiZjNmMjYyZmFiY2I2Y2I5MjBkZDA4YmU2ZjlkOGRmNzVkNWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-26T02:08:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-27T17:53:48Z"}, "message": "Improve the rt::thread module\n\n* Added doc comments explaining what all public functionality does.\n* Added the ability to spawn a detached thread\n* Added the ability for the procs to return a value in 'join'", "tree": {"sha": "8218728771f9eb50c20a621736c0dd4e682d15b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8218728771f9eb50c20a621736c0dd4e682d15b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "html_url": "https://github.com/rust-lang/rust/commit/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed86b48cc9a8349e8e99de5f013f68f1edff4121", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed86b48cc9a8349e8e99de5f013f68f1edff4121", "html_url": "https://github.com/rust-lang/rust/commit/ed86b48cc9a8349e8e99de5f013f68f1edff4121"}], "stats": {"total": 216, "additions": 154, "deletions": 62}, "files": [{"sha": "6355de36d43bb5d857dd9cb25b43ded57379ccce", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "patch": "@@ -41,6 +41,8 @@ pub static mut RT_TLS_PTR: *mut c_void = 0 as *mut c_void;\n #[cfg(stage0)]\n #[cfg(windows)]\n static mut RT_TLS_KEY: tls::Key = -1;\n+#[cfg(stage0)]\n+#[cfg(windows)]\n static mut tls_lock: Mutex = MUTEX_INIT;\n static mut tls_initialized: bool = false;\n \n@@ -60,7 +62,11 @@ pub fn init_tls_key() {\n }\n \n #[cfg(not(stage0), not(windows))]\n-pub fn init_tls_key() {}\n+pub fn init_tls_key() {\n+    unsafe {\n+        tls_initialized = true;\n+    }\n+}\n \n #[cfg(windows)]\n pub unsafe fn cleanup() {\n@@ -76,7 +82,6 @@ pub unsafe fn cleanup() {\n #[cfg(not(windows))]\n pub unsafe fn cleanup() {\n     assert!(tls_initialized);\n-    tls_lock.destroy();\n     tls_initialized = false;\n }\n "}, {"sha": "943b76dd1a0ecd992bef605e8144f9fdd5517668", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "patch": "@@ -336,7 +336,7 @@ pub fn spawntask_try(f: proc()) -> Result<(),()> {\n }\n \n /// Spawn a new task in a new scheduler and return a thread handle.\n-pub fn spawntask_thread(f: proc()) -> Thread {\n+pub fn spawntask_thread(f: proc()) -> Thread<()> {\n \n     let f = Cell::new(f);\n "}, {"sha": "9031147f8b139a6a128afdb41849113b511d3bf8", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 145, "deletions": 58, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "patch": "@@ -8,126 +8,213 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Native os-thread management\n+//!\n+//! This modules contains bindings necessary for managing OS-level threads.\n+//! These functions operate outside of the rust runtime, creating threads\n+//! which are not used for scheduling in any way.\n+\n #[allow(non_camel_case_types)];\n \n use cast;\n+use kinds::Send;\n use libc;\n use ops::Drop;\n-use uint;\n+use option::{Option, Some, None};\n use ptr;\n+use uint;\n \n #[cfg(windows)]\n use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T,\n                                    LPVOID, DWORD, LPDWORD, HANDLE};\n \n #[cfg(windows)] type rust_thread = HANDLE;\n #[cfg(unix)] type rust_thread = libc::pthread_t;\n+#[cfg(windows)] type rust_thread_return = DWORD;\n+#[cfg(unix)] type rust_thread_return = *libc::c_void;\n \n-pub struct Thread {\n+type StartFn = extern \"C\" fn(*libc::c_void) -> rust_thread_return;\n+\n+/// This struct represents a native thread's state. This is used to join on an\n+/// existing thread created in the join-able state.\n+pub struct Thread<T> {\n     priv native: rust_thread,\n-    priv joined: bool\n+    priv joined: bool,\n+    priv packet: ~Option<T>,\n }\n \n static DEFAULT_STACK_SIZE: libc::size_t = 1024*1024;\n \n-#[cfg(windows)] type rust_thread_return = DWORD;\n-#[cfg(unix)] type rust_thread_return = *libc::c_void;\n+// This is the starting point of rust os threads. The first thing we do\n+// is make sure that we don't trigger __morestack (also why this has a\n+// no_split_stack annotation), and then we extract the main function\n+// and invoke it.\n+#[no_split_stack]\n+extern fn thread_start(main: *libc::c_void) -> rust_thread_return {\n+    use rt::context;\n+    unsafe {\n+        context::record_stack_bounds(0, uint::max_value);\n+        let f: ~proc() = cast::transmute(main);\n+        (*f)();\n+        cast::transmute(0 as rust_thread_return)\n+    }\n+}\n \n-impl Thread {\n-\n-    pub fn start(main: proc()) -> Thread {\n-        // This is the starting point of rust os threads. The first thing we do\n-        // is make sure that we don't trigger __morestack (also why this has a\n-        // no_split_stack annotation), and then we extract the main function\n-        // and invoke it.\n-        #[no_split_stack]\n-        extern \"C\" fn thread_start(trampoline: *libc::c_void) -> rust_thread_return {\n-            use rt::context;\n-            unsafe {\n-                context::record_stack_bounds(0, uint::max_value);\n-                let f: ~proc() = cast::transmute(trampoline);\n-                (*f)();\n-            }\n-            unsafe { cast::transmute(0 as rust_thread_return) }\n-        }\n+// There are two impl blocks b/c if T were specified at the top then it's just a\n+// pain to specify a type parameter on Thread::spawn (which doesn't need the\n+// type parameter).\n+impl Thread<()> {\n+\n+    /// Starts execution of a new OS thread.\n+    ///\n+    /// This function will not wait for the thread to join, but a handle to the\n+    /// thread will be returned.\n+    ///\n+    /// Note that the handle returned is used to acquire the return value of the\n+    /// procedure `main`. The `join` function will wait for the thread to finish\n+    /// and return the value that `main` generated.\n+    ///\n+    /// Also note that the `Thread` returned will *always* wait for the thread\n+    /// to finish executing. This means that even if `join` is not explicitly\n+    /// called, when the `Thread` falls out of scope its destructor will block\n+    /// waiting for the OS thread.\n+    pub fn start<T: Send>(main: proc() -> T) -> Thread<T> {\n+\n+        // We need the address of the packet to fill in to be stable so when\n+        // `main` fills it in it's still valid, so allocate an extra ~ box to do\n+        // so.\n+        let packet = ~None;\n+        let packet2: *mut Option<T> = unsafe {\n+            *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n+        };\n+        let main: proc() = proc() unsafe { *packet2 = Some(main()); };\n+        let native = unsafe { native_thread_create(~main) };\n \n-        let native = native_thread_create(thread_start, ~main);\n         Thread {\n             native: native,\n             joined: false,\n+            packet: packet,\n         }\n     }\n \n-    pub fn join(mut self) {\n+    /// This will spawn a new thread, but it will not wait for the thread to\n+    /// finish, nor is it possible to wait for the thread to finish.\n+    ///\n+    /// This corresponds to creating threads in the 'detached' state on unix\n+    /// systems. Note that platforms may not keep the main program alive even if\n+    /// there are detached thread still running around.\n+    pub fn spawn(main: proc()) {\n+        unsafe {\n+            let handle = native_thread_create(~main);\n+            native_thread_detach(handle);\n+        }\n+    }\n+}\n+\n+impl<T: Send> Thread<T> {\n+    /// Wait for this thread to finish, returning the result of the thread's\n+    /// calculation.\n+    pub fn join(mut self) -> T {\n         assert!(!self.joined);\n-        native_thread_join(self.native);\n+        unsafe { native_thread_join(self.native) };\n         self.joined = true;\n+        assert!(self.packet.is_some());\n+        self.packet.take_unwrap()\n     }\n }\n \n-#[cfg(windows)]\n-fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~proc()) -> rust_thread {\n-    unsafe {\n-        let ptr: *mut libc::c_void = cast::transmute(tramp);\n-        CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start, ptr, 0, ptr::mut_null())\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Thread<T> {\n+    fn drop(&mut self) {\n+        // This is required for correctness. If this is not done then the thread\n+        // would fill in a return box which no longer exists.\n+        if !self.joined {\n+            unsafe { native_thread_join(self.native) };\n+        }\n     }\n }\n \n #[cfg(windows)]\n-fn native_thread_join(native: rust_thread) {\n+unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n+    let arg: *mut libc::c_void = cast::transmute(p);\n+    CreateThread(ptr::mut_null(), DEFAULT_STACK_SIZE, thread_start,\n+                 arg, 0, ptr::mut_null())\n+}\n+\n+#[cfg(windows)]\n+unsafe fn native_thread_join(native: rust_thread) {\n     use libc::consts::os::extra::INFINITE;\n-    unsafe { WaitForSingleObject(native, INFINITE); }\n+    WaitForSingleObject(native, INFINITE);\n+}\n+\n+#[cfg(windows)]\n+unsafe fn native_thread_detach(native: rust_thread) {\n+    assert!(libc::CloseHandle(native) != 0);\n }\n \n #[cfg(unix)]\n-fn native_thread_create(thread_start: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                        tramp: ~proc()) -> rust_thread {\n+unsafe fn native_thread_create(p: ~proc()) -> rust_thread {\n     use unstable::intrinsics;\n-    let mut native: libc::pthread_t = unsafe { intrinsics::uninit() };\n-\n-    unsafe {\n-        use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n+    use libc::consts::os::posix01::PTHREAD_CREATE_JOINABLE;\n \n-        let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n-        assert!(pthread_attr_init(&mut attr) == 0);\n-        assert!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE) == 0);\n-        assert!(pthread_attr_setdetachstate(&mut attr, PTHREAD_CREATE_JOINABLE) == 0);\n+    let mut native: libc::pthread_t = intrinsics::uninit();\n+    let mut attr: libc::pthread_attr_t = intrinsics::uninit();\n+    assert_eq!(pthread_attr_init(&mut attr), 0);\n+    assert_eq!(pthread_attr_setstacksize(&mut attr, DEFAULT_STACK_SIZE), 0);\n+    assert_eq!(pthread_attr_setdetachstate(&mut attr, PTHREAD_CREATE_JOINABLE), 0);\n \n-        let ptr: *libc::c_void = cast::transmute(tramp);\n-        assert!(pthread_create(&mut native, &attr, thread_start, ptr) == 0);\n-    }\n+    let arg: *libc::c_void = cast::transmute(p);\n+    assert_eq!(pthread_create(&mut native, &attr, thread_start, arg), 0);\n     native\n }\n \n #[cfg(unix)]\n-fn native_thread_join(native: rust_thread) {\n-    unsafe { assert!(pthread_join(native, ptr::null()) == 0) }\n+unsafe fn native_thread_join(native: rust_thread) {\n+    assert_eq!(pthread_join(native, ptr::null()), 0);\n }\n \n-impl Drop for Thread {\n-    fn drop(&mut self) {\n-        assert!(self.joined);\n-    }\n+#[cfg(unix)]\n+fn native_thread_detach(native: rust_thread) {\n+    unsafe { assert_eq!(pthread_detach(native), 0) }\n }\n \n #[cfg(windows)]\n extern \"system\" {\n-    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T,\n-                    lpStartAddress: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n-                    lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD) -> HANDLE;\n+    fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES,\n+                    dwStackSize: SIZE_T,\n+                    lpStartAddress: StartFn,\n+                    lpParameter: LPVOID,\n+                    dwCreationFlags: DWORD,\n+                    lpThreadId: LPDWORD) -> HANDLE;\n     fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n }\n \n #[cfg(unix)]\n extern {\n-    fn pthread_create(native: *mut libc::pthread_t, attr: *libc::pthread_attr_t,\n-                      f: extern \"C\" fn(*libc::c_void) -> rust_thread_return,\n+    fn pthread_create(native: *mut libc::pthread_t,\n+                      attr: *libc::pthread_attr_t,\n+                      f: StartFn,\n                       value: *libc::c_void) -> libc::c_int;\n-    fn pthread_join(native: libc::pthread_t, value: **libc::c_void) -> libc::c_int;\n+    fn pthread_join(native: libc::pthread_t,\n+                    value: **libc::c_void) -> libc::c_int;\n     fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n     fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,\n                                  stack_size: libc::size_t) -> libc::c_int;\n     fn pthread_attr_setdetachstate(attr: *mut libc::pthread_attr_t,\n                                    state: libc::c_int) -> libc::c_int;\n+    fn pthread_detach(thread: libc::pthread_t) -> libc::c_int;\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::Thread;\n+\n+    #[test]\n+    fn smoke() { do Thread::start {}.join(); }\n+\n+    #[test]\n+    fn data() { assert_eq!(do Thread::start { 1 }.join(), 1); }\n+\n+    #[test]\n+    fn detached() { do Thread::spawn {} }\n }"}, {"sha": "198fe596a896ee4fc18432bd99d7535ecf6c8233", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5d6dbf3f262fabcb6cb920dd08be6f9d8df75d5c", "patch": "@@ -139,7 +139,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n             let join_task = do Task::build_child(None) {\n                 debug!(\"running join task\");\n                 let thread_port = thread_port_cell.take();\n-                let thread: Thread = thread_port.recv();\n+                let thread: Thread<()> = thread_port.recv();\n                 thread.join();\n             };\n "}]}