{"sha": "71b8646854d00ce03320038f98aa6442f1ca2c1e", "node_id": "C_kwDOAAsO6NoAKDcxYjg2NDY4NTRkMDBjZTAzMzIwMDM4Zjk4YWE2NDQyZjFjYTJjMWU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-23T00:55:16Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-02-21T00:51:56Z"}, "message": "Use `ThinVec` in various AST types.\n\nThis commit changes the sequence parsers to produce `ThinVec`, which\ntriggers numerous conversions.", "tree": {"sha": "025d3da520e42603cc4943f9acfa90dce6ccadeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/025d3da520e42603cc4943f9acfa90dce6ccadeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71b8646854d00ce03320038f98aa6442f1ca2c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71b8646854d00ce03320038f98aa6442f1ca2c1e", "html_url": "https://github.com/rust-lang/rust/commit/71b8646854d00ce03320038f98aa6442f1ca2c1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71b8646854d00ce03320038f98aa6442f1ca2c1e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0373f5ad2d3065008bfc734aac6da3f9a9d48e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0373f5ad2d3065008bfc734aac6da3f9a9d48e9", "html_url": "https://github.com/rust-lang/rust/commit/c0373f5ad2d3065008bfc734aac6da3f9a9d48e9"}], "stats": {"total": 54, "additions": 36, "deletions": 18}, "files": [{"sha": "9011f0896a057579c53965f3f10a4981d2936f5b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71b8646854d00ce03320038f98aa6442f1ca2c1e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71b8646854d00ce03320038f98aa6442f1ca2c1e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=71b8646854d00ce03320038f98aa6442f1ca2c1e", "patch": "@@ -42,6 +42,7 @@ extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n extern crate rustc_trait_selection;\n+extern crate thin_vec;\n \n #[macro_use]\n extern crate clippy_utils;"}, {"sha": "06d248204c1f4c5d26a23d4462f0eb977054c374", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/71b8646854d00ce03320038f98aa6442f1ca2c1e/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71b8646854d00ce03320038f98aa6442f1ca2c1e/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=71b8646854d00ce03320038f98aa6442f1ca2c1e", "patch": "@@ -12,9 +12,9 @@ use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::DUMMY_SP;\n-\n use std::cell::Cell;\n use std::mem;\n+use thin_vec::{thin_vec, ThinVec};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -214,7 +214,7 @@ macro_rules! always_pat {\n /// Focus on `focus_idx` in `alternatives`,\n /// attempting to extend it with elements of the same constructor `C`\n /// in `alternatives[focus_idx + 1..]`.\n-fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize) -> bool {\n+fn transform_with_focus_on_idx(alternatives: &mut ThinVec<P<Pat>>, focus_idx: usize) -> bool {\n     // Extract the kind; we'll need to make some changes in it.\n     let mut focus_kind = mem::replace(&mut alternatives[focus_idx].kind, PatKind::Wild);\n     // We'll focus on `alternatives[focus_idx]`,\n@@ -296,7 +296,7 @@ fn extend_with_struct_pat(\n     fps1: &mut [ast::PatField],\n     rest1: bool,\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n ) -> bool {\n     (0..fps1.len()).any(|idx| {\n         let pos_in_2 = Cell::new(None); // The element `k`.\n@@ -336,9 +336,9 @@ fn extend_with_struct_pat(\n fn extend_with_matching_product(\n     targets: &mut [P<Pat>],\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind, &[P<Pat>], usize) -> bool,\n-    extract: impl Fn(PatKind) -> Vec<P<Pat>>,\n+    extract: impl Fn(PatKind) -> ThinVec<P<Pat>>,\n ) -> bool {\n     (0..targets.len()).any(|idx| {\n         let tail_or = drain_matching(\n@@ -365,14 +365,14 @@ fn take_pat(from: &mut Pat) -> Pat {\n \n /// Extend `target` as an or-pattern with the alternatives\n /// in `tail_or` if there are any and return if there were.\n-fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n-    fn extend(target: &mut Pat, mut tail_or: Vec<P<Pat>>) {\n+fn extend_with_tail_or(target: &mut Pat, tail_or: ThinVec<P<Pat>>) -> bool {\n+    fn extend(target: &mut Pat, mut tail_or: ThinVec<P<Pat>>) {\n         match target {\n             // On an existing or-pattern in the target, append to it.\n             Pat { kind: Or(ps), .. } => ps.append(&mut tail_or),\n             // Otherwise convert the target to an or-pattern.\n             target => {\n-                let mut init_or = vec![P(take_pat(target))];\n+                let mut init_or = thin_vec![P(take_pat(target))];\n                 init_or.append(&mut tail_or);\n                 target.kind = Or(init_or);\n             },\n@@ -391,26 +391,42 @@ fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n // Only elements beginning with `start` are considered for extraction.\n fn drain_matching(\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind) -> bool,\n     extract: impl Fn(PatKind) -> P<Pat>,\n-) -> Vec<P<Pat>> {\n-    let mut tail_or = vec![];\n+) -> ThinVec<P<Pat>> {\n+    let mut tail_or = ThinVec::new();\n     let mut idx = 0;\n-    for pat in alternatives.drain_filter(|p| {\n-        // Check if we should extract, but only if `idx >= start`.\n+\n+    // If `ThinVec` had the `drain_filter` method, this loop could be rewritten\n+    // like so:\n+    // \n+    //   for pat in alternatives.drain_filter(|p| {\n+    //       // Check if we should extract, but only if `idx >= start`.\n+    //       idx += 1;\n+    //       idx > start && predicate(&p.kind)\n+    //   }) {\n+    //       tail_or.push(extract(pat.into_inner().kind));\n+    //   }\n+    let mut i = 0;\n+    while i < alternatives.len() {\n         idx += 1;\n-        idx > start && predicate(&p.kind)\n-    }) {\n-        tail_or.push(extract(pat.into_inner().kind));\n+        // Check if we should extract, but only if `idx >= start`.\n+\tif idx > start && predicate(&alternatives[i].kind) {\n+\t    let pat = alternatives.remove(i);\n+            tail_or.push(extract(pat.into_inner().kind));\n+\t} else {\n+\t    i += 1;\n+\t}\n     }\n+\n     tail_or\n }\n \n fn extend_with_matching(\n     target: &mut Pat,\n     start: usize,\n-    alternatives: &mut Vec<P<Pat>>,\n+    alternatives: &mut ThinVec<P<Pat>>,\n     predicate: impl Fn(&PatKind) -> bool,\n     extract: impl Fn(PatKind) -> P<Pat>,\n ) -> bool {"}, {"sha": "d82098523e3bea2a967577714dc9f2929f89e892", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71b8646854d00ce03320038f98aa6442f1ca2c1e/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71b8646854d00ce03320038f98aa6442f1ca2c1e/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=71b8646854d00ce03320038f98aa6442f1ca2c1e", "patch": "@@ -144,7 +144,8 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (_, Paren(r)) => eq_expr(l, r),\n         (Err, Err) => true,\n         (Box(l), Box(r)) | (Try(l), Try(r)) | (Await(l), Await(r)) => eq_expr(l, r),\n-        (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Array(l), Array(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n         ("}]}