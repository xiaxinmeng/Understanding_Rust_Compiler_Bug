{"sha": "a882554a785152c74c96cee036d252b071ed5ce1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ODI1NTRhNzg1MTUyYzc0Yzk2Y2VlMDM2ZDI1MmIwNzFlZDVjZTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-16T01:07:36Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-18T23:59:37Z"}, "message": "core: Refactor uv bindings\n\nI can already see these are going to get massive. Putting them into multiple\nfiles.", "tree": {"sha": "b89a33559ec592e49deca89c9ce5d7850a395d5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b89a33559ec592e49deca89c9ce5d7850a395d5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a882554a785152c74c96cee036d252b071ed5ce1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a882554a785152c74c96cee036d252b071ed5ce1", "html_url": "https://github.com/rust-lang/rust/commit/a882554a785152c74c96cee036d252b071ed5ce1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a882554a785152c74c96cee036d252b071ed5ce1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ef54c7ecd625376de092cbd741621987673c45f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ef54c7ecd625376de092cbd741621987673c45f", "html_url": "https://github.com/rust-lang/rust/commit/7ef54c7ecd625376de092cbd741621987673c45f"}], "stats": {"total": 1018, "additions": 535, "deletions": 483}, "files": [{"sha": "621cdca89e8f428947cdba715984bda0b014e732", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=a882554a785152c74c96cee036d252b071ed5ce1", "patch": "@@ -16,21 +16,21 @@ use super::Stream;\n pub struct FileStream;\n \n pub impl FileStream {\n-    static fn new(path: Path) -> FileStream {\n+    static fn new(_path: Path) -> FileStream {\n         fail!()\n     }\n }\n \n impl Stream for FileStream {\n-    fn read(&mut self, buf: &mut [u8]) -> uint {\n+    fn read(&mut self, _buf: &mut [u8]) -> uint {\n         fail!()\n     }\n \n     fn eof(&mut self) -> bool {\n         fail!()\n     }\n \n-    fn write(&mut self, v: &const [u8]) {\n+    fn write(&mut self, _v: &const [u8]) {\n         fail!()\n     }\n }"}, {"sha": "1e919af4d14d1583bc92d08db6fa9b8d08e897c5", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=a882554a785152c74c96cee036d252b071ed5ce1", "patch": "@@ -33,6 +33,7 @@ mod sched;\n mod rtio;\n pub mod uvll;\n mod uvio;\n+#[path = \"uv/mod.rs\"]\n mod uv;\n #[path = \"io/mod.rs\"]\n mod io;"}, {"sha": "5eb951be7848c1df63ca1422f13f216b9b597582", "filename": "src/libcore/rt/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread.rs?ref=a882554a785152c74c96cee036d252b071ed5ce1", "patch": "@@ -14,12 +14,12 @@ use ops::Drop;\n #[allow(non_camel_case_types)] // runtime type\n type raw_thread = libc::c_void;\n \n-struct Thread {\n+pub struct Thread {\n     main: ~fn(),\n     raw_thread: *raw_thread\n }\n \n-impl Thread {\n+pub impl Thread {\n     static fn start(main: ~fn()) -> Thread {\n         fn substart(main: &fn()) -> *raw_thread {\n             unsafe { rust_raw_thread_start(&main) }"}, {"sha": "3a7b7f135d5862c56cc58a409798f61ad9808e9b", "filename": "src/libcore/rt/uv/file.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ffile.rs?ref=a882554a785152c74c96cee036d252b071ed5ce1", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use ptr::null;\n+use libc::c_void;\n+use super::{UvError, Callback, Request, NativeHandle, Loop};\n+use super::super::uvll;\n+use super::super::uvll::*;\n+\n+pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+impl Callback for FsCallback { }\n+\n+pub struct FsRequest(*uvll::uv_fs_t);\n+\n+impl Request for FsRequest;\n+\n+impl FsRequest {\n+    static fn new() -> FsRequest {\n+        let fs_req = unsafe { malloc_req(UV_FS) };\n+        fail_unless!(fs_req.is_not_null());\n+        let fs_req = fs_req as *uvll::uv_write_t;\n+        unsafe { uvll::set_data_for_req(fs_req, null::<()>()); }\n+        NativeHandle::from_native_handle(fs_req)\n+    }\n+\n+    fn delete(self) {\n+        unsafe { free_req(self.native_handle() as *c_void) }\n+    }\n+\n+    fn open(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    }\n+\n+    fn close(&mut self, _loop_: &Loop, _cb: FsCallback) {\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n+    static fn from_native_handle(handle: *uvll:: uv_fs_t) -> FsRequest {\n+        FsRequest(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_fs_t {\n+        match self { &FsRequest(ptr) => ptr }\n+    }\n+}"}, {"sha": "c44998532ebaaf60b04884bc63aa71d3716aacd8", "filename": "src/libcore/rt/uv/mod.rs", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=a882554a785152c74c96cee036d252b071ed5ce1", "patch": "@@ -0,0 +1,456 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Bindings to libuv.\n+\n+UV types consist of the event loop (Loop), Watchers, Requests and\n+Callbacks.\n+\n+Watchers and Requests encapsulate pointers to uv *handles*, which have\n+subtyping relationships with each other.  This subtyping is reflected\n+in the bindings with explicit or implicit coercions. For example, an\n+upcast from TcpWatcher to StreamWatcher is done with\n+`tcp_watcher.as_stream()`. In other cases a callback on a specific\n+type of watcher will be passed a watcher of a supertype.\n+\n+Currently all use of Request types (connect/write requests) are\n+encapsulated in the bindings and don't need to be dealt with by the\n+caller.\n+\n+# Safety note\n+\n+Due to the complex lifecycle of uv handles, as well as compiler bugs,\n+this module is not memory safe and requires explicit memory management,\n+via `close` and `delete` methods.\n+\n+*/\n+\n+use option::*;\n+use str::raw::from_c_str;\n+use to_str::ToStr;\n+use vec;\n+use ptr;\n+use libc::{c_void, c_int, size_t, malloc, free, ssize_t};\n+use cast::{transmute, transmute_mut_region};\n+use ptr::null;\n+use sys::size_of;\n+use super::uvll;\n+use super::uvll::*;\n+use unstable::finally::Finally;\n+\n+#[cfg(test)] use unstable::run_in_bare_thread;\n+#[cfg(test)] use super::thread::Thread;\n+#[cfg(test)] use cell::Cell;\n+\n+pub use self::file::{FsRequest, FsCallback};\n+pub use self::net::{StreamWatcher, TcpWatcher};\n+pub use self::net::{ReadCallback, AllocCallback, ConnectionCallback, ConnectCallback};\n+\n+pub mod file;\n+pub mod net;\n+\n+/// A trait for callbacks to implement. Provides a little extra type safety\n+/// for generic, unsafe interop functions like `set_watcher_callback`.\n+pub trait Callback { }\n+\n+pub trait Request { }\n+\n+/// The trait implemented by uv 'watchers' (handles). Watchers are\n+/// non-owning wrappers around the uv handles and are not completely\n+/// safe - there may be multiple instances for a single underlying\n+/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n+/// and `close`ed, but due to their complex life cycle may not be\n+/// entirely memory safe if used in unanticipated patterns.\n+pub trait Watcher {\n+    fn event_loop(&self) -> Loop;\n+}\n+\n+pub type NullCallback = ~fn();\n+impl Callback for NullCallback { }\n+\n+/// A type that wraps a native handle\n+pub trait NativeHandle<T> {\n+    static pub fn from_native_handle(T) -> Self;\n+    pub fn native_handle(&self) -> T;\n+}\n+\n+/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n+/// with dtors may not be destructured, but tuple structs can,\n+/// but the results are not correct.\n+pub struct Loop {\n+    handle: *uvll::uv_loop_t\n+}\n+\n+pub impl Loop {\n+    static fn new() -> Loop {\n+        let handle = unsafe { uvll::loop_new() };\n+        fail_unless!(handle.is_not_null());\n+        NativeHandle::from_native_handle(handle)\n+    }\n+\n+    fn run(&mut self) {\n+        unsafe { uvll::run(self.native_handle()) };\n+    }\n+\n+    fn close(&mut self) {\n+        unsafe { uvll::loop_delete(self.native_handle()) };\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_loop_t> for Loop {\n+    static fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n+        Loop { handle: handle }\n+    }\n+    fn native_handle(&self) -> *uvll::uv_loop_t {\n+        self.handle\n+    }\n+}\n+\n+pub struct IdleWatcher(*uvll::uv_idle_t);\n+\n+impl Watcher for IdleWatcher {\n+    fn event_loop(&self) -> Loop {\n+        loop_from_watcher(self)\n+    }\n+}\n+\n+pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n+impl Callback for IdleCallback { }\n+\n+pub impl IdleWatcher {\n+    static fn new(loop_: &mut Loop) -> IdleWatcher {\n+        unsafe {\n+            let handle = uvll::idle_new();\n+            fail_unless!(handle.is_not_null());\n+            fail_unless!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            uvll::set_data_for_uv_handle(handle, null::<()>());\n+            NativeHandle::from_native_handle(handle)\n+        }\n+    }\n+\n+    fn start(&mut self, cb: IdleCallback) {\n+\n+        set_watcher_callback(self, cb);\n+        unsafe {\n+            fail_unless!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n+        };\n+\n+        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+            let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+            let cb: &IdleCallback = borrow_callback_from_watcher(&idle_watcher);\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(idle_watcher, status);\n+        }\n+    }\n+\n+    fn stop(&mut self) {\n+        unsafe { fail_unless!(0 == uvll::idle_stop(self.native_handle())); }\n+    }\n+\n+    fn close(self) {\n+        unsafe { uvll::close(self.native_handle(), close_cb) };\n+\n+        extern fn close_cb(handle: *uvll::uv_idle_t) {\n+            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n+            drop_watcher_callback::<uvll::uv_idle_t, IdleWatcher, IdleCallback>(&mut idle_watcher);\n+            unsafe { uvll::idle_delete(handle) };\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n+    static fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n+        IdleWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &IdleWatcher(ptr) => ptr }\n+    }\n+}\n+\n+// XXX: Need to define the error constants like EOF so they can be\n+// compared to the UvError type\n+\n+pub struct UvError(uvll::uv_err_t);\n+\n+pub impl UvError {\n+\n+    pure fn name(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let name_str = uvll::err_name(inner);\n+            fail_unless!(name_str.is_not_null());\n+            from_c_str(name_str)\n+        }\n+    }\n+\n+    pure fn desc(&self) -> ~str {\n+        unsafe {\n+            let inner = match self { &UvError(ref a) => a };\n+            let desc_str = uvll::strerror(inner);\n+            fail_unless!(desc_str.is_not_null());\n+            from_c_str(desc_str)\n+        }\n+    }\n+}\n+\n+impl ToStr for UvError {\n+    pure fn to_str(&self) -> ~str {\n+        fmt!(\"%s: %s\", self.name(), self.desc())\n+    }\n+}\n+\n+#[test]\n+fn error_smoke_test() {\n+    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n+    let err: UvError = UvError(err);\n+    fail_unless!(err.to_str() == ~\"EOF: end of file\");\n+}\n+\n+\n+/// Given a uv handle, convert a callback status to a UvError\n+// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n+pub fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n+    if status != -1 {\n+        None\n+    } else {\n+        unsafe {\n+            rtdebug!(\"handle: %x\", handle as uint);\n+            let loop_ = uvll::get_loop_for_uv_handle(handle);\n+            rtdebug!(\"loop: %x\", loop_ as uint);\n+            let err = uvll::last_error(loop_);\n+            Some(UvError(err))\n+        }\n+    }\n+}\n+\n+/// Get the uv event loop from a Watcher\n+pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n+    watcher: &W) -> Loop {\n+\n+    let handle = watcher.native_handle();\n+    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n+    NativeHandle::from_native_handle(loop_)\n+}\n+\n+/// Set the custom data on a handle to a callback Note: This is only\n+/// suitable for watchers that make just one type of callback.  For\n+/// others use WatcherData\n+pub fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W, cb: CB) {\n+\n+    drop_watcher_callback::<H, W, CB>(watcher);\n+    // XXX: Boxing the callback so it fits into a\n+    // pointer. Unfortunate extra allocation\n+    let boxed_cb = ~cb;\n+    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n+    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n+}\n+\n+/// Delete a callback from a handle's custom data\n+pub fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W) {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        if handle_data.is_not_null() {\n+            // Take ownership of the callback and drop it\n+            let _cb = transmute::<*c_void, ~CB>(handle_data);\n+            // Make sure the pointer is zeroed\n+            uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+        }\n+    }\n+}\n+\n+/// Take a pointer to the callback installed as custom data\n+pub fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n+                                CB: Callback>(watcher: &W) -> &CB {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        fail_unless!(handle_data.is_not_null());\n+        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n+        return &**cb;\n+    }\n+}\n+\n+/// Take ownership of the callback installed as custom data\n+pub fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n+    watcher: &mut W) -> CB {\n+\n+    unsafe {\n+        let handle = watcher.native_handle();\n+        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n+        fail_unless!(handle_data.is_not_null());\n+        uvll::set_data_for_uv_handle(handle, null::<()>());\n+        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n+        let cb = match cb { ~cb => cb };\n+        return cb;\n+    }\n+}\n+\n+/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n+struct WatcherData {\n+    read_cb: Option<ReadCallback>,\n+    write_cb: Option<ConnectionCallback>,\n+    connect_cb: Option<ConnectionCallback>,\n+    close_cb: Option<NullCallback>,\n+    alloc_cb: Option<AllocCallback>\n+}\n+\n+pub fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n+    unsafe {\n+        let data = ~WatcherData {\n+            read_cb: None,\n+            write_cb: None,\n+            connect_cb: None,\n+            close_cb: None,\n+            alloc_cb: None\n+        };\n+        let data = transmute::<~WatcherData, *c_void>(data);\n+        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n+    }\n+}\n+\n+pub fn get_watcher_data<H, W: Watcher + NativeHandle<*H>>(\n+    watcher: &r/mut W) -> &r/mut WatcherData {\n+\n+    unsafe {\n+        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n+        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n+        return &mut **data;\n+    }\n+}\n+\n+pub fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n+    unsafe {\n+        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n+        let _data = transmute::<*c_void, ~WatcherData>(data);\n+        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n+    }\n+}\n+\n+#[test]\n+fn test_slice_to_uv_buf() {\n+    let slice = [0, .. 20];\n+    let buf = slice_to_uv_buf(slice);\n+\n+    fail_unless!(buf.len == 20);\n+\n+    unsafe {\n+        let base = transmute::<*u8, *mut u8>(buf.base);\n+        (*base) = 1;\n+        (*ptr::mut_offset(base, 1)) = 2;\n+    }\n+\n+    fail_unless!(slice[0] == 1);\n+    fail_unless!(slice[1] == 2);\n+}\n+\n+/// The uv buffer type\n+pub type Buf = uvll::uv_buf_t;\n+\n+/// Borrow a slice to a Buf\n+pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n+    let data = unsafe { vec::raw::to_ptr(v) };\n+    unsafe { uvll::buf_init(data, v.len()) }\n+}\n+\n+// XXX: Do these conversions without copying\n+\n+/// Transmute an owned vector to a Buf\n+pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n+    let data = unsafe { malloc(v.len() as size_t) } as *u8;\n+    fail_unless!(data.is_not_null());\n+    do vec::as_imm_buf(v) |b, l| {\n+        let data = data as *mut u8;\n+        unsafe { ptr::copy_memory(data, b, l) }\n+    }\n+    let buf = unsafe { uvll::buf_init(data, v.len()) };\n+    return buf;\n+}\n+\n+/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n+pub fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n+    if !(buf.len == 0 && buf.base.is_null()) {\n+        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n+        unsafe { free(buf.base as *c_void) };\n+        return Some(v);\n+    } else {\n+        // No buffer\n+        return None;\n+    }\n+}\n+\n+#[test]\n+fn loop_smoke_test() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        loop_.run();\n+        loop_.close();\n+    }\n+}\n+\n+#[test]\n+#[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n+fn idle_new_then_close() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        idle_watcher.close();\n+    }\n+}\n+\n+#[test]\n+fn idle_smoke_test() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        let mut count = 10;\n+        let count_ptr: *mut int = &mut count;\n+        do idle_watcher.start |idle_watcher, status| {\n+            let mut idle_watcher = idle_watcher;\n+            fail_unless!(status.is_none());\n+            if unsafe { *count_ptr == 10 } {\n+                idle_watcher.stop();\n+                idle_watcher.close();\n+            } else {\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+        fail_unless!(count == 10);\n+    }\n+}\n+\n+#[test]\n+fn idle_start_stop_start() {\n+    do run_in_bare_thread {\n+        let mut loop_ = Loop::new();\n+        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n+        do idle_watcher.start |idle_watcher, status| {\n+            let mut idle_watcher = idle_watcher;\n+            fail_unless!(status.is_none());\n+            idle_watcher.stop();\n+            do idle_watcher.start |idle_watcher, status| {\n+                fail_unless!(status.is_none());\n+                let mut idle_watcher = idle_watcher;\n+                idle_watcher.stop();\n+                idle_watcher.close();\n+            }\n+        }\n+        loop_.run();\n+        loop_.close();\n+    }\n+}"}, {"sha": "bcbb1b2d02e4212bf24e43b97fd7eab5e59ceb72", "filename": "src/libcore/rt/uv/net.rs", "status": "renamed", "additions": 20, "deletions": 478, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=a882554a785152c74c96cee036d252b071ed5ce1", "patch": "@@ -8,49 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Bindings to libuv.\n-\n-UV types consist of the event loop (Loop), Watchers, Requests and\n-Callbacks.\n-\n-Watchers and Requests encapsulate pointers to uv *handles*, which have\n-subtyping relationships with each other.  This subtyping is reflected\n-in the bindings with explicit or implicit coercions. For example, an\n-upcast from TcpWatcher to StreamWatcher is done with\n-`tcp_watcher.as_stream()`. In other cases a callback on a specific\n-type of watcher will be passed a watcher of a supertype.\n-\n-Currently all use of Request types (connect/write requests) are\n-encapsulated in the bindings and don't need to be dealt with by the\n-caller.\n-\n-# Safety note\n-\n-Due to the complex lifecycle of uv handles, as well as compiler bugs,\n-this module is not memory safe and requires explicit memory management,\n-via `close` and `delete` methods.\n-\n-*/\n-\n-use option::*;\n-use str::raw::from_c_str;\n-use to_str::ToStr;\n-use vec;\n-use ptr;\n-use libc::{c_void, c_int, size_t, malloc, free, ssize_t};\n+use prelude::*;\n+use libc::{size_t, ssize_t, c_int, c_void};\n use cast::{transmute, transmute_mut_region};\n-use ptr::null;\n-use sys::size_of;\n-use super::uvll;\n-use super::uvll::*;\n-use super::rtio::{IpAddr, Ipv4, Ipv6};\n-use unstable::finally::Finally;\n-\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::thread::Thread;\n-#[cfg(test)] use cell::Cell;\n+use super::super::uvll;\n+use super::super::uvll::*;\n+use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCallback,\n+            loop_from_watcher, status_to_maybe_uv_error,\n+            install_watcher_data, get_watcher_data, drop_watcher_data,\n+            vec_to_uv_buf, vec_from_uv_buf};\n+use super::super::rtio::{IpAddr, Ipv4, Ipv6};\n+\n+#[cfg(test)]\n+use unstable::run_in_bare_thread;\n+#[cfg(test)]\n+use super::super::thread::Thread;\n+#[cfg(test)]\n+use cell::Cell;\n \n fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n     match addr {\n@@ -72,122 +46,6 @@ fn ip4_as_uv_ip4(addr: IpAddr, f: &fn(*sockaddr_in)) {\n     }\n }\n \n-/// A trait for callbacks to implement. Provides a little extra type safety\n-/// for generic, unsafe interop functions like `set_watcher_callback`.\n-trait Callback { }\n-\n-type NullCallback = ~fn();\n-impl Callback for NullCallback { }\n-\n-/// A type that wraps a native handle\n-trait NativeHandle<T> {\n-    static pub fn from_native_handle(T) -> Self;\n-    pub fn native_handle(&self) -> T;\n-}\n-\n-/// XXX: Loop(*handle) is buggy with destructors. Normal structs\n-/// with dtors may not be destructured, but tuple structs can,\n-/// but the results are not correct.\n-pub struct Loop {\n-    handle: *uvll::uv_loop_t\n-}\n-\n-pub impl Loop {\n-    static fn new() -> Loop {\n-        let handle = unsafe { uvll::loop_new() };\n-        fail_unless!(handle.is_not_null());\n-        NativeHandle::from_native_handle(handle)\n-    }\n-\n-    fn run(&mut self) {\n-        unsafe { uvll::run(self.native_handle()) };\n-    }\n-\n-    fn close(&mut self) {\n-        unsafe { uvll::loop_delete(self.native_handle()) };\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_loop_t> for Loop {\n-    static fn from_native_handle(handle: *uvll::uv_loop_t) -> Loop {\n-        Loop { handle: handle }\n-    }\n-    fn native_handle(&self) -> *uvll::uv_loop_t {\n-        self.handle\n-    }\n-}\n-\n-/// The trait implemented by uv 'watchers' (handles). Watchers are\n-/// non-owning wrappers around the uv handles and are not completely\n-/// safe - there may be multiple instances for a single underlying\n-/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n-/// and `close`ed, but due to their complex life cycle may not be\n-/// entirely memory safe if used in unanticipated patterns.\n-trait Watcher {\n-    fn event_loop(&self) -> Loop;\n-}\n-\n-pub struct IdleWatcher(*uvll::uv_idle_t);\n-\n-impl Watcher for IdleWatcher {\n-    fn event_loop(&self) -> Loop {\n-        loop_from_watcher(self)\n-    }\n-}\n-\n-type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n-impl Callback for IdleCallback { }\n-\n-pub impl IdleWatcher {\n-    static fn new(loop_: &mut Loop) -> IdleWatcher {\n-        unsafe {\n-            let handle = uvll::idle_new();\n-            fail_unless!(handle.is_not_null());\n-            fail_unless!(0 == uvll::idle_init(loop_.native_handle(), handle));\n-            uvll::set_data_for_uv_handle(handle, null::<()>());\n-            NativeHandle::from_native_handle(handle)\n-        }\n-    }\n-\n-    fn start(&mut self, cb: IdleCallback) {\n-\n-        set_watcher_callback(self, cb);\n-        unsafe {\n-            fail_unless!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let cb: &IdleCallback = borrow_callback_from_watcher(&idle_watcher);\n-            let status = status_to_maybe_uv_error(handle, status);\n-            (*cb)(idle_watcher, status);\n-        }\n-    }\n-\n-    fn stop(&mut self) {\n-        unsafe { fail_unless!(0 == uvll::idle_stop(self.native_handle())); }\n-    }\n-\n-    fn close(self) {\n-        unsafe { uvll::close(self.native_handle(), close_cb) };\n-\n-        extern fn close_cb(handle: *uvll::uv_idle_t) {\n-            let mut idle_watcher = NativeHandle::from_native_handle(handle);\n-            drop_watcher_callback::<uvll::uv_idle_t, IdleWatcher, IdleCallback>(&mut idle_watcher);\n-            unsafe { uvll::idle_delete(handle) };\n-        }\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n-    static fn from_native_handle(handle: *uvll::uv_idle_t) -> IdleWatcher {\n-        IdleWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_idle_t {\n-        match self { &IdleWatcher(ptr) => ptr }\n-    }\n-}\n-\n // uv_stream t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n // and uv_file_t\n pub struct StreamWatcher(*uvll::uv_stream_t);\n@@ -198,7 +56,7 @@ impl Watcher for StreamWatcher {\n     }\n }\n \n-type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n+pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n impl Callback for ReadCallback { }\n \n // XXX: The uv alloc callback also has a *uv_handle_t arg\n@@ -319,7 +177,7 @@ impl Watcher for TcpWatcher {\n     }\n }\n \n-type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n+pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n impl Callback for ConnectionCallback { }\n \n pub impl TcpWatcher {\n@@ -419,9 +277,7 @@ impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n     }\n }\n \n-trait Request { }\n-\n-type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n+pub type ConnectCallback = ~fn(ConnectRequest, Option<UvError>);\n impl Callback for ConnectCallback { }\n \n // uv_connect_t is a subclass of uv_req_t\n@@ -466,7 +322,7 @@ pub struct WriteRequest(*uvll::uv_write_t);\n \n impl Request for WriteRequest { }\n \n-impl WriteRequest {\n+pub impl WriteRequest {\n \n     static fn new() -> WriteRequest {\n         let write_handle = unsafe {\n@@ -498,320 +354,6 @@ impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n     }\n }\n \n-type FsCallback = ~fn(FsRequest, Option<UvError>);\n-impl Callback for FsCallback { }\n-\n-pub struct FsRequest(*uvll::uv_fs_t);\n-\n-impl Request for FsRequest;\n-\n-impl FsRequest {\n-    static fn new() -> FsRequest {\n-        let fs_req = unsafe { malloc_req(UV_FS) };\n-        fail_unless!(fs_req.is_not_null());\n-        let fs_req = fs_req as *uvll::uv_write_t;\n-        uvll::set_data_for_uv_req(fs_req, null::<()>());\n-        Native(fs_req)\n-    }\n-\n-    fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n-    }\n-\n-    fn open(&mut self, loop_: &EventLoop, cb: FsCallback) {\n-    }\n-\n-    fn close(&mut self, loop_: &EventLoop, cb: FsCallback) {\n-    }\n-}\n-\n-impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n-    static fn from_native_handle(handle: *uvll:: uv_fs_t) -> FsRequest {\n-        FsRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_fs_t {\n-        match self { &FsRequest(ptr) => ptr }\n-    }\n-}\n-\n-// XXX: Need to define the error constants like EOF so they can be\n-// compared to the UvError type\n-\n-struct UvError(uvll::uv_err_t);\n-\n-impl UvError {\n-\n-    pure fn name(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n-            let name_str = uvll::err_name(inner);\n-            fail_unless!(name_str.is_not_null());\n-            from_c_str(name_str)\n-        }\n-    }\n-\n-    pure fn desc(&self) -> ~str {\n-        unsafe {\n-            let inner = match self { &UvError(ref a) => a };\n-            let desc_str = uvll::strerror(inner);\n-            fail_unless!(desc_str.is_not_null());\n-            from_c_str(desc_str)\n-        }\n-    }\n-}\n-\n-impl ToStr for UvError {\n-    pure fn to_str(&self) -> ~str {\n-        fmt!(\"%s: %s\", self.name(), self.desc())\n-    }\n-}\n-\n-#[test]\n-fn error_smoke_test() {\n-    let err = uvll::uv_err_t { code: 1, sys_errno_: 1 };\n-    let err: UvError = UvError(err);\n-    fail_unless!(err.to_str() == ~\"EOF: end of file\");\n-}\n-\n-\n-/// Given a uv handle, convert a callback status to a UvError\n-// XXX: Follow the pattern below by parameterizing over T: Watcher, not T\n-fn status_to_maybe_uv_error<T>(handle: *T, status: c_int) -> Option<UvError> {\n-    if status != -1 {\n-        None\n-    } else {\n-        unsafe {\n-            rtdebug!(\"handle: %x\", handle as uint);\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            rtdebug!(\"loop: %x\", loop_ as uint);\n-            let err = uvll::last_error(loop_);\n-            Some(UvError(err))\n-        }\n-    }\n-}\n-\n-/// Get the uv event loop from a Watcher\n-pub fn loop_from_watcher<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &W) -> Loop {\n-\n-    let handle = watcher.native_handle();\n-    let loop_ = unsafe { uvll::get_loop_for_uv_handle(handle) };\n-    NativeHandle::from_native_handle(loop_)\n-}\n-\n-/// Set the custom data on a handle to a callback Note: This is only\n-/// suitable for watchers that make just one type of callback.  For\n-/// others use WatcherData\n-fn set_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W, cb: CB) {\n-\n-    drop_watcher_callback::<H, W, CB>(watcher);\n-    // XXX: Boxing the callback so it fits into a\n-    // pointer. Unfortunate extra allocation\n-    let boxed_cb = ~cb;\n-    let data = unsafe { transmute::<~CB, *c_void>(boxed_cb) };\n-    unsafe { uvll::set_data_for_uv_handle(watcher.native_handle(), data) };\n-}\n-\n-/// Delete a callback from a handle's custom data\n-fn drop_watcher_callback<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        if handle_data.is_not_null() {\n-            // Take ownership of the callback and drop it\n-            let _cb = transmute::<*c_void, ~CB>(handle_data);\n-            // Make sure the pointer is zeroed\n-            uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n-        }\n-    }\n-}\n-\n-/// Take a pointer to the callback installed as custom data\n-fn borrow_callback_from_watcher<H, W: Watcher + NativeHandle<*H>,\n-                                CB: Callback>(watcher: &W) -> &CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        fail_unless!(handle_data.is_not_null());\n-        let cb = transmute::<&*c_void, &~CB>(&handle_data);\n-        return &**cb;\n-    }\n-}\n-\n-/// Take ownership of the callback installed as custom data\n-fn take_callback_from_watcher<H, W: Watcher + NativeHandle<*H>, CB: Callback>(\n-    watcher: &mut W) -> CB {\n-\n-    unsafe {\n-        let handle = watcher.native_handle();\n-        let handle_data: *c_void = uvll::get_data_for_uv_handle(handle);\n-        fail_unless!(handle_data.is_not_null());\n-        uvll::set_data_for_uv_handle(handle, null::<()>());\n-        let cb: ~CB = transmute::<*c_void, ~CB>(handle_data);\n-        let cb = match cb { ~cb => cb };\n-        return cb;\n-    }\n-}\n-\n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>\n-}\n-\n-fn install_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = ~WatcherData {\n-            read_cb: None,\n-            write_cb: None,\n-            connect_cb: None,\n-            close_cb: None,\n-            alloc_cb: None\n-        };\n-        let data = transmute::<~WatcherData, *c_void>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), data);\n-    }\n-}\n-\n-fn get_watcher_data<H, W: Watcher + NativeHandle<*H>>(\n-    watcher: &r/mut W) -> &r/mut WatcherData {\n-\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-        return &mut **data;\n-    }\n-}\n-\n-fn drop_watcher_data<H, W: Watcher + NativeHandle<*H>>(watcher: &mut W) {\n-    unsafe {\n-        let data = uvll::get_data_for_uv_handle(watcher.native_handle());\n-        let _data = transmute::<*c_void, ~WatcherData>(data);\n-        uvll::set_data_for_uv_handle(watcher.native_handle(), null::<()>());\n-    }\n-}\n-\n-#[test]\n-fn test_slice_to_uv_buf() {\n-    let slice = [0, .. 20];\n-    let buf = slice_to_uv_buf(slice);\n-\n-    fail_unless!(buf.len == 20);\n-\n-    unsafe {\n-        let base = transmute::<*u8, *mut u8>(buf.base);\n-        (*base) = 1;\n-        (*ptr::mut_offset(base, 1)) = 2;\n-    }\n-\n-    fail_unless!(slice[0] == 1);\n-    fail_unless!(slice[1] == 2);\n-}\n-\n-/// The uv buffer type\n-pub type Buf = uvll::uv_buf_t;\n-\n-/// Borrow a slice to a Buf\n-pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n-    let data = unsafe { vec::raw::to_ptr(v) };\n-    unsafe { uvll::buf_init(data, v.len()) }\n-}\n-\n-// XXX: Do these conversions without copying\n-\n-/// Transmute an owned vector to a Buf\n-fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n-    let data = unsafe { malloc(v.len() as size_t) } as *u8;\n-    fail_unless!(data.is_not_null());\n-    do vec::as_imm_buf(v) |b, l| {\n-        let data = data as *mut u8;\n-        unsafe { ptr::copy_memory(data, b, l) }\n-    }\n-    let buf = unsafe { uvll::buf_init(data, v.len()) };\n-    return buf;\n-}\n-\n-/// Transmute a Buf that was once a ~[u8] back to ~[u8]\n-fn vec_from_uv_buf(buf: Buf) -> Option<~[u8]> {\n-    if !(buf.len == 0 && buf.base.is_null()) {\n-        let v = unsafe { vec::from_buf(buf.base, buf.len as uint) };\n-        unsafe { free(buf.base as *c_void) };\n-        return Some(v);\n-    } else {\n-        // No buffer\n-        return None;\n-    }\n-}\n-\n-#[test]\n-fn loop_smoke_test() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n-\n-#[test]\n-#[ignore(reason = \"valgrind - loop destroyed before watcher?\")]\n-fn idle_new_then_close() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        idle_watcher.close();\n-    }\n-}\n-\n-#[test]\n-fn idle_smoke_test() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        let mut count = 10;\n-        let count_ptr: *mut int = &mut count;\n-        do idle_watcher.start |idle_watcher, status| {\n-            let mut idle_watcher = idle_watcher;\n-            fail_unless!(status.is_none());\n-            if unsafe { *count_ptr == 10 } {\n-                idle_watcher.stop();\n-                idle_watcher.close();\n-            } else {\n-                unsafe { *count_ptr = *count_ptr + 1; }\n-            }\n-        }\n-        loop_.run();\n-        loop_.close();\n-        fail_unless!(count == 10);\n-    }\n-}\n-\n-#[test]\n-fn idle_start_stop_start() {\n-    do run_in_bare_thread {\n-        let mut loop_ = Loop::new();\n-        let mut idle_watcher = { IdleWatcher::new(&mut loop_) };\n-        do idle_watcher.start |idle_watcher, status| {\n-            let mut idle_watcher = idle_watcher;\n-            fail_unless!(status.is_none());\n-            idle_watcher.stop();\n-            do idle_watcher.start |idle_watcher, status| {\n-                fail_unless!(status.is_none());\n-                let mut idle_watcher = idle_watcher;\n-                idle_watcher.stop();\n-                idle_watcher.close();\n-            }\n-        }\n-        loop_.run();\n-        loop_.close();\n-    }\n-}\n \n #[test]\n #[ignore(reason = \"ffi struct issues\")]", "previous_filename": "src/libcore/rt/uv.rs"}, {"sha": "a91e37d92e4cdc3217a8005603eda59140c2e6b9", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a882554a785152c74c96cee036d252b071ed5ce1/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=a882554a785152c74c96cee036d252b071ed5ce1", "patch": "@@ -53,6 +53,7 @@ pub type uv_write_t = c_void;\n pub type uv_async_t = c_void;\n pub type uv_timer_t = c_void;\n pub type uv_stream_t = c_void;\n+pub type uv_fs_t = c_void;\n \n pub type uv_idle_cb = *u8;\n "}]}