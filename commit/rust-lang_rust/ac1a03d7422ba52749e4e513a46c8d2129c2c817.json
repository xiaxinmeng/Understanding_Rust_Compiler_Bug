{"sha": "ac1a03d7422ba52749e4e513a46c8d2129c2c817", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMWEwM2Q3NDIyYmE1Mjc0OWU0ZTUxM2E0NmM4ZDIxMjljMmM4MTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:03:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-30T20:03:20Z"}, "message": "rollup merge of #21718: alexcrichton/stabilize-from-str\n\nThis commits adds an associated type to the `FromStr` trait representing an\nerror payload for parses which do not succeed. The previous return value,\n`Option<Self>` did not allow for this form of payload. After the associated type\nwas added, the following attributes were applied:\n\n* `FromStr` is now stable\n* `FromStr::Err` is now stable\n* `FromStr::from_str` is now stable\n* `StrExt::parse` is now stable\n* `FromStr for bool` is now stable\n* `FromStr for $float` is now stable\n* `FromStr for $integral` is now stable\n* Errors returned from stable `FromStr` implementations are stable\n* Errors implement `Display` and `Error` (both impl blocks being `#[stable]`)\n\nCloses #15138", "tree": {"sha": "cefa26a551d7703c5f8534cc6661432348c93e06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cefa26a551d7703c5f8534cc6661432348c93e06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac1a03d7422ba52749e4e513a46c8d2129c2c817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac1a03d7422ba52749e4e513a46c8d2129c2c817", "html_url": "https://github.com/rust-lang/rust/commit/ac1a03d7422ba52749e4e513a46c8d2129c2c817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac1a03d7422ba52749e4e513a46c8d2129c2c817/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba812fbf00e3026b29282e1a72d58ea7959833e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba812fbf00e3026b29282e1a72d58ea7959833e", "html_url": "https://github.com/rust-lang/rust/commit/0ba812fbf00e3026b29282e1a72d58ea7959833e"}, {"sha": "0cdde6e5e015ee6f6d9381ab624a312af7c9b069", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cdde6e5e015ee6f6d9381ab624a312af7c9b069", "html_url": "https://github.com/rust-lang/rust/commit/0cdde6e5e015ee6f6d9381ab624a312af7c9b069"}], "stats": {"total": 655, "additions": 392, "deletions": 263}, "files": [{"sha": "df2981a6c8334a385180a405c4f8155797e020ee", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -25,17 +25,18 @@ pub enum Mode {\n }\n \n impl FromStr for Mode {\n-    fn from_str(s: &str) -> Option<Mode> {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<Mode, ()> {\n         match s {\n-          \"compile-fail\" => Some(CompileFail),\n-          \"run-fail\" => Some(RunFail),\n-          \"run-pass\" => Some(RunPass),\n-          \"run-pass-valgrind\" => Some(RunPassValgrind),\n-          \"pretty\" => Some(Pretty),\n-          \"debuginfo-lldb\" => Some(DebugInfoLldb),\n-          \"debuginfo-gdb\" => Some(DebugInfoGdb),\n-          \"codegen\" => Some(Codegen),\n-          _ => None,\n+          \"compile-fail\" => Ok(CompileFail),\n+          \"run-fail\" => Ok(RunFail),\n+          \"run-pass\" => Ok(RunPass),\n+          \"run-pass-valgrind\" => Ok(RunPassValgrind),\n+          \"pretty\" => Ok(Pretty),\n+          \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n+          \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n+          \"codegen\" => Ok(Codegen),\n+          _ => Err(()),\n         }\n     }\n }"}, {"sha": "ea733c84a978bd816a5d04085cebc96451c97ee4", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -35,7 +35,6 @@ extern crate log;\n use std::os;\n use std::old_io;\n use std::old_io::fs;\n-use std::str::FromStr;\n use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n@@ -140,9 +139,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode: FromStr::from_str(matches.opt_str(\"mode\")\n-                                       .unwrap()\n-                                       .as_slice()).expect(\"invalid mode\"),\n+        mode: matches.opt_str(\"mode\").unwrap().parse().ok().expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),"}, {"sha": "66059d2d13d263bca1f9895eca4b293b716890e8", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -352,8 +352,8 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = components[0].parse().expect(error_string);\n-    let minor: int = components[1].parse().expect(error_string);\n+    let major: int = components[0].parse().ok().expect(error_string);\n+    let minor: int = components[1].parse().ok().expect(error_string);\n \n     return major * 1000 + minor;\n }\n@@ -363,6 +363,6 @@ pub fn lldb_version_to_int(version_string: &str) -> int {\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string.as_slice();\n-    let major: int = version_string.parse().expect(error_string);\n+    let major: int = version_string.parse().ok().expect(error_string);\n     return major;\n }"}, {"sha": "686820eb8132c2e63db9077e66fb036b7344e4a2", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -2994,7 +2994,7 @@ Some examples of call expressions:\n # fn add(x: i32, y: i32) -> i32 { 0 }\n \n let x: i32 = add(1i32, 2i32);\n-let pi: Option<f32> = \"3.14\".parse();\n+let pi: Option<f32> = \"3.14\".parse().ok();\n ```\n \n ### Lambda expressions"}, {"sha": "162e533d8bb72cb02aedfa75a79ca98691d9aa9f", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -400,7 +400,7 @@ a function for that:\n let input = old_io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n-let input_num: Option<u32> = input.parse();\n+let input_num: Option<u32> = input.parse().ok();\n ```\n \n The `parse` function takes in a `&str` value and converts it into something.\n@@ -422,11 +422,13 @@ In this case, we say `x` is a `u32` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = \"5\".parse::<u32>(); // input_num: Option<u32>\n-let input_num: Option<u32> = \"5\".parse(); // input_num: Option<u32>\n+let input_num = \"5\".parse::<u32>().ok(); // input_num: Option<u32>\n+let input_num: Option<u32> = \"5\".parse().ok(); // input_num: Option<u32>\n ```\n \n-Anyway, with us now converting our input to a number, our code looks like this:\n+Here we're converting the `Result` returned by `parse` to an `Option` by using\n+the `ok` method as well.  Anyway, with us now converting our input to a number,\n+our code looks like this:\n \n ```{rust,ignore}\n use std::old_io;\n@@ -445,7 +447,7 @@ fn main() {\n     let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<u32> = input.parse();\n+    let input_num: Option<u32> = input.parse().ok();\n \n     println!(\"You guessed: {}\", input_num);\n \n@@ -495,7 +497,7 @@ fn main() {\n     let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<u32> = input.parse();\n+    let input_num: Option<u32> = input.parse().ok();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -562,7 +564,7 @@ fn main() {\n     let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<u32> = input.trim().parse();\n+    let input_num: Option<u32> = input.trim().parse().ok();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -638,7 +640,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -714,7 +716,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -770,7 +772,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -847,7 +849,7 @@ fn main() {\n         let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<u32> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse().ok();\n \n         let num = match input_num {\n             Some(num) => num,"}, {"sha": "f6ba2b0ebaf94a47aa9c3c9494f44bd333330c3f", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -68,6 +68,7 @@ use core::ops::FullRange;\n #[cfg(not(stage0))]\n use core::ops::RangeFull;\n use core::option::Option::{self, Some, None};\n+use core::result::Result;\n use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n@@ -1231,13 +1232,12 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// # Example\n     ///\n     /// ```\n-    /// assert_eq!(\"4\".parse::<u32>(), Some(4));\n-    /// assert_eq!(\"j\".parse::<u32>(), None);\n+    /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// assert!(\"j\".parse::<u32>().is_err());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this method was just created\")]\n-    fn parse<F: FromStr>(&self) -> Option<F> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n         core_str::StrExt::parse(&self[])\n     }\n "}, {"sha": "fa399ca34149094d194ad29bcc8074279905ecd6", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -940,10 +940,12 @@ pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n \n+#[unstable(feature = \"collections\", reason = \"associated error type may change\")]\n impl FromStr for String {\n+    type Err = ();\n     #[inline]\n-    fn from_str(s: &str) -> Option<String> {\n-        Some(String::from_str(s))\n+    fn from_str(s: &str) -> Result<String, ()> {\n+        Ok(String::from_str(s))\n     }\n }\n \n@@ -1016,7 +1018,7 @@ mod tests {\n \n     #[test]\n     fn test_from_str() {\n-      let owned: Option<::std::string::String> = \"string\".parse();\n+      let owned: Option<::std::string::String> = \"string\".parse().ok();\n       assert_eq!(owned.as_ref().map(|s| s.as_slice()), Some(\"string\"));\n     }\n "}, {"sha": "206e63c7a17444f42e8b1bd7684b0e56fb02f6ab", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 123, "deletions": 51, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -17,16 +17,17 @@\n \n use char::CharExt;\n use clone::Clone;\n-use cmp::{PartialEq, Eq};\n-use cmp::{PartialOrd, Ord};\n+use cmp::{PartialEq, Eq, PartialOrd, Ord};\n+use error::Error;\n+use fmt;\n use intrinsics;\n use iter::IteratorExt;\n use marker::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n-use option::Option;\n-use option::Option::{Some, None};\n+use option::Option::{self, Some, None};\n+use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n@@ -1428,22 +1429,25 @@ pub trait Float\n }\n \n /// A generic trait for converting a string with a radix (base) to a value\n-#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n+#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n pub trait FromStrRadix {\n-    fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n+    type Err;\n+    fn from_str_radix(str: &str, radix: uint) -> Result<Self, Self::Err>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n-#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n+#[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint)\n+                                       -> Result<T, T::Err> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $T {\n+            type Err = ParseFloatError;\n+\n             /// Convert a string in base 10 to a float.\n             /// Accepts an optional decimal exponent.\n             ///\n@@ -1470,14 +1474,15 @@ macro_rules! from_str_radix_float_impl {\n             /// `None` if the string did not represent a valid number.  Otherwise,\n             /// `Some(n)` where `n` is the floating-point number represented by `src`.\n             #[inline]\n-            fn from_str(src: &str) -> Option<$T> {\n+            fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStrRadix for $T {\n+            type Err = ParseFloatError;\n+\n             /// Convert a string in a given base to a float.\n             ///\n             /// Due to possible conflicts, this function does **not** accept\n@@ -1493,24 +1498,28 @@ macro_rules! from_str_radix_float_impl {\n             ///\n             /// # Return value\n             ///\n-            /// `None` if the string did not represent a valid number. Otherwise,\n-            /// `Some(n)` where `n` is the floating-point number represented by `src`.\n-            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n-               assert!(radix >= 2 && radix <= 36,\n+            /// `None` if the string did not represent a valid number.\n+            /// Otherwise, `Some(n)` where `n` is the floating-point number\n+            /// represented by `src`.\n+            fn from_str_radix(src: &str, radix: uint)\n+                              -> Result<$T, ParseFloatError> {\n+                use self::FloatErrorKind::*;\n+                use self::ParseFloatError as PFE;\n+                assert!(radix >= 2 && radix <= 36,\n                        \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n                        radix);\n \n                 // Special values\n                 match src {\n-                    \"inf\"   => return Some(Float::infinity()),\n-                    \"-inf\"  => return Some(Float::neg_infinity()),\n-                    \"NaN\"   => return Some(Float::nan()),\n+                    \"inf\"   => return Ok(Float::infinity()),\n+                    \"-inf\"  => return Ok(Float::neg_infinity()),\n+                    \"NaN\"   => return Ok(Float::nan()),\n                     _       => {},\n                 }\n \n                 let (is_positive, src) =  match src.slice_shift_char() {\n-                    None             => return None,\n-                    Some(('-', \"\"))  => return None,\n+                    None             => return Err(PFE { kind: Empty }),\n+                    Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n                     Some(('-', src)) => (false, src),\n                     Some((_, _))     => (true,  src),\n                 };\n@@ -1541,15 +1550,15 @@ macro_rules! from_str_radix_float_impl {\n                             // if we've not seen any non-zero digits.\n                             if prev_sig != 0.0 {\n                                 if is_positive && sig <= prev_sig\n-                                    { return Some(Float::infinity()); }\n+                                    { return Ok(Float::infinity()); }\n                                 if !is_positive && sig >= prev_sig\n-                                    { return Some(Float::neg_infinity()); }\n+                                    { return Ok(Float::neg_infinity()); }\n \n                                 // Detect overflow by reversing the shift-and-add process\n                                 if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n-                                    { return Some(Float::infinity()); }\n+                                    { return Ok(Float::infinity()); }\n                                 if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n-                                    { return Some(Float::neg_infinity()); }\n+                                    { return Ok(Float::neg_infinity()); }\n                             }\n                             prev_sig = sig;\n                         },\n@@ -1562,7 +1571,7 @@ macro_rules! from_str_radix_float_impl {\n                                 break;  // start of fractional part\n                             },\n                             _ => {\n-                                return None;\n+                                return Err(PFE { kind: Invalid });\n                             },\n                         },\n                     }\n@@ -1585,9 +1594,9 @@ macro_rules! from_str_radix_float_impl {\n                                 };\n                                 // Detect overflow by comparing to last value\n                                 if is_positive && sig < prev_sig\n-                                    { return Some(Float::infinity()); }\n+                                    { return Ok(Float::infinity()); }\n                                 if !is_positive && sig > prev_sig\n-                                    { return Some(Float::neg_infinity()); }\n+                                    { return Ok(Float::neg_infinity()); }\n                                 prev_sig = sig;\n                             },\n                             None => match c {\n@@ -1596,7 +1605,7 @@ macro_rules! from_str_radix_float_impl {\n                                     break; // start of exponent\n                                 },\n                                 _ => {\n-                                    return None; // invalid number\n+                                    return Err(PFE { kind: Invalid });\n                                 },\n                             },\n                         }\n@@ -1609,7 +1618,7 @@ macro_rules! from_str_radix_float_impl {\n                         let base = match c {\n                             'E' | 'e' if radix == 10 => 10.0,\n                             'P' | 'p' if radix == 16 => 2.0,\n-                            _ => return None,\n+                            _ => return Err(PFE { kind: Invalid }),\n                         };\n \n                         // Parse the exponent as decimal integer\n@@ -1618,19 +1627,19 @@ macro_rules! from_str_radix_float_impl {\n                             Some(('-', src)) => (false, src.parse::<uint>()),\n                             Some(('+', src)) => (true,  src.parse::<uint>()),\n                             Some((_, _))     => (true,  src.parse::<uint>()),\n-                            None             => return None,\n+                            None             => return Err(PFE { kind: Invalid }),\n                         };\n \n                         match (is_positive, exp) {\n-                            (true,  Some(exp)) => base.powi(exp as i32),\n-                            (false, Some(exp)) => 1.0 / base.powi(exp as i32),\n-                            (_, None)          => return None,\n+                            (true,  Ok(exp)) => base.powi(exp as i32),\n+                            (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n+                            (_, Err(_))      => return Err(PFE { kind: Invalid }),\n                         }\n                     },\n                     None => 1.0, // no exponent\n                 };\n \n-                Some(sig * exp)\n+                Ok(sig * exp)\n             }\n         }\n     }\n@@ -1640,19 +1649,22 @@ from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $T {\n+            type Err = ParseIntError;\n             #[inline]\n-            fn from_str(src: &str) -> Option<$T> {\n+            fn from_str(src: &str) -> Result<$T, ParseIntError> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n-        #[unstable(feature = \"core\",\n-                   reason = \"might need to return Result\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStrRadix for $T {\n-            fn from_str_radix(src: &str, radix: uint) -> Option<$T> {\n+            type Err = ParseIntError;\n+            fn from_str_radix(src: &str, radix: uint)\n+                              -> Result<$T, ParseIntError> {\n+                use self::IntErrorKind::*;\n+                use self::ParseIntError as PIE;\n                 assert!(radix >= 2 && radix <= 36,\n                        \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n                        radix);\n@@ -1666,39 +1678,39 @@ macro_rules! from_str_radix_int_impl {\n                         for c in src.chars() {\n                             let x = match c.to_digit(radix) {\n                                 Some(x) => x,\n-                                None => return None,\n+                                None => return Err(PIE { kind: InvalidDigit }),\n                             };\n                             result = match result.checked_mul(radix as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Underflow }),\n                             };\n                             result = match result.checked_sub(x as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Underflow }),\n                             };\n                         }\n-                        Some(result)\n+                        Ok(result)\n                     },\n                     Some((_, _)) => {\n                         // The number is signed\n                         let mut result = 0;\n                         for c in src.chars() {\n                             let x = match c.to_digit(radix) {\n                                 Some(x) => x,\n-                                None => return None,\n+                                None => return Err(PIE { kind: InvalidDigit }),\n                             };\n                             result = match result.checked_mul(radix as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Overflow }),\n                             };\n                             result = match result.checked_add(x as $T) {\n                                 Some(result) => result,\n-                                None => return None,\n+                                None => return Err(PIE { kind: Overflow }),\n                             };\n                         }\n-                        Some(result)\n+                        Ok(result)\n                     },\n-                    None => None,\n+                    None => Err(ParseIntError { kind: Empty }),\n                 }\n             }\n         }\n@@ -1714,3 +1726,63 @@ from_str_radix_int_impl! { u8 }\n from_str_radix_int_impl! { u16 }\n from_str_radix_int_impl! { u32 }\n from_str_radix_int_impl! { u64 }\n+\n+/// An error which can be returned when parsing an integer.\n+#[derive(Show, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseIntError { kind: IntErrorKind }\n+\n+#[derive(Show, Clone, PartialEq)]\n+enum IntErrorKind {\n+    Empty,\n+    InvalidDigit,\n+    Overflow,\n+    Underflow,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseIntError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for ParseIntError {\n+    fn description(&self) -> &str {\n+        match self.kind {\n+            IntErrorKind::Empty => \"cannot parse integer from empty string\",\n+            IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n+            IntErrorKind::Overflow => \"number too large to fit in target type\",\n+            IntErrorKind::Underflow => \"number too small to fit in target type\",\n+        }\n+    }\n+}\n+\n+/// An error which can be returned when parsing a float.\n+#[derive(Show, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseFloatError { kind: FloatErrorKind }\n+\n+#[derive(Show, Clone, PartialEq)]\n+enum FloatErrorKind {\n+    Empty,\n+    Invalid,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseFloatError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for ParseFloatError {\n+    fn description(&self) -> &str {\n+        match self.kind {\n+            FloatErrorKind::Empty => \"cannot parse float from empty string\",\n+            FloatErrorKind::Invalid => \"invalid float literal\",\n+        }\n+    }\n+}"}, {"sha": "2f261b0628faf1cd6b550c4d27e55a022f1e4e29", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -728,8 +728,8 @@ impl<T: Default> Option<T> {\n     /// ```\n     /// let good_year_from_input = \"1909\";\n     /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n-    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n+    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n     ///\n     /// assert_eq!(1909, good_year);\n     /// assert_eq!(0, bad_year);"}, {"sha": "93942d0b8360d50d3d67ed78352690d18ee79c2b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -109,37 +109,62 @@ macro_rules! delegate_iter {\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n-// FIXME(#17307): there should be an `E` associated type for a `Result` return\n-#[unstable(feature = \"core\",\n-           reason = \"will return a Result once associated types are working\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait FromStr {\n+    /// The associated error which can be returned from parsing.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Err;\n+\n     /// Parses a string `s` to return an optional value of this type. If the\n     /// string is ill-formatted, the None is returned.\n-    fn from_str(s: &str) -> Option<Self>;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn from_str(s: &str) -> Result<Self, Self::Err>;\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for bool {\n+    type Err = ParseBoolError;\n+\n     /// Parse a `bool` from a string.\n     ///\n-    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n+    /// Yields an `Option<bool>`, because `s` may or may not actually be\n+    /// parseable.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// assert_eq!(\"true\".parse(), Some(true));\n-    /// assert_eq!(\"false\".parse(), Some(false));\n-    /// assert_eq!(\"not even a boolean\".parse::<bool>(), None);\n+    /// assert_eq!(\"true\".parse(), Ok(true));\n+    /// assert_eq!(\"false\".parse(), Ok(false));\n+    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n     /// ```\n     #[inline]\n-    fn from_str(s: &str) -> Option<bool> {\n+    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n         match s {\n-            \"true\"  => Some(true),\n-            \"false\" => Some(false),\n-            _       => None,\n+            \"true\"  => Ok(true),\n+            \"false\" => Ok(false),\n+            _       => Err(ParseBoolError { _priv: () }),\n         }\n     }\n }\n \n+/// An error returned when parsing a `bool` from a string fails.\n+#[derive(Show, Clone, PartialEq)]\n+#[allow(missing_copy_implementations)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseBoolError { _priv: () }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseBoolError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"provided string was not `true` or `false`\".fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for ParseBoolError {\n+    fn description(&self) -> &str { \"failed to parse bool\" }\n+}\n+\n /*\n Section: Creating a string\n */\n@@ -1356,7 +1381,7 @@ pub trait StrExt {\n     fn as_ptr(&self) -> *const u8;\n     fn len(&self) -> uint;\n     fn is_empty(&self) -> bool;\n-    fn parse<T: FromStr>(&self) -> Option<T>;\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n #[inline(never)]\n@@ -1671,7 +1696,7 @@ impl StrExt for str {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n \n     #[inline]\n-    fn parse<T: FromStr>(&self) -> Option<T> { FromStr::from_str(self) }\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n }\n \n /// Pluck a code point out of a UTF-8-like byte slice and return the"}, {"sha": "d956cd4816b0e132e34a8bb4df00050125f32c12", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -159,7 +159,7 @@ mod tests {\n     #[test]\n     fn test_from_str() {\n         fn from_str<T: ::std::str::FromStr>(t: &str) -> Option<T> {\n-            ::std::str::FromStr::from_str(t)\n+            ::std::str::FromStr::from_str(t).ok()\n         }\n         assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n         assert_eq!(from_str::<$T>(\"3\"), Some(3 as $T));\n@@ -180,26 +180,26 @@ mod tests {\n \n     #[test]\n     fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Ok(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n     }\n }\n "}, {"sha": "f93c07eac5f283ca8ca73598250e410e47f2a223", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -62,64 +62,64 @@ mod test {\n \n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix(\"1000\", 10);\n+        let u : Option<u8> = from_str_radix(\"1000\", 10).ok();\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix(\"80000\", 10);\n+        let s : Option<i16> = from_str_radix(\"80000\", 10).ok();\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10);\n+        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10).ok();\n         assert_eq!(f, Some(Float::infinity()));\n-        let fe : Option<f32> = from_str_radix(\"1e40\", 10);\n+        let fe : Option<f32> = from_str_radix(\"1e40\", 10).ok();\n         assert_eq!(fe, Some(Float::infinity()));\n     }\n \n     #[test]\n     fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10);\n+        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10).ok();\n         assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix(\"123.456\", 10);\n+        let x2 : Option<f32> = from_str_radix(\"123.456\", 10).ok();\n         assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10);\n+        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10).ok();\n         assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix(\"0.0\", 10);\n+        let x4 : Option<f32> = from_str_radix(\"0.0\", 10).ok();\n         assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix(\"1.0\", 10);\n+        let x4 : Option<f32> = from_str_radix(\"1.0\", 10).ok();\n         assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10);\n+        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10).ok();\n         assert_eq!(x5, Some(-1.0));\n     }\n \n     #[test]\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n-        assert_eq!(\"127\".parse::<i8>(), Some(i8_val));\n-        assert_eq!(\"128\".parse::<i8>(), None);\n+        assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n+        assert_eq!(\"128\".parse::<i8>().ok(), None);\n \n         i8_val += 1 as i8;\n-        assert_eq!(\"-128\".parse::<i8>(), Some(i8_val));\n-        assert_eq!(\"-129\".parse::<i8>(), None);\n+        assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n+        assert_eq!(\"-129\".parse::<i8>().ok(), None);\n \n         let mut i16_val: i16 = 32_767_i16;\n-        assert_eq!(\"32767\".parse::<i16>(), Some(i16_val));\n-        assert_eq!(\"32768\".parse::<i16>(), None);\n+        assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n+        assert_eq!(\"32768\".parse::<i16>().ok(), None);\n \n         i16_val += 1 as i16;\n-        assert_eq!(\"-32768\".parse::<i16>(), Some(i16_val));\n-        assert_eq!(\"-32769\".parse::<i16>(), None);\n+        assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n+        assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n-        assert_eq!(\"2147483647\".parse::<i32>(), Some(i32_val));\n-        assert_eq!(\"2147483648\".parse::<i32>(), None);\n+        assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n+        assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n \n         i32_val += 1 as i32;\n-        assert_eq!(\"-2147483648\".parse::<i32>(), Some(i32_val));\n-        assert_eq!(\"-2147483649\".parse::<i32>(), None);\n+        assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n+        assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-        assert_eq!(\"9223372036854775807\".parse::<i64>(), Some(i64_val));\n-        assert_eq!(\"9223372036854775808\".parse::<i64>(), None);\n+        assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n+        assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n \n         i64_val += 1 as i64;\n-        assert_eq!(\"-9223372036854775808\".parse::<i64>(), Some(i64_val));\n-        assert_eq!(\"-9223372036854775809\".parse::<i64>(), None);\n+        assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n+        assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n     }\n }"}, {"sha": "f2a1b0ac584d3d34875b5ede0d2db196fbb50c3e", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -10,9 +10,9 @@\n \n #[test]\n fn test_bool_from_str() {\n-    assert_eq!(\"true\".parse(), Some(true));\n-    assert_eq!(\"false\".parse(), Some(false));\n-    assert_eq!(\"not even a boolean\".parse::<bool>(), None);\n+    assert_eq!(\"true\".parse().ok(), Some(true));\n+    assert_eq!(\"false\".parse().ok(), Some(false));\n+    assert_eq!(\"not even a boolean\".parse::<bool>().ok(), None);\n }\n \n fn check_contains_all_substrings(s: &str) {"}, {"sha": "46b9b2ed86539483d95ca88017678dfcd077f6e8", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -22,7 +22,7 @@ pub static LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\",\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    level.parse::<u32>().or_else(|| {\n+    level.parse::<u32>().ok().or_else(|| {\n         let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n         pos.map(|p| p as u32 + 1)\n     }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))"}, {"sha": "2248562352d55b353624e5832f196a3e81fc88d5", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -254,7 +254,7 @@ impl LintPass for TypeLimits {\n                         let lit_val: f64 = match lit.node {\n                             ast::LitFloat(ref v, _) |\n                             ast::LitFloatUnsuffixed(ref v) => {\n-                                match v.parse() {\n+                                match v.parse().ok() {\n                                     Some(f) => f,\n                                     None => return\n                                 }"}, {"sha": "bb4b52378ea9a6cdc9c3d470b94e17537bb45447", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -223,7 +223,7 @@ fn each_reexport<F>(d: rbml::Doc, f: F) -> bool where\n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n         reader::with_doc_data(val_doc, |data| {\n-            str::from_utf8(data).ok().and_then(|s| s.parse())\n+            str::from_utf8(data).ok().and_then(|s| s.parse().ok())\n         })\n     })\n }"}, {"sha": "6d19107096a4b6b9569ea7f84159cb3d5a5e9bc7", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -717,12 +717,16 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_part = &buf[0u..colon_idx];\n     let def_part = &buf[colon_idx + 1u..len];\n \n-    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n+    let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n+        s.parse::<uint>().ok()\n+    }) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n                      crate_part)\n     };\n-    let def_num = match str::from_utf8(def_part).ok().and_then(|s| s.parse::<uint>()) {\n+    let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n+        s.parse::<uint>().ok()\n+    }) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n                      def_part)"}, {"sha": "92d8419484ad92ecb8bab0fd30fe31b16336783f", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -59,7 +59,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n \n     let requested_node : Option<ast::NodeId> =\n-        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse());\n+        os::getenv(\"RUST_REGION_GRAPH_NODE\").and_then(|s| s.parse().ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;"}, {"sha": "da83833fba3a14b3470293681f823bb26290b5a3", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -18,7 +18,6 @@\n use session::Session;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use std::str::FromStr;\n \n pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n     for attr in krate.attrs.iter() {\n@@ -27,7 +26,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n         }\n \n         if let Some(s) = attr.value_str() {\n-            if let Some(n) = FromStr::from_str(s.get()) {\n+            if let Some(n) = s.parse().ok() {\n                 sess.recursion_limit.set(n);\n                 return;\n             }"}, {"sha": "125fbaa40e05fdfcf287ea77a5397bf4dca288f1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -424,15 +424,15 @@ macro_rules! options {\n         }\n \n         fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse()) {\n+            match v.and_then(|s| s.parse().ok()) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }\n         }\n \n         fn parse_opt_uint(slot: &mut Option<uint>, v: Option<&str>) -> bool {\n             match v {\n-                Some(s) => { *slot = s.parse(); slot.is_some() }\n+                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n                 None => { *slot = None; true }\n             }\n         }"}, {"sha": "bd7ad51de37247ee77956eca4e91e248d38f90a6", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -99,7 +99,7 @@ pub fn parse_pretty(sess: &Session,\n             }\n         }\n     };\n-    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>());\n+    let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n     (first, opt_second)\n }\n \n@@ -345,13 +345,11 @@ pub enum UserIdentifiedItem {\n }\n \n impl FromStr for UserIdentifiedItem {\n-    fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n-        s.parse().map(ItemViaNode).or_else(|| {\n-            let v : Vec<_> = s.split_str(\"::\")\n-                .map(|x|x.to_string())\n-                .collect();\n-            Some(ItemViaPath(v))\n-        })\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n+        Ok(s.parse().map(ItemViaNode).unwrap_or_else(|_| {\n+            ItemViaPath(s.split_str(\"::\").map(|s| s.to_string()).collect())\n+        }))\n     }\n }\n "}, {"sha": "b50f12deb445869cd25e1c07b71e8106db8e55f8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -2127,7 +2127,7 @@ macro_rules! read_primitive {\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                Json::String(s) => match s.parse() {\n+                Json::String(s) => match s.parse().ok() {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 },\n@@ -2165,7 +2165,7 @@ impl ::Decoder for Decoder {\n             Json::String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                match s.parse() {\n+                match s.parse().ok() {\n                     Some(f) => Ok(f),\n                     None => Err(ExpectedError(\"Number\".to_string(), s)),\n                 }\n@@ -2597,8 +2597,9 @@ impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n }\n \n impl FromStr for Json {\n-    fn from_str(s: &str) -> Option<Json> {\n-        from_str(s).ok()\n+    type Err = BuilderError;\n+    fn from_str(s: &str) -> Result<Json, BuilderError> {\n+        from_str(s)\n     }\n }\n "}, {"sha": "4cd6391318f16925a401d78f331f34df04f501da", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -20,7 +20,7 @@ mod tests {\n     use num::FromStrRadix;\n \n     fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> {\n-        ::str::FromStr::from_str(t)\n+        ::str::FromStr::from_str(t).ok()\n     }\n \n     #[test]\n@@ -38,15 +38,15 @@ mod tests {\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123u as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9u as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83u as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291u as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535u as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35u as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35u as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2).ok(), None::<$T>);\n     }\n \n     #[test]"}, {"sha": "3e2e69f75a63624dc7d709160bcfc241246f3b63", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -25,7 +25,7 @@ use iter::{Iterator, IteratorExt};\n use ops::{FnOnce, FnMut};\n use option::Option;\n use option::Option::{None, Some};\n-use result::Result::{Ok, Err};\n+use result::Result::{self, Ok, Err};\n use slice::SliceExt;\n use str::{FromStr, StrExt};\n use vec::Vec;\n@@ -350,17 +350,28 @@ impl<'a> Parser<'a> {\n }\n \n impl FromStr for IpAddr {\n-    fn from_str(s: &str) -> Option<IpAddr> {\n-        Parser::new(s).read_till_eof(|p| p.read_ip_addr())\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<IpAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n     }\n }\n \n impl FromStr for SocketAddr {\n-    fn from_str(s: &str) -> Option<SocketAddr> {\n-        Parser::new(s).read_till_eof(|p| p.read_socket_addr())\n+    type Err = ParseError;\n+    fn from_str(s: &str) -> Result<SocketAddr, ParseError> {\n+        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n+            Some(s) => Ok(s),\n+            None => Err(ParseError),\n+        }\n     }\n }\n \n+#[derive(Show, Clone, PartialEq, Copy)]\n+pub struct ParseError;\n+\n /// A trait for objects which can be converted or resolved to one or more `SocketAddr` values.\n ///\n /// Implementing types minimally have to implement either `to_socket_addr` or `to_socket_addr_all`\n@@ -493,7 +504,7 @@ fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n     let mut parts_iter = s.rsplitn(2, ':');\n     let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n     let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n-    let port: u16 = try_opt!(FromStr::from_str(port_str), \"invalid port value\");\n+    let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n     resolve_socket_addr(host, port)\n }\n \n@@ -502,7 +513,7 @@ impl<'a> ToSocketAddr for (&'a str, u16) {\n         let (host, port) = *self;\n \n         // try to parse the host as a regular IpAddr first\n-        match FromStr::from_str(host) {\n+        match host.parse().ok() {\n             Some(addr) => return Ok(vec![SocketAddr {\n                 ip: addr,\n                 port: port\n@@ -518,7 +529,7 @@ impl<'a> ToSocketAddr for (&'a str, u16) {\n impl<'a> ToSocketAddr for &'a str {\n     fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n         // try to parse as a regular SocketAddr first\n-        match FromStr::from_str(*self) {\n+        match self.parse().ok() {\n             Some(addr) => return Ok(addr),\n             None => {}\n         }\n@@ -535,7 +546,7 @@ impl<'a> ToSocketAddr for &'a str {\n \n     fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n         // try to parse as a regular SocketAddr first\n-        match FromStr::from_str(*self) {\n+        match self.parse().ok() {\n             Some(addr) => return Ok(vec![addr]),\n             None => {}\n         }\n@@ -553,95 +564,94 @@ mod test {\n \n     #[test]\n     fn test_from_str_ipv4() {\n-        assert_eq!(Some(Ipv4Addr(127, 0, 0, 1)), FromStr::from_str(\"127.0.0.1\"));\n-        assert_eq!(Some(Ipv4Addr(255, 255, 255, 255)), FromStr::from_str(\"255.255.255.255\"));\n-        assert_eq!(Some(Ipv4Addr(0, 0, 0, 0)), FromStr::from_str(\"0.0.0.0\"));\n+        assert_eq!(Ok(Ipv4Addr(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+        assert_eq!(Ok(Ipv4Addr(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+        assert_eq!(Ok(Ipv4Addr(0, 0, 0, 0)), \"0.0.0.0\".parse());\n \n         // out of range\n-        let none: Option<IpAddr> = FromStr::from_str(\"256.0.0.1\");\n+        let none: Option<IpAddr> = \"256.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // too short\n-        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0\");\n+        let none: Option<IpAddr> = \"255.0.0\".parse().ok();\n         assert_eq!(None, none);\n         // too long\n-        let none: Option<IpAddr> = FromStr::from_str(\"255.0.0.1.2\");\n+        let none: Option<IpAddr> = \"255.0.0.1.2\".parse().ok();\n         assert_eq!(None, none);\n         // no number between dots\n-        let none: Option<IpAddr> = FromStr::from_str(\"255.0..1\");\n+        let none: Option<IpAddr> = \"255.0..1\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n     #[test]\n     fn test_from_str_ipv6() {\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"0:0:0:0:0:0:0:0\"));\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"0:0:0:0:0:0:0:1\"));\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n \n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"::1\"));\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"::\"));\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n \n-        assert_eq!(Some(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n-                FromStr::from_str(\"2a02:6b8::11:11\"));\n+        assert_eq!(Ok(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                \"2a02:6b8::11:11\".parse());\n \n         // too long group\n-        let none: Option<IpAddr> = FromStr::from_str(\"::00000\");\n+        let none: Option<IpAddr> = \"::00000\".parse().ok();\n         assert_eq!(None, none);\n         // too short\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7\");\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7\".parse().ok();\n         assert_eq!(None, none);\n         // too long\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2:3:4:5:6:7:8:9\");\n+        let none: Option<IpAddr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n         assert_eq!(None, none);\n         // triple colon\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2:::6:7:8\");\n+        let none: Option<IpAddr> = \"1:2:::6:7:8\".parse().ok();\n         assert_eq!(None, none);\n         // two double colons\n-        let none: Option<IpAddr> = FromStr::from_str(\"1:2::6::8\");\n+        let none: Option<IpAddr> = \"1:2::6::8\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n     #[test]\n     fn test_from_str_ipv4_in_ipv6() {\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n-                FromStr::from_str(\"::192.0.2.33\"));\n-        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n-                FromStr::from_str(\"::FFFF:192.0.2.33\"));\n-        assert_eq!(Some(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-                FromStr::from_str(\"64:ff9b::192.0.2.33\"));\n-        assert_eq!(Some(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-                FromStr::from_str(\"2001:db8:122:c000:2:2100:192.0.2.33\"));\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                \"::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                \"::FFFF:192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                \"64:ff9b::192.0.2.33\".parse());\n+        assert_eq!(Ok(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n \n         // colon after v4\n-        let none: Option<IpAddr> = FromStr::from_str(\"::127.0.0.1:\");\n+        let none: Option<IpAddr> = \"::127.0.0.1:\".parse().ok();\n         assert_eq!(None, none);\n         // not enough groups\n-        let none: Option<IpAddr> = FromStr::from_str(\"1.2.3.4.5:127.0.0.1\");\n+        let none: Option<IpAddr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // too many groups\n-        let none: Option<IpAddr> =\n-            FromStr::from_str(\"1.2.3.4.5:6:7:127.0.0.1\");\n+        let none: Option<IpAddr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n     #[test]\n     fn test_from_str_socket_addr() {\n-        assert_eq!(Some(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n-                FromStr::from_str(\"77.88.21.11:80\"));\n-        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n-                FromStr::from_str(\"[2a02:6b8:0:1::1]:53\"));\n-        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n-                FromStr::from_str(\"[::127.0.0.1]:22\"));\n+        assert_eq!(Ok(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n+                \"77.88.21.11:80\".parse());\n+        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n+                \"[2a02:6b8:0:1::1]:53\".parse());\n+        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n+                \"[::127.0.0.1]:22\".parse());\n \n         // without port\n-        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1\");\n+        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // without port\n-        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:\");\n+        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n         assert_eq!(None, none);\n         // wrong brackets around v4\n-        let none: Option<SocketAddr> = FromStr::from_str(\"[127.0.0.1]:22\");\n+        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n         assert_eq!(None, none);\n         // port out of range\n-        let none: Option<SocketAddr> = FromStr::from_str(\"127.0.0.1:123456\");\n+        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n         assert_eq!(None, none);\n     }\n "}, {"sha": "72c41f2399e0c015013c07b4b1d6cb2b8f5ef730", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -19,6 +19,7 @@ use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n use marker::Sized;\n use option::Option::{self, Some, None};\n+use result::Result::{self, Ok, Err};\n use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n use str::{self, FromStr, StrExt};\n use vec::Vec;\n@@ -86,11 +87,19 @@ impl Ord for Path {\n }\n \n impl FromStr for Path {\n-    fn from_str(s: &str) -> Option<Path> {\n-        Path::new_opt(s)\n+    type Err = ParsePathError;\n+    fn from_str(s: &str) -> Result<Path, ParsePathError> {\n+        match Path::new_opt(s) {\n+            Some(p) => Ok(p),\n+            None => Err(ParsePathError),\n+        }\n     }\n }\n \n+/// Valuelue indicating that a path could not be parsed from a string.\n+#[derive(Show, Clone, PartialEq, Copy)]\n+pub struct ParsePathError;\n+\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "e04f697b2a480ab78d890816af7eac9feee8cfa5", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -27,6 +27,7 @@ use mem;\n use option::Option::{self, Some, None};\n #[cfg(stage0)]\n use ops::FullRange;\n+use result::Result::{self, Ok, Err};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n@@ -115,11 +116,19 @@ impl Ord for Path {\n }\n \n impl FromStr for Path {\n-    fn from_str(s: &str) -> Option<Path> {\n-        Path::new_opt(s)\n+    type Err = ParsePathError;\n+    fn from_str(s: &str) -> Result<Path, ParsePathError> {\n+        match Path::new_opt(s) {\n+            Some(p) => Ok(p),\n+            None => Err(ParsePathError),\n+        }\n     }\n }\n \n+/// Value indicating that a path could not be parsed from a string.\n+#[derive(Show, Clone, PartialEq, Copy)]\n+pub struct ParsePathError;\n+\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[cfg(not(test))]\n     #[inline]"}, {"sha": "f5727a38b69976fee9652dec5ae55d5129cb0c0b", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -51,7 +51,7 @@ pub fn min_stack() -> uint {\n         0 => {}\n         n => return n - 1,\n     }\n-    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse());\n+    let amt = os::getenv(\"RUST_MIN_STACK\").and_then(|s| s.parse().ok());\n     let amt = amt.unwrap_or(2 * 1024 * 1024);\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n@@ -64,7 +64,7 @@ pub fn min_stack() -> uint {\n pub fn default_sched_threads() -> uint {\n     match os::getenv(\"RUST_THREADS\") {\n         Some(nstr) => {\n-            let opt_n: Option<uint> = nstr.parse();\n+            let opt_n: Option<uint> = nstr.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"`RUST_THREADS` is `{}`, should be a positive integer\", nstr)"}, {"sha": "2cf6058a43379a093d7db89c2372a6476f07d875", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -613,7 +613,7 @@ impl<'a> StringReader<'a> {\n         // find the integer representing the name\n         self.scan_digits(base);\n         let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n-            num::from_str_radix(s, 10).unwrap_or_else(|| {\n+            num::from_str_radix(s, 10).ok().unwrap_or_else(|| {\n                 panic!(\"expected digits representing a name, got {:?}, {}, range [{:?},{:?}]\",\n                       s, whence, start_bpos, self.last_pos);\n             })\n@@ -631,7 +631,7 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         self.scan_digits(base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n-            num::from_str_radix(s, 10).unwrap_or_else(|| {\n+            num::from_str_radix(s, 10).ok().unwrap_or_else(|| {\n                 panic!(\"expected digits representing a ctxt, got {:?}, {}\", s, whence);\n             })\n         });"}, {"sha": "e7be876edbbecd618ad645ce585c19fe5abf6281", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -401,7 +401,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n     let msg2 = &msg[];\n \n     fn esc(len: usize, lit: &str) -> Option<(char, isize)> {\n-        num::from_str_radix(&lit[2..len], 16)\n+        num::from_str_radix(&lit[2..len], 16).ok()\n         .and_then(char::from_u32)\n         .map(|x| (x, len as isize))\n     }\n@@ -410,7 +410,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n             let subslice = &lit[3..idx];\n-            num::from_str_radix(subslice, 16)\n+            num::from_str_radix(subslice, 16).ok()\n                 .and_then(char::from_u32)\n                 .map(|x| (x, subslice.chars().count() as isize + 4))\n         } else {\n@@ -583,7 +583,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n             b'\\'' => b'\\'',\n             b'0' => b'\\0',\n             _ => {\n-                match ::std::num::from_str_radix::<u64>(&lit[2..4], 16) {\n+                match ::std::num::from_str_radix::<u64>(&lit[2..4], 16).ok() {\n                     Some(c) =>\n                         if c > 0xFF {\n                             panic!(err(2))\n@@ -732,7 +732,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    let res: u64 = match ::std::num::from_str_radix(s, base) {\n+    let res: u64 = match ::std::num::from_str_radix(s, base).ok() {\n         Some(r) => r,\n         None => { sd.span_err(sp, \"int literal is too large\"); 0 }\n     };"}, {"sha": "d99095eeba37799be8df741502767973732cf712", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -2459,7 +2459,7 @@ impl<'a> Parser<'a> {\n                     hi = self.span.hi;\n                     self.bump();\n \n-                    let index = n.as_str().parse::<usize>();\n+                    let index = n.as_str().parse::<usize>().ok();\n                     match index {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n@@ -2479,7 +2479,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(last_span,\n                                   &format!(\"unexpected token: `{}`\", n.as_str())[]);\n                     if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n-                        let float = match fstr.parse::<f64>() {\n+                        let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n                             None => continue,\n                         };"}, {"sha": "6492cd4b095a775260897f12b606f360c8f0abad", "filename": "src/libsyntax/show_span.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fshow_span.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -27,14 +27,15 @@ enum Mode {\n }\n \n impl FromStr for Mode {\n-    fn from_str(s: &str) -> Option<Mode> {\n+    type Err = ();\n+    fn from_str(s: &str) -> Result<Mode, ()> {\n         let mode = match s {\n             \"expr\" => Mode::Expression,\n             \"pat\" => Mode::Pattern,\n             \"ty\" => Mode::Type,\n-            _ => return None\n+            _ => return Err(())\n         };\n-        Some(mode)\n+        Ok(mode)\n     }\n }\n \n@@ -73,7 +74,7 @@ impl<'a, 'v> Visitor<'v> for ShowSpanVisitor<'a> {\n pub fn run(span_diagnostic: &diagnostic::SpanHandler,\n            mode: &str,\n            krate: &ast::Crate) {\n-    let mode = match mode.parse() {\n+    let mode = match mode.parse().ok() {\n         Some(mode) => mode,\n         None => return\n     };"}, {"sha": "da893ec251ac4cc0c2838f15637a263376e5a0e7", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -76,7 +76,6 @@ use std::old_io;\n use std::iter::repeat;\n use std::num::{Float, Int};\n use std::os;\n-use std::str::FromStr;\n use std::sync::mpsc::{channel, Sender};\n use std::thread::{self, Thread};\n use std::thunk::{Thunk, Invoke};\n@@ -820,7 +819,7 @@ fn get_concurrency() -> uint {\n     use std::rt;\n     match os::getenv(\"RUST_TEST_TASKS\") {\n         Some(s) => {\n-            let opt_n: Option<uint> = FromStr::from_str(s.as_slice());\n+            let opt_n: Option<uint> = s.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"RUST_TEST_TASKS is `{}`, should be a positive integer.\", s)"}, {"sha": "6cb16f04ce115713ab4bd4f2b52f2cf162f6e85b", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -19,7 +19,7 @@ pub trait read {\n \n impl read for int {\n     fn readMaybe(s: String) -> Option<int> {\n-        s.parse()\n+        s.parse().ok()\n     }\n }\n "}, {"sha": "15a63e153b9f5ef44621e154459148ed02df26b8", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -232,7 +232,7 @@ fn main() {\n     } else {\n         std::os::args().as_slice()\n                        .get(1)\n-                       .and_then(|arg| arg.parse())\n+                       .and_then(|arg| arg.parse().ok())\n                        .unwrap_or(600u)\n     };\n "}, {"sha": "03666c84d576f71c637961b70a635b53ad587efc", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -182,7 +182,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n fn main() {\n     let n = std::os::args().as_slice()\n         .get(1)\n-        .and_then(|arg| arg.parse())\n+        .and_then(|arg| arg.parse().ok())\n         .unwrap_or(2i32);\n \n     let (checksum, maxflips) = fannkuch(n);"}, {"sha": "b216100032221894fb027cc7400d4447ec219a61", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -174,7 +174,7 @@ fn main() {\n         5000000\n     } else {\n         std::os::args().get(1)\n-            .and_then(|arg| arg.parse())\n+            .and_then(|arg| arg.parse().ok())\n             .unwrap_or(1000)\n     };\n     let mut bodies = BODIES;"}, {"sha": "ebe8a0751c3b009226550afcb57fae16ab925bbd", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -68,10 +68,10 @@ fn main() {\n     let token = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         2000000\n     } else {\n-        args.get(1).and_then(|arg| arg.parse()).unwrap_or(1000)\n+        args.get(1).and_then(|arg| arg.parse().ok()).unwrap_or(1000)\n     };\n     let n_tasks = args.get(2)\n-                      .and_then(|arg| arg.parse())\n+                      .and_then(|arg| arg.parse().ok())\n                       .unwrap_or(503);\n \n     start(n_tasks, token);"}, {"sha": "05c6aac90e39c9982830af973cf7a1b4119e9c5a", "filename": "src/test/run-pass/match-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-with-ret-arm.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     // sometimes we have had trouble finding\n     // the right type for f, as we unified\n     // bot and u32 here\n-    let f = match \"1234\".parse::<uint>() {\n+    let f = match \"1234\".parse::<uint>().ok() {\n         None => return (),\n         Some(num) => num as u32\n     };"}, {"sha": "12de40129fd2ff28e0c5e10597d9af177320a92c", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1a03d7422ba52749e4e513a46c8d2129c2c817/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=ac1a03d7422ba52749e4e513a46c8d2129c2c817", "patch": "@@ -41,7 +41,7 @@ fn find_zombies() {\n         if 0 < line_no && 0 < line.len() &&\n            my_pid == line.split(' ').filter(|w| 0 < w.len()).nth(1)\n                          .expect(\"1st column should be PPID\")\n-                         .parse()\n+                         .parse().ok()\n                          .expect(\"PPID string into integer\") &&\n            line.contains(\"defunct\") {\n             panic!(\"Zombie child {}\", line);"}]}