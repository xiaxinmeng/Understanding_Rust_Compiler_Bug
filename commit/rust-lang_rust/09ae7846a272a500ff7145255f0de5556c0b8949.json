{"sha": "09ae7846a272a500ff7145255f0de5556c0b8949", "node_id": "C_kwDOAAsO6NoAKDA5YWU3ODQ2YTI3MmE1MDBmZjcxNDUyNTVmMGRlNTU1NmMwYjg5NDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-28T11:11:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-28T11:11:42Z"}, "message": "Auto merge of #101619 - Xiretza:rustc_parse-session-diagnostics, r=davidtwco\n\nMigrate more of rustc_parse to SessionDiagnostic\n\nStill far from complete, but I thought I'd add a checkpoint here because rebasing was starting to get annoying.", "tree": {"sha": "c1962c694d861b3347d647e5ab3f5fcc75a245eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1962c694d861b3347d647e5ab3f5fcc75a245eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ae7846a272a500ff7145255f0de5556c0b8949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ae7846a272a500ff7145255f0de5556c0b8949", "html_url": "https://github.com/rust-lang/rust/commit/09ae7846a272a500ff7145255f0de5556c0b8949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ae7846a272a500ff7145255f0de5556c0b8949/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6201eabde85db854c1ebb57624be5ec699246b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/6201eabde85db854c1ebb57624be5ec699246b50", "html_url": "https://github.com/rust-lang/rust/commit/6201eabde85db854c1ebb57624be5ec699246b50"}, {"sha": "d7c64574e03f1d44c0a9e200b7dbeba98c50d8b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c64574e03f1d44c0a9e200b7dbeba98c50d8b3", "html_url": "https://github.com/rust-lang/rust/commit/d7c64574e03f1d44c0a9e200b7dbeba98c50d8b3"}], "stats": {"total": 3332, "additions": 2047, "deletions": 1285}, "files": [{"sha": "6b2146ad3ed260391e17fa7ab7b2aeb300d463e7", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -3450,6 +3450,8 @@ version = \"0.0.0\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n+ \"rustc_ast\",\n+ \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_error_messages\",\n  \"rustc_hir\","}, {"sha": "6d34cdce3408f3b4fbb44400004690bc29beeb78", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -71,6 +71,8 @@ parser_field_expression_with_generic = field expressions cannot have generic arg\n parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n \n parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+    .suggestion_remove_label = consider removing the label\n+    .suggestion_enclose_in_block = consider enclosing expression in a block\n \n parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n     .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n@@ -161,3 +163,209 @@ parser_use_eq_instead = unexpected `==`\n \n parser_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n     .suggestion = try using { \"`{}`\" } instead\n+\n+parser_comparison_interpreted_as_generic =\n+    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as comparison\n+    .suggestion = try comparing the cast value\n+\n+parser_shift_interpreted_as_generic =\n+    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as shift\n+    .suggestion = try shifting the cast value\n+\n+parser_found_expr_would_be_stmt = expected expression, found `{$token}`\n+    .label = expected expression\n+\n+parser_leading_plus_not_supported = leading `+` is not supported\n+    .label = unexpected `+`\n+    .suggestion_remove_plus = try removing the `+`\n+\n+parser_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n+    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n+    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n+\n+parser_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n+\n+parser_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n+\n+parser_array_brackets_instead_of_braces = this is a block expression, not an array\n+    .suggestion = to make an array, use square brackets instead of curly braces\n+\n+parser_match_arm_body_without_braces = `match` arm body without braces\n+    .label_statements = {$num_statements ->\n+            [one] this statement is not surrounded by a body\n+           *[other] these statements are not surrounded by a body\n+        }\n+    .label_arrow = while parsing the `match` arm starting here\n+    .suggestion_add_braces = surround the {$num_statements ->\n+            [one] statement\n+           *[other] statements\n+        } with a body\n+    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n+\n+parser_struct_literal_not_allowed_here = struct literals are not allowed here\n+    .suggestion = surround the struct literal with parentheses\n+\n+parser_invalid_interpolated_expression = invalid interpolated expression\n+\n+parser_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+parser_octal_float_literal_not_supported = octal float literal is not supported\n+parser_binary_float_literal_not_supported = binary float literal is not supported\n+parser_not_supported = not supported\n+\n+parser_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n+\n+parser_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n+    .label = invalid suffix `{$suffix}`\n+    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n+    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n+    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n+\n+parser_non_string_abi_literal = non-string ABI literal\n+    .suggestion = specify the ABI with a string literal\n+\n+parser_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n+    .label_unmatched = mismatched closing delimiter\n+    .label_opening_candidate = closing delimiter possibly meant for this\n+    .label_unclosed = unclosed delimiter\n+\n+parser_incorrect_visibility_restriction = incorrect visibility restriction\n+    .help = some possible visibility restrictions are:\n+            `pub(crate)`: visible only on the current crate\n+            `pub(super)`: visible only in the current module's parent\n+            `pub(in path::to::module)`: visible only on the specified path\n+    .suggestion = make this visible only to module `{$inner_str}` with `in`\n+\n+parser_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n+\n+parser_expected_statement_after_outer_attr = expected statement after outer attribute\n+\n+parser_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n+    .help = doc comments must come before what they document, maybe a comment was intended with `//`?\n+    .suggestion = missing comma here\n+\n+parser_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n+    .suggestion = remove `let`\n+\n+parser_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n+parser_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+\n+parser_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n+    .suggestion = initialize the variable\n+    .help = if you meant to overwrite, remove the `let` binding\n+\n+parser_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n+    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+parser_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n+\n+parser_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n+parser_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n+\n+parser_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n+    .label_attr = not permitted following an outer doc comment\n+    .label_prev_doc_comment = previous doc comment\n+    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n+\n+parser_inner_attr_not_permitted_after_outer_attr = an inner attribute is not permitted following an outer attribute\n+    .label_attr = not permitted following an outer attribute\n+    .label_prev_attr = previous outer attribute\n+    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n+\n+parser_inner_attr_not_permitted = an inner attribute is not permitted in this context\n+    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n+\n+parser_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+parser_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n+\n+parser_inner_doc_comment_not_permitted = expected outer doc comment\n+    .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n+    .suggestion = you might have meant to write a regular comment\n+    .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n+    .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n+\n+parser_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n+parser_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n+parser_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n+parser_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n+parser_expected_identifier_found_str = expected identifier, found `{$token}`\n+\n+parser_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n+parser_expected_identifier_found_keyword = expected identifier, found keyword\n+parser_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n+parser_expected_identifier_found_doc_comment = expected identifier, found doc comment\n+parser_expected_identifier = expected identifier\n+\n+parser_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n+\n+parser_sugg_remove_comma = remove this comma\n+\n+parser_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n+parser_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n+parser_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n+parser_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n+parser_expected_semi_found_str = expected `;`, found `{$token}`\n+\n+parser_sugg_change_this_to_semi = change this to `;`\n+parser_sugg_add_semi = add `;` here\n+parser_label_unexpected_token = unexpected token\n+\n+parser_unmatched_angle_brackets = {$num_extra_brackets ->\n+        [one] unmatched angle bracket\n+       *[other] unmatched angle brackets\n+    }\n+    .suggestion = {$num_extra_brackets ->\n+            [one] remove extra angle bracket\n+           *[other] remove extra angle brackets\n+        }\n+\n+parser_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n+    .suggestion = surround the type parameters with angle brackets\n+\n+parser_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n+    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n+    .sugg_split_comparison = split the comparison into two\n+    .sugg_parenthesize = parenthesize the comparison\n+parser_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n+\n+parser_question_mark_in_type = invalid `?` in type\n+    .label = `?` is only allowed on expressions, not types\n+    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n+\n+parser_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n+    .suggestion = remove parentheses in `for` loop\n+\n+parser_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n+    .label = doc comments are not allowed here\n+\n+parser_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n+    .label = attributes are not allowed here\n+\n+parser_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n+    .suggestion = give this argument a name or use an underscore to ignore it\n+\n+parser_self_param_not_first = unexpected `self` parameter in function\n+    .label = must be the first parameter of an associated function\n+\n+parser_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n+    .suggestion = enclose the `const` expression in braces\n+\n+parser_unexpected_const_param_declaration = unexpected `const` parameter declaration\n+    .label = expected a `const` expression, not a parameter declaration\n+    .suggestion = `const` parameters must be declared for the `impl`\n+\n+parser_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n+    .suggestion = the `const` keyword is only needed in the definition of the type\n+\n+parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n+    .suggestion = try switching the order\n+\n+parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n+    .suggestion = use single colon"}, {"sha": "3ea9429a23ab1799641a52afabb8e484f37eb562", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -66,3 +66,5 @@ session_crate_name_invalid = crate names cannot start with a `-`, but `{$s}` has\n session_crate_name_empty = crate name must not be empty\n \n session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`\n+\n+session_expr_parentheses_needed = parentheses are required to parse this as an expression"}, {"sha": "1eb9dca2a2b915ca70e8222767c28e99164d0db6", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -8,6 +8,8 @@ doctest = false\n \n [dependencies]\n tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_error_messages = { path = \"../rustc_error_messages\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "5520e22e4767c720b8b3eb63dd28d2e2b7ac87fb", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -3,6 +3,8 @@ use crate::{\n     CodeSuggestion, DiagnosticMessage, EmissionGuarantee, Level, LintDiagnosticBuilder, MultiSpan,\n     SubdiagnosticMessage, Substitution, SubstitutionPart, SuggestionStyle,\n };\n+use rustc_ast as ast;\n+use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_error_messages::FluentValue;\n use rustc_hir as hir;\n@@ -175,6 +177,24 @@ impl IntoDiagnosticArg for hir::ConstContext {\n     }\n }\n \n+impl IntoDiagnosticArg for ast::Path {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(pprust::path_to_string(&self)))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for ast::token::Token {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(pprust::token_to_string(&self))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for ast::token::TokenKind {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(pprust::token_kind_to_string(&self))\n+    }\n+}\n+\n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(Subdiagnostic)]` -- see [rustc_macros::Subdiagnostic].\n #[cfg_attr(bootstrap, rustc_diagnostic_item = \"AddSubdiagnostic\")]"}, {"sha": "9e88dc7a913a2c5c5707ae0ee1dd88eec9894ffe", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -281,6 +281,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         if should_generate_set_arg(&field) {\n             let diag = &self.parent.diag;\n             let ident = field.ident.as_ref().unwrap();\n+            // strip `r#` prefix, if present\n+            let ident = format_ident!(\"{}\", ident);\n             return quote! {\n                 #diag.set_arg(\n                     stringify!(#ident),"}, {"sha": "9a2588513f06da099e310e042f9d2920670d431b", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -189,6 +189,9 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n \n         let diag = &self.diag;\n         let ident = ast.ident.as_ref().unwrap();\n+        // strip `r#` prefix, if present\n+        let ident = format_ident!(\"{}\", ident);\n+\n         quote! {\n             #diag.set_arg(\n                 stringify!(#ident),"}, {"sha": "98fee997427270d42f2f4459c55bb6c6440e7b21", "filename": "compiler/rustc_parse/src/errors.rs", "status": "added", "additions": 1251, "deletions": 0, "changes": 1251, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -0,0 +1,1251 @@\n+use rustc_ast::token::Token;\n+use rustc_ast::Path;\n+use rustc_errors::{fluent, AddToDiagnostic, Applicability, EmissionGuarantee, IntoDiagnostic};\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_session::errors::ExprParenthesesNeeded;\n+use rustc_span::symbol::Ident;\n+use rustc_span::{Span, Symbol};\n+\n+use crate::parser::TokenDescription;\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::maybe_report_ambiguous_plus)]\n+pub(crate) struct AmbiguousPlus {\n+    pub sum_ty: String,\n+    #[primary_span]\n+    #[suggestion(code = \"({sum_ty})\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n+pub(crate) struct BadTypePlus {\n+    pub ty: String,\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: BadTypePlusSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum BadTypePlusSub {\n+    #[suggestion(\n+        parser::add_paren,\n+        code = \"{sum_with_parens}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    AddParen {\n+        sum_with_parens: String,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(parser::forgot_paren)]\n+    ForgotParen {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(parser::expect_path)]\n+    ExpectPath {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::maybe_recover_from_bad_qpath_stage_2)]\n+pub(crate) struct BadQPathStage2 {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub ty: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_semicolon)]\n+pub(crate) struct IncorrectSemicolon<'a> {\n+    #[primary_span]\n+    #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[help]\n+    pub opt_help: Option<()>,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_use_of_await)]\n+pub(crate) struct IncorrectUseOfAwait {\n+    #[primary_span]\n+    #[suggestion(parser::parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_use_of_await)]\n+pub(crate) struct IncorrectAwait {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n+    pub sugg_span: (Span, Applicability),\n+    pub expr: String,\n+    pub question_mark: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::in_in_typo)]\n+pub(crate) struct InInTypo {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_variable_declaration)]\n+pub(crate) struct InvalidVariableDeclaration {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidVariableDeclarationSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum InvalidVariableDeclarationSub {\n+    #[suggestion(\n+        parser::switch_mut_let_order,\n+        applicability = \"maybe-incorrect\",\n+        code = \"let mut\"\n+    )]\n+    SwitchMutLetOrder(#[primary_span] Span),\n+    #[suggestion(\n+        parser::missing_let_before_mut,\n+        applicability = \"machine-applicable\",\n+        code = \"let mut\"\n+    )]\n+    MissingLet(#[primary_span] Span),\n+    #[suggestion(parser::use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n+    UseLetNotAuto(#[primary_span] Span),\n+    #[suggestion(parser::use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n+    UseLetNotVar(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_comparison_operator)]\n+pub(crate) struct InvalidComparisonOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub invalid: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidComparisonOperatorSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum InvalidComparisonOperatorSub {\n+    #[suggestion_short(\n+        parser::use_instead,\n+        applicability = \"machine-applicable\",\n+        code = \"{correct}\"\n+    )]\n+    Correctable {\n+        #[primary_span]\n+        span: Span,\n+        invalid: String,\n+        correct: String,\n+    },\n+    #[label(parser::spaceship_operator_invalid)]\n+    Spaceship(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_logical_operator)]\n+#[note]\n+pub(crate) struct InvalidLogicalOperator {\n+    #[primary_span]\n+    pub span: Span,\n+    pub incorrect: String,\n+    #[subdiagnostic]\n+    pub sub: InvalidLogicalOperatorSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum InvalidLogicalOperatorSub {\n+    #[suggestion_short(\n+        parser::use_amp_amp_for_conjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"&&\"\n+    )]\n+    Conjunction(#[primary_span] Span),\n+    #[suggestion_short(\n+        parser::use_pipe_pipe_for_disjunction,\n+        applicability = \"machine-applicable\",\n+        code = \"||\"\n+    )]\n+    Disjunction(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::tilde_is_not_unary_operator)]\n+pub(crate) struct TildeAsUnaryOperator(\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n+    pub Span,\n+);\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_token_after_not)]\n+pub(crate) struct NotAsNegationOperator {\n+    #[primary_span]\n+    pub negated: Span,\n+    pub negated_desc: String,\n+    #[subdiagnostic]\n+    pub sub: NotAsNegationOperatorSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NotAsNegationOperatorSub {\n+    #[suggestion_short(\n+        parser::unexpected_token_after_not_default,\n+        applicability = \"machine-applicable\",\n+        code = \"!\"\n+    )]\n+    SuggestNotDefault(#[primary_span] Span),\n+\n+    #[suggestion_short(\n+        parser::unexpected_token_after_not_bitwise,\n+        applicability = \"machine-applicable\",\n+        code = \"!\"\n+    )]\n+    SuggestNotBitwise(#[primary_span] Span),\n+\n+    #[suggestion_short(\n+        parser::unexpected_token_after_not_logical,\n+        applicability = \"machine-applicable\",\n+        code = \"!\"\n+    )]\n+    SuggestNotLogical(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::malformed_loop_label)]\n+pub(crate) struct MalformedLoopLabel {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n+    pub span: Span,\n+    pub correct_label: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::lifetime_in_borrow_expression)]\n+pub(crate) struct LifetimeInBorrowExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    #[label]\n+    pub lifetime_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::field_expression_with_generic)]\n+pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::macro_invocation_with_qualified_path)]\n+pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_token_after_label)]\n+pub(crate) struct UnexpectedTokenAfterLabel {\n+    #[primary_span]\n+    #[label(parser::unexpected_token_after_label)]\n+    pub span: Span,\n+    #[suggestion_verbose(parser::suggestion_remove_label, code = \"\")]\n+    pub remove_label: Option<Span>,\n+    #[subdiagnostic]\n+    pub enclose_in_block: Option<UnexpectedTokenAfterLabelSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n+pub(crate) struct UnexpectedTokenAfterLabelSugg {\n+    #[suggestion_part(code = \"{{ \")]\n+    pub left: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::require_colon_after_labeled_expression)]\n+#[note]\n+pub(crate) struct RequireColonAfterLabeledExpression {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub label: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \": \")]\n+    pub label_end: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::do_catch_syntax_removed)]\n+#[note]\n+pub(crate) struct DoCatchSyntaxRemoved {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"try\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::float_literal_requires_integer_part)]\n+pub(crate) struct FloatLiteralRequiresIntegerPart {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n+    pub span: Span,\n+    pub correct: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_int_literal_width)]\n+#[help]\n+pub(crate) struct InvalidIntLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_num_literal_base_prefix)]\n+#[note]\n+pub(crate) struct InvalidNumLiteralBasePrefix {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n+    pub span: Span,\n+    pub fixed: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_num_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidNumLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_float_literal_width)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralWidth {\n+    #[primary_span]\n+    pub span: Span,\n+    pub width: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_float_literal_suffix)]\n+#[help]\n+pub(crate) struct InvalidFloatLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::int_literal_too_large)]\n+pub(crate) struct IntLiteralTooLarge {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::missing_semicolon_before_array)]\n+pub(crate) struct MissingSemicolonBeforeArray {\n+    #[primary_span]\n+    pub open_delim: Span,\n+    #[suggestion_verbose(applicability = \"maybe-incorrect\", code = \";\")]\n+    pub semicolon: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_block_macro_segment)]\n+pub(crate) struct InvalidBlockMacroSegment {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub context: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::if_expression_missing_then_block)]\n+pub(crate) struct IfExpressionMissingThenBlock {\n+    #[primary_span]\n+    pub if_span: Span,\n+    #[subdiagnostic]\n+    pub sub: IfExpressionMissingThenBlockSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum IfExpressionMissingThenBlockSub {\n+    #[help(parser::condition_possibly_unfinished)]\n+    UnfinishedCondition(#[primary_span] Span),\n+    #[help(parser::add_then_block)]\n+    AddThenBlock(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::if_expression_missing_condition)]\n+pub(crate) struct IfExpressionMissingCondition {\n+    #[primary_span]\n+    #[label(parser::condition_label)]\n+    pub if_span: Span,\n+    #[label(parser::block_label)]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::expected_expression_found_let)]\n+pub(crate) struct ExpectedExpressionFoundLet {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::expected_else_block)]\n+pub(crate) struct ExpectedElseBlock {\n+    #[primary_span]\n+    pub first_tok_span: Span,\n+    pub first_tok: String,\n+    #[label]\n+    pub else_span: Span,\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"if \")]\n+    pub condition_start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n+pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n+    #[primary_span]\n+    pub last: Span,\n+\n+    #[label(parser::branch_label)]\n+    pub branch_span: Span,\n+\n+    #[label(parser::ctx_label)]\n+    pub ctx_span: Span,\n+    pub ctx: String,\n+\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    pub attributes: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::missing_in_in_for_loop)]\n+pub(crate) struct MissingInInForLoop {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: MissingInInForLoopSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum MissingInInForLoopSub {\n+    // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n+    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n+    InNotOf(#[primary_span] Span),\n+    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n+    AddIn(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::missing_comma_after_match_arm)]\n+pub(crate) struct MissingCommaAfterMatchArm {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::catch_after_try)]\n+#[help]\n+pub(crate) struct CatchAfterTry {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::comma_after_base_struct)]\n+#[note]\n+pub(crate) struct CommaAfterBaseStruct {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    pub comma: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::eq_field_init)]\n+pub(crate) struct EqFieldInit {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\", code = \":\")]\n+    pub eq: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::dotdotdot)]\n+pub(crate) struct DotDotDot {\n+    #[primary_span]\n+    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n+    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::left_arrow_operator)]\n+pub(crate) struct LeftArrowOperator {\n+    #[primary_span]\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::remove_let)]\n+pub(crate) struct RemoveLet {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::use_eq_instead)]\n+pub(crate) struct UseEqInstead {\n+    #[primary_span]\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::use_empty_block_not_semi)]\n+pub(crate) struct UseEmptyBlockNotSemi {\n+    #[primary_span]\n+    #[suggestion_hidden(applicability = \"machine-applicable\", code = \"{{}}\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::comparison_interpreted_as_generic)]\n+pub(crate) struct ComparisonInterpretedAsGeneric {\n+    #[primary_span]\n+    #[label(parser::label_comparison)]\n+    pub comparison: Span,\n+    pub r#type: Path,\n+    #[label(parser::label_args)]\n+    pub args: Span,\n+    #[subdiagnostic]\n+    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::shift_interpreted_as_generic)]\n+pub(crate) struct ShiftInterpretedAsGeneric {\n+    #[primary_span]\n+    #[label(parser::label_comparison)]\n+    pub shift: Span,\n+    pub r#type: Path,\n+    #[label(parser::label_args)]\n+    pub args: Span,\n+    #[subdiagnostic]\n+    pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::found_expr_would_be_stmt)]\n+pub(crate) struct FoundExprWouldBeStmt {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub token: Token,\n+    #[subdiagnostic]\n+    pub suggestion: ExprParenthesesNeeded,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::leading_plus_not_supported)]\n+pub(crate) struct LeadingPlusNotSupported {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[suggestion_verbose(\n+        parser::suggestion_remove_plus,\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    pub remove_plus: Option<Span>,\n+    #[subdiagnostic]\n+    pub add_parentheses: Option<ExprParenthesesNeeded>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::parentheses_with_struct_fields)]\n+pub(crate) struct ParenthesesWithStructFields {\n+    #[primary_span]\n+    pub span: Span,\n+    pub r#type: Path,\n+    #[subdiagnostic]\n+    pub braces_for_struct: BracesForStructLiteral,\n+    #[subdiagnostic]\n+    pub no_fields_for_fn: NoFieldsForFnCall,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n+pub(crate) struct BracesForStructLiteral {\n+    #[suggestion_part(code = \" {{ \")]\n+    pub first: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub second: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n+pub(crate) struct NoFieldsForFnCall {\n+    #[suggestion_part(code = \"\")]\n+    pub fields: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::labeled_loop_in_break)]\n+pub(crate) struct LabeledLoopInBreak {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: WrapExpressionInParentheses,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    parser::sugg_wrap_expression_in_parentheses,\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct WrapExpressionInParentheses {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::array_brackets_instead_of_braces)]\n+pub(crate) struct ArrayBracketsInsteadOfSpaces {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: ArrayBracketsInsteadOfSpacesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"maybe-incorrect\")]\n+pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n+    #[suggestion_part(code = \"[\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \"]\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::match_arm_body_without_braces)]\n+pub(crate) struct MatchArmBodyWithoutBraces {\n+    #[primary_span]\n+    #[label(parser::label_statements)]\n+    pub statements: Span,\n+    #[label(parser::label_arrow)]\n+    pub arrow: Span,\n+    pub num_statements: usize,\n+    #[subdiagnostic]\n+    pub sub: MatchArmBodyWithoutBracesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum MatchArmBodyWithoutBracesSugg {\n+    #[multipart_suggestion(parser::suggestion_add_braces, applicability = \"machine-applicable\")]\n+    AddBraces {\n+        #[suggestion_part(code = \"{{ \")]\n+        left: Span,\n+        #[suggestion_part(code = \" }}\")]\n+        right: Span,\n+    },\n+    #[suggestion(\n+        parser::suggestion_use_comma_not_semicolon,\n+        code = \",\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    UseComma {\n+        #[primary_span]\n+        semicolon: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::struct_literal_not_allowed_here)]\n+pub(crate) struct StructLiteralNotAllowedHere {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: StructLiteralNotAllowedHereSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct StructLiteralNotAllowedHereSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_interpolated_expression)]\n+pub(crate) struct InvalidInterpolatedExpression {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::hexadecimal_float_literal_not_supported)]\n+pub(crate) struct HexadecimalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::octal_float_literal_not_supported)]\n+pub(crate) struct OctalFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::binary_float_literal_not_supported)]\n+pub(crate) struct BinaryFloatLiteralNotSupported {\n+    #[primary_span]\n+    #[label(parser::not_supported)]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_literal_suffix)]\n+pub(crate) struct InvalidLiteralSuffix {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    // FIXME(#100717)\n+    pub kind: String,\n+    pub suffix: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_literal_suffix_on_tuple_index)]\n+pub(crate) struct InvalidLiteralSuffixOnTupleIndex {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub suffix: Symbol,\n+    #[help(parser::tuple_exception_line_1)]\n+    #[help(parser::tuple_exception_line_2)]\n+    #[help(parser::tuple_exception_line_3)]\n+    pub exception: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::non_string_abi_literal)]\n+pub(crate) struct NonStringAbiLiteral {\n+    #[primary_span]\n+    #[suggestion(code = \"\\\"C\\\"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::mismatched_closing_delimiter)]\n+pub(crate) struct MismatchedClosingDelimiter {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub delimiter: String,\n+    #[label(parser::label_unmatched)]\n+    pub unmatched: Span,\n+    #[label(parser::label_opening_candidate)]\n+    pub opening_candidate: Option<Span>,\n+    #[label(parser::label_unclosed)]\n+    pub unclosed: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::incorrect_visibility_restriction, code = \"E0704\")]\n+#[help]\n+pub(crate) struct IncorrectVisibilityRestriction {\n+    #[primary_span]\n+    #[suggestion(code = \"in {inner_str}\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub inner_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::assignment_else_not_allowed)]\n+pub(crate) struct AssignmentElseNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::expected_statement_after_outer_attr)]\n+pub(crate) struct ExpectedStatementAfterOuterAttr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::doc_comment_does_not_document_anything, code = \"E0585\")]\n+#[help]\n+pub(crate) struct DocCommentDoesNotDocumentAnything {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \",\", applicability = \"machine-applicable\")]\n+    pub missing_comma: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::const_let_mutually_exclusive)]\n+pub(crate) struct ConstLetMutuallyExclusive {\n+    #[primary_span]\n+    #[suggestion(code = \"const\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_expression_in_let_else)]\n+pub(crate) struct InvalidExpressionInLetElse {\n+    #[primary_span]\n+    pub span: Span,\n+    pub operator: &'static str,\n+    #[subdiagnostic]\n+    pub sugg: WrapExpressionInParentheses,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_curly_in_let_else)]\n+pub(crate) struct InvalidCurlyInLetElse {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: WrapExpressionInParentheses,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::compound_assignment_expression_in_let)]\n+#[help]\n+pub(crate) struct CompoundAssignmentExpressionInLet {\n+    #[primary_span]\n+    #[suggestion_short(code = \"=\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::suffixed_literal_in_attribute)]\n+#[help]\n+pub(crate) struct SuffixedLiteralInAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::invalid_meta_item)]\n+pub(crate) struct InvalidMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub token: Token,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion_verbose(\n+    parser::sugg_escape_to_use_as_identifier,\n+    applicability = \"maybe-incorrect\",\n+    code = \"r#\"\n+)]\n+pub(crate) struct SuggEscapeToUseAsIdentifier {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident_name: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(parser::sugg_remove_comma, applicability = \"machine-applicable\", code = \"\")]\n+pub(crate) struct SuggRemoveComma {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ExpectedIdentifierFound {\n+    #[label(parser::expected_identifier_found_reserved_identifier)]\n+    ReservedIdentifier(#[primary_span] Span),\n+    #[label(parser::expected_identifier_found_keyword)]\n+    Keyword(#[primary_span] Span),\n+    #[label(parser::expected_identifier_found_reserved_keyword)]\n+    ReservedKeyword(#[primary_span] Span),\n+    #[label(parser::expected_identifier_found_doc_comment)]\n+    DocComment(#[primary_span] Span),\n+    #[label(parser::expected_identifier)]\n+    Other(#[primary_span] Span),\n+}\n+\n+impl ExpectedIdentifierFound {\n+    pub fn new(token_descr: Option<TokenDescription>, span: Span) -> Self {\n+        (match token_descr {\n+            Some(TokenDescription::ReservedIdentifier) => {\n+                ExpectedIdentifierFound::ReservedIdentifier\n+            }\n+            Some(TokenDescription::Keyword) => ExpectedIdentifierFound::Keyword,\n+            Some(TokenDescription::ReservedKeyword) => ExpectedIdentifierFound::ReservedKeyword,\n+            Some(TokenDescription::DocComment) => ExpectedIdentifierFound::DocComment,\n+            None => ExpectedIdentifierFound::Other,\n+        })(span)\n+    }\n+}\n+\n+pub(crate) struct ExpectedIdentifier {\n+    pub span: Span,\n+    pub token: Token,\n+    pub suggest_raw: Option<SuggEscapeToUseAsIdentifier>,\n+    pub suggest_remove_comma: Option<SuggRemoveComma>,\n+}\n+\n+impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, G> {\n+        let token_descr = super::parser::TokenDescription::from_token(&self.token);\n+\n+        let mut diag = handler.struct_diagnostic(match token_descr {\n+            Some(TokenDescription::ReservedIdentifier) => {\n+                fluent::parser::expected_identifier_found_reserved_identifier_str\n+            }\n+            Some(TokenDescription::Keyword) => {\n+                fluent::parser::expected_identifier_found_keyword_str\n+            }\n+            Some(TokenDescription::ReservedKeyword) => {\n+                fluent::parser::expected_identifier_found_reserved_keyword_str\n+            }\n+            Some(TokenDescription::DocComment) => {\n+                fluent::parser::expected_identifier_found_doc_comment_str\n+            }\n+            None => fluent::parser::expected_identifier_found_str,\n+        });\n+        diag.set_span(self.span);\n+        diag.set_arg(\"token\", self.token);\n+\n+        if let Some(sugg) = self.suggest_raw {\n+            sugg.add_to_diagnostic(&mut diag);\n+        }\n+\n+        ExpectedIdentifierFound::new(token_descr, self.span).add_to_diagnostic(&mut diag);\n+\n+        if let Some(sugg) = self.suggest_remove_comma {\n+            sugg.add_to_diagnostic(&mut diag);\n+        }\n+\n+        diag\n+    }\n+}\n+\n+pub(crate) struct ExpectedSemi {\n+    pub span: Span,\n+    pub token: Token,\n+\n+    pub unexpected_token_label: Option<Span>,\n+    pub sugg: ExpectedSemiSugg,\n+}\n+\n+impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, G> {\n+        let token_descr = super::parser::TokenDescription::from_token(&self.token);\n+\n+        let mut diag = handler.struct_diagnostic(match token_descr {\n+            Some(TokenDescription::ReservedIdentifier) => {\n+                fluent::parser::expected_semi_found_reserved_identifier_str\n+            }\n+            Some(TokenDescription::Keyword) => fluent::parser::expected_semi_found_keyword_str,\n+            Some(TokenDescription::ReservedKeyword) => {\n+                fluent::parser::expected_semi_found_reserved_keyword_str\n+            }\n+            Some(TokenDescription::DocComment) => {\n+                fluent::parser::expected_semi_found_doc_comment_str\n+            }\n+            None => fluent::parser::expected_semi_found_str,\n+        });\n+        diag.set_span(self.span);\n+        diag.set_arg(\"token\", self.token);\n+\n+        if let Some(unexpected_token_label) = self.unexpected_token_label {\n+            diag.span_label(unexpected_token_label, fluent::parser::label_unexpected_token);\n+        }\n+\n+        self.sugg.add_to_diagnostic(&mut diag);\n+\n+        diag\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ExpectedSemiSugg {\n+    #[suggestion(\n+        parser::sugg_change_this_to_semi,\n+        code = \";\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    ChangeToSemi(#[primary_span] Span),\n+    #[suggestion_short(parser::sugg_add_semi, code = \";\", applicability = \"machine-applicable\")]\n+    AddSemi(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::struct_literal_body_without_path)]\n+pub(crate) struct StructLiteralBodyWithoutPath {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: StructLiteralBodyWithoutPathSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"has-placeholders\")]\n+pub(crate) struct StructLiteralBodyWithoutPathSugg {\n+    #[suggestion_part(code = \"{{ SomeStruct \")]\n+    pub before: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub after: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unmatched_angle_brackets)]\n+pub(crate) struct UnmatchedAngleBrackets {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub num_extra_brackets: usize,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::generic_parameters_without_angle_brackets)]\n+pub(crate) struct GenericParamsWithoutAngleBrackets {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: GenericParamsWithoutAngleBracketsSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n+    #[suggestion_part(code = \"<\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \">\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::comparison_operators_cannot_be_chained)]\n+pub(crate) struct ComparisonOperatorsCannotBeChained {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+    #[suggestion_verbose(\n+        parser::sugg_turbofish_syntax,\n+        code = \"::\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub suggest_turbofish: Option<Span>,\n+    #[help(parser::sugg_turbofish_syntax)]\n+    #[help(parser::sugg_parentheses_for_function_args)]\n+    pub help_turbofish: Option<()>,\n+    #[subdiagnostic]\n+    pub chaining_sugg: Option<ComparisonOperatorsCannotBeChainedSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n+    #[suggestion_verbose(\n+        parser::sugg_split_comparison,\n+        code = \" && {middle_term}\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    SplitComparison {\n+        #[primary_span]\n+        span: Span,\n+        middle_term: String,\n+    },\n+    #[multipart_suggestion(parser::sugg_parenthesize, applicability = \"maybe-incorrect\")]\n+    Parenthesize {\n+        #[suggestion_part(code = \"(\")]\n+        left: Span,\n+        #[suggestion_part(code = \")\")]\n+        right: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::question_mark_in_type)]\n+pub(crate) struct QuestionMarkInType {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: QuestionMarkInTypeSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct QuestionMarkInTypeSugg {\n+    #[suggestion_part(code = \"Option<\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \">\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_parentheses_in_for_head)]\n+pub(crate) struct ParenthesesInForHead {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+    #[subdiagnostic]\n+    pub sugg: ParenthesesInForHeadSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ParenthesesInForHeadSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \"\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::doc_comment_on_param_type)]\n+pub(crate) struct DocCommentOnParamType {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::attribute_on_param_type)]\n+pub(crate) struct AttributeOnParamType {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::pattern_method_param_without_body, code = \"E0642\")]\n+pub(crate) struct PatternMethodParamWithoutBody {\n+    #[primary_span]\n+    #[suggestion(code = \"_\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::self_param_not_first)]\n+pub(crate) struct SelfParamNotFirst {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::const_generic_without_braces)]\n+pub(crate) struct ConstGenericWithoutBraces {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: ConstGenericWithoutBracesSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct ConstGenericWithoutBracesSugg {\n+    #[suggestion_part(code = \"{{ \")]\n+    pub left: Span,\n+    #[suggestion_part(code = \" }}\")]\n+    pub right: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_const_param_declaration)]\n+pub(crate) struct UnexpectedConstParamDeclaration {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: Option<UnexpectedConstParamDeclarationSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum UnexpectedConstParamDeclarationSugg {\n+    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    AddParam {\n+        #[suggestion_part(code = \"<{snippet}>\")]\n+        impl_generics: Span,\n+        #[suggestion_part(code = \"{ident}\")]\n+        incorrect_decl: Span,\n+        snippet: String,\n+        ident: String,\n+    },\n+    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    AppendParam {\n+        #[suggestion_part(code = \", {snippet}\")]\n+        impl_generics_end: Span,\n+        #[suggestion_part(code = \"{ident}\")]\n+        incorrect_decl: Span,\n+        snippet: String,\n+        ident: String,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::unexpected_const_in_generic_param)]\n+pub(crate) struct UnexpectedConstInGenericParam {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion_verbose(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub to_remove: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::async_move_order_incorrect)]\n+pub(crate) struct AsyncMoveOrderIncorrect {\n+    #[primary_span]\n+    #[suggestion_verbose(code = \"async move\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parser::double_colon_in_bound)]\n+pub(crate) struct DoubleColonInBound {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \": \", applicability = \"machine-applicable\")]\n+    pub between: Span,\n+}"}, {"sha": "0bdfe10359c0bea9d36b670aaf77f022c9bd89cc", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -32,6 +32,8 @@ use parser::{emit_unclosed_delims, make_unclosed_delims_error, Parser};\n pub mod lexer;\n pub mod validate_attr;\n \n+mod errors;\n+\n // A bunch of utility functions of the form `parse_<thing>_from_<source>`\n // where <thing> includes crate, expr, item, stmt, tts, and one that\n // uses a HOF to parse anything, and <source> includes file and"}, {"sha": "58be348883c0c765a89982ca871c57fbce731ad2", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 68, "deletions": 91, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -1,27 +1,26 @@\n+use crate::errors::{InvalidMetaItem, SuffixedLiteralInAttribute};\n+\n use super::{AttrWrapper, Capturing, FnParseMode, ForceCollect, Parser, PathStyle};\n use rustc_ast as ast;\n use rustc_ast::attr;\n use rustc_ast::token::{self, Delimiter, Nonterminal};\n-use rustc_ast_pretty::pprust;\n-use rustc_errors::{error_code, Diagnostic, PResult};\n+use rustc_errors::{error_code, fluent, Diagnostic, IntoDiagnostic, PResult};\n use rustc_span::{sym, BytePos, Span};\n use std::convert::TryInto;\n \n // Public for rustfmt usage\n #[derive(Debug)]\n-pub enum InnerAttrPolicy<'a> {\n+pub enum InnerAttrPolicy {\n     Permitted,\n-    Forbidden { reason: &'a str, saw_doc_comment: bool, prev_outer_attr_sp: Option<Span> },\n+    Forbidden(Option<InnerAttrForbiddenReason>),\n }\n \n-const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n-                                                     permitted in this context\";\n-\n-pub(super) const DEFAULT_INNER_ATTR_FORBIDDEN: InnerAttrPolicy<'_> = InnerAttrPolicy::Forbidden {\n-    reason: DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG,\n-    saw_doc_comment: false,\n-    prev_outer_attr_sp: None,\n-};\n+#[derive(Clone, Copy, Debug)]\n+pub enum InnerAttrForbiddenReason {\n+    InCodeBlock,\n+    AfterOuterDocComment { prev_doc_comment_span: Span },\n+    AfterOuterAttribute { prev_outer_attr_sp: Span },\n+}\n \n enum OuterAttributeType {\n     DocComment,\n@@ -40,25 +39,23 @@ impl<'a> Parser<'a> {\n                 let prev_outer_attr_sp = outer_attrs.last().map(|attr| attr.span);\n \n                 let inner_error_reason = if just_parsed_doc_comment {\n-                    \"an inner attribute is not permitted following an outer doc comment\"\n-                } else if prev_outer_attr_sp.is_some() {\n-                    \"an inner attribute is not permitted following an outer attribute\"\n+                    Some(InnerAttrForbiddenReason::AfterOuterDocComment {\n+                        prev_doc_comment_span: prev_outer_attr_sp.unwrap(),\n+                    })\n+                } else if let Some(prev_outer_attr_sp) = prev_outer_attr_sp {\n+                    Some(InnerAttrForbiddenReason::AfterOuterAttribute { prev_outer_attr_sp })\n                 } else {\n-                    DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n-                };\n-                let inner_parse_policy = InnerAttrPolicy::Forbidden {\n-                    reason: inner_error_reason,\n-                    saw_doc_comment: just_parsed_doc_comment,\n-                    prev_outer_attr_sp,\n+                    None\n                 };\n+                let inner_parse_policy = InnerAttrPolicy::Forbidden(inner_error_reason);\n                 just_parsed_doc_comment = false;\n                 Some(self.parse_attribute(inner_parse_policy)?)\n             } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n                 if attr_style != ast::AttrStyle::Outer {\n                     let span = self.token.span;\n                     let mut err = self.sess.span_diagnostic.struct_span_err_with_code(\n                         span,\n-                        \"expected outer doc comment\",\n+                        fluent::parser::inner_doc_comment_not_permitted,\n                         error_code!(E0753),\n                     );\n                     if let Some(replacement_span) = self.annotate_following_item_if_applicable(\n@@ -69,13 +66,10 @@ impl<'a> Parser<'a> {\n                             token::CommentKind::Block => OuterAttributeType::DocBlockComment,\n                         },\n                     ) {\n-                        err.note(\n-                            \"inner doc comments like this (starting with `//!` or `/*!`) can \\\n-                            only appear before items\",\n-                        );\n+                        err.note(fluent::parser::note);\n                         err.span_suggestion_verbose(\n                             replacement_span,\n-                            \"you might have meant to write a regular comment\",\n+                            fluent::parser::suggestion,\n                             \"\",\n                             rustc_errors::Applicability::MachineApplicable,\n                         );\n@@ -113,7 +107,7 @@ impl<'a> Parser<'a> {\n     // Public for rustfmt usage.\n     pub fn parse_attribute(\n         &mut self,\n-        inner_parse_policy: InnerAttrPolicy<'_>,\n+        inner_parse_policy: InnerAttrPolicy,\n     ) -> PResult<'a, ast::Attribute> {\n         debug!(\n             \"parse_attribute: inner_parse_policy={:?} self.token={:?}\",\n@@ -122,35 +116,22 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         // Attributes can't have attributes of their own [Editor's note: not with that attitude]\n         self.collect_tokens_no_attrs(|this| {\n-            if this.eat(&token::Pound) {\n-                let style = if this.eat(&token::Not) {\n-                    ast::AttrStyle::Inner\n-                } else {\n-                    ast::AttrStyle::Outer\n-                };\n+            assert!(this.eat(&token::Pound), \"parse_attribute called in non-attribute position\");\n \n-                this.expect(&token::OpenDelim(Delimiter::Bracket))?;\n-                let item = this.parse_attr_item(false)?;\n-                this.expect(&token::CloseDelim(Delimiter::Bracket))?;\n-                let attr_sp = lo.to(this.prev_token.span);\n+            let style =\n+                if this.eat(&token::Not) { ast::AttrStyle::Inner } else { ast::AttrStyle::Outer };\n \n-                // Emit error if inner attribute is encountered and forbidden.\n-                if style == ast::AttrStyle::Inner {\n-                    this.error_on_forbidden_inner_attr(attr_sp, inner_parse_policy);\n-                }\n+            this.expect(&token::OpenDelim(Delimiter::Bracket))?;\n+            let item = this.parse_attr_item(false)?;\n+            this.expect(&token::CloseDelim(Delimiter::Bracket))?;\n+            let attr_sp = lo.to(this.prev_token.span);\n \n-                Ok(attr::mk_attr_from_item(\n-                    &self.sess.attr_id_generator,\n-                    item,\n-                    None,\n-                    style,\n-                    attr_sp,\n-                ))\n-            } else {\n-                let token_str = pprust::token_to_string(&this.token);\n-                let msg = &format!(\"expected `#`, found `{token_str}`\");\n-                Err(this.struct_span_err(this.token.span, msg))\n+            // Emit error if inner attribute is encountered and forbidden.\n+            if style == ast::AttrStyle::Inner {\n+                this.error_on_forbidden_inner_attr(attr_sp, inner_parse_policy);\n             }\n+\n+            Ok(attr::mk_attr_from_item(&self.sess.attr_id_generator, item, None, style, attr_sp))\n         })\n     }\n \n@@ -190,21 +171,12 @@ impl<'a> Parser<'a> {\n             ForceCollect::No,\n         ) {\n             Ok(Some(item)) => {\n-                let attr_name = match attr_type {\n-                    OuterAttributeType::Attribute => \"attribute\",\n-                    _ => \"doc comment\",\n-                };\n-                err.span_label(\n-                    item.span,\n-                    &format!(\"the inner {} doesn't annotate this {}\", attr_name, item.kind.descr()),\n-                );\n+                // FIXME(#100717)\n+                err.set_arg(\"item\", item.kind.descr());\n+                err.span_label(item.span, fluent::parser::label_does_not_annotate_this);\n                 err.span_suggestion_verbose(\n                     replacement_span,\n-                    &format!(\n-                        \"to annotate the {}, change the {} from inner to outer style\",\n-                        item.kind.descr(),\n-                        attr_name\n-                    ),\n+                    fluent::parser::sugg_change_inner_to_outer,\n                     match attr_type {\n                         OuterAttributeType::Attribute => \"\",\n                         OuterAttributeType::DocBlockComment => \"*\",\n@@ -222,22 +194,33 @@ impl<'a> Parser<'a> {\n         Some(replacement_span)\n     }\n \n-    pub(super) fn error_on_forbidden_inner_attr(&self, attr_sp: Span, policy: InnerAttrPolicy<'_>) {\n-        if let InnerAttrPolicy::Forbidden { reason, saw_doc_comment, prev_outer_attr_sp } = policy {\n-            let prev_outer_attr_note =\n-                if saw_doc_comment { \"previous doc comment\" } else { \"previous outer attribute\" };\n-\n-            let mut diag = self.struct_span_err(attr_sp, reason);\n-\n-            if let Some(prev_outer_attr_sp) = prev_outer_attr_sp {\n-                diag.span_label(attr_sp, \"not permitted following an outer attribute\")\n-                    .span_label(prev_outer_attr_sp, prev_outer_attr_note);\n-            }\n+    pub(super) fn error_on_forbidden_inner_attr(&self, attr_sp: Span, policy: InnerAttrPolicy) {\n+        if let InnerAttrPolicy::Forbidden(reason) = policy {\n+            let mut diag = match reason.as_ref().copied() {\n+                Some(InnerAttrForbiddenReason::AfterOuterDocComment { prev_doc_comment_span }) => {\n+                    let mut diag = self.struct_span_err(\n+                        attr_sp,\n+                        fluent::parser::inner_attr_not_permitted_after_outer_doc_comment,\n+                    );\n+                    diag.span_label(attr_sp, fluent::parser::label_attr)\n+                        .span_label(prev_doc_comment_span, fluent::parser::label_prev_doc_comment);\n+                    diag\n+                }\n+                Some(InnerAttrForbiddenReason::AfterOuterAttribute { prev_outer_attr_sp }) => {\n+                    let mut diag = self.struct_span_err(\n+                        attr_sp,\n+                        fluent::parser::inner_attr_not_permitted_after_outer_attr,\n+                    );\n+                    diag.span_label(attr_sp, fluent::parser::label_attr)\n+                        .span_label(prev_outer_attr_sp, fluent::parser::label_prev_attr);\n+                    diag\n+                }\n+                Some(InnerAttrForbiddenReason::InCodeBlock) | None => {\n+                    self.struct_span_err(attr_sp, fluent::parser::inner_attr_not_permitted)\n+                }\n+            };\n \n-            diag.note(\n-                \"inner attributes, like `#![no_std]`, annotate the item enclosing them, and \\\n-                are usually found at the beginning of source files\",\n-            );\n+            diag.note(fluent::parser::inner_attr_explanation);\n             if self\n                 .annotate_following_item_if_applicable(\n                     &mut diag,\n@@ -246,7 +229,7 @@ impl<'a> Parser<'a> {\n                 )\n                 .is_some()\n             {\n-                diag.note(\"outer attributes, like `#[test]`, annotate the item following them\");\n+                diag.note(fluent::parser::outer_attr_explanation);\n             };\n             diag.emit();\n         }\n@@ -337,12 +320,7 @@ impl<'a> Parser<'a> {\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n         if !lit.kind.is_unsuffixed() {\n-            self.struct_span_err(lit.span, \"suffixed literals are not allowed in attributes\")\n-                .help(\n-                    \"instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), \\\n-                    use an unsuffixed version (`1`, `1.0`, etc.)\",\n-                )\n-                .emit();\n+            self.sess.emit_err(SuffixedLiteralInAttribute { span: lit.span });\n         }\n \n         Ok(lit)\n@@ -435,9 +413,8 @@ impl<'a> Parser<'a> {\n             Err(err) => err.cancel(),\n         }\n \n-        let found = pprust::token_to_string(&self.token);\n-        let msg = format!(\"expected unsuffixed literal or identifier, found `{found}`\");\n-        Err(self.struct_span_err(self.token.span, &msg))\n+        Err(InvalidMetaItem { span: self.token.span, token: self.token.clone() }\n+            .into_diagnostic(&self.sess.span_diagnostic))\n     }\n }\n "}, {"sha": "b512f26335f6c9af58aa46ea21791869f00f898f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 158, "deletions": 789, "changes": 947, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -3,6 +3,19 @@ use super::{\n     BlockMode, CommaRecoveryMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep,\n     TokenExpectType, TokenType,\n };\n+use crate::errors::{\n+    AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub,\n+    ComparisonOperatorsCannotBeChained, ComparisonOperatorsCannotBeChainedSugg,\n+    ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentOnParamType,\n+    DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n+    GenericParamsWithoutAngleBrackets, GenericParamsWithoutAngleBracketsSugg, InInTypo,\n+    IncorrectAwait, IncorrectSemicolon, IncorrectUseOfAwait, ParenthesesInForHead,\n+    ParenthesesInForHeadSugg, PatternMethodParamWithoutBody, QuestionMarkInType,\n+    QuestionMarkInTypeSugg, SelfParamNotFirst, StructLiteralBodyWithoutPath,\n+    StructLiteralBodyWithoutPathSugg, SuggEscapeToUseAsIdentifier, SuggRemoveComma,\n+    UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n+    UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n+};\n \n use crate::lexer::UnmatchedBrace;\n use rustc_ast as ast;\n@@ -19,8 +32,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{\n     fluent, Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n };\n-use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed};\n-use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_errors::{pluralize, Diagnostic, ErrorGuaranteed, IntoDiagnostic};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n@@ -30,9 +42,6 @@ use std::mem::take;\n \n use crate::parser;\n \n-const TURBOFISH_SUGGESTION_STR: &str =\n-    \"use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\";\n-\n /// Creates a placeholder argument.\n pub(super) fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n@@ -52,34 +61,6 @@ pub(super) fn dummy_arg(ident: Ident) -> Param {\n     }\n }\n \n-pub enum Error {\n-    UselessDocComment,\n-}\n-\n-impl Error {\n-    fn span_err(\n-        self,\n-        sp: impl Into<MultiSpan>,\n-        handler: &Handler,\n-    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        match self {\n-            Error::UselessDocComment => {\n-                let mut err = struct_span_err!(\n-                    handler,\n-                    sp,\n-                    E0585,\n-                    \"found a documentation comment that doesn't document anything\",\n-                );\n-                err.help(\n-                    \"doc comments must come before what they document, maybe a comment was \\\n-                          intended with `//`?\",\n-                );\n-                err\n-            }\n-        }\n-    }\n-}\n-\n pub(super) trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n     fn to_ty(&self) -> Option<P<Ty>>;\n@@ -242,517 +223,6 @@ impl MultiSugg {\n     }\n }\n \n-#[derive(Diagnostic)]\n-#[diag(parser::maybe_report_ambiguous_plus)]\n-struct AmbiguousPlus {\n-    pub sum_ty: String,\n-    #[primary_span]\n-    #[suggestion(code = \"({sum_ty})\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n-struct BadTypePlus {\n-    pub ty: String,\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: BadTypePlusSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum BadTypePlusSub {\n-    #[suggestion(\n-        parser::add_paren,\n-        code = \"{sum_with_parens}\",\n-        applicability = \"machine-applicable\"\n-    )]\n-    AddParen {\n-        sum_with_parens: String,\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(parser::forgot_paren)]\n-    ForgotParen {\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(parser::expect_path)]\n-    ExpectPath {\n-        #[primary_span]\n-        span: Span,\n-    },\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_qpath_stage_2)]\n-struct BadQPathStage2 {\n-    #[primary_span]\n-    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n-    span: Span,\n-    ty: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::incorrect_semicolon)]\n-struct IncorrectSemicolon<'a> {\n-    #[primary_span]\n-    #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n-    span: Span,\n-    #[help]\n-    opt_help: Option<()>,\n-    name: &'a str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n-struct IncorrectUseOfAwait {\n-    #[primary_span]\n-    #[suggestion(parser::parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n-    span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n-struct IncorrectAwait {\n-    #[primary_span]\n-    span: Span,\n-    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n-    sugg_span: (Span, Applicability),\n-    expr: String,\n-    question_mark: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::in_in_typo)]\n-struct InInTypo {\n-    #[primary_span]\n-    span: Span,\n-    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n-    sugg_span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_variable_declaration)]\n-pub struct InvalidVariableDeclaration {\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: InvalidVariableDeclarationSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum InvalidVariableDeclarationSub {\n-    #[suggestion(\n-        parser::switch_mut_let_order,\n-        applicability = \"maybe-incorrect\",\n-        code = \"let mut\"\n-    )]\n-    SwitchMutLetOrder(#[primary_span] Span),\n-    #[suggestion(\n-        parser::missing_let_before_mut,\n-        applicability = \"machine-applicable\",\n-        code = \"let mut\"\n-    )]\n-    MissingLet(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n-    UseLetNotAuto(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n-    UseLetNotVar(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_comparison_operator)]\n-pub(crate) struct InvalidComparisonOperator {\n-    #[primary_span]\n-    pub span: Span,\n-    pub invalid: String,\n-    #[subdiagnostic]\n-    pub sub: InvalidComparisonOperatorSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum InvalidComparisonOperatorSub {\n-    #[suggestion_short(\n-        parser::use_instead,\n-        applicability = \"machine-applicable\",\n-        code = \"{correct}\"\n-    )]\n-    Correctable {\n-        #[primary_span]\n-        span: Span,\n-        invalid: String,\n-        correct: String,\n-    },\n-    #[label(parser::spaceship_operator_invalid)]\n-    Spaceship(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_logical_operator)]\n-#[note]\n-pub(crate) struct InvalidLogicalOperator {\n-    #[primary_span]\n-    pub span: Span,\n-    pub incorrect: String,\n-    #[subdiagnostic]\n-    pub sub: InvalidLogicalOperatorSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum InvalidLogicalOperatorSub {\n-    #[suggestion_short(\n-        parser::use_amp_amp_for_conjunction,\n-        applicability = \"machine-applicable\",\n-        code = \"&&\"\n-    )]\n-    Conjunction(#[primary_span] Span),\n-    #[suggestion_short(\n-        parser::use_pipe_pipe_for_disjunction,\n-        applicability = \"machine-applicable\",\n-        code = \"||\"\n-    )]\n-    Disjunction(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::tilde_is_not_unary_operator)]\n-pub(crate) struct TildeAsUnaryOperator(\n-    #[primary_span]\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n-    pub Span,\n-);\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_not)]\n-pub(crate) struct NotAsNegationOperator {\n-    #[primary_span]\n-    pub negated: Span,\n-    pub negated_desc: String,\n-    #[subdiagnostic]\n-    pub sub: NotAsNegationOperatorSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum NotAsNegationOperatorSub {\n-    #[suggestion_short(\n-        parser::unexpected_token_after_not_default,\n-        applicability = \"machine-applicable\",\n-        code = \"!\"\n-    )]\n-    SuggestNotDefault(#[primary_span] Span),\n-\n-    #[suggestion_short(\n-        parser::unexpected_token_after_not_bitwise,\n-        applicability = \"machine-applicable\",\n-        code = \"!\"\n-    )]\n-    SuggestNotBitwise(#[primary_span] Span),\n-\n-    #[suggestion_short(\n-        parser::unexpected_token_after_not_logical,\n-        applicability = \"machine-applicable\",\n-        code = \"!\"\n-    )]\n-    SuggestNotLogical(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::malformed_loop_label)]\n-pub(crate) struct MalformedLoopLabel {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n-    pub span: Span,\n-    pub correct_label: Ident,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::lifetime_in_borrow_expression)]\n-pub(crate) struct LifetimeInBorrowExpression {\n-    #[primary_span]\n-    pub span: Span,\n-    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n-    #[label]\n-    pub lifetime_span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::field_expression_with_generic)]\n-pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::macro_invocation_with_qualified_path)]\n-pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_label)]\n-pub(crate) struct UnexpectedTokenAfterLabel(\n-    #[primary_span]\n-    #[label(parser::unexpected_token_after_label)]\n-    pub Span,\n-);\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::require_colon_after_labeled_expression)]\n-#[note]\n-pub(crate) struct RequireColonAfterLabeledExpression {\n-    #[primary_span]\n-    pub span: Span,\n-    #[label]\n-    pub label: Span,\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \": \")]\n-    pub label_end: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::do_catch_syntax_removed)]\n-#[note]\n-pub(crate) struct DoCatchSyntaxRemoved {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"try\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::float_literal_requires_integer_part)]\n-pub(crate) struct FloatLiteralRequiresIntegerPart {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n-    pub span: Span,\n-    pub correct: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_int_literal_width)]\n-#[help]\n-pub(crate) struct InvalidIntLiteralWidth {\n-    #[primary_span]\n-    pub span: Span,\n-    pub width: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_base_prefix)]\n-#[note]\n-pub(crate) struct InvalidNumLiteralBasePrefix {\n-    #[primary_span]\n-    #[suggestion(applicability = \"maybe-incorrect\", code = \"{fixed}\")]\n-    pub span: Span,\n-    pub fixed: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_suffix)]\n-#[help]\n-pub(crate) struct InvalidNumLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub suffix: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_width)]\n-#[help]\n-pub(crate) struct InvalidFloatLiteralWidth {\n-    #[primary_span]\n-    pub span: Span,\n-    pub width: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_suffix)]\n-#[help]\n-pub(crate) struct InvalidFloatLiteralSuffix {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub suffix: String,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::int_literal_too_large)]\n-pub(crate) struct IntLiteralTooLarge {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::missing_semicolon_before_array)]\n-pub(crate) struct MissingSemicolonBeforeArray {\n-    #[primary_span]\n-    pub open_delim: Span,\n-    #[suggestion_verbose(applicability = \"maybe-incorrect\", code = \";\")]\n-    pub semicolon: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::invalid_block_macro_segment)]\n-pub(crate) struct InvalidBlockMacroSegment {\n-    #[primary_span]\n-    pub span: Span,\n-    #[label]\n-    pub context: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_then_block)]\n-pub(crate) struct IfExpressionMissingThenBlock {\n-    #[primary_span]\n-    pub if_span: Span,\n-    #[subdiagnostic]\n-    pub sub: IfExpressionMissingThenBlockSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum IfExpressionMissingThenBlockSub {\n-    #[help(parser::condition_possibly_unfinished)]\n-    UnfinishedCondition(#[primary_span] Span),\n-    #[help(parser::add_then_block)]\n-    AddThenBlock(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_condition)]\n-pub(crate) struct IfExpressionMissingCondition {\n-    #[primary_span]\n-    #[label(parser::condition_label)]\n-    pub if_span: Span,\n-    #[label(parser::block_label)]\n-    pub block_span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::expected_expression_found_let)]\n-pub(crate) struct ExpectedExpressionFoundLet {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::expected_else_block)]\n-pub(crate) struct ExpectedElseBlock {\n-    #[primary_span]\n-    pub first_tok_span: Span,\n-    pub first_tok: String,\n-    #[label]\n-    pub else_span: Span,\n-    #[suggestion(applicability = \"maybe-incorrect\", code = \"if \")]\n-    pub condition_start: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n-pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n-    #[primary_span]\n-    pub last: Span,\n-\n-    #[label(parser::branch_label)]\n-    pub branch_span: Span,\n-\n-    #[label(parser::ctx_label)]\n-    pub ctx_span: Span,\n-    pub ctx: String,\n-\n-    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n-    pub attributes: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::missing_in_in_for_loop)]\n-pub(crate) struct MissingInInForLoop {\n-    #[primary_span]\n-    pub span: Span,\n-    #[subdiagnostic]\n-    pub sub: MissingInInForLoopSub,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub(crate) enum MissingInInForLoopSub {\n-    // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n-    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n-    InNotOf(#[primary_span] Span),\n-    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n-    AddIn(#[primary_span] Span),\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::missing_comma_after_match_arm)]\n-pub(crate) struct MissingCommaAfterMatchArm {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::catch_after_try)]\n-#[help]\n-pub(crate) struct CatchAfterTry {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::comma_after_base_struct)]\n-#[note]\n-pub(crate) struct CommaAfterBaseStruct {\n-    #[primary_span]\n-    pub span: Span,\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n-    pub comma: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::eq_field_init)]\n-pub(crate) struct EqFieldInit {\n-    #[primary_span]\n-    pub span: Span,\n-    #[suggestion(applicability = \"machine-applicable\", code = \":\")]\n-    pub eq: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::dotdotdot)]\n-pub(crate) struct DotDotDot {\n-    #[primary_span]\n-    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n-    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::left_arrow_operator)]\n-pub(crate) struct LeftArrowOperator {\n-    #[primary_span]\n-    #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::remove_let)]\n-pub(crate) struct RemoveLet {\n-    #[primary_span]\n-    #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::use_eq_instead)]\n-pub(crate) struct UseEqInstead {\n-    #[primary_span]\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(parser::use_empty_block_not_semi)]\n-pub(crate) struct UseEmptyBlockNotSemi {\n-    #[primary_span]\n-    #[suggestion_hidden(applicability = \"machine-applicable\", code = \"{{}}\")]\n-    pub span: Span,\n-}\n-\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped.\n@@ -776,15 +246,6 @@ impl<'a> DerefMut for SnapshotParser<'a> {\n }\n \n impl<'a> Parser<'a> {\n-    #[rustc_lint_diagnostics]\n-    pub(super) fn span_err<S: Into<MultiSpan>>(\n-        &self,\n-        sp: S,\n-        err: Error,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        err.span_err(sp, self.diagnostic())\n-    }\n-\n     #[rustc_lint_diagnostics]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n@@ -830,10 +291,6 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn expected_ident_found(&self) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err = self.struct_span_err(\n-            self.token.span,\n-            &format!(\"expected identifier, found {}\", super::token_descr(&self.token)),\n-        );\n         let valid_follow = &[\n             TokenKind::Eq,\n             TokenKind::Colon,\n@@ -845,34 +302,35 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(Delimiter::Brace),\n             TokenKind::CloseDelim(Delimiter::Parenthesis),\n         ];\n-        match self.token.ident() {\n+        let suggest_raw = match self.token.ident() {\n             Some((ident, false))\n                 if ident.is_raw_guess()\n                     && self.look_ahead(1, |t| valid_follow.contains(&t.kind)) =>\n             {\n-                err.span_suggestion_verbose(\n-                    ident.span.shrink_to_lo(),\n-                    &format!(\"escape `{}` to use it as an identifier\", ident.name),\n-                    \"r#\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+                Some(SuggEscapeToUseAsIdentifier {\n+                    span: ident.span.shrink_to_lo(),\n+                    // `Symbol::to_string()` is different from `Symbol::into_diagnostic_arg()`,\n+                    // which uses `Symbol::to_ident_string()` and \"helpfully\" adds an implicit `r#`\n+                    ident_name: ident.name.to_string(),\n+                })\n             }\n-            _ => {}\n-        }\n-        if let Some(token_descr) = super::token_descr_opt(&self.token) {\n-            err.span_label(self.token.span, format!(\"expected identifier, found {}\", token_descr));\n-        } else {\n-            err.span_label(self.token.span, \"expected identifier\");\n+            _ => None,\n+        };\n+\n+        let suggest_remove_comma =\n             if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n-                err.span_suggestion(\n-                    self.token.span,\n-                    \"remove this comma\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        err\n+                Some(SuggRemoveComma { span: self.token.span })\n+            } else {\n+                None\n+            };\n+\n+        let err = ExpectedIdentifier {\n+            span: self.token.span,\n+            token: self.token.clone(),\n+            suggest_raw,\n+            suggest_remove_comma,\n+        };\n+        err.into_diagnostic(&self.sess.span_diagnostic)\n     }\n \n     pub(super) fn expected_one_of_not_found(\n@@ -937,8 +395,8 @@ impl<'a> Parser<'a> {\n         expected.dedup();\n \n         let sm = self.sess.source_map();\n-        let msg = format!(\"expected `;`, found {}\", super::token_descr(&self.token));\n-        let appl = Applicability::MachineApplicable;\n+\n+        // Special-case \"expected `;`\" errors\n         if expected.contains(&TokenType::Token(token::Semi)) {\n             if self.token.span == DUMMY_SP || self.prev_token.span == DUMMY_SP {\n                 // Likely inside a macro, can't provide meaningful suggestions.\n@@ -966,11 +424,13 @@ impl<'a> Parser<'a> {\n                 //\n                 //   let x = 32:\n                 //   let y = 42;\n+                self.sess.emit_err(ExpectedSemi {\n+                    span: self.token.span,\n+                    token: self.token.clone(),\n+                    unexpected_token_label: None,\n+                    sugg: ExpectedSemiSugg::ChangeToSemi(self.token.span),\n+                });\n                 self.bump();\n-                let sp = self.prev_token.span;\n-                self.struct_span_err(sp, &msg)\n-                    .span_suggestion_short(sp, \"change this to `;`\", \";\", appl)\n-                    .emit();\n                 return Ok(true);\n             } else if self.look_ahead(0, |t| {\n                 t == &token::CloseDelim(Delimiter::Brace)\n@@ -988,11 +448,13 @@ impl<'a> Parser<'a> {\n                 //\n                 //   let x = 32\n                 //   let y = 42;\n-                let sp = self.prev_token.span.shrink_to_hi();\n-                self.struct_span_err(sp, &msg)\n-                    .span_label(self.token.span, \"unexpected token\")\n-                    .span_suggestion_short(sp, \"add `;` here\", \";\", appl)\n-                    .emit();\n+                let span = self.prev_token.span.shrink_to_hi();\n+                self.sess.emit_err(ExpectedSemi {\n+                    span,\n+                    token: self.token.clone(),\n+                    unexpected_token_label: Some(self.token.span),\n+                    sugg: ExpectedSemiSugg::AddSemi(span),\n+                });\n                 return Ok(true);\n             }\n         }\n@@ -1029,6 +491,7 @@ impl<'a> Parser<'a> {\n             )\n         };\n         self.last_unexpected_token_span = Some(self.token.span);\n+        // FIXME: translation requires list formatting (for `expect`)\n         let mut err = self.struct_span_err(self.token.span, &msg_exp);\n \n         if let TokenKind::Ident(symbol, _) = &self.prev_token.kind {\n@@ -1037,7 +500,7 @@ impl<'a> Parser<'a> {\n                     self.prev_token.span,\n                     &format!(\"write `fn` instead of `{symbol}` to declare a function\"),\n                     \"fn\",\n-                    appl,\n+                    Applicability::MachineApplicable,\n                 );\n             }\n         }\n@@ -1051,7 +514,7 @@ impl<'a> Parser<'a> {\n                 self.prev_token.span,\n                 \"write `pub` instead of `public` to make the item public\",\n                 \"pub\",\n-                appl,\n+                Applicability::MachineApplicable,\n             );\n         }\n \n@@ -1189,19 +652,13 @@ impl<'a> Parser<'a> {\n                     //     field: value,\n                     // } }\n                     err.delay_as_bug();\n-                    self.struct_span_err(\n-                        expr.span,\n-                        fluent::parser::struct_literal_body_without_path,\n-                    )\n-                    .multipart_suggestion(\n-                        fluent::parser::suggestion,\n-                        vec![\n-                            (expr.span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n-                            (expr.span.shrink_to_hi(), \" }\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n+                    self.sess.emit_err(StructLiteralBodyWithoutPath {\n+                        span: expr.span,\n+                        sugg: StructLiteralBodyWithoutPathSugg {\n+                            before: expr.span.shrink_to_lo(),\n+                            after: expr.span.shrink_to_hi(),\n+                        },\n+                    });\n                     self.restore_snapshot(snapshot);\n                     let mut tail = self.mk_block(\n                         vec![self.mk_stmt_err(expr.span)],\n@@ -1395,18 +852,8 @@ impl<'a> Parser<'a> {\n             self.eat_to_tokens(end);\n             let span = lo.until(self.token.span);\n \n-            let total_num_of_gt = number_of_gt + number_of_shr * 2;\n-            self.struct_span_err(\n-                span,\n-                &format!(\"unmatched angle bracket{}\", pluralize!(total_num_of_gt)),\n-            )\n-            .span_suggestion(\n-                span,\n-                &format!(\"remove extra angle bracket{}\", pluralize!(total_num_of_gt)),\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            let num_extra_brackets = number_of_gt + number_of_shr * 2;\n+            self.sess.emit_err(UnmatchedAngleBrackets { span, num_extra_brackets });\n             return true;\n         }\n         false\n@@ -1435,19 +882,13 @@ impl<'a> Parser<'a> {\n                         let args = AngleBracketedArgs { args, span }.into();\n                         segment.args = args;\n \n-                        self.struct_span_err(\n+                        self.sess.emit_err(GenericParamsWithoutAngleBrackets {\n                             span,\n-                            \"generic parameters without surrounding angle brackets\",\n-                        )\n-                        .multipart_suggestion(\n-                            \"surround the type parameters with angle brackets\",\n-                            vec![\n-                                (span.shrink_to_lo(), \"<\".to_string()),\n-                                (trailing_span, \">\".to_string()),\n-                            ],\n-                            Applicability::MachineApplicable,\n-                        )\n-                        .emit();\n+                            sugg: GenericParamsWithoutAngleBracketsSugg {\n+                                left: span.shrink_to_lo(),\n+                                right: trailing_span,\n+                            },\n+                        });\n                     } else {\n                         // This doesn't look like an invalid turbofish, can't recover parse state.\n                         self.restore_snapshot(snapshot);\n@@ -1484,7 +925,7 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Gt) {\n                         e.span_suggestion_verbose(\n                             binop.span.shrink_to_lo(),\n-                            TURBOFISH_SUGGESTION_STR,\n+                            fluent::parser::sugg_turbofish_syntax,\n                             \"::\",\n                             Applicability::MaybeIncorrect,\n                         )\n@@ -1516,7 +957,7 @@ impl<'a> Parser<'a> {\n     /// parenthesising the leftmost comparison.\n     fn attempt_chained_comparison_suggestion(\n         &mut self,\n-        err: &mut Diagnostic,\n+        err: &mut ComparisonOperatorsCannotBeChained,\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n     ) -> bool /* advanced the cursor */ {\n@@ -1529,16 +970,6 @@ impl<'a> Parser<'a> {\n                 // suggestion being the only one to apply is high.\n                 return false;\n             }\n-            let mut enclose = |left: Span, right: Span| {\n-                err.multipart_suggestion(\n-                    \"parenthesize the comparison\",\n-                    vec![\n-                        (left.shrink_to_lo(), \"(\".to_string()),\n-                        (right.shrink_to_hi(), \")\".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect,\n-                );\n-            };\n             return match (op.node, &outer_op.node) {\n                 // `x == y == z`\n                 (BinOpKind::Eq, AssocOp::Equal) |\n@@ -1552,12 +983,10 @@ impl<'a> Parser<'a> {\n                         self.span_to_snippet(e.span)\n                             .unwrap_or_else(|_| pprust::expr_to_string(&e))\n                     };\n-                    err.span_suggestion_verbose(\n-                        inner_op.span.shrink_to_hi(),\n-                        \"split the comparison into two\",\n-                        format!(\" && {}\", expr_to_str(&r1)),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    err.chaining_sugg = Some(ComparisonOperatorsCannotBeChainedSugg::SplitComparison {\n+                        span: inner_op.span.shrink_to_hi(),\n+                        middle_term: expr_to_str(&r1),\n+                    });\n                     false // Keep the current parse behavior, where the AST is `(x < y) < z`.\n                 }\n                 // `x == y < z`\n@@ -1568,7 +997,10 @@ impl<'a> Parser<'a> {\n                         Ok(r2) => {\n                             // We are sure that outer-op-rhs could be consumed, the suggestion is\n                             // likely correct.\n-                            enclose(r1.span, r2.span);\n+                            err.chaining_sugg = Some(ComparisonOperatorsCannotBeChainedSugg::Parenthesize {\n+                                left: r1.span.shrink_to_lo(),\n+                                right: r2.span.shrink_to_hi(),\n+                            });\n                             true\n                         }\n                         Err(expr_err) => {\n@@ -1585,7 +1017,10 @@ impl<'a> Parser<'a> {\n                     // further checks are necessary.\n                     match self.parse_expr() {\n                         Ok(_) => {\n-                            enclose(l1.span, r1.span);\n+                            err.chaining_sugg = Some(ComparisonOperatorsCannotBeChainedSugg::Parenthesize {\n+                                left: l1.span.shrink_to_lo(),\n+                                right: r1.span.shrink_to_hi(),\n+                            });\n                             true\n                         }\n                         Err(expr_err) => {\n@@ -1634,18 +1069,11 @@ impl<'a> Parser<'a> {\n \n         match inner_op.kind {\n             ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n-                let mut err = self.struct_span_err(\n-                    vec![op.span, self.prev_token.span],\n-                    \"comparison operators cannot be chained\",\n-                );\n-\n-                let suggest = |err: &mut Diagnostic| {\n-                    err.span_suggestion_verbose(\n-                        op.span.shrink_to_lo(),\n-                        TURBOFISH_SUGGESTION_STR,\n-                        \"::\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                let mut err = ComparisonOperatorsCannotBeChained {\n+                    span: vec![op.span, self.prev_token.span],\n+                    suggest_turbofish: None,\n+                    help_turbofish: None,\n+                    chaining_sugg: None,\n                 };\n \n                 // Include `<` to provide this recommendation even in a case like\n@@ -1672,7 +1100,7 @@ impl<'a> Parser<'a> {\n                     return if token::ModSep == self.token.kind {\n                         // We have some certainty that this was a bad turbofish at this point.\n                         // `foo< bar >::`\n-                        suggest(&mut err);\n+                        err.suggest_turbofish = Some(op.span.shrink_to_lo());\n \n                         let snapshot = self.create_snapshot_for_diagnostic();\n                         self.bump(); // `::`\n@@ -1681,7 +1109,7 @@ impl<'a> Parser<'a> {\n                         match self.parse_expr() {\n                             Ok(_) => {\n                                 // 99% certain that the suggestion is correct, continue parsing.\n-                                err.emit();\n+                                self.sess.emit_err(err);\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n@@ -1692,18 +1120,18 @@ impl<'a> Parser<'a> {\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n                                 self.restore_snapshot(snapshot);\n-                                Err(err)\n+                                Err(err.into_diagnostic(&self.sess.span_diagnostic))\n                             }\n                         }\n                     } else if token::OpenDelim(Delimiter::Parenthesis) == self.token.kind {\n                         // We have high certainty that this was a bad turbofish at this point.\n                         // `foo< bar >(`\n-                        suggest(&mut err);\n+                        err.suggest_turbofish = Some(op.span.shrink_to_lo());\n                         // Consume the fn call arguments.\n                         match self.consume_fn_args() {\n-                            Err(()) => Err(err),\n+                            Err(()) => Err(err.into_diagnostic(&self.sess.span_diagnostic)),\n                             Ok(()) => {\n-                                err.emit();\n+                                self.sess.emit_err(err);\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n@@ -1716,25 +1144,24 @@ impl<'a> Parser<'a> {\n                         {\n                             // All we know is that this is `foo < bar >` and *nothing* else. Try to\n                             // be helpful, but don't attempt to recover.\n-                            err.help(TURBOFISH_SUGGESTION_STR);\n-                            err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                            err.help_turbofish = Some(());\n                         }\n \n                         // If it looks like a genuine attempt to chain operators (as opposed to a\n                         // misformatted turbofish, for instance), suggest a correct form.\n                         if self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op)\n                         {\n-                            err.emit();\n+                            self.sess.emit_err(err);\n                             mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                         } else {\n                             // These cases cause too many knock-down errors, bail out (#61329).\n-                            Err(err)\n+                            Err(err.into_diagnostic(&self.sess.span_diagnostic))\n                         }\n                     };\n                 }\n                 let recover =\n                     self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n-                err.emit();\n+                self.sess.emit_err(err);\n                 if recover {\n                     return mk_err_expr(self, inner_op.span.to(self.prev_token.span));\n                 }\n@@ -1775,17 +1202,13 @@ impl<'a> Parser<'a> {\n     pub(super) fn maybe_recover_from_question_mark(&mut self, ty: P<Ty>) -> P<Ty> {\n         if self.token == token::Question {\n             self.bump();\n-            self.struct_span_err(self.prev_token.span, \"invalid `?` in type\")\n-                .span_label(self.prev_token.span, \"`?` is only allowed on expressions, not types\")\n-                .multipart_suggestion(\n-                    \"if you meant to express that the type might not contain a value, use the `Option` wrapper type\",\n-                    vec![\n-                        (ty.span.shrink_to_lo(), \"Option<\".to_string()),\n-                        (self.prev_token.span, \">\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(QuestionMarkInType {\n+                span: self.prev_token.span,\n+                sugg: QuestionMarkInTypeSugg {\n+                    left: ty.span.shrink_to_lo(),\n+                    right: self.prev_token.span,\n+                },\n+            });\n             self.mk_ty(ty.span.to(self.prev_token.span), TyKind::Err)\n         } else {\n             ty\n@@ -2209,19 +1632,16 @@ impl<'a> Parser<'a> {\n             (token::CloseDelim(Delimiter::Parenthesis), Some(begin_par_sp)) => {\n                 self.bump();\n \n-                self.struct_span_err(\n-                    MultiSpan::from_spans(vec![begin_par_sp, self.prev_token.span]),\n-                    \"unexpected parentheses surrounding `for` loop head\",\n-                )\n-                .multipart_suggestion(\n-                    \"remove parentheses in `for` loop\",\n-                    vec![(begin_par_sp, String::new()), (self.prev_token.span, String::new())],\n+                self.sess.emit_err(ParenthesesInForHead {\n+                    span: vec![begin_par_sp, self.prev_token.span],\n                     // With e.g. `for (x) in y)` this would replace `(x) in y)`\n                     // with `x) in y)` which is syntactically invalid.\n                     // However, this is prevented before we get here.\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+                    sugg: ParenthesesInForHeadSugg {\n+                        left: begin_par_sp,\n+                        right: self.prev_token.span,\n+                    },\n+                });\n \n                 // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint.\n                 pat.and_then(|pat| match pat.kind {\n@@ -2440,12 +1860,7 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn eat_incorrect_doc_comment_for_param_type(&mut self) {\n         if let token::DocComment(..) = self.token.kind {\n-            self.struct_span_err(\n-                self.token.span,\n-                \"documentation comments cannot be applied to a function parameter's type\",\n-            )\n-            .span_label(self.token.span, \"doc comments are not allowed here\")\n-            .emit();\n+            self.sess.emit_err(DocCommentOnParamType { span: self.token.span });\n             self.bump();\n         } else if self.token == token::Pound\n             && self.look_ahead(1, |t| *t == token::OpenDelim(Delimiter::Bracket))\n@@ -2457,9 +1872,7 @@ impl<'a> Parser<'a> {\n             }\n             let sp = lo.to(self.token.span);\n             self.bump();\n-            self.struct_span_err(sp, \"attributes cannot be applied to a function parameter's type\")\n-                .span_label(sp, \"attributes are not allowed here\")\n-                .emit();\n+            self.sess.emit_err(AttributeOnParamType { span: sp });\n         }\n     }\n \n@@ -2580,19 +1993,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        struct_span_err!(\n-            self.diagnostic(),\n-            pat.span,\n-            E0642,\n-            \"patterns aren't allowed in methods without bodies\",\n-        )\n-        .span_suggestion_short(\n-            pat.span,\n-            \"give this argument a name or use an underscore to ignore it\",\n-            \"_\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+        self.sess.emit_err(PatternMethodParamWithoutBody { span: pat.span });\n \n         // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n         let pat =\n@@ -2601,11 +2002,9 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn recover_bad_self_param(&mut self, mut param: Param) -> PResult<'a, Param> {\n-        let sp = param.pat.span;\n+        let span = param.pat.span;\n         param.ty.kind = TyKind::Err;\n-        self.struct_span_err(sp, \"unexpected `self` parameter in function\")\n-            .span_label(sp, \"must be the first parameter of an associated function\")\n-            .emit();\n+        self.sess.emit_err(SelfParamNotFirst { span });\n         Ok(param)\n     }\n \n@@ -2754,20 +2153,13 @@ impl<'a> Parser<'a> {\n             err\n         })?;\n         if !self.expr_is_valid_const_arg(&expr) {\n-            self.struct_span_err(\n-                expr.span,\n-                \"expressions must be enclosed in braces to be used as const generic \\\n-                    arguments\",\n-            )\n-            .multipart_suggestion(\n-                \"enclose the `const` expression in braces\",\n-                vec![\n-                    (expr.span.shrink_to_lo(), \"{ \".to_string()),\n-                    (expr.span.shrink_to_hi(), \" }\".to_string()),\n-                ],\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.sess.emit_err(ConstGenericWithoutBraces {\n+                span: expr.span,\n+                sugg: ConstGenericWithoutBracesSugg {\n+                    left: expr.span.shrink_to_lo(),\n+                    right: expr.span.shrink_to_hi(),\n+                },\n+            });\n         }\n         Ok(expr)\n     }\n@@ -2782,24 +2174,30 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n         };\n-        let mut err =\n-            self.struct_span_err(param.span(), \"unexpected `const` parameter declaration\");\n-        err.span_label(param.span(), \"expected a `const` expression, not a parameter declaration\");\n-        if let (Some(generics), Ok(snippet)) =\n-            (ty_generics, self.sess.source_map().span_to_snippet(param.span()))\n-        {\n-            let (span, sugg) = match &generics.params[..] {\n-                [] => (generics.span, format!(\"<{snippet}>\")),\n-                [.., generic] => (generic.span().shrink_to_hi(), format!(\", {snippet}\")),\n-            };\n-            err.multipart_suggestion(\n-                \"`const` parameters must be declared for the `impl`\",\n-                vec![(span, sugg), (param.span(), param.ident.to_string())],\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+\n+        let ident = param.ident.to_string();\n+        let sugg = match (ty_generics, self.sess.source_map().span_to_snippet(param.span())) {\n+            (Some(Generics { params, span: impl_generics, .. }), Ok(snippet)) => {\n+                Some(match &params[..] {\n+                    [] => UnexpectedConstParamDeclarationSugg::AddParam {\n+                        impl_generics: *impl_generics,\n+                        incorrect_decl: param.span(),\n+                        snippet,\n+                        ident,\n+                    },\n+                    [.., generic] => UnexpectedConstParamDeclarationSugg::AppendParam {\n+                        impl_generics_end: generic.span().shrink_to_hi(),\n+                        incorrect_decl: param.span(),\n+                        snippet,\n+                        ident,\n+                    },\n+                })\n+            }\n+            _ => None,\n+        };\n+        self.sess.emit_err(UnexpectedConstParamDeclaration { span: param.span(), sugg });\n+\n         let value = self.mk_expr_err(param.span());\n-        err.emit();\n         Some(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value }))\n     }\n \n@@ -2817,20 +2215,15 @@ impl<'a> Parser<'a> {\n         self.bump(); // `const`\n \n         // Detect and recover from the old, pre-RFC2000 syntax for const generics.\n-        let mut err = self\n-            .struct_span_err(start, \"expected lifetime, type, or constant, found keyword `const`\");\n+        let mut err = UnexpectedConstInGenericParam { span: start, to_remove: None };\n         if self.check_const_arg() {\n-            err.span_suggestion_verbose(\n-                start.until(self.token.span),\n-                \"the `const` keyword is only needed in the definition of the type\",\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            );\n-            err.emit();\n+            err.to_remove = Some(start.until(self.token.span));\n+            self.sess.emit_err(err);\n             Ok(Some(GenericArg::Const(self.parse_const_arg()?)))\n         } else {\n             let after_kw_const = self.token.span;\n-            self.recover_const_arg(after_kw_const, err).map(Some)\n+            self.recover_const_arg(after_kw_const, err.into_diagnostic(&self.sess.span_diagnostic))\n+                .map(Some)\n         }\n     }\n \n@@ -2936,24 +2329,6 @@ impl<'a> Parser<'a> {\n         GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value })\n     }\n \n-    /// Get the diagnostics for the cases where `move async` is found.\n-    ///\n-    /// `move_async_span` starts at the 'm' of the move keyword and ends with the 'c' of the async keyword\n-    pub(super) fn incorrect_move_async_order_found(\n-        &self,\n-        move_async_span: Span,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err =\n-            self.struct_span_err(move_async_span, \"the order of `move` and `async` is incorrect\");\n-        err.span_suggestion_verbose(\n-            move_async_span,\n-            \"try switching the order\",\n-            \"async move\",\n-            Applicability::MaybeIncorrect,\n-        );\n-        err\n-    }\n-\n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n     pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n@@ -3149,17 +2524,11 @@ impl<'a> Parser<'a> {\n                 let (a_span, b_span) = (a.span(), b.span());\n                 let between_span = a_span.shrink_to_hi().to(b_span.shrink_to_lo());\n                 if self.span_to_snippet(between_span).as_ref().map(|a| &a[..]) == Ok(\":: \") {\n-                    let mut err = self.struct_span_err(\n-                        path.span.shrink_to_hi(),\n-                        \"expected `:` followed by trait or lifetime\",\n-                    );\n-                    err.span_suggestion(\n-                        between_span,\n-                        \"use single colon\",\n-                        \": \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                    return Err(err);\n+                    return Err(DoubleColonInBound {\n+                        span: path.span.shrink_to_hi(),\n+                        between: between_span,\n+                    }\n+                    .into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             }\n         }"}, {"sha": "8b328e593ae807c791f6801e9450227015cf8d82", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 167, "deletions": 234, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -1,27 +1,33 @@\n-use super::diagnostics::{\n-    CatchAfterTry, CommaAfterBaseStruct, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n-    ExpectedElseBlock, ExpectedExpressionFoundLet, FieldExpressionWithGeneric,\n-    FloatLiteralRequiresIntegerPart, IfExpressionMissingCondition, IfExpressionMissingThenBlock,\n-    IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment, InvalidComparisonOperator,\n-    InvalidComparisonOperatorSub, InvalidLogicalOperator, InvalidLogicalOperatorSub,\n-    LeftArrowOperator, LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath,\n-    MalformedLoopLabel, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n-    NotAsNegationOperator, NotAsNegationOperatorSub, OuterAttributeNotAllowedOnIfElse,\n-    RequireColonAfterLabeledExpression, SnapshotParser, TildeAsUnaryOperator,\n-    UnexpectedTokenAfterLabel,\n-};\n+use super::diagnostics::SnapshotParser;\n use super::pat::{CommaRecoveryMode, RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n-use crate::maybe_recover_from_interpolated_ty_qpath;\n-use crate::parser::diagnostics::{\n-    IntLiteralTooLarge, InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth,\n-    InvalidIntLiteralWidth, InvalidNumLiteralBasePrefix, InvalidNumLiteralSuffix,\n-    MissingCommaAfterMatchArm,\n+use crate::errors::{\n+    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncMoveOrderIncorrect,\n+    BinaryFloatLiteralNotSupported, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n+    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n+    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedExpressionFoundLet,\n+    FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt,\n+    HexadecimalFloatLiteralNotSupported, IfExpressionMissingCondition,\n+    IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub, IntLiteralTooLarge,\n+    InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n+    InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth, InvalidIntLiteralWidth,\n+    InvalidInterpolatedExpression, InvalidLiteralSuffix, InvalidLiteralSuffixOnTupleIndex,\n+    InvalidLogicalOperator, InvalidLogicalOperatorSub, InvalidNumLiteralBasePrefix,\n+    InvalidNumLiteralSuffix, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n+    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n+    MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n+    MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall,\n+    NotAsNegationOperator, NotAsNegationOperatorSub, OctalFloatLiteralNotSupported,\n+    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n+    RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n+    StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n+    UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n };\n+use crate::maybe_recover_from_interpolated_ty_qpath;\n \n use core::mem;\n use rustc_ast::ptr::P;\n@@ -38,6 +44,7 @@ use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::IntoDiagnostic;\n use rustc_errors::{Applicability, Diagnostic, PResult};\n+use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::source_map::{self, Span, Spanned};\n@@ -421,13 +428,11 @@ impl<'a> Parser<'a> {\n     /// but the next token implies this should be parsed as an expression.\n     /// For example: `if let Some(x) = x { x } else { 0 } / 2`.\n     fn error_found_expr_would_be_stmt(&self, lhs: &Expr) {\n-        let mut err = self.struct_span_err(\n-            self.token.span,\n-            &format!(\"expected expression, found `{}`\", pprust::token_to_string(&self.token),),\n-        );\n-        err.span_label(self.token.span, \"expected expression\");\n-        self.sess.expr_parentheses_needed(&mut err, lhs.span);\n-        err.emit();\n+        self.sess.emit_err(FoundExprWouldBeStmt {\n+            span: self.token.span,\n+            token: self.token.clone(),\n+            suggestion: ExprParenthesesNeeded::surrounding(lhs.span),\n+        });\n     }\n \n     /// Possibly translate the current token to an associative operator.\n@@ -578,21 +583,16 @@ impl<'a> Parser<'a> {\n                 make_it!(this, attrs, |this, _| this.parse_borrow_expr(lo))\n             }\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n-                let mut err = this.struct_span_err(lo, \"leading `+` is not supported\");\n-                err.span_label(lo, \"unexpected `+`\");\n+                let mut err =\n+                    LeadingPlusNotSupported { span: lo, remove_plus: None, add_parentheses: None };\n \n                 // a block on the LHS might have been intended to be an expression instead\n                 if let Some(sp) = this.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n-                    this.sess.expr_parentheses_needed(&mut err, *sp);\n+                    err.add_parentheses = Some(ExprParenthesesNeeded::surrounding(*sp));\n                 } else {\n-                    err.span_suggestion_verbose(\n-                        lo,\n-                        \"try removing the `+`\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    err.remove_plus = Some(lo);\n                 }\n-                err.emit();\n+                this.sess.emit_err(err);\n \n                 this.bump();\n                 this.parse_prefix_expr(None)\n@@ -755,9 +755,34 @@ impl<'a> Parser<'a> {\n \n                 match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n-                        let (op_noun, op_verb) = match self.token.kind {\n-                            token::Lt => (\"comparison\", \"comparing\"),\n-                            token::BinOp(token::Shl) => (\"shift\", \"shifting\"),\n+                        let span_after_type = parser_snapshot_after_type.token.span;\n+                        let expr = mk_expr(\n+                            self,\n+                            lhs,\n+                            self.mk_ty(path.span, TyKind::Path(None, path.clone())),\n+                        );\n+\n+                        let args_span = self.look_ahead(1, |t| t.span).to(span_after_type);\n+                        let suggestion = ComparisonOrShiftInterpretedAsGenericSugg {\n+                            left: expr.span.shrink_to_lo(),\n+                            right: expr.span.shrink_to_hi(),\n+                        };\n+\n+                        match self.token.kind {\n+                            token::Lt => self.sess.emit_err(ComparisonInterpretedAsGeneric {\n+                                comparison: self.token.span,\n+                                r#type: path,\n+                                args: args_span,\n+                                suggestion,\n+                            }),\n+                            token::BinOp(token::Shl) => {\n+                                self.sess.emit_err(ShiftInterpretedAsGeneric {\n+                                    shift: self.token.span,\n+                                    r#type: path,\n+                                    args: args_span,\n+                                    suggestion,\n+                                })\n+                            }\n                             _ => {\n                                 // We can end up here even without `<` being the next token, for\n                                 // example because `parse_ty_no_plus` returns `Err` on keywords,\n@@ -771,33 +796,7 @@ impl<'a> Parser<'a> {\n                         // Successfully parsed the type path leaving a `<` yet to parse.\n                         type_err.cancel();\n \n-                        // Report non-fatal diagnostics, keep `x as usize` as an expression\n-                        // in AST and continue parsing.\n-                        let msg = format!(\n-                            \"`<` is interpreted as a start of generic arguments for `{}`, not a {}\",\n-                            pprust::path_to_string(&path),\n-                            op_noun,\n-                        );\n-                        let span_after_type = parser_snapshot_after_type.token.span;\n-                        let expr =\n-                            mk_expr(self, lhs, self.mk_ty(path.span, TyKind::Path(None, path)));\n-\n-                        self.struct_span_err(self.token.span, &msg)\n-                            .span_label(\n-                                self.look_ahead(1, |t| t.span).to(span_after_type),\n-                                \"interpreted as generic arguments\",\n-                            )\n-                            .span_label(self.token.span, format!(\"not interpreted as {op_noun}\"))\n-                            .multipart_suggestion(\n-                                &format!(\"try {op_verb} the cast value\"),\n-                                vec![\n-                                    (expr.span.shrink_to_lo(), \"(\".to_string()),\n-                                    (expr.span.shrink_to_hi(), \")\".to_string()),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n-\n+                        // Keep `x as usize` as an expression in AST and continue parsing.\n                         expr\n                     }\n                     Err(path_err) => {\n@@ -1158,7 +1157,9 @@ impl<'a> Parser<'a> {\n         }\n         let span = self.prev_token.span;\n         let field = ExprKind::Field(base, Ident::new(field, span));\n-        self.expect_no_suffix(span, \"a tuple index\", suffix);\n+        if let Some(suffix) = suffix {\n+            self.expect_no_tuple_index_suffix(span, suffix);\n+        }\n         self.mk_expr(lo.to(span), field)\n     }\n \n@@ -1196,9 +1197,8 @@ impl<'a> Parser<'a> {\n     ) -> Option<P<Expr>> {\n         match (seq.as_mut(), snapshot) {\n             (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n-                let name = pprust::path_to_string(&path);\n                 snapshot.bump(); // `(`\n-                match snapshot.parse_struct_fields(path, false, Delimiter::Parenthesis) {\n+                match snapshot.parse_struct_fields(path.clone(), false, Delimiter::Parenthesis) {\n                     Ok((fields, ..))\n                         if snapshot.eat(&token::CloseDelim(Delimiter::Parenthesis)) =>\n                     {\n@@ -1208,29 +1208,25 @@ impl<'a> Parser<'a> {\n                         let close_paren = self.prev_token.span;\n                         let span = lo.to(self.prev_token.span);\n                         if !fields.is_empty() {\n-                            let replacement_err = self.struct_span_err(\n+                            let mut replacement_err = ParenthesesWithStructFields {\n                                 span,\n-                                \"invalid `struct` delimiters or `fn` call arguments\",\n-                            );\n-                            mem::replace(err, replacement_err).cancel();\n-\n-                            err.multipart_suggestion(\n-                                &format!(\"if `{name}` is a struct, use braces as delimiters\"),\n-                                vec![\n-                                    (open_paren, \" { \".to_string()),\n-                                    (close_paren, \" }\".to_string()),\n-                                ],\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            err.multipart_suggestion(\n-                                &format!(\"if `{name}` is a function, use the arguments directly\"),\n-                                fields\n-                                    .into_iter()\n-                                    .map(|field| (field.span.until(field.expr.span), String::new()))\n-                                    .collect(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            err.emit();\n+                                r#type: path,\n+                                braces_for_struct: BracesForStructLiteral {\n+                                    first: open_paren,\n+                                    second: close_paren,\n+                                },\n+                                no_fields_for_fn: NoFieldsForFnCall {\n+                                    fields: fields\n+                                        .into_iter()\n+                                        .map(|field| field.span.until(field.expr.span))\n+                                        .collect(),\n+                                },\n+                            }\n+                            .into_diagnostic(&self.sess.span_diagnostic);\n+                            replacement_err.emit();\n+\n+                            let old_err = mem::replace(err, replacement_err);\n+                            old_err.cancel();\n                         } else {\n                             err.emit();\n                         }\n@@ -1537,15 +1533,19 @@ impl<'a> Parser<'a> {\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n-            self.sess.emit_err(UnexpectedTokenAfterLabel(self.token.span));\n+            self.sess.emit_err(UnexpectedTokenAfterLabel {\n+                span: self.token.span,\n+                remove_label: None,\n+                enclose_in_block: None,\n+            });\n             consume_colon = false;\n             Ok(self.mk_expr_err(lo))\n         } else {\n-            // FIXME: use UnexpectedTokenAfterLabel, needs multipart suggestions\n-            let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n-\n-            let mut err = self.struct_span_err(self.token.span, msg);\n-            err.span_label(self.token.span, msg);\n+            let mut err = UnexpectedTokenAfterLabel {\n+                span: self.token.span,\n+                remove_label: None,\n+                enclose_in_block: None,\n+            };\n \n             // Continue as an expression in an effort to recover on `'label: non_block_expr`.\n             let expr = self.parse_expr().map(|expr| {\n@@ -1572,36 +1572,23 @@ impl<'a> Parser<'a> {\n                 // If there are no breaks that may use this label, suggest removing the label and\n                 // recover to the unmodified expression.\n                 if !found_labeled_breaks {\n-                    let msg = \"consider removing the label\";\n-                    err.span_suggestion_verbose(\n-                        lo.until(span),\n-                        msg,\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n+                    err.remove_label = Some(lo.until(span));\n \n                     return expr;\n                 }\n \n-                let sugg_msg = \"consider enclosing expression in a block\";\n-                let suggestions = vec![\n-                    (span.shrink_to_lo(), \"{ \".to_owned()),\n-                    (span.shrink_to_hi(), \" }\".to_owned()),\n-                ];\n-\n-                err.multipart_suggestion_verbose(\n-                    sugg_msg,\n-                    suggestions,\n-                    Applicability::MachineApplicable,\n-                );\n+                err.enclose_in_block = Some(UnexpectedTokenAfterLabelSugg {\n+                    left: span.shrink_to_lo(),\n+                    right: span.shrink_to_hi(),\n+                });\n \n                 // Replace `'label: non_block_expr` with `'label: {non_block_expr}` in order to suppress future errors about `break 'label`.\n                 let stmt = self.mk_stmt(span, StmtKind::Expr(expr));\n                 let blk = self.mk_block(vec![stmt], BlockCheckMode::Default, span);\n                 self.mk_expr(span, ExprKind::Block(blk, label))\n             });\n \n-            err.emit();\n+            self.sess.emit_err(err);\n             expr\n         }?;\n \n@@ -1672,19 +1659,13 @@ impl<'a> Parser<'a> {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n             let lexpr = self.parse_labeled_expr(label.take().unwrap(), true)?;\n-            self.struct_span_err(\n-                lexpr.span,\n-                \"parentheses are required around this expression to avoid confusion with a labeled break expression\",\n-            )\n-            .multipart_suggestion(\n-                \"wrap the expression in parentheses\",\n-                vec![\n-                    (lexpr.span.shrink_to_lo(), \"(\".to_string()),\n-                    (lexpr.span.shrink_to_hi(), \")\".to_string()),\n-                ],\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.sess.emit_err(LabeledLoopInBreak {\n+                span: lexpr.span,\n+                sub: WrapExpressionInParentheses {\n+                    left: lexpr.span.shrink_to_lo(),\n+                    right: lexpr.span.shrink_to_hi(),\n+                },\n+            });\n             Some(lexpr)\n         } else if self.token != token::OpenDelim(Delimiter::Brace)\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n@@ -1756,9 +1737,8 @@ impl<'a> Parser<'a> {\n                 };\n                 if let Some(expr) = expr {\n                     if matches!(expr.kind, ExprKind::Err) {\n-                        let mut err = self\n-                            .diagnostic()\n-                            .struct_span_err(self.token.span, \"invalid interpolated expression\");\n+                        let mut err = InvalidInterpolatedExpression { span: self.token.span }\n+                            .into_diagnostic(&self.sess.span_diagnostic);\n                         err.downgrade_to_delayed_bug();\n                         return err;\n                     }\n@@ -1790,7 +1770,10 @@ impl<'a> Parser<'a> {\n             });\n             if let Some(token) = &recovered {\n                 self.bump();\n-                self.error_float_lits_must_have_int_part(&token);\n+                self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n+                    span: token.span,\n+                    correct: pprust::token_to_string(token).into_owned(),\n+                });\n             }\n         }\n \n@@ -1818,13 +1801,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn error_float_lits_must_have_int_part(&self, token: &Token) {\n-        self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n-            span: token.span,\n-            correct: pprust::token_to_string(token).into_owned(),\n-        });\n-    }\n-\n     fn report_lit_error(&self, err: LitError, lit: token::Lit, span: Span) {\n         // Checks if `s` looks like i32 or u1234 etc.\n         fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n@@ -1853,11 +1829,13 @@ impl<'a> Parser<'a> {\n             // by lexer, so here we don't report it the second time.\n             LitError::LexerError => {}\n             LitError::InvalidSuffix => {\n-                self.expect_no_suffix(\n-                    span,\n-                    &format!(\"{} {} literal\", kind.article(), kind.descr()),\n-                    suffix,\n-                );\n+                if let Some(suffix) = suffix {\n+                    self.sess.emit_err(InvalidLiteralSuffix {\n+                        span,\n+                        kind: format!(\"{}\", kind.descr()),\n+                        suffix,\n+                    });\n+                }\n             }\n             LitError::InvalidIntSuffix => {\n                 let suf = suffix.expect(\"suffix error with no suffix\");\n@@ -1883,54 +1861,30 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             LitError::NonDecimalFloat(base) => {\n-                let descr = match base {\n-                    16 => \"hexadecimal\",\n-                    8 => \"octal\",\n-                    2 => \"binary\",\n+                match base {\n+                    16 => self.sess.emit_err(HexadecimalFloatLiteralNotSupported { span }),\n+                    8 => self.sess.emit_err(OctalFloatLiteralNotSupported { span }),\n+                    2 => self.sess.emit_err(BinaryFloatLiteralNotSupported { span }),\n                     _ => unreachable!(),\n                 };\n-                self.struct_span_err(span, &format!(\"{descr} float literal is not supported\"))\n-                    .span_label(span, \"not supported\")\n-                    .emit();\n             }\n             LitError::IntTooLarge => {\n                 self.sess.emit_err(IntLiteralTooLarge { span });\n             }\n         }\n     }\n \n-    pub(super) fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<Symbol>) {\n-        if let Some(suf) = suffix {\n-            let mut err = if kind == \"a tuple index\"\n-                && [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suf)\n-            {\n-                // #59553: warn instead of reject out of hand to allow the fix to percolate\n-                // through the ecosystem when people fix their macros\n-                let mut err = self\n-                    .sess\n-                    .span_diagnostic\n-                    .struct_span_warn(sp, &format!(\"suffixes on {kind} are invalid\"));\n-                err.note(&format!(\n-                    \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n-                        incorrectly accepted on stable for a few releases\",\n-                    suf,\n-                ));\n-                err.help(\n-                    \"on proc macros, you'll want to use `syn::Index::from` or \\\n-                        `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n-                        to tuple field access\",\n-                );\n-                err.note(\n-                    \"see issue #60210 <https://github.com/rust-lang/rust/issues/60210> \\\n-                     for more information\",\n-                );\n-                err\n-            } else {\n-                self.struct_span_err(sp, &format!(\"suffixes on {kind} are invalid\"))\n-                    .forget_guarantee()\n-            };\n-            err.span_label(sp, format!(\"invalid suffix `{suf}`\"));\n-            err.emit();\n+    pub(super) fn expect_no_tuple_index_suffix(&self, span: Span, suffix: Symbol) {\n+        if [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suffix) {\n+            // #59553: warn instead of reject out of hand to allow the fix to percolate\n+            // through the ecosystem when people fix their macros\n+            self.sess.emit_warning(InvalidLiteralSuffixOnTupleIndex {\n+                span,\n+                suffix,\n+                exception: Some(()),\n+            });\n+        } else {\n+            self.sess.emit_err(InvalidLiteralSuffixOnTupleIndex { span, suffix, exception: None });\n         }\n     }\n \n@@ -1964,14 +1918,13 @@ impl<'a> Parser<'a> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n         match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n             Ok(arr) => {\n-                let hi = snapshot.prev_token.span;\n-                self.struct_span_err(arr.span, \"this is a block expression, not an array\")\n-                    .multipart_suggestion(\n-                        \"to make an array, use square brackets instead of curly braces\",\n-                        vec![(lo, \"[\".to_owned()), (hi, \"]\".to_owned())],\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(ArrayBracketsInsteadOfSpaces {\n+                    span: arr.span,\n+                    sub: ArrayBracketsInsteadOfSpacesSugg {\n+                        left: lo,\n+                        right: snapshot.prev_token.span,\n+                    },\n+                });\n \n                 self.restore_snapshot(snapshot);\n                 Some(self.mk_expr_err(arr.span))\n@@ -2134,7 +2087,8 @@ impl<'a> Parser<'a> {\n             // Check for `move async` and recover\n             if self.check_keyword(kw::Async) {\n                 let move_async_span = self.token.span.with_lo(self.prev_token.span.data().lo);\n-                Err(self.incorrect_move_async_order_found(move_async_span))\n+                Err(AsyncMoveOrderIncorrect { span: move_async_span }\n+                    .into_diagnostic(&self.sess.span_diagnostic))\n             } else {\n                 Ok(CaptureBy::Value)\n             }\n@@ -2515,39 +2469,22 @@ impl<'a> Parser<'a> {\n         self.bump(); // `;`\n         let mut stmts =\n             vec![self.mk_stmt(first_expr.span, ast::StmtKind::Expr(first_expr.clone()))];\n-        let err = |this: &mut Parser<'_>, stmts: Vec<ast::Stmt>| {\n+        let err = |this: &Parser<'_>, stmts: Vec<ast::Stmt>| {\n             let span = stmts[0].span.to(stmts[stmts.len() - 1].span);\n-            let mut err = this.struct_span_err(span, \"`match` arm body without braces\");\n-            let (these, s, are) =\n-                if stmts.len() > 1 { (\"these\", \"s\", \"are\") } else { (\"this\", \"\", \"is\") };\n-            err.span_label(\n-                span,\n-                &format!(\n-                    \"{these} statement{s} {are} not surrounded by a body\",\n-                    these = these,\n-                    s = s,\n-                    are = are\n-                ),\n-            );\n-            err.span_label(arrow_span, \"while parsing the `match` arm starting here\");\n-            if stmts.len() > 1 {\n-                err.multipart_suggestion(\n-                    &format!(\"surround the statement{s} with a body\"),\n-                    vec![\n-                        (span.shrink_to_lo(), \"{ \".to_string()),\n-                        (span.shrink_to_hi(), \" }\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-            } else {\n-                err.span_suggestion(\n-                    semi_sp,\n-                    \"use a comma to end a `match` arm expression\",\n-                    \",\",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            err.emit();\n+\n+            this.sess.emit_err(MatchArmBodyWithoutBraces {\n+                statements: span,\n+                arrow: arrow_span,\n+                num_statements: stmts.len(),\n+                sub: if stmts.len() > 1 {\n+                    MatchArmBodyWithoutBracesSugg::AddBraces {\n+                        left: span.shrink_to_lo(),\n+                        right: span.shrink_to_hi(),\n+                    }\n+                } else {\n+                    MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n+                },\n+            });\n             this.mk_expr_err(span)\n         };\n         // We might have either a `,` -> `;` typo, or a block without braces. We need\n@@ -2836,23 +2773,19 @@ impl<'a> Parser<'a> {\n             let expr = self.parse_struct_expr(qself.cloned(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n-                self.error_struct_lit_not_allowed_here(path.span, expr.span);\n+                self.sess.emit_err(StructLiteralNotAllowedHere {\n+                    span: expr.span,\n+                    sub: StructLiteralNotAllowedHereSugg {\n+                        left: path.span.shrink_to_lo(),\n+                        right: expr.span.shrink_to_hi(),\n+                    },\n+                });\n             }\n             return Some(expr);\n         }\n         None\n     }\n \n-    fn error_struct_lit_not_allowed_here(&self, lo: Span, sp: Span) {\n-        self.struct_span_err(sp, \"struct literals are not allowed here\")\n-            .multipart_suggestion(\n-                \"surround the struct literal with parentheses\",\n-                vec![(lo.shrink_to_lo(), \"(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())],\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n-    }\n-\n     pub(super) fn parse_struct_fields(\n         &mut self,\n         pth: ast::Path,"}, {"sha": "b7454d7bfc18e207344c2798daef198a8a8081a3", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -1,4 +1,6 @@\n-use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error, UseEmptyBlockNotSemi};\n+use crate::errors::{DocCommentDoesNotDocumentAnything, UseEmptyBlockNotSemi};\n+\n+use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, TrailingToken};\n \n@@ -13,7 +15,7 @@ use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, Vari\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, PResult, StashKey};\n+use rustc_errors::{struct_span_err, Applicability, IntoDiagnostic, PResult, StashKey};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n@@ -1584,7 +1586,10 @@ impl<'a> Parser<'a> {\n             token::CloseDelim(Delimiter::Brace) => {}\n             token::DocComment(..) => {\n                 let previous_span = self.prev_token.span;\n-                let mut err = self.span_err(self.token.span, Error::UselessDocComment);\n+                let mut err = DocCommentDoesNotDocumentAnything {\n+                    span: self.token.span,\n+                    missing_comma: None,\n+                };\n                 self.bump(); // consume the doc comment\n                 let comma_after_doc_seen = self.eat(&token::Comma);\n                 // `seen_comma` is always false, because we are inside doc block\n@@ -1593,18 +1598,13 @@ impl<'a> Parser<'a> {\n                     seen_comma = true;\n                 }\n                 if comma_after_doc_seen || self.token == token::CloseDelim(Delimiter::Brace) {\n-                    err.emit();\n+                    self.sess.emit_err(err);\n                 } else {\n                     if !seen_comma {\n                         let sp = self.sess.source_map().next_point(previous_span);\n-                        err.span_suggestion(\n-                            sp,\n-                            \"missing comma here\",\n-                            \",\",\n-                            Applicability::MachineApplicable,\n-                        );\n+                        err.missing_comma = Some(sp);\n                     }\n-                    return Err(err);\n+                    return Err(err.into_diagnostic(&self.sess.span_diagnostic));\n                 }\n             }\n             _ => {"}, {"sha": "2aebaf7c3af2acbce9a2761a69dfe8d6db7fabb6", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 54, "deletions": 60, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -13,7 +13,6 @@ mod ty;\n use crate::lexer::UnmatchedBrace;\n pub use attr_wrapper::AttrWrapper;\n pub use diagnostics::AttemptLocalParseRecovery;\n-use diagnostics::Error;\n pub(crate) use item::FnParseMode;\n pub use pat::{CommaRecoveryMode, RecoverColon, RecoverComma};\n pub use path::PathStyle;\n@@ -32,7 +31,7 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::PResult;\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, MultiSpan,\n+    Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, IntoDiagnostic, MultiSpan,\n };\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{Span, DUMMY_SP};\n@@ -41,6 +40,11 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use std::ops::Range;\n use std::{cmp, mem, slice};\n \n+use crate::errors::{\n+    DocCommentDoesNotDocumentAnything, IncorrectVisibilityRestriction, MismatchedClosingDelimiter,\n+    NonStringAbiLiteral,\n+};\n+\n bitflags::bitflags! {\n     struct Restrictions: u8 {\n         const STMT_EXPR         = 1 << 0;\n@@ -406,24 +410,39 @@ pub enum FollowedByType {\n     No,\n }\n \n-fn token_descr_opt(token: &Token) -> Option<&'static str> {\n-    Some(match token.kind {\n-        _ if token.is_special_ident() => \"reserved identifier\",\n-        _ if token.is_used_keyword() => \"keyword\",\n-        _ if token.is_unused_keyword() => \"reserved keyword\",\n-        token::DocComment(..) => \"doc comment\",\n-        _ => return None,\n-    })\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum TokenDescription {\n+    ReservedIdentifier,\n+    Keyword,\n+    ReservedKeyword,\n+    DocComment,\n }\n \n-pub(super) fn token_descr(token: &Token) -> String {\n-    let token_str = pprust::token_to_string(token);\n-    match token_descr_opt(token) {\n-        Some(prefix) => format!(\"{} `{}`\", prefix, token_str),\n-        _ => format!(\"`{}`\", token_str),\n+impl TokenDescription {\n+    pub fn from_token(token: &Token) -> Option<Self> {\n+        match token.kind {\n+            _ if token.is_special_ident() => Some(TokenDescription::ReservedIdentifier),\n+            _ if token.is_used_keyword() => Some(TokenDescription::Keyword),\n+            _ if token.is_unused_keyword() => Some(TokenDescription::ReservedKeyword),\n+            token::DocComment(..) => Some(TokenDescription::DocComment),\n+            _ => None,\n+        }\n     }\n }\n \n+pub(super) fn token_descr(token: &Token) -> String {\n+    let name = pprust::token_to_string(token).to_string();\n+\n+    let kind = TokenDescription::from_token(token).map(|kind| match kind {\n+        TokenDescription::ReservedIdentifier => \"reserved identifier\",\n+        TokenDescription::Keyword => \"keyword\",\n+        TokenDescription::ReservedKeyword => \"reserved keyword\",\n+        TokenDescription::DocComment => \"doc comment\",\n+    });\n+\n+    if let Some(kind) = kind { format!(\"{} `{}`\", kind, name) } else { format!(\"`{}`\", name) }\n+}\n+\n impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n@@ -518,9 +537,11 @@ impl<'a> Parser<'a> {\n \n     fn ident_or_err(&mut self) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n         self.token.ident().ok_or_else(|| match self.prev_token.kind {\n-            TokenKind::DocComment(..) => {\n-                self.span_err(self.prev_token.span, Error::UselessDocComment)\n+            TokenKind::DocComment(..) => DocCommentDoesNotDocumentAnything {\n+                span: self.prev_token.span,\n+                missing_comma: None,\n             }\n+            .into_diagnostic(&self.sess.span_diagnostic),\n             _ => self.expected_ident_found(),\n         })\n     }\n@@ -1144,7 +1165,9 @@ impl<'a> Parser<'a> {\n     fn parse_field_name(&mut self) -> PResult<'a, Ident> {\n         if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) = self.token.kind\n         {\n-            self.expect_no_suffix(self.token.span, \"a tuple index\", suffix);\n+            if let Some(suffix) = suffix {\n+                self.expect_no_tuple_index_suffix(self.token.span, suffix);\n+            }\n             self.bump();\n             Ok(Ident::new(symbol, self.prev_token.span))\n         } else {\n@@ -1342,23 +1365,8 @@ impl<'a> Parser<'a> {\n         let path = self.parse_path(PathStyle::Mod)?;\n         self.expect(&token::CloseDelim(Delimiter::Parenthesis))?; // `)`\n \n-        let msg = \"incorrect visibility restriction\";\n-        let suggestion = r##\"some possible visibility restrictions are:\n-`pub(crate)`: visible only on the current crate\n-`pub(super)`: visible only in the current module's parent\n-`pub(in path::to::module)`: visible only on the specified path\"##;\n-\n         let path_str = pprust::path_to_string(&path);\n-\n-        struct_span_err!(self.sess.span_diagnostic, path.span, E0704, \"{}\", msg)\n-            .help(suggestion)\n-            .span_suggestion(\n-                path.span,\n-                &format!(\"make this visible only to module `{}` with `in`\", path_str),\n-                format!(\"in {}\", path_str),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.sess.emit_err(IncorrectVisibilityRestriction { span: path.span, inner_str: path_str });\n \n         Ok(())\n     }\n@@ -1384,14 +1392,7 @@ impl<'a> Parser<'a> {\n             Err(Some(lit)) => match lit.kind {\n                 ast::LitKind::Err => None,\n                 _ => {\n-                    self.struct_span_err(lit.span, \"non-string ABI literal\")\n-                        .span_suggestion(\n-                            lit.span,\n-                            \"specify the ABI with a string literal\",\n-                            \"\\\"C\\\"\",\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.sess.emit_err(NonStringAbiLiteral { span: lit.span });\n                     None\n                 }\n             },\n@@ -1432,25 +1433,18 @@ pub(crate) fn make_unclosed_delims_error(\n     // `None` here means an `Eof` was found. We already emit those errors elsewhere, we add them to\n     // `unmatched_braces` only for error recovery in the `Parser`.\n     let found_delim = unmatched.found_delim?;\n-    let span: MultiSpan = if let Some(sp) = unmatched.unclosed_span {\n-        vec![unmatched.found_span, sp].into()\n-    } else {\n-        unmatched.found_span.into()\n-    };\n-    let mut err = sess.span_diagnostic.struct_span_err(\n-        span,\n-        &format!(\n-            \"mismatched closing delimiter: `{}`\",\n-            pprust::token_kind_to_string(&token::CloseDelim(found_delim)),\n-        ),\n-    );\n-    err.span_label(unmatched.found_span, \"mismatched closing delimiter\");\n-    if let Some(sp) = unmatched.candidate_span {\n-        err.span_label(sp, \"closing delimiter possibly meant for this\");\n-    }\n+    let mut spans = vec![unmatched.found_span];\n     if let Some(sp) = unmatched.unclosed_span {\n-        err.span_label(sp, \"unclosed delimiter\");\n-    }\n+        spans.push(sp);\n+    };\n+    let err = MismatchedClosingDelimiter {\n+        spans,\n+        delimiter: pprust::token_kind_to_string(&token::CloseDelim(found_delim)).to_string(),\n+        unmatched: unmatched.found_span,\n+        opening_candidate: unmatched.candidate_span,\n+        unclosed: unmatched.unclosed_span,\n+    }\n+    .into_diagnostic(&sess.span_diagnostic);\n     Some(err)\n }\n "}, {"sha": "542a1ac5dc65cc0b0d138d22112fe22a710bb586", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -1,5 +1,5 @@\n use super::{ForceCollect, Parser, PathStyle, TrailingToken};\n-use crate::parser::diagnostics::RemoveLet;\n+use crate::errors::RemoveLet;\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_ast::mut_visit::{noop_visit_pat, MutVisitor};\n use rustc_ast::ptr::P;"}, {"sha": "a61e77b7c3bfb599b7970b9d0ad210bc25e42c25", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 37, "deletions": 67, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -1,14 +1,18 @@\n-use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n-use super::diagnostics::{\n-    AttemptLocalParseRecovery, Error, InvalidVariableDeclaration, InvalidVariableDeclarationSub,\n-};\n+use super::attr::InnerAttrForbiddenReason;\n+use super::diagnostics::AttemptLocalParseRecovery;\n use super::expr::LhsExpr;\n use super::pat::RecoverComma;\n use super::path::PathStyle;\n use super::TrailingToken;\n use super::{\n     AttrWrapper, BlockMode, FnParseMode, ForceCollect, Parser, Restrictions, SemiColonMode,\n };\n+use crate::errors::{\n+    AssignmentElseNotAllowed, CompoundAssignmentExpressionInLet, ConstLetMutuallyExclusive,\n+    DocCommentDoesNotDocumentAnything, ExpectedStatementAfterOuterAttr, InvalidCurlyInLetElse,\n+    InvalidExpressionInLetElse, InvalidVariableDeclaration, InvalidVariableDeclarationSub,\n+    WrapExpressionInParentheses,\n+};\n use crate::maybe_whole;\n \n use rustc_ast as ast;\n@@ -112,11 +116,7 @@ impl<'a> Parser<'a> {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else.\n                 // This is not allowed, but point it out in a nice way.\n-                let mut err = self.struct_span_err(\n-                    e.span.to(bl.span),\n-                    \"<assignment> ... else { ... } is not allowed\",\n-                );\n-                err.emit();\n+                self.sess.emit_err(AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n             }\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n@@ -202,9 +202,12 @@ impl<'a> Parser<'a> {\n     fn error_outer_attrs(&self, attrs: &[Attribute]) {\n         if let [.., last] = attrs {\n             if last.is_doc_comment() {\n-                self.span_err(last.span, Error::UselessDocComment).emit();\n+                self.sess.emit_err(DocCommentDoesNotDocumentAnything {\n+                    span: last.span,\n+                    missing_comma: None,\n+                });\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                self.struct_span_err(last.span, \"expected statement after outer attribute\").emit();\n+                self.sess.emit_err(ExpectedStatementAfterOuterAttr { span: last.span });\n             }\n         }\n     }\n@@ -255,17 +258,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n \n         if self.token.is_keyword(kw::Const) && self.look_ahead(1, |t| t.is_ident()) {\n-            self.struct_span_err(\n-                lo.to(self.token.span),\n-                \"`const` and `let` are mutually exclusive\",\n-            )\n-            .span_suggestion(\n-                lo.to(self.token.span),\n-                \"remove `let`\",\n-                \"const\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n+            self.sess.emit_err(ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n             self.bump();\n         }\n \n@@ -363,44 +356,27 @@ impl<'a> Parser<'a> {\n     fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n         if let ast::ExprKind::Binary(op, ..) = init.kind {\n             if op.node.lazy() {\n-                let suggs = vec![\n-                    (init.span.shrink_to_lo(), \"(\".to_string()),\n-                    (init.span.shrink_to_hi(), \")\".to_string()),\n-                ];\n-                self.struct_span_err(\n-                    init.span,\n-                    &format!(\n-                        \"a `{}` expression cannot be directly assigned in `let...else`\",\n-                        op.node.to_string()\n-                    ),\n-                )\n-                .multipart_suggestion(\n-                    \"wrap the expression in parentheses\",\n-                    suggs,\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+                self.sess.emit_err(InvalidExpressionInLetElse {\n+                    span: init.span,\n+                    operator: op.node.to_string(),\n+                    sugg: WrapExpressionInParentheses {\n+                        left: init.span.shrink_to_lo(),\n+                        right: init.span.shrink_to_hi(),\n+                    },\n+                });\n             }\n         }\n     }\n \n     fn check_let_else_init_trailing_brace(&self, init: &ast::Expr) {\n         if let Some(trailing) = classify::expr_trailing_brace(init) {\n-            let err_span = trailing.span.with_lo(trailing.span.hi() - BytePos(1));\n-            let suggs = vec![\n-                (trailing.span.shrink_to_lo(), \"(\".to_string()),\n-                (trailing.span.shrink_to_hi(), \")\".to_string()),\n-            ];\n-            self.struct_span_err(\n-                err_span,\n-                \"right curly brace `}` before `else` in a `let...else` statement not allowed\",\n-            )\n-            .multipart_suggestion(\n-                \"try wrapping the expression in parentheses\",\n-                suggs,\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.sess.emit_err(InvalidCurlyInLetElse {\n+                span: trailing.span.with_lo(trailing.span.hi() - BytePos(1)),\n+                sugg: WrapExpressionInParentheses {\n+                    left: trailing.span.shrink_to_lo(),\n+                    right: trailing.span.shrink_to_hi(),\n+                },\n+            });\n         }\n     }\n \n@@ -409,18 +385,7 @@ impl<'a> Parser<'a> {\n         let eq_consumed = match self.token.kind {\n             token::BinOpEq(..) => {\n                 // Recover `let x <op>= 1` as `let x = 1`\n-                self.struct_span_err(\n-                    self.token.span,\n-                    \"can't reassign to an uninitialized variable\",\n-                )\n-                .span_suggestion_short(\n-                    self.token.span,\n-                    \"initialize the variable\",\n-                    \"=\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .help(\"if you meant to overwrite, remove the `let` binding\")\n-                .emit();\n+                self.sess.emit_err(CompoundAssignmentExpressionInLet { span: self.token.span });\n                 self.bump();\n                 true\n             }\n@@ -434,7 +399,12 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         let (attrs, block) = self.parse_inner_attrs_and_block()?;\n         if let [.., last] = &*attrs {\n-            self.error_on_forbidden_inner_attr(last.span, DEFAULT_INNER_ATTR_FORBIDDEN);\n+            self.error_on_forbidden_inner_attr(\n+                last.span,\n+                super::attr::InnerAttrPolicy::Forbidden(Some(\n+                    InnerAttrForbiddenReason::InCodeBlock,\n+                )),\n+            );\n         }\n         Ok(block)\n     }"}, {"sha": "b5962f76b7f4a54d467040610e72e191f243ad93", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -219,3 +219,18 @@ impl IntoDiagnostic<'_> for InvalidCharacterInCrateName<'_> {\n         diag\n     }\n }\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(session::expr_parentheses_needed, applicability = \"machine-applicable\")]\n+pub struct ExprParenthesesNeeded {\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}\n+\n+impl ExprParenthesesNeeded {\n+    pub fn surrounding(s: Span) -> Self {\n+        ExprParenthesesNeeded { left: s.shrink_to_lo(), right: s.shrink_to_hi() }\n+    }\n+}"}, {"sha": "d97e1df2a16509c2f6c50f88d7f54b16194ad46f", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -2,7 +2,9 @@\n //! It also serves as an input to the parser itself.\n \n use crate::config::CheckCfg;\n-use crate::errors::{FeatureDiagnosticForIssue, FeatureDiagnosticHelp, FeatureGateError};\n+use crate::errors::{\n+    ExprParenthesesNeeded, FeatureDiagnosticForIssue, FeatureDiagnosticHelp, FeatureGateError,\n+};\n use crate::lint::{\n     builtin::UNSTABLE_SYNTAX_PRE_EXPANSION, BufferedEarlyLint, BuiltinLintDiagnostics, Lint, LintId,\n };\n@@ -11,7 +13,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n-    fallback_fluent_bundle, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId,\n+    fallback_fluent_bundle, AddToDiagnostic, Diagnostic, DiagnosticBuilder, DiagnosticId,\n     DiagnosticMessage, EmissionGuarantee, ErrorGuaranteed, IntoDiagnostic, MultiSpan, StashKey,\n };\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n@@ -325,11 +327,7 @@ impl ParseSess {\n     /// Extend an error with a suggestion to wrap an expression with parentheses to allow the\n     /// parser to continue parsing the following operation as part of the same expression.\n     pub fn expr_parentheses_needed(&self, err: &mut Diagnostic, span: Span) {\n-        err.multipart_suggestion(\n-            \"parentheses are required to parse this as an expression\",\n-            vec![(span.shrink_to_lo(), \"(\".to_string()), (span.shrink_to_hi(), \")\".to_string())],\n-            Applicability::MachineApplicable,\n-        );\n+        ExprParenthesesNeeded::surrounding(span).add_to_diagnostic(err);\n     }\n \n     pub fn save_proc_macro_span(&self, span: Span) -> usize {"}, {"sha": "3d363cae47310783f90af7b02b6bff9ca10b99b9", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -671,3 +671,9 @@ enum ExampleEnum {\n     #[diag(typeck::ambiguous_lifetime_bound)]\n     Baz,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct RawIdentDiagnosticArg {\n+    pub r#type: String,\n+}"}, {"sha": "84ee5af42dea51945f66d32ef600faebb6cb2a97", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -633,3 +633,11 @@ struct BI {\n     #[suggestion_part(code = \"\")]\n     spans: Vec<Span>,\n }\n+\n+#[derive(Subdiagnostic)]\n+#[label(parser::add_paren)]\n+struct BJ {\n+    #[primary_span]\n+    span: Span,\n+    r#type: String,\n+}"}, {"sha": "b7533f41351da547ef1459befa9dfb057901e008", "filename": "src/test/ui/extenv/issue-55897.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -14,7 +14,7 @@ mod nonexistent_env {\n \n mod erroneous_literal {\n     include!(concat!(\"NON_EXISTENT\"suffix, \"/data.rs\"));\n-    //~^ ERROR suffixes on a string literal are invalid\n+    //~^ ERROR suffixes on string literals are invalid\n }\n \n fn main() {}"}, {"sha": "e2afe6f34c1210b61a251db9b6839cab61123389", "filename": "src/test/ui/extenv/issue-55897.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextenv%2Fissue-55897.stderr?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -6,7 +6,7 @@ LL |     include!(concat!(env!(\"NON_EXISTENT\"), \"/data.rs\"));\n    |\n    = note: this error originates in the macro `env` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: suffixes on a string literal are invalid\n+error: suffixes on string literals are invalid\n   --> $DIR/issue-55897.rs:16:22\n    |\n LL |     include!(concat!(\"NON_EXISTENT\"suffix, \"/data.rs\"));"}, {"sha": "b1d69dcd862605131a98083700b0692142dd0d54", "filename": "src/test/ui/issues/issue-22644.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -29,7 +29,7 @@ fn main() {\n                    < //~ ERROR `<` is interpreted as a start of generic\n                    5);\n \n-    println!(\"{}\", a as usize << long_name); //~ ERROR `<` is interpreted as a start of generic\n+    println!(\"{}\", a as usize << long_name); //~ ERROR `<<` is interpreted as a start of generic\n \n     println!(\"{}\", a: &mut 4); //~ ERROR expected type, found `4`\n }"}, {"sha": "45027afa7b62b0b04c318df78150ee1d635308a5", "filename": "src/test/ui/issues/issue-22644.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -95,7 +95,7 @@ LL |\n LL ~                    usize)\n    |\n \n-error: `<` is interpreted as a start of generic arguments for `usize`, not a shift\n+error: `<<` is interpreted as a start of generic arguments for `usize`, not a shift\n   --> $DIR/issue-22644.rs:32:31\n    |\n LL |     println!(\"{}\", a as usize << long_name);"}, {"sha": "cb01e4c18a114f8725f657c5c6f13cf95ca8fe4b", "filename": "src/test/ui/let-else/let-else-brace-before-else.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-brace-before-else.stderr?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -4,7 +4,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let Some(1) = { Some(1) } else {\n    |                             ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let Some(1) = ({ Some(1) }) else {\n    |                   +           +\n@@ -15,7 +15,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let Some(1) = loop { break Some(1) } else {\n    |                                        ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let Some(1) = (loop { break Some(1) }) else {\n    |                   +                      +\n@@ -26,7 +26,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let 2 = 1 + match 1 { n => n } else {\n    |                                  ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let 2 = 1 + (match 1 { n => n }) else {\n    |                 +                  +\n@@ -37,7 +37,7 @@ error: right curly brace `}` before `else` in a `let...else` statement not allow\n LL |     let Some(1) = unsafe { unsafe_fn() } else {\n    |                                        ^\n    |\n-help: try wrapping the expression in parentheses\n+help: wrap the expression in parentheses\n    |\n LL |     let Some(1) = (unsafe { unsafe_fn() }) else {\n    |                   +                      +"}, {"sha": "9724533c420c28c4037d3bd22125796c6e9dfa99", "filename": "src/test/ui/parser/bad-lit-suffixes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -1,18 +1,18 @@\n extern\n-    \"C\"suffix //~ ERROR suffixes on a string literal are invalid\n+    \"C\"suffix //~ ERROR suffixes on string literals are invalid\n     fn foo() {}\n \n extern\n-    \"C\"suffix //~ ERROR suffixes on a string literal are invalid\n+    \"C\"suffix //~ ERROR suffixes on string literals are invalid\n {}\n \n fn main() {\n-    \"\"suffix; //~ ERROR suffixes on a string literal are invalid\n-    b\"\"suffix; //~ ERROR suffixes on a byte string literal are invalid\n-    r#\"\"#suffix; //~ ERROR suffixes on a string literal are invalid\n-    br#\"\"#suffix; //~ ERROR suffixes on a byte string literal are invalid\n-    'a'suffix; //~ ERROR suffixes on a char literal are invalid\n-    b'a'suffix; //~ ERROR suffixes on a byte literal are invalid\n+    \"\"suffix; //~ ERROR suffixes on string literals are invalid\n+    b\"\"suffix; //~ ERROR suffixes on byte string literals are invalid\n+    r#\"\"#suffix; //~ ERROR suffixes on string literals are invalid\n+    br#\"\"#suffix; //~ ERROR suffixes on byte string literals are invalid\n+    'a'suffix; //~ ERROR suffixes on char literals are invalid\n+    b'a'suffix; //~ ERROR suffixes on byte literals are invalid\n \n     1234u1024; //~ ERROR invalid width `1024` for integer literal\n     1234i1024; //~ ERROR invalid width `1024` for integer literal"}, {"sha": "f74eef324450d1e74e3bc59b959dfe35e27c2d26", "filename": "src/test/ui/parser/bad-lit-suffixes.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -1,46 +1,46 @@\n-error: suffixes on a string literal are invalid\n+error: suffixes on string literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:2:5\n    |\n LL |     \"C\"suffix\n    |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on a string literal are invalid\n+error: suffixes on string literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:6:5\n    |\n LL |     \"C\"suffix\n    |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on a string literal are invalid\n+error: suffixes on string literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:10:5\n    |\n LL |     \"\"suffix;\n    |     ^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on a byte string literal are invalid\n+error: suffixes on byte string literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:11:5\n    |\n LL |     b\"\"suffix;\n    |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on a string literal are invalid\n+error: suffixes on string literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:12:5\n    |\n LL |     r#\"\"#suffix;\n    |     ^^^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on a byte string literal are invalid\n+error: suffixes on byte string literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:13:5\n    |\n LL |     br#\"\"#suffix;\n    |     ^^^^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on a char literal are invalid\n+error: suffixes on char literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:14:5\n    |\n LL |     'a'suffix;\n    |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on a byte literal are invalid\n+error: suffixes on byte literals are invalid\n   --> $DIR/bad-lit-suffixes.rs:15:5\n    |\n LL |     b'a'suffix;"}, {"sha": "3ec3ad8e977a8514dcba72c9abc3288e6ed9f16f", "filename": "src/test/ui/parser/inner-attr-after-doc-comment.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fparser%2Finner-attr-after-doc-comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09ae7846a272a500ff7145255f0de5556c0b8949/src%2Ftest%2Fui%2Fparser%2Finner-attr-after-doc-comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finner-attr-after-doc-comment.stderr?ref=09ae7846a272a500ff7145255f0de5556c0b8949", "patch": "@@ -7,7 +7,7 @@ LL | |  */\n    | |___- previous doc comment\n LL |\n LL |   #![recursion_limit=\"100\"]\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ not permitted following an outer attribute\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^^ not permitted following an outer doc comment\n LL |\n LL |   fn main() {}\n    |   ------------ the inner attribute doesn't annotate this function"}]}