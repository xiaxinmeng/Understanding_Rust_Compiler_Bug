{"sha": "fd0ad03902402d5bc23f9d04307388f3d6235961", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMGFkMDM5MDI0MDJkNWJjMjNmOWQwNDMwNzM4OGYzZDYyMzU5NjE=", "commit": {"author": {"name": "J. Ryan Stinnett", "email": "jryans@gmail.com", "date": "2020-12-31T02:23:19Z"}, "committer": {"name": "J. Ryan Stinnett", "email": "jryans@gmail.com", "date": "2021-01-08T07:15:03Z"}, "message": "Recursively document methods via `Deref` traits", "tree": {"sha": "5f7eed10fa3499f48b6c24d770620f1bd85437f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f7eed10fa3499f48b6c24d770620f1bd85437f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd0ad03902402d5bc23f9d04307388f3d6235961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0ad03902402d5bc23f9d04307388f3d6235961", "html_url": "https://github.com/rust-lang/rust/commit/fd0ad03902402d5bc23f9d04307388f3d6235961", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd0ad03902402d5bc23f9d04307388f3d6235961/comments", "author": {"login": "jryans", "id": 279572, "node_id": "MDQ6VXNlcjI3OTU3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/279572?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jryans", "html_url": "https://github.com/jryans", "followers_url": "https://api.github.com/users/jryans/followers", "following_url": "https://api.github.com/users/jryans/following{/other_user}", "gists_url": "https://api.github.com/users/jryans/gists{/gist_id}", "starred_url": "https://api.github.com/users/jryans/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jryans/subscriptions", "organizations_url": "https://api.github.com/users/jryans/orgs", "repos_url": "https://api.github.com/users/jryans/repos", "events_url": "https://api.github.com/users/jryans/events{/privacy}", "received_events_url": "https://api.github.com/users/jryans/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jryans", "id": 279572, "node_id": "MDQ6VXNlcjI3OTU3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/279572?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jryans", "html_url": "https://github.com/jryans", "followers_url": "https://api.github.com/users/jryans/followers", "following_url": "https://api.github.com/users/jryans/following{/other_user}", "gists_url": "https://api.github.com/users/jryans/gists{/gist_id}", "starred_url": "https://api.github.com/users/jryans/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jryans/subscriptions", "organizations_url": "https://api.github.com/users/jryans/orgs", "repos_url": "https://api.github.com/users/jryans/repos", "events_url": "https://api.github.com/users/jryans/events{/privacy}", "received_events_url": "https://api.github.com/users/jryans/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61c8aae0a9222b7d2481704094f85a0d8f6b333e", "url": "https://api.github.com/repos/rust-lang/rust/commits/61c8aae0a9222b7d2481704094f85a0d8f6b333e", "html_url": "https://github.com/rust-lang/rust/commit/61c8aae0a9222b7d2481704094f85a0d8f6b333e"}], "stats": {"total": 93, "additions": 90, "deletions": 3}, "files": [{"sha": "28e638a58a8a2e88e7a70e7cca5a455187146d14", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fd0ad03902402d5bc23f9d04307388f3d6235961/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0ad03902402d5bc23f9d04307388f3d6235961/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=fd0ad03902402d5bc23f9d04307388f3d6235961", "patch": "@@ -3548,9 +3548,6 @@ fn render_assoc_items(\n             );\n         }\n     }\n-    if let AssocItemRender::DerefFor { .. } = what {\n-        return;\n-    }\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.inner_impl().trait_.def_id() == cache.deref_trait_did);\n@@ -3560,6 +3557,12 @@ fn render_assoc_items(\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, cache);\n         }\n \n+        // If we were already one level into rendering deref methods, we don't want to render\n+        // anything after recursing into any further deref methods above.\n+        if let AssocItemRender::DerefFor { .. } = what {\n+            return;\n+        }\n+\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             traits.iter().partition(|t| t.inner_impl().synthetic);\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n@@ -3631,6 +3634,13 @@ fn render_deref_methods(\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n+        if let Some(type_did) = impl_.inner_impl().for_.def_id() {\n+            // `impl Deref<Target = S> for S`\n+            if did == type_did {\n+                // Avoid infinite cycles\n+                return;\n+            }\n+        }\n         render_assoc_items(w, cx, container_item, did, what, cache);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n@@ -4417,6 +4427,26 @@ fn sidebar_deref_methods(impl_: &Impl, v: &Vec<Impl>) -> String {\n                 out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", ret.join(\"\")));\n             }\n         }\n+\n+        // Recurse into any further impls that might exist for `target`\n+        if let Some(target_did) = target.def_id() {\n+            if let Some(target_impls) = c.impls.get(&target_did) {\n+                if let Some(target_deref_impl) = target_impls\n+                    .iter()\n+                    .filter(|i| i.inner_impl().trait_.is_some())\n+                    .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n+                {\n+                    if let Some(type_did) = impl_.inner_impl().for_.def_id() {\n+                        // `impl Deref<Target = S> for S`\n+                        if target_did == type_did {\n+                            // Avoid infinite cycles\n+                            return out;\n+                        }\n+                    }\n+                    out.push_str(&sidebar_deref_methods(target_deref_impl, target_impls));\n+                }\n+            }\n+        }\n     }\n \n     out"}, {"sha": "4cb518cbbbd5c14fd0057c91a03a71b0ffe0f582", "filename": "src/test/rustdoc-ui/deref-recursive-cycle.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd0ad03902402d5bc23f9d04307388f3d6235961/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0ad03902402d5bc23f9d04307388f3d6235961/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs?ref=fd0ad03902402d5bc23f9d04307388f3d6235961", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// #26207: Ensure `Deref` cycles are properly handled without errors.\n+\n+#[derive(Copy, Clone)]\n+struct S;\n+\n+impl std::ops::Deref for S {\n+    type Target = S;\n+\n+    fn deref(&self) -> &S {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    let s: S = *******S;\n+}"}, {"sha": "0d1e7fb1932c5bf706ca7c64126163ca294fe8f9", "filename": "src/test/rustdoc/deref-recursive.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fd0ad03902402d5bc23f9d04307388f3d6235961/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd0ad03902402d5bc23f9d04307388f3d6235961/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive.rs?ref=fd0ad03902402d5bc23f9d04307388f3d6235961", "patch": "@@ -0,0 +1,40 @@\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels if needed.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = Bar>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.bar\"]' 'pub fn bar(&self)'\n+// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = Baz>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.baz\"]' 'pub fn baz(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]' 'Methods from Deref<Target=Bar>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.bar\"]' 'bar'\n+// @has '-' '//*[@class=\"sidebar-title\"]' 'Methods from Deref<Target=Baz>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.baz\"]' 'baz'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+\n+pub struct Foo(Bar);\n+pub struct Bar(Baz);\n+pub struct Baz;\n+\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Bar { &self.0 }\n+}\n+\n+impl Deref for Bar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { &self.0 }\n+}\n+\n+impl Bar {\n+    /// This appears under `Foo` methods\n+    pub fn bar(&self) {}\n+}\n+\n+impl Baz {\n+    /// This should also appear in `Foo` methods when recursing\n+    pub fn baz(&self) {}\n+}"}]}