{"sha": "2b4bd0780bb98f4171dd6464a4f01065b8d85ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNGJkMDc4MGJiOThmNDE3MWRkNjQ2NGE0ZjAxMDY1YjhkODVmZmQ=", "commit": {"author": {"name": "SiegeLord", "email": "slabode@aim.com", "date": "2014-01-16T23:24:03Z"}, "committer": {"name": "SiegeLord", "email": "slabode@aim.com", "date": "2014-01-23T01:32:40Z"}, "message": "float_to_str_bytes_common can now handle exponential notation", "tree": {"sha": "85887b4fd5a178eda845b44343fa84cb46745fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85887b4fd5a178eda845b44343fa84cb46745fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd", "html_url": "https://github.com/rust-lang/rust/commit/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd/comments", "author": {"login": "SiegeLord", "id": 480550, "node_id": "MDQ6VXNlcjQ4MDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/480550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLord", "html_url": "https://github.com/SiegeLord", "followers_url": "https://api.github.com/users/SiegeLord/followers", "following_url": "https://api.github.com/users/SiegeLord/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLord/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLord/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLord/orgs", "repos_url": "https://api.github.com/users/SiegeLord/repos", "events_url": "https://api.github.com/users/SiegeLord/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLord/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SiegeLord", "id": 480550, "node_id": "MDQ6VXNlcjQ4MDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/480550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLord", "html_url": "https://github.com/SiegeLord", "followers_url": "https://api.github.com/users/SiegeLord/followers", "following_url": "https://api.github.com/users/SiegeLord/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLord/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLord/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLord/orgs", "repos_url": "https://api.github.com/users/SiegeLord/repos", "events_url": "https://api.github.com/users/SiegeLord/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLord/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fce792249e72a181f2ad52413b25b1db643c371f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce792249e72a181f2ad52413b25b1db643c371f", "html_url": "https://github.com/rust-lang/rust/commit/fce792249e72a181f2ad52413b25b1db643c371f"}], "stats": {"total": 94, "additions": 77, "deletions": 17}, "files": [{"sha": "e95ad7ca7f55bf37f889624d341d10cee993a886", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=2b4bd0780bb98f4171dd6464a4f01065b8d85ffd", "patch": "@@ -718,7 +718,7 @@ impl Float for f32 {\n #[inline]\n pub fn to_str(num: f32) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n@@ -732,7 +732,7 @@ pub fn to_str(num: f32) -> ~str {\n #[inline]\n pub fn to_str_hex(num: f32) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n@@ -748,7 +748,7 @@ pub fn to_str_hex(num: f32) -> ~str {\n #[inline]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n-                           strconv::SignNeg, strconv::DigAll)\n+                           strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n \n ///\n@@ -763,7 +763,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (~str, bool) {\n #[inline]\n pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n }\n \n@@ -779,7 +779,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> ~str {\n #[inline]\n pub fn to_str_digits(num: f32, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n }\n \n@@ -804,7 +804,7 @@ impl num::ToStrRadix for f32 {\n     #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n+            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\\n                             try to_str_radix_special() if those are expected\") }\n         r"}, {"sha": "33ee4acf58bb0e884d24f962e837e39671c557af", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=2b4bd0780bb98f4171dd6464a4f01065b8d85ffd", "patch": "@@ -720,7 +720,7 @@ impl Float for f64 {\n #[inline]\n pub fn to_str(num: f64) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 10u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n@@ -734,7 +734,7 @@ pub fn to_str(num: f64) -> ~str {\n #[inline]\n pub fn to_str_hex(num: f64) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, strconv::SignNeg, strconv::DigAll);\n+        num, 16u, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n     r\n }\n \n@@ -750,7 +750,7 @@ pub fn to_str_hex(num: f64) -> ~str {\n #[inline]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n     strconv::float_to_str_common(num, rdx, true,\n-                           strconv::SignNeg, strconv::DigAll)\n+                           strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false)\n }\n \n ///\n@@ -765,7 +765,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (~str, bool) {\n #[inline]\n pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigExact(dig), strconv::ExpNone, false);\n     r\n }\n \n@@ -781,7 +781,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> ~str {\n #[inline]\n pub fn to_str_digits(num: f64, dig: uint) -> ~str {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig));\n+        num, 10u, true, strconv::SignNeg, strconv::DigMax(dig), strconv::ExpNone, false);\n     r\n }\n \n@@ -806,7 +806,7 @@ impl num::ToStrRadix for f64 {\n     #[inline]\n     fn to_str_radix(&self, rdx: uint) -> ~str {\n         let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n+            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n         if special { fail!(\"number has a special value, \\\n                              try to_str_radix_special() if those are expected\") }\n         r"}, {"sha": "30abe86866e220b526089c26588ff0a9919c625d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4bd0780bb98f4171dd6464a4f01065b8d85ffd/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=2b4bd0780bb98f4171dd6464a4f01065b8d85ffd", "patch": "@@ -207,11 +207,13 @@ pub fn int_to_str_bytes_common<T:NumCast\n  * # Arguments\n  * - `num`           - The number to convert. Accepts any number that\n  *                     implements the numeric traits.\n- * - `radix`         - Base to use. Accepts only the values 2-36.\n+ * - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n+ *                     is used, then this base is only used for the significand. The exponent\n+ *                     itself always printed using a base of 10.\n  * - `negative_zero` - Whether to treat the special value `-0` as\n  *                     `-0` or as `+0`.\n  * - `sign`          - How to emit the sign. Options are:\n- *     - `SignNone`: No sign at all. Basically emits `abs(num)`.\n+ *     - `SignNone`: No sign at all. The exponent sign is also omitted.\n  *     - `SignNeg`:  Only `-` on negative values.\n  *     - `SignAll`:  Both `+` on positive, and `-` on negative numbers.\n  * - `digits`        - The amount of digits to use for emitting the\n@@ -220,6 +222,17 @@ pub fn int_to_str_bytes_common<T:NumCast\n  *                         fractions!\n  *     - `DigMax(uint)`:   Maximum N digits, truncating any trailing zeros.\n  *     - `DigExact(uint)`: Exactly N digits.\n+ * - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n+ *                    Options are:\n+ *     - `ExpNone`: Do not use the exponential notation.\n+ *     - `ExpDec`:  Use the exponential notation with the exponent having a base of 10,\n+ *                  and exponent sign being `'e'` or `'E'` depending on the value of\n+ *                  the `exp_upper` argument. E.g. the number 1000 would be printed as 1e3.\n+ *     - `ExpBin`:  Use the exponential notation with the exponent having a base of 2,\n+ *                  and exponent sign being `'p'` or `'P'` depending on the value of\n+ *                  the `exp_upper` argument. E.g. the number 8 would be printed as 1p3.\n+ * - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n+ *                     exponential notation is desired.\n  *\n  * # Return value\n  * A tuple containing the byte vector, and a boolean flag indicating\n@@ -229,12 +242,26 @@ pub fn int_to_str_bytes_common<T:NumCast\n  *\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n+ * - Fails if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n+ *   between digit and exponent sign `'e'`.\n+ * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n+ *   between digit and exponent sign `'p'`.\n  */\n pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n+        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n+        ) -> (~[u8], bool) {\n     assert!(2 <= radix && radix <= 36);\n+    match exp_format {\n+        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'e' as decimal exponent\", radix),\n+        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n+          => fail!(\"float_to_str_bytes_common: radix {} incompatible with \\\n+                    use of 'p' as binary exponent\", radix),\n+        _ => ()\n+    }\n \n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -260,6 +287,23 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n     let mut buf: ~[u8] = ~[];\n     let radix_gen: T   = cast(radix as int).unwrap();\n \n+    let (num, exp) = match exp_format {\n+        ExpNone => (num, 0i32),\n+        ExpDec | ExpBin => {\n+            if num == _0 {\n+                (num, 0i32)\n+            } else {\n+                let (exp, exp_base) = match exp_format {\n+                    ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n+                    ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n+                    ExpNone => unreachable!()\n+                };\n+\n+                (num / exp_base.powf(&exp), cast::<T, i32>(exp).unwrap())\n+            }\n+        }\n+    };\n+\n     // First emit the non-fractional part, looping at least once to make\n     // sure at least a `0` gets emitted.\n     let mut deccum = num.trunc();\n@@ -413,6 +457,21 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         }\n     }\n \n+    match exp_format {\n+        ExpNone => (),\n+        _ => {\n+            buf.push(match exp_format {\n+                ExpDec if exp_upper => 'E',\n+                ExpDec if !exp_upper => 'e',\n+                ExpBin if exp_upper => 'P',\n+                ExpBin if !exp_upper => 'p',\n+                _ => unreachable!()\n+            } as u8);\n+\n+            int_to_str_bytes_common(exp, 10, sign, |c| buf.push(c));\n+        }\n+    }\n+\n     (buf, false)\n }\n \n@@ -424,9 +483,10 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n                              Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n-        sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n+        sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n+        ) -> (~str, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n-                               negative_zero, sign, digits);\n+                               negative_zero, sign, digits, exp_format, exp_capital);\n     (str::from_utf8_owned(bytes).unwrap(), special)\n }\n "}]}