{"sha": "07a34293faeb10757944ce2fa9d552cc2b189583", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YTM0MjkzZmFlYjEwNzU3OTQ0Y2UyZmE5ZDU1MmNjMmIxODk1ODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-28T21:10:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-28T21:10:07Z"}, "message": "Auto merge of #40867 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 19 pull requests\n\n- Successful merges: #40317, #40516, #40524, #40606, #40683, #40751, #40778, #40813, #40818, #40819, #40824, #40828, #40832, #40833, #40837, #40849, #40852, #40853, #40865\n- Failed merges:", "tree": {"sha": "b25508bcd4d999249c34c2a4b751f2ca84d2a072", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b25508bcd4d999249c34c2a4b751f2ca84d2a072"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07a34293faeb10757944ce2fa9d552cc2b189583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07a34293faeb10757944ce2fa9d552cc2b189583", "html_url": "https://github.com/rust-lang/rust/commit/07a34293faeb10757944ce2fa9d552cc2b189583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07a34293faeb10757944ce2fa9d552cc2b189583/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccce2c6eb914a66571f60fa0afe8a46faa9fb3bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccce2c6eb914a66571f60fa0afe8a46faa9fb3bd", "html_url": "https://github.com/rust-lang/rust/commit/ccce2c6eb914a66571f60fa0afe8a46faa9fb3bd"}, {"sha": "61928a03564f7bf8201d8a29d5a37efbc64d6712", "url": "https://api.github.com/repos/rust-lang/rust/commits/61928a03564f7bf8201d8a29d5a37efbc64d6712", "html_url": "https://github.com/rust-lang/rust/commit/61928a03564f7bf8201d8a29d5a37efbc64d6712"}], "stats": {"total": 1566, "additions": 974, "deletions": 592}, "files": [{"sha": "68b2a239aff1babc31c622fd0631dd4abaac9c78", "filename": "appveyor.yml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -46,13 +46,13 @@ environment:\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-ninja\n     SCRIPT: python x.py test\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-win32-dwarf-rt_v5-rev1.7z\n+    MINGW_ARCHIVE: i686-6.2.0-release-win32-dwarf-rt_v5-rev1.7z\n     MINGW_DIR: mingw32\n   - MSYS_BITS: 64\n     SCRIPT: python x.py test\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-ninja\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror\n-    MINGW_ARCHIVE: x86_64-6.3.0-release-win32-seh-rt_v5-rev1.7z\n+    MINGW_ARCHIVE: x86_64-6.2.0-release-win32-seh-rt_v5-rev1.7z\n     MINGW_DIR: mingw64\n \n   # 32/64 bit MSVC and GNU deployment\n@@ -71,14 +71,14 @@ environment:\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-extended --enable-ninja\n     SCRIPT: python x.py dist\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-win32-dwarf-rt_v5-rev1.7z\n+    MINGW_ARCHIVE: i686-6.2.0-release-win32-dwarf-rt_v5-rev1.7z\n     MINGW_DIR: mingw32\n     DEPLOY: 1\n   - MSYS_BITS: 64\n     SCRIPT: python x.py dist\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-extended --enable-ninja\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror\n-    MINGW_ARCHIVE: x86_64-6.3.0-release-win32-seh-rt_v5-rev1.7z\n+    MINGW_ARCHIVE: x86_64-6.2.0-release-win32-seh-rt_v5-rev1.7z\n     MINGW_DIR: mingw64\n     DEPLOY: 1\n "}, {"sha": "4e95c6b41eca3388f54dd5f7787366ad2df637b5", "filename": "cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -1 +1 @@\n-Subproject commit c995e9eb5acf3976ae8674a0dc6d9e958053d9fd\n+Subproject commit 4e95c6b41eca3388f54dd5f7787366ad2df637b5"}, {"sha": "3a1a9c3e40d66066b708f48e2de876d38d7fa702", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -40,6 +40,14 @@ fn main() {\n         .arg(sysroot)\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n+\n+    // Pass the `rustbuild` feature flag to crates which rustbuild is\n+    // building. See the comment in bootstrap/lib.rs where this env var is\n+    // set for more details.\n+    if env::var_os(\"RUSTBUILD_UNSTABLE\").is_some() {\n+        cmd.arg(\"--cfg\").arg(\"rustbuild\");\n+    }\n+\n     std::process::exit(match cmd.status() {\n         Ok(s) => s.code().unwrap_or(1),\n         Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),"}, {"sha": "f8f641060c442674f4d7b9a03b8d8bcde5008fec", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -586,7 +586,7 @@ fn android_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n                       .arg(ADB_TEST_DIR));\n \n     let target_dir = format!(\"{}/{}\", ADB_TEST_DIR, target);\n-    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", &target_dir[..]]));\n+    build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", &target_dir]));\n \n     for f in t!(build.sysroot_libdir(compiler, target).read_dir()) {\n         let f = t!(f);"}, {"sha": "bd28a63c5f4dfb947edce379ac569c3c1af43519", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -196,7 +196,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n     let toknum = &s[content_end + 3 .. toknum_end];\n \n     let not_found = format!(\"didn't find token {:?} in the map\", toknum);\n-    let proto_tok = tokens.get(toknum).expect(&not_found[..]);\n+    let proto_tok = tokens.get(toknum).expect(&not_found);\n \n     let nm = Symbol::intern(content);\n \n@@ -304,14 +304,14 @@ fn main() {\n     let mut token_file = File::open(&Path::new(&args.next().unwrap())).unwrap();\n     let mut token_list = String::new();\n     token_file.read_to_string(&mut token_list).unwrap();\n-    let token_map = parse_token_list(&token_list[..]);\n+    let token_map = parse_token_list(&token_list);\n \n     let stdin = std::io::stdin();\n     let lock = stdin.lock();\n     let lines = lock.lines();\n     let antlr_tokens = lines.map(|l| parse_antlr_token(l.unwrap().trim(),\n                                                        &token_map,\n-                                                       &surrogate_pairs_pos[..],\n+                                                       &surrogate_pairs_pos,\n                                                        has_bom));\n \n     for antlr_tok in antlr_tokens {"}, {"sha": "8f0488f69369e5d905c18c906e1cfa5c459e34f0", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -1376,7 +1376,7 @@ mod tests {\n         thread::spawn(move || {\n                 check_links(&n);\n                 let a: &[_] = &[&1, &2, &3];\n-                assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n+                assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n             })\n             .join()\n             .ok()"}, {"sha": "d203b68c0dfd57fd1e8461968bf607a9089de01c", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -196,7 +196,7 @@ pub trait Drop {\n     fn drop(&mut self);\n }\n \n-/// The `Add` trait is used to specify the functionality of `+`.\n+/// The addition operator `+`.\n ///\n /// # Examples\n ///\n@@ -269,7 +269,7 @@ macro_rules! add_impl {\n \n add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `Sub` trait is used to specify the functionality of `-`.\n+/// The subtraction operator `-`.\n ///\n /// # Examples\n ///\n@@ -342,7 +342,7 @@ macro_rules! sub_impl {\n \n sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `Mul` trait is used to specify the functionality of `*`.\n+/// The multiplication operator `*`.\n ///\n /// # Examples\n ///\n@@ -464,7 +464,7 @@ macro_rules! mul_impl {\n \n mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `Div` trait is used to specify the functionality of `/`.\n+/// The division operator `/`.\n ///\n /// # Examples\n ///\n@@ -609,7 +609,7 @@ macro_rules! div_impl_float {\n \n div_impl_float! { f32 f64 }\n \n-/// The `Rem` trait is used to specify the functionality of `%`.\n+/// The remainder operator `%`.\n ///\n /// # Examples\n ///\n@@ -689,7 +689,7 @@ macro_rules! rem_impl_float {\n \n rem_impl_float! { f32 f64 }\n \n-/// The `Neg` trait is used to specify the functionality of unary `-`.\n+/// The unary negation operator `-`.\n ///\n /// # Examples\n ///\n@@ -768,7 +768,7 @@ macro_rules! neg_impl_unsigned {\n // neg_impl_unsigned! { usize u8 u16 u32 u64 }\n neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `Not` trait is used to specify the functionality of unary `!`.\n+/// The unary logical negation operator `!`.\n ///\n /// # Examples\n ///\n@@ -826,7 +826,7 @@ macro_rules! not_impl {\n \n not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-/// The `BitAnd` trait is used to specify the functionality of `&`.\n+/// The bitwise AND operator `&`.\n ///\n /// # Examples\n ///\n@@ -909,7 +909,7 @@ macro_rules! bitand_impl {\n \n bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-/// The `BitOr` trait is used to specify the functionality of `|`.\n+/// The bitwise OR operator `|`.\n ///\n /// # Examples\n ///\n@@ -992,7 +992,7 @@ macro_rules! bitor_impl {\n \n bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-/// The `BitXor` trait is used to specify the functionality of `^`.\n+/// The bitwise XOR operator `^`.\n ///\n /// # Examples\n ///\n@@ -1078,7 +1078,7 @@ macro_rules! bitxor_impl {\n \n bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-/// The `Shl` trait is used to specify the functionality of `<<`.\n+/// The left shift operator `<<`.\n ///\n /// # Examples\n ///\n@@ -1181,7 +1181,7 @@ macro_rules! shl_impl_all {\n \n shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n \n-/// The `Shr` trait is used to specify the functionality of `>>`.\n+/// The right shift operator `>>`.\n ///\n /// # Examples\n ///\n@@ -1284,7 +1284,7 @@ macro_rules! shr_impl_all {\n \n shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n \n-/// The `AddAssign` trait is used to specify the functionality of `+=`.\n+/// The addition assignment operator `+=`.\n ///\n /// # Examples\n ///\n@@ -1340,7 +1340,7 @@ macro_rules! add_assign_impl {\n \n add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `SubAssign` trait is used to specify the functionality of `-=`.\n+/// The subtraction assignment operator `-=`.\n ///\n /// # Examples\n ///\n@@ -1396,7 +1396,7 @@ macro_rules! sub_assign_impl {\n \n sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `MulAssign` trait is used to specify the functionality of `*=`.\n+/// The multiplication assignment operator `*=`.\n ///\n /// # Examples\n ///\n@@ -1441,7 +1441,7 @@ macro_rules! mul_assign_impl {\n \n mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `DivAssign` trait is used to specify the functionality of `/=`.\n+/// The division assignment operator `/=`.\n ///\n /// # Examples\n ///\n@@ -1485,7 +1485,7 @@ macro_rules! div_assign_impl {\n \n div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `RemAssign` trait is used to specify the functionality of `%=`.\n+/// The remainder assignment operator `%=`.\n ///\n /// # Examples\n ///\n@@ -1529,7 +1529,7 @@ macro_rules! rem_assign_impl {\n \n rem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n-/// The `BitAndAssign` trait is used to specify the functionality of `&=`.\n+/// The bitwise AND assignment operator `&=`.\n ///\n /// # Examples\n ///\n@@ -1615,7 +1615,7 @@ macro_rules! bitand_assign_impl {\n \n bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-/// The `BitOrAssign` trait is used to specify the functionality of `|=`.\n+/// The bitwise OR assignment operator `|=`.\n ///\n /// # Examples\n ///\n@@ -1659,7 +1659,7 @@ macro_rules! bitor_assign_impl {\n \n bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-/// The `BitXorAssign` trait is used to specify the functionality of `^=`.\n+/// The bitwise XOR assignment operator `^=`.\n ///\n /// # Examples\n ///\n@@ -1703,7 +1703,7 @@ macro_rules! bitxor_assign_impl {\n \n bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-/// The `ShlAssign` trait is used to specify the functionality of `<<=`.\n+/// The left shift assignment operator `<<=`.\n ///\n /// # Examples\n ///\n@@ -1768,7 +1768,7 @@ macro_rules! shl_assign_impl_all {\n \n shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n \n-/// The `ShrAssign` trait is used to specify the functionality of `>>=`.\n+/// The right shift assignment operator `>>=`.\n ///\n /// # Examples\n ///"}, {"sha": "3612ee65bca0dba78c5ad3fd35e51bbba3b3340e", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -498,32 +498,40 @@ fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n #[cold]\n fn break_patterns<T>(v: &mut [T]) {\n     let len = v.len();\n-\n     if len >= 8 {\n-        // A random number will be taken modulo this one. The modulus is a power of two so that we\n-        // can simply take bitwise \"and\", thus avoiding costly CPU operations.\n-        let modulus = (len / 4).next_power_of_two();\n-        debug_assert!(modulus >= 1 && modulus <= len / 2);\n-\n-        // Pseudorandom number generation from the \"Xorshift RNGs\" paper by George Marsaglia.\n-        let mut random = len;\n-        random ^= random << 13;\n-        random ^= random >> 17;\n-        random ^= random << 5;\n-        random &= modulus - 1;\n-        debug_assert!(random < len / 2);\n-\n-        // The first index.\n-        let a = len / 4 * 2;\n-        debug_assert!(a >= 1 && a < len - 2);\n-\n-        // The second index.\n-        let b = len / 4 + random;\n-        debug_assert!(b >= 1 && b < len - 2);\n-\n-        // Swap neighbourhoods of `a` and `b`.\n+        // Pseudorandom number generator from the \"Xorshift RNGs\" paper by George Marsaglia.\n+        let mut random = len as u32;\n+        let mut gen_u32 = || {\n+            random ^= random << 13;\n+            random ^= random >> 17;\n+            random ^= random << 5;\n+            random\n+        };\n+        let mut gen_usize = || {\n+            if mem::size_of::<usize>() <= 4 {\n+                gen_u32() as usize\n+            } else {\n+                (((gen_u32() as u64) << 32) | (gen_u32() as u64)) as usize\n+            }\n+        };\n+\n+        // Take random numbers modulo this number.\n+        // The number fits into `usize` because `len` is not greater than `isize::MAX`.\n+        let modulus = len.next_power_of_two();\n+\n+        // Some pivot candidates will be in the nearby of this index. Let's randomize them.\n+        let pos = len / 4 * 2;\n+\n         for i in 0..3 {\n-            v.swap(a - 1 + i, b - 1 + i);\n+            // Generate a random number modulo `len`. However, in order to avoid costly operations\n+            // we first take it modulo a power of two, and then decrease by `len` until it fits\n+            // into the range `[0, len - 1]`.\n+            let mut other = gen_usize() & (modulus - 1);\n+            while other >= len {\n+                other -= len;\n+            }\n+\n+            v.swap(pos - 1 + i, other);\n         }\n     }\n }"}, {"sha": "0d66d0e93aa85a5344706486479c1658d07fec3c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -35,6 +35,39 @@ pub mod pattern;\n /// [`from_str`]: #tymethod.from_str\n /// [`str`]: ../../std/primitive.str.html\n /// [`parse`]: ../../std/primitive.str.html#method.parse\n+///\n+/// # Examples\n+///\n+/// Basic implementation of `FromStr` on an example `Point` type:\n+///\n+/// ```\n+/// use std::str::FromStr;\n+/// use std::num::ParseIntError;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32\n+/// }\n+///\n+/// impl FromStr for Point {\n+///     type Err = ParseIntError;\n+///\n+///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n+///         let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\n+///                                  .split(\",\")\n+///                                  .collect();\n+///\n+///         let x_fromstr = coords[0].parse::<i32>()?;\n+///         let y_fromstr = coords[1].parse::<i32>()?;\n+///\n+///         Ok(Point { x: x_fromstr, y: y_fromstr })\n+///     }\n+/// }\n+///\n+/// let p = Point::from_str(\"(1,2)\");\n+/// assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait FromStr: Sized {\n     /// The associated error which can be returned from parsing.\n@@ -101,7 +134,9 @@ impl FromStr for bool {\n     }\n }\n \n-/// An error returned when parsing a `bool` from a string fails.\n+/// An error returned when parsing a `bool` using [`from_str`] fails\n+///\n+/// [`from_str`]: ../../std/primitive.bool.html#method.from_str\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError { _priv: () }"}, {"sha": "1b2c7775185f78d9dbf9e318236f8d3e4e5c0426", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -554,7 +554,7 @@ impl<'a> LabelText<'a> {\n     pub fn to_dot_string(&self) -> String {\n         match self {\n             &LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n-            &EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s[..])),\n+            &EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s)),\n             &HtmlStr(ref s) => format!(\"<{}>\", s),\n         }\n     }\n@@ -587,7 +587,7 @@ impl<'a> LabelText<'a> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(&suffix[..]);\n+        prefix.push_str(&suffix);\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -878,7 +878,7 @@ mod tests {\n         type Node = Node;\n         type Edge = &'a Edge;\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(&self.name[..]).unwrap()\n+            Id::new(self.name).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)"}, {"sha": "05a2d197356ef253dfd985166576619ac9b6947f", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -1 +1 @@\n-Subproject commit 64d954c6a76e896fbf7ed5c17e77c40e388abe84\n+Subproject commit 05a2d197356ef253dfd985166576619ac9b6947f"}, {"sha": "5aea2bcaa4f5c5fd5f4979df6ddb5183f4a9dcc5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -75,7 +75,6 @@ pub enum DepNode<D: Clone + Debug> {\n     CoherenceCheckImpl(D),\n     CoherenceOverlapCheck(D),\n     CoherenceOverlapCheckSpecial(D),\n-    CoherenceOverlapInherentCheck(D),\n     CoherenceOrphanCheck(D),\n     Variance,\n     WfCheck(D),\n@@ -252,7 +251,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n             CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n-            CoherenceOverlapInherentCheck(ref d) => op(d).map(CoherenceOverlapInherentCheck),\n             CoherenceOrphanCheck(ref d) => op(d).map(CoherenceOrphanCheck),\n             WfCheck(ref d) => op(d).map(WfCheck),\n             TypeckItemType(ref d) => op(d).map(TypeckItemType),"}, {"sha": "b6a2360211cac92610410d081de314d4c45a2148", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -81,21 +81,6 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n-\n-    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n-    /// This is considered a write to `k`.\n-    ///\n-    /// NOTE: Caution is required when using this method. You should\n-    /// be sure that nobody is **reading from the vector** while you\n-    /// are writing to it. Eventually, it'd be nice to remove this.\n-    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n-        where M: DepTrackingMapConfig<Value=Vec<E>>\n-    {\n-        self.write(&k);\n-        self.map.entry(k)\n-                .or_insert(Vec::new())\n-                .push(elem);\n-    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "5a0fbf8efb70778cc07954fe2c60d8436b1d7e0b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -1336,7 +1336,7 @@ trait SecondTrait : FirstTrait {\n \n E0398: r##\"\n In Rust 1.3, the default object lifetime bounds are expected to change, as\n-described in RFC #1156 [1]. You are getting a warning because the compiler\n+described in [RFC 1156]. You are getting a warning because the compiler\n thinks it is possible that this change will cause a compilation error in your\n code. It is possible, though unlikely, that this is a false alarm.\n \n@@ -1365,7 +1365,7 @@ fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }\n This explicitly states that you expect the trait object `SomeTrait` to contain\n references (with a maximum lifetime of `'a`).\n \n-[1]: https://github.com/rust-lang/rfcs/pull/1156\n+[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\n \"##,\n \n E0452: r##\"\n@@ -1771,6 +1771,7 @@ This pattern is incorrect because, because the type of `foo` is a function\n **item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n is a function pointer, which is not zero-sized.\n This pattern should be rewritten. There are a few possible ways to do this:\n+\n - change the original fn declaration to match the expected signature,\n   and do the cast in the fn body (the prefered option)\n - cast the fn item fo a fn pointer before calling transmute, as shown here:"}, {"sha": "e760f7efc93d912645454213f9b42b5707836261", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -55,7 +55,7 @@ impl Fingerprint {\n impl Encodable for Fingerprint {\n     #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        for &byte in &self.0[..] {\n+        for &byte in &self.0 {\n             s.emit_u8(byte)?;\n         }\n         Ok(())\n@@ -66,7 +66,7 @@ impl Decodable for Fingerprint {\n     #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Fingerprint, D::Error> {\n         let mut result = Fingerprint([0u8; FINGERPRINT_LENGTH]);\n-        for byte in &mut result.0[..] {\n+        for byte in &mut result.0 {\n             *byte = d.read_u8()?;\n         }\n         Ok(result)"}, {"sha": "20bf241a99906e3afe1a5196fb29718bc88f9cc1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -40,7 +40,6 @@ use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n use std::fmt;\n-use std::ops::Deref;\n use syntax::attr;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -485,7 +484,7 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n                 Allow => bug!(\"earlier conditional return should handle Allow case\")\n             };\n             let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str().deref() == name {\n+            if lint_flag_val.as_str() == name {\n                 err.note(&format!(\"requested on the command line with `{} {}`\",\n                                   flag, hyphen_case_lint_name));\n             } else {\n@@ -496,7 +495,7 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n         },\n         Node(lint_attr_name, src) => {\n             def = Some(src);\n-            if lint_attr_name.as_str().deref() != name {\n+            if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n                 err.note(&format!(\"#[{}({})] implied by #[{}({})]\",\n                                   level_str, name, level_str, lint_attr_name));"}, {"sha": "8bc0cf2577b5db05761ebbbf9a4b966875383605", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -176,7 +176,6 @@ pub trait CrateStore {\n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n@@ -310,7 +309,6 @@ impl CrateStore for DummyCrateStore {\n         { bug!(\"item_generics_cloned\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }"}, {"sha": "4354ed6817ae96376db2640305c638b9f9567b34", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -536,7 +536,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 if !self.stability.borrow().active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n-                                               &feature.as_str(), &r),\n+                                               feature.as_str(), &r),\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n                     emit_feature_err(&self.sess.parse_sess, &feature.as_str(), span,"}, {"sha": "d8ca30477205c53ccfcfd0e5bc61dab9c16828ae", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -139,6 +139,21 @@ pub enum AutoBorrow<'tcx> {\n     RawPtr(hir::Mutability),\n }\n \n+/// Information for `CoerceUnsized` impls, storing information we\n+/// have computed about the coercion.\n+///\n+/// This struct can be obtained via the `coerce_impl_info` query.\n+/// Demanding this struct also has the side-effect of reporting errors\n+/// for inappropriate impls.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub struct CoerceUnsizedInfo {\n+    /// If this is a \"custom coerce\" impl, then what kind of custom\n+    /// coercion is it? This applies to impls of `CoerceUnsized` for\n+    /// structs, primarily, where we store a bit of info about which\n+    /// fields need to be coerced.\n+    pub custom_kind: Option<CustomCoerceUnsized>\n+}\n+\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced."}, {"sha": "5a57b0072107c666e6c504f2dc39ab37718513a7", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -13,7 +13,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use middle::const_val::ConstVal;\n use middle::privacy::AccessLevels;\n use mir;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n@@ -177,9 +177,15 @@ impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::coherent_inherent_impls<'tcx> {\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n+    fn describe(_: TyCtxt, k: CrateNum) -> String {\n+        format!(\"all inherent impls defined in crate `{:?}`\", k)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"coherence checking all inherent impls\")\n+        format!(\"check for overlap between inherent impls defined in this crate\")\n     }\n }\n \n@@ -375,7 +381,7 @@ define_maps! { <'tcx>\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: InherentImpls(DefId) -> Vec<DefId>,\n+    pub inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from the def-id of a function/method or const/static\n     /// to its MIR. Mutation is done at an item granularity to\n@@ -400,14 +406,22 @@ define_maps! { <'tcx>\n     pub closure_type: ItemSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub custom_coerce_unsized_kind: ItemSignature(DefId)\n-        -> ty::adjustment::CustomCoerceUnsized,\n+    pub coerce_unsized_info: ItemSignature(DefId)\n+        -> ty::adjustment::CoerceUnsizedInfo,\n \n     pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n     pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    pub coherent_inherent_impls: coherent_inherent_impls_dep_node(CrateNum) -> (),\n+    /// Gets a complete map from all types to their inherent impls.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    pub crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+\n+    /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n+    /// Not meant to be used directly outside of coherence.\n+    /// (Defined only for LOCAL_CRATE)\n+    pub crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n@@ -423,7 +437,7 @@ fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n     DepNode::CoherenceCheckTrait(def_id)\n }\n \n-fn coherent_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n+fn crate_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Coherence\n }\n "}, {"sha": "6a4e7db21dd127d2d20bf57cb32a2517e4b1d0d1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -31,7 +31,7 @@ use ty::subst::{Subst, Substs};\n use ty::util::IntTypeExt;\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, FxHashMap};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -2057,8 +2057,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        queries::custom_coerce_unsized_kind::get(self, DUMMY_SP, did)\n+    pub fn coerce_unsized_info(self, did: DefId) -> adjustment::CoerceUnsizedInfo {\n+        queries::coerce_unsized_info::get(self, DUMMY_SP, did)\n     }\n \n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n@@ -2348,34 +2348,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Populates the type context with all the inherent implementations for\n-    /// the given type if necessary.\n-    pub fn populate_inherent_implementations_for_type_if_necessary(self,\n-                                                                   span: Span,\n-                                                                   type_id: DefId) {\n-        if type_id.is_local() {\n-            // Make sure coherence of inherent impls ran already.\n-            ty::queries::coherent_inherent_impls::force(self, span, LOCAL_CRATE);\n-            return\n-        }\n-\n-        // The type is not local, hence we are reading this out of\n-        // metadata and don't need to track edges.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        if self.populated_external_types.borrow().contains(&type_id) {\n-            return\n-        }\n-\n-        debug!(\"populate_inherent_implementations_for_type_if_necessary: searching for {:?}\",\n-               type_id);\n-\n-        let inherent_impls = self.sess.cstore.inherent_implementations_for_type(type_id);\n-\n-        self.maps.inherent_impls.borrow_mut().insert(type_id, inherent_impls);\n-        self.populated_external_types.borrow_mut().insert(type_id);\n-    }\n-\n     /// Populates the type context with all the implementations for the given\n     /// trait if necessary.\n     pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n@@ -2640,3 +2612,16 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         ..*providers\n     };\n }\n+\n+\n+/// A map for the local crate mapping each type to a vector of its\n+/// inherent impls. This is not meant to be used outside of coherence;\n+/// rather, you should request the vector for a specific type via\n+/// `ty::queries::inherent_impls::get(def_id)` so as to minimize your\n+/// dependencies (constructing this map requires touching the entire\n+/// crate).\n+#[derive(Clone, Debug)]\n+pub struct CrateInherentImpls {\n+    pub inherent_impls: DefIdMap<Rc<Vec<DefId>>>,\n+}\n+"}, {"sha": "b728d4d534516672e436312a336f40f627017943", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -267,11 +267,11 @@ pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved[..]));\n+    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[..]));\n+    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned));\n \n     // Second, build parents from the moved and assigned.\n     for m in &moved {\n@@ -291,14 +291,14 @@ pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents[..]));\n+    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, &parents[..]));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved[..]));\n+    moved.retain(|f| non_member(*f, &parents));\n+    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved));\n \n-    assigned.retain(|f| non_member(*f, &parents[..]));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[..]));\n+    assigned.retain(|f| non_member(*f, &parents));\n+    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in &moved {\n@@ -316,16 +316,16 @@ pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved[..]));\n+    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, &parents[..]) &&\n-            non_member(mpi, &moved[..]) &&\n-            non_member(mpi, &assigned[..])\n+        Just(mpi) => non_member(mpi, &parents) &&\n+            non_member(mpi, &moved) &&\n+            non_member(mpi, &assigned)\n     });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved[..]));\n+    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;"}, {"sha": "59c3e68aadab2b4f2b9182f76334af3b30e92c19", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -112,7 +112,7 @@ fn borrowck_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, body_id: hir::BodyId) {\n                                                  &flowed_moves.move_data,\n                                                  owner_id);\n \n-    check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans[..], body);\n+    check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,"}, {"sha": "e3a2bfa392738586fe06cd374082d3222c6bf50d", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&lp);\n-            set.push_str(&loan_str[..]);\n+            set.push_str(&loan_str);\n             saw_some = true;\n             true\n         });"}, {"sha": "c1dc5f5f7a2b8d10e0f5a99565480dfab83f9993", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -680,10 +680,10 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     }).collect();\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n     let matrix = Matrix(m.iter().flat_map(|r| {\n-        specialize(cx, &r[..], &ctor, &wild_patterns)\n+        specialize(cx, &r, &ctor, &wild_patterns)\n     }).collect());\n     match specialize(cx, v, &ctor, &wild_patterns) {\n-        Some(v) => match is_useful(cx, &matrix, &v[..], witness) {\n+        Some(v) => match is_useful(cx, &matrix, &v, witness) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses.into_iter()\n                     .map(|witness| witness.apply_constructor(cx, &ctor, lty))"}, {"sha": "9d55281d019d9ee579a4d755e47b6303d674ec04", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -311,7 +311,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         for &(pat, hir_pat) in pats {\n             let v = vec![pat];\n \n-            match is_useful(cx, &seen, &v[..], LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v, LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         hir::MatchSource::IfLetDesugar { .. } => {"}, {"sha": "c03c2890ba34c6cb4723c3eb00ed514a8bf2e5a5", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -91,17 +91,17 @@ impl<A: Array> Deref for AccumulateVec<A> {\n     type Target = [A::Element];\n     fn deref(&self) -> &Self::Target {\n         match *self {\n-            AccumulateVec::Array(ref v) => &v[..],\n-            AccumulateVec::Heap(ref v) => &v[..],\n+            AccumulateVec::Array(ref v) => v,\n+            AccumulateVec::Heap(ref v) => v,\n         }\n     }\n }\n \n impl<A: Array> DerefMut for AccumulateVec<A> {\n     fn deref_mut(&mut self) -> &mut [A::Element] {\n         match *self {\n-            AccumulateVec::Array(ref mut v) => &mut v[..],\n-            AccumulateVec::Heap(ref mut v) => &mut v[..],\n+            AccumulateVec::Array(ref mut v) => v,\n+            AccumulateVec::Heap(ref mut v) => v,\n         }\n     }\n }"}, {"sha": "cf54229fa7f52e59130cbd39c43ee7656c90d1f4", "filename": "src/librustc_data_structures/base_n.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -48,7 +48,7 @@ pub fn encode(n: u64, base: u64) -> String {\n #[test]\n fn test_encode() {\n     fn test(n: u64, base: u64) {\n-        assert_eq!(Ok(n), u64::from_str_radix(&encode(n, base)[..], base as u32));\n+        assert_eq!(Ok(n), u64::from_str_radix(&encode(n, base), base as u32));\n     }\n \n     for base in 2..37 {"}, {"sha": "9d97a83f693c32f7cb528def5b49ff3ac47f1178", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -35,7 +35,7 @@ pub struct Blake2bCtx {\n impl ::std::fmt::Debug for Blake2bCtx {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n         try!(write!(fmt, \"hash: \"));\n-        for v in &self.h[..] {\n+        for v in &self.h {\n             try!(write!(fmt, \"{:x}\", v));\n         }\n         Ok(())"}, {"sha": "572ce98d3ae8e30a0f19a8b9a69b887c9873eb3e", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -91,13 +91,13 @@ impl<T: Idx> IdxSet<T> {\n impl<T: Idx> Deref for IdxSetBuf<T> {\n     type Target = IdxSet<T>;\n     fn deref(&self) -> &IdxSet<T> {\n-        unsafe { IdxSet::from_slice(&self.bits[..]) }\n+        unsafe { IdxSet::from_slice(&self.bits) }\n     }\n }\n \n impl<T: Idx> DerefMut for IdxSetBuf<T> {\n     fn deref_mut(&mut self) -> &mut IdxSet<T> {\n-        unsafe { IdxSet::from_slice_mut(&mut self.bits[..]) }\n+        unsafe { IdxSet::from_slice_mut(&mut self.bits) }\n     }\n }\n \n@@ -135,11 +135,11 @@ impl<T: Idx> IdxSet<T> {\n     }\n \n     pub fn words(&self) -> &[Word] {\n-        &self.bits[..]\n+        &self.bits\n     }\n \n     pub fn words_mut(&mut self) -> &mut [Word] {\n-        &mut self.bits[..]\n+        &mut self.bits\n     }\n \n     pub fn clone_from(&mut self, other: &IdxSet<T>) {"}, {"sha": "4873b21c548740f98480346794ea5abc76309c64", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -258,10 +258,7 @@ fn keep_hygiene_data(sess: &Session) -> bool {\n }\n \n fn keep_ast(sess: &Session) -> bool {\n-    sess.opts.debugging_opts.keep_ast ||\n-    sess.opts.debugging_opts.save_analysis ||\n-    sess.opts.debugging_opts.save_analysis_csv ||\n-    sess.opts.debugging_opts.save_analysis_api\n+    sess.opts.debugging_opts.keep_ast || ::save_analysis(sess)\n }\n \n /// The name used for source code that doesn't originate in a file"}, {"sha": "c90dde3a5f6e0232694ae37dec7e11e70c91b446", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -67,6 +67,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n \n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n+use rustc_save_analysis::DumpHandler;\n use rustc_trans::back::link;\n use rustc_trans::back::write::{create_target_machine, RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n@@ -233,7 +234,7 @@ fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>)\n // Extract input (string or file and optional path) from matches.\n fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n     if free_matches.len() == 1 {\n-        let ifile = &free_matches[0][..];\n+        let ifile = &free_matches[0];\n         if ifile == \"-\" {\n             let mut src = String::new();\n             io::stdin().read_to_string(&mut src).unwrap();\n@@ -507,8 +508,9 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                                         state.expanded_crate.unwrap(),\n                                         state.analysis.unwrap(),\n                                         state.crate_name.unwrap(),\n-                                        state.out_dir,\n-                                        save_analysis_format(state.session))\n+                                        DumpHandler::new(save_analysis_format(state.session),\n+                                                         state.out_dir,\n+                                                         state.crate_name.unwrap()))\n                 });\n             };\n             control.after_analysis.run_callback_on_error = true;\n@@ -800,7 +802,7 @@ Available lint options:\n         for lint in lints {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(&name[..]),\n+                     padded(&name),\n                      lint.default_level.as_str(),\n                      lint.desc);\n         }\n@@ -838,7 +840,7 @@ Available lint options:\n                          .map(|x| x.to_string().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>()\n                          .join(\", \");\n-            println!(\"    {}  {}\", padded(&name[..]), desc);\n+            println!(\"    {}  {}\", padded(&name), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -945,7 +947,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n                                                  .into_iter()\n                                                  .map(|x| x.opt_group)\n                                                  .collect();\n-    let matches = match getopts::getopts(&args[..], &all_groups) {\n+    let matches = match getopts::getopts(&args, &all_groups) {\n         Ok(m) => m,\n         Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n     };\n@@ -1084,7 +1086,7 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                       format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n             for note in &xs {\n                 handler.emit(&MultiSpan::new(),\n-                             &note[..],\n+                             &note,\n                              errors::Level::Note);\n             }\n             if match env::var_os(\"RUST_BACKTRACE\") {"}, {"sha": "18dc504ca8aa913568bbf5fd48fae2c8ff5728db", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -589,7 +589,7 @@ impl UserIdentifiedItem {\n                                        -> NodesMatchingUII<'a, 'hir> {\n         match *self {\n             ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) => NodesMatchingSuffix(map.nodes_matching_suffix(&parts[..])),\n+            ItemViaPath(ref parts) => NodesMatchingSuffix(map.nodes_matching_suffix(&parts)),\n         }\n     }\n \n@@ -600,7 +600,7 @@ impl UserIdentifiedItem {\n                                   user_option,\n                                   self.reconstructed_input(),\n                                   is_wrong_because);\n-            sess.fatal(&message[..])\n+            sess.fatal(&message)\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -771,7 +771,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n         r.map_err(|ioerr| {\n             io::Error::new(io::ErrorKind::Other,\n-                           &format!(\"graphviz::render failed: {}\", ioerr)[..])\n+                           format!(\"graphviz::render failed: {}\", ioerr))\n         })\n     }\n }"}, {"sha": "af2416f787ea4669e693fa0162bca977c6ac7ece", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(index, Symbol::intern(&name[..]))\n+        self.infcx.tcx.mk_param(index, Symbol::intern(&name))\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {"}, {"sha": "5c20f65274f54ffbcd86a5323b3bb704dbe328fb", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -99,9 +99,9 @@ pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<Vec<u8>>> {\n         let rustc_version_str_len = rustc_version_str_len[0] as usize;\n         let mut buffer = Vec::with_capacity(rustc_version_str_len);\n         buffer.resize(rustc_version_str_len, 0);\n-        file.read_exact(&mut buffer[..])?;\n+        file.read_exact(&mut buffer)?;\n \n-        if &buffer[..] != rustc_version().as_bytes() {\n+        if buffer != rustc_version().as_bytes() {\n             report_format_mismatch(sess, path, \"Different compiler version\");\n             return Ok(None);\n         }"}, {"sha": "c4220e9a0d3dc1420022e6a7b5b2a3c1ff9c8c98", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -88,7 +88,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, name, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m);\n         }\n     }\n }"}, {"sha": "0ee9d4a42c7f81a26c15efdb0a37ab3eb5af6b45", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             attr.check_name(\"doc\") &&\n             match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n+                Some(l) => attr::list_contains_name(&l, \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);"}, {"sha": "86bf209ccf8c8d92c5c841f684f356f869293b20", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             ty::TyBool => return,\n             ty::TyAdt(def, _) => {\n                 let attrs = cx.tcx.get_attrs(def.did);\n-                check_must_use(cx, &attrs[..], s.span)\n+                check_must_use(cx, &attrs, s.span)\n             }\n             _ => false,\n         };"}, {"sha": "2b945e0a3afaff2f8e7d8ffe10335be2e719bbea", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -140,7 +140,7 @@ fn main() {\n         cfg.flag(flag);\n     }\n \n-    for component in &components[..] {\n+    for component in &components {\n         let mut flag = String::from(\"-DLLVM_COMPONENT_\");\n         flag.push_str(&component.to_uppercase());\n         cfg.flag(&flag);\n@@ -173,7 +173,7 @@ fn main() {\n     if !is_crossed {\n         cmd.arg(\"--system-libs\");\n     }\n-    cmd.args(&components[..]);\n+    cmd.args(&components);\n \n     for lib in output(&mut cmd).split_whitespace() {\n         let name = if lib.starts_with(\"-l\") {"}, {"sha": "04a8b88f8a594a694537722cfda51677330f75f6", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -669,7 +669,7 @@ impl<'a> CrateLoader<'a> {\n                                   name,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            span_fatal!(self.sess, span, E0456, \"{}\", &message[..]);\n+            span_fatal!(self.sess, span, E0456, \"{}\", &message);\n         }\n \n         let root = ekrate.metadata.get_root();"}, {"sha": "3e9b6a6226ab507d7f7087251b31f75fa6bdf9ea", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -88,9 +88,9 @@ provide! { <'tcx> tcx, def_id, cdata\n     }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n-    custom_coerce_unsized_kind => {\n-        cdata.get_custom_coerce_unsized_kind(def_id.index).unwrap_or_else(|| {\n-            bug!(\"custom_coerce_unsized_kind: `{:?}` is missing its kind\", def_id);\n+    coerce_unsized_info => {\n+        cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n+            bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n         })\n     }\n     mir => {\n@@ -109,6 +109,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     typeck_tables => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+    inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n }\n \n impl CrateStore for cstore::CStore {\n@@ -162,12 +163,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(did.krate).get_fn_arg_names(did.index)\n     }\n \n-    fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).get_inherent_implementations_for_type(def_id.index)\n-    }\n-\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n     {\n         if let Some(def_id) = filter {"}, {"sha": "3de1e3442c69ddb6c0ecf63f8a31df8062bbad8d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -643,10 +643,10 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).polarity\n     }\n \n-    pub fn get_custom_coerce_unsized_kind(&self,\n-                                          id: DefIndex)\n-                                          -> Option<ty::adjustment::CustomCoerceUnsized> {\n-        self.get_impl_data(id).coerce_unsized_kind\n+    pub fn get_coerce_unsized_info(&self,\n+                                   id: DefIndex)\n+                                   -> Option<ty::adjustment::CoerceUnsizedInfo> {\n+        self.get_impl_data(id).coerce_unsized_info\n     }\n \n     pub fn get_impl_trait(&self,"}, {"sha": "38d774992a55111b8d901b75a5d192730f76ba38", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -693,7 +693,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = ImplData {\n                     polarity: hir::ImplPolarity::Positive,\n                     parent_impl: None,\n-                    coerce_unsized_kind: None,\n+                    coerce_unsized_info: None,\n                     trait_ref: tcx.impl_trait_ref(def_id).map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n@@ -713,13 +713,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     None\n                 };\n \n+                // if this is an impl of `CoerceUnsized`, create its\n+                // \"unsized info\", else just store None\n+                let coerce_unsized_info =\n+                    trait_ref.and_then(|t| {\n+                        if Some(t.def_id) == tcx.lang_items.coerce_unsized_trait() {\n+                            Some(ty::queries::coerce_unsized_info::get(tcx, item.span, def_id))\n+                        } else {\n+                            None\n+                        }\n+                    });\n+\n                 let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n-                    coerce_unsized_kind: tcx.maps.custom_coerce_unsized_kind\n-                        .borrow()\n-                        .get(&def_id)\n-                        .cloned(),\n+                    coerce_unsized_info: coerce_unsized_info,\n                     trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n@@ -918,14 +926,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 self.encode_fields(def_id);\n             }\n             hir::ItemImpl(..) => {\n-                for &trait_item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n+                for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(trait_item_def_id,\n                                 EncodeContext::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemTrait(..) => {\n-                for &item_def_id in &self.tcx.associated_item_def_ids(def_id)[..] {\n+                for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(item_def_id,\n                                 EncodeContext::encode_info_for_trait_item,\n                                 item_def_id);"}, {"sha": "e8bc8b01652a62a5c71161b6b8e489a21ea21a6f", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -477,15 +477,15 @@ impl<'a> Context<'a> {\n                 Some(file) => file,\n             };\n             let (hash, found_kind) =\n-                if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n+                if file.starts_with(&rlib_prefix) && file.ends_with(\".rlib\") {\n                     (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n-                } else if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rmeta\") {\n+                } else if file.starts_with(&rlib_prefix) && file.ends_with(\".rmeta\") {\n                     (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n                 } else if file.starts_with(&dylib_prefix) &&\n                                              file.ends_with(&dypair.1) {\n                     (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n                 } else {\n-                    if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n+                    if file.starts_with(&staticlib_prefix) && file.ends_with(&staticpair.1) {\n                         staticlibs.push(CrateMismatch {\n                             path: path.to_path_buf(),\n                             got: \"static\".to_string(),"}, {"sha": "abb482a50ebc2621487e53fb43c3af4c5e8f7b73", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -285,7 +285,9 @@ pub struct TraitData<'tcx> {\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n     pub parent_impl: Option<DefId>,\n-    pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n+\n+    /// This is `Some` only for impls of `CoerceUnsized`.\n+    pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n     pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n "}, {"sha": "efe9963cecc7300a955394726544c1af4130cc4a", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -126,19 +126,19 @@ impl<'a> PluginLoader<'a> {\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n             Err(err) => {\n-                self.sess.span_fatal(span, &err[..])\n+                self.sess.span_fatal(span, &err)\n             }\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(&symbol[..]) {\n+                match lib.symbol(&symbol) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n                     Err(err) => {\n-                        self.sess.span_fatal(span, &err[..])\n+                        self.sess.span_fatal(span, &err)\n                     }\n                 };\n "}, {"sha": "2c2babf0a66535724b080ec1d8913c210f98eacd", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -890,19 +890,23 @@ match (A, B, C) {\n E0422: r##\"\n You are trying to use an identifier that is either undefined or not a struct.\n Erroneous code example:\n-``` compile_fail,E0422\n+\n+```compile_fail,E0422\n fn main () {\n     let x = Foo { x: 1, y: 2 };\n }\n ```\n+\n In this case, `Foo` is undefined, so it inherently isn't anything, and\n definitely not a struct.\n+\n ```compile_fail\n fn main () {\n     let foo = 1;\n     let x = foo { x: 1, y: 2 };\n }\n ```\n+\n In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n one.\n \"##,"}, {"sha": "0466e76475da3d1f05069ec0b24edccf45500de3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -922,6 +922,10 @@ impl<'a> ModuleData<'a> {\n     fn is_local(&self) -> bool {\n         self.normal_ancestor_id.is_local()\n     }\n+\n+    fn nearest_item_scope(&'a self) -> Module<'a> {\n+        if self.is_trait() { self.parent.unwrap() } else { self }\n+    }\n }\n \n impl<'a> fmt::Debug for ModuleData<'a> {"}, {"sha": "05f30f039c8f0649dd3eaf3bab6fc28c909219ee", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -172,7 +172,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n             expansion: mark,\n         };\n         expansion.visit_with(&mut visitor);\n-        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n@@ -390,7 +389,7 @@ impl<'a> Resolver<'a> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n-            self.current_module.macro_resolutions.borrow_mut()\n+            self.current_module.nearest_item_scope().macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n@@ -410,7 +409,7 @@ impl<'a> Resolver<'a> {\n             }\n         };\n \n-        self.current_module.legacy_macro_resolutions.borrow_mut()\n+        self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n             .push((scope, path[0], span, kind));\n \n         result"}, {"sha": "4bab135ff12f70db54b2a65ef5007de61d07dcea", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -423,7 +423,7 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n \n     let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from(v))));\n     strs.fold(String::new(), |mut s, ss| {\n-        s.push_str(&ss[..]);\n+        s.push_str(&ss);\n         s\n     })\n }"}, {"sha": "2d1e12bf0a10dfd379e4d90488a6f915a9059d9e", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -22,25 +22,55 @@ use external_data::*;\n use data::{self, VariableKind};\n use dump::Dump;\n \n-pub struct JsonDumper<'b, W: Write + 'b> {\n-    output: &'b mut W,\n+pub struct JsonDumper<O: DumpOutput> {\n     result: Analysis,\n+    output: O,\n }\n \n-impl<'b, W: Write> JsonDumper<'b, W> {\n-    pub fn new(writer: &'b mut W) -> JsonDumper<'b, W> {\n-        JsonDumper { output: writer, result: Analysis::new() }\n-    }\n+pub trait DumpOutput {\n+    fn dump(&mut self, result: &Analysis);\n }\n \n-impl<'b, W: Write> Drop for JsonDumper<'b, W> {\n-    fn drop(&mut self) {\n-        if let Err(_) = write!(self.output, \"{}\", as_json(&self.result)) {\n+pub struct WriteOutput<'b, W: Write + 'b> {\n+    output: &'b mut W,\n+}\n+\n+impl<'b, W: Write> DumpOutput for WriteOutput<'b, W> {\n+    fn dump(&mut self, result: &Analysis) {\n+        if let Err(_) = write!(self.output, \"{}\", as_json(&result)) {\n             error!(\"Error writing output\");\n         }\n     }\n }\n \n+pub struct CallbackOutput<'b> {\n+    callback: &'b mut FnMut(&Analysis),\n+}\n+\n+impl<'b> DumpOutput for CallbackOutput<'b> {\n+    fn dump(&mut self, result: &Analysis) {\n+        (self.callback)(result)\n+    }\n+}\n+\n+impl<'b, W: Write> JsonDumper<WriteOutput<'b, W>> {\n+    pub fn new(writer: &'b mut W) -> JsonDumper<WriteOutput<'b, W>> {\n+        JsonDumper { output: WriteOutput { output: writer }, result: Analysis::new() }\n+    }\n+}\n+\n+impl<'b> JsonDumper<CallbackOutput<'b>> {\n+    pub fn with_callback(callback: &'b mut FnMut(&Analysis)) -> JsonDumper<CallbackOutput<'b>> {\n+        JsonDumper { output: CallbackOutput { callback: callback }, result: Analysis::new() }\n+    }\n+}\n+\n+impl<O: DumpOutput> Drop for JsonDumper<O> {\n+    fn drop(&mut self) {\n+        self.output.dump(&self.result);\n+    }\n+}\n+\n macro_rules! impl_fn {\n     ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n         fn $fn_name(&mut self, data: $data_type) {\n@@ -49,7 +79,7 @@ macro_rules! impl_fn {\n     }\n }\n \n-impl<'b, W: Write + 'b> Dump for JsonDumper<'b, W> {\n+impl<'b, O: DumpOutput + 'b> Dump for JsonDumper<O> {\n     fn crate_prelude(&mut self, data: CratePreludeData) {\n         self.result.prelude = Some(data)\n     }"}, {"sha": "e5c04f6b61ec297643bb9cd1726fb33bcff8b115", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 119, "deletions": 56, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -48,6 +48,7 @@ use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::hir::def_id::DefId;\n use rustc::session::config::CrateType::CrateTypeExecutable;\n+use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n \n use std::env;\n@@ -866,55 +867,131 @@ impl Format {\n     }\n }\n \n-pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-                               krate: &ast::Crate,\n-                               analysis: &'l ty::CrateAnalysis,\n-                               cratename: &str,\n-                               odir: Option<&Path>,\n-                               format: Format) {\n-    let _ignore = tcx.dep_graph.in_ignore();\n+/// Defines what to do with the results of saving the analysis.\n+pub trait SaveHandler {\n+    fn save<'l, 'tcx>(&mut self,\n+                      save_ctxt: SaveContext<'l, 'tcx>,\n+                      krate: &ast::Crate,\n+                      cratename: &str);\n+}\n \n-    assert!(analysis.glob_map.is_some());\n+/// Dump the save-analysis results to a file.\n+pub struct DumpHandler<'a> {\n+    format: Format,\n+    odir: Option<&'a Path>,\n+    cratename: String\n+}\n \n-    info!(\"Dumping crate {}\", cratename);\n+impl<'a> DumpHandler<'a> {\n+    pub fn new(format: Format, odir: Option<&'a Path>, cratename: &str) -> DumpHandler<'a> {\n+        DumpHandler {\n+            format: format,\n+            odir: odir,\n+            cratename: cratename.to_owned()\n+        }\n+    }\n \n-    // find a path to dump our data to\n-    let mut root_path = match env::var_os(\"RUST_SAVE_ANALYSIS_FOLDER\") {\n-        Some(val) => PathBuf::from(val),\n-        None => match odir {\n-            Some(val) => val.join(\"save-analysis\"),\n-            None => PathBuf::from(\"save-analysis-temp\"),\n-        },\n-    };\n+    fn output_file(&self, sess: &Session) -> File {\n+        let mut root_path = match env::var_os(\"RUST_SAVE_ANALYSIS_FOLDER\") {\n+            Some(val) => PathBuf::from(val),\n+            None => match self.odir {\n+                Some(val) => val.join(\"save-analysis\"),\n+                None => PathBuf::from(\"save-analysis-temp\"),\n+            },\n+        };\n \n-    if let Err(e) = std::fs::create_dir_all(&root_path) {\n-        tcx.sess.err(&format!(\"Could not create directory {}: {}\",\n-                              root_path.display(),\n-                              e));\n+        if let Err(e) = std::fs::create_dir_all(&root_path) {\n+            error!(\"Could not create directory {}: {}\", root_path.display(), e);\n+        }\n+\n+        {\n+            let disp = root_path.display();\n+            info!(\"Writing output to {}\", disp);\n+        }\n+\n+        let executable = sess.crate_types.borrow().iter().any(|ct| *ct == CrateTypeExecutable);\n+        let mut out_name = if executable {\n+            \"\".to_owned()\n+        } else {\n+            \"lib\".to_owned()\n+        };\n+        out_name.push_str(&self.cratename);\n+        out_name.push_str(&sess.opts.cg.extra_filename);\n+        out_name.push_str(self.format.extension());\n+        root_path.push(&out_name);\n+        let output_file = File::create(&root_path).unwrap_or_else(|e| {\n+            let disp = root_path.display();\n+            sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n+        });\n+        root_path.pop();\n+        output_file\n     }\n+}\n+\n+impl<'a> SaveHandler for DumpHandler<'a> {\n+    fn save<'l, 'tcx>(&mut self,\n+                      save_ctxt: SaveContext<'l, 'tcx>,\n+                      krate: &ast::Crate,\n+                      cratename: &str) {\n+        macro_rules! dump {\n+            ($new_dumper: expr) => {{\n+                let mut dumper = $new_dumper;\n+                let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n+\n+                visitor.dump_crate_info(cratename, krate);\n+                visit::walk_crate(&mut visitor, krate);\n+            }}\n+        }\n+\n+        let output = &mut self.output_file(&save_ctxt.tcx.sess);\n \n-    {\n-        let disp = root_path.display();\n-        info!(\"Writing output to {}\", disp);\n+        match self.format {\n+            Format::Csv => dump!(CsvDumper::new(output)),\n+            Format::Json => dump!(JsonDumper::new(output)),\n+            Format::JsonApi => dump!(JsonApiDumper::new(output)),\n+        }\n     }\n+}\n \n-    // Create output file.\n-    let executable = tcx.sess.crate_types.borrow().iter().any(|ct| *ct == CrateTypeExecutable);\n-    let mut out_name = if executable {\n-        \"\".to_owned()\n-    } else {\n-        \"lib\".to_owned()\n-    };\n-    out_name.push_str(&cratename);\n-    out_name.push_str(&tcx.sess.opts.cg.extra_filename);\n-    out_name.push_str(format.extension());\n-    root_path.push(&out_name);\n-    let mut output_file = File::create(&root_path).unwrap_or_else(|e| {\n-        let disp = root_path.display();\n-        tcx.sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n-    });\n-    root_path.pop();\n-    let output = &mut output_file;\n+/// Call a callback with the results of save-analysis.\n+pub struct CallbackHandler<'b> {\n+    pub callback: &'b mut FnMut(&rls_data::Analysis),\n+}\n+\n+impl<'b> SaveHandler for CallbackHandler<'b> {\n+    fn save<'l, 'tcx>(&mut self,\n+                      save_ctxt: SaveContext<'l, 'tcx>,\n+                      krate: &ast::Crate,\n+                      cratename: &str) {\n+        macro_rules! dump {\n+            ($new_dumper: expr) => {{\n+                let mut dumper = $new_dumper;\n+                let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n+\n+                visitor.dump_crate_info(cratename, krate);\n+                visit::walk_crate(&mut visitor, krate);\n+            }}\n+        }\n+\n+        // We're using the JsonDumper here because it has the format of the\n+        // save-analysis results that we will pass to the callback. IOW, we are\n+        // using the JsonDumper to collect the save-analysis results, but not\n+        // actually to dump them to a file. This is all a bit convoluted and\n+        // there is certainly a simpler design here trying to get out (FIXME).\n+        dump!(JsonDumper::with_callback(self.callback))\n+    }\n+}\n+\n+pub fn process_crate<'l, 'tcx, H: SaveHandler>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+                                               krate: &ast::Crate,\n+                                               analysis: &'l ty::CrateAnalysis,\n+                                               cratename: &str,\n+                                               mut handler: H) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    assert!(analysis.glob_map.is_some());\n+\n+    info!(\"Dumping crate {}\", cratename);\n \n     let save_ctxt = SaveContext {\n         tcx: tcx,\n@@ -923,21 +1000,7 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n         span_utils: SpanUtils::new(&tcx.sess),\n     };\n \n-    macro_rules! dump {\n-        ($new_dumper: expr) => {{\n-            let mut dumper = $new_dumper;\n-            let mut visitor = DumpVisitor::new(save_ctxt, &mut dumper);\n-\n-            visitor.dump_crate_info(cratename, krate);\n-            visit::walk_crate(&mut visitor, krate);\n-        }}\n-    }\n-\n-    match format {\n-        Format::Csv => dump!(CsvDumper::new(output)),\n-        Format::Json => dump!(JsonDumper::new(output)),\n-        Format::JsonApi => dump!(JsonApiDumper::new(output)),\n-    }\n+    handler.save(save_ctxt, krate, cratename)\n }\n \n // Utility functions for the module."}, {"sha": "1530708b4b8882c6361608a1936496ae90769e93", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -369,7 +369,7 @@ impl FnType {\n             match sig.inputs().last().unwrap().sty {\n                 ty::TyTuple(ref tupled_arguments, _) => {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    &tupled_arguments[..]\n+                    &tupled_arguments\n                 }\n                 _ => {\n                     bug!(\"argument to function with \\\"rust-call\\\" ABI \\"}, {"sha": "5c1ced573402e07d8314d0654ee458b6bbde3a18", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -229,11 +229,11 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                  variant_fill].iter().cloned().collect();\n             match name {\n                 None => {\n-                    Type::struct_(cx, &fields[..], false)\n+                    Type::struct_(cx, &fields, false)\n                 }\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&fields[..], false);\n+                    llty.set_struct_body(&fields, false);\n                     llty\n                 }\n             }\n@@ -330,7 +330,7 @@ fn struct_wrapped_nullable_bitdiscr(\n     alignment: Alignment,\n ) -> ValueRef {\n     let llptrptr = bcx.gepi(scrutinee,\n-        &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>()[..]);\n+        &discrfield.iter().map(|f| *f as usize).collect::<Vec<_>>());\n     let llptr = bcx.load(llptrptr, alignment.to_align());\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n@@ -402,7 +402,7 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {\n                     let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n-                    let llptrptr = bcx.gepi(val, &path[..]);\n+                    let llptrptr = bcx.gepi(val, &path);\n                     let llptrty = val_ty(llptrptr).element_type();\n                     bcx.store(C_null(llptrty), llptrptr, None);\n                 }"}, {"sha": "b6195765b27c29711856314d9afc1524b0e012e2", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -77,14 +77,14 @@ pub fn trans_inline_asm<'a, 'tcx>(\n           .chain(arch_clobbers.iter().map(|s| s.to_string()))\n           .collect::<Vec<String>>().join(\",\");\n \n-    debug!(\"Asm Constraints: {}\", &all_constraints[..]);\n+    debug!(\"Asm Constraints: {}\", &all_constraints);\n \n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n         0 => Type::void(bcx.ccx),\n         1 => output_types[0],\n-        _ => Type::struct_(bcx.ccx, &output_types[..], false)\n+        _ => Type::struct_(bcx.ccx, &output_types, false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "0f908b7d0698bc48e7bd1fd529d46212c5433a0f", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -65,10 +65,10 @@ pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n \n     for path in search_paths {\n         debug!(\"looking for {} inside {:?}\", name, path);\n-        let test = path.join(&oslibname[..]);\n+        let test = path.join(&oslibname);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(&unixlibname[..]);\n+            let test = path.join(&unixlibname);\n             if test.exists() { return test }\n         }\n     }"}, {"sha": "6d17b2f0eeda3514c3b6079c2c0d92cc7ce315ff", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -91,7 +91,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n-        cstore::validate_crate_name(sess, &s[..], span);\n+        cstore::validate_crate_name(sess, &s, span);\n         s\n     };\n \n@@ -109,7 +109,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, &msg[..]);\n+                    sess.span_err(attr.span, &msg);\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -417,7 +417,7 @@ fn object_filenames(trans: &CrateTranslation,\n                     outputs: &OutputFilenames)\n                     -> Vec<PathBuf> {\n     trans.modules.iter().map(|module| {\n-        outputs.temp_path(OutputType::Object, Some(&module.name[..]))\n+        outputs.temp_path(OutputType::Object, Some(&module.name))\n     }).collect()\n }\n \n@@ -551,7 +551,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                  e))\n                 }\n \n-                let bc_data_deflated = flate::deflate_bytes(&bc_data[..]);\n+                let bc_data_deflated = flate::deflate_bytes(&bc_data);\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n@@ -819,12 +819,12 @@ fn link_natively(sess: &Session,\n                                          pname,\n                                          prog.status))\n                     .note(&format!(\"{:?}\", &cmd))\n-                    .note(&escape_string(&output[..]))\n+                    .note(&escape_string(&output))\n                     .emit();\n                 sess.abort_if_errors();\n             }\n-            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr[..]));\n-            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout[..]));\n+            info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));\n+            info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n         },\n         Err(e) => {\n             sess.struct_err(&format!(\"could not exec the linker `{}`: {}\", pname, e))"}, {"sha": "e23ddd2542a808f8ae0b765c2c86a95ecafa3f45", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -61,7 +61,7 @@ pub fn run(sess: &session::Session,\n     }\n \n     let export_threshold =\n-        symbol_export::crates_export_threshold(&sess.crate_types.borrow()[..]);\n+        symbol_export::crates_export_threshold(&sess.crate_types.borrow());\n \n     let symbol_filter = &|&(ref name, level): &(String, _)| {\n         if symbol_export::is_below_threshold(level, export_threshold) {\n@@ -147,7 +147,7 @@ pub fn run(sess: &session::Session,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            &name[..]));\n+                                            name));\n                 }\n             });\n         }"}, {"sha": "104e7bc6a52bde0cf04a013fe4ef0f4d47169a62", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -37,8 +37,8 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n \n     let libs = config.used_crates.clone();\n     let libs = libs.into_iter().filter_map(|(_, l)| l.option()).collect::<Vec<_>>();\n-    let rpaths = get_rpaths(config, &libs[..]);\n-    flags.extend_from_slice(&rpaths_to_flags(&rpaths[..]));\n+    let rpaths = get_rpaths(config, &libs);\n+    flags.extend_from_slice(&rpaths_to_flags(&rpaths));\n \n     // Use DT_RUNPATH instead of DT_RPATH if available\n     if config.linker_is_gnu {\n@@ -84,14 +84,14 @@ fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n         }\n     }\n \n-    log_rpaths(\"relative\", &rel_rpaths[..]);\n-    log_rpaths(\"fallback\", &fallback_rpaths[..]);\n+    log_rpaths(\"relative\", &rel_rpaths);\n+    log_rpaths(\"fallback\", &fallback_rpaths);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.extend_from_slice(&fallback_rpaths[..]);\n+    rpaths.extend_from_slice(&fallback_rpaths);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(&rpaths[..]);\n+    let rpaths = minimize_rpaths(&rpaths);\n     return rpaths;\n }\n \n@@ -177,7 +177,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths {\n-        if set.insert(&rpath[..]) {\n+        if set.insert(rpath) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "23a67ef5046eebec0a527e24a0859eff3f359dce", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -154,7 +154,7 @@ impl ExportedSymbols {\n                             cnum: CrateNum)\n                             -> &[(String, SymbolExportLevel)] {\n         match self.exports.get(&cnum) {\n-            Some(exports) => &exports[..],\n+            Some(exports) => exports,\n             None => &[]\n         }\n     }\n@@ -167,7 +167,7 @@ impl ExportedSymbols {\n     {\n         for &(ref name, export_level) in self.exported_symbols(cnum) {\n             if is_below_threshold(export_level, export_threshold) {\n-                f(&name[..], export_level)\n+                f(&name, export_level)\n             }\n         }\n     }"}, {"sha": "3ad04e10cb027d20f4a555929eb43eff1a11dd62", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -341,7 +341,7 @@ pub fn sanitize(s: &str) -> String {\n     if !result.is_empty() &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", &result[..]);\n+        return format!(\"_{}\", result);\n     }\n \n     return result;"}, {"sha": "5a017e4fb8a9aa07e163887f28c443960278b1da", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -105,7 +105,7 @@ impl SharedEmitter {\n                 Some(ref code) => {\n                     handler.emit_with_code(&MultiSpan::new(),\n                                            &diag.msg,\n-                                           &code[..],\n+                                           &code,\n                                            diag.lvl);\n                 },\n                 None => {\n@@ -189,8 +189,8 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => &s[..],\n-        None => &sess.target.target.options.code_model[..],\n+        Some(ref s) => &s,\n+        None => &sess.target.target.options.code_model,\n     };\n \n     let code_model = match CODE_GEN_MODEL_ARGS.iter().find(\n@@ -397,7 +397,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     let msg = llvm::build_string(|s| llvm::LLVMRustWriteSMDiagnosticToString(diag, s))\n         .expect(\"non-UTF8 SMDiagnostic\");\n \n-    report_inline_asm(cgcx, &msg[..], cookie);\n+    report_inline_asm(cgcx, &msg, cookie);\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n@@ -823,7 +823,7 @@ pub fn run_passes(sess: &Session,\n         if trans.modules.len() == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n-            let module_name = Some(&(trans.modules[0].name)[..]);\n+            let module_name = Some(&trans.modules[0].name[..]);\n             let path = crate_output.temp_path(output_type, module_name);\n             copy_gracefully(&path,\n                             &crate_output.path(output_type));\n@@ -939,7 +939,7 @@ pub fn run_passes(sess: &Session,\n \n         if metadata_config.emit_bc && !user_wants_bitcode {\n             let path = crate_output.temp_path(OutputType::Bitcode,\n-                                              Some(&trans.metadata_module.name[..]));\n+                                              Some(&trans.metadata_module.name));\n             remove(sess, &path);\n         }\n     }"}, {"sha": "ec45c5593632ed3fddbc5bf18924ffdec73fc740", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -514,7 +514,7 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n                                n_bytes: ValueRef,\n                                align: u32) {\n     let ccx = b.ccx;\n-    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+    let ptr_width = &ccx.sess().target.target.target_pointer_width;\n     let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n@@ -550,7 +550,7 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n                              size: ValueRef,\n                              align: ValueRef,\n                              volatile: bool) -> ValueRef {\n-    let ptr_width = &b.ccx.sess().target.target.target_pointer_width[..];\n+    let ptr_width = &b.ccx.sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = b.ccx.get_intrinsic(&intrinsic_key);\n     let volatile = C_bool(b.ccx, volatile);\n@@ -765,7 +765,7 @@ fn write_metadata(cx: &SharedCrateContext,\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata));\n \n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[..]);\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = cx.metadata_symbol_name();\n     let buf = CString::new(name).unwrap();\n@@ -796,7 +796,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n     let export_threshold =\n-        symbol_export::crates_export_threshold(&sess.crate_types.borrow()[..]);\n+        symbol_export::crates_export_threshold(&sess.crate_types.borrow());\n \n     let exported_symbols = exported_symbols\n         .exported_symbols(LOCAL_CRATE)\n@@ -1035,7 +1035,7 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n                 (generics.parent_types == 0 && generics.types.is_empty()) &&\n                 // Functions marked with #[inline] are only ever translated\n                 // with \"internal\" linkage and are never exported.\n-                !attr::requests_inline(&attributes[..])\n+                !attr::requests_inline(&attributes)\n             }\n \n             _ => false\n@@ -1574,7 +1574,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                 cgus.dedup();\n                 for &(ref cgu_name, linkage) in cgus.iter() {\n                     output.push_str(\" \");\n-                    output.push_str(&cgu_name[..]);\n+                    output.push_str(&cgu_name);\n \n                     let linkage_abbrev = match linkage {\n                         llvm::Linkage::ExternalLinkage => \"External\","}, {"sha": "8b1010d89fd9fd1c03c5f0e657de371ae090529c", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -627,7 +627,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, &v[..])\n+            self.inbounds_gep(base, &v)\n         }\n     }\n \n@@ -835,8 +835,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", &s[..]);\n-            self.add_comment(&s[..]);\n+            debug!(\"{}\", s);\n+            self.add_comment(&s);\n         }\n     }\n "}, {"sha": "382ca8ef01001ecfd31d922b869d143d5e3a04a0", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -287,7 +287,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n \n     match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n+            scx.tcx().coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n         vtable => {\n             bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);"}, {"sha": "5b0418921563a2dea56b4fa4bbf47897b57f3fc8", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -479,14 +479,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n-        // Read the inherent implementation candidates for this type from the\n-        // metadata if necessary.\n-        self.tcx.populate_inherent_implementations_for_type_if_necessary(self.span, def_id);\n-\n-        if let Some(impl_infos) = self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n-            for &impl_def_id in impl_infos.iter() {\n-                self.assemble_inherent_impl_probe(impl_def_id);\n-            }\n+        let impl_def_ids = ty::queries::inherent_impls::get(self.tcx, self.span, def_id);\n+        for &impl_def_id in impl_def_ids.iter() {\n+            self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }\n "}, {"sha": "47b41a75cf5316a9f041d1200ce362f260a45aea", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -18,6 +18,7 @@ use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::ParameterEnvironment;\n use rustc::ty::TypeFoldable;\n+use rustc::ty::adjustment::CoerceUnsizedInfo;\n use rustc::ty::subst::Subst;\n use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n@@ -159,28 +160,41 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                    coerce_unsized_trait: DefId,\n+                                                    _: DefId,\n                                                     impl_did: DefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\",\n            impl_did);\n \n+    // Just compute this for the side-effects, in particular reporting\n+    // errors; other parts of the code may demand it for the info of\n+    // course.\n+    if impl_did.is_local() {\n+        let span = tcx.def_span(impl_did);\n+        ty::queries::coerce_unsized_info::get(tcx, span, impl_did);\n+    }\n+}\n+\n+pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     impl_did: DefId)\n+                                     -> CoerceUnsizedInfo {\n+    debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n+    let coerce_unsized_trait = tcx.lang_items.coerce_unsized_trait().unwrap();\n+\n     let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n         Ok(id) => id,\n         Err(err) => {\n             tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n         }\n     };\n \n-    let impl_node_id = if let Some(n) = tcx.hir.as_local_node_id(impl_did) {\n-        n\n-    } else {\n-        debug!(\"visit_implementation_of_coerce_unsized(): impl not \\\n-                in this crate\");\n-        return;\n-    };\n+    // this provider should only get invoked for local def-ids\n+    let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n+        bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n+    });\n \n     let source = tcx.item_type(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n@@ -192,6 +206,8 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let target = target.subst(tcx, &param_env.free_substs);\n     assert!(!source.has_escaping_regions());\n \n+    let err_info = CoerceUnsizedInfo { custom_kind: None };\n+\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\",\n            source,\n            target);\n@@ -234,7 +250,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                definition; expected {}, found {}\",\n                               source_path,\n                               target_path);\n-                    return;\n+                    return err_info;\n                 }\n \n                 let fields = &def_a.struct_variant().fields;\n@@ -268,7 +284,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n-                    return;\n+                    return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = tcx.hir.expect_item(impl_node_id);\n                     let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n@@ -295,7 +311,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           .join(\", \")));\n                     err.span_label(span, &format!(\"requires multiple coercions\"));\n                     err.emit();\n-                    return;\n+                    return err_info;\n                 }\n \n                 let (i, a, b) = diff_fields[0];\n@@ -309,7 +325,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n                            for a coercion between structures\");\n-                return;\n+                return err_info;\n             }\n         };\n \n@@ -331,8 +347,8 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             .caller_bounds);\n         infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n-        if let Some(kind) = kind {\n-            tcx.maps.custom_coerce_unsized_kind.borrow_mut().insert(impl_did, kind);\n+        CoerceUnsizedInfo {\n+            custom_kind: kind\n         }\n-    });\n+    })\n }"}, {"sha": "3a39df505eb07863ae2314bff3f2174dd419abe3", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "renamed", "additions": 76, "deletions": 107, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -8,19 +8,82 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! The code in this module gathers up all of the inherent impls in\n+//! the current crate and organizes them in a map. It winds up\n+//! touching the whole crate and thus must be recomputed completely\n+//! for any change, but it is very cheap to compute. In practice, most\n+//! code in the compiler never *directly* requests this map. Instead,\n+//! it requests the inherent impls specific to some type (via\n+//! `ty::queries::inherent_impls::get(def_id)`). That value, however,\n+//! is computed by selecting an idea from this table.\n+\n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::lint;\n-use rustc::traits::{self, Reveal};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, CrateInherentImpls, TyCtxt};\n+use rustc::util::nodemap::DefIdMap;\n \n+use std::rc::Rc;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+/// On-demand query: yields a map containing all types mapped to their inherent impls.\n+pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      crate_num: CrateNum)\n+                                      -> CrateInherentImpls {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+\n+    let krate = tcx.hir.krate();\n+    let mut collect = InherentCollect {\n+        tcx,\n+        impls_map: CrateInherentImpls {\n+            inherent_impls: DefIdMap()\n+        }\n+    };\n+    krate.visit_all_item_likes(&mut collect);\n+    collect.impls_map\n+}\n+\n+/// On-demand query: yields a vector of the inherent impls for a specific type.\n+pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                ty_def_id: DefId)\n+                                -> Rc<Vec<DefId>> {\n+    assert!(ty_def_id.is_local());\n+\n+    // NB. Until we adopt the red-green dep-tracking algorithm (see\n+    // [the plan] for details on that), we do some hackery here to get\n+    // the dependencies correct.  Basically, we use a `with_ignore` to\n+    // read the result we want. If we didn't have the `with_ignore`,\n+    // we would wind up with a dependency on the entire crate, which\n+    // we don't want. Then we go and add dependencies on all the impls\n+    // in the result (which is what we wanted).\n+    //\n+    // The result is a graph with an edge from `Hir(I)` for every impl\n+    // `I` defined on some type `T` to `CoherentInherentImpls(T)`,\n+    // thus ensuring that if any of those impls change, the set of\n+    // inherent impls is considered dirty.\n+    //\n+    // [the plan]: https://github.com/rust-lang/rust-roadmap/issues/4\n+\n+    let result = tcx.dep_graph.with_ignore(|| {\n+        let crate_map = ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, ty_def_id.krate);\n+        match crate_map.inherent_impls.get(&ty_def_id) {\n+            Some(v) => v.clone(),\n+            None => Rc::new(vec![]),\n+        }\n+    });\n+\n+    for &impl_def_id in &result[..] {\n+        tcx.dep_graph.read(DepNode::Hir(impl_def_id));\n+    }\n+\n+    result\n+}\n \n struct InherentCollect<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impls_map: CrateInherentImpls,\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n@@ -209,25 +272,19 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n-    fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n+    fn check_def_id(&mut self, item: &hir::Item, def_id: DefId) {\n         if def_id.is_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits.\n             let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+            let mut rc_vec = self.impls_map.inherent_impls\n+                                           .entry(def_id)\n+                                           .or_insert_with(|| Rc::new(vec![]));\n \n-            // Subtle: it'd be better to collect these into a local map\n-            // and then write the vector only once all items are known,\n-            // but that leads to degenerate dep-graphs. The problem is\n-            // that the write of that big vector winds up having reads\n-            // from *all* impls in the krate, since we've lost the\n-            // precision basically.  This would be ok in the firewall\n-            // model so once we've made progess towards that we can modify\n-            // the strategy here. In the meantime, using `push` is ok\n-            // because we are doing this as a pre-pass before anyone\n-            // actually reads from `inherent_impls` -- and we know this is\n-            // true beacuse we hold the refcell lock.\n-            self.tcx.maps.inherent_impls.borrow_mut().push(def_id, impl_def_id);\n+            // At this point, there should not be any clones of the\n+            // `Rc`, so we can still safely push into it in place:\n+            Rc::get_mut(&mut rc_vec).unwrap().push(impl_def_id);\n         } else {\n             struct_span_err!(self.tcx.sess,\n                              item.span,\n@@ -266,91 +323,3 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n     }\n }\n \n-struct InherentOverlapChecker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n-}\n-\n-impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n-        #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace {\n-            Type,\n-            Value,\n-        }\n-\n-        let name_and_namespace = |def_id| {\n-            let item = self.tcx.associated_item(def_id);\n-            (item.name, match item.kind {\n-                ty::AssociatedKind::Type => Namespace::Type,\n-                ty::AssociatedKind::Const |\n-                ty::AssociatedKind::Method => Namespace::Value,\n-            })\n-        };\n-\n-        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n-        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n-\n-        for &item1 in &impl_items1[..] {\n-            let (name, namespace) = name_and_namespace(item1);\n-\n-            for &item2 in &impl_items2[..] {\n-                if (name, namespace) == name_and_namespace(item2) {\n-                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n-                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n-                                           node_id,\n-                                           self.tcx.span_of_impl(item1).unwrap(),\n-                                           msg);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n-        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n-\n-        let inherent_impls = self.tcx.maps.inherent_impls.borrow();\n-        let impls = match inherent_impls.get(&ty_def_id) {\n-            Some(impls) => impls,\n-            None => return,\n-        };\n-\n-        for (i, &impl1_def_id) in impls.iter().enumerate() {\n-            for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n-                    }\n-                });\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'v hir::Item) {\n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTrait(..) |\n-            hir::ItemUnion(..) => {\n-                let type_def_id = self.tcx.hir.local_def_id(item.id);\n-                self.check_for_overlapping_inherent_impls(type_def_id);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl,\n-                                      &mut InherentCollect { tcx });\n-    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial,\n-                                      &mut InherentOverlapChecker { tcx });\n-}", "previous_filename": "src/librustc_typeck/coherence/inherent.rs"}, {"sha": "4b36072243c810ae1f9b110faa3f8fc69580e784", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::lint;\n+use rustc::traits::{self, Reveal};\n+use rustc::ty::{self, TyCtxt};\n+\n+use syntax_pos::DUMMY_SP;\n+\n+pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                    crate_num: CrateNum) {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    let krate = tcx.hir.krate();\n+    krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n+}\n+\n+struct InherentOverlapChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+        #[derive(Copy, Clone, PartialEq)]\n+        enum Namespace {\n+            Type,\n+            Value,\n+        }\n+\n+        let name_and_namespace = |def_id| {\n+            let item = self.tcx.associated_item(def_id);\n+            (item.name, match item.kind {\n+                ty::AssociatedKind::Type => Namespace::Type,\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => Namespace::Value,\n+            })\n+        };\n+\n+        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n+        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n+\n+        for &item1 in &impl_items1[..] {\n+            let (name, namespace) = name_and_namespace(item1);\n+\n+            for &item2 in &impl_items2[..] {\n+                if (name, namespace) == name_and_namespace(item2) {\n+                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n+                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n+                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n+                                           node_id,\n+                                           self.tcx.span_of_impl(item1).unwrap(),\n+                                           msg);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n+        let impls = ty::queries::inherent_impls::get(self.tcx, DUMMY_SP, ty_def_id);\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            for &impl2_def_id in &impls[(i + 1)..] {\n+                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'v hir::Item) {\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemTrait(..) |\n+            hir::ItemUnion(..) => {\n+                let type_def_id = self.tcx.hir.local_def_id(item.id);\n+                self.check_for_overlapping_inherent_impls(type_def_id);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+"}, {"sha": "b3a7b612dd5b8532af75ac7aee58742cbfb29953", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -24,7 +24,8 @@ use syntax::ast;\n use syntax_pos::DUMMY_SP;\n \n mod builtin;\n-mod inherent;\n+mod inherent_impls;\n+mod inherent_impls_overlap;\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -102,9 +103,16 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n }\n \n pub fn provide(providers: &mut Providers) {\n+    use self::builtin::coerce_unsized_info;\n+    use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n+    use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;\n+\n     *providers = Providers {\n         coherent_trait,\n-        coherent_inherent_impls,\n+        crate_inherent_impls,\n+        inherent_impls,\n+        crate_inherent_impls_overlap_check,\n+        coerce_unsized_info,\n         ..*providers\n     };\n }\n@@ -123,10 +131,6 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     builtin::check_trait(tcx, def_id);\n }\n \n-fn coherent_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, _: CrateNum) {\n-    inherent::check(tcx);\n-}\n-\n pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Coherence);\n     for &trait_def_id in tcx.hir.krate().trait_impls.keys() {\n@@ -137,5 +141,7 @@ pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     orphan::check(tcx);\n     overlap::check_default_impls(tcx);\n \n-    ty::queries::coherent_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    // these queries are executed for side-effects (error reporting):\n+    ty::queries::crate_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n+    ty::queries::crate_inherent_impls_overlap_check::get(tcx, DUMMY_SP, LOCAL_CRATE);\n }"}, {"sha": "bd6129eb5bee3c80befdfa76500988837d72f91e", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -790,7 +790,7 @@ Furthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]\n and [RFC 809] for more details.\n \n [RFC 470]: https://github.com/rust-lang/rfcs/pull/470\n-[RFC 809]: https://github.com/rust-lang/rfcs/pull/809\n+[RFC 809]: https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md\n \"##,\n \n E0067: r##\"\n@@ -1428,7 +1428,7 @@ type X = u32; // this compiles\n ```\n \n Note that type parameters for enum-variant constructors go after the variant,\n-not after the enum (Option::None::<u32>, not Option::<u32>::None).\n+not after the enum (`Option::None::<u32>`, not `Option::<u32>::None`).\n \"##,\n \n E0110: r##\"\n@@ -1521,7 +1521,7 @@ impl Bar for u32 {\n \n For information on the design of the orphan rules, see [RFC 1023].\n \n-[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n+[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n \"##,\n \n E0118: r##\"\n@@ -1911,8 +1911,9 @@ type Foo = Trait<Bar=i32>; // ok!\n \n E0192: r##\"\n Negative impls are only allowed for traits with default impls. For more\n-information see the [opt-in builtin traits RFC](https://github.com/rust-lang/\n-rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n+information see the [opt-in builtin traits RFC][RFC 19].\n+\n+[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n \"##,\n \n E0193: r##\"\n@@ -2147,7 +2148,7 @@ E0202: r##\"\n Inherent associated types were part of [RFC 195] but are not yet implemented.\n See [the tracking issue][iss8995] for the status of this implementation.\n \n-[RFC 195]: https://github.com/rust-lang/rfcs/pull/195\n+[RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n [iss8995]: https://github.com/rust-lang/rust/issues/8995\n \"##,\n \n@@ -2424,7 +2425,7 @@ such that `Ti` is a local type. Then no type parameter can appear in any of the\n \n For information on the design of the orphan rules, see [RFC 1023].\n \n-[RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n+[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n \"##,\n \n /*\n@@ -2799,8 +2800,9 @@ verify this assertion; therefore we must tag this `impl` as unsafe.\n \n E0318: r##\"\n Default impls for a trait must be located in the same crate where the trait was\n-defined. For more information see the [opt-in builtin traits RFC](https://github\n-.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n+defined. For more information see the [opt-in builtin traits RFC][RFC 19].\n+\n+[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n \"##,\n \n E0321: r##\"\n@@ -3018,10 +3020,8 @@ impl<T> Unsize<T> for MyType {}\n ```\n \n If you are defining your own smart pointer type and would like to enable\n-conversion from a sized to an unsized type with the [DST coercion system]\n-(https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md), use\n-[`CoerceUnsized`](https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html)\n-instead.\n+conversion from a sized to an unsized type with the\n+[DST coercion system][RFC 982], use [`CoerceUnsized`] instead.\n \n ```\n #![feature(coerce_unsized)]\n@@ -3035,6 +3035,9 @@ pub struct MyType<T: ?Sized> {\n impl<T, U> CoerceUnsized<MyType<U>> for MyType<T>\n     where T: CoerceUnsized<U> {}\n ```\n+\n+[RFC 982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+[`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html\n \"##,\n \n E0329: r##\"\n@@ -3438,8 +3441,9 @@ struct.\n \n E0380: r##\"\n Default impls are only allowed for traits with no methods or associated items.\n-For more information see the [opt-in builtin traits RFC](https://github.com/rust\n--lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n+For more information see the [opt-in builtin traits RFC][RFC 19].\n+\n+[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md\n \"##,\n \n E0390: r##\""}, {"sha": "cc30fdf56fc346c08b411d8b027a6400cfbb33f1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -232,14 +232,12 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n \n pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n-    tcx.populate_inherent_implementations_for_type_if_necessary(DUMMY_SP, did);\n     let mut impls = Vec::new();\n \n-    if let Some(i) = tcx.maps.inherent_impls.borrow().get(&did) {\n-        for &did in i.iter() {\n-            build_impl(cx, did, &mut impls);\n-        }\n+    for &did in ty::queries::inherent_impls::get(tcx, DUMMY_SP, did).iter() {\n+        build_impl(cx, did, &mut impls);\n     }\n+\n     // If this is the first time we've inlined something from another crate, then\n     // we inline *all* impls from all the crates into this crate. Note that there's\n     // currently no way for us to filter this based on type, and we likely need"}, {"sha": "612e765a499b7b93f3e5483c581e85e7d779a291", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -2611,7 +2611,7 @@ fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n     if attr.is_word() {\n         Some(format!(\"{}\", name))\n     } else if let Some(v) = attr.value_str() {\n-        Some(format!(\"{} = {:?}\", name, &v.as_str()[..]))\n+        Some(format!(\"{} = {:?}\", name, v.as_str()))\n     } else if let Some(values) = attr.meta_item_list() {\n         let display: Vec<_> = values.iter().filter_map(|attr| {\n             attr.meta_item().and_then(|mi| render_attribute(mi))\n@@ -2642,7 +2642,7 @@ fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n \n     for attr in &it.attrs.other_attrs {\n         let name = attr.name().unwrap();\n-        if !ATTRIBUTE_WHITELIST.contains(&&name.as_str()[..]) {\n+        if !ATTRIBUTE_WHITELIST.contains(&&*name.as_str()) {\n             continue;\n         }\n         if let Some(s) = render_attribute(&attr.meta().unwrap()) {"}, {"sha": "5fadda030a4b41c5bc7798375ae6848694a3dbba", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -28,20 +28,22 @@ use html::markdown;\n use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n-/// Separate any lines at the start of the file that begin with `%`.\n+/// Separate any lines at the start of the file that begin with `# ` or `%`.\n fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     let mut metadata = Vec::new();\n     let mut count = 0;\n+\n     for line in s.lines() {\n-        if line.starts_with(\"%\") {\n-            // remove %<whitespace>\n+        if line.starts_with(\"# \") || line.starts_with(\"%\") {\n+            // trim the whitespace after the symbol\n             metadata.push(line[1..].trim_left());\n             count += line.len() + 1;\n         } else {\n             return (metadata, &s[count..]);\n         }\n     }\n-    // if we're here, then all lines were metadata % lines.\n+\n+    // if we're here, then all lines were metadata `# ` or `%` lines.\n     (metadata, \"\")\n }\n \n@@ -83,7 +85,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     if metadata.is_empty() {\n         let _ = writeln!(\n             &mut io::stderr(),\n-            \"rustdoc: invalid markdown file: expecting initial line with `% ...TITLE...`\"\n+            \"rustdoc: invalid markdown file: no initial lines starting with `# ` or `%`\"\n         );\n         return 5;\n     }"}, {"sha": "1cac11f668d95ebc90366af15145066816921d16", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -17,7 +17,7 @@ use mem;\n use ops::Range;\n use iter::FusedIterator;\n \n-/// Extension methods for ASCII-subset only operations on string slices.\n+/// Extension methods for ASCII-subset only operations.\n ///\n /// Be aware that operations on seemingly non-ASCII characters can sometimes\n /// have unexpected results. Consider this example:\n@@ -54,19 +54,21 @@ pub trait AsciiExt {\n     ///\n     /// let ascii = 'a';\n     /// let utf8 = '\u2764';\n+    /// let int_ascii = 97;\n     ///\n     /// assert!(ascii.is_ascii());\n     /// assert!(!utf8.is_ascii());\n+    /// assert!(int_ascii.is_ascii());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_ascii(&self) -> bool;\n \n-    /// Makes a copy of the string in ASCII upper case.\n+    /// Makes a copy of the value in its ASCII upper case equivalent.\n     ///\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To uppercase the string in-place, use [`make_ascii_uppercase`].\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n     ///\n     /// To uppercase ASCII characters in addition to non-ASCII characters, use\n     /// [`str::to_uppercase`].\n@@ -78,22 +80,24 @@ pub trait AsciiExt {\n     ///\n     /// let ascii = 'a';\n     /// let utf8 = '\u2764';\n+    /// let int_ascii = 97;\n     ///\n     /// assert_eq!('A', ascii.to_ascii_uppercase());\n     /// assert_eq!('\u2764', utf8.to_ascii_uppercase());\n+    /// assert_eq!(65, int_ascii.to_ascii_uppercase());\n     /// ```\n     ///\n     /// [`make_ascii_uppercase`]: #tymethod.make_ascii_uppercase\n     /// [`str::to_uppercase`]: ../primitive.str.html#method.to_uppercase\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_ascii_uppercase(&self) -> Self::Owned;\n \n-    /// Makes a copy of the string in ASCII lower case.\n+    /// Makes a copy of the value in its ASCII lower case equivalent.\n     ///\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To lowercase the string in-place, use [`make_ascii_lowercase`].\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n     ///\n     /// To lowercase ASCII characters in addition to non-ASCII characters, use\n     /// [`str::to_lowercase`].\n@@ -105,20 +109,22 @@ pub trait AsciiExt {\n     ///\n     /// let ascii = 'A';\n     /// let utf8 = '\u2764';\n+    /// let int_ascii = 65;\n     ///\n     /// assert_eq!('a', ascii.to_ascii_lowercase());\n     /// assert_eq!('\u2764', utf8.to_ascii_lowercase());\n+    /// assert_eq!(97, int_ascii.to_ascii_lowercase());\n     /// ```\n     ///\n     /// [`make_ascii_lowercase`]: #tymethod.make_ascii_lowercase\n     /// [`str::to_lowercase`]: ../primitive.str.html#method.to_lowercase\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_ascii_lowercase(&self) -> Self::Owned;\n \n-    /// Checks that two strings are an ASCII case-insensitive match.\n+    /// Checks that two values are an ASCII case-insensitive match.\n     ///\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n-    /// but without allocating and copying temporary strings.\n+    /// but without allocating and copying temporaries.\n     ///\n     /// # Examples\n     ///\n@@ -142,7 +148,7 @@ pub trait AsciiExt {\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To return a new uppercased string without modifying the existing one, use\n+    /// To return a new uppercased value without modifying the existing one, use\n     /// [`to_ascii_uppercase`].\n     ///\n     /// # Examples\n@@ -166,7 +172,7 @@ pub trait AsciiExt {\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n     ///\n-    /// To return a new lowercased string without modifying the existing one, use\n+    /// To return a new lowercased value without modifying the existing one, use\n     /// [`to_ascii_lowercase`].\n     ///\n     /// # Examples"}, {"sha": "c34491941d69010a25f60a5ec6aa3ac947c36f98", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -14,22 +14,24 @@\n \n use fmt;\n \n-#[cfg(any(target_os = \"android\",\n-          target_os = \"emscripten\",\n+#[cfg(any(target_os = \"emscripten\",\n           all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                        target_arch = \"arm\",\n                                        target_arch = \"powerpc\",\n                                        target_arch = \"powerpc64\",\n                                        target_arch = \"s390x\")),\n+          all(target_os = \"android\", any(target_arch = \"aarch64\",\n+                                         target_arch = \"arm\")),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg(not(any(target_os = \"android\",\n-              target_os = \"emscripten\",\n+#[cfg(not(any(target_os = \"emscripten\",\n               all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                            target_arch = \"arm\",\n                                            target_arch = \"powerpc\",\n                                            target_arch = \"powerpc64\",\n                                            target_arch = \"s390x\")),\n+              all(target_os = \"android\", any(target_arch = \"aarch64\",\n+                                             target_arch = \"arm\")),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;"}, {"sha": "d688f2fa504517cb3fe450b15f68cc8ea7005f6e", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -641,7 +641,7 @@ impl UnixListener {\n                 let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n                 let (addr, len) = sockaddr_un(path)?;\n \n-                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n+                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n                 cvt(libc::listen(*inner.as_inner(), 128))?;\n \n                 Ok(UnixListener(inner))\n@@ -920,7 +920,7 @@ impl UnixDatagram {\n                 let socket = UnixDatagram::unbound()?;\n                 let (addr, len) = sockaddr_un(path)?;\n \n-                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len))?;\n+                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n \n                 Ok(socket)\n             }"}, {"sha": "e9f41009064ca43ea267861b2bfe76cc8fd64718", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -417,12 +417,26 @@ mod tests {\n         }\n     }\n \n+    // Android with api less than 21 define sig* functions inline, so it is not\n+    // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n+    // to support older Android version (independent of libc version).\n+    // The following implementations are based on https://git.io/vSkNf\n+\n     #[cfg(not(target_os = \"android\"))]\n     extern {\n+        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n+        fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n+\n         #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n         fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n     }\n \n+    #[cfg(target_os = \"android\")]\n+    unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n+        libc::memset(set as *mut _, 0, mem::size_of::<libc::sigset_t>());\n+        return 0;\n+    }\n+\n     #[cfg(target_os = \"android\")]\n     unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n         use slice;\n@@ -450,7 +464,7 @@ mod tests {\n \n             let mut set: libc::sigset_t = mem::uninitialized();\n             let mut old_set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(libc::sigemptyset(&mut set)));\n+            t!(cvt(sigemptyset(&mut set)));\n             t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n "}, {"sha": "edd322ca6fa0708b1e4a928f7ecdb3ff66e5480c", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -193,7 +193,16 @@ impl Command {\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n             let mut set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(libc::sigemptyset(&mut set)));\n+            if cfg!(target_os = \"android\") {\n+                // Implementing sigemptyset allow us to support older Android\n+                // versions. See the comment about Android and sig* functions in\n+                // process_common.rs\n+                libc::memset(&mut set as *mut _ as *mut _,\n+                             0,\n+                             mem::size_of::<libc::sigset_t>());\n+            } else {\n+                t!(cvt(libc::sigemptyset(&mut set)));\n+            }\n             t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n                                          ptr::null_mut())));\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);"}, {"sha": "dfbc1b581ee55f39b4bb22366beb1240e3c4c79a", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -257,8 +257,13 @@ impl Stdio {\n             // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => {\n                 match stdio::get(stdio_id) {\n-                    Ok(io) => io.handle().duplicate(0, true,\n-                                                    c::DUPLICATE_SAME_ACCESS),\n+                    Ok(io) => {\n+                        let io = Handle::new(io.handle());\n+                        let ret = io.duplicate(0, true,\n+                                               c::DUPLICATE_SAME_ACCESS);\n+                        io.into_raw();\n+                        return ret\n+                    }\n                     Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n                 }\n             }"}, {"sha": "d72e4b4438b7bc8d367638bcb55ec96a6bf77474", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -22,42 +22,43 @@ use sys::cvt;\n use sys::handle::Handle;\n use sys_common::io::read_to_end_uninitialized;\n \n-pub struct NoClose(Option<Handle>);\n-\n pub enum Output {\n-    Console(NoClose),\n-    Pipe(NoClose),\n+    Console(c::HANDLE),\n+    Pipe(c::HANDLE),\n }\n \n pub struct Stdin {\n-    handle: Output,\n     utf8: Mutex<io::Cursor<Vec<u8>>>,\n }\n-pub struct Stdout(Output);\n-pub struct Stderr(Output);\n+pub struct Stdout;\n+pub struct Stderr;\n \n pub fn get(handle: c::DWORD) -> io::Result<Output> {\n     let handle = unsafe { c::GetStdHandle(handle) };\n     if handle == c::INVALID_HANDLE_VALUE {\n         Err(io::Error::last_os_error())\n     } else if handle.is_null() {\n-        Err(io::Error::new(io::ErrorKind::Other,\n-                           \"no stdio handle available for this process\"))\n+        Err(io::Error::from_raw_os_error(c::ERROR_INVALID_HANDLE as i32))\n     } else {\n-        let ret = NoClose::new(handle);\n         let mut out = 0;\n         match unsafe { c::GetConsoleMode(handle, &mut out) } {\n-            0 => Ok(Output::Pipe(ret)),\n-            _ => Ok(Output::Console(ret)),\n+            0 => Ok(Output::Pipe(handle)),\n+            _ => Ok(Output::Console(handle)),\n         }\n     }\n }\n \n-fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n-    let handle = match *out {\n-        Output::Console(ref c) => c.get().raw(),\n-        Output::Pipe(ref p) => return p.get().write(data),\n+fn write(handle: c::DWORD, data: &[u8]) -> io::Result<usize> {\n+    let handle = match try!(get(handle)) {\n+        Output::Console(c) => c,\n+        Output::Pipe(p) => {\n+            let handle = Handle::new(p);\n+            let ret = handle.write(data);\n+            handle.into_raw();\n+            return ret\n+        }\n     };\n+\n     // As with stdin on windows, stdout often can't handle writes of large\n     // sizes. For an example, see #14940. For this reason, don't try to\n     // write the entire output buffer on windows.\n@@ -93,18 +94,20 @@ fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n \n impl Stdin {\n     pub fn new() -> io::Result<Stdin> {\n-        get(c::STD_INPUT_HANDLE).map(|handle| {\n-            Stdin {\n-                handle: handle,\n-                utf8: Mutex::new(Cursor::new(Vec::new())),\n-            }\n+        Ok(Stdin {\n+            utf8: Mutex::new(Cursor::new(Vec::new())),\n         })\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let handle = match self.handle {\n-            Output::Console(ref c) => c.get().raw(),\n-            Output::Pipe(ref p) => return p.get().read(buf),\n+        let handle = match try!(get(c::STD_INPUT_HANDLE)) {\n+            Output::Console(c) => c,\n+            Output::Pipe(p) => {\n+                let handle = Handle::new(p);\n+                let ret = handle.read(buf);\n+                handle.into_raw();\n+                return ret\n+            }\n         };\n         let mut utf8 = self.utf8.lock().unwrap();\n         // Read more if the buffer is empty\n@@ -125,11 +128,9 @@ impl Stdin {\n                 Ok(utf8) => utf8.into_bytes(),\n                 Err(..) => return Err(invalid_encoding()),\n             };\n-            if let Output::Console(_) = self.handle {\n-                if let Some(&last_byte) = data.last() {\n-                    if last_byte == CTRL_Z {\n-                        data.pop();\n-                    }\n+            if let Some(&last_byte) = data.last() {\n+                if last_byte == CTRL_Z {\n+                    data.pop();\n                 }\n             }\n             *utf8 = Cursor::new(data);\n@@ -158,11 +159,11 @@ impl<'a> Read for &'a Stdin {\n \n impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n-        get(c::STD_OUTPUT_HANDLE).map(Stdout)\n+        Ok(Stdout)\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(&self.0, data)\n+        write(c::STD_OUTPUT_HANDLE, data)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n@@ -172,11 +173,11 @@ impl Stdout {\n \n impl Stderr {\n     pub fn new() -> io::Result<Stderr> {\n-        get(c::STD_ERROR_HANDLE).map(Stderr)\n+        Ok(Stderr)\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        write(&self.0, data)\n+        write(c::STD_ERROR_HANDLE, data)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n@@ -197,27 +198,12 @@ impl io::Write for Stderr {\n     }\n }\n \n-impl NoClose {\n-    fn new(handle: c::HANDLE) -> NoClose {\n-        NoClose(Some(Handle::new(handle)))\n-    }\n-\n-    fn get(&self) -> &Handle { self.0.as_ref().unwrap() }\n-}\n-\n-impl Drop for NoClose {\n-    fn drop(&mut self) {\n-        self.0.take().unwrap().into_raw();\n-    }\n-}\n-\n impl Output {\n-    pub fn handle(&self) -> &Handle {\n-        let nc = match *self {\n-            Output::Console(ref c) => c,\n-            Output::Pipe(ref c) => c,\n-        };\n-        nc.0.as_ref().unwrap()\n+    pub fn handle(&self) -> c::HANDLE {\n+        match *self {\n+            Output::Console(c) => c,\n+            Output::Pipe(c) => c,\n+        }\n     }\n }\n "}, {"sha": "9239c18e59717a2bf088859ff05a8dbbccfbe81a", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -339,7 +339,7 @@ impl TcpListener {\n \n         // Bind our new socket\n         let (addrp, len) = addr.into_inner();\n-        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) })?;\n+        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len as _) })?;\n \n         // Start listening\n         cvt(unsafe { c::listen(*sock.as_inner(), 128) })?;\n@@ -430,7 +430,7 @@ impl UdpSocket {\n \n         let sock = Socket::new(addr, c::SOCK_DGRAM)?;\n         let (addrp, len) = addr.into_inner();\n-        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) })?;\n+        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len as _) })?;\n         Ok(UdpSocket { inner: sock })\n     }\n "}, {"sha": "92e5369758b4e5914dff87ebfedbf2862ae02a42", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -842,11 +842,11 @@ impl char {\n     /// Returns an iterator that yields the uppercase equivalent of a `char`\n     /// as one or more `char`s.\n     ///\n-    /// If a character does not have a uppercase equivalent, the same character\n+    /// If a character does not have an uppercase equivalent, the same character\n     /// will be returned back by the iterator.\n     ///\n     /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its lowercase equivalent according to the\n+    /// one Unicode character to its uppercase equivalent according to the\n     /// [Unicode database] and the additional complex mappings\n     /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n     /// language) are not considered here."}, {"sha": "2d0994a7b78fb1b798f00cd04366b20fab589d7c", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -106,8 +106,8 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         match item.node {\n-            ast::ItemKind::Mac(ref mac) if !mac.node.path.segments.is_empty() => {}\n             ast::ItemKind::Mac(_) => return self.remove(item.id).make_items(),\n+            ast::ItemKind::MacroDef(_) => return SmallVector::one(item),\n             _ => {}\n         }\n "}, {"sha": "66f5520b8826371991822087a551cfc35277a80e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -119,7 +119,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 };\n                 let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), false);\n                 p.root_module_name = cx.current_expansion.module.mod_path.last()\n-                    .map(|id| (*id.name.as_str()).to_owned());\n+                    .map(|id| id.name.as_str().to_string());\n \n                 p.check_unknown_macro_variable();\n                 // Let the context choose how to interpret the result."}, {"sha": "9d280a413e666c5403015bcbdc9ccec310febd68", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -818,7 +818,7 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = &*cfg.name().as_str();\n+        let name = cfg.name().as_str();\n         GATED_CFGS.iter()\n                   .position(|info| info.0 == name)\n                   .map(|idx| {\n@@ -865,8 +865,7 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = unwrap_or!(attr.name(), return);\n-\n+        let name = unwrap_or!(attr.name(), return).as_str();\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if name == n {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n@@ -885,12 +884,12 @@ impl<'a> Context<'a> {\n                 return;\n             }\n         }\n-        if name.as_str().starts_with(\"rustc_\") {\n+        if name.starts_with(\"rustc_\") {\n             gate_feature!(self, rustc_attrs, attr.span,\n                           \"unless otherwise specified, attributes \\\n                            with the prefix `rustc_` \\\n                            are reserved for internal compiler diagnostics\");\n-        } else if name.as_str().starts_with(\"derive_\") {\n+        } else if name.starts_with(\"derive_\") {\n             gate_feature!(self, custom_derive, attr.span, EXPLAIN_DERIVE_UNDERSCORE);\n         } else if !attr::is_known(attr) {\n             // Only run the custom attribute lint during regular"}, {"sha": "43a9d8c5f787c77bcc993e6f5a701c668e97b95f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -5151,15 +5151,15 @@ impl<'a> Parser<'a> {\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n         if let Some(path) = attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            self.directory.path.push(&*path.as_str());\n+            self.directory.path.push(&path.as_str());\n             self.directory.ownership = DirectoryOwnership::Owned;\n         } else {\n-            self.directory.path.push(&*id.name.as_str());\n+            self.directory.path.push(&id.name.as_str());\n         }\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d.as_str()))\n+        attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&d.as_str()))\n     }\n \n     /// Returns either a path to a module, or ."}, {"sha": "2acbeee426beead4b72b286e16bfffacf89957ad", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -72,9 +72,9 @@ impl Decodable for Symbol {\n     }\n }\n \n-impl<'a> PartialEq<&'a str> for Symbol {\n-    fn eq(&self, other: &&str) -> bool {\n-        *self.as_str() == **other\n+impl<T: ::std::ops::Deref<Target=str>> PartialEq<T> for Symbol {\n+    fn eq(&self, other: &T) -> bool {\n+        self.as_str() == other.deref()\n     }\n }\n \n@@ -244,11 +244,47 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n /// destroyed. In particular, they must not access string contents. This can\n /// be fixed in the future by just leaking all strings until thread death\n /// somehow.\n-#[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n+#[derive(Clone, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n     string: &'static str,\n }\n \n+impl<U: ?Sized> ::std::convert::AsRef<U> for InternedString where str: ::std::convert::AsRef<U> {\n+    fn as_ref(&self) -> &U {\n+        self.string.as_ref()\n+    }\n+}\n+\n+impl<T: ::std::ops::Deref<Target = str>> ::std::cmp::PartialEq<T> for InternedString {\n+    fn eq(&self, other: &T) -> bool {\n+        self.string == other.deref()\n+    }\n+}\n+\n+impl ::std::cmp::PartialEq<InternedString> for str {\n+    fn eq(&self, other: &InternedString) -> bool {\n+        self == other.string\n+    }\n+}\n+\n+impl<'a> ::std::cmp::PartialEq<InternedString> for &'a str {\n+    fn eq(&self, other: &InternedString) -> bool {\n+        *self == other.string\n+    }\n+}\n+\n+impl ::std::cmp::PartialEq<InternedString> for String {\n+    fn eq(&self, other: &InternedString) -> bool {\n+        self == other.string\n+    }\n+}\n+\n+impl<'a> ::std::cmp::PartialEq<InternedString> for &'a String {\n+    fn eq(&self, other: &InternedString) -> bool {\n+        *self == other.string\n+    }\n+}\n+\n impl !Send for InternedString { }\n \n impl ::std::ops::Deref for InternedString {"}, {"sha": "6fb6db9ca0282fd09cac855a9f6f3838714694ea", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -616,7 +616,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs) {\n-        Some(s) if \"test\" == &*s.as_str() => true,\n+        Some(s) if \"test\" == s.as_str() => true,\n         _ => false\n     }\n }"}, {"sha": "c5604a0427b2ae0866e45aa57ecd8133e647718a", "filename": "src/test/compile-fail/issue-40845.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftest%2Fcompile-fail%2Fissue-40845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftest%2Fcompile-fail%2Fissue-40845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40845.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait T { m!(); } //~ ERROR cannot find macro `m!` in this scope\n+\n+struct S;\n+impl S { m!(); } //~ ERROR cannot find macro `m!` in this scope\n+\n+fn main() {}"}, {"sha": "4542e27545a4c9768dbb1054431635b359fb5ad4", "filename": "src/test/run-pass-fulldeps/switch-stdout.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fswitch-stdout.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_back;\n+\n+use std::fs::File;\n+use std::io::{Read, Write};\n+\n+use rustc_back::tempdir::TempDir;\n+\n+#[cfg(unix)]\n+fn switch_stdout_to(file: File) {\n+    use std::os::unix::prelude::*;\n+\n+    extern {\n+        fn dup2(old: i32, new: i32) -> i32;\n+    }\n+\n+    unsafe {\n+        assert_eq!(dup2(file.as_raw_fd(), 1), 1);\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn switch_stdout_to(file: File) {\n+    use std::os::windows::prelude::*;\n+\n+    extern \"system\" {\n+        fn SetStdHandle(nStdHandle: u32, handle: *mut u8) -> i32;\n+    }\n+\n+    const STD_OUTPUT_HANDLE: u32 = (-11i32) as u32;\n+\n+    unsafe {\n+        let rc = SetStdHandle(STD_OUTPUT_HANDLE,\n+                              file.into_raw_handle() as *mut _);\n+        assert!(rc != 0);\n+    }\n+}\n+\n+fn main() {\n+    let td = TempDir::new(\"foo\").unwrap();\n+    let path = td.path().join(\"bar\");\n+    let f = File::create(&path).unwrap();\n+\n+    println!(\"foo\");\n+    std::io::stdout().flush().unwrap();\n+    switch_stdout_to(f);\n+    println!(\"bar\");\n+    std::io::stdout().flush().unwrap();\n+\n+    let mut contents = String::new();\n+    File::open(&path).unwrap().read_to_string(&mut contents).unwrap();\n+    assert_eq!(contents, \"bar\\n\");\n+}"}, {"sha": "599d0b273e3f14e7798f08b689818c1bb36c3717", "filename": "src/test/run-pass/issue-40770.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftest%2Frun-pass%2Fissue-40770.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftest%2Frun-pass%2Fissue-40770.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-40770.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m {\n+    ($e:expr) => {\n+        macro_rules! n { () => { $e } }\n+    }\n+}\n+\n+fn main() {\n+    m!(foo!());\n+}"}, {"sha": "3d8f2296236a2014c6c60df5657c7ab5fd522b26", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a34293faeb10757944ce2fa9d552cc2b189583/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=07a34293faeb10757944ce2fa9d552cc2b189583", "patch": "@@ -58,24 +58,8 @@ pub fn run(lib_path: &str,\n     let mut cmd = Command::new(prog);\n     cmd.args(args)\n         .stdout(Stdio::piped())\n-        .stderr(Stdio::piped());\n-\n-    // Why oh why do we sometimes make a pipe and sometimes inherit the stdin\n-    // stream, well that's an excellent question! In theory it should suffice to\n-    // always create a pipe here and be done with it. Unfortunately though\n-    // there's apparently something odd with the gdb that comes with gcc 6.3.0\n-    // on MinGW. Tracked at rust-lang/rust#40184 when stdin is piped here\n-    // (unconditionally) then all gdb tests will fail on MinGW when using gcc\n-    // 6.3.0. WHen using an inherited stdin though they happen to all work!\n-    //\n-    // As to why this fixes the issue, well, I have no idea. If you can remove\n-    // this branch and unconditionally use `piped` and it gets past @bors please\n-    // feel free to send a PR!\n-    if input.is_some() || !cfg!(windows) {\n-        cmd.stdin(Stdio::piped());\n-    } else {\n-        cmd.stdin(Stdio::inherit());\n-    }\n+        .stderr(Stdio::piped())\n+        .stdin(Stdio::piped());\n \n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {"}]}