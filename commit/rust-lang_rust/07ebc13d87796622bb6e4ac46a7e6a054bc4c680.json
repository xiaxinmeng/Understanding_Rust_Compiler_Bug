{"sha": "07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "node_id": "C_kwDOAAsO6NoAKDA3ZWJjMTNkODc3OTY2MjJiYjZlNGFjNDZhN2U2YTA1NGJjNGM2ODA", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-03-03T10:15:25Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-03-14T15:49:06Z"}, "message": "debuginfo: Refactor debuginfo generation for types\n\nThis commit\n- changes names to use di_node instead of metadata\n- uniformly names all functions that build new debuginfo nodes build_xyz_di_node\n- renames CrateDebugContext to CodegenUnitDebugContext (which is more accurate)\n- moves TypeMap and functions that work directly work with it to a new type_map module\n- moves and reimplements enum related builder functions to a new enums module\n- splits enum debuginfo building for the native and cpp-like cases, since they are mostly separate\n- uses SmallVec instead of Vec in many places\n- removes the old infrastructure for dealing with recursion cycles (create_and_register_recursive_type_forward_declaration(), RecursiveTypeDescription, set_members_of_composite_type(), MemberDescription, MemberDescriptionFactory, prepare_xyz_metadata(), etc)\n- adds type_map::build_type_with_children() as a replacement for dealing with recursion cycles\n- adds many (doc-)comments explaining what's going on\n- changes cpp-like naming for C-Style enums so they don't get a enum$<...> name (because the NatVis visualizer does not apply to them)\n- fixes detection of what is a C-style enum because some enums where classified as C-style even though they have fields\n- changes the position of discriminant debuginfo node so it is consistently nested inside the top-level union instead of, sometimes, next to it", "tree": {"sha": "2659b10121db9d5ea098465f8b19073bab9d8397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2659b10121db9d5ea098465f8b19073bab9d8397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "html_url": "https://github.com/rust-lang/rust/commit/07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ac4658909c967eac914ab098e81a6e98b742e72", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac4658909c967eac914ab098e81a6e98b742e72", "html_url": "https://github.com/rust-lang/rust/commit/0ac4658909c967eac914ab098e81a6e98b742e72"}], "stats": {"total": 4057, "additions": 2293, "deletions": 1764}, "files": [{"sha": "b647cfa5f4a6e999979966911798b2cb73d0a150", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -140,8 +140,8 @@ pub(crate) unsafe fn codegen(\n     llvm::LLVMDisposeBuilder(llbuilder);\n \n     if tcx.sess.opts.debuginfo != DebugInfo::None {\n-        let dbg_cx = debuginfo::CrateDebugContext::new(llmod);\n-        debuginfo::metadata::compile_unit_metadata(tcx, module_name, &dbg_cx);\n+        let dbg_cx = debuginfo::CodegenUnitDebugContext::new(llmod);\n+        debuginfo::metadata::build_compile_unit_di_node(tcx, module_name, &dbg_cx);\n         dbg_cx.finalize(tcx.sess);\n     }\n }"}, {"sha": "413ef0ba764642f3feafb20766e70deb580fbe0a", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -428,7 +428,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n \n-            debuginfo::create_global_var_metadata(self, def_id, g);\n+            debuginfo::build_global_var_di_node(self, def_id, g);\n \n             if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n                 llvm::set_thread_local_mode(g, self.tls_model);"}, {"sha": "9fbc33d4b05d4075ee78819a52cb62b84a2f260c", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -95,7 +95,7 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub isize_ty: &'ll Type,\n \n     pub coverage_cx: Option<coverageinfo::CrateCoverageContext<'ll, 'tcx>>,\n-    pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n+    pub dbg_cx: Option<debuginfo::CodegenUnitDebugContext<'ll, 'tcx>>,\n \n     eh_personality: Cell<Option<&'ll Value>>,\n     eh_catch_typeinfo: Cell<Option<&'ll Value>>,\n@@ -396,8 +396,12 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         };\n \n         let dbg_cx = if tcx.sess.opts.debuginfo != DebugInfo::None {\n-            let dctx = debuginfo::CrateDebugContext::new(llmod);\n-            debuginfo::metadata::compile_unit_metadata(tcx, codegen_unit.name().as_str(), &dctx);\n+            let dctx = debuginfo::CodegenUnitDebugContext::new(llmod);\n+            debuginfo::metadata::build_compile_unit_di_node(\n+                tcx,\n+                codegen_unit.name().as_str(),\n+                &dctx,\n+            );\n             Some(dctx)\n         } else {\n             None"}, {"sha": "488dbe3456be3a0c2565a8d56c59dfb6b56b43f6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 534, "deletions": 1691, "changes": 2225, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680"}, {"sha": "e9772cd78d7626de9aaad652f44eca00c2488ada", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "added", "additions": 515, "deletions": 0, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -0,0 +1,515 @@\n+use std::borrow::Cow;\n+\n+use libc::c_uint;\n+use rustc_codegen_ssa::debuginfo::{\n+    type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo,\n+};\n+use rustc_middle::{\n+    bug,\n+    ty::{\n+        self,\n+        layout::{LayoutOf, TyAndLayout},\n+        util::Discr,\n+        AdtDef, GeneratorSubsts,\n+    },\n+};\n+use rustc_target::abi::{Size, TagEncoding, VariantIdx, Variants};\n+use smallvec::smallvec;\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::{\n+        metadata::{\n+            build_field_di_node, closure_saved_names_of_captured_variables,\n+            enums::tag_base_type,\n+            file_metadata, generator_layout_and_saved_local_names, size_and_align_of,\n+            type_map::{self, UniqueTypeId},\n+            unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n+            UNKNOWN_LINE_NUMBER,\n+        },\n+        utils::DIB,\n+    },\n+    llvm::{\n+        self,\n+        debuginfo::{DIFile, DIFlags, DIType},\n+    },\n+};\n+\n+/// In CPP-like mode, we generate a union of structs for each variant and an\n+/// explicit discriminant field roughly equivalent to the following C/C++ code:\n+///\n+/// ```c\n+/// union enum$<{fully-qualified-name}> {\n+///   struct {variant 0 name} {\n+///     <variant 0 fields>\n+///   } variant0;\n+///   <other variant structs>\n+///   {name} discriminant;\n+/// }\n+/// ```\n+///\n+/// As you can see, the type name is wrapped `enum$`. This way we can have a\n+/// single NatVis rule for handling all enums.\n+///\n+/// At the LLVM IR level this looks like\n+///\n+/// ```txt\n+///       DW_TAG_union_type              (top-level type for enum)\n+///         DW_TAG_member                    (member for variant 1)\n+///         DW_TAG_member                    (member for variant 2)\n+///         DW_TAG_member                    (member for variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+///         DW_TAG_enumeration_type          (type of tag)\n+/// ```\n+///\n+/// The above encoding applies for enums with a direct tag. For niche-tag we have to do things\n+/// differently in order to allow a NatVis visualizer to extract all the information needed:\n+/// We generate a union of two fields, one for the dataful variant\n+/// and one that just points to the discriminant (which is some field within the dataful variant).\n+/// We also create a DW_TAG_enumeration_type DIE that contains tag values for the non-dataful\n+/// variants and make the discriminant field that type. We then use NatVis to render the enum type\n+/// correctly in Windbg/VS. This will generate debuginfo roughly equivalent to the following C:\n+///\n+/// ```c\n+/// union enum$<{name}, {min niche}, {max niche}, {dataful variant name}> {\n+///   struct <dataful variant name> {\n+///     <fields in dataful variant>\n+///   } dataful_variant;\n+///   enum Discriminant$ {\n+///     <non-dataful variants>\n+///   } discriminant;\n+/// }\n+/// ```\n+///\n+/// The NatVis in `intrinsic.natvis` matches on the type name `enum$<*, *, *, *>`\n+/// and evaluates `this.discriminant`. If the value is between the min niche and max\n+/// niche, then the enum is in the dataful variant and `this.dataful_variant` is\n+/// rendered. Otherwise, the enum is in one of the non-dataful variants. In that\n+/// case, we just need to render the name of the `this.discriminant` enum.\n+pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let enum_type = unique_type_id.expect_ty();\n+    let &ty::Adt(enum_adt_def, _) = enum_type.kind() else {\n+        bug!(\"build_enum_type_di_node() called with non-enum type: `{:?}`\", enum_type)\n+        };\n+\n+    let enum_type_and_layout = cx.layout_of(enum_type);\n+    let enum_type_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(enum_type_and_layout));\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            type_map::Stub::Union,\n+            unique_type_id,\n+            &enum_type_name,\n+            cx.size_and_align_of(enum_type),\n+            NO_SCOPE_METADATA,\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, enum_type_di_node| {\n+            match enum_type_and_layout.variants {\n+                Variants::Single { index: variant_index } => {\n+                    if enum_adt_def.variants().is_empty() {\n+                        // Uninhabited enums have Variants::Single. We don't generate\n+                        // any members for them.\n+                        return smallvec![];\n+                    }\n+\n+                    build_single_variant_union_fields(\n+                        cx,\n+                        enum_adt_def,\n+                        enum_type_and_layout,\n+                        enum_type_di_node,\n+                        variant_index,\n+                    )\n+                }\n+                Variants::Multiple {\n+                    tag_encoding: TagEncoding::Direct,\n+                    ref variants,\n+                    tag_field,\n+                    ..\n+                } => build_union_fields_for_direct_tag_enum(\n+                    cx,\n+                    enum_adt_def,\n+                    enum_type_and_layout,\n+                    enum_type_di_node,\n+                    &mut variants.indices(),\n+                    tag_field,\n+                ),\n+                Variants::Multiple {\n+                    tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                    ref variants,\n+                    tag_field,\n+                    ..\n+                } => build_union_fields_for_niche_tag_enum(\n+                    cx,\n+                    enum_adt_def,\n+                    enum_type_and_layout,\n+                    enum_type_di_node,\n+                    dataful_variant,\n+                    &mut variants.indices(),\n+                    tag_field,\n+                ),\n+            }\n+        },\n+        NO_GENERICS,\n+    )\n+}\n+\n+/// A generator debuginfo node looks the same as a that of an enum type.\n+///\n+/// See [build_enum_type_di_node] for more information.\n+pub(super) fn build_generator_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let generator_type = unique_type_id.expect_ty();\n+    let generator_type_and_layout = cx.layout_of(generator_type);\n+    let generator_type_name = compute_debuginfo_type_name(cx.tcx, generator_type, false);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(generator_type_and_layout));\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            type_map::Stub::Union,\n+            unique_type_id,\n+            &generator_type_name,\n+            size_and_align_of(generator_type_and_layout),\n+            NO_SCOPE_METADATA,\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, generator_type_di_node| match generator_type_and_layout.variants {\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => {\n+                build_union_fields_for_direct_tag_generator(\n+                    cx,\n+                    generator_type_and_layout,\n+                    generator_type_di_node,\n+                )\n+            }\n+            Variants::Single { .. }\n+            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => {\n+                bug!(\n+                    \"Encountered generator with non-direct-tag layout: {:?}\",\n+                    generator_type_and_layout\n+                )\n+            }\n+        },\n+        NO_GENERICS,\n+    )\n+}\n+\n+fn build_single_variant_union_fields<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_index: VariantIdx,\n+) -> SmallVec<&'ll DIType> {\n+    let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n+    let variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+        cx,\n+        enum_type_and_layout.ty,\n+        enum_type_di_node,\n+        variant_index,\n+        enum_adt_def.variant(variant_index),\n+        variant_layout,\n+    );\n+\n+    // NOTE: The field name of the union is the same as the variant name, not \"variant0\".\n+    let variant_name = enum_adt_def.variant(variant_index).name.as_str();\n+\n+    smallvec![build_field_di_node(\n+        cx,\n+        enum_type_di_node,\n+        variant_name,\n+        // NOTE: We use the size and align of the entire type, not from variant_layout\n+        //       since the later is sometimes smaller (if it has fewer fields).\n+        size_and_align_of(enum_type_and_layout),\n+        Size::ZERO,\n+        DIFlags::FlagZero,\n+        variant_struct_type_di_node,\n+    )]\n+}\n+\n+fn build_union_fields_for_direct_tag_enum<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n+    tag_field: usize,\n+) -> SmallVec<&'ll DIType> {\n+    let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_indices\n+        .map(|variant_index| {\n+            let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n+\n+            VariantFieldInfo {\n+                variant_index,\n+                variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n+                    cx,\n+                    enum_type_and_layout.ty,\n+                    enum_type_di_node,\n+                    variant_index,\n+                    enum_adt_def.variant(variant_index),\n+                    variant_layout,\n+                ),\n+                source_info: None,\n+            }\n+        })\n+        .collect();\n+\n+    let discr_type_name = cx.tcx.item_name(enum_adt_def.did());\n+    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n+    let discr_type_di_node = super::build_enumeration_type_di_node(\n+        cx,\n+        discr_type_name.as_str(),\n+        tag_base_type,\n+        &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n+            (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n+        }),\n+        enum_type_di_node,\n+    );\n+\n+    build_union_fields_for_direct_tag_enum_or_generator(\n+        cx,\n+        enum_type_and_layout,\n+        enum_type_di_node,\n+        &variant_field_infos,\n+        discr_type_di_node,\n+        tag_field,\n+    )\n+}\n+\n+fn build_union_fields_for_niche_tag_enum<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    dataful_variant_index: VariantIdx,\n+    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n+    tag_field: usize,\n+) -> SmallVec<&'ll DIType> {\n+    let dataful_variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+        cx,\n+        enum_type_and_layout.ty,\n+        enum_type_di_node,\n+        dataful_variant_index,\n+        &enum_adt_def.variant(dataful_variant_index),\n+        enum_type_and_layout.for_variant(cx, dataful_variant_index),\n+    );\n+\n+    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n+    // Create an DW_TAG_enumerator for each variant except the dataful one.\n+    let discr_type_di_node = super::build_enumeration_type_di_node(\n+        cx,\n+        \"Discriminant$\",\n+        tag_base_type,\n+        &mut variant_indices.filter_map(|variant_index| {\n+            if let Some(discr_val) =\n+                super::compute_discriminant_value(cx, enum_type_and_layout, variant_index)\n+            {\n+                let discr = Discr { val: discr_val as u128, ty: tag_base_type };\n+                let variant_name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n+                Some((discr, variant_name))\n+            } else {\n+                debug_assert_eq!(variant_index, dataful_variant_index);\n+                None\n+            }\n+        }),\n+        enum_type_di_node,\n+    );\n+\n+    smallvec![\n+        build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            \"dataful_variant\",\n+            size_and_align_of(enum_type_and_layout),\n+            Size::ZERO,\n+            DIFlags::FlagZero,\n+            dataful_variant_struct_type_di_node,\n+        ),\n+        build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            \"discriminant\",\n+            cx.size_and_align_of(tag_base_type),\n+            enum_type_and_layout.fields.offset(tag_field),\n+            DIFlags::FlagZero,\n+            discr_type_di_node,\n+        ),\n+    ]\n+}\n+\n+fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    generator_type_and_layout: TyAndLayout<'tcx>,\n+    generator_type_di_node: &'ll DIType,\n+) -> SmallVec<&'ll DIType> {\n+    let Variants::Multiple { tag_encoding: TagEncoding::Direct, tag_field, .. } = generator_type_and_layout.variants else {\n+        bug!(\"This function only supports layouts with direcly encoded tags.\")\n+    };\n+\n+    let (generator_def_id, generator_substs) = match generator_type_and_layout.ty.kind() {\n+        &ty::Generator(def_id, substs, _) => (def_id, substs.as_generator()),\n+        _ => unreachable!(),\n+    };\n+\n+    let (generator_layout, state_specific_upvar_names) =\n+        generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+\n+    let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+    let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n+\n+    // Build the type node for each field.\n+    let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_range\n+        .clone()\n+        .map(|variant_index| {\n+            let variant_struct_type_di_node = super::build_generator_variant_struct_type_di_node(\n+                cx,\n+                variant_index,\n+                generator_type_and_layout,\n+                generator_type_di_node,\n+                generator_layout,\n+                &state_specific_upvar_names,\n+                &common_upvar_names,\n+            );\n+\n+            let span = generator_layout.variant_source_info[variant_index].span;\n+            let source_info = if !span.is_dummy() {\n+                let loc = cx.lookup_debug_loc(span.lo());\n+                Some((file_metadata(cx, &loc.file), loc.line as c_uint))\n+            } else {\n+                None\n+            };\n+\n+            VariantFieldInfo { variant_index, variant_struct_type_di_node, source_info }\n+        })\n+        .collect();\n+\n+    let tag_base_type = tag_base_type(cx, generator_type_and_layout);\n+    let discr_type_name = \"Discriminant$\";\n+    let discr_type_di_node = super::build_enumeration_type_di_node(\n+        cx,\n+        discr_type_name,\n+        tag_base_type,\n+        &mut generator_substs\n+            .discriminants(generator_def_id, cx.tcx)\n+            .map(|(variant_index, discr)| (discr, GeneratorSubsts::variant_name(variant_index))),\n+        generator_type_di_node,\n+    );\n+\n+    build_union_fields_for_direct_tag_enum_or_generator(\n+        cx,\n+        generator_type_and_layout,\n+        generator_type_di_node,\n+        &variant_field_infos[..],\n+        discr_type_di_node,\n+        tag_field,\n+    )\n+}\n+\n+/// This is a helper function shared between enums and generators that makes sure fields have the\n+/// expect names.\n+fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_field_infos: &[VariantFieldInfo<'ll>],\n+    discr_type_di_node: &'ll DIType,\n+    tag_field: usize,\n+) -> SmallVec<&'ll DIType> {\n+    let mut unions_fields = SmallVec::with_capacity(variant_field_infos.len() + 1);\n+\n+    // We create a field in the union for each variant ...\n+    unions_fields.extend(variant_field_infos.into_iter().map(|variant_member_info| {\n+        let (file_di_node, line_number) = variant_member_info\n+            .source_info\n+            .unwrap_or_else(|| (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER));\n+\n+        let field_name = variant_union_field_name(variant_member_info.variant_index);\n+        let (size, align) = size_and_align_of(enum_type_and_layout);\n+\n+        // We use LLVMRustDIBuilderCreateMemberType() member type directly because\n+        // the build_field_di_node() function does not support specifying a source location,\n+        // which is something that we don't do anywhere else.\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateMemberType(\n+                DIB(cx),\n+                enum_type_di_node,\n+                field_name.as_ptr().cast(),\n+                field_name.len(),\n+                file_di_node,\n+                line_number,\n+                // NOTE: We use the size and align of the entire type, not from variant_layout\n+                //       since the later is sometimes smaller (if it has fewer fields).\n+                size.bits(),\n+                align.bits() as u32,\n+                // Union fields are always at offset zero\n+                Size::ZERO.bits(),\n+                DIFlags::FlagZero,\n+                variant_member_info.variant_struct_type_di_node,\n+            )\n+        }\n+    }));\n+\n+    debug_assert_eq!(\n+        cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n+        cx.size_and_align_of(super::tag_base_type(cx, enum_type_and_layout))\n+    );\n+\n+    // ... and a field for the discriminant.\n+    unions_fields.push(build_field_di_node(\n+        cx,\n+        enum_type_di_node,\n+        \"discriminant\",\n+        cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n+        enum_type_and_layout.fields.offset(tag_field),\n+        DIFlags::FlagZero,\n+        discr_type_di_node,\n+    ));\n+\n+    unions_fields\n+}\n+\n+/// Information about a single field of the top-level DW_TAG_union_type.\n+struct VariantFieldInfo<'ll> {\n+    variant_index: VariantIdx,\n+    variant_struct_type_di_node: &'ll DIType,\n+    source_info: Option<(&'ll DIFile, c_uint)>,\n+}\n+\n+fn variant_union_field_name(variant_index: VariantIdx) -> Cow<'static, str> {\n+    const PRE_ALLOCATED: [&str; 16] = [\n+        \"variant0\",\n+        \"variant1\",\n+        \"variant2\",\n+        \"variant3\",\n+        \"variant4\",\n+        \"variant5\",\n+        \"variant6\",\n+        \"variant7\",\n+        \"variant8\",\n+        \"variant9\",\n+        \"variant10\",\n+        \"variant11\",\n+        \"variant12\",\n+        \"variant13\",\n+        \"variant14\",\n+        \"variant15\",\n+    ];\n+\n+    PRE_ALLOCATED\n+        .get(variant_index.as_usize())\n+        .map(|&s| Cow::from(s))\n+        .unwrap_or_else(|| format!(\"variant{}\", variant_index.as_usize()).into())\n+}"}, {"sha": "e41f11b34c894e3081603e54ab6ca929ca5f4e36", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "added", "additions": 428, "deletions": 0, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -0,0 +1,428 @@\n+use rustc_codegen_ssa::debuginfo::{\n+    type_names::{compute_debuginfo_type_name, cpp_like_debuginfo},\n+    wants_c_like_enum_debuginfo,\n+};\n+use rustc_hir::def::CtorKind;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{\n+    bug,\n+    mir::{Field, GeneratorLayout, GeneratorSavedLocal},\n+    ty::{\n+        self,\n+        layout::{IntegerExt, LayoutOf, PrimitiveExt, TyAndLayout},\n+        util::Discr,\n+        AdtDef, GeneratorSubsts, Ty, VariantDef,\n+    },\n+};\n+use rustc_span::Symbol;\n+use rustc_target::abi::{HasDataLayout, Integer, Primitive, TagEncoding, VariantIdx, Variants};\n+use std::borrow::Cow;\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::{\n+        metadata::{\n+            build_field_di_node, build_generic_type_param_di_nodes, type_di_node,\n+            type_map::{self, Stub},\n+            unknown_file_metadata, UNKNOWN_LINE_NUMBER,\n+        },\n+        utils::{create_DIArray, get_namespace_for_item, DIB},\n+    },\n+    llvm::{\n+        self,\n+        debuginfo::{DIFlags, DIType},\n+    },\n+};\n+\n+use super::{\n+    size_and_align_of,\n+    type_map::{DINodeCreationResult, UniqueTypeId},\n+    SmallVec,\n+};\n+\n+mod cpp_like;\n+mod native;\n+\n+pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let enum_type = unique_type_id.expect_ty();\n+    let &ty::Adt(enum_adt_def, _) = enum_type.kind() else {\n+        bug!(\"build_enum_type_di_node() called with non-enum type: `{:?}`\", enum_type)\n+        };\n+\n+    let enum_type_and_layout = cx.layout_of(enum_type);\n+\n+    if wants_c_like_enum_debuginfo(enum_type_and_layout) {\n+        return build_c_style_enum_di_node(cx, enum_adt_def, enum_type_and_layout);\n+    }\n+\n+    if cpp_like_debuginfo(cx.tcx) {\n+        cpp_like::build_enum_type_di_node(cx, unique_type_id)\n+    } else {\n+        native::build_enum_type_di_node(cx, unique_type_id)\n+    }\n+}\n+\n+pub(super) fn build_generator_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    if cpp_like_debuginfo(cx.tcx) {\n+        cpp_like::build_generator_di_node(cx, unique_type_id)\n+    } else {\n+        native::build_generator_di_node(cx, unique_type_id)\n+    }\n+}\n+\n+/// Build the debuginfo node for a C-style enum, i.e. an enum the variants of which have no fields.\n+///\n+/// The resulting debuginfo will be a DW_TAG_enumeration_type.\n+fn build_c_style_enum_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_adt_def: AdtDef<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let containing_scope = get_namespace_for_item(cx, enum_adt_def.did());\n+    DINodeCreationResult {\n+        di_node: build_enumeration_type_di_node(\n+            cx,\n+            &compute_debuginfo_type_name(cx.tcx, enum_type_and_layout.ty, false),\n+            tag_base_type(cx, enum_type_and_layout),\n+            &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n+                (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n+            }),\n+            containing_scope,\n+        ),\n+        already_stored_in_typemap: false,\n+    }\n+}\n+\n+/// Extract the type with which we want to describe the tag of the given enum or generator.\n+fn tag_base_type<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+) -> Ty<'tcx> {\n+    debug_assert!(match enum_type_and_layout.ty.kind() {\n+        ty::Generator(..) => true,\n+        ty::Adt(adt_def, _) => adt_def.is_enum(),\n+        _ => false,\n+    });\n+\n+    // FIXME(mw): Why are niche and regular tags treated differently? Because we want to preserve\n+    //            the sign?\n+    match enum_type_and_layout.layout.variants() {\n+        // A single-variant enum has no discriminant.\n+        Variants::Single { .. } => {\n+            bug!(\"tag_base_type() called for enum without tag: {:?}\", enum_type_and_layout)\n+        }\n+\n+        Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, tag, .. } => {\n+            match tag.value {\n+                Primitive::Int(t, _) => t,\n+                Primitive::F32 => Integer::I32,\n+                Primitive::F64 => Integer::I64,\n+                Primitive::Pointer => {\n+                    // If the niche is the NULL value of a reference, then `discr_enum_ty` will be\n+                    // a RawPtr. CodeView doesn't know what to do with enums whose base type is a\n+                    // pointer so we fix this up to just be `usize`.\n+                    cx.data_layout().ptr_sized_integer()\n+                }\n+            }\n+            .to_ty(cx.tcx, false)\n+        }\n+\n+        Variants::Multiple { tag_encoding: TagEncoding::Direct, tag, .. } => {\n+            tag.value.to_ty(cx.tcx)\n+        }\n+    }\n+}\n+\n+/// This is a helper function. FIXME: elaborate docs.\n+fn build_enumeration_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    type_name: &str,\n+    base_type: Ty<'tcx>,\n+    variants: &mut dyn Iterator<Item = (Discr<'tcx>, Cow<'tcx, str>)>,\n+    containing_scope: &'ll DIType,\n+) -> &'ll DIType {\n+    let enumerator_di_nodes: SmallVec<Option<&'ll DIType>> = variants\n+        .map(|(discr, variant_name)| {\n+            let is_unsigned = match discr.ty.kind() {\n+                ty::Int(_) => false,\n+                ty::Uint(_) => true,\n+                _ => bug!(\"build_enumeration_type_di_node() called with non-integer tag type.\"),\n+            };\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                    DIB(cx),\n+                    variant_name.as_ptr().cast(),\n+                    variant_name.len(),\n+                    // FIXME: what if enumeration has i128 discriminant?\n+                    discr.val as i64,\n+                    is_unsigned,\n+                ))\n+            }\n+        })\n+        .collect();\n+\n+    let (size, align) = cx.size_and_align_of(base_type);\n+\n+    unsafe {\n+        llvm::LLVMRustDIBuilderCreateEnumerationType(\n+            DIB(cx),\n+            containing_scope,\n+            type_name.as_ptr().cast(),\n+            type_name.len(),\n+            unknown_file_metadata(cx),\n+            UNKNOWN_LINE_NUMBER,\n+            size.bits(),\n+            align.bits() as u32,\n+            create_DIArray(DIB(cx), &enumerator_di_nodes[..]),\n+            type_di_node(cx, base_type),\n+            true,\n+        )\n+    }\n+}\n+\n+/// Build the debuginfo node for the struct type describing a single variant of an enum.\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///  --->   DW_TAG_structure_type            (type of variant 1)\n+///  --->   DW_TAG_structure_type            (type of variant 2)\n+///  --->   DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+///\n+/// In CPP-like mode, we have the exact same descriptions for each variant too:\n+///\n+/// ```txt\n+///       DW_TAG_union_type              (top-level type for enum)\n+///         DW_TAG_member                    (member for variant 1)\n+///         DW_TAG_member                    (member for variant 2)\n+///         DW_TAG_member                    (member for variant 3)\n+///  --->   DW_TAG_structure_type            (type of variant 1)\n+///  --->   DW_TAG_structure_type            (type of variant 2)\n+///  --->   DW_TAG_structure_type            (type of variant 3)\n+///         DW_TAG_enumeration_type          (type of tag)\n+/// ```\n+///\n+/// The node looks like:\n+///\n+/// ```txt\n+/// DW_TAG_structure_type\n+///   DW_AT_name                  <name-of-variant>\n+///   DW_AT_byte_size             0x00000010\n+///   DW_AT_alignment             0x00000008\n+///   DW_TAG_member\n+///     DW_AT_name                  <name-of-field-0>\n+///     DW_AT_type                  <0x0000018e>\n+///     DW_AT_alignment             0x00000004\n+///     DW_AT_data_member_location  4\n+///   DW_TAG_member\n+///     DW_AT_name                  <name-of-field-1>\n+///     DW_AT_type                  <0x00000195>\n+///     DW_AT_alignment             0x00000008\n+///     DW_AT_data_member_location  8\n+///   ...\n+/// ```\n+///\n+/// The type of a variant is always a struct type with the name of the variant\n+/// and a DW_TAG_member for each field (but not the discriminant).\n+fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type: Ty<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_index: VariantIdx,\n+    variant_def: &VariantDef,\n+    variant_layout: TyAndLayout<'tcx>,\n+) -> &'ll DIType {\n+    debug_assert_eq!(variant_layout.ty, enum_type);\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            UniqueTypeId::for_enum_variant_struct_type(cx.tcx, enum_type, variant_index),\n+            variant_def.name.as_str(),\n+            // NOTE: We use size and align of enum_type, not from variant_layout:\n+            cx.size_and_align_of(enum_type),\n+            Some(enum_type_di_node),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, struct_type_di_node| {\n+            (0..variant_layout.fields.count())\n+                .map(|field_index| {\n+                    let field_name = if variant_def.ctor_kind != CtorKind::Fn {\n+                        // Fields have names\n+                        Cow::from(variant_def.fields[field_index].name.as_str())\n+                    } else {\n+                        // Tuple-like\n+                        super::tuple_field_name(field_index)\n+                    };\n+\n+                    let field_layout = variant_layout.field(cx, field_index);\n+\n+                    build_field_di_node(\n+                        cx,\n+                        struct_type_di_node,\n+                        &field_name,\n+                        (field_layout.size, field_layout.align.abi),\n+                        variant_layout.fields.offset(field_index),\n+                        DIFlags::FlagZero,\n+                        type_di_node(cx, field_layout.ty),\n+                    )\n+                })\n+                .collect()\n+        },\n+        |cx| build_generic_type_param_di_nodes(cx, enum_type),\n+    )\n+    .di_node\n+}\n+\n+/// Build the struct type for describing a single generator state.\n+/// See [build_generator_variant_struct_type_di_node].\n+///\n+/// ```txt\n+///\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///  --->   DW_TAG_structure_type            (type of variant 1)\n+///  --->   DW_TAG_structure_type            (type of variant 2)\n+///  --->   DW_TAG_structure_type            (type of variant 3)\n+///\n+/// ```\n+pub fn build_generator_variant_struct_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    variant_index: VariantIdx,\n+    generator_type_and_layout: TyAndLayout<'tcx>,\n+    generator_type_di_node: &'ll DIType,\n+    generator_layout: &GeneratorLayout<'tcx>,\n+    state_specific_upvar_names: &IndexVec<GeneratorSavedLocal, Option<Symbol>>,\n+    common_upvar_names: &[String],\n+) -> &'ll DIType {\n+    let variant_name = GeneratorSubsts::variant_name(variant_index);\n+    let unique_type_id = UniqueTypeId::for_enum_variant_struct_type(\n+        cx.tcx,\n+        generator_type_and_layout.ty,\n+        variant_index,\n+    );\n+\n+    let variant_layout = generator_type_and_layout.for_variant(cx, variant_index);\n+\n+    let generator_substs = match generator_type_and_layout.ty.kind() {\n+        ty::Generator(_, substs, _) => substs.as_generator(),\n+        _ => unreachable!(),\n+    };\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            unique_type_id,\n+            &variant_name,\n+            size_and_align_of(generator_type_and_layout),\n+            Some(generator_type_di_node),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, variant_struct_type_di_node| {\n+            // Fields that just belong to this variant/state\n+            let state_specific_fields: SmallVec<_> = (0..variant_layout.fields.count())\n+                .map(|field_index| {\n+                    let generator_saved_local = generator_layout.variant_fields[variant_index]\n+                        [Field::from_usize(field_index)];\n+                    let field_name_maybe = state_specific_upvar_names[generator_saved_local];\n+                    let field_name = field_name_maybe\n+                        .as_ref()\n+                        .map(|s| Cow::from(s.as_str()))\n+                        .unwrap_or_else(|| super::tuple_field_name(field_index));\n+\n+                    let field_type = variant_layout.field(cx, field_index).ty;\n+\n+                    build_field_di_node(\n+                        cx,\n+                        variant_struct_type_di_node,\n+                        &field_name,\n+                        cx.size_and_align_of(field_type),\n+                        variant_layout.fields.offset(field_index),\n+                        DIFlags::FlagZero,\n+                        type_di_node(cx, field_type),\n+                    )\n+                })\n+                .collect();\n+\n+            // Fields that are common to all states\n+            let common_fields: SmallVec<_> = generator_substs\n+                .prefix_tys()\n+                .enumerate()\n+                .map(|(index, upvar_ty)| {\n+                    build_field_di_node(\n+                        cx,\n+                        variant_struct_type_di_node,\n+                        &common_upvar_names[index],\n+                        cx.size_and_align_of(upvar_ty),\n+                        generator_type_and_layout.fields.offset(index),\n+                        DIFlags::FlagZero,\n+                        type_di_node(cx, upvar_ty),\n+                    )\n+                })\n+                .collect();\n+\n+            state_specific_fields.into_iter().chain(common_fields.into_iter()).collect()\n+        },\n+        |cx| build_generic_type_param_di_nodes(cx, generator_type_and_layout.ty),\n+    )\n+    .di_node\n+}\n+\n+/// Returns the discriminant value corresponding to the variant index.\n+///\n+/// Will return `None` if there is less than two variants (because then the enum won't have)\n+/// a tag, and if this is the dataful variant of a niche-layout enum (because then there is no\n+/// single discriminant value).\n+fn compute_discriminant_value<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    variant_index: VariantIdx,\n+) -> Option<u64> {\n+    match enum_type_and_layout.layout.variants() {\n+        &Variants::Single { .. } => None,\n+        &Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => Some(\n+            enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val\n+                as u64,\n+        ),\n+        &Variants::Multiple {\n+            tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n+            tag,\n+            ..\n+        } => {\n+            if variant_index == dataful_variant {\n+                None\n+            } else {\n+                let value = (variant_index.as_u32() as u128)\n+                    .wrapping_sub(niche_variants.start().as_u32() as u128)\n+                    .wrapping_add(niche_start);\n+                let value = tag.value.size(cx).truncate(value);\n+                // NOTE(eddyb) do *NOT* remove this assert, until\n+                // we pass the full 128-bit value to LLVM, otherwise\n+                // truncation will be silent and remain undetected.\n+                assert_eq!(value as u64 as u128, value);\n+                Some(value as u64)\n+            }\n+        }\n+    }\n+}"}, {"sha": "12b8cfb4812539a81dfcfae60dc60c339e3ddea3", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -0,0 +1,441 @@\n+use std::borrow::Cow;\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::{\n+        metadata::{\n+            closure_saved_names_of_captured_variables,\n+            enums::tag_base_type,\n+            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            type_map::{self, Stub, StubInfo, UniqueTypeId},\n+            unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS,\n+            UNKNOWN_LINE_NUMBER,\n+        },\n+        utils::{create_DIArray, get_namespace_for_item, DIB},\n+    },\n+    llvm::{\n+        self,\n+        debuginfo::{DIFile, DIFlags, DIType},\n+    },\n+};\n+use libc::c_uint;\n+use rustc_codegen_ssa::{\n+    debuginfo::{type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo},\n+    traits::ConstMethods,\n+};\n+use rustc_middle::{\n+    bug,\n+    ty::{\n+        self,\n+        layout::{LayoutOf, TyAndLayout},\n+    },\n+};\n+use rustc_target::abi::{Size, TagEncoding, VariantIdx, Variants};\n+use smallvec::smallvec;\n+\n+/// Build the debuginfo node for an enum type. The listing below shows how such a\n+/// type looks like at the LLVM IR/DWARF level. It is a `DW_TAG_structure_type`\n+/// with a single `DW_TAG_variant_part` that in turn contains a `DW_TAG_variant`\n+/// for each variant of the enum. The variant-part also contains a single member\n+/// describing the discriminant, and a nested struct type for each of the variants.\n+///\n+/// ```txt\n+///  ---> DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let enum_type = unique_type_id.expect_ty();\n+    let &ty::Adt(enum_adt_def, _) = enum_type.kind() else {\n+        bug!(\"build_enum_type_di_node() called with non-enum type: `{:?}`\", enum_type)\n+        };\n+\n+    let containing_scope = get_namespace_for_item(cx, enum_adt_def.did());\n+    let enum_type_and_layout = cx.layout_of(enum_type);\n+    let enum_type_name = compute_debuginfo_type_name(cx.tcx, enum_type, false);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(enum_type_and_layout));\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            unique_type_id,\n+            &enum_type_name,\n+            size_and_align_of(enum_type_and_layout),\n+            Some(containing_scope),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, enum_type_di_node| {\n+            // Build the struct type for each variant. These will be referenced by the\n+            // DW_TAG_variant DIEs inside of the DW_TAG_variant_part DIE.\n+            // We also called the names for the corresponding DW_TAG_variant DIEs here.\n+            let variant_member_infos: SmallVec<_> = enum_adt_def\n+                .variant_range()\n+                .map(|variant_index| VariantMemberInfo {\n+                    variant_index,\n+                    variant_name: Cow::from(enum_adt_def.variant(variant_index).name.as_str()),\n+                    variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n+                        cx,\n+                        enum_type,\n+                        enum_type_di_node,\n+                        variant_index,\n+                        enum_adt_def.variant(variant_index),\n+                        enum_type_and_layout.for_variant(cx, variant_index),\n+                    ),\n+                    source_info: None,\n+                })\n+                .collect();\n+\n+            smallvec![build_enum_variant_part_di_node(\n+                cx,\n+                enum_type_and_layout,\n+                enum_type_di_node,\n+                &variant_member_infos[..],\n+            )]\n+        },\n+        // We don't seem to be emitting generic args on the enum type, it seems. Rather\n+        // they get attached to the struct type of each variant.\n+        NO_GENERICS,\n+    )\n+}\n+\n+/// Build the debuginfo node for a generator environment. It looks the same as the debuginfo for\n+/// an enum. See [build_enum_type_di_node] for more information.\n+///\n+/// ```txt\n+///\n+///  ---> DW_TAG_structure_type              (top-level type for the generator)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+///\n+/// ```\n+pub(super) fn build_generator_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+) -> DINodeCreationResult<'ll> {\n+    let generator_type = unique_type_id.expect_ty();\n+    let &ty::Generator(generator_def_id, _, _ ) = generator_type.kind() else {\n+        bug!(\"build_generator_di_node() called with non-generator type: `{:?}`\", generator_type)\n+        };\n+\n+    let containing_scope = get_namespace_for_item(cx, generator_def_id);\n+    let generator_type_and_layout = cx.layout_of(generator_type);\n+\n+    debug_assert!(!wants_c_like_enum_debuginfo(generator_type_and_layout));\n+\n+    let generator_type_name = compute_debuginfo_type_name(cx.tcx, generator_type, false);\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        type_map::stub(\n+            cx,\n+            Stub::Struct,\n+            unique_type_id,\n+            &generator_type_name,\n+            size_and_align_of(generator_type_and_layout),\n+            Some(containing_scope),\n+            DIFlags::FlagZero,\n+        ),\n+        |cx, generator_type_di_node| {\n+            let (generator_layout, state_specific_upvar_names) =\n+                generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+\n+            let Variants::Multiple { tag_encoding: TagEncoding::Direct, ref variants, .. } = generator_type_and_layout.variants else {\n+                bug!(\n+                    \"Encountered generator with non-direct-tag layout: {:?}\",\n+                    generator_type_and_layout\n+                )\n+            };\n+\n+            let common_upvar_names =\n+                closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+\n+            // Build variant struct types\n+            let variant_struct_type_di_nodes: SmallVec<_> = variants\n+                .indices()\n+                .map(|variant_index| {\n+                    // FIXME: This is problematic because just a number is not a valid identifier.\n+                    //        GeneratorSubsts::variant_name(variant_index), would be consistent\n+                    //        with enums?\n+                    let variant_name = format!(\"{}\", variant_index.as_usize()).into();\n+\n+                    let span = generator_layout.variant_source_info[variant_index].span;\n+                    let source_info = if !span.is_dummy() {\n+                        let loc = cx.lookup_debug_loc(span.lo());\n+                        Some((file_metadata(cx, &loc.file), loc.line))\n+                    } else {\n+                        None\n+                    };\n+\n+                    VariantMemberInfo {\n+                        variant_index,\n+                        variant_name,\n+                        variant_struct_type_di_node:\n+                            super::build_generator_variant_struct_type_di_node(\n+                                cx,\n+                                variant_index,\n+                                generator_type_and_layout,\n+                                generator_type_di_node,\n+                                generator_layout,\n+                                &state_specific_upvar_names,\n+                                &common_upvar_names,\n+                            ),\n+                        source_info,\n+                    }\n+                })\n+                .collect();\n+\n+            smallvec![build_enum_variant_part_di_node(\n+                cx,\n+                generator_type_and_layout,\n+                generator_type_di_node,\n+                &variant_struct_type_di_nodes[..],\n+            )]\n+        },\n+        // We don't seem to be emitting generic args on the generator type, it seems. Rather\n+        // they get attached to the struct type of each variant.\n+        NO_GENERICS,\n+    )\n+}\n+\n+/// Builds the DW_TAG_variant_part of an enum or generator debuginfo node:\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+/// --->    DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+fn build_enum_variant_part_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    enum_type_di_node: &'ll DIType,\n+    variant_member_infos: &[VariantMemberInfo<'_, 'll>],\n+) -> &'ll DIType {\n+    let tag_member_di_node =\n+        build_discr_member_di_node(cx, enum_type_and_layout, enum_type_di_node);\n+\n+    let variant_part_unique_type_id =\n+        UniqueTypeId::for_enum_variant_part(cx.tcx, enum_type_and_layout.ty);\n+\n+    let stub = StubInfo::new(\n+        cx,\n+        variant_part_unique_type_id,\n+        |cx, variant_part_unique_type_id_str| unsafe {\n+            let variant_part_name = \"\";\n+            llvm::LLVMRustDIBuilderCreateVariantPart(\n+                DIB(cx),\n+                enum_type_di_node,\n+                variant_part_name.as_ptr().cast(),\n+                variant_part_name.len(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                enum_type_and_layout.size.bits(),\n+                enum_type_and_layout.align.abi.bits() as u32,\n+                DIFlags::FlagZero,\n+                tag_member_di_node,\n+                create_DIArray(DIB(cx), &[]),\n+                variant_part_unique_type_id_str.as_ptr().cast(),\n+                variant_part_unique_type_id_str.len(),\n+            )\n+        },\n+    );\n+\n+    type_map::build_type_with_children(\n+        cx,\n+        stub,\n+        |cx, variant_part_di_node| {\n+            variant_member_infos\n+                .iter()\n+                .map(|variant_member_info| {\n+                    build_enum_variant_member_di_node(\n+                        cx,\n+                        enum_type_and_layout,\n+                        variant_part_di_node,\n+                        variant_member_info,\n+                    )\n+                })\n+                .collect()\n+        },\n+        NO_GENERICS,\n+    )\n+    .di_node\n+}\n+\n+/// Builds the DW_TAG_member describing where we can find the tag of an enum.\n+/// Returns `None` if the enum does not have a tag.\n+///\n+/// ```txt\n+///\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+/// --->      DW_TAG_member                  (discriminant member)\n+///           DW_TAG_variant                 (variant 1)\n+///           DW_TAG_variant                 (variant 2)\n+///           DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+///\n+/// ```\n+fn build_discr_member_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_or_generator_type_and_layout: TyAndLayout<'tcx>,\n+    enum_or_generator_type_di_node: &'ll DIType,\n+) -> Option<&'ll DIType> {\n+    let tag_name = match enum_or_generator_type_and_layout.ty.kind() {\n+        ty::Generator(..) => \"__state\",\n+        _ => \"\",\n+    };\n+\n+    // NOTE: This is actually wrong. This will become a member of\n+    //       of the DW_TAG_variant_part. But, due to LLVM's API, that\n+    //       can only be constructed with this DW_TAG_member already in created.\n+    //       In LLVM IR the wrong scope will be listed but when DWARF is\n+    //       generated from it, the DW_TAG_member will be a child the\n+    //       DW_TAG_variant_part.\n+    let containing_scope = enum_or_generator_type_di_node;\n+\n+    match enum_or_generator_type_and_layout.layout.variants() {\n+        // A single-variant enum has no discriminant.\n+        &Variants::Single { .. } => None,\n+\n+        &Variants::Multiple { tag_field, .. } => {\n+            let tag_base_type = tag_base_type(cx, enum_or_generator_type_and_layout);\n+            let (size, align) = cx.size_and_align_of(tag_base_type);\n+\n+            unsafe {\n+                Some(llvm::LLVMRustDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    tag_name.as_ptr().cast(),\n+                    tag_name.len(),\n+                    unknown_file_metadata(cx),\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.bits() as u32,\n+                    enum_or_generator_type_and_layout.fields.offset(tag_field).bits(),\n+                    DIFlags::FlagArtificial,\n+                    type_di_node(cx, tag_base_type),\n+                ))\n+            }\n+        }\n+    }\n+}\n+\n+/// Build the debuginfo node for `DW_TAG_variant`:\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///  --->     DW_TAG_variant                 (variant 1)\n+///  --->     DW_TAG_variant                 (variant 2)\n+///  --->     DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n+///\n+/// This node looks like:\n+///\n+/// ```txt\n+/// DW_TAG_variant\n+///   DW_AT_discr_value           0\n+///   DW_TAG_member\n+///     DW_AT_name                  None\n+///     DW_AT_type                  <0x000002a1>\n+///     DW_AT_alignment             0x00000002\n+///     DW_AT_data_member_location  0\n+/// ```\n+///\n+/// The DW_AT_discr_value is optional, and is omitted if\n+///   - This is the only variant of a univariant enum (i.e. their is no discriminant)\n+///   - This is the \"dataful\" variant of a niche-layout enum\n+///     (where only the other variants are identified by a single value)\n+///\n+/// There is only ever a single member, the type of which is a struct that describes the\n+/// fields of the variant (excluding the discriminant). The name of the member is the name\n+/// of the variant as given in the source code. The DW_AT_data_member_location is always\n+/// zero.\n+///\n+/// Note that the LLVM DIBuilder API is a bit unintuitive here. The DW_TAG_variant subtree\n+/// (including the DW_TAG_member) is built by a single call to\n+/// `LLVMRustDIBuilderCreateVariantMemberType()`.\n+fn build_enum_variant_member_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n+    variant_part_di_node: &'ll DIType,\n+    variant_member_info: &VariantMemberInfo<'_, 'll>,\n+) -> &'ll DIType {\n+    let variant_index = variant_member_info.variant_index;\n+    let discr_value = super::compute_discriminant_value(cx, enum_type_and_layout, variant_index);\n+\n+    let (file_di_node, line_number) = variant_member_info\n+        .source_info\n+        .unwrap_or_else(|| (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER));\n+\n+    unsafe {\n+        llvm::LLVMRustDIBuilderCreateVariantMemberType(\n+            DIB(cx),\n+            variant_part_di_node,\n+            variant_member_info.variant_name.as_ptr().cast(),\n+            variant_member_info.variant_name.len(),\n+            file_di_node,\n+            line_number,\n+            enum_type_and_layout.size.bits(), // FIXME: Unused?\n+            enum_type_and_layout.align.abi.bits() as u32, // FIXME: Unused?\n+            Size::ZERO.bits(),                // FIXME: Unused?\n+            discr_value.map(|v| cx.const_u64(v)),\n+            DIFlags::FlagZero,\n+            variant_member_info.variant_struct_type_di_node,\n+        )\n+    }\n+}\n+\n+/// Information needed for building a `DW_TAG_variant`:\n+///\n+/// ```txt\n+///       DW_TAG_structure_type              (top-level type for enum)\n+///         DW_TAG_variant_part              (variant part)\n+///           DW_AT_discr                    (reference to discriminant DW_TAG_member)\n+///           DW_TAG_member                  (discriminant member)\n+///  --->     DW_TAG_variant                 (variant 1)\n+///  --->     DW_TAG_variant                 (variant 2)\n+///  --->     DW_TAG_variant                 (variant 3)\n+///         DW_TAG_structure_type            (type of variant 1)\n+///         DW_TAG_structure_type            (type of variant 2)\n+///         DW_TAG_structure_type            (type of variant 3)\n+struct VariantMemberInfo<'a, 'll> {\n+    variant_index: VariantIdx,\n+    variant_name: Cow<'a, str>,\n+    variant_struct_type_di_node: &'ll DIType,\n+    source_info: Option<(&'ll DIFile, c_uint)>,\n+}"}, {"sha": "26f0647f888a24be6ae08bc8b6c57bdbbdeb9ccd", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -0,0 +1,271 @@\n+use std::cell::RefCell;\n+\n+use rustc_data_structures::{\n+    fingerprint::Fingerprint,\n+    fx::FxHashMap,\n+    stable_hasher::{HashStable, NodeIdHashingMode, StableHasher},\n+};\n+use rustc_middle::{\n+    bug,\n+    ty::{ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt},\n+};\n+use rustc_target::abi::{Align, Size, VariantIdx};\n+\n+use crate::{\n+    common::CodegenCx,\n+    debuginfo::utils::{create_DIArray, debug_context, DIB},\n+    llvm::{\n+        self,\n+        debuginfo::{DIFlags, DIScope, DIType},\n+    },\n+};\n+\n+use super::{unknown_file_metadata, SmallVec, UNKNOWN_LINE_NUMBER};\n+\n+mod private {\n+    // This type cannot be constructed outside of this module because\n+    // it has a private field. We make use of this in order to prevent\n+    // `UniqueTypeId` from being constructed directly, without asserting\n+    // the preconditions.\n+    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n+    pub struct HiddenZst;\n+}\n+\n+/// A unique identifier for anything that we create a debuginfo node for.\n+/// The types it contains are expected to already be normalized (which\n+/// is debug_asserted in the constructors).\n+///\n+/// Note that there are some things that only show up in debuginfo, like\n+/// the separate type descriptions for each enum variant. These get an ID\n+/// too because they have their own debuginfo node in LLVM IR.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n+pub(super) enum UniqueTypeId<'tcx> {\n+    /// The ID of a regular type as it shows up at the language level.\n+    Ty(Ty<'tcx>, private::HiddenZst),\n+    /// The ID for the single DW_TAG_variant_part nested inside the top-level\n+    /// DW_TAG_structure_type that describes enums and generators.\n+    VariantPart(Ty<'tcx>, private::HiddenZst),\n+    /// The ID for the artificial struct type describing a single enum variant.\n+    VariantStructType(Ty<'tcx>, VariantIdx, private::HiddenZst),\n+    /// The ID of the artificial type we create for VTables.\n+    VTableTy(Ty<'tcx>, Option<PolyExistentialTraitRef<'tcx>>, private::HiddenZst),\n+}\n+\n+impl<'tcx> UniqueTypeId<'tcx> {\n+    pub fn for_ty(tcx: TyCtxt<'tcx>, t: Ty<'tcx>) -> Self {\n+        debug_assert_eq!(t, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t));\n+        UniqueTypeId::Ty(t, private::HiddenZst)\n+    }\n+\n+    pub fn for_enum_variant_part(tcx: TyCtxt<'tcx>, enum_ty: Ty<'tcx>) -> Self {\n+        debug_assert_eq!(enum_ty, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty));\n+        UniqueTypeId::VariantPart(enum_ty, private::HiddenZst)\n+    }\n+\n+    pub fn for_enum_variant_struct_type(\n+        tcx: TyCtxt<'tcx>,\n+        enum_ty: Ty<'tcx>,\n+        variant_idx: VariantIdx,\n+    ) -> Self {\n+        debug_assert_eq!(enum_ty, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty));\n+        UniqueTypeId::VariantStructType(enum_ty, variant_idx, private::HiddenZst)\n+    }\n+\n+    pub fn for_vtable_ty(\n+        tcx: TyCtxt<'tcx>,\n+        self_type: Ty<'tcx>,\n+        implemented_trait: Option<PolyExistentialTraitRef<'tcx>>,\n+    ) -> Self {\n+        debug_assert_eq!(\n+            self_type,\n+            tcx.normalize_erasing_regions(ParamEnv::reveal_all(), self_type)\n+        );\n+        debug_assert_eq!(\n+            implemented_trait,\n+            tcx.normalize_erasing_regions(ParamEnv::reveal_all(), implemented_trait)\n+        );\n+        UniqueTypeId::VTableTy(self_type, implemented_trait, private::HiddenZst)\n+    }\n+\n+    /// Generates a string version of this [UniqueTypeId], which can be used as the `UniqueId`\n+    /// argument of the various `LLVMRustDIBuilderCreate*Type()` methods.\n+    ///\n+    /// Right now this takes the form of a hex-encoded opaque hash value.\n+    pub fn generate_unique_id_string(self, tcx: TyCtxt<'tcx>) -> String {\n+        let mut hasher = StableHasher::new();\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                self.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n+        hasher.finish::<Fingerprint>().to_hex()\n+    }\n+\n+    pub fn expect_ty(self) -> Ty<'tcx> {\n+        match self {\n+            UniqueTypeId::Ty(ty, _) => ty,\n+            _ => bug!(\"Expected `UniqueTypeId::Ty` but found `{:?}`\", self),\n+        }\n+    }\n+}\n+\n+/// The `TypeMap` is where the debug context holds the type metadata nodes\n+/// created so far. The debuginfo nodes are identified by `UniqueTypeId`.\n+#[derive(Default)]\n+pub(crate) struct TypeMap<'ll, 'tcx> {\n+    pub(super) unique_id_to_di_node: RefCell<FxHashMap<UniqueTypeId<'tcx>, &'ll DIType>>,\n+}\n+\n+impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n+    /// Adds a `UniqueTypeId` to metadata mapping to the `TypeMap`. The method will\n+    /// fail if the mapping already exists.\n+    pub(super) fn insert(&self, unique_type_id: UniqueTypeId<'tcx>, metadata: &'ll DIType) {\n+        if self.unique_id_to_di_node.borrow_mut().insert(unique_type_id, metadata).is_some() {\n+            bug!(\"type metadata for unique ID '{:?}' is already in the `TypeMap`!\", unique_type_id);\n+        }\n+    }\n+\n+    pub(super) fn di_node_for_unique_id(\n+        &self,\n+        unique_type_id: UniqueTypeId<'tcx>,\n+    ) -> Option<&'ll DIType> {\n+        self.unique_id_to_di_node.borrow().get(&unique_type_id).cloned()\n+    }\n+}\n+\n+pub struct DINodeCreationResult<'ll> {\n+    pub di_node: &'ll DIType,\n+    pub already_stored_in_typemap: bool,\n+}\n+\n+impl<'ll> DINodeCreationResult<'ll> {\n+    pub fn new(di_node: &'ll DIType, already_stored_in_typemap: bool) -> Self {\n+        DINodeCreationResult { di_node, already_stored_in_typemap }\n+    }\n+}\n+\n+#[allow(dead_code)]\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub enum Stub<'ll> {\n+    Struct,\n+    Union,\n+    VtableTy { vtable_holder: &'ll DIType },\n+}\n+\n+pub struct StubInfo<'ll, 'tcx> {\n+    metadata: &'ll DIType,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+}\n+\n+impl<'ll, 'tcx> StubInfo<'ll, 'tcx> {\n+    pub(super) fn new(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        unique_type_id: UniqueTypeId<'tcx>,\n+        build: impl FnOnce(&CodegenCx<'ll, 'tcx>, /* unique_type_id_str: */ &str) -> &'ll DIType,\n+    ) -> StubInfo<'ll, 'tcx> {\n+        let unique_type_id_str = unique_type_id.generate_unique_id_string(cx.tcx);\n+        let di_node = build(cx, &unique_type_id_str);\n+        StubInfo { metadata: di_node, unique_type_id }\n+    }\n+}\n+\n+/// Create a stub debuginfo node onto which fields and nested types can be attached.\n+pub(super) fn stub<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    kind: Stub<'ll>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n+    name: &str,\n+    (size, align): (Size, Align),\n+    containing_scope: Option<&'ll DIScope>,\n+    flags: DIFlags,\n+) -> StubInfo<'ll, 'tcx> {\n+    let empty_array = create_DIArray(DIB(cx), &[]);\n+    let unique_type_id_str = unique_type_id.generate_unique_id_string(cx.tcx);\n+\n+    let metadata = match kind {\n+        Stub::Struct | Stub::VtableTy { .. } => {\n+            let vtable_holder = match kind {\n+                Stub::VtableTy { vtable_holder } => Some(vtable_holder),\n+                _ => None,\n+            };\n+            unsafe {\n+                llvm::LLVMRustDIBuilderCreateStructType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    name.as_ptr().cast(),\n+                    name.len(),\n+                    unknown_file_metadata(cx),\n+                    UNKNOWN_LINE_NUMBER,\n+                    size.bits(),\n+                    align.bits() as u32,\n+                    flags,\n+                    None,\n+                    empty_array,\n+                    0,\n+                    vtable_holder,\n+                    unique_type_id_str.as_ptr().cast(),\n+                    unique_type_id_str.len(),\n+                )\n+            }\n+        }\n+        Stub::Union => unsafe {\n+            llvm::LLVMRustDIBuilderCreateUnionType(\n+                DIB(cx),\n+                containing_scope,\n+                name.as_ptr().cast(),\n+                name.len(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                size.bits(),\n+                align.bits() as u32,\n+                flags,\n+                Some(empty_array),\n+                0,\n+                unique_type_id_str.as_ptr().cast(),\n+                unique_type_id_str.len(),\n+            )\n+        },\n+    };\n+    StubInfo { metadata, unique_type_id }\n+}\n+\n+/// This function enables creating debuginfo nodes that can recursively refer to themselves.\n+/// It will first insert the given stub into the type map and only then execute the `members`\n+/// and `generics` closures passed in. These closures have access to the stub so they can\n+/// directly attach fields to them. If build the type of a field transitively refers back\n+/// to the type currently being built, the stub will already be found in the type map,\n+/// which effectively breaks the recursion cycle.\n+pub(super) fn build_type_with_children<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    stub_info: StubInfo<'ll, 'tcx>,\n+    members: impl FnOnce(&CodegenCx<'ll, 'tcx>, &'ll DIType) -> SmallVec<&'ll DIType>,\n+    generics: impl FnOnce(&CodegenCx<'ll, 'tcx>) -> SmallVec<&'ll DIType>,\n+) -> DINodeCreationResult<'ll> {\n+    debug_assert_eq!(\n+        debug_context(cx).type_map.di_node_for_unique_id(stub_info.unique_type_id),\n+        None\n+    );\n+\n+    debug_context(cx).type_map.insert(stub_info.unique_type_id, stub_info.metadata);\n+\n+    let members: SmallVec<_> =\n+        members(cx, stub_info.metadata).into_iter().map(|node| Some(node)).collect();\n+    let generics: SmallVec<Option<&'ll DIType>> =\n+        generics(cx).into_iter().map(|node| Some(node)).collect();\n+\n+    if !(members.is_empty() && generics.is_empty()) {\n+        unsafe {\n+            let members_array = create_DIArray(DIB(cx), &members[..]);\n+            let generics_array = create_DIArray(DIB(cx), &generics[..]);\n+            llvm::LLVMRustDICompositeTypeReplaceArrays(\n+                DIB(cx),\n+                stub_info.metadata,\n+                Some(members_array),\n+                Some(generics_array),\n+            );\n+        }\n+    }\n+\n+    DINodeCreationResult { di_node: stub_info.metadata, already_stored_in_typemap: true }\n+}"}, {"sha": "6cb8f7863a9d85348033add9e0f9b8212d794cd2", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n-use self::metadata::{file_metadata, type_metadata, TypeMap};\n+use self::metadata::{file_metadata, type_di_node};\n use self::metadata::{UNKNOWN_COLUMN_NUMBER, UNKNOWN_LINE_NUMBER};\n use self::namespace::mangled_name_of_instance;\n use self::utils::{create_DIArray, is_node_local_to_unit, DIB};\n@@ -20,7 +20,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::{DefId, DefIdMap};\n use rustc_index::vec::IndexVec;\n@@ -32,7 +32,7 @@ use rustc_session::config::{self, DebugInfo};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n use rustc_span::{self, BytePos, Pos, SourceFile, SourceFileAndLine, Span};\n-use rustc_target::abi::{Primitive, Size};\n+use rustc_target::abi::Size;\n \n use libc::c_uint;\n use smallvec::SmallVec;\n@@ -48,7 +48,7 @@ mod namespace;\n mod utils;\n \n pub use self::create_scope_map::compute_mir_scopes;\n-pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::build_global_var_di_node;\n pub use self::metadata::extend_scope_to_file;\n \n #[allow(non_upper_case_globals)]\n@@ -57,47 +57,39 @@ const DW_TAG_auto_variable: c_uint = 0x100;\n const DW_TAG_arg_variable: c_uint = 0x101;\n \n /// A context object for maintaining all state needed by the debuginfo module.\n-pub struct CrateDebugContext<'a, 'tcx> {\n-    llcontext: &'a llvm::Context,\n-    llmod: &'a llvm::Module,\n-    builder: &'a mut DIBuilder<'a>,\n-    created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'a DIFile>>,\n-    created_enum_disr_types: RefCell<FxHashMap<(DefId, Primitive), &'a DIType>>,\n-\n-    type_map: TypeMap<'a, 'tcx>,\n-    namespace_map: RefCell<DefIdMap<&'a DIScope>>,\n-\n-    recursion_marker_type: OnceCell<&'a DIType>,\n-\n-    // This collection is used to assert that composite types (structs, enums,\n-    // ...) have their members only set once:\n-    composite_types_completed: RefCell<FxHashSet<&'a DIType>>,\n+pub struct CodegenUnitDebugContext<'ll, 'tcx> {\n+    llcontext: &'ll llvm::Context,\n+    llmod: &'ll llvm::Module,\n+    builder: &'ll mut DIBuilder<'ll>,\n+    created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'ll DIFile>>,\n+\n+    type_map: metadata::TypeMap<'ll, 'tcx>,\n+    namespace_map: RefCell<DefIdMap<&'ll DIScope>>,\n+    recursion_marker_type: OnceCell<&'ll DIType>,\n }\n \n-impl Drop for CrateDebugContext<'_, '_> {\n+impl Drop for CodegenUnitDebugContext<'_, '_> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMRustDIBuilderDispose(&mut *(self.builder as *mut _));\n         }\n     }\n }\n \n-impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n-    pub fn new(llmod: &'a llvm::Module) -> Self {\n-        debug!(\"CrateDebugContext::new\");\n+impl<'ll, 'tcx> CodegenUnitDebugContext<'ll, 'tcx> {\n+    pub fn new(llmod: &'ll llvm::Module) -> Self {\n+        debug!(\"CodegenUnitDebugContext::new\");\n         let builder = unsafe { llvm::LLVMRustDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n         let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n-        CrateDebugContext {\n+        CodegenUnitDebugContext {\n             llcontext,\n             llmod,\n             builder,\n             created_files: Default::default(),\n-            created_enum_disr_types: Default::default(),\n             type_map: Default::default(),\n             namespace_map: RefCell::new(Default::default()),\n             recursion_marker_type: OnceCell::new(),\n-            composite_types_completed: Default::default(),\n         }\n     }\n \n@@ -415,7 +407,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             signature.push(if fn_abi.ret.is_ignore() {\n                 None\n             } else {\n-                Some(type_metadata(cx, fn_abi.ret.layout.ty))\n+                Some(type_di_node(cx, fn_abi.ret.layout.ty))\n             });\n \n             // Arguments types\n@@ -440,11 +432,11 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                         _ => t,\n                     };\n-                    Some(type_metadata(cx, t))\n+                    Some(type_di_node(cx, t))\n                 }));\n             } else {\n                 signature\n-                    .extend(fn_abi.args.iter().map(|arg| Some(type_metadata(cx, arg.layout.ty))));\n+                    .extend(fn_abi.args.iter().map(|arg| Some(type_di_node(cx, arg.layout.ty))));\n             }\n \n             create_DIArray(DIB(cx), &signature[..])\n@@ -467,7 +459,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         if let GenericArgKind::Type(ty) = kind.unpack() {\n                             let actual_type =\n                                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                            let actual_type_metadata = type_metadata(cx, actual_type);\n+                            let actual_type_metadata = type_di_node(cx, actual_type);\n                             let name = name.as_str();\n                             Some(unsafe {\n                                 Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n@@ -522,7 +514,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n                                 && !impl_self_ty.needs_subst()\n                             {\n-                                Some(type_metadata(cx, impl_self_ty))\n+                                Some(type_di_node(cx, impl_self_ty))\n                             } else {\n                                 Some(namespace::item_namespace(cx, def.did()))\n                             }\n@@ -569,7 +561,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n         vtable: Self::Value,\n     ) {\n-        metadata::create_vtable_metadata(self, ty, trait_ref, vtable)\n+        metadata::create_vtable_di_node(self, ty, trait_ref, vtable)\n     }\n \n     fn extend_scope_to_file(\n@@ -597,7 +589,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n \n-        let type_metadata = type_metadata(self, variable_type);\n+        let type_metadata = type_di_node(self, variable_type);\n \n         let (argument_index, dwarf_tag) = match variable_kind {\n             ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),"}, {"sha": "fe9851cfa561218c93b2247a39684578aa095af5", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -1,7 +1,7 @@\n // Utility Functions.\n \n use super::namespace::item_namespace;\n-use super::CrateDebugContext;\n+use super::CodegenUnitDebugContext;\n \n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n@@ -35,7 +35,7 @@ pub fn create_DIArray<'ll>(\n #[inline]\n pub fn debug_context<'a, 'll, 'tcx>(\n     cx: &'a CodegenCx<'ll, 'tcx>,\n-) -> &'a CrateDebugContext<'ll, 'tcx> {\n+) -> &'a CodegenUnitDebugContext<'ll, 'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n "}, {"sha": "6e3f4f0b8ef0163d2f7fe6d0bc23f8e702b58238", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -1,2 +1,34 @@\n+use rustc_middle::ty::{self, layout::TyAndLayout};\n+use rustc_target::abi::Size;\n+\n // FIXME(eddyb) find a place for this (or a way to replace it).\n pub mod type_names;\n+\n+/// Returns true if we want to generate a DW_TAG_enumeration_type description for\n+/// this instead of a DW_TAG_struct_type with DW_TAG_variant_part.\n+///\n+/// NOTE: This is somewhat inconsistent right now: For empty enums and enums with a single\n+///       fieldless variant, we generate DW_TAG_struct_type, although a\n+///       DW_TAG_enumeration_type would be a better fit.\n+pub fn wants_c_like_enum_debuginfo<'tcx>(enum_type_and_layout: TyAndLayout<'tcx>) -> bool {\n+    match enum_type_and_layout.ty.kind() {\n+        ty::Adt(adt_def, _) => {\n+            if !adt_def.is_enum() {\n+                return false;\n+            }\n+\n+            match adt_def.variants().len() {\n+                0 => false,\n+                1 => {\n+                    // Univariant enums unless they are zero-sized\n+                    enum_type_and_layout.size != Size::ZERO && adt_def.all_fields().count() == 0\n+                }\n+                _ => {\n+                    // Enums with more than one variant if they have no fields\n+                    adt_def.all_fields().count() == 0\n+                }\n+            }\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "6a122addf22687f165cc0a31d6bcf11dd292d238", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -18,13 +18,15 @@ use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathD\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Mutability};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, AdtDef, ExistentialProjection, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtDef, ExistentialProjection, ParamEnv, Ty, TyCtxt};\n use rustc_query_system::ich::NodeIdHashingMode;\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use smallvec::SmallVec;\n \n use std::fmt::Write;\n \n+use crate::debuginfo::wants_c_like_enum_debuginfo;\n+\n // Compute the name of the type as it should be stored in debuginfo. Does not do\n // any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n@@ -71,7 +73,9 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n-            if def.is_enum() && cpp_like_debuginfo {\n+            let ty_and_layout = tcx.layout_of(ParamEnv::reveal_all().and(t)).expect(\"layout error\");\n+\n+            if def.is_enum() && cpp_like_debuginfo && !wants_c_like_enum_debuginfo(ty_and_layout) {\n                 msvc_enum_fallback(tcx, t, def, substs, output, visited);\n             } else {\n                 push_item_name(tcx, def.did(), qualified, output);"}, {"sha": "b10e662b5bbd64ae0fdc3b83f31770bbe1a2e4e5", "filename": "src/test/codegen/async-fn-debug-msvc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -16,8 +16,7 @@ async fn async_fn_test() {\n \n // FIXME: No way to reliably check the filename.\n \n-// CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"async_fn_env$0\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"async_fn_env$0\", {{.*}}, align: {{32|64}},\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 11,\n@@ -40,10 +39,10 @@ async fn async_fn_test() {\n // CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n+// CHECK:      [[VARIANT]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[VARIANT]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"discriminant\", scope: [[GEN]],"}, {"sha": "9f6058a71b3433a4ff12622850fae3bda78ad29b", "filename": "src/test/codegen/async-fn-debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -18,7 +18,7 @@ async fn async_fn_test() {\n \n // CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n // CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}\", scope: [[ASYNC_FN]]\n-// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[ASYNC_FN]],\n+// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: discriminator: [[DISC:![0-9]*]]\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"0\", scope: [[VARIANT]],\n@@ -50,7 +50,7 @@ async fn async_fn_test() {\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[ASYNC_FN]],\n+// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[GEN]],\n // CHECK-SAME: flags: DIFlagArtificial\n \n fn main() {"}, {"sha": "a6e56a6bd579e9c60a4ef2cf3f106a846c170939", "filename": "src/test/codegen/generator-debug-msvc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -20,7 +20,6 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n \n // FIXME: No way to reliably check the filename.\n \n-// CHECK-DAG:  [[GEN_FN:!.*]] = !DINamespace(name: \"generator_test\"\n // CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator_env$0\"\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n@@ -44,10 +43,10 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n // CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n+// CHECK:      [[VARIANT]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[VARIANT]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"discriminant\", scope: [[GEN]],"}, {"sha": "3ec860f2cbc0681370b27d30788be1699d2fe1af", "filename": "src/test/codegen/generator-debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -22,7 +22,7 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n \n // CHECK-DAG:  [[GEN_FN:!.*]] = !DINamespace(name: \"generator_test\"\n // CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{generator_env#0}\", scope: [[GEN_FN]]\n-// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[GEN_FN]],\n+// CHECK:      [[VARIANT:!.*]] = !DICompositeType(tag: DW_TAG_variant_part, scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: discriminator: [[DISC:![0-9]*]]\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"0\", scope: [[VARIANT]],\n@@ -54,7 +54,7 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[GEN_FN]],\n+// CHECK:      [[DISC]] = !DIDerivedType(tag: DW_TAG_member, name: \"__state\", scope: [[GEN]],\n // CHECK-SAME: flags: DIFlagArtificial\n \n fn main() {"}, {"sha": "a153a9a42289a4018b913a9f68ad3dcee080465f", "filename": "src/test/debuginfo/msvc-pretty-enums.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -4,14 +4,14 @@\n // cdb-command: g\n \n // cdb-command: dx a\n-// cdb-check:a                :  Some({...}) [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n+// cdb-check:a                :  Some({...}) [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n+// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n // cdb-check:    [variant]        :  Some\n // cdb-check:    [+0x000] __0              : Low (0x2) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx b\n-// cdb-check:b                : None [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum> >, 2, 16, Some>]\n+// cdb-check:b                : None [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n+// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n // cdb-check:    [variant]        : None\n \n // cdb-command: dx c\n@@ -78,7 +78,7 @@ pub enum NicheLayoutEnum {\n     Tag2,\n }\n \n-pub enum Empty { }\n+pub enum Empty {}\n \n fn main() {\n     let a = Some(CStyleEnum::Low);\n@@ -97,4 +97,6 @@ fn main() {\n     zzz(); // #break\n }\n \n-fn zzz() { () }\n+fn zzz() {\n+    ()\n+}"}, {"sha": "52841d50f642fcb567d057a90aa5fbd75edd8291", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ebc13d87796622bb6e4ac46a7e6a054bc4c680/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=07ebc13d87796622bb6e4ac46a7e6a054bc4c680", "patch": "@@ -33,10 +33,10 @@\n // gdb-check:type = type_names::mod1::Enum2\n \n // gdb-command:whatis generic_enum_1\n-// gdb-check:type = type_names::mod1::mod2::Enum3\n+// gdb-check:type = type_names::mod1::mod2::Enum3<type_names::mod1::Struct2>\n \n // gdb-command:whatis generic_enum_2\n-// gdb-check:type = type_names::mod1::mod2::Enum3\n+// gdb-check:type = type_names::mod1::mod2::Enum3<type_names::Struct1>\n \n // TUPLES\n // gdb-command:whatis tuple1\n@@ -159,10 +159,10 @@\n \n // FOREIGN TYPES\n // gdb-command:whatis foreign1\n-// gdb-check:type = *mut ForeignType1\n+// gdb-check:type = *mut type_names::{extern#0}::ForeignType1\n \n // gdb-command:whatis foreign2\n-// gdb-check:type = *mut ForeignType2\n+// gdb-check:type = *mut type_names::mod1::{extern#0}::ForeignType2\n \n // === CDB TESTS ==================================================================================\n \n@@ -178,9 +178,9 @@\n // cdb-command:dv /t *_enum_*\n // cdb-check:union enum$<type_names::Enum1> simple_enum_1 = [...]\n // cdb-check:union enum$<type_names::Enum1> simple_enum_2 = [...]\n-// cdb-check:type_names::mod1::Enum2 simple_enum_3 = [...]\n-// cdb-check:type_names::mod1::mod2::Enum3 generic_enum_1 = [...]\n-// cdb-check:type_names::mod1::mod2::Enum3 generic_enum_2 = [...]\n+// cdb-check:union enum$<type_names::mod1::Enum2> simple_enum_3 = [...]\n+// cdb-check:union enum$<type_names::mod1::mod2::Enum3<type_names::mod1::Struct2> > generic_enum_1 = [...]\n+// cdb-check:union enum$<type_names::mod1::mod2::Enum3<type_names::Struct1> > generic_enum_2 = [...]\n \n // TUPLES\n // cdb-command:dv /t tuple*\n@@ -258,8 +258,8 @@\n \n // FOREIGN TYPES\n // cdb-command:dv /t foreign*\n-// cdb-check:struct ForeignType2 * foreign2 = [...]\n-// cdb-check:struct ForeignType1 * foreign1 = [...]\n+// cdb-check:struct type_names::mod1::extern$0::ForeignType2 * foreign2 = [...]\n+// cdb-check:struct type_names::extern$0::ForeignType1 * foreign1 = [...]\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n@@ -283,7 +283,6 @@ extern \"C\" {\n }\n \n mod mod1 {\n-    pub use self::Enum2::{Variant1, Variant2};\n     pub struct Struct2;\n \n     pub enum Enum2 {\n@@ -367,14 +366,14 @@ fn main() {\n     // Enums\n     let simple_enum_1 = Variant1;\n     let simple_enum_2 = Variant2(0);\n-    let simple_enum_3 = mod1::Variant2(Struct1);\n+    let simple_enum_3 = mod1::Enum2::Variant2(Struct1);\n \n     let generic_enum_1: mod1::mod2::Enum3<mod1::Struct2> = mod1::mod2::Variant1;\n     let generic_enum_2 = mod1::mod2::Variant2(Struct1);\n \n     // Tuples\n     let tuple1 = (8u32, Struct1, mod1::mod2::Variant2(mod1::Struct2));\n-    let tuple2 = ((Struct1, mod1::mod2::Struct3), mod1::Variant1, 'x');\n+    let tuple2 = ((Struct1, mod1::mod2::Struct3), mod1::Enum2::Variant1, 'x');\n \n     // Box\n     let box1 = (Box::new(1f32), 0i32);\n@@ -404,7 +403,7 @@ fn main() {\n \n     let vec1 = vec![0_usize, 2, 3];\n     let slice1 = &*vec1;\n-    let vec2 = vec![mod1::Variant2(Struct1)];\n+    let vec2 = vec![mod1::Enum2::Variant2(Struct1)];\n     let slice2 = &*vec2;\n \n     // Trait Objects"}]}