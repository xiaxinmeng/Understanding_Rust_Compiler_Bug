{"sha": "196236980613249f25ccb2968a214922f7db10f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NjIzNjk4MDYxMzI0OWYyNWNjYjI5NjhhMjE0OTIyZjdkYjEwZjE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-12T19:08:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-12T19:08:14Z"}, "message": "more modules", "tree": {"sha": "515e3a7476fffffc17b69c4929451a399f2113ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/515e3a7476fffffc17b69c4929451a399f2113ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/196236980613249f25ccb2968a214922f7db10f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/196236980613249f25ccb2968a214922f7db10f1", "html_url": "https://github.com/rust-lang/rust/commit/196236980613249f25ccb2968a214922f7db10f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/196236980613249f25ccb2968a214922f7db10f1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acd7552698d374fbf95b08f55cf9eba3e4ff863d", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd7552698d374fbf95b08f55cf9eba3e4ff863d", "html_url": "https://github.com/rust-lang/rust/commit/acd7552698d374fbf95b08f55cf9eba3e4ff863d"}], "stats": {"total": 385, "additions": 206, "deletions": 179}, "files": [{"sha": "fccfe9b3b706e80b497bfe04a6b6fbed0c5f7171", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 5, "deletions": 179, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/196236980613249f25ccb2968a214922f7db10f1/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196236980613249f25ccb2968a214922f7db10f1/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=196236980613249f25ccb2968a214922f7db10f1", "patch": "@@ -21,21 +21,17 @@ mod io;\n mod caps;\n mod req;\n mod dispatch;\n-mod handlers;\n mod util;\n mod conv;\n+mod main_loop;\n \n use threadpool::ThreadPool;\n-use crossbeam_channel::{bounded, Sender, Receiver};\n+use crossbeam_channel::bounded;\n use flexi_logger::Logger;\n-use languageserver_types::Url;\n-use libanalysis::{WorldState, World};\n+use libanalysis::WorldState;\n \n use ::{\n-    io::{Io, RawMsg, RawRequest, RawResponse, RawNotification},\n-    handlers::{handle_syntax_tree, handle_extend_selection, publish_diagnostics, publish_decorations,\n-               handle_document_symbol, handle_code_action},\n-    util::FilePath,\n+    io::{Io, RawMsg, RawResponse, RawNotification}\n };\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n@@ -121,7 +117,7 @@ fn initialized(io: &mut Io) -> Result<()> {\n         let mut pool = ThreadPool::new(4);\n         let (sender, receiver) = bounded::<Task>(16);\n         info!(\"lifecycle: handshake finished, server ready to serve requests\");\n-        let res = main_loop(io, &mut world, &mut pool, sender, receiver.clone());\n+        let res = main_loop::main_loop(io, &mut world, &mut pool, sender, receiver.clone());\n         info!(\"waiting for background jobs to finish...\");\n         receiver.for_each(drop);\n         pool.join();\n@@ -142,173 +138,3 @@ fn initialized(io: &mut Io) -> Result<()> {\n         }\n     }\n }\n-\n-fn main_loop(\n-    io: &mut Io,\n-    world: &mut WorldState,\n-    pool: &mut ThreadPool,\n-    sender: Sender<Task>,\n-    receiver: Receiver<Task>,\n-) -> Result<()> {\n-    info!(\"server initialized, serving requests\");\n-    loop {\n-        enum Event {\n-            Msg(RawMsg),\n-            Task(Task),\n-            ReceiverDead,\n-        }\n-\n-        let event = select! {\n-            recv(io.receiver(), msg) => match msg {\n-                Some(msg) => Event::Msg(msg),\n-                None => Event::ReceiverDead,\n-            },\n-            recv(receiver, task) => Event::Task(task.unwrap()),\n-        };\n-\n-        let msg = match event {\n-            Event::ReceiverDead => {\n-                io.cleanup_receiver()?;\n-                unreachable!();\n-            }\n-            Event::Task(task) => {\n-                match task {\n-                    Task::Respond(response) =>\n-                        io.send(RawMsg::Response(response)),\n-                    Task::Notify(n) =>\n-                        io.send(RawMsg::Notification(n)),\n-                    Task::Die(error) =>\n-                        return Err(error),\n-                }\n-                continue;\n-            }\n-            Event::Msg(msg) => msg,\n-        };\n-\n-        match msg {\n-            RawMsg::Request(req) => {\n-                let mut req = Some(req);\n-                handle_request_on_threadpool::<req::SyntaxTree>(\n-                    &mut req, pool, world, &sender, handle_syntax_tree,\n-                )?;\n-                handle_request_on_threadpool::<req::ExtendSelection>(\n-                    &mut req, pool, world, &sender, handle_extend_selection,\n-                )?;\n-                handle_request_on_threadpool::<req::DocumentSymbolRequest>(\n-                    &mut req, pool, world, &sender, handle_document_symbol,\n-                )?;\n-                handle_request_on_threadpool::<req::CodeActionRequest>(\n-                    &mut req, pool, world, &sender, handle_code_action,\n-                )?;\n-\n-                let mut shutdown = false;\n-                dispatch::handle_request::<req::Shutdown, _>(&mut req, |(), resp| {\n-                    let resp = resp.into_response(Ok(()))?;\n-                    io.send(RawMsg::Response(resp));\n-                    shutdown = true;\n-                    Ok(())\n-                })?;\n-                if shutdown {\n-                    info!(\"lifecycle: initiating shutdown\");\n-                    drop(sender);\n-                    return Ok(());\n-                }\n-                if let Some(req) = req {\n-                    error!(\"unknown method: {:?}\", req);\n-                    dispatch::unknown_method(io, req)?;\n-                }\n-            }\n-            RawMsg::Notification(not) => {\n-                let mut not = Some(not);\n-                dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n-                    let path = params.text_document.file_path()?;\n-                    world.change_overlay(path, Some(params.text_document.text));\n-                    update_file_notifications_on_threadpool(\n-                        pool, world.snapshot(), sender.clone(), params.text_document.uri,\n-                    );\n-                    Ok(())\n-                })?;\n-                dispatch::handle_notification::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n-                    let path = params.text_document.file_path()?;\n-                    let text = params.content_changes.pop()\n-                        .ok_or_else(|| format_err!(\"empty changes\"))?\n-                        .text;\n-                    world.change_overlay(path, Some(text));\n-                    update_file_notifications_on_threadpool(\n-                        pool, world.snapshot(), sender.clone(), params.text_document.uri,\n-                    );\n-                    Ok(())\n-                })?;\n-                dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n-                    let path = params.text_document.file_path()?;\n-                    world.change_overlay(path, None);\n-                    let not = req::PublishDiagnosticsParams {\n-                        uri: params.text_document.uri,\n-                        diagnostics: Vec::new(),\n-                    };\n-                    let not = dispatch::send_notification::<req::PublishDiagnostics>(not);\n-                    io.send(RawMsg::Notification(not));\n-                    Ok(())\n-                })?;\n-\n-                if let Some(not) = not {\n-                    error!(\"unhandled notification: {:?}\", not)\n-                }\n-            }\n-            msg => {\n-                eprintln!(\"msg = {:?}\", msg);\n-            }\n-        }\n-    }\n-}\n-\n-fn handle_request_on_threadpool<R: req::ClientRequest>(\n-    req: &mut Option<RawRequest>,\n-    pool: &ThreadPool,\n-    world: &WorldState,\n-    sender: &Sender<Task>,\n-    f: fn(World, R::Params) -> Result<R::Result>,\n-) -> Result<()>\n-{\n-    dispatch::handle_request::<R, _>(req, |params, resp| {\n-        let world = world.snapshot();\n-        let sender = sender.clone();\n-        pool.execute(move || {\n-            let res = f(world, params);\n-            let task = match resp.into_response(res) {\n-                Ok(resp) => Task::Respond(resp),\n-                Err(e) => Task::Die(e),\n-            };\n-            sender.send(task);\n-        });\n-        Ok(())\n-    })\n-}\n-\n-fn update_file_notifications_on_threadpool(\n-    pool: &ThreadPool,\n-    world: World,\n-    sender: Sender<Task>,\n-    uri: Url,\n-) {\n-    pool.execute(move || {\n-        match publish_diagnostics(world.clone(), uri.clone()) {\n-            Err(e) => {\n-                error!(\"failed to compute diagnostics: {:?}\", e)\n-            }\n-            Ok(params) => {\n-                let not = dispatch::send_notification::<req::PublishDiagnostics>(params);\n-                sender.send(Task::Notify(not));\n-            }\n-        }\n-        match publish_decorations(world, uri) {\n-            Err(e) => {\n-                error!(\"failed to compute decorations: {:?}\", e)\n-            }\n-            Ok(params) => {\n-                let not = dispatch::send_notification::<req::PublishDecorations>(params);\n-                sender.send(Task::Notify(not))\n-            }\n-        }\n-    });\n-}"}, {"sha": "c6db222899aeeb50946e4deb17e9878e7339d1df", "filename": "crates/server/src/main_loop/handlers.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/196236980613249f25ccb2968a214922f7db10f1/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196236980613249f25ccb2968a214922f7db10f1/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=196236980613249f25ccb2968a214922f7db10f1", "previous_filename": "crates/server/src/handlers.rs"}, {"sha": "e7b24e53f2741fff9199688821dc77c4321deb03", "filename": "crates/server/src/main_loop/mod.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/196236980613249f25ccb2968a214922f7db10f1/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/196236980613249f25ccb2968a214922f7db10f1/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=196236980613249f25ccb2968a214922f7db10f1", "patch": "@@ -0,0 +1,201 @@\n+mod handlers;\n+\n+use threadpool::ThreadPool;\n+use crossbeam_channel::{Sender, Receiver};\n+use languageserver_types::Url;\n+use libanalysis::{World, WorldState};\n+use {\n+    req, dispatch,\n+    Task, Result,\n+    io::{Io, RawMsg, RawRequest},\n+    util::FilePath,\n+    main_loop::handlers::{\n+        handle_syntax_tree,\n+        handle_extend_selection,\n+        publish_diagnostics,\n+        publish_decorations,\n+        handle_document_symbol,\n+        handle_code_action,\n+    },\n+};\n+\n+pub(super) fn main_loop(\n+    io: &mut Io,\n+    world: &mut WorldState,\n+    pool: &mut ThreadPool,\n+    sender: Sender<Task>,\n+    receiver: Receiver<Task>,\n+) -> Result<()> {\n+    info!(\"server initialized, serving requests\");\n+    loop {\n+        enum Event {\n+            Msg(RawMsg),\n+            Task(Task),\n+            ReceiverDead,\n+        }\n+        let event = select! {\n+            recv(io.receiver(), msg) => match msg {\n+                Some(msg) => Event::Msg(msg),\n+                None => Event::ReceiverDead,\n+            },\n+            recv(receiver, task) => Event::Task(task.unwrap()),\n+        };\n+\n+        match event {\n+            Event::ReceiverDead => {\n+                io.cleanup_receiver()?;\n+                unreachable!();\n+            }\n+            Event::Task(task) => {\n+                match task {\n+                    Task::Respond(response) =>\n+                        io.send(RawMsg::Response(response)),\n+                    Task::Notify(n) =>\n+                        io.send(RawMsg::Notification(n)),\n+                    Task::Die(error) =>\n+                        return Err(error),\n+                }\n+                continue;\n+            }\n+            Event::Msg(msg) => {\n+                if !on_msg(io, world, pool, &sender, msg)? {\n+                    return Ok(());\n+                }\n+            }\n+        };\n+    }\n+}\n+\n+fn on_msg(\n+    io: &mut Io,\n+    world: &mut WorldState,\n+    pool: &mut ThreadPool,\n+    sender: &Sender<Task>,\n+    msg: RawMsg,\n+) -> Result<bool> {\n+    match msg {\n+        RawMsg::Request(req) => {\n+            let mut req = Some(req);\n+            handle_request_on_threadpool::<req::SyntaxTree>(\n+                &mut req, pool, world, sender, handle_syntax_tree,\n+            )?;\n+            handle_request_on_threadpool::<req::ExtendSelection>(\n+                &mut req, pool, world, sender, handle_extend_selection,\n+            )?;\n+            handle_request_on_threadpool::<req::DocumentSymbolRequest>(\n+                &mut req, pool, world, sender, handle_document_symbol,\n+            )?;\n+            handle_request_on_threadpool::<req::CodeActionRequest>(\n+                &mut req, pool, world, sender, handle_code_action,\n+            )?;\n+\n+            let mut shutdown = false;\n+            dispatch::handle_request::<req::Shutdown, _>(&mut req, |(), resp| {\n+                let resp = resp.into_response(Ok(()))?;\n+                io.send(RawMsg::Response(resp));\n+                shutdown = true;\n+                Ok(())\n+            })?;\n+            if shutdown {\n+                info!(\"lifecycle: initiating shutdown\");\n+                return Ok(false);\n+            }\n+            if let Some(req) = req {\n+                error!(\"unknown method: {:?}\", req);\n+                dispatch::unknown_method(io, req)?;\n+            }\n+        }\n+        RawMsg::Notification(not) => {\n+            let mut not = Some(not);\n+            dispatch::handle_notification::<req::DidOpenTextDocument, _>(&mut not, |params| {\n+                let path = params.text_document.file_path()?;\n+                world.change_overlay(path, Some(params.text_document.text));\n+                update_file_notifications_on_threadpool(\n+                    pool, world.snapshot(), sender.clone(), params.text_document.uri,\n+                );\n+                Ok(())\n+            })?;\n+            dispatch::handle_notification::<req::DidChangeTextDocument, _>(&mut not, |mut params| {\n+                let path = params.text_document.file_path()?;\n+                let text = params.content_changes.pop()\n+                    .ok_or_else(|| format_err!(\"empty changes\"))?\n+                    .text;\n+                world.change_overlay(path, Some(text));\n+                update_file_notifications_on_threadpool(\n+                    pool, world.snapshot(), sender.clone(), params.text_document.uri,\n+                );\n+                Ok(())\n+            })?;\n+            dispatch::handle_notification::<req::DidCloseTextDocument, _>(&mut not, |params| {\n+                let path = params.text_document.file_path()?;\n+                world.change_overlay(path, None);\n+                let not = req::PublishDiagnosticsParams {\n+                    uri: params.text_document.uri,\n+                    diagnostics: Vec::new(),\n+                };\n+                let not = dispatch::send_notification::<req::PublishDiagnostics>(not);\n+                io.send(RawMsg::Notification(not));\n+                Ok(())\n+            })?;\n+\n+            if let Some(not) = not {\n+                error!(\"unhandled notification: {:?}\", not)\n+            }\n+        }\n+        msg => {\n+            eprintln!(\"msg = {:?}\", msg);\n+        }\n+    };\n+    Ok(true)\n+}\n+\n+fn handle_request_on_threadpool<R: req::ClientRequest>(\n+    req: &mut Option<RawRequest>,\n+    pool: &ThreadPool,\n+    world: &WorldState,\n+    sender: &Sender<Task>,\n+    f: fn(World, R::Params) -> Result<R::Result>,\n+) -> Result<()>\n+{\n+    dispatch::handle_request::<R, _>(req, |params, resp| {\n+        let world = world.snapshot();\n+        let sender = sender.clone();\n+        pool.execute(move || {\n+            let res = f(world, params);\n+            let task = match resp.into_response(res) {\n+                Ok(resp) => Task::Respond(resp),\n+                Err(e) => Task::Die(e),\n+            };\n+            sender.send(task);\n+        });\n+        Ok(())\n+    })\n+}\n+\n+fn update_file_notifications_on_threadpool(\n+    pool: &ThreadPool,\n+    world: World,\n+    sender: Sender<Task>,\n+    uri: Url,\n+) {\n+    pool.execute(move || {\n+        match publish_diagnostics(world.clone(), uri.clone()) {\n+            Err(e) => {\n+                error!(\"failed to compute diagnostics: {:?}\", e)\n+            }\n+            Ok(params) => {\n+                let not = dispatch::send_notification::<req::PublishDiagnostics>(params);\n+                sender.send(Task::Notify(not));\n+            }\n+        }\n+        match publish_decorations(world, uri) {\n+            Err(e) => {\n+                error!(\"failed to compute decorations: {:?}\", e)\n+            }\n+            Ok(params) => {\n+                let not = dispatch::send_notification::<req::PublishDecorations>(params);\n+                sender.send(Task::Notify(not))\n+            }\n+        }\n+    });\n+}"}]}