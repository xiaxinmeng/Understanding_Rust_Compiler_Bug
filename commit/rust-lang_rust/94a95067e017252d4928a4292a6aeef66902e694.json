{"sha": "94a95067e017252d4928a4292a6aeef66902e694", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YTk1MDY3ZTAxNzI1MmQ0OTI4YTQyOTJhNmFlZWY2NjkwMmU2OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-18T17:32:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-18T17:32:13Z"}, "message": "Auto merge of #23473 - Manishearth:rollup, r=Manishearth", "tree": {"sha": "1ead2554c428c121991282ebeae87f6609c729b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ead2554c428c121991282ebeae87f6609c729b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94a95067e017252d4928a4292a6aeef66902e694", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94a95067e017252d4928a4292a6aeef66902e694", "html_url": "https://github.com/rust-lang/rust/commit/94a95067e017252d4928a4292a6aeef66902e694", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94a95067e017252d4928a4292a6aeef66902e694/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46f649c479ce40f3b4590590dda6c2895e8d60f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/46f649c479ce40f3b4590590dda6c2895e8d60f6", "html_url": "https://github.com/rust-lang/rust/commit/46f649c479ce40f3b4590590dda6c2895e8d60f6"}, {"sha": "2a106d68f4987733b150e4a8b2f8be209ab6ae14", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a106d68f4987733b150e4a8b2f8be209ab6ae14", "html_url": "https://github.com/rust-lang/rust/commit/2a106d68f4987733b150e4a8b2f8be209ab6ae14"}], "stats": {"total": 479, "additions": 362, "deletions": 117}, "files": [{"sha": "a754bd950f7f6006709fac0e228eda7cb706c8ec", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -1052,22 +1052,22 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let range = haystack.char_range_at(*idx);\n-    if range.ch != needle {\n+    let ch = haystack.char_at(*idx);\n+    if ch != needle {\n         return false;\n     }\n-    *idx = range.next;\n+    *idx += ch.len_utf8();\n     return true;\n }\n \n fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n-        let range = haystack.char_range_at(i);\n-        if range.ch < '0' || '9' < range.ch {\n+        let ch = haystack.char_at(i);\n+        if ch < '0' || '9' < ch {\n             break;\n         }\n-        i = range.next;\n+        i += ch.len_utf8();\n     }\n     if i == *idx {\n         return false;\n@@ -1083,9 +1083,9 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n         if haystack_i >= haystack.len() {\n             return false;\n         }\n-        let range = haystack.char_range_at(haystack_i);\n-        haystack_i = range.next;\n-        if !scan_char(needle, range.ch, &mut needle_i) {\n+        let ch = haystack.char_at(haystack_i);\n+        haystack_i += ch.len_utf8();\n+        if !scan_char(needle, ch, &mut needle_i) {\n             return false;\n         }\n     }"}, {"sha": "c4a014967633321e10a765c2c9a53edfe87bb738", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -35,6 +35,7 @@\n #![feature(unique)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(step_by)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand\n "}, {"sha": "078d18a310aff49bdfc36a81d7f50b9ef218543c", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 104, "deletions": 58, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -175,7 +175,9 @@ enum DecompositionType {\n ///\n /// For use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"unicode\",\n+           reason = \"this functionality may be replaced with a more generic \\\n+                     unicode crate on crates.io\")]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n@@ -266,7 +268,9 @@ enum RecompositionState {\n ///\n /// For use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"collections\")]\n+#[unstable(feature = \"unicode\",\n+           reason = \"this functionality may be replaced with a more generic \\\n+                     unicode crate on crates.io\")]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -472,8 +476,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -486,8 +491,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfkd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -500,8 +506,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -515,8 +522,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn nfkc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -923,11 +931,11 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n     /// Returns a string with all pre- and suffixes that match a pattern repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// The pattern can be any `DoubleEndedSearcher`, including a closure that determines the split.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple `char` patterns:\n     ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n@@ -1023,8 +1031,11 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"it is unclear whether this method pulls its weight \\\n+                         with the existence of the char_indices iterator or \\\n+                         this method may want to be replaced with checked \\\n+                         slicing\")]\n     fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n@@ -1069,8 +1080,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// 14: a\n     /// 15: m\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at() or eventually \\\n+                         removed altogether\")]\n     fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[..], start)\n     }\n@@ -1117,8 +1130,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// 6: \u534e\n     /// 3: \u4e2d\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at() or eventually \\\n+                         removed altogether\")]\n     fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n@@ -1137,8 +1152,12 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"frequently replaced by the chars() iterator, this \\\n+                         method may be removed or possibly renamed in the \\\n+                         future; it is normally replaced by chars/char_indices \\\n+                         iterators or by getting the first char from a \\\n+                         subslice\")]\n     fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[..], i)\n     }\n@@ -1157,8 +1176,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n     /// assert_eq!(s.char_at_reverse(2), 'b');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"see char_at for more details, but reverse semantics \\\n+                         are also somewhat unclear, especially with which \\\n+                         cases generate panics\")]\n     fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n@@ -1297,8 +1318,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"awaiting conventions about shifting and slices\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"awaiting conventions about shifting and slices and \\\n+                         may not be warranted with the existence of the chars \\\n+                         and/or char_indices iterators\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[..])\n     }\n@@ -1421,8 +1444,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[..], is_extended)\n     }\n@@ -1438,8 +1462,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[..], is_extended)\n     }\n@@ -1467,13 +1492,15 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// Control characters have zero width.\n     ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category: if `is_cjk` is\n-    /// `true`, these are 2 columns wide; otherwise, they are 1. In CJK locales, `is_cjk` should be\n-    /// `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/) recommends that these\n-    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the locale is unknown.\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may only be provided by libunicode\")]\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e., `is_cjk =\n+    /// false`) if the locale is unknown.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[..], is_cjk)\n     }\n@@ -1615,8 +1642,9 @@ impl str {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -1629,8 +1657,9 @@ impl str {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfkd_chars(&self) -> Decompositions {\n         Decompositions {\n             iter: self[..].chars(),\n@@ -1643,8 +1672,9 @@ impl str {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfd_chars(),\n@@ -1658,8 +1688,9 @@ impl str {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"collections\",\n-               reason = \"this functionality may be moved to libunicode\")]\n+    #[unstable(feature = \"unicode\",\n+               reason = \"this functionality may be replaced with a more generic \\\n+                         unicode crate on crates.io\")]\n     pub fn nfkc_chars(&self) -> Recompositions {\n         Recompositions {\n             iter: self.nfkd_chars(),\n@@ -2172,8 +2203,11 @@ impl str {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"it is unclear whether this method pulls its weight \\\n+                         with the existence of the char_indices iterator or \\\n+                         this method may want to be replaced with checked \\\n+                         slicing\")]\n     pub fn is_char_boundary(&self, index: usize) -> bool {\n         core_str::StrExt::is_char_boundary(&self[..], index)\n     }\n@@ -2218,8 +2252,10 @@ impl str {\n     /// 14: a\n     /// 15: m\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at() or eventually \\\n+                         removed altogether\")]\n     pub fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[..], start)\n     }\n@@ -2266,8 +2302,10 @@ impl str {\n     /// 6: \u534e\n     /// 3: \u4e2d\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"often replaced by char_indices, this method may \\\n+                         be removed in favor of just char_at_reverse() or \\\n+                         eventually removed altogether\")]\n     pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[..], start)\n     }\n@@ -2286,8 +2324,12 @@ impl str {\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"frequently replaced by the chars() iterator, this \\\n+                         method may be removed or possibly renamed in the \\\n+                         future; it is normally replaced by chars/char_indices \\\n+                         iterators or by getting the first char from a \\\n+                         subslice\")]\n     pub fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[..], i)\n     }\n@@ -2306,8 +2348,10 @@ impl str {\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n     /// assert_eq!(s.char_at_reverse(2), 'b');\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"naming is uncertain with container conventions\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"see char_at for more details, but reverse semantics \\\n+                         are also somewhat unclear, especially with which \\\n+                         cases generate panics\")]\n     pub fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n@@ -2446,8 +2490,10 @@ impl str {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"awaiting conventions about shifting and slices\")]\n+    #[unstable(feature = \"str_char\",\n+               reason = \"awaiting conventions about shifting and slices and \\\n+                         may not be warranted with the existence of the chars \\\n+                         and/or char_indices iterators\")]\n     pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[..])\n     }\n@@ -2570,7 +2616,7 @@ impl str {\n     ///\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[..], is_extended)\n@@ -2587,7 +2633,7 @@ impl str {\n     ///\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[..], is_extended)\n@@ -2621,7 +2667,7 @@ impl str {\n     /// `true`, else it should be `false`.\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/) recommends that these\n     /// characters be treated as 1 column (i.e., `is_cjk = false`) if the locale is unknown.\n-    #[unstable(feature = \"collections\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[..], is_cjk)"}, {"sha": "2a5f8db049689e870fb3e7782e2bdbb4962b3908", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -29,7 +29,7 @@ use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n use borrow::{Cow, IntoCow};\n-use str::{self, CharRange, FromStr, Utf8Error};\n+use str::{self, FromStr, Utf8Error};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -561,9 +561,9 @@ impl String {\n             return None\n         }\n \n-        let CharRange {ch, next} = self.char_range_at_reverse(len);\n+        let ch = self.char_at_reverse(len);\n         unsafe {\n-            self.vec.set_len(next);\n+            self.vec.set_len(len - ch.len_utf8());\n         }\n         Some(ch)\n     }\n@@ -595,7 +595,8 @@ impl String {\n         let len = self.len();\n         assert!(idx <= len);\n \n-        let CharRange { ch, next } = self.char_range_at(idx);\n+        let ch = self.char_at(idx);\n+        let next = idx + ch.len_utf8();\n         unsafe {\n             ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n                       self.vec.as_ptr().offset(next as isize),"}, {"sha": "6b83338e1d2103f4c26b758469934ef3e84da77e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -18,6 +18,7 @@\n \n use self::OldSearcher::{TwoWay, TwoWayLong};\n \n+use char::CharExt;\n use clone::Clone;\n use cmp::{self, Eq};\n use default::Default;\n@@ -1112,8 +1113,10 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[derive(Copy)]\n-#[unstable(feature = \"core\",\n-           reason = \"naming is uncertain with container conventions\")]\n+#[unstable(feature = \"str_char\",\n+           reason = \"existence of this struct is uncertain as it is frequently \\\n+                     able to be replaced with char.len_utf8() and/or \\\n+                     char/char_indices iterators\")]\n pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n@@ -1646,8 +1649,8 @@ impl StrExt for str {\n         if self.is_empty() {\n             None\n         } else {\n-            let CharRange {ch, next} = self.char_range_at(0);\n-            let next_s = unsafe { self.slice_unchecked(next, self.len()) };\n+            let ch = self.char_at(0);\n+            let next_s = unsafe { self.slice_unchecked(ch.len_utf8(), self.len()) };\n             Some((ch, next_s))\n         }\n     }"}, {"sha": "206fdd243c783ab154fc90b1e67123d974f1875c", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -92,11 +92,10 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![deny(missing_docs)]\n-#![feature(collections)]\n #![feature(int_uint)]\n #![feature(staged_api)]\n-#![feature(core)]\n #![feature(str_words)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;\n@@ -620,8 +619,8 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let mut j = 1;\n                 names = Vec::new();\n                 while j < curlen {\n-                    let range = cur.char_range_at(j);\n-                    let opt = Short(range.ch);\n+                    let ch = cur.char_at(j);\n+                    let opt = Short(ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n                        see one which takes an argument, we assume all\n@@ -642,12 +641,13 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                         No => false\n                     };\n \n-                    if arg_follows && range.next < curlen {\n-                        i_arg = Some((&cur[range.next..curlen]).to_string());\n+                    let next = j + ch.len_utf8();\n+                    if arg_follows && next < curlen {\n+                        i_arg = Some((&cur[next..curlen]).to_string());\n                         break;\n                     }\n \n-                    j = range.next;\n+                    j = next;\n                 }\n             }\n             let mut name_pos = 0;"}, {"sha": "1e1b128d71234abc3da8c11b453d2c3c1cb99602", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -269,8 +269,8 @@ pub mod types {\n                 #[repr(C)]\n                 #[derive(Copy)] pub struct sockaddr_storage {\n                     pub ss_family: sa_family_t,\n-                    pub __ss_align: i64,\n-                    pub __ss_pad2: [u8; 112],\n+                    pub __ss_align: isize,\n+                    pub __ss_pad2: [u8; 128 - 2 * (::core::isize::BYTES as usize)],\n                 }\n                 #[repr(C)]\n                 #[derive(Copy)] pub struct sockaddr_in {"}, {"sha": "97ed391fdfc7842470d6ba283928c6f6bf0f6369", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -42,6 +42,7 @@\n #![feature(io)]\n #![feature(path_ext)]\n #![feature(str_words)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "0071e4434efa4a5ae8cc1aff523c887388c41c67", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -38,6 +38,7 @@\n #![feature(exit_status)]\n #![feature(io)]\n #![feature(set_stdio)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "99b3393c003de840856e6511268a6bd1d318be51", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -41,6 +41,7 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n \n extern crate syntax;"}, {"sha": "45d4a1edc6b2414074ecc573012ad832a40e819d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -5240,7 +5240,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // inside the loop?\n     (loop_query(&*b, |e| {\n         match *e {\n-            ast::ExprBreak(_) => true,\n+            ast::ExprBreak(None) => true,\n             _ => false\n         }\n     })) ||"}, {"sha": "31c270dca6bba1fa612d6c18da71362b4cc33916", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -37,6 +37,7 @@ Core encoding and decoding interfaces.\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "b055796ba547fefc9ce9ea8df62d797373d89cc9", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -73,10 +73,10 @@\n //!\n //! ## Concurrency, I/O, and the runtime\n //!\n-//! The [`thread`](thread/index.html) module contains Rust's threading abstractions,\n-//! while [`comm`](comm/index.html) contains the channel types for message\n-//! passing. [`sync`](sync/index.html) contains further, primitive, shared\n-//! memory types, including [`atomic`](sync/atomic/index.html).\n+//! The [`thread`](thread/index.html) module contains Rust's threading abstractions.\n+//! [`sync`](sync/index.html) contains further, primitive, shared memory types,\n+//! including [`atomic`](sync/atomic/index.html), and [`mpsc`](sync/mpmc/index.html),\n+//! which contains the channel types for message passing.\n //!\n //! Common types of I/O, including files, TCP, UDP, pipes, Unix domain sockets,\n //! timers, and process spawning, are defined in the\n@@ -127,6 +127,7 @@\n #![feature(int_uint)]\n #![feature(unique)]\n #![feature(allow_internal_unstable)]\n+#![feature(str_char)]\n #![cfg_attr(test, feature(test, rustc_private))]\n \n // Don't link to std. We are std."}, {"sha": "73c2464a6b2cb9b33449568b3149c34a3e0e3a9e", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -202,7 +202,7 @@ impl FromInner<libc::in_addr> for Ipv4Addr {\n impl Ipv6Addr {\n     /// Create a new IPv6 address from eight 16-bit segments.\n     ///\n-    /// The result will represent the IP address a:b:c:d:e:f\n+    /// The result will represent the IP address a:b:c:d:e:f:g:h\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n                h: u16) -> Ipv6Addr {"}, {"sha": "5c2757153521c3f024c9412fc8dd677e24f1d471", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 157, "deletions": 15, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -150,7 +150,7 @@ impl PartialEq for Ident {\n \n /// A SyntaxContext represents a chain of macro-expandings\n /// and renamings. Each macro expansion corresponds to\n-/// a fresh usize\n+/// a fresh u32\n \n // I'm representing this syntax context as an index into\n // a table, in order to work around a compiler bug\n@@ -216,6 +216,7 @@ pub struct Lifetime {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+/// A lifetime definition, eg `'a: 'b+'c+'d`\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: Vec<Lifetime>\n@@ -251,7 +252,9 @@ pub struct PathSegment {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PathParameters {\n+    /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n     AngleBracketedParameters(AngleBracketedParameterData),\n+    /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n     ParenthesizedParameters(ParenthesizedParameterData),\n }\n \n@@ -436,34 +439,45 @@ impl Generics {\n     }\n }\n \n+/// A `where` clause in a definition\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n     pub predicates: Vec<WherePredicate>,\n }\n \n+/// A single predicate in a `where` clause\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum WherePredicate {\n+    /// A type binding, eg `for<'c> Foo: Send+Clone+'c`\n     BoundPredicate(WhereBoundPredicate),\n+    /// A lifetime predicate, e.g. `'a: 'b+'c`\n     RegionPredicate(WhereRegionPredicate),\n+    /// An equality predicate (unsupported)\n     EqPredicate(WhereEqPredicate)\n }\n \n+/// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n+    /// Any lifetimes from a `for` binding\n     pub bound_lifetimes: Vec<LifetimeDef>,\n+    /// The type being bounded\n     pub bounded_ty: P<Ty>,\n+    /// Trait and lifetime bounds (`Clone+Send+'static`)\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n \n+/// A lifetime predicate, e.g. `'a: 'b+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: Vec<Lifetime>,\n }\n \n+/// An equality predicate (unsupported), e.g. `T=int`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n@@ -521,9 +535,13 @@ impl PartialEq for MetaItem_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n+    /// Statements in a block\n     pub stmts: Vec<P<Stmt>>,\n+    /// An expression at the end of the block\n+    /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n+    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n }\n@@ -535,9 +553,16 @@ pub struct Pat {\n     pub span: Span,\n }\n \n+/// A single field in a struct pattern\n+///\n+/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n+/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n+/// except is_shorthand is true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n+    /// The identifier for the field\n     pub ident: Ident,\n+    /// The pattern the field is destructured to\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n }\n@@ -574,15 +599,23 @@ pub enum Pat_ {\n     /// \"None\" means a * pattern where we don't bind the fields to names.\n     PatEnum(Path, Option<Vec<P<Pat>>>),\n \n+    /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n+    /// The `bool` is `true` in the presence of a `..`\n     PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+    /// A tuple pattern `(a, b)`\n     PatTup(Vec<P<Pat>>),\n+    /// A `box` pattern\n     PatBox(P<Pat>),\n-    PatRegion(P<Pat>, Mutability), // reference pattern\n+    /// A reference pattern, e.g. `&mut (a, b)`\n+    PatRegion(P<Pat>, Mutability),\n+    /// A literal\n     PatLit(P<Expr>),\n+    /// A range pattern, e.g. `1...2`\n     PatRange(P<Expr>, P<Expr>),\n     /// [a, b, ..i, y, z] is represented as:\n     ///     PatVec(box [a, b], Some(i), box [y, z])\n     PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    /// A macro pattern; pre-expansion\n     PatMac(Mac),\n }\n \n@@ -594,36 +627,59 @@ pub enum Mutability {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOp_ {\n+    /// The `+` operator (addition)\n     BiAdd,\n+    /// The `-` operator (subtraction)\n     BiSub,\n+    /// The `*` operator (multiplication)\n     BiMul,\n+    /// The `/` operator (division)\n     BiDiv,\n+    /// The `%` operator (modulus)\n     BiRem,\n+    /// The `&&` operator (logical and)\n     BiAnd,\n+    /// The `||` operator (logical or)\n     BiOr,\n+    /// The `^` operator (bitwise xor)\n     BiBitXor,\n+    /// The `&` operator (bitwise and)\n     BiBitAnd,\n+    /// The `|` operator (bitwise or)\n     BiBitOr,\n+    /// The `<<` operator (shift left)\n     BiShl,\n+    /// The `>>` operator (shift right)\n     BiShr,\n+    /// The `==` operator (equality)\n     BiEq,\n+    /// The `<` operator (less than)\n     BiLt,\n+    /// The `<=` operator (less than or equal to)\n     BiLe,\n+    /// The `!=` operator (not equal to)\n     BiNe,\n+    /// The `>=` operator (greater than or equal to)\n     BiGe,\n+    /// The `>` operator (greater than)\n     BiGt,\n }\n \n pub type BinOp = Spanned<BinOp_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnOp {\n+    /// The `box` operator\n     UnUniq,\n+    /// The `*` operator for dereferencing\n     UnDeref,\n+    /// The `!` operator for logical inversion\n     UnNot,\n+    /// The `-` operator for negation\n     UnNeg\n }\n \n+/// A statement\n pub type Stmt = Spanned<Stmt_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -668,6 +724,7 @@ pub enum LocalSource {\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n+    /// Initializer expression to set the value, if any\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n@@ -714,6 +771,7 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n+/// An expression\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Expr {\n     pub id: NodeId,\n@@ -725,55 +783,109 @@ pub struct Expr {\n pub enum Expr_ {\n     /// First expr is the place; second expr is the value.\n     ExprBox(Option<P<Expr>>, P<Expr>),\n+    /// An array (`[a, b, c, d]`)\n     ExprVec(Vec<P<Expr>>),\n+    /// A function call\n+    /// The first field resolves to the function itself,\n+    /// and the second field is the list of arguments\n     ExprCall(P<Expr>, Vec<P<Expr>>),\n+    /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n+    /// The `SpannedIdent` is the identifier for the method name\n+    /// The vector of `Ty`s are the ascripted type parameters for the method\n+    /// (within the angle brackets)\n+    /// The first element of the vector of `Expr`s is the expression that evaluates\n+    /// to the object on which the method is being called on (the receiver),\n+    /// and the remaining elements are the rest of the arguments.\n+    /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n+    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`\n     ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    /// A tuple (`(a, b, c ,d)`)\n     ExprTup(Vec<P<Expr>>),\n+    /// A binary operation (For example: `a + b`, `a * b`)\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    /// A unary operation (For example: `!x`, `*x`)\n     ExprUnary(UnOp, P<Expr>),\n+    /// A literal (For example: `1u8`, `\"foo\"`)\n     ExprLit(P<Lit>),\n+    /// A cast (`foo as f64`)\n     ExprCast(P<Expr>, P<Ty>),\n+    /// An `if` block, with an optional else block\n+    /// `if expr { block } else { expr }`\n     ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    /// An `if let` expression with an optional else block\n+    /// `if let pat = expr { block } else { expr }`\n+    /// This is desugared to a `match` expression\n     ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    /// A while loop, with an optional label\n+    /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    /// A while-let loop, with an optional label\n+    /// `'label: while let pat = expr { block }`\n+    /// This is desugared to a combination of `loop` and `match` expressions\n     ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    /// A for loop, with an optional label\n+    /// `'label: for pat in expr { block }`\n+    /// This is desugared to a combination of `loop` and `match` expressions\n     ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n-    // Conditionless loop (can be exited with break, cont, or ret)\n+    /// Conditionless loop (can be exited with break, continue, or return)\n+    /// `'label: loop { block }`\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n+    /// A `match` block, with a source that indicates whether or not it is\n+    /// the result of a desugaring, and if so, which kind\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n+    /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n+    /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n+    /// An assignment (`a = foo()`)\n     ExprAssign(P<Expr>, P<Expr>),\n+    /// An assignment with an operator\n+    /// For example, `a += 1`\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    /// Access of a named struct field (`obj.foo`)\n     ExprField(P<Expr>, SpannedIdent),\n+    /// Access of an unnamed field of a struct or tuple-struct\n+    /// For example, `foo.0`\n     ExprTupField(P<Expr>, Spanned<usize>),\n+    /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n+    /// A range (`1..2`, `1..`, or `..2`)\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters, e.g. foo::bar::<baz>. Optionally \"qualified\",\n     /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ExprPath(Option<QSelf>, Path),\n \n+    /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n+    /// A `break`, with an optional label to break\n     ExprBreak(Option<Ident>),\n+    /// A `continue`, with an optional label\n     ExprAgain(Option<Ident>),\n+    /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n+    /// Output of the `asm!()` macro\n     ExprInlineAsm(InlineAsm),\n \n+    /// A macro invocation; pre-expansion\n     ExprMac(Mac),\n \n     /// A struct literal expression.\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>> /* base */),\n+    /// For example, `Foo {x: 1, y: 2}`, or\n+    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`\n+    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n \n     /// A vector literal constructed from one repeated element.\n-    ExprRepeat(P<Expr> /* element */, P<Expr> /* count */),\n+    /// For example, `[1u8; 5]`. The first expression is the element\n+    /// to be repeated; the second is the number of times to repeat it\n+    ExprRepeat(P<Expr>, P<Expr>),\n \n     /// No-op: used solely so we can pretty-print faithfully\n     ExprParen(P<Expr>)\n@@ -880,7 +992,6 @@ pub enum KleeneOp {\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-#[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     /// A single token\n     TtToken(Span, token::Token),\n@@ -991,10 +1102,14 @@ pub enum Mac_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StrStyle {\n+    /// A regular string, like `\"foo\"`\n     CookedStr,\n+    /// A raw string, like `r##\"foo\"##`\n+    /// The uint is the number of `#` symbols used\n     RawStr(usize)\n }\n \n+/// A literal\n pub type Lit = Spanned<Lit_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1032,13 +1147,21 @@ impl LitIntType {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Lit_ {\n+    /// A string literal (`\"foo\"`)\n     LitStr(InternedString, StrStyle),\n+    /// A byte string (`b\"foo\"`)\n     LitBinary(Rc<Vec<u8>>),\n+    /// A byte char (`b'f'`)\n     LitByte(u8),\n+    /// A character literal (`'a'`)\n     LitChar(char),\n+    /// An integer liteal (`1u8`)\n     LitInt(u64, LitIntType),\n+    /// A float literal (`1f64` or `1E10f64`)\n     LitFloat(InternedString, FloatTy),\n+    /// A float literal without a suffix (`1.0 or 1.0E10`)\n     LitFloatUnsuffixed(InternedString),\n+    /// A boolean literal\n     LitBool(bool),\n }\n \n@@ -1361,9 +1484,9 @@ impl fmt::Display for Unsafety {\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub enum ImplPolarity {\n-    /// impl Trait for Type\n+    /// `impl Trait for Type`\n     Positive,\n-    /// impl !Trait for Type\n+    /// `impl !Trait for Type`\n     Negative,\n }\n \n@@ -1379,10 +1502,10 @@ impl fmt::Debug for ImplPolarity {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n-    /// Functions with return type ! that always\n+    /// Functions with return type `!`that always\n     /// raise an error or exit (i.e. never return to the caller)\n     NoReturn(Span),\n-    /// Return type is not specified. Functions default to () and\n+    /// Return type is not specified. Functions default to `()` and\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n@@ -1438,7 +1561,9 @@ pub struct VariantArg {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantKind {\n+    /// Tuple variant, e.g. `Foo(A, B)`\n     TupleVariantKind(Vec<VariantArg>),\n+    /// Struct variant, e.g. `Foo {x: A, y: B}`\n     StructVariantKind(P<StructDef>),\n }\n \n@@ -1453,6 +1578,7 @@ pub struct Variant_ {\n     pub attrs: Vec<Attribute>,\n     pub kind: VariantKind,\n     pub id: NodeId,\n+    /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<P<Expr>>,\n     pub vis: Visibility,\n }\n@@ -1603,6 +1729,9 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n+/// An item\n+///\n+/// The name might be a dummy name in case of anonymous items\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub ident: Ident,\n@@ -1615,19 +1744,27 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n-    // Optional location (containing arbitrary characters) from which\n-    // to fetch the crate sources.\n-    // For example, extern crate whatever = \"github.com/rust-lang/rust\".\n+    /// An`extern crate` item, with optional original crate name,\n+    /// e.g. `extern crate foo` or `extern crate \"foo-bar\" as foo`\n     ItemExternCrate(Option<(InternedString, StrStyle)>),\n+    /// A `use` or `pub use` item\n     ItemUse(P<ViewPath>),\n \n+    /// A `static` item\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n+    /// A function declaration\n     ItemFn(P<FnDecl>, Unsafety, Abi, Generics, P<Block>),\n+    /// A module\n     ItemMod(Mod),\n+    /// An external module\n     ItemForeignMod(ForeignMod),\n+    /// A type alias, e.g. `type Foo = Bar<u8>`\n     ItemTy(P<Ty>, Generics),\n+    /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n     ItemEnum(EnumDef, Generics),\n+    /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(P<StructDef>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Unsafety,\n@@ -1636,8 +1773,9 @@ pub enum Item_ {\n               Vec<P<TraitItem>>),\n \n     // Default trait implementations\n-    // `impl Trait for ..`\n+    // `impl Trait for .. {}`\n     ItemDefaultImpl(Unsafety, TraitRef),\n+    /// An implementation, eg `impl<A> Trait for Foo { .. }`\n     ItemImpl(Unsafety,\n              ImplPolarity,\n              Generics,\n@@ -1679,10 +1817,14 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n+/// An item within an `extern` block\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItem_ {\n+    /// A foreign function\n     ForeignItemFn(P<FnDecl>, Generics),\n-    ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n+    /// A foreign static item (`static ext: u8`), with optional mutability\n+    /// (the boolean is true when mutable)\n+    ForeignItemStatic(P<Ty>, bool),\n }\n \n impl ForeignItem_ {"}, {"sha": "9f217bba00ab6e2b30b280c953a72032aed578a4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -38,6 +38,7 @@\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(path_ext)]\n+#![feature(str_char)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "277f5365db3eca6883cf06531db133c44a64e4ae", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -20,7 +20,6 @@ use parse::lexer;\n use print::pprust;\n \n use std::io::Read;\n-use std::str;\n use std::usize;\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -210,11 +209,11 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n     let mut col = col.to_usize();\n     let mut cursor: usize = 0;\n     while col > 0 && cursor < len {\n-        let r: str::CharRange = s.char_range_at(cursor);\n-        if !r.ch.is_whitespace() {\n+        let ch = s.char_at(cursor);\n+        if !ch.is_whitespace() {\n             return None;\n         }\n-        cursor = r.next;\n+        cursor += ch.len_utf8();\n         col -= 1;\n     }\n     return Some(cursor);"}, {"sha": "bb8f9da89171c96c8dea5b39f7de55a071ae2e1a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -22,7 +22,6 @@ use std::fmt;\n use std::mem::replace;\n use std::num;\n use std::rc::Rc;\n-use std::str;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader, new_tt_reader_with_doc_flag};\n \n@@ -291,7 +290,8 @@ impl<'a> StringReader<'a> {\n                           s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n         let mut i = 0;\n         while i < s.len() {\n-            let str::CharRange { ch, next } = s.char_range_at(i);\n+            let ch = s.char_at(i);\n+            let next = i + ch.len_utf8();\n             if ch == '\\r' {\n                 if next < s.len() && s.char_at(next) == '\\n' {\n                     return translate_crlf_(self, start, s, errmsg, i).into_cow();\n@@ -309,7 +309,8 @@ impl<'a> StringReader<'a> {\n             let mut buf = String::with_capacity(s.len());\n             let mut j = 0;\n             while i < s.len() {\n-                let str::CharRange { ch, next } = s.char_range_at(i);\n+                let ch = s.char_at(i);\n+                let next = i + ch.len_utf8();\n                 if ch == '\\r' {\n                     if j < i { buf.push_str(&s[j..i]); }\n                     j = next;\n@@ -335,10 +336,11 @@ impl<'a> StringReader<'a> {\n         if current_byte_offset < self.source_text.len() {\n             assert!(self.curr.is_some());\n             let last_char = self.curr.unwrap();\n-            let next = self.source_text.char_range_at(current_byte_offset);\n-            let byte_offset_diff = next.next - current_byte_offset;\n+            let ch = self.source_text.char_at(current_byte_offset);\n+            let next = current_byte_offset + ch.len_utf8();\n+            let byte_offset_diff = next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n-            self.curr = Some(next.ch);\n+            self.curr = Some(ch);\n             self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n                 self.filemap.next_line(self.last_pos);\n@@ -370,7 +372,7 @@ impl<'a> StringReader<'a> {\n         let offset = self.byte_offset(self.pos).to_usize();\n         let s = &self.source_text[..];\n         if offset >= s.len() { return None }\n-        let str::CharRange { next, .. } = s.char_range_at(offset);\n+        let next = offset + s.char_at(offset).len_utf8();\n         if next < s.len() {\n             Some(s.char_at(next))\n         } else {"}, {"sha": "f517dca53cdd20366324ceae83dd523a55597220", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -60,6 +60,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n+#![feature(str_char)]\n #![feature(path_ext)]\n #![cfg_attr(windows, feature(libc))]\n "}, {"sha": "0fbc98ea73cfbc4898aa953267b50eb6590accf4", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -244,7 +244,7 @@ impl<'a> Iterator for Graphemes<'a> {\n         }\n \n         self.cat = if take_curr {\n-            idx = self.string.char_range_at(idx).next;\n+            idx = idx + len_utf8(self.string.char_at(idx));\n             None\n         } else {\n             Some(cat)\n@@ -256,6 +256,11 @@ impl<'a> Iterator for Graphemes<'a> {\n     }\n }\n \n+#[cfg(stage0)]\n+fn len_utf8(c: char) -> usize { UCharExt::len_utf8(c) }\n+#[cfg(not(stage0))]\n+fn len_utf8(c: char) -> usize { c.len_utf8() }\n+\n impl<'a> DoubleEndedIterator for Graphemes<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {"}, {"sha": "e1ae3ae464f98bd2c052a0e8a0fc2272a40438e2", "filename": "src/test/compile-fail/loop-labeled-break-value.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Ftest%2Fcompile-fail%2Floop-labeled-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Ftest%2Fcompile-fail%2Floop-labeled-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-labeled-break-value.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    loop {\n+        let _: i32 = loop { break }; //~ ERROR mismatched types\n+    }\n+    loop {\n+        let _: i32 = 'inner: loop { break 'inner }; //~ ERROR mismatched types\n+    }\n+    loop {\n+        let _: i32 = 'inner: loop { loop { break 'inner } }; //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "f71dc6869bee985905c04cd083fb8d430570be9d", "filename": "src/test/run-pass/loop-labeled-break-value.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94a95067e017252d4928a4292a6aeef66902e694/src%2Ftest%2Frun-pass%2Floop-labeled-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a95067e017252d4928a4292a6aeef66902e694/src%2Ftest%2Frun-pass%2Floop-labeled-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-labeled-break-value.rs?ref=94a95067e017252d4928a4292a6aeef66902e694", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    'outer: loop {\n+        let _: i32 = loop { break 'outer };\n+    }\n+    'outer: loop {\n+        let _: i32 = loop { loop { break 'outer } };\n+    }\n+}"}]}