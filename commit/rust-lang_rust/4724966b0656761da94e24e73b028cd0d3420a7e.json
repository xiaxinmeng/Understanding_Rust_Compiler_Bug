{"sha": "4724966b0656761da94e24e73b028cd0d3420a7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MjQ5NjZiMDY1Njc2MWRhOTRlMjRlNzNiMDI4Y2QwZDM0MjBhN2U=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-11T00:07:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:19:15Z"}, "message": "core::rt: Add uv timer bindings", "tree": {"sha": "237ffde01617b5c513df382cfb291ca6bac6595b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/237ffde01617b5c513df382cfb291ca6bac6595b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4724966b0656761da94e24e73b028cd0d3420a7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4724966b0656761da94e24e73b028cd0d3420a7e", "html_url": "https://github.com/rust-lang/rust/commit/4724966b0656761da94e24e73b028cd0d3420a7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4724966b0656761da94e24e73b028cd0d3420a7e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76e097761e0bb11ebe57bd18c13a0c645c655108", "url": "https://api.github.com/repos/rust-lang/rust/commits/76e097761e0bb11ebe57bd18c13a0c645c655108", "html_url": "https://github.com/rust-lang/rust/commit/76e097761e0bb11ebe57bd18c13a0c645c655108"}], "stats": {"total": 220, "additions": 207, "deletions": 13}, "files": [{"sha": "ffc19c5b5e4760b9751e0a2ead44a4ab6058a4c9", "filename": "src/libcore/rt/local_sched.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=4724966b0656761da94e24e73b028cd0d3420a7e", "patch": "@@ -97,7 +97,10 @@ pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n }\n \n fn tls_key() -> tls::Key {\n-    maybe_tls_key().get()\n+    match maybe_tls_key() {\n+        Some(key) => key,\n+        None => abort!(\"runtime tls key not initialized\")\n+    }\n }\n \n fn maybe_tls_key() -> Option<tls::Key> {"}, {"sha": "ee3c5ceffd236bda22e23d522d90b13a5ae4aa7d", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=4724966b0656761da94e24e73b028cd0d3420a7e", "patch": "@@ -59,6 +59,7 @@ use rt::io::IoError;\n pub use self::file::FsRequest;\n pub use self::net::{StreamWatcher, TcpWatcher};\n pub use self::idle::IdleWatcher;\n+pub use self::timer::TimerWatcher;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;\n@@ -69,6 +70,7 @@ pub mod uvll;\n pub mod file;\n pub mod net;\n pub mod idle;\n+pub mod timer;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -125,6 +127,7 @@ pub type NullCallback = ~fn();\n pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n+pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n \n \n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n@@ -134,7 +137,8 @@ struct WatcherData {\n     connect_cb: Option<ConnectionCallback>,\n     close_cb: Option<NullCallback>,\n     alloc_cb: Option<AllocCallback>,\n-    idle_cb: Option<IdleCallback>\n+    idle_cb: Option<IdleCallback>,\n+    timer_cb: Option<TimerCallback>\n }\n \n pub trait WatcherInterop {\n@@ -162,7 +166,8 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 connect_cb: None,\n                 close_cb: None,\n                 alloc_cb: None,\n-                idle_cb: None\n+                idle_cb: None,\n+                timer_cb: None\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);"}, {"sha": "1045a77da12fa146b4982c9acd3adec08d1b103e", "filename": "src/libcore/rt/uv/timer.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Ftimer.rs?ref=4724966b0656761da94e24e73b028cd0d3420a7e", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{c_void, c_int};\n+use option::Some;\n+use rt::uv::uvll;\n+use rt::uv::{Watcher, Loop, NativeHandle, TimerCallback, NullCallback};\n+use rt::uv::status_to_maybe_uv_error;\n+\n+pub struct TimerWatcher(*uvll::uv_timer_t);\n+impl Watcher for TimerWatcher { }\n+\n+impl TimerWatcher {\n+    pub fn new(loop_: &mut Loop) -> TimerWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(uvll::UV_TIMER);\n+            assert!(handle.is_not_null());\n+            assert!(0 == uvll::timer_init(loop_.native_handle(), handle));\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            return watcher;\n+        }\n+    }\n+\n+    pub fn start(&mut self, timeout: u64, repeat: u64, cb: TimerCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            data.timer_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::timer_start(self.native_handle(), timer_cb, timeout, repeat);\n+        }\n+\n+        extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.timer_cb.get_ref();\n+            let status = status_to_maybe_uv_error(handle, status);\n+            (*cb)(watcher, status);\n+        }\n+    }\n+\n+    pub fn stop(&mut self) {\n+        unsafe {\n+            uvll::timer_stop(self.native_handle());\n+        }\n+    }\n+\n+    pub fn close(self, cb: NullCallback) {\n+        let mut watcher = self;\n+        {\n+            let data = watcher.get_watcher_data();\n+            assert!(data.close_cb.is_none());\n+            data.close_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            uvll::close(watcher.native_handle(), close_cb);\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_timer_t) {\n+            let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n+            {\n+                let mut data = watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n+            }\n+            watcher.drop_watcher_data();\n+            unsafe {\n+                uvll::free_handle(handle as *c_void);\n+            }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_timer_t> for TimerWatcher {\n+    fn from_native_handle(handle: *uvll::uv_timer_t) -> TimerWatcher {\n+        TimerWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_idle_t {\n+        match self { &TimerWatcher(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rt::uv::Loop;\n+    use unstable::run_in_bare_thread;\n+\n+    #[test]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                timer.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn start_twice() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 0) |timer, status| {\n+                let mut timer = timer;\n+                assert!(status.is_none());\n+                unsafe { *count_ptr += 1 };\n+                do timer.start(10, 0) |timer, status| {\n+                    let mut timer = timer;\n+                    assert!(status.is_none());\n+                    unsafe { *count_ptr += 1 };\n+                    timer.close(||());\n+                }\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn repeat_stop() {\n+        do run_in_bare_thread {\n+            let mut count = 0;\n+            let count_ptr: *mut int = &mut count;\n+            let mut loop_ = Loop::new();\n+            let mut timer = TimerWatcher::new(&mut loop_);\n+            do timer.start(10, 20) |timer, status| {\n+                assert!(status.is_none());\n+                unsafe {\n+                    *count_ptr += 1;\n+\n+                    if *count_ptr == 10 {\n+\n+                        // Stop the timer and do something else\n+                        let mut timer = timer;\n+                        timer.stop();\n+                        // Freeze timer so it can be captured\n+                        let timer = timer;\n+\n+                        let mut loop_ = timer.event_loop();\n+                        let mut timer2 = TimerWatcher::new(&mut loop_);\n+                        do timer2.start(10, 0) |timer2, status| {\n+\n+                            unsafe { *count_ptr += 1; }\n+\n+                            let mut timer2 = timer2;\n+                            timer2.close(||());\n+\n+                            // Restart the original timer\n+                            let mut timer = timer;\n+                            do timer.start(10, 0) |timer, status| {\n+                                unsafe { *count_ptr += 1; }\n+                                let mut timer = timer;\n+                                timer.close(||());\n+                            }\n+                        }\n+                    }\n+                };\n+            }\n+            loop_.run();\n+            loop_.close();\n+            assert!(count == 12);\n+        }\n+    }\n+\n+}"}, {"sha": "94e6b82ab8fa970bcc8d4e4f47e58670859199f8", "filename": "src/libcore/rt/uv/uvll.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvll.rs?ref=4724966b0656761da94e24e73b028cd0d3420a7e", "patch": "@@ -268,9 +268,9 @@ pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_init(loop_ptr, timer_ptr);\n }\n-pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n-                          repeat: uint) -> c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as c_uint, repeat as c_uint);\n+pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: u64,\n+                          repeat: u64) -> c_int {\n+    return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n     return rust_uv_timer_stop(timer_ptr);\n@@ -431,8 +431,8 @@ extern {\n                           timer_handle: *uv_timer_t) -> c_int;\n     fn rust_uv_timer_start(timer_handle: *uv_timer_t,\n                            cb: *u8,\n-                           timeout: c_uint,\n-                           repeat: c_uint) -> c_int;\n+                           timeout: libc::uint64_t,\n+                           repeat: libc::uint64_t) -> c_int;\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n \n     fn rust_uv_malloc_buf_base_of(sug_size: size_t) -> *u8;"}, {"sha": "96ceb1002d8b6094b9a3ac8f1a7c23616cd29051", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=4724966b0656761da94e24e73b028cd0d3420a7e", "patch": "@@ -819,8 +819,8 @@ extern {\n     unsafe fn rust_uv_timer_start(\n         timer_handle: *uv_timer_t,\n         cb: *u8,\n-        timeout: libc::c_uint,\n-        repeat: libc::c_uint) -> libc::c_int;\n+        timeout: libc::uint64_t,\n+        repeat: libc::uint64_t) -> libc::c_int;\n     unsafe fn rust_uv_timer_stop(handle: *uv_timer_t) -> libc::c_int;\n \n     unsafe fn rust_uv_getaddrinfo(loop_ptr: *libc::c_void,\n@@ -1084,8 +1084,8 @@ pub unsafe fn timer_init(loop_ptr: *libc::c_void,\n }\n pub unsafe fn timer_start(timer_ptr: *uv_timer_t, cb: *u8, timeout: uint,\n                       repeat: uint) -> libc::c_int {\n-    return rust_uv_timer_start(timer_ptr, cb, timeout as libc::c_uint,\n-                                    repeat as libc::c_uint);\n+    return rust_uv_timer_start(timer_ptr, cb, timeout as libc::uint64_t,\n+                               repeat as libc::uint64_t);\n }\n pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> libc::c_int {\n     return rust_uv_timer_stop(timer_ptr);"}, {"sha": "fefcbbcacf7d499fdc0dc7ed53b350c096549969", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4724966b0656761da94e24e73b028cd0d3420a7e/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=4724966b0656761da94e24e73b028cd0d3420a7e", "patch": "@@ -229,7 +229,7 @@ rust_uv_timer_init(uv_loop_t* loop, uv_timer_t* timer) {\n \n extern \"C\" int\n rust_uv_timer_start(uv_timer_t* the_timer, uv_timer_cb cb,\n-                        uint32_t timeout, uint32_t repeat) {\n+                    int64_t timeout, int64_t repeat) {\n     return uv_timer_start(the_timer, cb, timeout, repeat);\n }\n "}]}