{"sha": "3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkODNmYzkxNGEwZjExNmFkMGU0NDEyZDVjY2MwYmUyNGIzYjdhZjI=", "commit": {"author": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2017-12-13T14:35:26Z"}, "committer": {"name": "leonardo.yvens", "email": "leoyvens@gmail.com", "date": "2018-01-27T17:42:54Z"}, "message": "Lazy numeric fallback.\n\nThis refactoring tries to make numeric fallback easier to reason about.\nInstead of applying all fallbacks at an arbitrary point in the middle\nof inference, we apply the fallback only when necessary and only for\nthe variable that requires it, which for numeric fallback turns out to\nbe just casts.\n\nThe only visible consequence seems to be some error messages where\ninstead of getting `i32` we get `{integer}` because we are less eager\nabout fallback.\n\nThe bigger goal is to make it easier to integrate user fallbacks into\ninference, if we ever figure that out.", "tree": {"sha": "89b6902ac09c683ebb0231b214eccd713032f6f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89b6902ac09c683ebb0231b214eccd713032f6f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "html_url": "https://github.com/rust-lang/rust/commit/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/comments", "author": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "leoyvens", "id": 9885558, "node_id": "MDQ6VXNlcjk4ODU1NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/9885558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leoyvens", "html_url": "https://github.com/leoyvens", "followers_url": "https://api.github.com/users/leoyvens/followers", "following_url": "https://api.github.com/users/leoyvens/following{/other_user}", "gists_url": "https://api.github.com/users/leoyvens/gists{/gist_id}", "starred_url": "https://api.github.com/users/leoyvens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leoyvens/subscriptions", "organizations_url": "https://api.github.com/users/leoyvens/orgs", "repos_url": "https://api.github.com/users/leoyvens/repos", "events_url": "https://api.github.com/users/leoyvens/events{/privacy}", "received_events_url": "https://api.github.com/users/leoyvens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c01bfbd02b57a1aa9d8a39cd907f799d23c2a230", "url": "https://api.github.com/repos/rust-lang/rust/commits/c01bfbd02b57a1aa9d8a39cd907f799d23c2a230", "html_url": "https://github.com/rust-lang/rust/commit/c01bfbd02b57a1aa9d8a39cd907f799d23c2a230"}], "stats": {"total": 139, "additions": 87, "deletions": 52}, "files": [{"sha": "d38ceb619e3cc7d09396cd8ecf9b227d8ed67421", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "patch": "@@ -1290,6 +1290,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn is_ty_infer(&self) -> bool {\n+        match self.sty {\n+            TyInfer(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_phantom_data(&self) -> bool {\n         if let TyAdt(def, _) = self.sty {\n             def.is_phantom_data()"}, {"sha": "bc157d6feeafb57a110d6d5240061905e9460fb2", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "patch": "@@ -392,8 +392,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     pub fn check(mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n-        self.expr_ty = fcx.structurally_resolved_type(self.span, self.expr_ty);\n-        self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n+        self.expr_ty = fcx.resolved_type(self.span, self.expr_ty);\n+        self.cast_ty = fcx.resolved_type(self.span, self.cast_ty);\n \n         debug!(\"check_cast({}, {:?} as {:?})\",\n                self.expr.id,"}, {"sha": "aff96e39cfc729ce3809b9d75d60e54055b5285a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 68, "deletions": 42, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "patch": "@@ -858,9 +858,8 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             fcx\n         };\n \n-        fcx.select_all_obligations_and_apply_defaults();\n-        fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n+        fcx.closure_analyze(body);\n         fcx.check_casts();\n         fcx.resolve_generator_interiors(def_id);\n         fcx.select_all_obligations_or_error();\n@@ -2129,13 +2128,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Apply \"fallbacks\" to some types\n-    /// unconstrained types get replaced with ! or  () (depending on whether\n+    /// unconstrained types get replaced with ! or () (depending on whether\n     /// feature(never_type) is enabled), unconstrained ints with i32, and\n     /// unconstrained floats with f64.\n     fn default_type_parameters(&self) {\n-        use rustc::ty::error::UnconstrainedNumeric::Neither;\n-        use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n-\n         // Defaulting inference variables becomes very dubious if we have\n         // encountered type-checking errors. Therefore, if we think we saw\n         // some errors in this function, just resolve all uninstanted type\n@@ -2152,34 +2148,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         for ty in &self.unsolved_variables() {\n             let resolved = self.resolve_type_vars_if_possible(ty);\n-            if self.type_var_diverges(resolved) {\n-                debug!(\"default_type_parameters: defaulting `{:?}` to `!` because it diverges\",\n-                       resolved);\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n-                                   self.tcx.mk_diverging_default());\n-            } else {\n-                match self.type_is_unconstrained_numeric(resolved) {\n-                    UnconstrainedInt => {\n-                        debug!(\"default_type_parameters: defaulting `{:?}` to `i32`\",\n-                               resolved);\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.i32)\n-                    },\n-                    UnconstrainedFloat => {\n-                        debug!(\"default_type_parameters: defaulting `{:?}` to `f32`\",\n-                               resolved);\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.types.f64)\n-                    }\n-                    Neither => { }\n-                }\n+            if resolved.is_ty_infer() {\n+                self.apply_diverging_fallback_to_type(ty);\n+                self.apply_numeric_fallback_to_type(ty);\n             }\n         }\n     }\n \n-    // Implements type inference fallback algorithm\n-    fn select_all_obligations_and_apply_defaults(&self) {\n-        self.select_obligations_where_possible();\n-        self.default_type_parameters();\n-        self.select_obligations_where_possible();\n+    fn apply_diverging_fallback_to_type(&self, ty: Ty<'tcx>) {\n+        assert!(ty.is_ty_infer());\n+        if self.type_var_diverges(ty) {\n+            debug!(\"default_type_parameters: defaulting `{:?}` to `!` because it diverges\", ty);\n+            self.demand_eqtype(syntax_pos::DUMMY_SP, ty, self.tcx.mk_diverging_default());\n+        }\n+    }\n+\n+    fn apply_numeric_fallback_to_type(&self, ty: Ty<'tcx>) {\n+        use rustc::ty::error::UnconstrainedNumeric::Neither;\n+        use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n+\n+        assert!(ty.is_ty_infer());\n+        let fallback = match self.type_is_unconstrained_numeric(ty) {\n+            UnconstrainedInt => self.tcx.types.i32,\n+            UnconstrainedFloat => self.tcx.types.f64,\n+            Neither => return,\n+        };\n+        debug!(\"default_type_parameters: defaulting `{:?}` to `{:?}`\", ty, fallback);\n+        self.demand_eqtype(syntax_pos::DUMMY_SP, ty, fallback);\n     }\n \n     fn select_all_obligations_or_error(&self) {\n@@ -2189,7 +2184,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // resolutions are handled by now.\n         assert!(self.deferred_call_resolutions.borrow().is_empty());\n \n-        self.select_all_obligations_and_apply_defaults();\n+        self.select_obligations_where_possible();\n+        self.default_type_parameters();\n \n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n \n@@ -4954,21 +4950,51 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    // Resolves `typ` by a single level if `typ` is a type variable. If no\n-    // resolution is possible, then an error is reported.\n+    // Resolves `typ` by a single level if `typ` is a type variable.\n+    // If no resolution is possible, then an error is reported.\n+    // Numeric inference variables may be left unresolved.\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let mut ty = self.resolve_type_vars_with_obligations(ty);\n-        if ty.is_ty_var() {\n-            // If not, error.\n-            if !self.is_tainted_by_errors() {\n-                type_error_struct!(self.tcx.sess, sp, ty, E0619,\n-                                    \"the type of this value must be known in this context\")\n-                .emit();\n+        if !ty.is_ty_var() {\n+            ty\n+        } else {\n+            // Try divering fallback.\n+            self.apply_diverging_fallback_to_type(ty);\n+            ty = self.resolve_type_vars_with_obligations(ty);\n+            if !ty.is_ty_var() {\n+                ty\n+            } else { // Fallback failed, error.\n+                self.must_be_known_in_context(sp, ty)\n             }\n-            self.demand_suptype(sp, self.tcx.types.err, ty);\n-            ty = self.tcx.types.err;\n         }\n-        ty\n+    }\n+\n+    // Same as `structurally_resolved_type` but also resolves numeric vars, with fallback.\n+    pub fn resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let mut ty = self.resolve_type_vars_with_obligations(ty);\n+        if !ty.is_ty_infer() {\n+            return ty;\n+        } else {\n+            // Try diverging or numeric fallback.\n+            self.apply_diverging_fallback_to_type(ty);\n+            self.apply_numeric_fallback_to_type(ty);\n+            ty = self.resolve_type_vars_with_obligations(ty);\n+            if !ty.is_ty_infer() {\n+                ty\n+            } else { // Fallback failed, error.\n+                self.must_be_known_in_context(sp, ty)\n+            }\n+        }\n+    }\n+\n+    fn must_be_known_in_context(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if !self.is_tainted_by_errors() {\n+            type_error_struct!(self.tcx.sess, sp, ty, E0619,\n+                                \"the type of this value must be known in this context\")\n+            .emit();\n+        }\n+        self.demand_suptype(sp, self.tcx.types.err, ty);\n+        self.tcx.types.err\n     }\n \n     fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,"}, {"sha": "0385e3b8365d168b2dd6ebd6d65020bf61aa061c", "filename": "src/test/compile-fail/derived-errors/issue-31997.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs?ref=3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "patch": "@@ -20,7 +20,9 @@ fn closure<F, T>(x: F) -> Result<T, ()>\n }\n \n fn foo() -> Result<(), ()> {\n-    try!(closure(|| bar(0 as *mut _))); //~ ERROR cannot find function `bar` in this scope\n+    try!(closure(|| bar(0 as *mut _)));\n+    //~^ ERROR cannot find function `bar` in this scope\n+    //~^^ ERROR cannot cast to a pointer of an unknown kind\n     Ok(())\n }\n "}, {"sha": "dca9ab1b5415c900fa1282762bab36275a1af479", "filename": "src/test/ui/interior-mutability/interior-mutability.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Ftest%2Fui%2Finterior-mutability%2Finterior-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Ftest%2Fui%2Finterior-mutability%2Finterior-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finterior-mutability%2Finterior-mutability.stderr?ref=3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "patch": "@@ -1,13 +1,13 @@\n-error[E0277]: the trait bound `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied in `std::cell::Cell<i32>`\n+error[E0277]: the trait bound `std::cell::UnsafeCell<{integer}>: std::panic::RefUnwindSafe` is not satisfied in `std::cell::Cell<{integer}>`\n   --> $DIR/interior-mutability.rs:15:5\n    |\n 15 |     catch_unwind(|| { x.set(23); }); //~ ERROR the trait bound\n-   |     ^^^^^^^^^^^^ the type std::cell::UnsafeCell<i32> may contain interior mutability and a reference may not be safely transferrable across a catch_unwind boundary\n+   |     ^^^^^^^^^^^^ the type std::cell::UnsafeCell<{integer}> may contain interior mutability and a reference may not be safely transferrable across a catch_unwind boundary\n    |\n-   = help: within `std::cell::Cell<i32>`, the trait `std::panic::RefUnwindSafe` is not implemented for `std::cell::UnsafeCell<i32>`\n-   = note: required because it appears within the type `std::cell::Cell<i32>`\n-   = note: required because of the requirements on the impl of `std::panic::UnwindSafe` for `&std::cell::Cell<i32>`\n-   = note: required because it appears within the type `[closure@$DIR/interior-mutability.rs:15:18: 15:35 x:&std::cell::Cell<i32>]`\n+   = help: within `std::cell::Cell<{integer}>`, the trait `std::panic::RefUnwindSafe` is not implemented for `std::cell::UnsafeCell<{integer}>`\n+   = note: required because it appears within the type `std::cell::Cell<{integer}>`\n+   = note: required because of the requirements on the impl of `std::panic::UnwindSafe` for `&std::cell::Cell<{integer}>`\n+   = note: required because it appears within the type `[closure@$DIR/interior-mutability.rs:15:18: 15:35 x:&std::cell::Cell<{integer}>]`\n    = note: required by `std::panic::catch_unwind`\n \n error: aborting due to previous error"}, {"sha": "1b056486ad95b9b0fde57080b07d1b854b73894e", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=3d83fc914a0f116ad0e4412d5ccc0be24b3b7af2", "patch": "@@ -7,7 +7,7 @@ error[E0308]: mismatched types\n 37 |     write!(hello);\n    |     -------------- in this macro invocation\n \n-error[E0605]: non-primitive cast: `{integer}` as `()`\n+error[E0605]: non-primitive cast: `i32` as `()`\n   --> $DIR/issue-26480.rs:32:19\n    |\n 32 |     ($x:expr) => ($x as ()) //~ ERROR non-primitive cast"}]}