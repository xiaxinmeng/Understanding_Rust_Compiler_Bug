{"sha": "0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNDc5MWU2MGJiNDRhZTdkY2YzYjRiYjMxMmNjMjBiOTkxOTNjNGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-21T23:26:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "make NLL handle `IfEq` bounds by using SCC normalization", "tree": {"sha": "176a365738028b1089019b2af49cac5e9afe8398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/176a365738028b1089019b2af49cac5e9afe8398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "html_url": "https://github.com/rust-lang/rust/commit/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449", "html_url": "https://github.com/rust-lang/rust/commit/0f5dae0322ac47ea457aafadc11fc0eb6c8f2449"}], "stats": {"total": 639, "additions": 630, "deletions": 9}, "files": [{"sha": "a59bf9d530c4d0919001c3c81f23a33c9c0bbb40", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -535,6 +535,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n         self.raw.len()\n     }\n \n+    /// Gives the next index that will be assigned when `push` is\n+    /// called.\n+    #[inline]\n+    pub fn next_index(&self) -> I {\n+        I::new(self.len())\n+    }\n+\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n         self.raw.is_empty()"}, {"sha": "2dbb5cd9deb144437a38fb9d9cbd9e236489f217", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 113, "deletions": 9, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -69,6 +69,15 @@ pub struct RegionInferenceContext<'tcx> {\n     /// visible from this index.\n     scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n \n+    /// Contains a \"representative\" from each SCC. This will be the\n+    /// minimal RegionVid belonging to that universe. It is used as a\n+    /// kind of hacky way to manage checking outlives relationships,\n+    /// since we can 'canonicalize' each region to the representative\n+    /// of its SCC and be sure that -- if they have the same repr --\n+    /// they *must* be equal (though not having the same repr does not\n+    /// mean they are unequal).\n+    scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n+\n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n@@ -208,13 +217,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let scc_universes = Self::compute_scc_universes(&constraint_sccs, &definitions);\n \n+        let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n+\n         let mut result = Self {\n             definitions,\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n             scc_universes,\n+            scc_representatives,\n             scc_values,\n             type_tests,\n             universal_regions,\n@@ -251,6 +263,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         scc_universes\n     }\n \n+    /// For each SCC, we compute a unique `RegionVid` (in fact, the\n+    /// minimal one that belongs to the SCC). See\n+    /// `scc_representatives` field of `RegionInferenceContext` for\n+    /// more details.\n+    fn compute_scc_representatives(\n+        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    ) -> IndexVec<ConstraintSccIndex, ty::RegionVid> {\n+        let num_sccs = constraints_scc.num_sccs();\n+        let next_region_vid = definitions.next_index();\n+        let mut scc_representatives = IndexVec::from_elem_n(next_region_vid, num_sccs);\n+\n+        for region_vid in definitions.indices() {\n+            let scc = constraints_scc.scc(region_vid);\n+            let prev_min = scc_representatives[scc];\n+            scc_representatives[scc] = region_vid.min(prev_min);\n+        }\n+\n+        scc_representatives\n+    }\n+\n     /// Initializes the region variables for each universally\n     /// quantified region (lifetime parameter). The first N variables\n     /// always correspond to the regions appearing in the function\n@@ -545,7 +578,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_verify_bound(mir, type_test.lower_bound, &type_test.verify_bound) {\n+            let generic_ty = type_test.generic_kind.to_ty(tcx);\n+            if self.eval_verify_bound(\n+                tcx,\n+                mir,\n+                generic_ty,\n+                type_test.lower_bound,\n+                &type_test.verify_bound,\n+            ) {\n                 continue;\n             }\n \n@@ -679,7 +719,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_verify_bound(mir, ur, &type_test.verify_bound) {\n+            if self.eval_verify_bound(tcx, mir, generic_ty, ur, &type_test.verify_bound) {\n                 continue;\n             }\n \n@@ -853,7 +893,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`, and returns true or false.\n     fn eval_verify_bound(\n         &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n         verify_bound: &VerifyBound<'tcx>,\n     ) -> bool {\n@@ -863,23 +905,85 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         match verify_bound {\n-            VerifyBound::IfEq(..) => false, // FIXME\n+            VerifyBound::IfEq(test_ty, verify_bound1) => {\n+                self.eval_if_eq(tcx, mir, generic_ty, lower_bound, test_ty, verify_bound1)\n+            }\n \n             VerifyBound::OutlivedBy(r) => {\n                 let r_vid = self.to_region_vid(r);\n                 self.eval_outlives(mir, r_vid, lower_bound)\n             }\n \n-            VerifyBound::AnyBound(verify_bounds) => verify_bounds\n-                .iter()\n-                .any(|verify_bound| self.eval_verify_bound(mir, lower_bound, verify_bound)),\n+            VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n+                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+            }),\n \n-            VerifyBound::AllBounds(verify_bounds) => verify_bounds\n-                .iter()\n-                .all(|verify_bound| self.eval_verify_bound(mir, lower_bound, verify_bound)),\n+            VerifyBound::AllBounds(verify_bounds) => verify_bounds.iter().all(|verify_bound| {\n+                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+            }),\n         }\n     }\n \n+    fn eval_if_eq(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        generic_ty: Ty<'tcx>,\n+        lower_bound: RegionVid,\n+        test_ty: Ty<'tcx>,\n+        verify_bound: &VerifyBound<'tcx>,\n+    ) -> bool {\n+        let generic_ty_normalized = self.normalize_to_scc_representatives(tcx, generic_ty);\n+        let test_ty_normalized = self.normalize_to_scc_representatives(tcx, test_ty);\n+        if generic_ty_normalized == test_ty_normalized {\n+            self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// This is a conservative normalization procedure. It takes every\n+    /// free region in `value` and replaces it with the\n+    /// \"representative\" of its SCC (see `scc_representatives` field).\n+    /// We are guaranteed that if two values normalize to the same\n+    /// thing, then they are equal; this is a conservative check in\n+    /// that they could still be equal even if they normalize to\n+    /// different results. (For example, there might be two regions\n+    /// with the same value that are not in the same SCC).\n+    ///\n+    /// NB. This is not an ideal approach and I would like to revisit\n+    /// it. However, it works pretty well in practice. In particular,\n+    /// this is needed to deal with projection outlives bounds like\n+    ///\n+    ///     <T as Foo<'0>>::Item: '1\n+    ///\n+    /// In particular, this routine winds up being important when\n+    /// there are bounds like `where <T as Foo<'a>>::Item: 'b` in the\n+    /// environment.  In this case, if we can show that `'0 == 'a`,\n+    /// and that `'b: '1`, then we know that the clause is\n+    /// satisfied. In such cases, particularly due to limitations of\n+    /// the trait solver =), we usually wind up with a where-clause like\n+    /// `T: Foo<'a>` in scope, which thus forces `'0 == 'a` to be added as\n+    /// a constraint, and thus ensures that they are in the same SCC.\n+    ///\n+    /// So why can't we do a more correct routine? Well, we could\n+    /// *almost* use the `relate_tys` code, but the way it is\n+    /// currently setup it creates inference variables to deal with\n+    /// higher-ranked things and so forth, and right now the inference\n+    /// context is not permitted to make more inference variables. So\n+    /// we use this kind of hacky solution.\n+    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(&value, &mut false, |r, _db| {\n+            let vid = self.to_region_vid(r);\n+            let scc = self.constraint_sccs.scc(vid);\n+            let repr = self.scc_representatives[scc];\n+            tcx.mk_region(ty::ReVar(repr))\n+        })\n+    }\n+\n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,"}, {"sha": "593cdfdbf711a5a2bb1345216efd20816fa33512", "filename": "src/test/ui/nll/ty-outlives/issue-53789-1.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-1.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,91 @@\n+// Regression test for #53789.\n+//\n+// compile-pass\n+\n+#![feature(nll)]\n+#![allow(unused_variables)]\n+\n+use std::collections::BTreeMap;\n+\n+trait ValueTree {\n+    type Value;\n+}\n+\n+trait Strategy {\n+    type Value: ValueTree;\n+}\n+\n+type StrategyFor<A> = StrategyType<'static, A>;\n+type StrategyType<'a, A> = <A as Arbitrary<'a>>::Strategy;\n+\n+impl<K: ValueTree, V: ValueTree> Strategy for (K, V) {\n+    type Value = TupleValueTree<(K, V)>;\n+}\n+\n+impl<K: ValueTree, V: ValueTree> ValueTree for TupleValueTree<(K, V)> {\n+    type Value = BTreeMapValueTree<K, V>;\n+}\n+\n+struct TupleValueTree<T> {\n+    tree: T,\n+}\n+\n+struct BTreeMapStrategy<K, V>(std::marker::PhantomData<(K, V)>)\n+where\n+    K: Strategy,\n+    V: Strategy;\n+\n+struct BTreeMapValueTree<K, V>(std::marker::PhantomData<(K, V)>)\n+where\n+    K: ValueTree,\n+    V: ValueTree;\n+\n+impl<K, V> Strategy for BTreeMapStrategy<K, V>\n+where\n+    K: Strategy,\n+    V: Strategy,\n+{\n+    type Value = BTreeMapValueTree<K::Value, V::Value>;\n+}\n+\n+impl<K, V> ValueTree for BTreeMapValueTree<K, V>\n+where\n+    K: ValueTree,\n+    V: ValueTree,\n+{\n+    type Value = BTreeMap<K::Value, V::Value>;\n+}\n+\n+trait Arbitrary<'a>: Sized {\n+    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy;\n+    type Parameters;\n+    type Strategy: Strategy<Value = Self::ValueTree>;\n+    type ValueTree: ValueTree<Value = Self>;\n+}\n+\n+impl<'a, A, B> Arbitrary<'a> for BTreeMap<A, B>\n+where\n+    A: Arbitrary<'static>,\n+    B: Arbitrary<'static>,\n+    StrategyFor<A>: 'static,\n+    StrategyFor<B>: 'static,\n+{\n+    type ValueTree = <Self::Strategy as Strategy>::Value;\n+    type Parameters = (A::Parameters, B::Parameters);\n+    type Strategy = BTreeMapStrategy<A::Strategy, B::Strategy>;\n+    fn arbitrary_with(args: Self::Parameters) -> BTreeMapStrategy<A::Strategy, B::Strategy> {\n+        let (a, b) = args;\n+        btree_map(any_with::<A>(a), any_with::<B>(b))\n+    }\n+}\n+\n+fn btree_map<K: Strategy + 'static, V: Strategy>(key: K, value: V) -> BTreeMapStrategy<K, V> {\n+    unimplemented!()\n+}\n+\n+fn any_with<'a, A: Arbitrary<'a>>(args: A::Parameters) -> StrategyType<'a, A> {\n+    unimplemented!()\n+}\n+\n+fn main() { }\n+"}, {"sha": "62e2833aa1b1ab7e58aea24597e0d1b504d3e067", "filename": "src/test/ui/nll/ty-outlives/issue-53789-2.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,251 @@\n+// Regression test for #53789.\n+//\n+// compile-pass\n+\n+#![feature(nll)]\n+#![allow(unused_variables)]\n+\n+use std::collections::BTreeMap;\n+use std::ops::Range;\n+use std::cmp::Ord;\n+\n+macro_rules! valuetree {\n+    () => {\n+        type ValueTree =\n+            <Self::Strategy as $crate::Strategy>::Value;\n+    };\n+}\n+\n+macro_rules! product_unpack {\n+    ($factor: pat) => {\n+        ($factor,)\n+    };\n+    ($($factor: pat),*) => {\n+        ( $( $factor ),* )\n+    };\n+    ($($factor: pat),*,) => {\n+        ( $( $factor ),* )\n+    };\n+}\n+\n+macro_rules! product_type {\n+    ($factor: ty) => {\n+        ($factor,)\n+    };\n+    ($($factor: ty),*) => {\n+        ( $( $factor, )* )\n+    };\n+    ($($factor: ty),*,) => {\n+        ( $( $factor, )* )\n+    };\n+}\n+\n+macro_rules! default {\n+    ($type: ty, $val: expr) => {\n+        impl Default for $type {\n+            fn default() -> Self { $val.into() }\n+        }\n+    };\n+}\n+\n+// Pervasive internal sugar\n+macro_rules! mapfn {\n+    ($(#[$meta:meta])* [$($vis:tt)*]\n+     fn $name:ident[$($gen:tt)*]($parm:ident: $input:ty) -> $output:ty {\n+         $($body:tt)*\n+     }) => {\n+        $(#[$meta])*\n+            #[derive(Clone, Copy)]\n+        $($vis)* struct $name;\n+        impl $($gen)* statics::MapFn<$input> for $name {\n+            type Output = $output;\n+        }\n+    }\n+}\n+\n+macro_rules! opaque_strategy_wrapper {\n+    ($(#[$smeta:meta])* pub struct $stratname:ident\n+     [$($sgen:tt)*][$($swhere:tt)*]\n+     ($innerstrat:ty) -> $stratvtty:ty;\n+\n+     $(#[$vmeta:meta])* pub struct $vtname:ident\n+     [$($vgen:tt)*][$($vwhere:tt)*]\n+     ($innervt:ty) -> $actualty:ty;\n+    ) => {\n+        $(#[$smeta])* struct $stratname $($sgen)* (std::marker::PhantomData<(K, V)>)\n+            $($swhere)*;\n+\n+        $(#[$vmeta])* struct $vtname $($vgen)* ($innervt) $($vwhere)*;\n+\n+        impl $($sgen)* Strategy for $stratname $($sgen)* $($swhere)* {\n+            type Value = $stratvtty;\n+        }\n+\n+        impl $($vgen)* ValueTree for $vtname $($vgen)* $($vwhere)* {\n+            type Value = $actualty;\n+        }\n+    }\n+}\n+\n+trait ValueTree {\n+    type Value;\n+}\n+\n+trait Strategy {\n+    type Value : ValueTree;\n+}\n+\n+#[derive(Clone)]\n+struct VecStrategy<T : Strategy> {\n+    element: T,\n+    size: Range<usize>,\n+}\n+\n+fn vec<T : Strategy>(element: T, size: Range<usize>)\n+                     -> VecStrategy<T> {\n+    VecStrategy {\n+        element: element,\n+        size: size,\n+    }\n+}\n+\n+type ValueFor<S> = <<S as Strategy>::Value as ValueTree>::Value;\n+\n+trait Arbitrary<'a>: Sized {\n+    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy;\n+\n+    type Parameters: Default;\n+    type Strategy: Strategy<Value = Self::ValueTree>;\n+    type ValueTree: ValueTree<Value = Self>;\n+}\n+\n+type StrategyFor<A> = StrategyType<'static, A>;\n+type StrategyType<'a, A> = <A as Arbitrary<'a>>::Strategy;\n+\n+//#[derive(Clone, PartialEq, Eq, Hash, Debug, From, Into)]\n+struct SizeBounds(Range<usize>);\n+default!(SizeBounds, 0..100);\n+\n+\n+impl From<Range<usize>> for SizeBounds {\n+    fn from(high: Range<usize>) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl From<SizeBounds> for Range<usize> {\n+    fn from(high: SizeBounds) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+\n+fn any_with<'a, A: Arbitrary<'a>>(args: A::Parameters)\n+                                  -> StrategyType<'a, A> {\n+    unimplemented!()\n+}\n+\n+impl<K: ValueTree, V: ValueTree> Strategy for (K, V) where\n+    <K as ValueTree>::Value: Ord {\n+    type Value = TupleValueTree<(K, V)>;\n+}\n+\n+impl<K: ValueTree, V: ValueTree> ValueTree for TupleValueTree<(K, V)> where\n+    <K as ValueTree>::Value: Ord {\n+    type Value = BTreeMapValueTree<K, V>;\n+}\n+\n+#[derive(Clone)]\n+struct VecValueTree<T : ValueTree> {\n+    elements: Vec<T>,\n+}\n+\n+#[derive(Clone, Copy)]\n+struct TupleValueTree<T> {\n+    tree: T,\n+}\n+\n+opaque_strategy_wrapper! {\n+    #[derive(Clone)]\n+    pub struct BTreeMapStrategy[<K, V>]\n+        [where K : Strategy, V : Strategy, ValueFor<K> : Ord](\n+            statics::Filter<statics::Map<VecStrategy<(K,V)>,\n+            VecToBTreeMap>, MinSize>)\n+        -> BTreeMapValueTree<K::Value, V::Value>;\n+\n+    #[derive(Clone)]\n+    pub struct BTreeMapValueTree[<K, V>]\n+        [where K : ValueTree, V : ValueTree, K::Value : Ord](\n+            statics::Filter<statics::Map<VecValueTree<TupleValueTree<(K, V)>>,\n+            VecToBTreeMap>, MinSize>)\n+        -> BTreeMap<K::Value, V::Value>;\n+}\n+\n+type RangedParams2<A, B> = product_type![SizeBounds, A, B];\n+\n+impl<'a, A, B> Arbitrary<'a> for BTreeMap<A, B>\n+where\n+    A: Arbitrary<'static> + Ord,\n+    B: Arbitrary<'static>,\n+StrategyFor<A>: 'static,\n+StrategyFor<B>: 'static,\n+{\n+    valuetree!();\n+    type Parameters = RangedParams2<A::Parameters, B::Parameters>;\n+    type Strategy = BTreeMapStrategy<A::Strategy, B::Strategy>;\n+    fn arbitrary_with(args: Self::Parameters) -> Self::Strategy {\n+        let product_unpack![range, a, b] = args;\n+        btree_map(any_with::<A>(a), any_with::<B>(b), range.into())\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+struct MinSize(usize);\n+\n+mapfn! {\n+    [] fn VecToBTreeMap[<K : Ord, V>]\n+        (vec: Vec<(K, V)>) -> BTreeMap<K, V>\n+    {\n+        vec.into_iter().collect()\n+    }\n+}\n+\n+fn btree_map<K : Strategy + 'static, V : Strategy + 'static>\n+    (key: K, value: V, size: Range<usize>)\n+     -> BTreeMapStrategy<K, V>\n+where ValueFor<K> : Ord {\n+    unimplemented!()\n+}\n+\n+mod statics {\n+    pub(super) trait MapFn<T> {\n+        type Output;\n+    }\n+\n+    #[derive(Clone)]\n+    pub struct Filter<S, F> {\n+        source: S,\n+        fun: F,\n+    }\n+\n+    impl<S, F> Filter<S, F> {\n+        pub fn new(source: S, whence: String, filter: F) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+\n+    #[derive(Clone)]\n+    pub struct Map<S, F> {\n+        source: S,\n+        fun: F,\n+    }\n+\n+    impl<S, F> Map<S, F> {\n+        pub fn new(source: S, fun: F) -> Self {\n+            unimplemented!()\n+        }\n+    }\n+}\n+\n+fn main() { }\n+"}, {"sha": "680e26de65bc08c08eb2c46d660eb0b9fc09d187", "filename": "src/test/ui/nll/ty-outlives/projection-body.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-body.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,25 @@\n+// Test that when we infer the lifetime to a subset of the fn body, it\n+// works out.\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo1<T>()\n+where\n+    for<'x> T: MyTrait<'x>,\n+{\n+    // Here the region `'c` in `<T as MyTrait<'c>>::Output` will be\n+    // inferred to a subset of the fn body.\n+    let x = bar::<T::Output>();\n+    drop(x);\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "9c2cbfd4a4530ead2f45a365afa8127891e8a9d6", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-bound.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,36 @@\n+#![feature(nll)]\n+\n+// Test that we are able to establish that `<T as\n+// MyTrait<'a>>::Output` outlives `'b` here. We need to prove however\n+// that `<T as MyTrait<'a>>::Output` outlives `'a`, so we also have to\n+// prove that `'b: 'a`.\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo1<'a, 'b, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+    <T as MyTrait<'a>>::Output: 'b,\n+{\n+    bar::<T::Output>() //~ ERROR may not live long enough\n+}\n+\n+fn foo2<'a, 'b, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+    <T as MyTrait<'a>>::Output: 'b,\n+    'b: 'a,\n+{\n+    bar::<T::Output>() // OK\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "07cc37a8b290a435eb2e7ff88b13c9b69f25af5d", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-lifetime.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,24 @@\n+// Test that if we need to prove that `<T as MyTrait<'a>>::Output:\n+// 'a`, but we only know that `<T as MyTrait<'b>>::Output: 'a`, that\n+// doesn't suffice.\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo1<'a, 'b, T>() -> &'a ()\n+where\n+    for<'x> T: MyTrait<'x>,\n+    <T as MyTrait<'b>>::Output: 'a,\n+{\n+    bar::<<T as MyTrait<'a>>::Output>() //~ ERROR the associated type `<T as MyTrait<'a>>::Output` may not live long enough\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "c6935badf54b289dd8f66764568f260b9a17b505", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,30 @@\n+#![feature(nll)]\n+\n+// Test that when we have a `<T as MyTrait<'a>>::Output: 'a`\n+// relationship in the environment we take advantage of it.  In this\n+// case, that means we **don't** have to prove that `T: 'a`.\n+//\n+// Regression test for #53121.\n+//\n+// compile-pass\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo<'a, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+    <T as MyTrait<'a>>::Output: 'a,\n+{\n+    bar::<T::Output>()\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "f0f72f5d27f7675d22555be033b3926cd869121e", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-none.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-none.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,26 @@\n+#![feature(nll)]\n+\n+// Test that we are NOT able to establish that `<T as\n+// MyTrait<'a>>::Output: 'a` outlives `'a` here -- we have only one\n+// recourse, which is to prove that `T: 'a` and `'a: 'a`, but we don't\n+// know that `T: 'a`.\n+\n+trait MyTrait<'a> {\n+    type Output;\n+}\n+\n+fn foo<'a, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+{\n+    bar::<T::Output>() //~ ERROR the parameter type `T` may not live long enough\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}, {"sha": "7c7d64a8cb4d3d379b812c5d107c05ac60fb1148", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-trait.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-trait.rs?ref=0b4791e60bb44ae7dcf3b4bb312cc20b99193c4e", "patch": "@@ -0,0 +1,27 @@\n+#![feature(nll)]\n+\n+// Test that we are able to establish that `<T as\n+// MyTrait<'a>>::Output: 'a` outlives `'a` (because the trait says\n+// so).\n+//\n+// compile-pass\n+\n+trait MyTrait<'a> {\n+    type Output: 'a;\n+}\n+\n+fn foo<'a, T>() -> &'a ()\n+where\n+    T: MyTrait<'a>,\n+{\n+    bar::<T::Output>()\n+}\n+\n+fn bar<'a, T>() -> &'a ()\n+where\n+    T: 'a,\n+{\n+    &()\n+}\n+\n+fn main() {}"}]}