{"sha": "857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1N2MzNWRkYjAzZWU1ZGI5N2JiYjQ3NDNkZmVlZGViM2RmMzUwZWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-25T07:08:21Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-25T07:08:21Z"}, "message": "refactor import resolution\n\nextract path resolution\nuse enums instead of bools", "tree": {"sha": "f142de082849544273bc7b65c823e45a095b30b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f142de082849544273bc7b65c823e45a095b30b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "html_url": "https://github.com/rust-lang/rust/commit/857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d4b421aad0bbcd26d88e65b28dbbb4efb51d155", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d4b421aad0bbcd26d88e65b28dbbb4efb51d155", "html_url": "https://github.com/rust-lang/rust/commit/1d4b421aad0bbcd26d88e65b28dbbb4efb51d155"}], "stats": {"total": 245, "additions": 146, "deletions": 99}, "files": [{"sha": "338ed0516a8b606b58224dd2250f19e2fda21d76", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "patch": "@@ -1,3 +1,4 @@\n-use test_utils::mark;\n-\n-mark!(name_res_works_for_broken_modules);\n+test_utils::marks!(\n+    name_res_works_for_broken_modules\n+    item_map_enum_importing\n+);"}, {"sha": "8c8494b4603dbef8da46947c137c8082ae535b43", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 117, "deletions": 94, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "patch": "@@ -19,6 +19,7 @@ pub(crate) mod lower;\n use std::sync::Arc;\n \n use ra_db::CrateId;\n+use test_utils::tested_by;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n@@ -273,7 +274,7 @@ where\n                 // already done\n                 continue;\n             }\n-            if self.resolve_import(module_id, import_id, import_data) {\n+            if self.resolve_import(module_id, import_id, import_data) == ReachedFixedPoint::Yes {\n                 log::debug!(\"import {:?} resolved (or definite error)\", import_id);\n                 self.processed_imports.insert((module_id, import_id));\n             }\n@@ -285,116 +286,138 @@ where\n         module_id: ModuleId,\n         import_id: ImportId,\n         import: &ImportData,\n-    ) -> bool {\n+    ) -> ReachedFixedPoint {\n         log::debug!(\"resolving import: {:?}\", import);\n         if import.is_glob {\n-            return false;\n+            return ReachedFixedPoint::Yes;\n         };\n+        let original_module = Module {\n+            krate: self.krate,\n+            module_id,\n+        };\n+        let (def_id, reached_fixedpoint) =\n+            self.result\n+                .resolve_path(self.db, original_module, &import.path);\n+\n+        if reached_fixedpoint == ReachedFixedPoint::Yes {\n+            let last_segment = import.path.segments.last().unwrap();\n+            self.update(module_id, |items| {\n+                let res = Resolution {\n+                    def_id,\n+                    import: Some(import_id),\n+                };\n+                items.items.insert(last_segment.name.clone(), res);\n+            });\n+            log::debug!(\n+                \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n+                last_segment.name,\n+                import,\n+                def_id,\n+            );\n+        }\n+        reached_fixedpoint\n+    }\n+\n+    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n+        let module_items = self.result.per_module.get_mut(&module_id).unwrap();\n+        f(module_items)\n+    }\n+}\n \n-        let mut curr: ModuleId = match import.path.kind {\n-            PathKind::Plain | PathKind::Self_ => module_id,\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ReachedFixedPoint {\n+    Yes,\n+    No,\n+}\n+\n+impl ItemMap {\n+    // returns true if we are sure that additions to `ItemMap` wouldn't change\n+    // the result. That is, if we've reached fixed point at this particular\n+    // import.\n+    fn resolve_path(\n+        &self,\n+        db: &impl HirDatabase,\n+        original_module: Module,\n+        path: &Path,\n+    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n+        let mut curr_per_ns: PerNs<ModuleDef> = PerNs::types(match path.kind {\n+            PathKind::Crate => original_module.crate_root(db).into(),\n+            PathKind::Self_ | PathKind::Plain => original_module.into(),\n             PathKind::Super => {\n-                match module_id.parent(&self.module_tree) {\n-                    Some(it) => it,\n-                    None => {\n-                        // TODO: error\n-                        log::debug!(\"super path in root module\");\n-                        return true; // this can't suddenly resolve if we just resolve some other imports\n-                    }\n+                if let Some(p) = original_module.parent(db) {\n+                    p.into()\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return (PerNs::none(), ReachedFixedPoint::Yes);\n                 }\n             }\n-            PathKind::Crate => module_id.crate_root(&self.module_tree),\n             PathKind::Abs => {\n-                // TODO: absolute use is not supported for now\n-                return false;\n+                // TODO: absolute use is not supported\n+                return (PerNs::none(), ReachedFixedPoint::Yes);\n             }\n-        };\n-\n-        for (i, segment) in import.path.segments.iter().enumerate() {\n-            let is_last = i == import.path.segments.len() - 1;\n-\n-            let def_id = match self.result.per_module[&curr].items.get(&segment.name) {\n-                Some(res) if !res.def_id.is_none() => res.def_id,\n-                _ => {\n-                    log::debug!(\"path segment {:?} not found\", segment.name);\n-                    return false;\n+        });\n+\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            let curr = match curr_per_ns.as_ref().take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because curr_per_ns might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return (PerNs::none(), ReachedFixedPoint::No);\n                 }\n             };\n+            // resolve segment in curr\n+\n+            curr_per_ns = match curr {\n+                ModuleDef::Module(module) => {\n+                    if module.krate != original_module.krate {\n+                        let path = Path {\n+                            segments: path.segments[i..].iter().cloned().collect(),\n+                            kind: PathKind::Crate,\n+                        };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let def_id = module.resolve_path(db, &path);\n+                        return (def_id, ReachedFixedPoint::Yes);\n+                    }\n \n-            if !is_last {\n-                let type_def_id = if let Some(d) = def_id.take(Namespace::Types) {\n-                    d\n-                } else {\n-                    log::debug!(\n-                        \"path segment {:?} resolved to value only, but is not last\",\n-                        segment.name\n-                    );\n-                    return false;\n-                };\n-                curr = match type_def_id {\n-                    ModuleDef::Module(module) => {\n-                        if module.krate == self.krate {\n-                            module.module_id\n-                        } else {\n-                            let path = Path {\n-                                segments: import.path.segments[i + 1..].iter().cloned().collect(),\n-                                kind: PathKind::Crate,\n-                            };\n-                            log::debug!(\"resolving {:?} in other source root\", path);\n-                            let def_id = module.resolve_path(self.db, &path);\n-                            if !def_id.is_none() {\n-                                let last_segment = path.segments.last().unwrap();\n-                                self.update(module_id, |items| {\n-                                    let res = Resolution {\n-                                        def_id,\n-                                        import: Some(import_id),\n-                                    };\n-                                    items.items.insert(last_segment.name.clone(), res);\n-                                });\n-                                log::debug!(\n-                                    \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n-                                    last_segment.name,\n-                                    import,\n-                                    def_id,\n-                                );\n-                                return true;\n-                            } else {\n-                                log::debug!(\"rest of path did not resolve in other source root\");\n-                                return true;\n-                            }\n+                    match self.per_module[&module.module_id].items.get(&segment.name) {\n+                        Some(res) if !res.def_id.is_none() => res.def_id,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return (PerNs::none(), ReachedFixedPoint::No);\n                         }\n                     }\n-                    _ => {\n-                        log::debug!(\n-                            \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                            segment.name,\n-                            type_def_id,\n-                        );\n-                        return true; // this resolved to a non-module, so the path won't ever resolve\n+                }\n+                ModuleDef::Enum(e) => {\n+                    // enum variant\n+                    tested_by!(item_map_enum_importing);\n+                    let matching_variant = e\n+                        .variants(db)\n+                        .into_iter()\n+                        .find(|(n, _variant)| n == &segment.name);\n+\n+                    match matching_variant {\n+                        Some((_n, variant)) => PerNs::both(variant.into(), (*e).into()),\n+                        None => PerNs::none(),\n                     }\n                 }\n-            } else {\n-                log::debug!(\n-                    \"resolved import {:?} ({:?}) within source root to {:?}\",\n-                    segment.name,\n-                    import,\n-                    def_id,\n-                );\n-                self.update(module_id, |items| {\n-                    let res = Resolution {\n-                        def_id,\n-                        import: Some(import_id),\n-                    };\n-                    items.items.insert(segment.name.clone(), res);\n-                })\n-            }\n+                _ => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated\n+                    // item... Which we currently don't handle (TODO)\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+                    return (PerNs::none(), ReachedFixedPoint::Yes);\n+                }\n+            };\n         }\n-        true\n-    }\n-\n-    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n-        let module_items = self.result.per_module.get_mut(&module_id).unwrap();\n-        f(module_items)\n+        (curr_per_ns, ReachedFixedPoint::Yes)\n     }\n }\n "}, {"sha": "430d16a2e4bd5b5f844c156d58c4f6b2afb9b622", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "patch": "@@ -215,6 +215,27 @@ fn item_map_using_self() {\n     );\n }\n \n+#[test]\n+fn item_map_enum_importing() {\n+    covers!(item_map_enum_importing);\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        enum E { V }\n+        use self::E::V;\n+        <|>\n+        \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+        E: t\n+        V: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn item_map_across_crates() {\n     let (mut db, sr) = MockDatabase::with_files("}, {"sha": "ee47b5219814f11e2e98a395436e5312ac16bff6", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857c35ddb03ee5db97bbb4743dfeedeb3df350ec/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=857c35ddb03ee5db97bbb4743dfeedeb3df350ec", "patch": "@@ -46,11 +46,13 @@ macro_rules! covers {\n }\n \n #[macro_export]\n-macro_rules! mark {\n-    ($ident:ident) => {\n+macro_rules! marks {\n+    ($($ident:ident)*) => {\n+        $(\n         #[allow(bad_style)]\n         pub(crate) static $ident: std::sync::atomic::AtomicUsize =\n             std::sync::atomic::AtomicUsize::new(0);\n+        )*\n     };\n }\n "}]}