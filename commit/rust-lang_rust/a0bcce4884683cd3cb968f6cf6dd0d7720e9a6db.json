{"sha": "a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "node_id": "C_kwDOAAsO6NoAKGEwYmNjZTQ4ODQ2ODNjZDNjYjk2OGY2Y2Y2ZGQwZDc3MjBlOWE2ZGI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-22T17:28:20Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-01-27T13:46:40Z"}, "message": "Store def_id_to_hir_id as variant in hir_owner.\n\nIf hir_owner is Owner(_), the LocalDefId is pointing to an owner, so the ItemLocalId is 0.\nIf the HIR node does not exist, we store Phantom.\nOtherwise, we store the HirId associated to the LocalDefId.", "tree": {"sha": "5ce6029571ab576810aec2e0fbd62e9d25f312cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ce6029571ab576810aec2e0fbd62e9d25f312cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmHyokAACgkQgTGiTgx5\n769vJA/+O8CdB1xAFBozDNYf4f2NKjGkV2CZFhXhSSvHLqwNULh6DlEigWOLqtod\nxdq8/IcpzZvxU3V1BZdeRVgbpZzL/OeUB7QmoH43OS1M04LvWGRuUQSoRaFNoszu\nH8CCaqevejCDwV+3eG2E6Cr4oBxJus4GYbNZq7J038Uy3iXACcgcsiawUBUVR5QI\nfk2YhOX4H7kPExe4g3CHkEukWy6raoMErkq913UOX1NzSJxzoLGR325vUeYLIxOz\nmDvxRDgF05VyNG91vKtyBvoWo4GeN/zqfCw9ARhvH9BZ3YX59QxP5bvc4Ih6+orr\ny1yStixh/VRYsN8d9uJo+pGVv3lEpM2E4O2b4DBQBGkBzmGsh5YBB5vs3GnDMJ+m\nokKNAL9+6sMqofK8JJS/tPJWo5edAGo1Y9RaeCXjy091gMvhO1GOWscV8r/aTw8q\nvSbUGseWPwTwLwIyHmeDgfacJgDrUHAhXyy0CW8B4m5eLiMetTyxJ0uCneYizuZa\n0jf2kUpPjL840M0c0emqIE9m56aixWn/ZeRbtTS9pVQEShcOTVNkP94Bw/eyo+H3\nks2Y3S2FRGBniFMBcgScr+VmqjZV879w0qwRNhufFFBzmwxIALaXsyjQtHE7I8vw\nGSo/zXS+EwnAr13BjeGzWwpmQ1PpJ5zViLf2dz0JgkVoaB4MuA4=\n=6WUq\n-----END PGP SIGNATURE-----", "payload": "tree 5ce6029571ab576810aec2e0fbd62e9d25f312cd\nparent 009c1d02484dcc18e1596a33b3d8989a90361c89\nauthor Camille GILLOT <gillot.camille@gmail.com> 1632331700 +0200\ncommitter Santiago Pastorino <spastorino@gmail.com> 1643291200 -0300\n\nStore def_id_to_hir_id as variant in hir_owner.\n\nIf hir_owner is Owner(_), the LocalDefId is pointing to an owner, so the ItemLocalId is 0.\nIf the HIR node does not exist, we store Phantom.\nOtherwise, we store the HirId associated to the LocalDefId.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "html_url": "https://github.com/rust-lang/rust/commit/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "009c1d02484dcc18e1596a33b3d8989a90361c89", "url": "https://api.github.com/repos/rust-lang/rust/commits/009c1d02484dcc18e1596a33b3d8989a90361c89", "html_url": "https://github.com/rust-lang/rust/commit/009c1d02484dcc18e1596a33b3d8989a90361c89"}], "stats": {"total": 235, "additions": 123, "deletions": 112}, "files": [{"sha": "8b4a0840df58370e0d655ae089c06d57bc873a25", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -105,12 +105,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n \n-        let parent_generics =\n-            match self.owners[parent_hir_id].as_ref().unwrap().node().expect_item().kind {\n-                hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n-                | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n-                _ => &[],\n-            };\n+        let parent_generics = match self.owners[parent_hir_id].unwrap().node().expect_item().kind {\n+            hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n+            _ => &[],\n+        };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n             _ => None,\n@@ -480,6 +479,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             .node_id_to_hir_id\n                             .insert(new_node_id, hir::HirId::make_owner(new_id));\n                         debug_assert!(_old.is_none());\n+                        self.owners.ensure_contains_elem(new_id, || hir::MaybeOwner::Phantom);\n+                        let _old = std::mem::replace(\n+                            &mut self.owners[new_id],\n+                            hir::MaybeOwner::NonOwner(hir::HirId::make_owner(new_id)),\n+                        );\n+                        debug_assert!(matches!(_old, hir::MaybeOwner::Phantom));\n                         continue;\n                     };\n                     let ident = *ident;"}, {"sha": "f21f0b895adb67c012cf6d01cf375d682cbace38", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -98,7 +98,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     arena: &'hir Arena<'hir>,\n \n     /// The items being lowered are collected here.\n-    owners: IndexVec<LocalDefId, Option<hir::OwnerInfo<'hir>>>,\n+    owners: IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n     /// Bodies inside the owner being lowered.\n     bodies: Vec<(hir::ItemLocalId, &'hir hir::Body<'hir>)>,\n     /// Attributes inside the owner being lowered.\n@@ -291,7 +291,8 @@ pub fn lower_crate<'a, 'hir>(\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n-    let owners = IndexVec::from_fn_n(|_| None, resolver.definitions().def_index_count());\n+    let owners =\n+        IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, resolver.definitions().def_index_count());\n     LoweringContext {\n         sess,\n         resolver,\n@@ -402,19 +403,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let hir_hash = self.compute_hir_hash();\n \n-        let mut def_id_to_hir_id = IndexVec::default();\n-\n-        for (node_id, hir_id) in self.node_id_to_hir_id.into_iter_enumerated() {\n-            if let Some(def_id) = self.resolver.opt_local_def_id(node_id) {\n-                if def_id_to_hir_id.len() <= def_id.index() {\n-                    def_id_to_hir_id.resize(def_id.index() + 1, None);\n-                }\n-                def_id_to_hir_id[def_id] = hir_id;\n-            }\n-        }\n-\n-        self.resolver.definitions().init_def_id_to_hir_id_mapping(def_id_to_hir_id);\n-\n         let krate = hir::Crate { owners: self.owners, hir_hash };\n         self.arena.alloc(krate)\n     }\n@@ -427,7 +415,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .owners\n             .iter_enumerated()\n             .filter_map(|(def_id, info)| {\n-                let info = info.as_ref()?;\n+                let info = info.as_owner()?;\n                 let def_path_hash = definitions.def_path_hash(def_id);\n                 Some((def_path_hash, info))\n             })\n@@ -469,8 +457,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n \n-        let _old = self.owners.insert(def_id, info);\n-        debug_assert!(_old.is_none());\n+        self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+        self.owners[def_id] = hir::MaybeOwner::Owner(self.arena.alloc(info));\n \n         def_id\n     }\n@@ -488,6 +476,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     None\n                 } else {\n                     let def_id = self.resolver.opt_local_def_id(node_id)?;\n+                    self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+                    if let o @ hir::MaybeOwner::Phantom = &mut self.owners[def_id] {\n+                        // Do not override a `MaybeOwner::Owner` that may already here.\n+                        *o = hir::MaybeOwner::NonOwner(hir_id);\n+                    }\n                     Some((hir_id.local_id, def_id))\n                 }\n             })"}, {"sha": "d655f12f5e1d1989ea430226f121b83a18f8214b", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -7,7 +7,6 @@\n pub use crate::def_id::DefPathHash;\n use crate::def_id::{CrateNum, DefIndex, LocalDefId, StableCrateId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::def_path_hash_map::DefPathHashMap;\n-use crate::hir;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -101,13 +100,6 @@ impl DefPathTable {\n pub struct Definitions {\n     table: DefPathTable,\n \n-    /// Only [`LocalDefId`]s for items and item-like are HIR owners.\n-    /// The associated `HirId` has a `local_id` of `0`.\n-    /// Generic parameters and closures are also assigned a `LocalDefId` but are not HIR owners.\n-    /// Their `HirId`s are defined by their position while lowering the enclosing owner.\n-    // FIXME(cjgillot) Some `LocalDefId`s from `use` items are dropped during lowering and lack a `HirId`.\n-    pub(super) def_id_to_hir_id: IndexVec<LocalDefId, Option<hir::HirId>>,\n-\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n \n@@ -322,12 +314,6 @@ impl Definitions {\n         })\n     }\n \n-    #[inline]\n-    #[track_caller]\n-    pub fn local_def_id_to_hir_id(&self, id: LocalDefId) -> hir::HirId {\n-        self.def_id_to_hir_id[id].unwrap()\n-    }\n-\n     /// Adds a root definition (no parent) and a few other reserved definitions.\n     pub fn new(stable_crate_id: StableCrateId, crate_span: Span) -> Definitions {\n         let key = DefKey {\n@@ -354,7 +340,6 @@ impl Definitions {\n \n         Definitions {\n             table,\n-            def_id_to_hir_id: Default::default(),\n             expansions_that_defined: Default::default(),\n             def_id_to_span,\n             stable_crate_id,\n@@ -406,20 +391,6 @@ impl Definitions {\n         def_id\n     }\n \n-    /// Initializes the `LocalDefId` to `HirId` mapping once it has been generated during\n-    /// AST to HIR lowering.\n-    pub fn init_def_id_to_hir_id_mapping(\n-        &mut self,\n-        mapping: IndexVec<LocalDefId, Option<hir::HirId>>,\n-    ) {\n-        assert!(\n-            self.def_id_to_hir_id.is_empty(),\n-            \"trying to initialize `LocalDefId` <-> `HirId` mappings twice\"\n-        );\n-\n-        self.def_id_to_hir_id = mapping;\n-    }\n-\n     pub fn expansion_that_defined(&self, id: LocalDefId) -> ExpnId {\n         self.expansions_that_defined.get(&id).copied().unwrap_or_else(ExpnId::root)\n     }\n@@ -431,7 +402,7 @@ impl Definitions {\n     }\n \n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n-        self.def_id_to_hir_id.iter_enumerated().map(|(k, _)| k)\n+        self.table.def_path_hashes.indices().map(|local_def_index| LocalDefId { local_def_index })\n     }\n \n     #[inline(always)]"}, {"sha": "67398c80f360cbd2864a72ac41baff411345323f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -711,6 +711,15 @@ pub struct OwnerNodes<'tcx> {\n     pub local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n }\n \n+impl<'tcx> OwnerNodes<'tcx> {\n+    pub fn node(&self) -> OwnerNode<'tcx> {\n+        use rustc_index::vec::Idx;\n+        let node = self.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n+        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n+        node\n+    }\n+}\n+\n /// Full information resulting from lowering an AST node.\n #[derive(Debug, HashStable_Generic)]\n pub struct OwnerInfo<'hir> {\n@@ -728,10 +737,39 @@ pub struct OwnerInfo<'hir> {\n impl<'tcx> OwnerInfo<'tcx> {\n     #[inline]\n     pub fn node(&self) -> OwnerNode<'tcx> {\n-        use rustc_index::vec::Idx;\n-        let node = self.nodes.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n-        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n-        node\n+        self.nodes.node()\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n+pub enum MaybeOwner<T> {\n+    Owner(T),\n+    NonOwner(HirId),\n+    /// Used as a placeholder for unused LocalDefId.\n+    Phantom,\n+}\n+\n+impl<T> MaybeOwner<T> {\n+    pub fn as_owner(self) -> Option<T> {\n+        match self {\n+            MaybeOwner::Owner(i) => Some(i),\n+            MaybeOwner::NonOwner(_) | MaybeOwner::Phantom => None,\n+        }\n+    }\n+\n+    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> MaybeOwner<U> {\n+        match self {\n+            MaybeOwner::Owner(i) => MaybeOwner::Owner(f(i)),\n+            MaybeOwner::NonOwner(hir_id) => MaybeOwner::NonOwner(hir_id),\n+            MaybeOwner::Phantom => MaybeOwner::Phantom,\n+        }\n+    }\n+\n+    pub fn unwrap(self) -> T {\n+        match self {\n+            MaybeOwner::Owner(i) => i,\n+            MaybeOwner::NonOwner(_) | MaybeOwner::Phantom => panic!(\"Not a HIR owner\"),\n+        }\n     }\n }\n \n@@ -743,7 +781,7 @@ impl<'tcx> OwnerInfo<'tcx> {\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n #[derive(Debug)]\n pub struct Crate<'hir> {\n-    pub owners: IndexVec<LocalDefId, Option<OwnerInfo<'hir>>>,\n+    pub owners: IndexVec<LocalDefId, MaybeOwner<&'hir OwnerInfo<'hir>>>,\n     pub hir_hash: Fingerprint,\n }\n "}, {"sha": "dee391b9cce215cfe9d194fc1048936ce54555b7", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -30,6 +30,11 @@ impl HirId {\n         if self.local_id.index() == 0 { Some(self.owner) } else { None }\n     }\n \n+    #[inline]\n+    pub fn is_owner(self) -> bool {\n+        self.local_id.index() == 0\n+    }\n+\n     #[inline]\n     pub fn make_owner(owner: LocalDefId) -> Self {\n         Self { owner, local_id: ItemLocalId::from_u32(0) }"}, {"sha": "e75c16337ee4cbb5f93c8487bcd8d56ec28f0e3e", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -123,7 +123,7 @@ impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n     fn next(&mut self) -> Option<Self::Item> {\n         if self.current_id.local_id.index() != 0 {\n             self.current_id.local_id = ItemLocalId::new(0);\n-            if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n+            if let MaybeOwner::Owner(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n                 return Some((self.current_id.owner, node.node));\n             }\n         }\n@@ -141,7 +141,7 @@ impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n             self.current_id = HirId::make_owner(parent_id);\n \n             // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n-            if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n+            if let MaybeOwner::Owner(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n                 return Some((self.current_id.owner, node.node));\n             }\n         }\n@@ -155,14 +155,14 @@ impl<'hir> Map<'hir> {\n \n     pub fn root_module(&self) -> &'hir Mod<'hir> {\n         match self.tcx.hir_owner(CRATE_DEF_ID).map(|o| o.node) {\n-            Some(OwnerNode::Crate(item)) => item,\n+            MaybeOwner::Owner(OwnerNode::Crate(item)) => item,\n             _ => bug!(),\n         }\n     }\n \n     pub fn items(&self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n         let krate = self.krate();\n-        krate.owners.iter().filter_map(|owner| match owner.as_ref()?.node() {\n+        krate.owners.iter().filter_map(|owner| match owner.as_owner()?.node() {\n             OwnerNode::Item(item) => Some(item),\n             _ => None,\n         })\n@@ -205,7 +205,8 @@ impl<'hir> Map<'hir> {\n             Some(hir_id.owner)\n         } else {\n             self.tcx\n-                .hir_owner_nodes(hir_id.owner)?\n+                .hir_owner_nodes(hir_id.owner)\n+                .as_owner()?\n                 .local_id_to_def_id\n                 .get(&hir_id.local_id)\n                 .copied()\n@@ -214,8 +215,12 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n-        // FIXME(#85914) is this access safe for incr. comp.?\n-        self.tcx.untracked_resolutions.definitions.local_def_id_to_hir_id(def_id)\n+        let owner = self.tcx.hir_owner(def_id);\n+        match owner {\n+            MaybeOwner::Owner(_) => HirId::make_owner(def_id),\n+            MaybeOwner::Phantom => bug!(\"No HirId for {:?}\", def_id),\n+            MaybeOwner::NonOwner(hir_id) => hir_id,\n+        }\n     }\n \n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n@@ -321,7 +326,7 @@ impl<'hir> Map<'hir> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             Some(self.tcx.hir_owner_parent(id.owner))\n         } else {\n-            let owner = self.tcx.hir_owner_nodes(id.owner)?;\n+            let owner = self.tcx.hir_owner_nodes(id.owner).as_owner()?;\n             let node = owner.nodes[id.local_id].as_ref()?;\n             let hir_id = HirId { owner: id.owner, local_id: node.parent };\n             Some(hir_id)\n@@ -335,10 +340,10 @@ impl<'hir> Map<'hir> {\n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n-            let owner = self.tcx.hir_owner(id.owner)?;\n+            let owner = self.tcx.hir_owner(id.owner).as_owner()?;\n             Some(owner.node.into())\n         } else {\n-            let owner = self.tcx.hir_owner_nodes(id.owner)?;\n+            let owner = self.tcx.hir_owner_nodes(id.owner).as_owner()?;\n             let node = owner.nodes[id.local_id].as_ref()?;\n             Some(node.node)\n         }\n@@ -366,7 +371,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_generics(&self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n-        let node = self.tcx.hir_owner(id)?;\n+        let node = self.tcx.hir_owner(id).as_owner()?;\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n             OwnerNode::TraitItem(trait_item) => Some(&trait_item.generics),\n@@ -522,7 +527,7 @@ impl<'hir> Map<'hir> {\n             .owners\n             .iter_enumerated()\n             .flat_map(move |(owner, owner_info)| {\n-                let bodies = &owner_info.as_ref()?.nodes.bodies;\n+                let bodies = &owner_info.as_owner()?.nodes.bodies;\n                 Some(bodies.iter().map(move |&(local_id, _)| {\n                     let hir_id = HirId { owner, local_id };\n                     let body_id = BodyId { hir_id };\n@@ -539,7 +544,7 @@ impl<'hir> Map<'hir> {\n \n         par_iter(&self.krate().owners.raw).enumerate().for_each(|(owner, owner_info)| {\n             let owner = LocalDefId::new(owner);\n-            if let Some(owner_info) = owner_info {\n+            if let MaybeOwner::Owner(owner_info) = owner_info {\n                 par_iter(owner_info.nodes.bodies.range(..)).for_each(|(local_id, _)| {\n                     let hir_id = HirId { owner, local_id: *local_id };\n                     let body_id = BodyId { hir_id };\n@@ -583,10 +588,10 @@ impl<'hir> Map<'hir> {\n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = HirId::make_owner(module);\n         match self.tcx.hir_owner(module).map(|o| o.node) {\n-            Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n-                (m, span, hir_id)\n-            }\n-            Some(OwnerNode::Crate(item)) => (item, item.inner, hir_id),\n+            MaybeOwner::Owner(OwnerNode::Item(&Item {\n+                span, kind: ItemKind::Mod(ref m), ..\n+            })) => (m, span, hir_id),\n+            MaybeOwner::Owner(OwnerNode::Crate(item)) => (item, item.inner, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -601,7 +606,7 @@ impl<'hir> Map<'hir> {\n     pub fn walk_attributes(self, visitor: &mut impl Visitor<'hir>) {\n         let krate = self.krate();\n         for (owner, info) in krate.owners.iter_enumerated() {\n-            if let Some(info) = info {\n+            if let MaybeOwner::Owner(info) = info {\n                 for (local_id, attrs) in info.attrs.map.iter() {\n                     let id = HirId { owner, local_id: *local_id };\n                     for a in *attrs {\n@@ -625,7 +630,7 @@ impl<'hir> Map<'hir> {\n         V: itemlikevisit::ItemLikeVisitor<'hir>,\n     {\n         let krate = self.krate();\n-        for owner in krate.owners.iter().filter_map(Option::as_ref) {\n+        for owner in krate.owners.iter().filter_map(|i| i.as_owner()) {\n             match owner.node() {\n                 OwnerNode::Item(item) => visitor.visit_item(item),\n                 OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n@@ -642,12 +647,14 @@ impl<'hir> Map<'hir> {\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n         let krate = self.krate();\n-        par_for_each_in(&krate.owners.raw, |owner| match owner.as_ref().map(OwnerInfo::node) {\n-            Some(OwnerNode::Item(item)) => visitor.visit_item(item),\n-            Some(OwnerNode::ForeignItem(item)) => visitor.visit_foreign_item(item),\n-            Some(OwnerNode::ImplItem(item)) => visitor.visit_impl_item(item),\n-            Some(OwnerNode::TraitItem(item)) => visitor.visit_trait_item(item),\n-            Some(OwnerNode::Crate(_)) | None => {}\n+        par_for_each_in(&krate.owners.raw, |owner| match owner.map(OwnerInfo::node) {\n+            MaybeOwner::Owner(OwnerNode::Item(item)) => visitor.visit_item(item),\n+            MaybeOwner::Owner(OwnerNode::ForeignItem(item)) => visitor.visit_foreign_item(item),\n+            MaybeOwner::Owner(OwnerNode::ImplItem(item)) => visitor.visit_impl_item(item),\n+            MaybeOwner::Owner(OwnerNode::TraitItem(item)) => visitor.visit_trait_item(item),\n+            MaybeOwner::Owner(OwnerNode::Crate(_))\n+            | MaybeOwner::NonOwner(_)\n+            | MaybeOwner::Phantom => {}\n         })\n     }\n \n@@ -878,7 +885,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n-        if let Some(node) = self.tcx.hir_owner(parent) {\n+        if let MaybeOwner::Owner(node) = self.tcx.hir_owner(parent) {\n             if let OwnerNode::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node.node\n             {\n                 return *abi;\n@@ -892,21 +899,21 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_item(&self, id: LocalDefId) -> &'hir Item<'hir> {\n         match self.tcx.hir_owner(id) {\n-            Some(Owner { node: OwnerNode::Item(item), .. }) => item,\n+            MaybeOwner::Owner(Owner { node: OwnerNode::Item(item), .. }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n         match self.tcx.hir_owner(id) {\n-            Some(Owner { node: OwnerNode::ImplItem(item), .. }) => item,\n+            MaybeOwner::Owner(Owner { node: OwnerNode::ImplItem(item), .. }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n         match self.tcx.hir_owner(id) {\n-            Some(Owner { node: OwnerNode::TraitItem(item), .. }) => item,\n+            MaybeOwner::Owner(Owner { node: OwnerNode::TraitItem(item), .. }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n@@ -920,7 +927,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn expect_foreign_item(&self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n         match self.tcx.hir_owner(id) {\n-            Some(Owner { node: OwnerNode::ForeignItem(item), .. }) => item,\n+            MaybeOwner::Owner(Owner { node: OwnerNode::ForeignItem(item), .. }) => item,\n             _ => {\n                 bug!(\"expected foreign item, found {}\", self.node_to_string(HirId::make_owner(id)))\n             }\n@@ -1121,7 +1128,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n             .owners\n             .iter_enumerated()\n             .filter_map(|(def_id, info)| {\n-                let _ = info.as_ref()?;\n+                let _ = info.as_owner()?;\n                 let def_path_hash = definitions.def_path_hash(def_id);\n                 let span = definitions.def_span(def_id);\n                 debug_assert_eq!(span.parent(), None);"}, {"sha": "5543e96036b5127cbccfaa749038915896311ef8", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -65,20 +65,20 @@ pub fn provide(providers: &mut Providers) {\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {\n-        let owner = tcx.hir_crate(()).owners.get(id)?.as_ref()?;\n-        let node = owner.node();\n-        Some(Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies })\n+        tcx.hir_crate(()).owners[id].map(|owner| {\n+            let node = owner.nodes.node();\n+            Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies }\n+        })\n     };\n-    providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map(|i| &i.nodes);\n+    providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id].map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {\n         // Accessing the def_key is ok since its value is hashed as part of `id`'s DefPathHash.\n         let parent = tcx.untracked_resolutions.definitions.def_key(id).parent;\n         let parent = parent.map_or(CRATE_HIR_ID, |local_def_index| {\n             let def_id = LocalDefId { local_def_index };\n-            let mut parent_hir_id =\n-                tcx.untracked_resolutions.definitions.local_def_id_to_hir_id(def_id);\n+            let mut parent_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n             if let Some(local_id) =\n-                tcx.hir_crate(()).owners[parent_hir_id.owner].as_ref().unwrap().parenting.get(&id)\n+                tcx.hir_crate(()).owners[parent_hir_id.owner].unwrap().parenting.get(&id)\n             {\n                 parent_hir_id.local_id = *local_id;\n             }\n@@ -87,7 +87,7 @@ pub fn provide(providers: &mut Providers) {\n         parent\n     };\n     providers.hir_attrs =\n-        |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map_or(AttributeMap::EMPTY, |o| &o.attrs);\n+        |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs);\n     providers.source_span = |tcx, def_id| tcx.resolutions(()).definitions.def_span(def_id);\n     providers.def_span = |tcx, def_id| tcx.hir().span_if_local(def_id).unwrap_or(DUMMY_SP);\n     providers.fn_arg_names = |tcx, id| {\n@@ -111,4 +111,6 @@ pub fn provide(providers: &mut Providers) {\n         let id = id.expect_local();\n         tcx.resolutions(()).definitions.expansion_that_defined(id)\n     };\n+    providers.in_scope_traits_map =\n+        |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map(|owner_info| &owner_info.trait_map);\n }"}, {"sha": "f5b4925fbb3e67e05ec9cc084f1a7fb635b1a6dc", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -52,7 +52,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner(key: LocalDefId) -> Option<crate::hir::Owner<'tcx>> {\n+    query hir_owner(key: LocalDefId) -> hir::MaybeOwner<crate::hir::Owner<'tcx>> {\n         desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n@@ -68,7 +68,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx hir::OwnerNodes<'tcx>> {\n+    query hir_owner_nodes(key: LocalDefId) -> hir::MaybeOwner<&'tcx hir::OwnerNodes<'tcx>> {\n         desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n "}, {"sha": "75f1318e3631437f88fa00ece30ab319bdccfcef", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -2875,8 +2875,6 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {\n-    providers.in_scope_traits_map =\n-        |tcx, id| tcx.hir_crate(()).owners[id].as_ref().map(|owner_info| &owner_info.trait_map);\n     providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n     providers.module_reexports =\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);"}, {"sha": "2bb9f48f9b7c87c78ca51fba9c5193f9083e7784", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -579,7 +579,7 @@ fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n     let mut stable_hasher = StableHasher::new();\n     let owner = hir_body.id().hir_id.owner;\n-    let bodies = &tcx.hir_owner_nodes(owner).as_ref().unwrap().bodies;\n+    let bodies = &tcx.hir_owner_nodes(owner).unwrap().bodies;\n     hcx.with_hir_bodies(false, owner, bodies, |hcx| {\n         hir_body.value.hash_stable(hcx, &mut stable_hasher)\n     });"}, {"sha": "6ef85c426be7040839311d9f414902ad076028de", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=a0bcce4884683cd3cb968f6cf6dd0d7720e9a6db", "patch": "@@ -1019,15 +1019,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                     // Ensure that the parent of the def is an item, not HRTB\n                     let parent_id = self.tcx.hir().get_parent_node(hir_id);\n-                    // FIXME(cjgillot) Can this check be replaced by\n-                    // `let parent_is_item = parent_id.is_owner();`?\n-                    let parent_is_item = if let Some(parent_def_id) = parent_id.as_owner() {\n-                        matches!(self.tcx.hir().krate().owners.get(parent_def_id), Some(Some(_)),)\n-                    } else {\n-                        false\n-                    };\n-\n-                    if !parent_is_item {\n+                    if !parent_id.is_owner() {\n                         if !self.trait_definition_only {\n                             struct_span_err!(\n                                 self.tcx.sess,"}]}