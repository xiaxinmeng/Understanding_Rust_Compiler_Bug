{"sha": "ced5a8594053ab3eb15f9e317604f696402f4860", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZDVhODU5NDA1M2FiM2ViMTVmOWUzMTc2MDRmNjk2NDAyZjQ4NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-19T07:59:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-19T07:59:55Z"}, "message": "Auto merge of #31015 - nrc:fmt-test, r=sfackler", "tree": {"sha": "6342f5907cd58bbc18b7f5bbaf9253aac98df4d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6342f5907cd58bbc18b7f5bbaf9253aac98df4d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ced5a8594053ab3eb15f9e317604f696402f4860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ced5a8594053ab3eb15f9e317604f696402f4860", "html_url": "https://github.com/rust-lang/rust/commit/ced5a8594053ab3eb15f9e317604f696402f4860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ced5a8594053ab3eb15f9e317604f696402f4860/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66e88289e6ffa8be4701933369820613b9d345d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c66e88289e6ffa8be4701933369820613b9d345d", "html_url": "https://github.com/rust-lang/rust/commit/c66e88289e6ffa8be4701933369820613b9d345d"}, {"sha": "e305ee6db9a0cfb5b01f3b23d01edaab6a5018ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/e305ee6db9a0cfb5b01f3b23d01edaab6a5018ca", "html_url": "https://github.com/rust-lang/rust/commit/e305ee6db9a0cfb5b01f3b23d01edaab6a5018ca"}], "stats": {"total": 1029, "additions": 519, "deletions": 510}, "files": [{"sha": "ac5b235854a04cc54fb174cd94ea2fdc1f99026c", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 257, "deletions": 219, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a8594053ab3eb15f9e317604f696402f4860/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a8594053ab3eb15f9e317604f696402f4860/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ced5a8594053ab3eb15f9e317604f696402f4860", "patch": "@@ -77,12 +77,10 @@ use std::time::{Instant, Duration};\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n-    pub use {Bencher, TestName, TestResult, TestDesc,\n-             TestDescAndFn, TestOpts, TrFailed, TrIgnored, TrOk,\n-             Metric, MetricMap,\n-             StaticTestFn, StaticTestName, DynTestName, DynTestFn,\n-             run_test, test_main, test_main_static, filter_tests,\n-             parse_opts, StaticBenchFn, ShouldPanic};\n+    pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n+             TrIgnored, TrOk, Metric, MetricMap, StaticTestFn, StaticTestName, DynTestName,\n+             DynTestFn, run_test, test_main, test_main_static, filter_tests, parse_opts,\n+             StaticBenchFn, ShouldPanic};\n }\n \n pub mod stats;\n@@ -95,13 +93,13 @@ pub mod stats;\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TestName {\n     StaticTestName(&'static str),\n-    DynTestName(String)\n+    DynTestName(String),\n }\n impl TestName {\n     fn as_slice(&self) -> &str {\n         match *self {\n             StaticTestName(s) => s,\n-            DynTestName(ref s) => s\n+            DynTestName(ref s) => s,\n         }\n     }\n }\n@@ -146,19 +144,19 @@ pub enum TestFn {\n     StaticBenchFn(fn(&mut Bencher)),\n     StaticMetricFn(fn(&mut MetricMap)),\n     DynTestFn(Box<FnBox() + Send>),\n-    DynMetricFn(Box<FnBox(&mut MetricMap)+Send>),\n-    DynBenchFn(Box<TDynBenchFn+'static>)\n+    DynMetricFn(Box<FnBox(&mut MetricMap) + Send>),\n+    DynBenchFn(Box<TDynBenchFn + 'static>),\n }\n \n impl TestFn {\n     fn padding(&self) -> NamePadding {\n         match *self {\n-            StaticTestFn(..)   => PadNone,\n-            StaticBenchFn(..)  => PadOnRight,\n+            StaticTestFn(..) => PadNone,\n+            StaticBenchFn(..) => PadOnRight,\n             StaticMetricFn(..) => PadOnRight,\n-            DynTestFn(..)      => PadNone,\n-            DynMetricFn(..)    => PadOnRight,\n-            DynBenchFn(..)     => PadOnRight,\n+            DynTestFn(..) => PadNone,\n+            DynMetricFn(..) => PadOnRight,\n+            DynBenchFn(..) => PadOnRight,\n         }\n     }\n }\n@@ -171,7 +169,7 @@ impl fmt::Debug for TestFn {\n             StaticMetricFn(..) => \"StaticMetricFn(..)\",\n             DynTestFn(..) => \"DynTestFn(..)\",\n             DynMetricFn(..) => \"DynMetricFn(..)\",\n-            DynBenchFn(..) => \"DynBenchFn(..)\"\n+            DynBenchFn(..) => \"DynBenchFn(..)\",\n         })\n     }\n }\n@@ -192,7 +190,7 @@ pub struct Bencher {\n pub enum ShouldPanic {\n     No,\n     Yes,\n-    YesWithMessage(&'static str)\n+    YesWithMessage(&'static str),\n }\n \n // The definition of a single test. A test runner will run a list of\n@@ -215,17 +213,20 @@ pub struct TestDescAndFn {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Copy)]\n pub struct Metric {\n     value: f64,\n-    noise: f64\n+    noise: f64,\n }\n \n impl Metric {\n     pub fn new(value: f64, noise: f64) -> Metric {\n-        Metric {value: value, noise: noise}\n+        Metric {\n+            value: value,\n+            noise: noise,\n+        }\n     }\n }\n \n #[derive(PartialEq)]\n-pub struct MetricMap(BTreeMap<String,Metric>);\n+pub struct MetricMap(BTreeMap<String, Metric>);\n \n impl Clone for MetricMap {\n     fn clone(&self) -> MetricMap {\n@@ -236,13 +237,12 @@ impl Clone for MetricMap {\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n-    let opts =\n-        match parse_opts(args) {\n-            Some(Ok(o)) => o,\n-            Some(Err(msg)) => panic!(\"{:?}\", msg),\n-            None => return\n-        };\n+pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>) {\n+    let opts = match parse_opts(args) {\n+        Some(Ok(o)) => o,\n+        Some(Err(msg)) => panic!(\"{:?}\", msg),\n+        None => return,\n+    };\n     match run_tests_console(&opts, tests) {\n         Ok(true) => {}\n         Ok(false) => std::process::exit(101),\n@@ -259,13 +259,25 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n // rather than a &[].\n pub fn test_main_static(tests: &[TestDescAndFn]) {\n     let args = env::args().collect::<Vec<_>>();\n-    let owned_tests = tests.iter().map(|t| {\n-        match t.testfn {\n-            StaticTestFn(f) => TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n-            StaticBenchFn(f) => TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n-            _ => panic!(\"non-static tests passed to test::test_main_static\")\n-        }\n-    }).collect();\n+    let owned_tests = tests.iter()\n+                           .map(|t| {\n+                               match t.testfn {\n+                                   StaticTestFn(f) => {\n+                                       TestDescAndFn {\n+                                           testfn: StaticTestFn(f),\n+                                           desc: t.desc.clone(),\n+                                       }\n+                                   }\n+                                   StaticBenchFn(f) => {\n+                                       TestDescAndFn {\n+                                           testfn: StaticBenchFn(f),\n+                                           desc: t.desc.clone(),\n+                                       }\n+                                   }\n+                                   _ => panic!(\"non-static tests passed to test::test_main_static\"),\n+                               }\n+                           })\n+                           .collect();\n     test_main(&args, owned_tests)\n }\n \n@@ -304,6 +316,7 @@ impl TestOpts {\n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, String>;\n \n+#[cfg_attr(rustfmt, rustfmt_skip)]\n fn optgroups() -> Vec<getopts::OptGroup> {\n     vec!(getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n       getopts::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n@@ -353,13 +366,15 @@ Test Attributes:\n // Parses command line arguments into test options\n pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let args_ = &args[1..];\n-    let matches =\n-        match getopts::getopts(args_, &optgroups()) {\n-          Ok(m) => m,\n-          Err(f) => return Some(Err(f.to_string()))\n-        };\n+    let matches = match getopts::getopts(args_, &optgroups()) {\n+        Ok(m) => m,\n+        Err(f) => return Some(Err(f.to_string())),\n+    };\n \n-    if matches.opt_present(\"h\") { usage(&args[0]); return None; }\n+    if matches.opt_present(\"h\") {\n+        usage(&args[0]);\n+        return None;\n+    }\n \n     let filter = if !matches.free.is_empty() {\n         Some(matches.free[0].clone())\n@@ -373,8 +388,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let logfile = logfile.map(|s| PathBuf::from(&s));\n \n     let bench_benchmarks = matches.opt_present(\"bench\");\n-    let run_tests = ! bench_benchmarks ||\n-        matches.opt_present(\"test\");\n+    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n \n     let mut nocapture = matches.opt_present(\"nocapture\");\n     if !nocapture {\n@@ -386,9 +400,11 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(\"always\") => AlwaysColor,\n         Some(\"never\") => NeverColor,\n \n-        Some(v) => return Some(Err(format!(\"argument for --color must be \\\n-                                            auto, always, or never (was {})\",\n-                                            v))),\n+        Some(v) => {\n+            return Some(Err(format!(\"argument for --color must be auto, always, or never (was \\\n+                                     {})\",\n+                                    v)))\n+        }\n     };\n \n     let test_opts = TestOpts {\n@@ -436,20 +452,19 @@ struct ConsoleTestState<T> {\n     ignored: usize,\n     measured: usize,\n     metrics: MetricMap,\n-    failures: Vec<(TestDesc, Vec<u8> )> ,\n+    failures: Vec<(TestDesc, Vec<u8>)>,\n     max_name_len: usize, // number of columns to fill when aligning names\n }\n \n impl<T: Write> ConsoleTestState<T> {\n-    pub fn new(opts: &TestOpts,\n-               _: Option<T>) -> io::Result<ConsoleTestState<io::Stdout>> {\n+    pub fn new(opts: &TestOpts, _: Option<T>) -> io::Result<ConsoleTestState<io::Stdout>> {\n         let log_out = match opts.logfile {\n             Some(ref path) => Some(try!(File::create(path))),\n-            None => None\n+            None => None,\n         };\n         let out = match term::stdout() {\n             None => Raw(io::stdout()),\n-            Some(t) => Pretty(t)\n+            Some(t) => Pretty(t),\n         };\n \n         Ok(ConsoleTestState {\n@@ -487,9 +502,7 @@ impl<T: Write> ConsoleTestState<T> {\n         self.write_pretty(\"bench\", term::color::CYAN)\n     }\n \n-    pub fn write_pretty(&mut self,\n-                        word: &str,\n-                        color: term::color::Color) -> io::Result<()> {\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 if self.use_color {\n@@ -513,22 +526,25 @@ impl<T: Write> ConsoleTestState<T> {\n             Pretty(ref mut term) => {\n                 try!(term.write_all(s.as_bytes()));\n                 term.flush()\n-            },\n+            }\n             Raw(ref mut stdout) => {\n                 try!(stdout.write_all(s.as_bytes()));\n                 stdout.flush()\n-            },\n+            }\n         }\n     }\n \n     pub fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n         self.total = len;\n-        let noun = if len != 1 { \"tests\" } else { \"test\" };\n+        let noun = if len != 1 {\n+            \"tests\"\n+        } else {\n+            \"test\"\n+        };\n         self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n     }\n \n-    pub fn write_test_start(&mut self, test: &TestDesc,\n-                            align: NamePadding) -> io::Result<()> {\n+    pub fn write_test_start(&mut self, test: &TestDesc, align: NamePadding) -> io::Result<()> {\n         let name = test.padded_name(self.max_name_len, align);\n         self.write_plain(&format!(\"test {} ... \", name))\n     }\n@@ -553,18 +569,19 @@ impl<T: Write> ConsoleTestState<T> {\n         self.write_plain(\"\\n\")\n     }\n \n-    pub fn write_log(&mut self, test: &TestDesc,\n-                     result: &TestResult) -> io::Result<()> {\n+    pub fn write_log(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n         match self.log_out {\n             None => Ok(()),\n             Some(ref mut o) => {\n-                let s = format!(\"{} {}\\n\", match *result {\n-                        TrOk => \"ok\".to_owned(),\n-                        TrFailed => \"failed\".to_owned(),\n-                        TrIgnored => \"ignored\".to_owned(),\n-                        TrMetrics(ref mm) => mm.fmt_metrics(),\n-                        TrBench(ref bs) => fmt_bench_samples(bs)\n-                    }, test.name);\n+                let s = format!(\"{} {}\\n\",\n+                                match *result {\n+                                    TrOk => \"ok\".to_owned(),\n+                                    TrFailed => \"failed\".to_owned(),\n+                                    TrIgnored => \"ignored\".to_owned(),\n+                                    TrMetrics(ref mm) => mm.fmt_metrics(),\n+                                    TrBench(ref bs) => fmt_bench_samples(bs),\n+                                },\n+                                test.name);\n                 o.write_all(s.as_bytes())\n             }\n         }\n@@ -612,7 +629,10 @@ impl<T: Write> ConsoleTestState<T> {\n             try!(self.write_failed());\n         }\n         let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n-                        self.passed, self.failed, self.ignored, self.measured);\n+                        self.passed,\n+                        self.failed,\n+                        self.ignored,\n+                        self.measured);\n         try!(self.write_plain(&s));\n         return Ok(success);\n     }\n@@ -650,19 +670,19 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n     let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n \n     output.write_fmt(format_args!(\"{:>11} ns/iter (+/- {})\",\n-                     fmt_thousands_sep(median, ','),\n-                     fmt_thousands_sep(deviation, ','))).unwrap();\n+                                  fmt_thousands_sep(median, ','),\n+                                  fmt_thousands_sep(deviation, ',')))\n+          .unwrap();\n     if bs.mb_s != 0 {\n         output.write_fmt(format_args!(\" = {} MB/s\", bs.mb_s)).unwrap();\n     }\n     output\n }\n \n // A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Result<bool> {\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n \n-    fn callback<T: Write>(event: &TestEvent,\n-                          st: &mut ConsoleTestState<T>) -> io::Result<()> {\n+    fn callback<T: Write>(event: &TestEvent, st: &mut ConsoleTestState<T>) -> io::Result<()> {\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n@@ -675,13 +695,9 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Res\n                     TrMetrics(mm) => {\n                         let tname = test.name;\n                         let MetricMap(mm) = mm;\n-                        for (k,v) in &mm {\n+                        for (k, v) in &mm {\n                             st.metrics\n-                              .insert_metric(&format!(\"{}.{}\",\n-                                                      tname,\n-                                                      k),\n-                                             v.value,\n-                                             v.noise);\n+                              .insert_metric(&format!(\"{}.{}\", tname, k), v.value, v.noise);\n                         }\n                         st.measured += 1\n                     }\n@@ -708,11 +724,11 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Res\n             PadOnRight => t.desc.name.as_slice().len(),\n         }\n     }\n-    match tests.iter().max_by_key(|t|len_if_padded(*t)) {\n+    match tests.iter().max_by_key(|t| len_if_padded(*t)) {\n         Some(t) => {\n             let n = t.desc.name.as_slice();\n             st.max_name_len = n.len();\n-        },\n+        }\n         None => {}\n     }\n     try!(run_tests(opts, tests, |x| callback(&x, &mut st)));\n@@ -724,13 +740,13 @@ fn should_sort_failures_before_printing_them() {\n     let test_a = TestDesc {\n         name: StaticTestName(\"a\"),\n         ignore: false,\n-        should_panic: ShouldPanic::No\n+        should_panic: ShouldPanic::No,\n     };\n \n     let test_b = TestDesc {\n         name: StaticTestName(\"b\"),\n         ignore: false,\n-        should_panic: ShouldPanic::No\n+        should_panic: ShouldPanic::No,\n     };\n \n     let mut st = ConsoleTestState {\n@@ -744,13 +760,13 @@ fn should_sort_failures_before_printing_them() {\n         measured: 0,\n         max_name_len: 10,\n         metrics: MetricMap::new(),\n-        failures: vec!((test_b, Vec::new()), (test_a, Vec::new()))\n+        failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n     };\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n         Raw(ref m) => String::from_utf8_lossy(&m[..]),\n-        Pretty(_) => unreachable!()\n+        Pretty(_) => unreachable!(),\n     };\n \n     let apos = s.find(\"a\").unwrap();\n@@ -790,18 +806,16 @@ fn stdout_isatty() -> bool {\n \n #[derive(Clone)]\n enum TestEvent {\n-    TeFiltered(Vec<TestDesc> ),\n+    TeFiltered(Vec<TestDesc>),\n     TeWait(TestDesc, NamePadding),\n-    TeResult(TestDesc, TestResult, Vec<u8> ),\n+    TeResult(TestDesc, TestResult, Vec<u8>),\n }\n \n-pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n+pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n \n \n-fn run_tests<F>(opts: &TestOpts,\n-                tests: Vec<TestDescAndFn> ,\n-                mut callback: F) -> io::Result<()> where\n-    F: FnMut(TestEvent) -> io::Result<()>,\n+fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n+    where F: FnMut(TestEvent) -> io::Result<()>\n {\n     let mut filtered_tests = filter_tests(opts, tests);\n     if !opts.bench_benchmarks {\n@@ -818,7 +832,7 @@ fn run_tests<F>(opts: &TestOpts,\n         filtered_tests.into_iter().partition(|e| {\n             match e.testfn {\n                 StaticTestFn(_) | DynTestFn(_) => true,\n-                _ => false\n+                _ => false,\n             }\n         });\n \n@@ -873,7 +887,10 @@ fn get_concurrency() -> usize {\n             let opt_n: Option<usize> = s.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", s)\n+                _ => {\n+                    panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n+                           s)\n+                }\n             }\n         }\n         Err(..) => num_cpus(),\n@@ -911,9 +928,7 @@ fn get_concurrency() -> usize {\n               target_os = \"ios\",\n               target_os = \"android\"))]\n     fn num_cpus() -> usize {\n-        unsafe {\n-            libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize\n-        }\n+        unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n     }\n \n     #[cfg(any(target_os = \"freebsd\",\n@@ -926,18 +941,22 @@ fn get_concurrency() -> usize {\n         let mut mib = [libc::CTL_HW, libc::HW_AVAILCPU, 0, 0];\n \n         unsafe {\n-            libc::sysctl(mib.as_mut_ptr(), 2,\n+            libc::sysctl(mib.as_mut_ptr(),\n+                         2,\n                          &mut cpus as *mut _ as *mut _,\n                          &mut cpus_size as *mut _ as *mut _,\n-                         0 as *mut _, 0);\n+                         0 as *mut _,\n+                         0);\n         }\n         if cpus < 1 {\n             mib[1] = libc::HW_NCPU;\n             unsafe {\n-                libc::sysctl(mib.as_mut_ptr(), 2,\n+                libc::sysctl(mib.as_mut_ptr(),\n+                             2,\n                              &mut cpus as *mut _ as *mut _,\n                              &mut cpus_size as *mut _ as *mut _,\n-                             0 as *mut _, 0);\n+                             0 as *mut _,\n+                             0);\n             }\n             if cpus < 1 {\n                 cpus = 1;\n@@ -953,10 +972,12 @@ fn get_concurrency() -> usize {\n         let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n \n         unsafe {\n-            libc::sysctl(mib.as_mut_ptr(), 2,\n+            libc::sysctl(mib.as_mut_ptr(),\n+                         2,\n                          &mut cpus as *mut _ as *mut _,\n                          &mut cpus_size as *mut _ as *mut _,\n-                         0 as *mut _, 0);\n+                         0 as *mut _,\n+                         0);\n         }\n         if cpus < 1 {\n             cpus = 1;\n@@ -972,9 +993,9 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     filtered = match opts.filter {\n         None => filtered,\n         Some(ref filter) => {\n-            filtered.into_iter().filter(|test| {\n-                test.desc.name.as_slice().contains(&filter[..])\n-            }).collect()\n+            filtered.into_iter()\n+                    .filter(|test| test.desc.name.as_slice().contains(&filter[..]))\n+                    .collect()\n         }\n     };\n \n@@ -986,8 +1007,8 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n             if test.desc.ignore {\n                 let TestDescAndFn {desc, testfn} = test;\n                 Some(TestDescAndFn {\n-                    desc: TestDesc {ignore: false, ..desc},\n-                    testfn: testfn\n+                    desc: TestDesc { ignore: false, ..desc },\n+                    testfn: testfn,\n                 })\n             } else {\n                 None\n@@ -1004,18 +1025,23 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n \n pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     // convert benchmarks to tests, if we're not benchmarking them\n-    tests.into_iter().map(|x| {\n-        let testfn = match x.testfn {\n-            DynBenchFn(bench) => {\n-                DynTestFn(Box::new(move || bench::run_once(|b| bench.run(b))))\n-            }\n-            StaticBenchFn(benchfn) => {\n-                DynTestFn(Box::new(move || bench::run_once(|b| benchfn(b))))\n-            }\n-            f => f\n-        };\n-        TestDescAndFn { desc: x.desc, testfn: testfn }\n-    }).collect()\n+    tests.into_iter()\n+         .map(|x| {\n+             let testfn = match x.testfn {\n+                 DynBenchFn(bench) => {\n+                     DynTestFn(Box::new(move || bench::run_once(|b| bench.run(b))))\n+                 }\n+                 StaticBenchFn(benchfn) => {\n+                     DynTestFn(Box::new(move || bench::run_once(|b| benchfn(b))))\n+                 }\n+                 f => f,\n+             };\n+             TestDescAndFn {\n+                 desc: x.desc,\n+                 testfn: testfn,\n+             }\n+         })\n+         .collect()\n }\n \n pub fn run_test(opts: &TestOpts,\n@@ -1039,7 +1065,9 @@ pub fn run_test(opts: &TestOpts,\n             fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n                 Write::write(&mut *self.0.lock().unwrap(), data)\n             }\n-            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+            fn flush(&mut self) -> io::Result<()> {\n+                Ok(())\n+            }\n         }\n \n         thread::spawn(move || {\n@@ -1051,12 +1079,13 @@ pub fn run_test(opts: &TestOpts,\n             });\n \n             let result_guard = cfg.spawn(move || {\n-                if !nocapture {\n-                    io::set_print(box Sink(data2.clone()));\n-                    io::set_panic(box Sink(data2));\n-                }\n-                testfn()\n-            }).unwrap();\n+                                      if !nocapture {\n+                                          io::set_print(box Sink(data2.clone()));\n+                                          io::set_panic(box Sink(data2));\n+                                      }\n+                                      testfn()\n+                                  })\n+                                  .unwrap();\n             let test_result = calc_result(&desc, result_guard.join());\n             let stdout = data.lock().unwrap().to_vec();\n             monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n@@ -1087,27 +1116,25 @@ pub fn run_test(opts: &TestOpts,\n             return;\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, f),\n-        StaticTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture,\n-                                          Box::new(f))\n+        StaticTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(f)),\n     }\n }\n \n-fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any+Send>>) -> TestResult {\n+fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any + Send>>) -> TestResult {\n     match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) |\n         (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err))\n             if err.downcast_ref::<String>()\n-                .map(|e| &**e)\n-                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n-                .map(|e| e.contains(msg))\n-                .unwrap_or(false) => TrOk,\n+               .map(|e| &**e)\n+               .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n+               .map(|e| e.contains(msg))\n+               .unwrap_or(false) => TrOk,\n         _ => TrFailed,\n     }\n }\n \n impl MetricMap {\n-\n     pub fn new() -> MetricMap {\n         MetricMap(BTreeMap::new())\n     }\n@@ -1128,18 +1155,17 @@ impl MetricMap {\n     pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n         let m = Metric {\n             value: value,\n-            noise: noise\n+            noise: noise,\n         };\n         let MetricMap(ref mut map) = *self;\n         map.insert(name.to_owned(), m);\n     }\n \n     pub fn fmt_metrics(&self) -> String {\n         let MetricMap(ref mm) = *self;\n-        let v : Vec<String> = mm.iter()\n-            .map(|(k,v)| format!(\"{}: {} (+/- {})\", *k,\n-                                 v.value, v.noise))\n-            .collect();\n+        let v: Vec<String> = mm.iter()\n+                               .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n+                               .collect();\n         v.join(\", \")\n     }\n }\n@@ -1156,17 +1182,21 @@ impl MetricMap {\n pub fn black_box<T>(dummy: T) -> T {\n     // we need to \"use\" the argument in some way LLVM can't\n     // introspect.\n-    unsafe {asm!(\"\" : : \"r\"(&dummy))}\n+    unsafe { asm!(\"\" : : \"r\"(&dummy)) }\n     dummy\n }\n #[cfg(all(target_os = \"nacl\", target_arch = \"le32\"))]\n #[inline(never)]\n-pub fn black_box<T>(dummy: T) -> T { dummy }\n+pub fn black_box<T>(dummy: T) -> T {\n+    dummy\n+}\n \n \n impl Bencher {\n     /// Callback for benchmark functions to run in their body.\n-    pub fn iter<T, F>(&mut self, mut inner: F) where F: FnMut() -> T {\n+    pub fn iter<T, F>(&mut self, mut inner: F)\n+        where F: FnMut() -> T\n+    {\n         let start = Instant::now();\n         let k = self.iterations;\n         for _ in 0..k {\n@@ -1187,13 +1217,17 @@ impl Bencher {\n         }\n     }\n \n-    pub fn bench_n<F>(&mut self, n: u64, f: F) where F: FnOnce(&mut Bencher) {\n+    pub fn bench_n<F>(&mut self, n: u64, f: F)\n+        where F: FnOnce(&mut Bencher)\n+    {\n         self.iterations = n;\n         f(self);\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary where F: FnMut(&mut Bencher) {\n+    pub fn auto_bench<F>(&mut self, mut f: F) -> stats::Summary\n+        where F: FnMut(&mut Bencher)\n+    {\n         // Initial bench run to get ballpark figure.\n         let mut n = 1;\n         self.bench_n(n, |x| f(x));\n@@ -1210,35 +1244,36 @@ impl Bencher {\n         // side effect of not being able to do as many runs is\n         // automatically handled by the statistical analysis below\n         // (i.e. larger error bars).\n-        if n == 0 { n = 1; }\n+        if n == 0 {\n+            n = 1;\n+        }\n \n         let mut total_run = Duration::new(0, 0);\n-        let samples : &mut [f64] = &mut [0.0_f64; 50];\n+        let samples: &mut [f64] = &mut [0.0_f64; 50];\n         loop {\n             let loop_start = Instant::now();\n \n             for p in &mut *samples {\n                 self.bench_n(n, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n-            };\n+            }\n \n             stats::winsorize(samples, 5.0);\n             let summ = stats::Summary::new(samples);\n \n             for p in &mut *samples {\n                 self.bench_n(5 * n, |x| f(x));\n                 *p = self.ns_per_iter() as f64;\n-            };\n+            }\n \n             stats::winsorize(samples, 5.0);\n             let summ5 = stats::Summary::new(samples);\n             let loop_run = loop_start.elapsed();\n \n             // If we've run for 100ms and seem to have converged to a\n             // stable median.\n-            if loop_run > Duration::from_millis(100) &&\n-                summ.median_abs_dev_pct < 1.0 &&\n-                summ.median - summ5.median < summ5.median_abs_dev {\n+            if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0 &&\n+               summ.median - summ5.median < summ5.median_abs_dev {\n                 return summ5;\n             }\n \n@@ -1265,11 +1300,13 @@ pub mod bench {\n     use std::time::Duration;\n     use super::{Bencher, BenchSamples};\n \n-    pub fn benchmark<F>(f: F) -> BenchSamples where F: FnMut(&mut Bencher) {\n+    pub fn benchmark<F>(f: F) -> BenchSamples\n+        where F: FnMut(&mut Bencher)\n+    {\n         let mut bs = Bencher {\n             iterations: 0,\n             dur: Duration::new(0, 0),\n-            bytes: 0\n+            bytes: 0,\n         };\n \n         let ns_iter_summ = bs.auto_bench(f);\n@@ -1279,38 +1316,40 @@ pub mod bench {\n \n         BenchSamples {\n             ns_iter_summ: ns_iter_summ,\n-            mb_s: mb_s as usize\n+            mb_s: mb_s as usize,\n         }\n     }\n \n-    pub fn run_once<F>(f: F) where F: FnOnce(&mut Bencher) {\n+    pub fn run_once<F>(f: F)\n+        where F: FnOnce(&mut Bencher)\n+    {\n         let mut bs = Bencher {\n             iterations: 0,\n             dur: Duration::new(0, 0),\n-            bytes: 0\n+            bytes: 0,\n         };\n         bs.bench_n(1, f);\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts,\n-               TestDesc, TestDescAndFn, TestOpts, run_test,\n-               MetricMap,\n-               StaticTestName, DynTestName, DynTestFn, ShouldPanic};\n+    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc, TestDescAndFn,\n+               TestOpts, run_test, MetricMap, StaticTestName, DynTestName, DynTestFn, ShouldPanic};\n     use std::sync::mpsc::channel;\n \n     #[test]\n     pub fn do_not_run_ignored_tests() {\n-        fn f() { panic!(); }\n+        fn f() {\n+            panic!();\n+        }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n             },\n-            testfn: DynTestFn(Box::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move || f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1320,14 +1359,14 @@ mod tests {\n \n     #[test]\n     pub fn ignored_tests_result_in_ignored() {\n-        fn f() { }\n+        fn f() {}\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n             },\n-            testfn: DynTestFn(Box::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move || f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1337,14 +1376,16 @@ mod tests {\n \n     #[test]\n     fn test_should_panic() {\n-        fn f() { panic!(); }\n+        fn f() {\n+            panic!();\n+        }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes,\n             },\n-            testfn: DynTestFn(Box::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move || f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1354,14 +1395,16 @@ mod tests {\n \n     #[test]\n     fn test_should_panic_good_message() {\n-        fn f() { panic!(\"an error message\"); }\n+        fn f() {\n+            panic!(\"an error message\");\n+        }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n             },\n-            testfn: DynTestFn(Box::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move || f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1371,14 +1414,16 @@ mod tests {\n \n     #[test]\n     fn test_should_panic_bad_message() {\n-        fn f() { panic!(\"an error message\"); }\n+        fn f() {\n+            panic!(\"an error message\");\n+        }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::YesWithMessage(\"foobar\"),\n             },\n-            testfn: DynTestFn(Box::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move || f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1388,14 +1433,14 @@ mod tests {\n \n     #[test]\n     fn test_should_panic_but_succeeds() {\n-        fn f() { }\n+        fn f() {}\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes,\n             },\n-            testfn: DynTestFn(Box::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move || f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1405,12 +1450,10 @@ mod tests {\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = vec!(\"progname\".to_string(),\n-                        \"filter\".to_string(),\n-                        \"--ignored\".to_string());\n+        let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--ignored\".to_string()];\n         let opts = match parse_opts(&args) {\n             Some(Ok(o)) => o,\n-            _ => panic!(\"Malformed arg in parse_ignored_flag\")\n+            _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n         };\n         assert!((opts.run_ignored));\n     }\n@@ -1424,28 +1467,26 @@ mod tests {\n         opts.run_tests = true;\n         opts.run_ignored = true;\n \n-        let tests = vec!(\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                },\n-                testfn: DynTestFn(Box::new(move|| {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                },\n-                testfn: DynTestFn(Box::new(move|| {})),\n-            });\n+        let tests = vec![TestDescAndFn {\n+                             desc: TestDesc {\n+                                 name: StaticTestName(\"1\"),\n+                                 ignore: true,\n+                                 should_panic: ShouldPanic::No,\n+                             },\n+                             testfn: DynTestFn(Box::new(move || {})),\n+                         },\n+                         TestDescAndFn {\n+                             desc: TestDesc {\n+                                 name: StaticTestName(\"2\"),\n+                                 ignore: false,\n+                                 should_panic: ShouldPanic::No,\n+                             },\n+                             testfn: DynTestFn(Box::new(move || {})),\n+                         }];\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered[0].desc.name.to_string(),\n-                   \"1\");\n+        assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n         assert!(filtered[0].desc.ignore == false);\n     }\n \n@@ -1454,19 +1495,17 @@ mod tests {\n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n \n-        let names =\n-            vec!(\"sha1::test\".to_string(),\n-                 \"isize::test_to_str\".to_string(),\n-                 \"isize::test_pow\".to_string(),\n-                 \"test::do_not_run_ignored_tests\".to_string(),\n-                 \"test::ignored_tests_result_in_ignored\".to_string(),\n-                 \"test::first_free_arg_should_be_a_filter\".to_string(),\n-                 \"test::parse_ignored_flag\".to_string(),\n-                 \"test::filter_for_ignored_option\".to_string(),\n-                 \"test::sort_tests\".to_string());\n-        let tests =\n-        {\n-            fn testfn() { }\n+        let names = vec![\"sha1::test\".to_string(),\n+                         \"isize::test_to_str\".to_string(),\n+                         \"isize::test_pow\".to_string(),\n+                         \"test::do_not_run_ignored_tests\".to_string(),\n+                         \"test::ignored_tests_result_in_ignored\".to_string(),\n+                         \"test::first_free_arg_should_be_a_filter\".to_string(),\n+                         \"test::parse_ignored_flag\".to_string(),\n+                         \"test::filter_for_ignored_option\".to_string(),\n+                         \"test::sort_tests\".to_string()];\n+        let tests = {\n+            fn testfn() {}\n             let mut tests = Vec::new();\n             for name in &names {\n                 let test = TestDescAndFn {\n@@ -1483,16 +1522,15 @@ mod tests {\n         };\n         let filtered = filter_tests(&opts, tests);\n \n-        let expected =\n-            vec!(\"isize::test_pow\".to_string(),\n-                 \"isize::test_to_str\".to_string(),\n-                 \"sha1::test\".to_string(),\n-                 \"test::do_not_run_ignored_tests\".to_string(),\n-                 \"test::filter_for_ignored_option\".to_string(),\n-                 \"test::first_free_arg_should_be_a_filter\".to_string(),\n-                 \"test::ignored_tests_result_in_ignored\".to_string(),\n-                 \"test::parse_ignored_flag\".to_string(),\n-                 \"test::sort_tests\".to_string());\n+        let expected = vec![\"isize::test_pow\".to_string(),\n+                            \"isize::test_to_str\".to_string(),\n+                            \"sha1::test\".to_string(),\n+                            \"test::do_not_run_ignored_tests\".to_string(),\n+                            \"test::filter_for_ignored_option\".to_string(),\n+                            \"test::first_free_arg_should_be_a_filter\".to_string(),\n+                            \"test::ignored_tests_result_in_ignored\".to_string(),\n+                            \"test::parse_ignored_flag\".to_string(),\n+                            \"test::sort_tests\".to_string()];\n \n         for (a, b) in expected.iter().zip(filtered) {\n             assert!(*a == b.desc.name.to_string());"}, {"sha": "335b6d67209dedcde22a3ecbcaf0a1cc0298094d", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 262, "deletions": 291, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/ced5a8594053ab3eb15f9e317604f696402f4860/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced5a8594053ab3eb15f9e317604f696402f4860/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=ced5a8594053ab3eb15f9e317604f696402f4860", "patch": "@@ -111,7 +111,7 @@ pub trait Stats {\n     /// is otherwise equivalent.\n     ///\n     /// See also: https://en.wikipedia.org/wiki/Quartile\n-    fn quartiles(&self) -> (f64,f64,f64);\n+    fn quartiles(&self) -> (f64, f64, f64);\n \n     /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n     /// percentile (3rd quartile). See `quartiles`.\n@@ -134,7 +134,7 @@ pub struct Summary {\n     pub std_dev_pct: f64,\n     pub median_abs_dev: f64,\n     pub median_abs_dev_pct: f64,\n-    pub quartiles: (f64,f64,f64),\n+    pub quartiles: (f64, f64, f64),\n     pub iqr: f64,\n }\n \n@@ -153,7 +153,7 @@ impl Summary {\n             median_abs_dev: samples.median_abs_dev(),\n             median_abs_dev_pct: samples.median_abs_dev_pct(),\n             quartiles: samples.quartiles(),\n-            iqr: samples.iqr()\n+            iqr: samples.iqr(),\n         }\n     }\n }\n@@ -187,7 +187,7 @@ impl Stats for [f64] {\n                 partials.push(x);\n             } else {\n                 partials[j] = x;\n-                partials.truncate(j+1);\n+                partials.truncate(j + 1);\n             }\n         }\n         let zero: f64 = 0.0;\n@@ -221,13 +221,13 @@ impl Stats for [f64] {\n             let mut v: f64 = 0.0;\n             for s in self {\n                 let x = *s - mean;\n-                v = v + x*x;\n+                v = v + x * x;\n             }\n             // NB: this is _supposed to be_ len-1, not len. If you\n             // change it back to len, you will be calculating a\n             // population variance, not a sample variance.\n             let denom = (self.len() - 1) as f64;\n-            v/denom\n+            v / denom\n         }\n     }\n \n@@ -260,7 +260,7 @@ impl Stats for [f64] {\n         percentile_of_sorted(&tmp, pct)\n     }\n \n-    fn quartiles(&self) -> (f64,f64,f64) {\n+    fn quartiles(&self) -> (f64, f64, f64) {\n         let mut tmp = self.to_vec();\n         local_sort(&mut tmp);\n         let first = 25f64;\n@@ -269,11 +269,11 @@ impl Stats for [f64] {\n         let b = percentile_of_sorted(&tmp, secound);\n         let third = 75f64;\n         let c = percentile_of_sorted(&tmp, third);\n-        (a,b,c)\n+        (a, b, c)\n     }\n \n     fn iqr(&self) -> f64 {\n-        let (a,_,c) = self.quartiles();\n+        let (a, _, c) = self.quartiles();\n         c - a\n     }\n }\n@@ -299,7 +299,7 @@ fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n     let d = rank - lrank;\n     let n = lrank as usize;\n     let lo = sorted_samples[n];\n-    let hi = sorted_samples[n+1];\n+    let hi = sorted_samples[n + 1];\n     lo + (hi - lo) * d\n }\n \n@@ -316,7 +316,7 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n     local_sort(&mut tmp);\n     let lo = percentile_of_sorted(&tmp, pct);\n     let hundred = 100 as f64;\n-    let hi = percentile_of_sorted(&tmp, hundred-pct);\n+    let hi = percentile_of_sorted(&tmp, hundred - pct);\n     for samp in samples {\n         if *samp > hi {\n             *samp = hi\n@@ -380,10 +380,7 @@ mod tests {\n \n     #[test]\n     fn test_norm2() {\n-        let val = &[\n-            958.0000000000,\n-            924.0000000000,\n-        ];\n+        let val = &[958.0000000000, 924.0000000000];\n         let summ = &Summary {\n             sum: 1882.0000000000,\n             min: 924.0000000000,\n@@ -395,25 +392,23 @@ mod tests {\n             std_dev_pct: 2.5549022912,\n             median_abs_dev: 25.2042000000,\n             median_abs_dev_pct: 2.6784484591,\n-            quartiles: (932.5000000000,941.0000000000,949.5000000000),\n+            quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n             iqr: 17.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_norm10narrow() {\n-        let val = &[\n-            966.0000000000,\n-            985.0000000000,\n-            1110.0000000000,\n-            848.0000000000,\n-            821.0000000000,\n-            975.0000000000,\n-            962.0000000000,\n-            1157.0000000000,\n-            1217.0000000000,\n-            955.0000000000,\n-        ];\n+        let val = &[966.0000000000,\n+                    985.0000000000,\n+                    1110.0000000000,\n+                    848.0000000000,\n+                    821.0000000000,\n+                    975.0000000000,\n+                    962.0000000000,\n+                    1157.0000000000,\n+                    1217.0000000000,\n+                    955.0000000000];\n         let summ = &Summary {\n             sum: 9996.0000000000,\n             min: 821.0000000000,\n@@ -425,25 +420,23 @@ mod tests {\n             std_dev_pct: 12.6742097933,\n             median_abs_dev: 102.2994000000,\n             median_abs_dev_pct: 10.5408964451,\n-            quartiles: (956.7500000000,970.5000000000,1078.7500000000),\n+            quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n             iqr: 122.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_norm10medium() {\n-        let val = &[\n-            954.0000000000,\n-            1064.0000000000,\n-            855.0000000000,\n-            1000.0000000000,\n-            743.0000000000,\n-            1084.0000000000,\n-            704.0000000000,\n-            1023.0000000000,\n-            357.0000000000,\n-            869.0000000000,\n-        ];\n+        let val = &[954.0000000000,\n+                    1064.0000000000,\n+                    855.0000000000,\n+                    1000.0000000000,\n+                    743.0000000000,\n+                    1084.0000000000,\n+                    704.0000000000,\n+                    1023.0000000000,\n+                    357.0000000000,\n+                    869.0000000000];\n         let summ = &Summary {\n             sum: 8653.0000000000,\n             min: 357.0000000000,\n@@ -455,25 +448,23 @@ mod tests {\n             std_dev_pct: 25.4846418487,\n             median_abs_dev: 195.7032000000,\n             median_abs_dev_pct: 21.4704552935,\n-            quartiles: (771.0000000000,911.5000000000,1017.2500000000),\n+            quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n             iqr: 246.2500000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_norm10wide() {\n-        let val = &[\n-            505.0000000000,\n-            497.0000000000,\n-            1591.0000000000,\n-            887.0000000000,\n-            1026.0000000000,\n-            136.0000000000,\n-            1580.0000000000,\n-            940.0000000000,\n-            754.0000000000,\n-            1433.0000000000,\n-        ];\n+        let val = &[505.0000000000,\n+                    497.0000000000,\n+                    1591.0000000000,\n+                    887.0000000000,\n+                    1026.0000000000,\n+                    136.0000000000,\n+                    1580.0000000000,\n+                    940.0000000000,\n+                    754.0000000000,\n+                    1433.0000000000];\n         let summ = &Summary {\n             sum: 9349.0000000000,\n             min: 136.0000000000,\n@@ -485,40 +476,38 @@ mod tests {\n             std_dev_pct: 52.3146817750,\n             median_abs_dev: 611.5725000000,\n             median_abs_dev_pct: 66.9482758621,\n-            quartiles: (567.2500000000,913.5000000000,1331.2500000000),\n+            quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n             iqr: 764.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_norm25verynarrow() {\n-        let val = &[\n-            991.0000000000,\n-            1018.0000000000,\n-            998.0000000000,\n-            1013.0000000000,\n-            974.0000000000,\n-            1007.0000000000,\n-            1014.0000000000,\n-            999.0000000000,\n-            1011.0000000000,\n-            978.0000000000,\n-            985.0000000000,\n-            999.0000000000,\n-            983.0000000000,\n-            982.0000000000,\n-            1015.0000000000,\n-            1002.0000000000,\n-            977.0000000000,\n-            948.0000000000,\n-            1040.0000000000,\n-            974.0000000000,\n-            996.0000000000,\n-            989.0000000000,\n-            1015.0000000000,\n-            994.0000000000,\n-            1024.0000000000,\n-        ];\n+        let val = &[991.0000000000,\n+                    1018.0000000000,\n+                    998.0000000000,\n+                    1013.0000000000,\n+                    974.0000000000,\n+                    1007.0000000000,\n+                    1014.0000000000,\n+                    999.0000000000,\n+                    1011.0000000000,\n+                    978.0000000000,\n+                    985.0000000000,\n+                    999.0000000000,\n+                    983.0000000000,\n+                    982.0000000000,\n+                    1015.0000000000,\n+                    1002.0000000000,\n+                    977.0000000000,\n+                    948.0000000000,\n+                    1040.0000000000,\n+                    974.0000000000,\n+                    996.0000000000,\n+                    989.0000000000,\n+                    1015.0000000000,\n+                    994.0000000000,\n+                    1024.0000000000];\n         let summ = &Summary {\n             sum: 24926.0000000000,\n             min: 948.0000000000,\n@@ -530,25 +519,23 @@ mod tests {\n             std_dev_pct: 1.9888308788,\n             median_abs_dev: 22.2390000000,\n             median_abs_dev_pct: 2.2283567134,\n-            quartiles: (983.0000000000,998.0000000000,1013.0000000000),\n+            quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n             iqr: 30.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_exp10a() {\n-        let val = &[\n-            23.0000000000,\n-            11.0000000000,\n-            2.0000000000,\n-            57.0000000000,\n-            4.0000000000,\n-            12.0000000000,\n-            5.0000000000,\n-            29.0000000000,\n-            3.0000000000,\n-            21.0000000000,\n-        ];\n+        let val = &[23.0000000000,\n+                    11.0000000000,\n+                    2.0000000000,\n+                    57.0000000000,\n+                    4.0000000000,\n+                    12.0000000000,\n+                    5.0000000000,\n+                    29.0000000000,\n+                    3.0000000000,\n+                    21.0000000000];\n         let summ = &Summary {\n             sum: 167.0000000000,\n             min: 2.0000000000,\n@@ -560,25 +547,23 @@ mod tests {\n             std_dev_pct: 101.5828843560,\n             median_abs_dev: 13.3434000000,\n             median_abs_dev_pct: 116.0295652174,\n-            quartiles: (4.2500000000,11.5000000000,22.5000000000),\n+            quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n             iqr: 18.2500000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_exp10b() {\n-        let val = &[\n-            24.0000000000,\n-            17.0000000000,\n-            6.0000000000,\n-            38.0000000000,\n-            25.0000000000,\n-            7.0000000000,\n-            51.0000000000,\n-            2.0000000000,\n-            61.0000000000,\n-            32.0000000000,\n-        ];\n+        let val = &[24.0000000000,\n+                    17.0000000000,\n+                    6.0000000000,\n+                    38.0000000000,\n+                    25.0000000000,\n+                    7.0000000000,\n+                    51.0000000000,\n+                    2.0000000000,\n+                    61.0000000000,\n+                    32.0000000000];\n         let summ = &Summary {\n             sum: 263.0000000000,\n             min: 2.0000000000,\n@@ -590,25 +575,23 @@ mod tests {\n             std_dev_pct: 74.4671410520,\n             median_abs_dev: 22.9803000000,\n             median_abs_dev_pct: 93.7971428571,\n-            quartiles: (9.5000000000,24.5000000000,36.5000000000),\n+            quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n             iqr: 27.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_exp10c() {\n-        let val = &[\n-            71.0000000000,\n-            2.0000000000,\n-            32.0000000000,\n-            1.0000000000,\n-            6.0000000000,\n-            28.0000000000,\n-            13.0000000000,\n-            37.0000000000,\n-            16.0000000000,\n-            36.0000000000,\n-        ];\n+        let val = &[71.0000000000,\n+                    2.0000000000,\n+                    32.0000000000,\n+                    1.0000000000,\n+                    6.0000000000,\n+                    28.0000000000,\n+                    13.0000000000,\n+                    37.0000000000,\n+                    16.0000000000,\n+                    36.0000000000];\n         let summ = &Summary {\n             sum: 242.0000000000,\n             min: 1.0000000000,\n@@ -620,40 +603,38 @@ mod tests {\n             std_dev_pct: 88.4507754589,\n             median_abs_dev: 21.4977000000,\n             median_abs_dev_pct: 97.7168181818,\n-            quartiles: (7.7500000000,22.0000000000,35.0000000000),\n+            quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n             iqr: 27.2500000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_exp25() {\n-        let val = &[\n-            3.0000000000,\n-            24.0000000000,\n-            1.0000000000,\n-            19.0000000000,\n-            7.0000000000,\n-            5.0000000000,\n-            30.0000000000,\n-            39.0000000000,\n-            31.0000000000,\n-            13.0000000000,\n-            25.0000000000,\n-            48.0000000000,\n-            1.0000000000,\n-            6.0000000000,\n-            42.0000000000,\n-            63.0000000000,\n-            2.0000000000,\n-            12.0000000000,\n-            108.0000000000,\n-            26.0000000000,\n-            1.0000000000,\n-            7.0000000000,\n-            44.0000000000,\n-            25.0000000000,\n-            11.0000000000,\n-        ];\n+        let val = &[3.0000000000,\n+                    24.0000000000,\n+                    1.0000000000,\n+                    19.0000000000,\n+                    7.0000000000,\n+                    5.0000000000,\n+                    30.0000000000,\n+                    39.0000000000,\n+                    31.0000000000,\n+                    13.0000000000,\n+                    25.0000000000,\n+                    48.0000000000,\n+                    1.0000000000,\n+                    6.0000000000,\n+                    42.0000000000,\n+                    63.0000000000,\n+                    2.0000000000,\n+                    12.0000000000,\n+                    108.0000000000,\n+                    26.0000000000,\n+                    1.0000000000,\n+                    7.0000000000,\n+                    44.0000000000,\n+                    25.0000000000,\n+                    11.0000000000];\n         let summ = &Summary {\n             sum: 593.0000000000,\n             min: 1.0000000000,\n@@ -665,40 +646,38 @@ mod tests {\n             std_dev_pct: 103.3565983562,\n             median_abs_dev: 19.2738000000,\n             median_abs_dev_pct: 101.4410526316,\n-            quartiles: (6.0000000000,19.0000000000,31.0000000000),\n+            quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n             iqr: 25.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_binom25() {\n-        let val = &[\n-            18.0000000000,\n-            17.0000000000,\n-            27.0000000000,\n-            15.0000000000,\n-            21.0000000000,\n-            25.0000000000,\n-            17.0000000000,\n-            24.0000000000,\n-            25.0000000000,\n-            24.0000000000,\n-            26.0000000000,\n-            26.0000000000,\n-            23.0000000000,\n-            15.0000000000,\n-            23.0000000000,\n-            17.0000000000,\n-            18.0000000000,\n-            18.0000000000,\n-            21.0000000000,\n-            16.0000000000,\n-            15.0000000000,\n-            31.0000000000,\n-            20.0000000000,\n-            17.0000000000,\n-            15.0000000000,\n-        ];\n+        let val = &[18.0000000000,\n+                    17.0000000000,\n+                    27.0000000000,\n+                    15.0000000000,\n+                    21.0000000000,\n+                    25.0000000000,\n+                    17.0000000000,\n+                    24.0000000000,\n+                    25.0000000000,\n+                    24.0000000000,\n+                    26.0000000000,\n+                    26.0000000000,\n+                    23.0000000000,\n+                    15.0000000000,\n+                    23.0000000000,\n+                    17.0000000000,\n+                    18.0000000000,\n+                    18.0000000000,\n+                    21.0000000000,\n+                    16.0000000000,\n+                    15.0000000000,\n+                    31.0000000000,\n+                    20.0000000000,\n+                    17.0000000000,\n+                    15.0000000000];\n         let summ = &Summary {\n             sum: 514.0000000000,\n             min: 15.0000000000,\n@@ -710,40 +689,38 @@ mod tests {\n             std_dev_pct: 22.2037202539,\n             median_abs_dev: 5.9304000000,\n             median_abs_dev_pct: 29.6520000000,\n-            quartiles: (17.0000000000,20.0000000000,24.0000000000),\n+            quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n             iqr: 7.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_pois25lambda30() {\n-        let val = &[\n-            27.0000000000,\n-            33.0000000000,\n-            34.0000000000,\n-            34.0000000000,\n-            24.0000000000,\n-            39.0000000000,\n-            28.0000000000,\n-            27.0000000000,\n-            31.0000000000,\n-            28.0000000000,\n-            38.0000000000,\n-            21.0000000000,\n-            33.0000000000,\n-            36.0000000000,\n-            29.0000000000,\n-            37.0000000000,\n-            32.0000000000,\n-            34.0000000000,\n-            31.0000000000,\n-            39.0000000000,\n-            25.0000000000,\n-            31.0000000000,\n-            32.0000000000,\n-            40.0000000000,\n-            24.0000000000,\n-        ];\n+        let val = &[27.0000000000,\n+                    33.0000000000,\n+                    34.0000000000,\n+                    34.0000000000,\n+                    24.0000000000,\n+                    39.0000000000,\n+                    28.0000000000,\n+                    27.0000000000,\n+                    31.0000000000,\n+                    28.0000000000,\n+                    38.0000000000,\n+                    21.0000000000,\n+                    33.0000000000,\n+                    36.0000000000,\n+                    29.0000000000,\n+                    37.0000000000,\n+                    32.0000000000,\n+                    34.0000000000,\n+                    31.0000000000,\n+                    39.0000000000,\n+                    25.0000000000,\n+                    31.0000000000,\n+                    32.0000000000,\n+                    40.0000000000,\n+                    24.0000000000];\n         let summ = &Summary {\n             sum: 787.0000000000,\n             min: 21.0000000000,\n@@ -755,40 +732,38 @@ mod tests {\n             std_dev_pct: 16.3814245145,\n             median_abs_dev: 5.9304000000,\n             median_abs_dev_pct: 18.5325000000,\n-            quartiles: (28.0000000000,32.0000000000,34.0000000000),\n+            quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n             iqr: 6.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_pois25lambda40() {\n-        let val = &[\n-            42.0000000000,\n-            50.0000000000,\n-            42.0000000000,\n-            46.0000000000,\n-            34.0000000000,\n-            45.0000000000,\n-            34.0000000000,\n-            49.0000000000,\n-            39.0000000000,\n-            28.0000000000,\n-            40.0000000000,\n-            35.0000000000,\n-            37.0000000000,\n-            39.0000000000,\n-            46.0000000000,\n-            44.0000000000,\n-            32.0000000000,\n-            45.0000000000,\n-            42.0000000000,\n-            37.0000000000,\n-            48.0000000000,\n-            42.0000000000,\n-            33.0000000000,\n-            42.0000000000,\n-            48.0000000000,\n-        ];\n+        let val = &[42.0000000000,\n+                    50.0000000000,\n+                    42.0000000000,\n+                    46.0000000000,\n+                    34.0000000000,\n+                    45.0000000000,\n+                    34.0000000000,\n+                    49.0000000000,\n+                    39.0000000000,\n+                    28.0000000000,\n+                    40.0000000000,\n+                    35.0000000000,\n+                    37.0000000000,\n+                    39.0000000000,\n+                    46.0000000000,\n+                    44.0000000000,\n+                    32.0000000000,\n+                    45.0000000000,\n+                    42.0000000000,\n+                    37.0000000000,\n+                    48.0000000000,\n+                    42.0000000000,\n+                    33.0000000000,\n+                    42.0000000000,\n+                    48.0000000000];\n         let summ = &Summary {\n             sum: 1019.0000000000,\n             min: 28.0000000000,\n@@ -800,40 +775,38 @@ mod tests {\n             std_dev_pct: 14.3978417577,\n             median_abs_dev: 5.9304000000,\n             median_abs_dev_pct: 14.1200000000,\n-            quartiles: (37.0000000000,42.0000000000,45.0000000000),\n+            quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n             iqr: 8.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_pois25lambda50() {\n-        let val = &[\n-            45.0000000000,\n-            43.0000000000,\n-            44.0000000000,\n-            61.0000000000,\n-            51.0000000000,\n-            53.0000000000,\n-            59.0000000000,\n-            52.0000000000,\n-            49.0000000000,\n-            51.0000000000,\n-            51.0000000000,\n-            50.0000000000,\n-            49.0000000000,\n-            56.0000000000,\n-            42.0000000000,\n-            52.0000000000,\n-            51.0000000000,\n-            43.0000000000,\n-            48.0000000000,\n-            48.0000000000,\n-            50.0000000000,\n-            42.0000000000,\n-            43.0000000000,\n-            42.0000000000,\n-            60.0000000000,\n-        ];\n+        let val = &[45.0000000000,\n+                    43.0000000000,\n+                    44.0000000000,\n+                    61.0000000000,\n+                    51.0000000000,\n+                    53.0000000000,\n+                    59.0000000000,\n+                    52.0000000000,\n+                    49.0000000000,\n+                    51.0000000000,\n+                    51.0000000000,\n+                    50.0000000000,\n+                    49.0000000000,\n+                    56.0000000000,\n+                    42.0000000000,\n+                    52.0000000000,\n+                    51.0000000000,\n+                    43.0000000000,\n+                    48.0000000000,\n+                    48.0000000000,\n+                    50.0000000000,\n+                    42.0000000000,\n+                    43.0000000000,\n+                    42.0000000000,\n+                    60.0000000000];\n         let summ = &Summary {\n             sum: 1235.0000000000,\n             min: 42.0000000000,\n@@ -845,40 +818,38 @@ mod tests {\n             std_dev_pct: 11.3913245723,\n             median_abs_dev: 4.4478000000,\n             median_abs_dev_pct: 8.8956000000,\n-            quartiles: (44.0000000000,50.0000000000,52.0000000000),\n+            quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n             iqr: 8.0000000000,\n         };\n         check(val, summ);\n     }\n     #[test]\n     fn test_unif25() {\n-        let val = &[\n-            99.0000000000,\n-            55.0000000000,\n-            92.0000000000,\n-            79.0000000000,\n-            14.0000000000,\n-            2.0000000000,\n-            33.0000000000,\n-            49.0000000000,\n-            3.0000000000,\n-            32.0000000000,\n-            84.0000000000,\n-            59.0000000000,\n-            22.0000000000,\n-            86.0000000000,\n-            76.0000000000,\n-            31.0000000000,\n-            29.0000000000,\n-            11.0000000000,\n-            41.0000000000,\n-            53.0000000000,\n-            45.0000000000,\n-            44.0000000000,\n-            98.0000000000,\n-            98.0000000000,\n-            7.0000000000,\n-        ];\n+        let val = &[99.0000000000,\n+                    55.0000000000,\n+                    92.0000000000,\n+                    79.0000000000,\n+                    14.0000000000,\n+                    2.0000000000,\n+                    33.0000000000,\n+                    49.0000000000,\n+                    3.0000000000,\n+                    32.0000000000,\n+                    84.0000000000,\n+                    59.0000000000,\n+                    22.0000000000,\n+                    86.0000000000,\n+                    76.0000000000,\n+                    31.0000000000,\n+                    29.0000000000,\n+                    11.0000000000,\n+                    41.0000000000,\n+                    53.0000000000,\n+                    45.0000000000,\n+                    44.0000000000,\n+                    98.0000000000,\n+                    98.0000000000,\n+                    7.0000000000];\n         let summ = &Summary {\n             sum: 1242.0000000000,\n             min: 2.0000000000,\n@@ -890,7 +861,7 @@ mod tests {\n             std_dev_pct: 64.1488719719,\n             median_abs_dev: 45.9606000000,\n             median_abs_dev_pct: 102.1346666667,\n-            quartiles: (29.0000000000,45.0000000000,79.0000000000),\n+            quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n             iqr: 50.0000000000,\n         };\n         check(val, summ);\n@@ -920,7 +891,7 @@ mod bench {\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n-        let v = (0..500).map(|i| nums[i%5]).collect::<Vec<_>>();\n+        let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n \n         b.iter(|| {\n             v.sum();"}]}