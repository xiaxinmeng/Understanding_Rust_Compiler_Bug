{"sha": "949c96660c32ff9b19a639b4be607938c2262653", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0OWM5NjY2MGMzMmZmOWIxOWE2MzliNGJlNjA3OTM4YzIyNjI2NTM=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-09-08T21:29:36Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-09-21T19:50:26Z"}, "message": "move format! interface tests", "tree": {"sha": "b3559a199bebaacda5d8903c1f832c4fd265cfb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3559a199bebaacda5d8903c1f832c4fd265cfb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/949c96660c32ff9b19a639b4be607938c2262653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/949c96660c32ff9b19a639b4be607938c2262653", "html_url": "https://github.com/rust-lang/rust/commit/949c96660c32ff9b19a639b4be607938c2262653", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/949c96660c32ff9b19a639b4be607938c2262653/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85b2d9bf6f2b04ae8996050b2fb276bd58cd92de", "url": "https://api.github.com/repos/rust-lang/rust/commits/85b2d9bf6f2b04ae8996050b2fb276bd58cd92de", "html_url": "https://github.com/rust-lang/rust/commit/85b2d9bf6f2b04ae8996050b2fb276bd58cd92de"}], "stats": {"total": 642, "additions": 322, "deletions": 320}, "files": [{"sha": "6fd6468c3cea1995763cde2958268a5854b88142", "filename": "library/alloc/tests/fmt.rs", "status": "modified", "additions": 322, "deletions": 1, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/949c96660c32ff9b19a639b4be607938c2262653/library%2Falloc%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949c96660c32ff9b19a639b4be607938c2262653/library%2Falloc%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Ffmt.rs?ref=949c96660c32ff9b19a639b4be607938c2262653", "patch": "@@ -1,7 +1,328 @@\n-use std::fmt;\n+#![deny(warnings)]\n+#![allow(unused_must_use)]\n+\n+use std::cell::RefCell;\n+use std::fmt::{self, Write};\n \n #[test]\n fn test_format() {\n     let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n     assert_eq!(s, \"Hello, world!\");\n }\n+\n+struct A;\n+struct B;\n+struct C;\n+struct D;\n+\n+impl fmt::LowerHex for A {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"aloha\")\n+    }\n+}\n+impl fmt::UpperHex for B {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"adios\")\n+    }\n+}\n+impl fmt::Display for C {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad_integral(true, \"\u2603\", \"123\")\n+    }\n+}\n+impl fmt::Binary for D {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"aa\")?;\n+        f.write_char('\u2603')?;\n+        f.write_str(\"bb\")\n+    }\n+}\n+\n+macro_rules! t {\n+    ($a:expr, $b:expr) => {\n+        assert_eq!($a, $b)\n+    };\n+}\n+\n+#[test]\n+fn test_format_macro_interface() {\n+    // Various edge cases without formats\n+    t!(format!(\"\"), \"\");\n+    t!(format!(\"hello\"), \"hello\");\n+    t!(format!(\"hello {{\"), \"hello {\");\n+\n+    // default formatters should work\n+    t!(format!(\"{}\", 1.0f32), \"1\");\n+    t!(format!(\"{}\", 1.0f64), \"1\");\n+    t!(format!(\"{}\", \"a\"), \"a\");\n+    t!(format!(\"{}\", \"a\".to_string()), \"a\");\n+    t!(format!(\"{}\", false), \"false\");\n+    t!(format!(\"{}\", 'a'), \"a\");\n+\n+    // At least exercise all the formats\n+    t!(format!(\"{}\", true), \"true\");\n+    t!(format!(\"{}\", '\u2603'), \"\u2603\");\n+    t!(format!(\"{}\", 10), \"10\");\n+    t!(format!(\"{}\", 10_usize), \"10\");\n+    t!(format!(\"{:?}\", '\u2603'), \"'\u2603'\");\n+    t!(format!(\"{:?}\", 10), \"10\");\n+    t!(format!(\"{:?}\", 10_usize), \"10\");\n+    t!(format!(\"{:?}\", \"true\"), \"\\\"true\\\"\");\n+    t!(format!(\"{:?}\", \"foo\\nbar\"), \"\\\"foo\\\\nbar\\\"\");\n+    t!(\n+        format!(\"{:?}\", \"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"),\n+        r#\"\"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"\"#\n+    );\n+    t!(format!(\"{:?}\", \"foo\\0bar\\x01baz\\u{7f}q\\u{75}x\"), r#\"\"foo\\u{0}bar\\u{1}baz\\u{7f}qux\"\"#);\n+    t!(format!(\"{:o}\", 10_usize), \"12\");\n+    t!(format!(\"{:x}\", 10_usize), \"a\");\n+    t!(format!(\"{:X}\", 10_usize), \"A\");\n+    t!(format!(\"{}\", \"foo\"), \"foo\");\n+    t!(format!(\"{}\", \"foo\".to_string()), \"foo\");\n+    if cfg!(target_pointer_width = \"32\") {\n+        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x00001234\");\n+        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x00001234\");\n+    } else {\n+        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x0000000000001234\");\n+        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x0000000000001234\");\n+    }\n+    t!(format!(\"{:p}\", 0x1234 as *const isize), \"0x1234\");\n+    t!(format!(\"{:p}\", 0x1234 as *mut isize), \"0x1234\");\n+    t!(format!(\"{:x}\", A), \"aloha\");\n+    t!(format!(\"{:X}\", B), \"adios\");\n+    t!(format!(\"foo {} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t!(format!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t!(format!(\"{foo} {bar}\", foo = 0, bar = 1), \"0 1\");\n+    t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo = 2, bar = 3), \"2 1 3 0\");\n+    t!(format!(\"{} {0}\", \"a\"), \"a a\");\n+    t!(format!(\"{_foo}\", _foo = 6usize), \"6\");\n+    t!(format!(\"{foo_bar}\", foo_bar = 1), \"1\");\n+    t!(format!(\"{}\", 5 + 5), \"10\");\n+    t!(format!(\"{:#4}\", C), \"\u2603123\");\n+    t!(format!(\"{:b}\", D), \"aa\u2603bb\");\n+\n+    let a: &dyn fmt::Debug = &1;\n+    t!(format!(\"{:?}\", a), \"1\");\n+\n+    // Formatting strings and their arguments\n+    t!(format!(\"{}\", \"a\"), \"a\");\n+    t!(format!(\"{:4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4}\", \"\u2603\"), \"\u2603   \");\n+    t!(format!(\"{:>4}\", \"a\"), \"   a\");\n+    t!(format!(\"{:<4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:^5}\", \"a\"), \"  a  \");\n+    t!(format!(\"{:^5}\", \"aa\"), \" aa  \");\n+    t!(format!(\"{:^4}\", \"a\"), \" a  \");\n+    t!(format!(\"{:^4}\", \"aa\"), \" aa \");\n+    t!(format!(\"{:.4}\", \"a\"), \"a\");\n+    t!(format!(\"{:4.4}\", \"a\"), \"a   \");\n+    t!(format!(\"{:4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:<4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:^4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:>10.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"      aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaaa\"), \"aaaa\");\n+    t!(format!(\"{:2.4}\", \"aaa\"), \"aaa\");\n+    t!(format!(\"{:2.4}\", \"aa\"), \"aa\");\n+    t!(format!(\"{:2.4}\", \"a\"), \"a \");\n+    t!(format!(\"{:0>2}\", \"a\"), \"0a\");\n+    t!(format!(\"{:.*}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(format!(\"{:.1$}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(format!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a = 4), \"aaaa\");\n+    t!(format!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a = 4), \"aaaa\");\n+    t!(format!(\"{:1$}\", \"a\", 4), \"a   \");\n+    t!(format!(\"{1:0$}\", 4, \"a\"), \"a   \");\n+    t!(format!(\"{:a$}\", \"a\", a = 4), \"a   \");\n+    t!(format!(\"{:-#}\", \"a\"), \"a\");\n+    t!(format!(\"{:+#}\", \"a\"), \"a\");\n+    t!(format!(\"{:/^10.8}\", \"1234567890\"), \"/12345678/\");\n+\n+    // Some float stuff\n+    t!(format!(\"{:}\", 1.0f32), \"1\");\n+    t!(format!(\"{:}\", 1.0f64), \"1\");\n+    t!(format!(\"{:.3}\", 1.0f64), \"1.000\");\n+    t!(format!(\"{:10.3}\", 1.0f64), \"     1.000\");\n+    t!(format!(\"{:+10.3}\", 1.0f64), \"    +1.000\");\n+    t!(format!(\"{:+10.3}\", -1.0f64), \"    -1.000\");\n+\n+    t!(format!(\"{:e}\", 1.2345e6f32), \"1.2345e6\");\n+    t!(format!(\"{:e}\", 1.2345e6f64), \"1.2345e6\");\n+    t!(format!(\"{:E}\", 1.2345e6f64), \"1.2345E6\");\n+    t!(format!(\"{:.3e}\", 1.2345e6f64), \"1.234e6\");\n+    t!(format!(\"{:10.3e}\", 1.2345e6f64), \"   1.234e6\");\n+    t!(format!(\"{:+10.3e}\", 1.2345e6f64), \"  +1.234e6\");\n+    t!(format!(\"{:+10.3e}\", -1.2345e6f64), \"  -1.234e6\");\n+\n+    // Float edge cases\n+    t!(format!(\"{}\", -0.0), \"0\");\n+    t!(format!(\"{:?}\", -0.0), \"-0.0\");\n+    t!(format!(\"{:?}\", 0.0), \"0.0\");\n+\n+    // sign aware zero padding\n+    t!(format!(\"{:<3}\", 1), \"1  \");\n+    t!(format!(\"{:>3}\", 1), \"  1\");\n+    t!(format!(\"{:^3}\", 1), \" 1 \");\n+    t!(format!(\"{:03}\", 1), \"001\");\n+    t!(format!(\"{:<03}\", 1), \"001\");\n+    t!(format!(\"{:>03}\", 1), \"001\");\n+    t!(format!(\"{:^03}\", 1), \"001\");\n+    t!(format!(\"{:+03}\", 1), \"+01\");\n+    t!(format!(\"{:<+03}\", 1), \"+01\");\n+    t!(format!(\"{:>+03}\", 1), \"+01\");\n+    t!(format!(\"{:^+03}\", 1), \"+01\");\n+    t!(format!(\"{:#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:<#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:>#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:^#05x}\", 1), \"0x001\");\n+    t!(format!(\"{:05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:<05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:>05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:^05}\", 1.2), \"001.2\");\n+    t!(format!(\"{:05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:<05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:>05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:^05}\", -1.2), \"-01.2\");\n+    t!(format!(\"{:+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:<+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:>+05}\", 1.2), \"+01.2\");\n+    t!(format!(\"{:^+05}\", 1.2), \"+01.2\");\n+\n+    // Ergonomic format_args!\n+    t!(format!(\"{0:x} {0:X}\", 15), \"f F\");\n+    t!(format!(\"{0:x} {0:X} {}\", 15), \"f F 15\");\n+    t!(format!(\"{:x}{0:X}{a:x}{:X}{1:x}{a:X}\", 13, 14, a = 15), \"dDfEeF\");\n+    t!(format!(\"{a:x} {a:X}\", a = 15), \"f F\");\n+\n+    // And its edge cases\n+    t!(\n+        format!(\n+            \"{a:.0$} {b:.0$} {0:.0$}\\n{a:.c$} {b:.c$} {c:.c$}\",\n+            4,\n+            a = \"abcdefg\",\n+            b = \"hijklmn\",\n+            c = 3\n+        ),\n+        \"abcd hijk 4\\nabc hij 3\"\n+    );\n+    t!(format!(\"{a:.*} {0} {:.*}\", 4, 3, \"efgh\", a = \"abcdef\"), \"abcd 4 efg\");\n+    t!(format!(\"{:.a$} {a} {a:#x}\", \"aaaaaa\", a = 2), \"aa 2 0x2\");\n+\n+    // Test that pointers don't get truncated.\n+    {\n+        let val = usize::MAX;\n+        let exp = format!(\"{:#x}\", val);\n+        t!(format!(\"{:p}\", val as *const isize), exp);\n+    }\n+\n+    // Escaping\n+    t!(format!(\"{{\"), \"{\");\n+    t!(format!(\"}}\"), \"}\");\n+\n+    // make sure that format! doesn't move out of local variables\n+    let a = Box::new(3);\n+    format!(\"{}\", a);\n+    format!(\"{}\", a);\n+\n+    // make sure that format! doesn't cause spurious unused-unsafe warnings when\n+    // it's inside of an outer unsafe block\n+    unsafe {\n+        let a: isize = ::std::mem::transmute(3_usize);\n+        format!(\"{}\", a);\n+    }\n+\n+    // test that trailing commas are acceptable\n+    format!(\"{}\", \"test\",);\n+    format!(\"{foo}\", foo = \"test\",);\n+}\n+\n+// Basic test to make sure that we can invoke the `write!` macro with an\n+// fmt::Write instance.\n+#[test]\n+fn test_write() {\n+    let mut buf = String::new();\n+    write!(&mut buf, \"{}\", 3);\n+    {\n+        let w = &mut buf;\n+        write!(w, \"{foo}\", foo = 4);\n+        write!(w, \"{}\", \"hello\");\n+        writeln!(w, \"{}\", \"line\");\n+        writeln!(w, \"{foo}\", foo = \"bar\");\n+        w.write_char('\u2603');\n+        w.write_str(\"str\");\n+    }\n+\n+    t!(buf, \"34helloline\\nbar\\n\u2603str\");\n+}\n+\n+// Just make sure that the macros are defined, there's not really a lot that we\n+// can do with them just yet (to test the output)\n+#[test]\n+fn test_print() {\n+    print!(\"hi\");\n+    print!(\"{:?}\", vec![0u8]);\n+    println!(\"hello\");\n+    println!(\"this is a {}\", \"test\");\n+    println!(\"{foo}\", foo = \"bar\");\n+}\n+\n+// Just make sure that the macros are defined, there's not really a lot that we\n+// can do with them just yet (to test the output)\n+#[test]\n+fn test_format_args() {\n+    let mut buf = String::new();\n+    {\n+        let w = &mut buf;\n+        write!(w, \"{}\", format_args!(\"{}\", 1));\n+        write!(w, \"{}\", format_args!(\"test\"));\n+        write!(w, \"{}\", format_args!(\"{test}\", test = 3));\n+    }\n+    let s = buf;\n+    t!(s, \"1test3\");\n+\n+    let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    t!(s, \"hello world\");\n+    let s = format!(\"{}: {}\", \"args were\", format_args!(\"hello {}\", \"world\"));\n+    t!(s, \"args were: hello world\");\n+}\n+\n+#[test]\n+fn test_order() {\n+    // Make sure format!() arguments are always evaluated in a left-to-right\n+    // ordering\n+    fn foo() -> isize {\n+        static mut FOO: isize = 0;\n+        unsafe {\n+            FOO += 1;\n+            FOO\n+        }\n+    }\n+    assert_eq!(\n+        format!(\"{} {} {a} {b} {} {c}\", foo(), foo(), foo(), a = foo(), b = foo(), c = foo()),\n+        \"1 2 4 5 3 6\".to_string()\n+    );\n+}\n+\n+#[test]\n+fn test_once() {\n+    // Make sure each argument are evaluated only once even though it may be\n+    // formatted multiple times\n+    fn foo() -> isize {\n+        static mut FOO: isize = 0;\n+        unsafe {\n+            FOO += 1;\n+            FOO\n+        }\n+    }\n+    assert_eq!(format!(\"{0} {0} {0} {a} {a} {a}\", foo(), a = foo()), \"1 1 1 2 2 2\".to_string());\n+}\n+\n+#[test]\n+fn test_refcell() {\n+    let refcell = RefCell::new(5);\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n+    let borrow = refcell.borrow_mut();\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: <borrowed> }\");\n+    drop(borrow);\n+    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n+}"}, {"sha": "27ab3d6b7abffe921e2a30ad1fc9b74987341b41", "filename": "src/test/ui/ifmt.rs", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/85b2d9bf6f2b04ae8996050b2fb276bd58cd92de/src%2Ftest%2Fui%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b2d9bf6f2b04ae8996050b2fb276bd58cd92de/src%2Ftest%2Fui%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt.rs?ref=85b2d9bf6f2b04ae8996050b2fb276bd58cd92de", "patch": "@@ -1,319 +0,0 @@\n-// run-pass\n-\n-#![deny(warnings)]\n-#![allow(unused_must_use)]\n-#![allow(unused_features)]\n-#![feature(box_syntax)]\n-\n-use std::cell::RefCell;\n-use std::fmt::{self, Write};\n-use std::usize;\n-\n-struct A;\n-struct B;\n-struct C;\n-struct D;\n-\n-impl fmt::LowerHex for A {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"aloha\")\n-    }\n-}\n-impl fmt::UpperHex for B {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"adios\")\n-    }\n-}\n-impl fmt::Display for C {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad_integral(true, \"\u2603\", \"123\")\n-    }\n-}\n-impl fmt::Binary for D {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"aa\")?;\n-        f.write_char('\u2603')?;\n-        f.write_str(\"bb\")\n-    }\n-}\n-\n-macro_rules! t {\n-    ($a:expr, $b:expr) => { assert_eq!($a, $b) }\n-}\n-\n-pub fn main() {\n-    // Various edge cases without formats\n-    t!(format!(\"\"), \"\");\n-    t!(format!(\"hello\"), \"hello\");\n-    t!(format!(\"hello {{\"), \"hello {\");\n-\n-    // default formatters should work\n-    t!(format!(\"{}\", 1.0f32), \"1\");\n-    t!(format!(\"{}\", 1.0f64), \"1\");\n-    t!(format!(\"{}\", \"a\"), \"a\");\n-    t!(format!(\"{}\", \"a\".to_string()), \"a\");\n-    t!(format!(\"{}\", false), \"false\");\n-    t!(format!(\"{}\", 'a'), \"a\");\n-\n-    // At least exercise all the formats\n-    t!(format!(\"{}\", true), \"true\");\n-    t!(format!(\"{}\", '\u2603'), \"\u2603\");\n-    t!(format!(\"{}\", 10), \"10\");\n-    t!(format!(\"{}\", 10_usize), \"10\");\n-    t!(format!(\"{:?}\", '\u2603'), \"'\u2603'\");\n-    t!(format!(\"{:?}\", 10), \"10\");\n-    t!(format!(\"{:?}\", 10_usize), \"10\");\n-    t!(format!(\"{:?}\", \"true\"), \"\\\"true\\\"\");\n-    t!(format!(\"{:?}\", \"foo\\nbar\"), \"\\\"foo\\\\nbar\\\"\");\n-    t!(format!(\"{:?}\", \"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"),\n-       r#\"\"foo\\n\\\"bar\\\"\\r\\n\\'baz\\'\\t\\\\qux\\\\\"\"#);\n-    t!(format!(\"{:?}\", \"foo\\0bar\\x01baz\\u{7f}q\\u{75}x\"),\n-       r#\"\"foo\\u{0}bar\\u{1}baz\\u{7f}qux\"\"#);\n-    t!(format!(\"{:o}\", 10_usize), \"12\");\n-    t!(format!(\"{:x}\", 10_usize), \"a\");\n-    t!(format!(\"{:X}\", 10_usize), \"A\");\n-    t!(format!(\"{}\", \"foo\"), \"foo\");\n-    t!(format!(\"{}\", \"foo\".to_string()), \"foo\");\n-    if cfg!(target_pointer_width = \"32\") {\n-        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x00001234\");\n-        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x00001234\");\n-    } else {\n-        t!(format!(\"{:#p}\", 0x1234 as *const isize), \"0x0000000000001234\");\n-        t!(format!(\"{:#p}\", 0x1234 as *mut isize), \"0x0000000000001234\");\n-    }\n-    t!(format!(\"{:p}\", 0x1234 as *const isize), \"0x1234\");\n-    t!(format!(\"{:p}\", 0x1234 as *mut isize), \"0x1234\");\n-    t!(format!(\"{:x}\", A), \"aloha\");\n-    t!(format!(\"{:X}\", B), \"adios\");\n-    t!(format!(\"foo {} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n-    t!(format!(\"{1} {0}\", 0, 1), \"1 0\");\n-    t!(format!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n-    t!(format!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n-    t!(format!(\"{} {0}\", \"a\"), \"a a\");\n-    t!(format!(\"{_foo}\", _foo = 6usize), \"6\");\n-    t!(format!(\"{foo_bar}\", foo_bar=1), \"1\");\n-    t!(format!(\"{}\", 5 + 5), \"10\");\n-    t!(format!(\"{:#4}\", C), \"\u2603123\");\n-    t!(format!(\"{:b}\", D), \"aa\u2603bb\");\n-\n-    let a: &dyn fmt::Debug = &1;\n-    t!(format!(\"{:?}\", a), \"1\");\n-\n-    // Formatting strings and their arguments\n-    t!(format!(\"{}\", \"a\"), \"a\");\n-    t!(format!(\"{:4}\", \"a\"), \"a   \");\n-    t!(format!(\"{:4}\", \"\u2603\"), \"\u2603   \");\n-    t!(format!(\"{:>4}\", \"a\"), \"   a\");\n-    t!(format!(\"{:<4}\", \"a\"), \"a   \");\n-    t!(format!(\"{:^5}\", \"a\"),  \"  a  \");\n-    t!(format!(\"{:^5}\", \"aa\"), \" aa  \");\n-    t!(format!(\"{:^4}\", \"a\"),  \" a  \");\n-    t!(format!(\"{:^4}\", \"aa\"), \" aa \");\n-    t!(format!(\"{:.4}\", \"a\"), \"a\");\n-    t!(format!(\"{:4.4}\", \"a\"), \"a   \");\n-    t!(format!(\"{:4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:<4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:>4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:^4.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:>10.4}\", \"aaaaaaaaaaaaaaaaaa\"), \"      aaaa\");\n-    t!(format!(\"{:2.4}\", \"aaaaa\"), \"aaaa\");\n-    t!(format!(\"{:2.4}\", \"aaaa\"), \"aaaa\");\n-    t!(format!(\"{:2.4}\", \"aaa\"), \"aaa\");\n-    t!(format!(\"{:2.4}\", \"aa\"), \"aa\");\n-    t!(format!(\"{:2.4}\", \"a\"), \"a \");\n-    t!(format!(\"{:0>2}\", \"a\"), \"0a\");\n-    t!(format!(\"{:.*}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n-    t!(format!(\"{:.1$}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n-    t!(format!(\"{:.a$}\", \"aaaaaaaaaaaaaaaaaa\", a=4), \"aaaa\");\n-    t!(format!(\"{:._a$}\", \"aaaaaaaaaaaaaaaaaa\", _a=4), \"aaaa\");\n-    t!(format!(\"{:1$}\", \"a\", 4), \"a   \");\n-    t!(format!(\"{1:0$}\", 4, \"a\"), \"a   \");\n-    t!(format!(\"{:a$}\", \"a\", a=4), \"a   \");\n-    t!(format!(\"{:-#}\", \"a\"), \"a\");\n-    t!(format!(\"{:+#}\", \"a\"), \"a\");\n-    t!(format!(\"{:/^10.8}\", \"1234567890\"), \"/12345678/\");\n-\n-    // Some float stuff\n-    t!(format!(\"{:}\", 1.0f32), \"1\");\n-    t!(format!(\"{:}\", 1.0f64), \"1\");\n-    t!(format!(\"{:.3}\", 1.0f64), \"1.000\");\n-    t!(format!(\"{:10.3}\", 1.0f64),   \"     1.000\");\n-    t!(format!(\"{:+10.3}\", 1.0f64),  \"    +1.000\");\n-    t!(format!(\"{:+10.3}\", -1.0f64), \"    -1.000\");\n-\n-    t!(format!(\"{:e}\", 1.2345e6f32), \"1.2345e6\");\n-    t!(format!(\"{:e}\", 1.2345e6f64), \"1.2345e6\");\n-    t!(format!(\"{:E}\", 1.2345e6f64), \"1.2345E6\");\n-    t!(format!(\"{:.3e}\", 1.2345e6f64), \"1.234e6\");\n-    t!(format!(\"{:10.3e}\", 1.2345e6f64),   \"   1.234e6\");\n-    t!(format!(\"{:+10.3e}\", 1.2345e6f64),  \"  +1.234e6\");\n-    t!(format!(\"{:+10.3e}\", -1.2345e6f64), \"  -1.234e6\");\n-\n-    // Float edge cases\n-    t!(format!(\"{}\", -0.0), \"0\");\n-    t!(format!(\"{:?}\", -0.0), \"-0.0\");\n-    t!(format!(\"{:?}\", 0.0), \"0.0\");\n-\n-    // sign aware zero padding\n-    t!(format!(\"{:<3}\", 1), \"1  \");\n-    t!(format!(\"{:>3}\", 1), \"  1\");\n-    t!(format!(\"{:^3}\", 1), \" 1 \");\n-    t!(format!(\"{:03}\", 1), \"001\");\n-    t!(format!(\"{:<03}\", 1), \"001\");\n-    t!(format!(\"{:>03}\", 1), \"001\");\n-    t!(format!(\"{:^03}\", 1), \"001\");\n-    t!(format!(\"{:+03}\", 1), \"+01\");\n-    t!(format!(\"{:<+03}\", 1), \"+01\");\n-    t!(format!(\"{:>+03}\", 1), \"+01\");\n-    t!(format!(\"{:^+03}\", 1), \"+01\");\n-    t!(format!(\"{:#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:<#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:>#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:^#05x}\", 1), \"0x001\");\n-    t!(format!(\"{:05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:<05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:>05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:^05}\", 1.2), \"001.2\");\n-    t!(format!(\"{:05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:<05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:>05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:^05}\", -1.2), \"-01.2\");\n-    t!(format!(\"{:+05}\", 1.2), \"+01.2\");\n-    t!(format!(\"{:<+05}\", 1.2), \"+01.2\");\n-    t!(format!(\"{:>+05}\", 1.2), \"+01.2\");\n-    t!(format!(\"{:^+05}\", 1.2), \"+01.2\");\n-\n-    // Ergonomic format_args!\n-    t!(format!(\"{0:x} {0:X}\", 15), \"f F\");\n-    t!(format!(\"{0:x} {0:X} {}\", 15), \"f F 15\");\n-    t!(format!(\"{:x}{0:X}{a:x}{:X}{1:x}{a:X}\", 13, 14, a=15), \"dDfEeF\");\n-    t!(format!(\"{a:x} {a:X}\", a=15), \"f F\");\n-\n-    // And its edge cases\n-    t!(format!(\"{a:.0$} {b:.0$} {0:.0$}\\n{a:.c$} {b:.c$} {c:.c$}\",\n-               4, a=\"abcdefg\", b=\"hijklmn\", c=3),\n-               \"abcd hijk 4\\nabc hij 3\");\n-    t!(format!(\"{a:.*} {0} {:.*}\", 4, 3, \"efgh\", a=\"abcdef\"), \"abcd 4 efg\");\n-    t!(format!(\"{:.a$} {a} {a:#x}\", \"aaaaaa\", a=2), \"aa 2 0x2\");\n-\n-    // Test that pointers don't get truncated.\n-    {\n-        let val = usize::MAX;\n-        let exp = format!(\"{:#x}\", val);\n-        t!(format!(\"{:p}\", val as *const isize), exp);\n-    }\n-\n-    // Escaping\n-    t!(format!(\"{{\"), \"{\");\n-    t!(format!(\"}}\"), \"}\");\n-\n-    test_write();\n-    test_print();\n-    test_order();\n-    test_once();\n-\n-    // make sure that format! doesn't move out of local variables\n-    let a: Box<_> = box 3;\n-    format!(\"{}\", a);\n-    format!(\"{}\", a);\n-\n-    // make sure that format! doesn't cause spurious unused-unsafe warnings when\n-    // it's inside of an outer unsafe block\n-    unsafe {\n-        let a: isize = ::std::mem::transmute(3_usize);\n-        format!(\"{}\", a);\n-    }\n-\n-    test_format_args();\n-\n-    // test that trailing commas are acceptable\n-    format!(\"{}\", \"test\",);\n-    format!(\"{foo}\", foo=\"test\",);\n-\n-    test_refcell();\n-}\n-\n-// Basic test to make sure that we can invoke the `write!` macro with an\n-// fmt::Write instance.\n-fn test_write() {\n-    let mut buf = String::new();\n-    write!(&mut buf, \"{}\", 3);\n-    {\n-        let w = &mut buf;\n-        write!(w, \"{foo}\", foo=4);\n-        write!(w, \"{}\", \"hello\");\n-        writeln!(w, \"{}\", \"line\");\n-        writeln!(w, \"{foo}\", foo=\"bar\");\n-        w.write_char('\u2603');\n-        w.write_str(\"str\");\n-    }\n-\n-    t!(buf, \"34helloline\\nbar\\n\u2603str\");\n-}\n-\n-// Just make sure that the macros are defined, there's not really a lot that we\n-// can do with them just yet (to test the output)\n-fn test_print() {\n-    print!(\"hi\");\n-    print!(\"{:?}\", vec![0u8]);\n-    println!(\"hello\");\n-    println!(\"this is a {}\", \"test\");\n-    println!(\"{foo}\", foo=\"bar\");\n-}\n-\n-// Just make sure that the macros are defined, there's not really a lot that we\n-// can do with them just yet (to test the output)\n-fn test_format_args() {\n-    let mut buf = String::new();\n-    {\n-        let w = &mut buf;\n-        write!(w, \"{}\", format_args!(\"{}\", 1));\n-        write!(w, \"{}\", format_args!(\"test\"));\n-        write!(w, \"{}\", format_args!(\"{test}\", test=3));\n-    }\n-    let s = buf;\n-    t!(s, \"1test3\");\n-\n-    let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n-    t!(s, \"hello world\");\n-    let s = format!(\"{}: {}\", \"args were\", format_args!(\"hello {}\", \"world\"));\n-    t!(s, \"args were: hello world\");\n-}\n-\n-fn test_order() {\n-    // Make sure format!() arguments are always evaluated in a left-to-right\n-    // ordering\n-    fn foo() -> isize {\n-        static mut FOO: isize = 0;\n-        unsafe {\n-            FOO += 1;\n-            FOO\n-        }\n-    }\n-    assert_eq!(format!(\"{} {} {a} {b} {} {c}\",\n-                       foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n-               \"1 2 4 5 3 6\".to_string());\n-}\n-\n-fn test_once() {\n-    // Make sure each argument are evaluated only once even though it may be\n-    // formatted multiple times\n-    fn foo() -> isize {\n-        static mut FOO: isize = 0;\n-        unsafe {\n-            FOO += 1;\n-            FOO\n-        }\n-    }\n-    assert_eq!(format!(\"{0} {0} {0} {a} {a} {a}\", foo(), a=foo()),\n-               \"1 1 1 2 2 2\".to_string());\n-}\n-\n-fn test_refcell() {\n-    let refcell = RefCell::new(5);\n-    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n-    let borrow = refcell.borrow_mut();\n-    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: <borrowed> }\");\n-    drop(borrow);\n-    assert_eq!(format!(\"{:?}\", refcell), \"RefCell { value: 5 }\");\n-}"}]}