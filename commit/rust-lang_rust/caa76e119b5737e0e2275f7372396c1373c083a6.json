{"sha": "caa76e119b5737e0e2275f7372396c1373c083a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYTc2ZTExOWI1NzM3ZTBlMjI3NWY3MzcyMzk2YzEzNzNjMDgzYTY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-07-15T22:25:44Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-07-15T22:26:54Z"}, "message": "Improve docs", "tree": {"sha": "ba0649c721002873acbc782ffd6d3da790cfb3b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba0649c721002873acbc782ffd6d3da790cfb3b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caa76e119b5737e0e2275f7372396c1373c083a6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXiWMuAAoJEF5CfHlMukXoY2kP/1SYTCn/eeIyCzSS1K34geP2\nT5VFejz+hSfZ7N9B3H7CFWUuDwYlOBcDB+TvE2x2HII+gi10E+g9AwGTiZHHwcC3\ntou7UtOvABo+vrclI9naOjAPSt7Z1VAaC+vixK1PU68b4NKrp9uxtKSU/uZW+JoK\ni4EpQJxld16HWpSEbvrwcLWDicEiGzcAM0bCZWuGlIa71pyJRVhc5dmx+PppJDI3\nmMrW8CMFv28Soc1uOpLCHgbRTNY+hTneUhV2z8A+lKWeWZo77elduWmUnqra9+Zs\nU4wbU3EkLSS5hH7eUHJnwMmnwCxOSDJVC6/RInVlbWCo0O7TUhkBhH1gq9pt/ykY\nGTHbg0Eusw0f1kYz8iw6TIf7ozc7BaWHXRMRruNT/ruFB3vo60s3mGS/UFfVA6+p\nvMlnjH2cEihvVmkzZp3egGxG7fHrP4iBN+KK8XHUR04ugzO5hiEAzrg7TyV/ey5w\nTO3CM34rmlYLP4hWGXdAel/RyxbcQnl3eCVBU2D+JlTvHSGARypQI85YmRHifVcO\nOq9gGFFMG7R/x2HO9KCiKqbQfRa7jiiZLk1r24rTjMWsrZgrpIr0cigWn0U1zovq\noqSf9mj0j/dxxG2GdIYZyoQagoVu4B2D0JXB4p449J/3OhB50E/S3JNf15N/81pc\nW883hGJXW1/qIE+VHyH4\n=05zW\n-----END PGP SIGNATURE-----", "payload": "tree ba0649c721002873acbc782ffd6d3da790cfb3b4\nparent 26fdd3f2b77703ff3dcdda349de91f2f416a57df\nauthor mcarton <cartonmartin+git@gmail.com> 1468621544 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1468621614 +0200\n\nImprove docs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caa76e119b5737e0e2275f7372396c1373c083a6", "html_url": "https://github.com/rust-lang/rust/commit/caa76e119b5737e0e2275f7372396c1373c083a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caa76e119b5737e0e2275f7372396c1373c083a6/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26fdd3f2b77703ff3dcdda349de91f2f416a57df", "url": "https://api.github.com/repos/rust-lang/rust/commits/26fdd3f2b77703ff3dcdda349de91f2f416a57df", "html_url": "https://github.com/rust-lang/rust/commit/26fdd3f2b77703ff3dcdda349de91f2f416a57df"}], "stats": {"total": 903, "additions": 666, "deletions": 237}, "files": [{"sha": "11ae1457808fc7f23bc58f008c0d8cfe5430a6df", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -10,7 +10,10 @@ use utils::span_lint;\n ///\n /// **Known problems:** If you happen to have a value that is within 1/8192 of a known constant, but is not *and should not* be the same, this lint will report your value anyway. We have not yet noticed any false positives in code we tested clippy with (this includes servo), but YMMV.\n ///\n-/// **Example:** `let x = 3.14;`\n+/// **Example:**\n+/// ```rust\n+/// let x = 3.14;\n+/// ```\n declare_lint! {\n     pub APPROX_CONSTANT,\n     Warn,"}, {"sha": "2bd0562aebb2cb381f077ffee6eb7f2caee99c2d", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -12,7 +12,7 @@ use utils::span_lint;\n /// **Known problems:** None\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// a + 1\n /// ```\n declare_restriction_lint! {\n@@ -28,7 +28,7 @@ declare_restriction_lint! {\n /// **Known problems:** None\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// a + 1.0\n /// ```\n declare_restriction_lint! {"}, {"sha": "46d13d6c853554ffc1df863abde8440df1d0ee86", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -16,7 +16,7 @@ use utils::{self, higher};\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// let x = [1,2,3,4];\n /// ...\n /// x[9];\n@@ -38,7 +38,7 @@ declare_lint! {\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// ...\n /// x[2];\n /// &x[0..2];"}, {"sha": "f394452e6d2755e71dddb3e009b9395c96f0cc29", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -11,7 +11,7 @@ use utils::{higher, sugg};\n /// **Known problems:** Types implementing `OpAssign` don't necessarily implement `Op`.\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// a += 1;\n /// ```\n declare_restriction_lint! {\n@@ -27,7 +27,7 @@ declare_restriction_lint! {\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// let mut a = 5;\n /// ...\n /// a = a + b;"}, {"sha": "15830392d374751b3eddf4708960ca945a22963b", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -18,7 +18,7 @@ use utils::paths;\n /// **Known problems:** False positives, big time. This lint is meant to be deactivated by everyone doing serious performance work. This means having done the measurement.\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// #[inline(always)]\n /// fn not_quite_hot_code(..) { ... }\n /// ```\n@@ -34,7 +34,7 @@ declare_lint! {\n /// **Known problems:** None\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// #[deprecated(since = \"forever\")]\n /// fn something_else(..) { ... }\n /// ```"}, {"sha": "de555bbd6890439aa09772f727087f701b2a9fa1", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -26,7 +26,10 @@ use utils::span_lint;\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `x & 1 == 2` (also see table above)\n+/// **Example:**\n+/// ```rust\n+/// if (x & 1 == 2) { \u2026 }\n+/// ```\n declare_lint! {\n     pub BAD_BIT_MASK,\n     Warn,\n@@ -45,7 +48,10 @@ declare_lint! {\n ///\n /// **Known problems:** False negatives: This lint will only match instances where we have figured out the math (which is for a power-of-two compared value). This means things like `x | 1 >= 7` (which would be better written as `x >= 6`) will not be reported (but bit masks like this are fairly uncommon).\n ///\n-/// **Example:** `x | 1 > 3` (also see table above)\n+/// **Example:**\n+/// ```rust\n+/// if (x | 1 > 3) { \u2026 }\n+/// ```\n declare_lint! {\n     pub INEFFECTIVE_BIT_MASK,\n     Warn,"}, {"sha": "041ad6d543724b9bbf995eb8e42e93249114b046", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -8,7 +8,10 @@ use utils::span_lint;\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `let foo = 3.14;`\n+/// **Example:**\n+/// ```rust\n+/// let foo = 3.14;\n+/// ```\n declare_lint! {\n     pub BLACKLISTED_NAME,\n     Warn,"}, {"sha": "6d84eca75056752d8cc43614a959fbbe6adb2d93", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,7 +9,10 @@ use utils::*;\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `if { true } ..`\n+/// **Example:**\n+/// ```rust\n+/// if { true } ..\n+/// ```\n declare_lint! {\n     pub BLOCK_IN_IF_CONDITION_EXPR, Warn,\n     \"braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\"\n@@ -21,7 +24,12 @@ declare_lint! {\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `if { let x = somefunc(); x } ..` or `if somefunc(|x| { x == 47 }) ..`\n+/// **Example:**\n+/// ```rust\n+/// if { let x = somefunc(); x } ..\n+/// // or\n+/// if somefunc(|x| { x == 47 }) ..\n+/// ```\n declare_lint! {\n     pub BLOCK_IN_IF_CONDITION_STMT, Warn,\n     \"avoid complex blocks in conditions, instead move the block higher and bind it \\"}, {"sha": "162b42cc0e1951f0dbe37348ffdf7b7d4e2ee4a5", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -6,23 +6,23 @@ use syntax::codemap::{DUMMY_SP, dummy_spanned};\n use syntax::util::ThinVec;\n use utils::{span_lint_and_then, in_macro, snippet_opt, SpanlessEq};\n \n-/// **What it does:** This lint checks for boolean expressions that can be written more concisely\n+/// **What it does:** This lint checks for boolean expressions that can be written more concisely.\n ///\n-/// **Why is this bad?** Readability of boolean expressions suffers from unnecesessary duplication\n+/// **Why is this bad?** Readability of boolean expressions suffers from unnecessary duplication.\n ///\n-/// **Known problems:** Ignores short circuting behavior of `||` and `&&`. Ignores `|`, `&` and `^`.\n+/// **Known problems:** Ignores short circuiting behavior of `||` and `&&`. Ignores `|`, `&` and `^`.\n ///\n /// **Example:** `if a && true` should be `if a` and `!(a == b)` should be `a != b`\n declare_lint! {\n     pub NONMINIMAL_BOOL, Allow,\n     \"checks for boolean expressions that can be written more concisely\"\n }\n \n-/// **What it does:** This lint checks for boolean expressions that contain terminals that can be eliminated\n+/// **What it does:** This lint checks for boolean expressions that contain terminals that can be eliminated.\n ///\n-/// **Why is this bad?** This is most likely a logic bug\n+/// **Why is this bad?** This is most likely a logic bug.\n ///\n-/// **Known problems:** Ignores short circuiting behavior\n+/// **Known problems:** Ignores short circuiting behavior.\n ///\n /// **Example:** The `b` in `if a && b || a` is unnecessary because the expression is equivalent to `if a`\n declare_lint! {"}, {"sha": "5f273c9e950714d8cf037b61e9e23be0b5424bdc", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -26,14 +26,44 @@ use utils::sugg::Sugg;\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `if x { if y { .. } }`\n+/// **Example:**\n+/// ```rust\n+/// if x {\n+///     if y {\n+///         \u2026\n+///     }\n+/// }\n+///\n+/// // or\n+///\n+/// if x {\n+///     \u2026\n+/// } else {\n+///     if y {\n+///         \u2026\n+///     }\n+/// }\n+/// ```\n+///\n+/// Should be written:\n+///\n+/// ```rust\n+/// if x && y {\n+///     \u2026\n+/// }\n+///\n+/// // or\n+///\n+/// if x {\n+///     \u2026\n+/// } else if y {\n+///     \u2026\n+/// }\n+/// ```\n declare_lint! {\n     pub COLLAPSIBLE_IF,\n     Warn,\n-    \"two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` \\\n-     can be written as `if x && y { foo() }` \\\n-     and an `else { if .. }` expression can be collapsed to \\\n-     `else if`\"\n+    \"`if`s that can be collapsed (e.g. `if x { if y { \u2026 } }` and `else { if x { \u2026 } }`)\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "29217dc3171342b3ebf5ac67dc5b223739b94e45", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -8,28 +8,51 @@ use syntax::util::small_vector::SmallVector;\n use utils::{SpanlessEq, SpanlessHash};\n use utils::{get_parent_expr, in_macro, span_lint_and_then, span_note_and_lint, snippet};\n \n-/// **What it does:** This lint checks for consecutive `ifs` with the same condition. This lint is\n-/// `Warn` by default.\n+/// **What it does:** This lint checks for consecutive `ifs` with the same condition.\n ///\n /// **Why is this bad?** This is probably a copy & paste error.\n ///\n /// **Known problems:** Hopefully none.\n ///\n-/// **Example:** `if a == b { .. } else if a == b { .. }`\n+/// **Example:**\n+/// ```rust\n+/// if a == b {\n+///     \u2026\n+/// } else if a == b {\n+///     \u2026\n+/// }\n+/// ```\n+///\n+/// Note that this lint ignores all conditions with a function call as it could have side effects:\n+///\n+/// ```rust\n+/// if foo() {\n+///     \u2026\n+/// } else if foo() { // not linted\n+///     \u2026\n+/// }\n+/// ```\n declare_lint! {\n     pub IFS_SAME_COND,\n     Warn,\n     \"consecutive `ifs` with the same condition\"\n }\n \n /// **What it does:** This lint checks for `if/else` with the same body as the *then* part and the\n-/// *else* part. This lint is `Warn` by default.\n+/// *else* part.\n ///\n /// **Why is this bad?** This is probably a copy & paste error.\n ///\n /// **Known problems:** Hopefully none.\n ///\n-/// **Example:** `if .. { 42 } else { 42 }`\n+/// **Example:**\n+/// ```rust\n+/// let foo = if \u2026 {\n+///     42\n+/// } else {\n+///     42\n+/// };\n+/// ```\n declare_lint! {\n     pub IF_SAME_THEN_ELSE,\n     Warn,"}, {"sha": "675b5e88e8507651ae7a6368522013dee661da90", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -6,13 +6,22 @@ use rustc_const_math::*;\n use rustc::hir::*;\n use utils::span_lint;\n \n-/// **What it does:** Lints on C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`.\n+/// **What it does:** Lints on C-like enumerations that are `repr(isize/usize)` and have values\n+/// that don't fit into an `i32`.\n ///\n-/// **Why is this bad?** This will truncate the variant value on 32bit architectures, but works fine on 64 bit.\n+/// **Why is this bad?** This will truncate the variant value on 32 bit architectures, but works\n+/// fine on 64 bit.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `#[repr(usize)] enum NonPortable { X = 0x1_0000_0000, Y = 0 }`\n+/// **Example:**\n+/// ```rust\n+/// #[repr(usize)]\n+/// enum NonPortable {\n+///     X = 0x1_0000_0000,\n+///     Y = 0\n+/// }\n+/// ```\n declare_lint! {\n     pub ENUM_CLIKE_UNPORTABLE_VARIANT, Warn,\n     \"finds C-like enums that are `repr(isize/usize)` and have values that don't fit into an `i32`\""}, {"sha": "1bdaf7b867fd92b8949448e39c332b328f0cd001", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,13 +9,16 @@ use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;\n \n-/// **What it does:** Warns when `use`ing all variants of an enum\n+/// **What it does:** Warns when `use`ing all variants of an enumeration.\n ///\n-/// **Why is this bad?** It is usually better style to use the prefixed name of an enum variant, rather than importing variants\n+/// **Why is this bad?** It is usually better style to use the prefixed name of an enumeration variant, rather than importing variants\n ///\n-/// **Known problems:** Old-style enums that prefix the variants are still around\n+/// **Known problems:** Old-style enumerations that prefix the variants are still around\n ///\n-/// **Example:** `use std::cmp::Ordering::*;`\n+/// **Example:**\n+/// ```rust\n+/// use std::cmp::Ordering::*;\n+/// ```\n declare_lint! { pub ENUM_GLOB_USE, Allow,\n     \"finds use items that import all variants of an enum\" }\n "}, {"sha": "8278780d9b4746a0893ab3dbb8387ce12a02b251", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -7,13 +7,21 @@ use syntax::parse::token::InternedString;\n use utils::{span_help_and_lint, span_lint};\n use utils::{camel_case_from, camel_case_until, in_macro};\n \n-/// **What it does:** Warns on enum variants that are prefixed or suffixed by the same characters\n+/// **What it does:** Warns on enumeration variants that are prefixed or suffixed by the same\n+/// characters.\n ///\n-/// **Why is this bad?** Enum variant names should specify their variant, not the enum, too.\n+/// **Why is this bad?** Enumeration variant names should specify their variant, not repeat the\n+/// enumeration name.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** enum Cake { BlackForestCake, HummingbirdCake }\n+/// **Example:**\n+/// ```rust\n+/// enum Cake {\n+///     BlackForestCake,\n+///     HummingbirdCake,\n+/// }\n+/// ```\n declare_lint! {\n     pub ENUM_VARIANT_NAMES, Warn,\n     \"finds enums where all variants share a prefix/postfix\"\n@@ -25,7 +33,12 @@ declare_lint! {\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** mod cake { struct BlackForestCake; }\n+/// **Example:**\n+/// ```rust\n+/// mod cake {\n+///     struct BlackForestCake;\n+/// }\n+/// ```\n declare_lint! {\n     pub STUTTER, Allow,\n     \"finds type names prefixed/postfixed with their containing module's name\""}, {"sha": "23c2cc8abdd26e6b681b8c0cc27dbbc2bad8b393", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -8,9 +8,15 @@ use utils::{SpanlessEq, span_lint};\n ///\n /// **Why is this bad?** This is usually just a typo or a copy and paste error.\n ///\n-/// **Known problems:** False negatives: We had some false positives regarding calls (notably [racer](https://github.com/phildawes/racer) had one instance of `x.pop() && x.pop()`), so we removed matching any function or method calls. We may introduce a whitelist of known pure functions in the future.\n+/// **Known problems:** False negatives: We had some false positives regarding calls (notably\n+/// [racer](https://github.com/phildawes/racer) had one instance of `x.pop() && x.pop()`), so we\n+/// removed matching any function or method calls. We may introduce a whitelist of known pure\n+/// functions in the future.\n ///\n-/// **Example:** `x + 1 == x + 1`\n+/// **Example:**\n+/// ```rust\n+/// x + 1 == x + 1\n+/// ```\n declare_lint! {\n     pub EQ_OP,\n     Warn,"}, {"sha": "79dd24516503c4e5df56c1da6a5664b321758d01", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -19,7 +19,8 @@ pub struct Pass {\n \n /// **What it does:** This lint checks for usage of `Box<T>` where an unboxed `T` would work fine.\n ///\n-/// **Why is this bad?** This is an unnecessary allocation, and bad for performance. It is only necessary to allocate if you wish to move the box into something.\n+/// **Why is this bad?** This is an unnecessary allocation, and bad for performance. It is only\n+/// necessary to allocate if you wish to move the box into something.\n ///\n /// **Known problems:** None\n ///"}, {"sha": "4cd9bc8cba687dd9b1fc71848df0888ef6ea1267", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -7,13 +7,17 @@ use utils::{snippet_opt, span_lint_and_then, is_adjusted};\n pub struct EtaPass;\n \n \n-/// **What it does:** This lint checks for closures which just call another function where the function can be called directly. `unsafe` functions or calls where types get adjusted are ignored.\n+/// **What it does:** This lint checks for closures which just call another function where the\n+/// function can be called directly. `unsafe` functions or calls where types get adjusted are\n+/// ignored.\n ///\n-/// **Why is this bad?** Needlessly creating a closure just costs heap space and adds code for no benefit.\n+/// **Why is this bad?** Needlessly creating a closure just costs heap space and adds code for no\n+/// benefit.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `xs.map(|x| foo(x))` where `foo(_)` is a plain function that takes the exact argument type of `x`.\n+/// **Example:** `xs.map(|x| foo(x))` where `foo(_)` is a plain function that takes the exact\n+/// argument type of `x`.\n declare_lint! {\n     pub REDUNDANT_CLOSURE, Warn,\n     \"using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\""}, {"sha": "5ce8420acc0dd3b98313730421029800bd1c6cdc", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,7 +9,8 @@ use utils::{is_expn_of, match_path, match_type, span_lint, walk_ptrs_ty};\n /// **What it does:** This lints about use of `format!(\"string literal with no argument\")` and\n /// `format!(\"{}\", foo)` where `foo` is a string.\n ///\n-/// **Why is this bad?** There is no point of doing that. `format!(\"too\")` can be replaced by `\"foo\".to_owned()` if you really need a `String`. The even worse `&format!(\"foo\")` is often\n+/// **Why is this bad?** There is no point of doing that. `format!(\"too\")` can be replaced by\n+/// `\"foo\".to_owned()` if you really need a `String`. The even worse `&format!(\"foo\")` is often\n /// encountered in the wild. `format!(\"{}\", foo)` can be replaced by `foo.clone()` if `foo: String`\n /// or `foo.to_owned()` is `foo: &str`.\n ///"}, {"sha": "81498d0b6256a8727412569c3786a4fad7daacd3", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -7,11 +7,15 @@ use rustc_const_math::ConstInt;\n \n /// **What it does:** This lint checks for identity operations, e.g. `x + 0`.\n ///\n-/// **Why is this bad?** This code can be removed without changing the meaning. So it just obscures what's going on. Delete it mercilessly.\n+/// **Why is this bad?** This code can be removed without changing the meaning. So it just obscures\n+/// what's going on. Delete it mercilessly.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `x / 1 + 0 * 1 - 0 | 0`\n+/// **Example:**\n+/// ```rust\n+/// x / 1 + 0 * 1 - 0 | 0\n+/// ```\n declare_lint! {\n     pub IDENTITY_OP, Warn,\n     \"using identity operations, e.g. `x + 0` or `y / 1`\""}, {"sha": "1223fb38dbcee8b52d588b9a317a818e6f7de48a", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -11,7 +11,24 @@ use utils::span_help_and_lint;\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** if !v.is_empty() { a() } else { b() }\n+/// **Example:**\n+/// ```rust\n+/// if !v.is_empty() {\n+///     a()\n+/// } else {\n+///     b()\n+/// }\n+/// ```\n+///\n+/// Could be written:\n+///\n+/// ```rust\n+/// if v.is_empty() {\n+///     b()\n+/// } else {\n+///     a()\n+/// }\n+/// ```\n declare_lint! {\n     pub IF_NOT_ELSE, Allow,\n     \"finds if branches that could be swapped so no negation operation is necessary on the condition\""}, {"sha": "d34d87fa2796c782ac93cfc66cb2b8c87b45a8da", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -17,6 +17,7 @@ use utils::{in_macro, span_lint};\n /// fn foo() {\n ///     println!(\"cake\");\n /// }\n+///\n /// fn main() {\n ///     foo(); // prints \"foo\"\n ///     fn foo() {"}, {"sha": "e58bca41845df2fba835e2977a609e6019707934", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -7,13 +7,19 @@ use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n use utils::{get_item_name, in_macro, snippet, span_lint, span_lint_and_then, walk_ptrs_ty};\n \n-/// **What it does:** This lint checks for getting the length of something via `.len()` just to compare to zero, and suggests using `.is_empty()` where applicable.\n+/// **What it does:** This lint checks for getting the length of something via `.len()` just to\n+/// compare to zero, and suggests using `.is_empty()` where applicable.\n ///\n-/// **Why is this bad?** Some structures can answer `.is_empty()` much faster than calculating their length. So it is good to get into the habit of using `.is_empty()`, and having it is cheap. Besides, it makes the intent clearer than a comparison.\n+/// **Why is this bad?** Some structures can answer `.is_empty()` much faster than calculating\n+/// their length. So it is good to get into the habit of using `.is_empty()`, and having it is\n+/// cheap. Besides, it makes the intent clearer than a comparison.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `if x.len() == 0 { .. }`\n+/// **Example:**\n+/// ```rust\n+/// if x.len() == 0 { .. }\n+/// ```\n declare_lint! {\n     pub LEN_ZERO, Warn,\n     \"checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` \\\n@@ -22,12 +28,15 @@ declare_lint! {\n \n /// **What it does:** This lint checks for items that implement `.len()` but not `.is_empty()`.\n ///\n-/// **Why is this bad?** It is good custom to have both methods, because for some data structures, asking about the length will be a costly operation, whereas `.is_empty()` can usually answer in constant time. Also it used to lead to false positives on the [`len_zero`](#len_zero) lint \u2013 currently that lint will ignore such entities.\n+/// **Why is this bad?** It is good custom to have both methods, because for some data structures,\n+/// asking about the length will be a costly operation, whereas `.is_empty()` can usually answer in\n+/// constant time. Also it used to lead to false positives on the [`len_zero`](#len_zero) lint \u2013\n+/// currently that lint will ignore such entities.\n ///\n /// **Known problems:** None\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// impl X {\n ///     fn len(&self) -> usize { .. }\n /// }"}, {"sha": "b5a2c86c938e10c5ff36ab7c714a466841d1adb0", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -7,13 +7,19 @@ use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n use utils::{in_external_macro, span_lint};\n \n-/// **What it does:** This lint checks for lifetime annotations which can be removed by relying on lifetime elision.\n+/// **What it does:** This lint checks for lifetime annotations which can be removed by relying on\n+/// lifetime elision.\n ///\n-/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there is nothing out of the ordinary going on. Removing them leads to more readable code.\n+/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there\n+/// is nothing out of the ordinary going on. Removing them leads to more readable code.\n ///\n-/// **Known problems:** Potential false negatives: we bail out if the function has a `where` clause where lifetimes are mentioned.\n+/// **Known problems:** Potential false negatives: we bail out if the function has a `where` clause\n+/// where lifetimes are mentioned.\n ///\n-/// **Example:** `fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 { x }`\n+/// **Example:**\n+/// ```rust\n+/// fn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 { x }\n+/// ```\n declare_lint! {\n     pub NEEDLESS_LIFETIMES,\n     Warn,\n@@ -23,11 +29,15 @@ declare_lint! {\n \n /// **What it does:** This lint checks for lifetimes in generics that are never used anywhere else.\n ///\n-/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there is nothing out of the ordinary going on. Removing them leads to more readable code.\n+/// **Why is this bad?** The additional lifetimes make the code look more complicated, while there\n+/// is nothing out of the ordinary going on. Removing them leads to more readable code.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `fn unused_lifetime<'a>(x: u8) { .. }`\n+/// **Example:**\n+/// ```rust\n+/// fn unused_lifetime<'a>(x: u8) { .. }\n+/// ```\n declare_lint! {\n     pub UNUSED_LIFETIMES,\n     Warn,"}, {"sha": "44e70a6f2f8bfd8267a34cf65e855d6cd247d52b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 80, "deletions": 22, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -19,14 +19,16 @@ use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n             walk_ptrs_ty};\n use utils::paths;\n \n-/// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index.\n+/// **What it does:** This lint checks for looping over the range of `0..len` of some collection\n+/// just to get the values by index.\n ///\n-/// **Why is this bad?** Just iterating the collection itself makes the intent more clear and is probably faster.\n+/// **Why is this bad?** Just iterating the collection itself makes the intent more clear and is\n+/// probably faster.\n ///\n /// **Known problems:** None\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// for i in 0..vec.len() {\n ///     println!(\"{}\", vec[i]);\n /// }\n@@ -43,7 +45,11 @@ declare_lint! {\n ///\n /// **Known problems:** False negatives. We currently only warn on some known types.\n ///\n-/// **Example:** `for x in y.iter() { .. }` (where y is a `Vec` or slice)\n+/// **Example:**\n+/// ```rust\n+/// // with `y` a `Vec` or slice:\n+/// for x in y.iter() { .. }\n+/// ```\n declare_lint! {\n     pub EXPLICIT_ITER_LOOP,\n     Warn,\n@@ -52,11 +58,18 @@ declare_lint! {\n \n /// **What it does:** This lint checks for loops on `x.next()`.\n ///\n-/// **Why is this bad?** `next()` returns either `Some(value)` if there was a value, or `None` otherwise. The insidious thing is that `Option<_>` implements `IntoIterator`, so that possibly one value will be iterated, leading to some hard to find bugs. No one will want to write such code [except to win an Underhanded Rust Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+/// **Why is this bad?** `next()` returns either `Some(value)` if there was a value, or `None`\n+/// otherwise. The insidious thing is that `Option<_>` implements `IntoIterator`, so that possibly\n+/// one value will be iterated, leading to some hard to find bugs. No one will want to write such\n+/// code [except to win an Underhanded Rust\n+/// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `for x in y.next() { .. }`\n+/// **Example:**\n+/// ```rust\n+/// for x in y.next() { .. }\n+/// ```\n declare_lint! {\n     pub ITER_NEXT_LOOP,\n     Warn,\n@@ -69,7 +82,15 @@ declare_lint! {\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `for x in option { .. }`. This should be `if let Some(x) = option { .. }`.\n+/// **Example:**\n+/// ```rust\n+/// for x in option { .. }\n+/// ```\n+///\n+/// This should be\n+/// ```rust\n+/// if let Some(x) = option { .. }\n+/// ```\n declare_lint! {\n     pub FOR_LOOP_OVER_OPTION,\n     Warn,\n@@ -82,22 +103,31 @@ declare_lint! {\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `for x in result { .. }`. This should be `if let Ok(x) = result { .. }`.\n+/// **Example:**\n+/// ```rust\n+/// for x in result { .. }\n+/// ```\n+///\n+/// This should be\n+/// ```rust\n+/// if let Ok(x) = result { .. }\n+/// ```\n declare_lint! {\n     pub FOR_LOOP_OVER_RESULT,\n     Warn,\n     \"for-looping over a `Result`, which is more clearly expressed as an `if let`\"\n }\n \n-/// **What it does:** This lint detects `loop + match` combinations that are easier written as a `while let` loop.\n+/// **What it does:** This lint detects `loop + match` combinations that are easier written as a\n+/// `while let` loop.\n ///\n /// **Why is this bad?** The `while let` loop is usually shorter and more readable\n ///\n /// **Known problems:** Sometimes the wrong binding is displayed (#383)\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// loop {\n ///     let x = match y {\n ///         Some(x) => x,\n@@ -116,40 +146,58 @@ declare_lint! {\n     \"`loop { if let { ... } else break }` can be written as a `while let` loop\"\n }\n \n-/// **What it does:** This lint checks for using `collect()` on an iterator without using the result.\n+/// **What it does:** This lint checks for using `collect()` on an iterator without using the\n+/// result.\n ///\n /// **Why is this bad?** It is more idiomatic to use a `for` loop over the iterator instead.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();`\n+/// **Example:**\n+/// ```rust\n+/// vec.iter().map(|x| /* some operation returning () */).collect::<Vec<_>>();\n+/// ```\n declare_lint! {\n     pub UNUSED_COLLECT,\n     Warn,\n     \"`collect()`ing an iterator without using the result; this is usually better \\\n      written as a for loop\"\n }\n \n-/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative `.step_by(_)`.\n+/// **What it does:** This lint checks for loops over ranges `x..y` where both `x` and `y` are\n+/// constant and `x` is greater or equal to `y`, unless the range is reversed or has a negative\n+/// `.step_by(_)`.\n ///\n-/// **Why is it bad?** Such loops will either be skipped or loop until wrap-around (in debug code, this may `panic!()`). Both options are probably not intended.\n+/// **Why is it bad?** Such loops will either be skipped or loop until wrap-around (in debug code,\n+/// this may `panic!()`). Both options are probably not intended.\n ///\n-/// **Known problems:** The lint cannot catch loops over dynamically defined ranges. Doing this would require simulating all possible inputs and code paths through the program, which would be complex and error-prone.\n+/// **Known problems:** The lint cannot catch loops over dynamically defined ranges. Doing this\n+/// would require simulating all possible inputs and code paths through the program, which would be\n+/// complex and error-prone.\n ///\n-/// **Examples**: `for x in 5..10-5 { .. }` (oops, stray `-`)\n+/// **Examples**:\n+/// ```rust\n+/// for x in 5..10-5 { .. } // oops, stray `-`\n+/// ```\n declare_lint! {\n     pub REVERSE_RANGE_LOOP,\n     Warn,\n     \"Iterating over an empty range, such as `10..0` or `5..5`\"\n }\n \n-/// **What it does:** This lint checks `for` loops over slices with an explicit counter and suggests the use of `.enumerate()`.\n+/// **What it does:** This lint checks `for` loops over slices with an explicit counter and\n+/// suggests the use of `.enumerate()`.\n ///\n-/// **Why is it bad?** Not only is the version using `.enumerate()` more readable, the compiler is able to remove bounds checks which can lead to faster code in some instances.\n+/// **Why is it bad?** Not only is the version using `.enumerate()` more readable, the compiler is\n+/// able to remove bounds checks which can lead to faster code in some instances.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `for i in 0..v.len() { foo(v[i]); }` or `for i in 0..v.len() { bar(i, v[i]); }`\n+/// **Example:**\n+/// ```rust\n+/// for i in 0..v.len() { foo(v[i]);\n+/// for i in 0..v.len() { bar(i, v[i]); }\n+/// ```\n declare_lint! {\n     pub EXPLICIT_COUNTER_LOOP,\n     Warn,\n@@ -158,11 +206,16 @@ declare_lint! {\n \n /// **What it does:** This lint checks for empty `loop` expressions.\n ///\n-/// **Why is this bad?** Those busy loops burn CPU cycles without doing anything. Think of the environment and either block on something or at least make the thread sleep for some microseconds.\n+/// **Why is this bad?** Those busy loops burn CPU cycles without doing anything. Think of the\n+/// environment and either block on something or at least make the thread sleep for some\n+/// microseconds.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `loop {}`\n+/// **Example:**\n+/// ```rust\n+/// loop {}\n+/// ```\n declare_lint! {\n     pub EMPTY_LOOP,\n     Warn,\n@@ -175,7 +228,10 @@ declare_lint! {\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `while let Some(val) = iter() { .. }`\n+/// **Example:**\n+/// ```rust\n+/// while let Some(val) = iter() { .. }\n+/// ```\n declare_lint! {\n     pub WHILE_LET_ON_ITERATOR,\n     Warn,\n@@ -194,7 +250,9 @@ declare_lint! {\n /// ```rust\n /// for (k, _) in &map { .. }\n /// ```\n+///\n /// could be replaced by\n+///\n /// ```rust\n /// for k in map.keys() { .. }\n /// ```"}, {"sha": "9a1b067ff78ecd03b4a6708112c79b0c811fa66f", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -10,7 +10,10 @@ use utils::{is_adjusted, match_path, match_trait_method, match_type, paths, snip\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `x.map(|e| e.clone());`\n+/// **Example:**\n+/// ```rust\n+/// x.map(|e| e.clone());\n+/// ```\n declare_lint! {\n     pub MAP_CLONE, Warn,\n     \"using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends \\"}, {"sha": "0f1c9755be90f6933a2a4b111b920659f4ffdc60", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -12,14 +12,15 @@ use utils::paths;\n use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n use utils::sugg::Sugg;\n \n-/// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice.\n+/// **What it does:** This lint checks for matches with a single arm where an `if let` will usually\n+/// suffice.\n ///\n /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n ///\n /// **Known problems:** None\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// match x {\n ///     Some(ref foo) -> bar(foo),\n ///     _ => ()\n@@ -31,14 +32,15 @@ declare_lint! {\n      is `_ => {}`) is used; recommends `if let` instead\"\n }\n \n-/// **What it does:** This lint checks for matches with a two arms where an `if let` will usually suffice.\n+/// **What it does:** This lint checks for matches with a two arms where an `if let` will usually\n+/// suffice.\n ///\n /// **Why is this bad?** Just readability \u2013 `if let` nests less than a `match`.\n ///\n /// **Known problems:** Personal style preferences may differ\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// match x {\n ///     Some(ref foo) -> bar(foo),\n ///     _ => bar(other_ref),\n@@ -50,15 +52,18 @@ declare_lint! {\n      recommends `if let` instead\"\n }\n \n-/// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It also checks for `if let &foo = bar` blocks.\n+/// **What it does:** This lint checks for matches where all arms match a reference, suggesting to\n+/// remove the reference and deref the matched expression instead. It also checks for `if let &foo\n+/// = bar` blocks.\n ///\n-/// **Why is this bad?** It just makes the code less readable. That reference destructuring adds nothing to the code.\n+/// **Why is this bad?** It just makes the code less readable. That reference destructuring adds\n+/// nothing to the code.\n ///\n /// **Known problems:** None\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// match x {\n ///     &A(ref y) => foo(y),\n ///     &B => bar(),\n@@ -71,15 +76,16 @@ declare_lint! {\n      dereferenced instead\"\n }\n \n-/// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests to replace the expression with an `if...else` block.\n+/// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests\n+/// to replace the expression with an `if...else` block.\n ///\n /// **Why is this bad?** It makes the code less readable.\n ///\n /// **Known problems:** None\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// let condition: bool = true;\n /// match condition {\n ///     true => foo(),\n@@ -99,7 +105,7 @@ declare_lint! {\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// let x = 5;\n /// match x {\n ///     1 ... 10 => println!(\"1 ... 10\"),"}, {"sha": "716e0fff24ddc895a222f64b63a6c8fb2ee88f1d", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -4,11 +4,15 @@ use utils::{match_def_path, paths, span_lint};\n \n /// **What it does:** This lint checks for usage of `std::mem::forget(t)` where `t` is `Drop`.\n ///\n-/// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its destructor, possibly causing leaks\n+/// **Why is this bad?** `std::mem::forget(t)` prevents `t` from running its destructor, possibly\n+/// causing leaks\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `mem::forget(Rc::new(55)))`\n+/// **Example:**\n+/// ```rust\n+/// mem::forget(Rc::new(55)))\n+/// ```\n declare_lint! {\n     pub MEM_FORGET,\n     Allow,"}, {"sha": "d47179c52195472d3bf9604a936925e6fc724665", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -22,7 +22,9 @@ pub struct Pass;\n \n /// **What it does:** This lint checks for `.unwrap()` calls on `Option`s.\n ///\n-/// **Why is this bad?** Usually it is better to handle the `None` case, or to at least call `.expect(_)` with a more helpful message. Still, for a lot of quick-and-dirty code, `unwrap` is a good choice, which is why this lint is `Allow` by default.\n+/// **Why is this bad?** Usually it is better to handle the `None` case, or to at least call\n+/// `.expect(_)` with a more helpful message. Still, for a lot of quick-and-dirty code, `unwrap` is\n+/// a good choice, which is why this lint is `Allow` by default.\n ///\n /// **Known problems:** None\n ///\n@@ -37,9 +39,12 @@ declare_lint! {\n \n /// **What it does:** This lint checks for `.unwrap()` calls on `Result`s.\n ///\n-/// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err` values. Normally, you want to implement more sophisticated error handling, and propagate errors upwards with `try!`.\n+/// **Why is this bad?** `result.unwrap()` will let the thread panic on `Err` values. Normally, you\n+/// want to implement more sophisticated error handling, and propagate errors upwards with `try!`.\n ///\n-/// Even if you want to panic on errors, not all `Error`s implement good messages on display. Therefore it may be beneficial to look at the places where they may get displayed. Activate this lint to do just that.\n+/// Even if you want to panic on errors, not all `Error`s implement good messages on display.\n+/// Therefore it may be beneficial to look at the places where they may get displayed. Activate\n+/// this lint to do just that.\n ///\n /// **Known problems:** None\n ///\n@@ -52,14 +57,18 @@ declare_lint! {\n     \"using `Result.unwrap()`, which might be better handled\"\n }\n \n-/// **What it does:** This lint checks for methods that should live in a trait implementation of a `std` trait (see [llogiq's blog post](http://llogiq.github.io/2015/07/30/traits.html) for further information) instead of an inherent implementation.\n+/// **What it does:** This lint checks for methods that should live in a trait implementation of a\n+/// `std` trait (see [llogiq's blog post](http://llogiq.github.io/2015/07/30/traits.html) for\n+/// further information) instead of an inherent implementation.\n ///\n-/// **Why is this bad?** Implementing the traits improve ergonomics for users of the code, often with very little cost. Also people seeing a `mul(..)` method may expect `*` to work equally, so you should have good reason to disappoint them.\n+/// **Why is this bad?** Implementing the traits improve ergonomics for users of the code, often\n+/// with very little cost. Also people seeing a `mul(..)` method may expect `*` to work equally, so\n+/// you should have good reason to disappoint them.\n ///\n /// **Known problems:** None\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// struct X;\n /// impl X {\n ///    fn add(&self, other: &X) -> X { .. }\n@@ -70,7 +79,8 @@ declare_lint! {\n     \"defining a method that should be implementing a std trait\"\n }\n \n-/// **What it does:** This lint checks for methods with certain name prefixes and which doesn't match how self is taken. The actual rules are:\n+/// **What it does:** This lint checks for methods with certain name prefixes and which doesn't\n+/// match how self is taken. The actual rules are:\n ///\n /// |Prefix |`self` taken          |\n /// |-------|----------------------|\n@@ -80,7 +90,8 @@ declare_lint! {\n /// |`is_`  |`&self` or none       |\n /// |`to_`  |`&self`               |\n ///\n-/// **Why is this bad?** Consistency breeds readability. If you follow the conventions, your users won't be surprised that they, e.g., need to supply a mutable reference to a `as_..` function.\n+/// **Why is this bad?** Consistency breeds readability. If you follow the conventions, your users\n+/// won't be surprised that they, e.g., need to supply a mutable reference to a `as_..` function.\n ///\n /// **Known problems:** None\n ///\n@@ -97,11 +108,14 @@ declare_lint! {\n      `self` with the wrong convention\"\n }\n \n-/// **What it does:** This is the same as [`wrong_self_convention`](#wrong_self_convention), but for public items.\n+/// **What it does:** This is the same as [`wrong_self_convention`](#wrong_self_convention), but\n+/// for public items.\n ///\n /// **Why is this bad?** See [`wrong_self_convention`](#wrong_self_convention).\n ///\n-/// **Known problems:** Actually *renaming* the function may break clients if the function is part of the public interface. In that case, be mindful of the stability guarantees you've given your users.\n+/// **Known problems:** Actually *renaming* the function may break clients if the function is part\n+/// of the public interface. In that case, be mindful of the stability guarantees you've given your\n+/// users.\n ///\n /// **Example:**\n /// ```rust\n@@ -117,7 +131,8 @@ declare_lint! {\n \n /// **What it does:** This lint checks for usage of `ok().expect(..)`.\n ///\n-/// **Why is this bad?** Because you usually call `expect()` on the `Result` directly to get a good error message.\n+/// **Why is this bad?** Because you usually call `expect()` on the `Result` directly to get a good\n+/// error message.\n ///\n /// **Known problems:** None.\n ///\n@@ -178,7 +193,8 @@ declare_lint! {\n     \"using `filter(p).next()`, which is more succinctly expressed as `.find(p)`\"\n }\n \n-/// **What it does:** This lint `Warn`s on `_.filter(_).map(_)`, `_.filter(_).flat_map(_)`, `_.filter_map(_).flat_map(_)` and similar.\n+/// **What it does:** This lint `Warn`s on `_.filter(_).map(_)`, `_.filter(_).flat_map(_)`,\n+/// `_.filter_map(_).flat_map(_)` and similar.\n ///\n /// **Why is this bad?** Readability, this can be written more concisely as a single method call\n ///\n@@ -352,7 +368,7 @@ declare_lint! {\n /// ```rust,ignore\n /// let c_str = CString::new(\"foo\").unwrap();\n /// unsafe {\n-/// call_some_ffi_func(c_str.as_ptr());\n+///     call_some_ffi_func(c_str.as_ptr());\n /// }\n /// ```\n declare_lint! {"}, {"sha": "82888b9789c37543c121551ee6ac7fa83b07c950", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -5,13 +5,16 @@ use std::cmp::{PartialOrd, Ordering};\n use syntax::ptr::P;\n use utils::{match_def_path, paths, span_lint};\n \n-/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to clamp values, but switched so that the result is constant.\n+/// **What it does:** This lint checks for expressions where `std::cmp::min` and `max` are used to\n+/// clamp values, but switched so that the result is constant.\n ///\n-/// **Why is this bad?** This is in all probability not the intended outcome. At the least it hurts readability of the code.\n+/// **Why is this bad?** This is in all probability not the intended outcome. At the least it hurts\n+/// readability of the code.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `min(0, max(100, x))` will always be equal to `0`. Probably the author meant to clamp the value between 0 and 100, but has erroneously swapped `min` and `max`.\n+/// **Example:** `min(0, max(100, x))` will always be equal to `0`. Probably the author meant to\n+/// clamp the value between 0 and 100, but has erroneously swapped `min` and `max`.\n declare_lint! {\n     pub MIN_MAX, Warn,\n     \"`min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\""}, {"sha": "238bb402298f61a2a08c854b76248d37ff0690e0", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -17,13 +17,22 @@ use utils::sugg::Sugg;\n \n /// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`.\n ///\n-/// **Why is this bad?** The `ref` declaration makes the function take an owned value, but turns the argument into a reference (which means that the value is destroyed when exiting the function). This adds not much value: either take a reference type, or take an owned value and create references in the body.\n+/// **Why is this bad?** The `ref` declaration makes the function take an owned value, but turns\n+/// the argument into a reference (which means that the value is destroyed when exiting the\n+/// function). This adds not much value: either take a reference type, or take an owned value and\n+/// create references in the body.\n ///\n-/// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The type of `x` is more obvious with the former.\n+/// For let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The type of `x` is more\n+/// obvious with the former.\n ///\n-/// **Known problems:** If the argument is dereferenced within the function, removing the `ref` will lead to errors. This can be fixed by removing the dereferences, e.g. changing `*x` to `x` within the function.\n+/// **Known problems:** If the argument is dereferenced within the function, removing the `ref`\n+/// will lead to errors. This can be fixed by removing the dereferences, e.g. changing `*x` to `x`\n+/// within the function.\n ///\n-/// **Example:** `fn foo(ref x: u8) -> bool { .. }`\n+/// **Example:**\n+/// ```rust\n+/// fn foo(ref x: u8) -> bool { .. }\n+/// ```\n declare_lint! {\n     pub TOPLEVEL_REF_ARG, Warn,\n     \"An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), \\"}, {"sha": "569fe76e0299cb761d58de8d4f048a4ce71561e7", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -10,7 +10,10 @@ use utils::{span_lint, span_help_and_lint, snippet, span_lint_and_then};\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `let { a: _, b: ref b, c: _ } = ..`\n+/// **Example:**\n+/// ```rust\n+/// let { a: _, b: ref b, c: _ } = ..\n+/// ```\n declare_lint! {\n     pub UNNEEDED_FIELD_PATTERN, Warn,\n     \"Struct fields are bound to a wildcard instead of using `..`\"\n@@ -22,7 +25,10 @@ declare_lint! {\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `fn foo(a: i32, _a: i32) {}`\n+/// **Example:**\n+/// ```rust\n+/// fn foo(a: i32, _a: i32) {}\n+/// ```\n declare_lint! {\n     pub DUPLICATE_UNDERSCORE_ARGUMENT, Warn,\n     \"Function arguments having names which only differ by an underscore\"\n@@ -34,7 +40,10 @@ declare_lint! {\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `(|| 42)()`\n+/// **Example:**\n+/// ```rust\n+/// (|| 42)()\n+/// ```\n declare_lint! {\n     pub REDUNDANT_CLOSURE_CALL, Warn,\n     \"Closures should not be called in the expression they are defined\"\n@@ -46,7 +55,10 @@ declare_lint! {\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `--x;`\n+/// **Example:**\n+/// ```rust\n+/// --x;\n+/// ```\n declare_lint! {\n     pub DOUBLE_NEG, Warn,\n     \"`--x` is a double negation of `x` and not a pre-decrement as in C or C++\""}, {"sha": "08d979cb5d7a8287e98fa036a746cda677838750", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -6,16 +6,19 @@ use utils::{higher, in_external_macro, span_lint};\n \n /// **What it does:** This lint checks for instances of `mut mut` references.\n ///\n-/// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the source.\n+/// **Why is this bad?** Multiple `mut`s don't add anything meaningful to the source. This is\n+/// either a copy'n'paste error, or it shows a fundamental misunderstanding of references)\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `let x = &mut &mut y;`\n+/// **Example:**\n+/// ```rust\n+/// let x = &mut &mut y;\n+/// ```\n declare_lint! {\n     pub MUT_MUT,\n     Allow,\n-    \"usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, \\\n-     or shows a fundamental misunderstanding of references)\"\n+    \"usage of double-mut refs, e.g. `&mut &mut ...`\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "38cec410013a792e15faa431d09042dad0fd3791", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -4,13 +4,18 @@ use rustc::hir::*;\n use syntax::ptr::P;\n use utils::span_lint;\n \n-/// **What it does:** This lint detects giving a mutable reference to a function that only requires an immutable reference.\n+/// **What it does:** This lint detects giving a mutable reference to a function that only requires\n+/// an immutable reference.\n ///\n-/// **Why is this bad?** The immutable reference rules out all other references to the value. Also the code misleads about the intent of the call site.\n+/// **Why is this bad?** The immutable reference rules out all other references to the value. Also\n+/// the code misleads about the intent of the call site.\n ///\n /// **Known problems:** None\n ///\n-/// **Example** `my_vec.push(&mut value)`\n+/// **Example**\n+/// ```rust\n+/// my_vec.push(&mut value)\n+/// ```\n declare_lint! {\n     pub UNNECESSARY_MUT_PASSED,\n     Warn,"}, {"sha": "766df3946ce6d6b0b1493d148b4a21925ec1c8d8", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -1,4 +1,4 @@\n-//! Checks for uses of Mutex where an atomic value could be used\n+//! Checks for uses of mutex where an atomic value could be used\n //!\n //! This lint is **warn** by default\n \n@@ -11,28 +11,37 @@ use utils::{match_type, paths, span_lint};\n \n /// **What it does:** This lint checks for usages of `Mutex<X>` where an atomic will do.\n ///\n-/// **Why is this bad?** Using a Mutex just to make access to a plain bool or reference sequential is shooting flies with cannons. `std::atomic::AtomicBool` and `std::atomic::AtomicPtr` are leaner and faster.\n+/// **Why is this bad?** Using a mutex just to make access to a plain bool or reference sequential\n+/// is shooting flies with cannons. `std::atomic::AtomicBool` and `std::atomic::AtomicPtr` are\n+/// leaner and faster.\n ///\n-/// **Known problems:** This lint cannot detect if the Mutex is actually used for waiting before a critical section.\n+/// **Known problems:** This lint cannot detect if the mutex is actually used for waiting before a critical section.\n ///\n-/// **Example:** `let x = Mutex::new(&y);`\n+/// **Example:**\n+/// ```rust\n+/// let x = Mutex::new(&y);\n+/// ```\n declare_lint! {\n     pub MUTEX_ATOMIC,\n     Warn,\n-    \"using a Mutex where an atomic value could be used instead\"\n+    \"using a mutex where an atomic value could be used instead\"\n }\n \n /// **What it does:** This lint checks for usages of `Mutex<X>` where `X` is an integral type.\n ///\n-/// **Why is this bad?** Using a Mutex just to make access to a plain integer sequential is shooting flies with cannons. `std::atomic::usize` is leaner and faster.\n+/// **Why is this bad?** Using a mutex just to make access to a plain integer sequential is\n+/// shooting flies with cannons. `std::atomic::usize` is leaner and faster.\n ///\n-/// **Known problems:** This lint cannot detect if the Mutex is actually used for waiting before a critical section.\n+/// **Known problems:** This lint cannot detect if the mutex is actually used for waiting before a critical section.\n ///\n-/// **Example:** `let x = Mutex::new(0usize);`\n+/// **Example:**\n+/// ```rust\n+/// let x = Mutex::new(0usize);\n+/// ```\n declare_lint! {\n     pub MUTEX_INTEGER,\n     Allow,\n-    \"using a Mutex for an integer type\"\n+    \"using a mutex for an integer type\"\n }\n \n impl LintPass for MutexAtomic {"}, {"sha": "d9f019a8c6e340aef56570cd08e99c9635d4a47c", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,21 +9,28 @@ use syntax::codemap::Spanned;\n use utils::{span_lint, span_lint_and_then, snippet};\n use utils::sugg::Sugg;\n \n-/// **What it does:** This lint checks for expressions of the form `if c { true } else { false }` (or vice versa) and suggest using the condition directly.\n+/// **What it does:** This lint checks for expressions of the form `if c { true } else { false }`\n+/// (or vice versa) and suggest using the condition directly.\n ///\n /// **Why is this bad?** Redundant code.\n ///\n-/// **Known problems:** Maybe false positives: Sometimes, the two branches are painstakingly documented (which we of course do not detect), so they *may* have some value. Even then, the documentation can be rewritten to match the shorter code.\n+/// **Known problems:** Maybe false positives: Sometimes, the two branches are painstakingly\n+/// documented (which we of course do not detect), so they *may* have some value. Even then, the\n+/// documentation can be rewritten to match the shorter code.\n ///\n-/// **Example:** `if x { false } else { true }`\n+/// **Example:**\n+/// ```rust\n+/// if x { false } else { true }\n+/// ```\n declare_lint! {\n     pub NEEDLESS_BOOL,\n     Warn,\n     \"if-statements with plain booleans in the then- and else-clause, e.g. \\\n      `if p { true } else { false }`\"\n }\n \n-/// **What it does:** This lint checks for expressions of the form `x == true` (or vice versa) and suggest using the variable directly.\n+/// **What it does:** This lint checks for expressions of the form `x == true` (or vice versa) and\n+/// suggest using the variable directly.\n ///\n /// **Why is this bad?** Unnecessary code.\n ///"}, {"sha": "e34e8b9c5203df7590e494538f7430ee1162a6c2", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -8,13 +8,17 @@ use rustc::ty::TyRef;\n use utils::{span_lint, in_macro};\n use rustc::ty::adjustment::AutoAdjustment::AdjustDerefRef;\n \n-/// **What it does:** This lint checks for address of operations (`&`) that are going to be dereferenced immediately by the compiler\n+/// **What it does:** This lint checks for address of operations (`&`) that are going to be\n+/// dereferenced immediately by the compiler\n ///\n-/// **Why is this bad?** Suggests that the receiver of the expression borrows the expression\n+/// **Why is this bad?** Suggests that the receiver of the expression borrows the expression.\n ///\n /// **Known problems:**\n ///\n-/// **Example:** `let x: &i32 = &&&&&&5;`\n+/// **Example:**\n+/// ```rust\n+/// let x: &i32 = &&&&&&5;\n+/// ```\n declare_lint! {\n     pub NEEDLESS_BORROW,\n     Warn,"}, {"sha": "11a05f1a5af93e77705e43be4ac71c85552fb36c", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,11 +9,14 @@ use utils::span_lint;\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `Point { x: 1, y: 0, ..zero_point }`\n+/// **Example:**\n+/// ```rust\n+/// Point { x: 1, y: 0, ..zero_point }\n+/// ```\n declare_lint! {\n     pub NEEDLESS_UPDATE,\n     Warn,\n-    \"using `{ ..base }` when there are no missing fields\"\n+    \"using `Foo { ..base }` when there are no missing fields\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "2a9c9b32f940a36165b2f80b9405bfc77f7921e8", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -11,7 +11,10 @@ use utils::span_lint;\n ///\n /// **Known problems:** This only catches integers (for now)\n ///\n-/// **Example:** `x * -1`\n+/// **Example:**\n+/// ```rust\n+/// x * -1\n+/// ```\n declare_lint! {\n     pub NEG_MULTIPLY,\n     Warn,"}, {"sha": "774c055178b37ece71fd21bbb1651916ed6aec81", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -6,11 +6,15 @@ use std::ops::Deref;\n \n /// **What it does:** This lint checks for statements which have no effect.\n ///\n-/// **Why is this bad?** Similar to dead code, these statements are actually executed. However, as they have no effect, all they do is make the code less readable.\n+/// **Why is this bad?** Similar to dead code, these statements are actually executed. However, as\n+/// they have no effect, all they do is make the code less readable.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `0;`\n+/// **Example:**\n+/// ```rust\n+/// 0;\n+/// ```\n declare_lint! {\n     pub NO_EFFECT,\n     Warn,\n@@ -19,11 +23,15 @@ declare_lint! {\n \n /// **What it does:** This lint checks for expression statements that can be reduced to a sub-expression\n ///\n-/// **Why is this bad?** Expressions by themselves often have no side-effects. Having such expressions reduces redability.\n+/// **Why is this bad?** Expressions by themselves often have no side-effects. Having such\n+/// expressions reduces readability.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `compute_array()[0];`\n+/// **Example:**\n+/// ```rust\n+/// compute_array()[0];\n+/// ```\n declare_lint! {\n     pub UNNECESSARY_OPERATION,\n     Warn,"}, {"sha": "5580074796fe35bb0ca03920c5edbe36213ce185", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -4,13 +4,18 @@ use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n use utils::{match_type, paths, span_lint, walk_ptrs_ty_depth};\n \n-/// **What it does:** This lint checks for duplicate open options as well as combinations that make no sense.\n+/// **What it does:** This lint checks for duplicate open options as well as combinations that make\n+/// no sense.\n ///\n-/// **Why is this bad?** In the best case, the code will be harder to read than necessary. I don't know the worst case.\n+/// **Why is this bad?** In the best case, the code will be harder to read than necessary. I don't\n+/// know the worst case.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `OpenOptions::new().read(true).truncate(true)`\n+/// **Example:**\n+/// ```rust\n+/// OpenOptions::new().read(true).truncate(true)\n+/// ```\n declare_lint! {\n     pub NONSENSICAL_OPEN_OPTIONS,\n     Warn,"}, {"sha": "494c113ff104bd9e53e1bcda353700104cb84f97", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -4,11 +4,15 @@ use utils::span_lint;\n \n /// **What it does:** This lint finds classic underflow / overflow checks.\n ///\n-/// **Why is this bad?** Most classic C underflow / overflow checks will fail in Rust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n+/// **Why is this bad?** Most classic C underflow / overflow checks will fail in Rust. Users can\n+/// use functions like `overflowing_*` and `wrapping_*` instead.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `a + b < a`\n+/// **Example:**\n+/// ```rust\n+/// a + b < a\n+/// ```\n \n declare_lint!(pub OVERFLOW_CHECK_CONDITIONAL, Warn,\n               \"Using overflow checks which are likely to panic\");"}, {"sha": "775373f8105ae846952e56ba9e5fe8dc4de158c0", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,7 +9,7 @@ use utils::{is_direct_expn_of, match_path, paths, span_lint};\n /// this lint will warn.\n ///\n /// **Example:**\n-/// ```\n+/// ```rust\n /// panic!(\"This `panic!` is probably missing a parameter there: {}\");\n /// ```\n declare_lint! {"}, {"sha": "e70e320929a8aca54b9c57c3f0c93825ee3b0826", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -3,11 +3,14 @@ use syntax::ast::*;\n use syntax::codemap::Spanned;\n use utils::{span_lint, snippet};\n \n-/// **What it does:** This lint checks for operations where precedence may be unclear and suggests to add parentheses. Currently it catches the following:\n+/// **What it does:** This lint checks for operations where precedence may be unclear and suggests\n+/// to add parentheses. Currently it catches the following:\n /// * mixed usage of arithmetic and bit shifting/combining operators without parentheses\n-/// * a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal) followed by a method call\n+/// * a \"negative\" numeric literal (which is really a unary `-` followed by a numeric literal)\n+///   followed by a method call\n ///\n-/// **Why is this bad?** Because not everyone knows the precedence of those operators by heart, so expressions like these may trip others trying to reason about the code.\n+/// **Why is this bad?** Because not everyone knows the precedence of those operators by heart, so\n+/// expressions like these may trip others trying to reason about the code.\n ///\n /// **Known problems:** None\n ///\n@@ -16,8 +19,7 @@ use utils::{span_lint, snippet};\n /// * `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1\n declare_lint! {\n     pub PRECEDENCE, Warn,\n-    \"catches operations where precedence may be unclear. See the wiki for a \\\n-     list of cases caught\"\n+    \"catches operations where precedence may be unclear\"\n }\n \n #[derive(Copy,Clone)]"}, {"sha": "cec140b1aec0c92863a45630ab50e13469af0f50", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -4,26 +4,34 @@ use rustc::lint::*;\n use utils::paths;\n use utils::{is_expn_of, match_path, span_lint};\n \n-/// **What it does:** This lint warns whenever you print on *stdout*. The purpose of this lint is to catch debugging remnants.\n+/// **What it does:** This lint warns whenever you print on *stdout*. The purpose of this lint is\n+/// to catch debugging remnants.\n ///\n /// **Why is this bad?** People often print on *stdout* while debugging an application and might\n /// forget to remove those prints afterward.\n ///\n /// **Known problems:** Only catches `print!` and `println!` calls.\n ///\n-/// **Example:** `println!(\"Hello world!\");`\n+/// **Example:**\n+/// ```rust\n+/// println!(\"Hello world!\");\n+/// ```\n declare_lint! {\n     pub PRINT_STDOUT,\n     Allow,\n     \"printing on stdout\"\n }\n \n-/// **What it does:** This lint warns whenever you use `Debug` formatting. The purpose of this lint is to catch debugging remnants.\n+/// **What it does:** This lint warns whenever you use `Debug` formatting. The purpose of this lint\n+/// is to catch debugging remnants.\n ///\n /// **Why is this bad?** The purpose of the `Debug` trait is to facilitate debugging Rust code. It\n /// should not be used in in user-facing output.\n ///\n-/// **Example:** `println!(\"{:?}\", foo);`\n+/// **Example:**\n+/// ```rust\n+/// println!(\"{:?}\", foo);\n+/// ```\n declare_lint! {\n     pub USE_DEBUG,\n     Allow,"}, {"sha": "4a237340353891093505b3b13088751a1be70595", "filename": "clippy_lints/src/ptr_arg.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_arg.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -7,13 +7,19 @@ use rustc::ty;\n use syntax::ast::NodeId;\n use utils::{match_type, paths, span_lint};\n \n-/// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless the references are mutable.\n+/// **What it does:** This lint checks for function arguments of type `&String` or `&Vec` unless\n+/// the references are mutable.\n ///\n-/// **Why is this bad?** Requiring the argument to be of the specific size makes the function less useful for no benefit; slices in the form of `&[T]` or `&str` usually suffice and can be obtained from other types, too.\n+/// **Why is this bad?** Requiring the argument to be of the specific size makes the function less\n+/// useful for no benefit; slices in the form of `&[T]` or `&str` usually suffice and can be\n+/// obtained from other types, too.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `fn foo(&Vec<u32>) { .. }`\n+/// **Example:**\n+/// ```rust\n+/// fn foo(&Vec<u32>) { .. }\n+/// ```\n declare_lint! {\n     pub PTR_ARG,\n     Warn,"}, {"sha": "066fccec1d152a5cb664cdc5c878bd5b46b25ec7", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -4,13 +4,18 @@ use syntax::codemap::Spanned;\n use utils::{is_integer_literal, match_type, paths, snippet, span_lint};\n use utils::higher;\n \n-/// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n+/// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never\n+/// terminates.\n ///\n-/// **Why is this bad?** This very much looks like an oversight, since with `loop { .. }` there is an obvious better way to endlessly loop.\n+/// **Why is this bad?** This very much looks like an oversight, since with `loop { .. }` there is\n+/// an obvious better way to endlessly loop.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `for x in (5..5).step_by(0) { .. }`\n+/// **Example:**\n+/// ```rust\n+/// for x in (5..5).step_by(0) { .. }\n+/// ```\n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n     \"using Range::step_by(0), which produces an infinite iterator\"\n@@ -21,7 +26,10 @@ declare_lint! {\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `x.iter().zip(0..x.len())`\n+/// **Example:**\n+/// ```rust\n+/// x.iter().zip(0..x.len())\n+/// ```\n declare_lint! {\n     pub RANGE_ZIP_WITH_LEN, Warn,\n     \"zipping iterator with a range when enumerate() would do\""}, {"sha": "40c9fa6a067e07a6e0c8940a958ba5cf51cb3009", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -14,11 +14,16 @@ use utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_help_\n /// **What it does:** This lint checks [regex] creation (with `Regex::new`, `RegexBuilder::new` or\n /// `RegexSet::new`) for correct regex syntax.\n ///\n+/// [regex]: https://crates.io/crates/regex\n+///\n /// **Why is this bad?** This will lead to a runtime panic.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `Regex::new(\"|\")`\n+/// **Example:**\n+/// ```rust\n+/// Regex::new(\"|\")\n+/// ```\n declare_lint! {\n     pub INVALID_REGEX,\n     Deny,\n@@ -28,27 +33,35 @@ declare_lint! {\n /// **What it does:** This lint checks for trivial [regex] creation (with `Regex::new`,\n /// `RegexBuilder::new` or `RegexSet::new`).\n ///\n+/// [regex]: https://crates.io/crates/regex\n+///\n /// **Why is this bad?** This can likely be replaced by `==` or `str::starts_with`,\n /// `str::ends_with` or `std::contains` or other `str` methods.\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `Regex::new(\"^foobar\")`\n-///\n-/// [regex]: https://crates.io/crates/regex\n+/// **Example:**\n+/// ```rust\n+/// Regex::new(\"^foobar\")\n+/// ```\n declare_lint! {\n     pub TRIVIAL_REGEX,\n     Warn,\n     \"finds trivial regular expressions\"\n }\n \n-/// **What it does:** This lint checks for usage of `regex!(_)` which as of now is usually slower than `Regex::new(_)` unless called in a loop (which is a bad idea anyway).\n+/// **What it does:** This lint checks for usage of `regex!(_)` which as of now is usually slower\n+/// than `Regex::new(_)` unless called in a loop (which is a bad idea anyway).\n ///\n-/// **Why is this bad?** Performance, at least for now. The macro version is likely to catch up long-term, but for now the dynamic version is faster.\n+/// **Why is this bad?** Performance, at least for now. The macro version is likely to catch up\n+/// long-term, but for now the dynamic version is faster.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `regex!(\"foo|bar\")`\n+/// **Example:**\n+/// ```rust\n+/// regex!(\"foo|bar\")\n+/// ```\n declare_lint! {\n     pub REGEX_MACRO,\n     Warn,"}, {"sha": "1100bdc5951dd84a056bbbdbf757dea364ea8788", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,9 +9,14 @@ use utils::{span_note_and_lint, span_lint_and_then, snippet_opt, match_path_ast,\n ///\n /// **Why is this bad?** Removing the `return` and semicolon will make the code more rusty.\n ///\n-/// **Known problems:** Following this lint's advice may currently run afoul of Rust issue [#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please roll back the change until that issue is fixed.\n+/// **Known problems:** Following this lint's advice may currently run afoul of Rust issue\n+/// [#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please\n+/// roll back the change until that issue is fixed.\n ///\n-/// **Example:** `fn foo(x: usize) { return x; }`\n+/// **Example:**\n+/// ```rust\n+/// fn foo(x: usize) { return x; }\n+/// ```\n declare_lint! {\n     pub NEEDLESS_RETURN, Warn,\n     \"using a return statement like `return expr;` where an expression would suffice\"\n@@ -21,9 +26,14 @@ declare_lint! {\n ///\n /// **Why is this bad?** It is just extraneous code. Remove it to make your code more rusty.\n ///\n-/// **Known problems:** Following this lint's advice may currently run afoul of Rust issue [#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please roll back the change until that issue is fixed.\n+/// **Known problems:** Following this lint's advice may currently run afoul of Rust issue\n+/// [#31439](https://github.com/rust-lang/rust/issues/31439), so if you get lifetime errors, please\n+/// roll back the change until that issue is fixed.\n ///\n-/// **Example:** `{ let x = ..; x }`\n+/// **Example:**\n+/// ```rust\n+/// { let x = ..; x }\n+/// ```\n declare_lint! {\n     pub LET_AND_RETURN, Warn,\n     \"creating a let-binding and then immediately returning it like `let x = expr; x` at \\"}, {"sha": "05a23f57600de445b301335b18c0484819e05aeb", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -7,38 +7,59 @@ use std::ops::Deref;\n use syntax::codemap::Span;\n use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n \n-/// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while just changing reference level or mutability.\n+/// **What it does:** This lint checks for bindings that shadow other bindings already in scope,\n+/// while just changing reference level or mutability.\n ///\n-/// **Why is this bad?** Not much, in fact it's a very common pattern in Rust code. Still, some may opt to avoid it in their code base, they can set this lint to `Warn`.\n+/// **Why is this bad?** Not much, in fact it's a very common pattern in Rust code. Still, some may\n+/// opt to avoid it in their code base, they can set this lint to `Warn`.\n ///\n-/// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n+/// **Known problems:** This lint, as the other shadowing related lints, currently only catches\n+/// very simple patterns.\n ///\n-/// **Example:** `let x = &x;`\n+/// **Example:**\n+/// ```rust\n+/// let x = &x;\n+/// ```\n declare_lint! {\n     pub SHADOW_SAME, Allow,\n     \"rebinding a name to itself, e.g. `let mut x = &mut x`\"\n }\n \n-/// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while reusing the original value.\n+/// **What it does:** This lint checks for bindings that shadow other bindings already in scope,\n+/// while reusing the original value.\n ///\n-/// **Why is this bad?** Not too much, in fact it's a common pattern in Rust code. Still, some argue that name shadowing like this hurts readability, because a value may be bound to different things depending on position in the code.\n+/// **Why is this bad?** Not too much, in fact it's a common pattern in Rust code. Still, some\n+/// argue that name shadowing like this hurts readability, because a value may be bound to\n+/// different things depending on position in the code.\n ///\n-/// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n+/// **Known problems:** This lint, as the other shadowing related lints, currently only catches\n+/// very simple patterns.\n ///\n-/// **Example:** `let x = x + 1;`\n+/// **Example:**\n+/// ```rust\n+/// let x = x + 1;\n+/// ```\n declare_lint! {\n     pub SHADOW_REUSE, Allow,\n     \"rebinding a name to an expression that re-uses the original value, e.g. \\\n     `let x = x + 1`\"\n }\n \n-/// **What it does:** This lint checks for bindings that shadow other bindings already in scope, either without a initialization or with one that does not even use the original value.\n+/// **What it does:** This lint checks for bindings that shadow other bindings already in scope,\n+/// either without a initialization or with one that does not even use the original value.\n ///\n-/// **Why is this bad?** Name shadowing can hurt readability, especially in large code bases, because it is easy to lose track of the active binding at any place in the code. This can be alleviated by either giving more specific names to bindings ore introducing more scopes to contain the bindings.\n+/// **Why is this bad?** Name shadowing can hurt readability, especially in large code bases,\n+/// because it is easy to lose track of the active binding at any place in the code. This can be\n+/// alleviated by either giving more specific names to bindings ore introducing more scopes to\n+/// contain the bindings.\n ///\n-/// **Known problems:** This lint, as the other shadowing related lints, currently only catches very simple patterns.\n+/// **Known problems:** This lint, as the other shadowing related lints, currently only catches\n+/// very simple patterns.\n ///\n-/// **Example:** `let x = y; let x = z; // shadows the earlier binding`\n+/// **Example:**\n+/// ```rust\n+/// let x = y; let x = z; // shadows the earlier binding\n+/// ```\n declare_lint! {\n     pub SHADOW_UNRELATED, Allow,\n     \"The name is re-bound without even using the original value\""}, {"sha": "24aee0092be13348e1e49bee4f0852664af6128d", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -1,8 +1,3 @@\n-//! This lint catches both string addition and string addition + assignment\n-//!\n-//! Note that since we have two lints where one subsumes the other, we try to\n-//! disable the subsumed lint unless it has a higher level\n-\n use rustc::hir::*;\n use rustc::lint::*;\n use syntax::codemap::Spanned;\n@@ -11,13 +6,14 @@ use utils::{match_type, paths, span_lint, span_lint_and_then, walk_ptrs_ty, get_\n \n /// **What it does:** This lint matches code of the form `x = x + y` (without `let`!).\n ///\n-/// **Why is this bad?** It's not really bad, but some people think that the `.push_str(_)` method is more readable.\n+/// **Why is this bad?** It's not really bad, but some people think that the `.push_str(_)` method\n+/// is more readable.\n ///\n /// **Known problems:** None.\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// let mut x = \"Hello\".to_owned();\n /// x = x + \", World\";\n /// ```\n@@ -27,17 +23,22 @@ declare_lint! {\n     \"using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\"\n }\n \n-/// **What it does:** The `string_add` lint matches all instances of `x + _` where `x` is of type `String`, but only if [`string_add_assign`](#string_add_assign) does *not* match.\n+/// **What it does:** The `string_add` lint matches all instances of `x + _` where `x` is of type\n+/// `String`, but only if [`string_add_assign`](#string_add_assign) does *not* match.\n ///\n-/// **Why is this bad?** It's not bad in and of itself. However, this particular `Add` implementation is asymmetric (the other operand need not be `String`, but `x` does), while addition as mathematically defined is symmetric, also the `String::push_str(_)` function is a perfectly good replacement. Therefore some dislike it and wish not to have it in their code.\n+/// **Why is this bad?** It's not bad in and of itself. However, this particular `Add`\n+/// implementation is asymmetric (the other operand need not be `String`, but `x` does), while\n+/// addition as mathematically defined is symmetric, also the `String::push_str(_)` function is a\n+/// perfectly good replacement. Therefore some dislike it and wish not to have it in their code.\n ///\n-/// That said, other people think that String addition, having a long tradition in other languages is actually fine, which is why we decided to make this particular lint `allow` by default.\n+/// That said, other people think that string addition, having a long tradition in other languages\n+/// is actually fine, which is why we decided to make this particular lint `allow` by default.\n ///\n /// **Known problems:** None\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// let x = \"Hello\".to_owned();\n /// x + \", World\"\n /// ```\n@@ -48,13 +49,14 @@ declare_lint! {\n }\n \n /// **What it does:** This lint matches the `as_bytes` method called on string\n-/// literals that contain only ascii characters.\n+/// literals that contain only ASCII characters.\n ///\n-/// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used instead. They are shorter but less discoverable than `as_bytes()`.\n+/// **Why is this bad?** Byte string literals (e.g. `b\"foo\"`) can be used instead. They are shorter\n+/// but less discoverable than `as_bytes()`.\n ///\n /// **Example:**\n ///\n-/// ```\n+/// ```rust\n /// let bs = \"a byte string\".as_bytes();\n /// ```\n declare_lint! {"}, {"sha": "2b06ae48294c61094055874eb3795d19d1a3bf4a", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -3,13 +3,18 @@ use rustc::hir::{Expr, ExprAssign, ExprField, ExprStruct, ExprTup, ExprTupField}\n use utils::is_adjusted;\n use utils::span_lint;\n \n-/// **What it does:** This lint checks for construction of a structure or tuple just to assign a value in it.\n+/// **What it does:** This lint checks for construction of a structure or tuple just to assign a\n+/// value in it.\n ///\n-/// **Why is this bad?** Readability. If the structure is only created to be updated, why not write the structure you want in the first place?\n+/// **Why is this bad?** Readability. If the structure is only created to be updated, why not write\n+/// the structure you want in the first place?\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `(0, 0).0 = 1`\n+/// **Example:**\n+/// ```rust\n+/// (0, 0).0 = 1\n+/// ```\n declare_lint! {\n     pub TEMPORARY_ASSIGNMENT,\n     Warn,"}, {"sha": "b9c0dceb5870ec23e40a3c868f69b79c6bed04c0", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -9,22 +9,31 @@ use utils::sugg;\n ///\n /// **Why is this bad?** It's basically guaranteed to be undefined behaviour\n ///\n-/// **Known problems:** When accessing C, users might want to store pointer sized objects in `extradata` arguments to save an allocation.\n+/// **Known problems:** When accessing C, users might want to store pointer sized objects in\n+/// `extradata` arguments to save an allocation.\n ///\n-/// **Example:** `let ptr: *const T = core::intrinsics::transmute('x')`.\n+/// **Example:**\n+/// ```rust\n+/// let ptr: *const T = core::intrinsics::transmute('x')`\n+/// ```\n declare_lint! {\n     pub WRONG_TRANSMUTE,\n     Warn,\n     \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n }\n \n-/// **What it does:** This lint checks for transmutes to the original type of the object and transmutes that could be a cast.\n+/// **What it does:** This lint checks for transmutes to the original type of the object and\n+/// transmutes that could be a cast.\n ///\n-/// **Why is this bad?** Readability. The code tricks people into thinking that something complex is going on\n+/// **Why is this bad?** Readability. The code tricks people into thinking that something complex\n+/// is going on\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `core::intrinsics::transmute(t)` where the result type is the same as `t`'s.\n+/// **Example:**\n+/// ```rust\n+/// core::intrinsics::transmute(t) // where the result type is the same as `t`'s\n+/// ```\n declare_lint! {\n     pub USELESS_TRANSMUTE,\n     Warn,\n@@ -37,7 +46,10 @@ declare_lint! {\n ///\n /// **Known problems:** None.\n ///\n-/// **Example:** `core::intrinsics::transmute(t)` where the result type is the same as `*t` or `&t`'s.\n+/// **Example:**\n+/// ```rust\n+/// core::intrinsics::transmute(t)` // where the result type is the same as `*t` or `&t`'s\n+/// ```\n declare_lint! {\n     pub CROSSPOINTER_TRANSMUTE,\n     Warn,"}, {"sha": "f18dfdbc35bee6851f479c4ef42c161a40c4195d", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -16,27 +16,44 @@ pub struct TypePass;\n \n /// **What it does:** This lint checks for use of `Box<Vec<_>>` anywhere in the code.\n ///\n-/// **Why is this bad?** `Vec` already keeps its contents in a separate area on the heap. So if you `Box` it, you just add another level of indirection without any benefit whatsoever.\n+/// **Why is this bad?** `Vec` already keeps its contents in a separate area on the heap. So if you\n+/// `Box` it, you just add another level of indirection without any benefit whatsoever.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `struct X { values: Box<Vec<Foo>> }`\n+/// **Example:**\n+/// ```rust\n+/// struct X {\n+///     values: Box<Vec<Foo>>,\n+/// }\n+/// ```\n declare_lint! {\n     pub BOX_VEC, Warn,\n     \"usage of `Box<Vec<T>>`, vector elements are already on the heap\"\n }\n \n-/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or a `VecDeque` (formerly called `RingBuf`).\n+/// **What it does:** This lint checks for usage of any `LinkedList`, suggesting to use a `Vec` or\n+/// a `VecDeque` (formerly called `RingBuf`).\n ///\n /// **Why is this bad?** Gankro says:\n ///\n-/// >The TL;DR of `LinkedList` is that it's built on a massive amount of pointers and indirection. It wastes memory, it has terrible cache locality, and is all-around slow. `RingBuf`, while \"only\" amortized for push/pop, should be faster in the general case for almost every possible workload, and isn't even amortized at all if you can predict the capacity you need.\n+/// > The TL;DR of `LinkedList` is that it's built on a massive amount of pointers and indirection.\n+/// > It wastes memory, it has terrible cache locality, and is all-around slow. `RingBuf`, while\n+/// > \"only\" amortized for push/pop, should be faster in the general case for almost every possible\n+/// > workload, and isn't even amortized at all if you can predict the capacity you need.\n /// >\n-/// > `LinkedList`s are only really good if you're doing a lot of merging or splitting of lists. This is because they can just mangle some pointers instead of actually copying the data. Even if you're doing a lot of insertion in the middle of the list, `RingBuf` can still be better because of how expensive it is to seek to the middle of a `LinkedList`.\n-///\n-/// **Known problems:** False positives \u2013 the instances where using a `LinkedList` makes sense are few and far between, but they can still happen.\n-///\n-/// **Example:** `let x = LinkedList::new();`\n+/// > `LinkedList`s are only really good if you're doing a lot of merging or splitting of lists.\n+/// > This is because they can just mangle some pointers instead of actually copying the data. Even\n+/// > if you're doing a lot of insertion in the middle of the list, `RingBuf` can still be better\n+/// > because of how expensive it is to seek to the middle of a `LinkedList`.\n+///\n+/// **Known problems:** False positives \u2013 the instances where using a `LinkedList` makes sense are\n+/// few and far between, but they can still happen.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let x = LinkedList::new();\n+/// ```\n declare_lint! {\n     pub LINKEDLIST, Warn,\n     \"usage of LinkedList, usually a vector is faster, or a more specialized data \\"}, {"sha": "067c14c3c14712c17a93dd0252611dfcb79683b9", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -5,9 +5,10 @@ use syntax::codemap::Span;\n use unicode_normalization::UnicodeNormalization;\n use utils::{snippet, span_help_and_lint};\n \n-/// **What it does:** This lint checks for the unicode zero-width space in the code.\n+/// **What it does:** This lint checks for the Unicode zero-width space in the code.\n ///\n-/// **Why is this bad?** Having an invisible character in the code makes for all sorts of April fools, but otherwise is very much frowned upon.\n+/// **Why is this bad?** Having an invisible character in the code makes for all sorts of April\n+/// fools, but otherwise is very much frowned upon.\n ///\n /// **Known problems:** None\n ///\n@@ -17,26 +18,34 @@ declare_lint! {\n     \"using a zero-width space in a string literal, which is confusing\"\n }\n \n-/// **What it does:** This lint checks for non-ascii characters in string literals.\n+/// **What it does:** This lint checks for non-ASCII characters in string literals.\n ///\n-/// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset back. Even so, there still are editors and other programs out there that don't work well with unicode. So if the code is meant to be used internationally, on multiple operating systems, or has other portability requirements, activating this lint could be useful.\n+/// **Why is this bad?** Yeah, we know, the 90's called and wanted their charset back. Even so,\n+/// there still are editors and other programs out there that don't work well with Unicode. So if\n+/// the code is meant to be used internationally, on multiple operating systems, or has other\n+/// portability requirements, activating this lint could be useful.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `let x = \"H\u00e4?\"`\n+/// **Example:**\n+/// ```rust\n+/// let x = \"H\u00e4?\"\n+/// ```\n declare_lint! {\n     pub NON_ASCII_LITERAL, Allow,\n     \"using any literal non-ASCII chars in a string literal; suggests \\\n-     using the \\\\u escape instead\"\n+     using the `\\\\u` escape instead\"\n }\n \n-/// **What it does:** This lint checks for string literals that contain unicode in a form that is not equal to its [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n+/// **What it does:** This lint checks for string literals that contain Unicode in a form that is\n+/// not equal to its [NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n ///\n /// **Why is this bad?** If such a string is compared to another, the results may be surprising.\n ///\n /// **Known problems** None\n ///\n-/// **Example:** You may not see it, but \"a\u0300\" and \"\u00e0\" aren't the same string. The former when escaped is actually \"a\\u{300}\" while the latter is \"\\u{e0}\".\n+/// **Example:** You may not see it, but \u201ca\u0300\u201d and \u201c\u00e0\u201d aren't the same string. The former when\n+/// escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.\n declare_lint! {\n     pub UNICODE_NOT_NFC, Allow,\n     \"using a unicode literal not in NFC normal form (see \\"}, {"sha": "3e828798a9aa1e1d192343934e2f5670e7f7ad2b", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa76e119b5737e0e2275f7372396c1373c083a6/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=caa76e119b5737e0e2275f7372396c1373c083a6", "patch": "@@ -14,7 +14,10 @@ pub struct Pass;\n ///\n /// **Known problems:** None\n ///\n-/// **Example** `0.0f32 / 0.0`\n+/// **Example**\n+/// ```rust\n+/// 0.0f32 / 0.0\n+/// ```\n declare_lint! {\n     pub ZERO_DIVIDED_BY_ZERO,\n     Warn,"}]}