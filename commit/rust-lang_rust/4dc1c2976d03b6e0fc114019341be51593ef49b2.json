{"sha": "4dc1c2976d03b6e0fc114019341be51593ef49b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYzFjMjk3NmQwM2I2ZTBmYzExNDAxOTM0MWJlNTE1OTNlZjQ5YjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T18:30:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:58Z"}, "message": "libcore: Remove mutable fields from hash", "tree": {"sha": "a29c2a8b4b5d89a4f10f30febfdf61cb169541a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a29c2a8b4b5d89a4f10f30febfdf61cb169541a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dc1c2976d03b6e0fc114019341be51593ef49b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc1c2976d03b6e0fc114019341be51593ef49b2", "html_url": "https://github.com/rust-lang/rust/commit/4dc1c2976d03b6e0fc114019341be51593ef49b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dc1c2976d03b6e0fc114019341be51593ef49b2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2961997f169a526ccf5a3bafd95db3e12f7e0283", "url": "https://api.github.com/repos/rust-lang/rust/commits/2961997f169a526ccf5a3bafd95db3e12f7e0283", "html_url": "https://github.com/rust-lang/rust/commit/2961997f169a526ccf5a3bafd95db3e12f7e0283"}], "stats": {"total": 271, "additions": 160, "deletions": 111}, "files": [{"sha": "486f0e096e8ac5b067a09974b1ce328b6f29e986", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 123, "deletions": 85, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=4dc1c2976d03b6e0fc114019341be51593ef49b2", "patch": "@@ -19,12 +19,16 @@\n  * CPRNG like rand::rng.\n  */\n \n-use io;\n-use io::Writer;\n+#[cfg(stage0)]\n+use cast;\n+use rt::io::Writer;\n use to_bytes::IterBytes;\n use uint;\n use vec;\n \n+// Alias `SipState` to `State`.\n+pub use State = hash::SipState;\n+\n /**\n  * Types that can meaningfully be hashed should implement this.\n  *\n@@ -65,112 +69,158 @@ impl<A:Hash> HashUtil for A {\n \n /// Streaming hash-functions should implement this.\n pub trait Streaming {\n-    fn input(&self, (&const [u8]));\n+    fn input(&mut self, &[u8]);\n     // These can be refactored some when we have default methods.\n-    fn result_bytes(&self) -> ~[u8];\n-    fn result_str(&self) -> ~str;\n-    fn result_u64(&self) -> u64;\n-    fn reset(&self);\n+    fn result_bytes(&mut self) -> ~[u8];\n+    fn result_str(&mut self) -> ~str;\n+    fn result_u64(&mut self) -> u64;\n+    fn reset(&mut self);\n+}\n+\n+// XXX: Ugly workaround for bootstrapping.\n+#[cfg(stage0)]\n+fn transmute_for_stage0<'a>(bytes: &'a [const u8]) -> &'a [u8] {\n+    unsafe {\n+        cast::transmute(bytes)\n+    }\n+}\n+#[cfg(not(stage0))]\n+fn transmute_for_stage0<'a>(bytes: &'a [u8]) -> &'a [u8] {\n+    bytes\n }\n \n impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n-        let s = &State(k0, k1);\n+        let mut s = State::new(k0, k1);\n         for self.iter_bytes(true) |bytes| {\n-            s.input(bytes);\n+            s.input(transmute_for_stage0(bytes));\n         }\n         s.result_u64()\n     }\n }\n \n fn hash_keyed_2<A: IterBytes,\n                 B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n fn hash_keyed_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for c.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n fn hash_keyed_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n-                D: IterBytes>(a: &A, b: &B, c: &C, d: &D, k0: u64, k1: u64)\n-                           -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n+                D: IterBytes>(\n+                a: &A,\n+                b: &B,\n+                c: &C,\n+                d: &D,\n+                k0: u64,\n+                k1: u64)\n+                -> u64 {\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for c.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for d.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n fn hash_keyed_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n-                E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n-                              k0: u64, k1: u64) -> u64 {\n-    let s = &State(k0, k1);\n-    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n-    for e.iter_bytes(true) |bytes| { s.input(bytes); }\n+                E: IterBytes>(\n+                a: &A,\n+                b: &B,\n+                c: &C,\n+                d: &D,\n+                e: &E,\n+                k0: u64,\n+                k1: u64)\n+                -> u64 {\n+    let mut s = State::new(k0, k1);\n+    for a.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for b.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for c.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for d.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n+    for e.iter_bytes(true) |bytes| {\n+        s.input(transmute_for_stage0(bytes));\n+    }\n     s.result_u64()\n }\n \n-// Implement State as SipState\n-\n-pub type State = SipState;\n-\n-#[inline(always)]\n-pub fn State(k0: u64, k1: u64) -> State {\n-    SipState(k0, k1)\n-}\n-\n #[inline(always)]\n pub fn default_state() -> State {\n-    State(0,0)\n+    State::new(0, 0)\n }\n \n struct SipState {\n     k0: u64,\n     k1: u64,\n-    mut length: uint, // how many bytes we've processed\n-    mut v0: u64,      // hash state\n-    mut v1: u64,\n-    mut v2: u64,\n-    mut v3: u64,\n-    mut tail: [u8, ..8], // unprocessed bytes\n-    mut ntail: uint,  // how many bytes in tail are valid\n+    length: uint, // how many bytes we've processed\n+    v0: u64,      // hash state\n+    v1: u64,\n+    v2: u64,\n+    v3: u64,\n+    tail: [u8, ..8], // unprocessed bytes\n+    ntail: uint,  // how many bytes in tail are valid\n }\n \n-#[inline(always)]\n-fn SipState(key0: u64, key1: u64) -> SipState {\n-    let state = SipState {\n-        k0 : key0,\n-        k1 : key1,\n-        mut length : 0u,\n-        mut v0 : 0u64,\n-        mut v1 : 0u64,\n-        mut v2 : 0u64,\n-        mut v3 : 0u64,\n-        mut tail : [0u8,0,0,0,0,0,0,0],\n-        mut ntail : 0u,\n-    };\n-    (&state).reset();\n-    state\n+impl SipState {\n+    #[inline(always)]\n+    fn new(key0: u64, key1: u64) -> SipState {\n+        let mut state = SipState {\n+            k0: key0,\n+            k1: key1,\n+            length: 0,\n+            v0: 0,\n+            v1: 0,\n+            v2: 0,\n+            v3: 0,\n+            tail: [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n+            ntail: 0,\n+        };\n+        state.reset();\n+        state\n+    }\n }\n \n // sadly, these macro definitions can't appear later,\n@@ -207,12 +257,10 @@ macro_rules! compress (\n )\n \n \n-impl io::Writer for SipState {\n-\n+impl Writer for SipState {\n     // Methods for io::writer\n     #[inline(always)]\n-    fn write(&self, msg: &const [u8]) {\n-\n+    fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n \n@@ -272,29 +320,19 @@ impl io::Writer for SipState {\n         self.ntail = left;\n     }\n \n-    fn seek(&self, _x: int, _s: io::SeekStyle) {\n-        fail!();\n-    }\n-    fn tell(&self) -> uint {\n-        self.length\n-    }\n-    fn flush(&self) -> int {\n-        0\n-    }\n-    fn get_type(&self) -> io::WriterType {\n-        io::File\n+    fn flush(&mut self) {\n+        // No-op\n     }\n }\n \n impl Streaming for SipState {\n-\n     #[inline(always)]\n-    fn input(&self, buf: &const [u8]) {\n+    fn input(&mut self, buf: &[u8]) {\n         self.write(buf);\n     }\n \n     #[inline(always)]\n-    fn result_u64(&self) -> u64 {\n+    fn result_u64(&mut self) -> u64 {\n         let mut v0 = self.v0;\n         let mut v1 = self.v1;\n         let mut v2 = self.v2;\n@@ -324,7 +362,7 @@ impl Streaming for SipState {\n         return (v0 ^ v1 ^ v2 ^ v3);\n     }\n \n-    fn result_bytes(&self) -> ~[u8] {\n+    fn result_bytes(&mut self) -> ~[u8] {\n         let h = self.result_u64();\n         ~[(h >> 0) as u8,\n           (h >> 8) as u8,\n@@ -337,7 +375,7 @@ impl Streaming for SipState {\n         ]\n     }\n \n-    fn result_str(&self) -> ~str {\n+    fn result_str(&mut self) -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for vec::each(r) |b| {\n@@ -347,7 +385,7 @@ impl Streaming for SipState {\n     }\n \n     #[inline(always)]\n-    fn reset(&self) {\n+    fn reset(&mut self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;\n         self.v1 = self.k1 ^ 0x646f72616e646f6d;\n@@ -529,4 +567,4 @@ mod tests {\n             val & !(0xff << (byte * 8))\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3b5c90ec1f964eb98cba4dd41825e69d299fd33a", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4dc1c2976d03b6e0fc114019341be51593ef49b2", "patch": "@@ -22,9 +22,9 @@ use util::ppaux;\n \n use core::hash::Streaming;\n use core::hash;\n-use core::io::WriterUtil;\n use core::libc::{c_int, c_uint};\n use core::os::consts::{macos, freebsd, linux, android, win32};\n+use core::rt::io::Writer;\n use core::run;\n use syntax::ast;\n use syntax::ast_map::{path, path_mod, path_name};\n@@ -41,6 +41,11 @@ pub enum output_type {\n     output_type_exe,\n }\n \n+fn write_string<W:Writer>(writer: &mut W, string: &str) {\n+    let buffer = str::as_bytes_slice(string);\n+    writer.write(buffer);\n+}\n+\n pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n@@ -458,9 +463,11 @@ pub mod write {\n  *\n  */\n \n-pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n-                   symbol_hasher: &hash::State) -> LinkMeta {\n-\n+pub fn build_link_meta(sess: Session,\n+                       c: &ast::crate,\n+                       output: &Path,\n+                       symbol_hasher: &mut hash::State)\n+                       -> LinkMeta {\n     struct ProvidedMetas {\n         name: Option<@str>,\n         vers: Option<@str>,\n@@ -498,7 +505,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     }\n \n     // This calculates CMH as defined above\n-    fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n+    fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n                               cmh_items: ~[@ast::meta_item],\n                               dep_hashes: ~[~str]) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n@@ -511,17 +518,17 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n \n         let cmh_items = attr::sort_meta_items(cmh_items);\n \n-        fn hash(symbol_hasher: &hash::State, m: &@ast::meta_item) {\n+        fn hash(symbol_hasher: &mut hash::State, m: &@ast::meta_item) {\n             match m.node {\n               ast::meta_name_value(key, value) => {\n-                symbol_hasher.write_str(len_and_str(*key));\n-                symbol_hasher.write_str(len_and_str_lit(value));\n+                write_string(symbol_hasher, len_and_str(*key));\n+                write_string(symbol_hasher, len_and_str_lit(value));\n               }\n               ast::meta_word(name) => {\n-                symbol_hasher.write_str(len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(*name));\n               }\n               ast::meta_list(name, ref mis) => {\n-                symbol_hasher.write_str(len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(*name));\n                 for mis.each |m_| {\n                     hash(symbol_hasher, m_);\n                 }\n@@ -535,7 +542,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n         }\n \n         for dep_hashes.each |dh| {\n-            symbol_hasher.write_str(len_and_str(*dh));\n+            write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n     // tjc: allocation is unfortunate; need to change core::hash\n@@ -596,23 +603,26 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     }\n }\n \n-pub fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n+pub fn truncated_hash_result(symbol_hasher: &mut hash::State) -> ~str {\n     symbol_hasher.result_str()\n }\n \n \n // This calculates STH for a symbol, as defined above\n-pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n-               link_meta: LinkMeta) -> @str {\n+pub fn symbol_hash(tcx: ty::ctxt,\n+                   symbol_hasher: &mut hash::State,\n+                   t: ty::t,\n+                   link_meta: LinkMeta)\n+                   -> @str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.write_str(link_meta.name);\n-    symbol_hasher.write_str(~\"-\");\n-    symbol_hasher.write_str(link_meta.extras_hash);\n-    symbol_hasher.write_str(~\"-\");\n-    symbol_hasher.write_str(encoder::encoded_ty(tcx, t));\n+    write_string(symbol_hasher, link_meta.name);\n+    write_string(symbol_hasher, ~\"-\");\n+    write_string(symbol_hasher, link_meta.extras_hash);\n+    write_string(symbol_hasher, ~\"-\");\n+    write_string(symbol_hasher, encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n     str::unshift_char(&mut hash, '_');"}, {"sha": "76ad7d7405365ea0e2b9d33007b87c028eebea12", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4dc1c2976d03b6e0fc114019341be51593ef49b2", "patch": "@@ -2987,9 +2987,8 @@ pub fn trans_crate(sess: session::Session,\n                    emap2: resolve::ExportMap2,\n                    maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n \n-    let symbol_hasher = @hash::default_state();\n-    let link_meta =\n-        link::build_link_meta(sess, crate, output, symbol_hasher);\n+    let symbol_hasher = @mut hash::default_state();\n+    let link_meta = link::build_link_meta(sess, crate, output, symbol_hasher);\n     let reachable = reachable::find_reachable(\n         &crate.node.module,\n         emap2,"}, {"sha": "c1309b422880affbd1a2406e013fd358541dcc81", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4dc1c2976d03b6e0fc114019341be51593ef49b2", "patch": "@@ -207,7 +207,7 @@ pub struct CrateContext {\n      adt_reprs: @mut HashMap<ty::t, @adt::Repr>,\n      names: namegen,\n      next_addrspace: addrspace_gen,\n-     symbol_hasher: @hash::State,\n+     symbol_hasher: @mut hash::State,\n      type_hashcodes: @mut HashMap<ty::t, @str>,\n      type_short_names: @mut HashMap<ty::t, ~str>,\n      all_llvm_symbols: @mut HashSet<@~str>,"}, {"sha": "fc5a9a60df29053e68b625c5e20449e686138a90", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=4dc1c2976d03b6e0fc114019341be51593ef49b2", "patch": "@@ -230,6 +230,7 @@ pub fn future_writer_factory(\n         let markdown_ch = markdown_ch.clone();\n         do task::spawn || {\n             let (writer, future) = future_writer();\n+            let mut future = future;\n             writer_ch.send(writer);\n             let s = future.get();\n             markdown_ch.send((copy page, s));"}, {"sha": "5e43cb4396075856b34d1f8af793439a80f8951f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc1c2976d03b6e0fc114019341be51593ef49b2/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=4dc1c2976d03b6e0fc114019341be51593ef49b2", "patch": "@@ -11,6 +11,7 @@\n use core::*;\n use core::cmp::Ord;\n use core::hash::Streaming;\n+use core::rt::io::Writer;\n use rustc::driver::{driver, session};\n use rustc::driver::session::{lib_crate, unknown_crate};\n use rustc::metadata::filesearch;\n@@ -367,9 +368,9 @@ pub fn error(msg: ~str) {\n }\n \n pub fn hash(data: ~str) -> ~str {\n-    let hasher = &hash::default_state();\n-\n-    hasher.write_str(data);\n+    let mut hasher = hash::default_state();\n+    let buffer = str::as_bytes_slice(data);\n+    hasher.write(buffer);\n     hasher.result_str()\n }\n "}]}