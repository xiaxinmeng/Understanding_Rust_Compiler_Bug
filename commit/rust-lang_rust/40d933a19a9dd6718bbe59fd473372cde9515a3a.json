{"sha": "40d933a19a9dd6718bbe59fd473372cde9515a3a", "node_id": "C_kwDOAAsO6NoAKDQwZDkzM2ExOWE5ZGQ2NzE4YmJlNTlmZDQ3MzM3MmNkZTk1MTVhM2E", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-11T05:05:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-11T05:05:26Z"}, "message": "Rollup merge of #108705 - clubby789:refutable-let-closure-borrow, r=cjgillot\n\nPrevent ICE with broken borrow in closure\n\nr? `@Nilstrieb`\nFixes #108683\n\nThis solution isn't ideal, I'm hoping to find a way to continue compilation without ICEing.", "tree": {"sha": "ff05f28fac7b853a2baf3b4b683d89318c38dd84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff05f28fac7b853a2baf3b4b683d89318c38dd84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40d933a19a9dd6718bbe59fd473372cde9515a3a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkXHeWCRBK7hj4Ov3rIwAAFzkIAKimCg6Lx9ueZL6ugEnEmxn/\nPE/+MU7oCpOiZwoOvr01q9sg/vtlzaaL2FYmGrYwG9KvKg4LjXFNbv+jJEWTELwG\nieAbvH2U3ay0fLiih/ZGrJrwqhtWsfqZJJh2kAJy8rRaNBQaK9E7IML72kSdaqpn\nyDej+vZ9A+4IQr1S/3M/iJE7HAChnYzmKfwPiq8cFW/VYy757NmIVXpTwp0SbeWt\nmObUGQHrpyuZohADIy4mr7eXZln6PKYVihPGnA6Q9SF0C6TnzJhSmo7FpRwAt+kx\nSO5bsIdJpeOKKZUopQHuZIDyrc5To20zzwr5l8lOhIDUpOmHzAOae0XdaA6ImZk=\n=XWa7\n-----END PGP SIGNATURE-----\n", "payload": "tree ff05f28fac7b853a2baf3b4b683d89318c38dd84\nparent 9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d\nparent 2d5ca0ea4f896201325f9d165498118b320810a7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683781526 +0200\ncommitter GitHub <noreply@github.com> 1683781526 +0200\n\nRollup merge of #108705 - clubby789:refutable-let-closure-borrow, r=cjgillot\n\nPrevent ICE with broken borrow in closure\n\nr? `@Nilstrieb`\nFixes #108683\n\nThis solution isn't ideal, I'm hoping to find a way to continue compilation without ICEing.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40d933a19a9dd6718bbe59fd473372cde9515a3a", "html_url": "https://github.com/rust-lang/rust/commit/40d933a19a9dd6718bbe59fd473372cde9515a3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40d933a19a9dd6718bbe59fd473372cde9515a3a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "html_url": "https://github.com/rust-lang/rust/commit/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d"}, {"sha": "2d5ca0ea4f896201325f9d165498118b320810a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5ca0ea4f896201325f9d165498118b320810a7", "html_url": "https://github.com/rust-lang/rust/commit/2d5ca0ea4f896201325f9d165498118b320810a7"}], "stats": {"total": 167, "additions": 154, "deletions": 13}, "files": [{"sha": "9fad2816b0d842ed5c7160dd71d64502285fd1d6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d933a19a9dd6718bbe59fd473372cde9515a3a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d933a19a9dd6718bbe59fd473372cde9515a3a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=40d933a19a9dd6718bbe59fd473372cde9515a3a", "patch": "@@ -1016,7 +1016,7 @@ rustc_queries! {\n         desc { \"converting literal to mir constant\" }\n     }\n \n-    query check_match(key: LocalDefId) {\n+    query check_match(key: LocalDefId) -> Result<(), rustc_errors::ErrorGuaranteed> {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { true }\n     }"}, {"sha": "20d381eddb1fc0b8fa6f6f4dd0ba7ba864422d48", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/40d933a19a9dd6718bbe59fd473372cde9515a3a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d933a19a9dd6718bbe59fd473372cde9515a3a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=40d933a19a9dd6718bbe59fd473372cde9515a3a", "patch": "@@ -42,7 +42,9 @@ fn mir_build(tcx: TyCtxt<'_>, def: LocalDefId) -> Body<'_> {\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n     tcx.ensure_with_value().thir_check_unsafety(def);\n     tcx.ensure_with_value().thir_abstract_const(def);\n-    tcx.ensure_with_value().check_match(def);\n+    if let Err(e) = tcx.check_match(def) {\n+        return construct_error(tcx, def, e);\n+    }\n \n     let body = match tcx.thir_body(def) {\n         Err(error_reported) => construct_error(tcx, def, error_reported),"}, {"sha": "ca25f83e6437eb35fcad769824734c899e8b45d9", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/40d933a19a9dd6718bbe59fd473372cde9515a3a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d933a19a9dd6718bbe59fd473372cde9515a3a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=40d933a19a9dd6718bbe59fd473372cde9515a3a", "patch": "@@ -26,8 +26,8 @@ use rustc_session::Session;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n-pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let Ok((thir, expr)) = tcx.thir_body(def_id) else { return };\n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGuaranteed> {\n+    let (thir, expr) = tcx.thir_body(def_id)?;\n     let thir = thir.borrow();\n     let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n@@ -37,13 +37,16 @@ pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         lint_level: tcx.hir().local_def_id_to_hir_id(def_id),\n         let_source: LetSource::None,\n         pattern_arena: &pattern_arena,\n+        error: Ok(()),\n     };\n     visitor.visit_expr(&thir[expr]);\n+\n     for param in thir.params.iter() {\n         if let Some(box ref pattern) = param.pat {\n             visitor.check_irrefutable(pattern, \"function argument\", None);\n         }\n     }\n+    visitor.error\n }\n \n fn create_e0004(\n@@ -77,6 +80,7 @@ struct MatchVisitor<'a, 'p, 'tcx> {\n     lint_level: HirId,\n     let_source: LetSource,\n     pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    error: Result<(), ErrorGuaranteed>,\n }\n \n impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n@@ -276,9 +280,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 let [pat_field] = &subpatterns[..] else { bug!() };\n                 self.check_irrefutable(&pat_field.pattern, \"`for` loop binding\", None);\n             } else {\n-                non_exhaustive_match(\n+                self.error = Err(non_exhaustive_match(\n                     &cx, self.thir, scrut_ty, scrut.span, witnesses, arms, expr_span,\n-                );\n+                ));\n             }\n         }\n     }\n@@ -406,7 +410,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n-    fn check_irrefutable(&self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n+    fn check_irrefutable(&mut self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(self.lint_level, false);\n \n         let pattern = self.lower_pattern(&mut cx, pat);\n@@ -475,7 +479,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             AdtDefinedHere { adt_def_span, ty, variants }\n         };\n \n-        self.tcx.sess.emit_err(PatternNotCovered {\n+        self.error = Err(self.tcx.sess.emit_err(PatternNotCovered {\n             span: pat.span,\n             origin,\n             uncovered: Uncovered::new(pat.span, &cx, witnesses),\n@@ -486,7 +490,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             let_suggestion,\n             misc_suggestion,\n             adt_defined_here,\n-        });\n+        }));\n     }\n }\n \n@@ -628,7 +632,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n     arms: &[ArmId],\n     expr_span: Span,\n-) {\n+) -> ErrorGuaranteed {\n     let is_empty_match = arms.is_empty();\n     let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants().is_empty(),\n@@ -640,13 +644,12 @@ fn non_exhaustive_match<'p, 'tcx>(\n     let pattern;\n     let patterns_len;\n     if is_empty_match && !non_empty_enum {\n-        cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n+        return cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n             cx,\n             expr_span,\n             span: sp,\n             ty: scrut_ty,\n         });\n-        return;\n     } else {\n         // FIXME: migration of this diagnostic will require list support\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n@@ -797,7 +800,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     } else {\n         err.help(msg);\n     }\n-    err.emit();\n+    err.emit()\n }\n \n pub(crate) fn joined_uncovered_patterns<'p, 'tcx>("}, {"sha": "a7bf9b67d453ef2da607c74630b19f5c6679d765", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/40d933a19a9dd6718bbe59fd473372cde9515a3a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d933a19a9dd6718bbe59fd473372cde9515a3a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs?ref=40d933a19a9dd6718bbe59fd473372cde9515a3a", "patch": "@@ -0,0 +1,23 @@\n+// regression test for #108683\n+// edition:2021\n+\n+enum Refutable {\n+    A,\n+    B,\n+}\n+\n+fn example(v1: u32, v2: [u32; 4], v3: Refutable) {\n+    const PAT: u32 = 0;\n+    let v4 = &v2[..];\n+    || {\n+        let 0 = v1; //~ ERROR refutable pattern in local binding\n+        let (0 | 1) = v1; //~ ERROR refutable pattern in local binding\n+        let 1.. = v1; //~ ERROR refutable pattern in local binding\n+        let [0, 0, 0, 0] = v2; //~ ERROR refutable pattern in local binding\n+        let [0] = v4; //~ ERROR refutable pattern in local binding\n+        let Refutable::A = v3; //~ ERROR refutable pattern in local binding\n+        let PAT = v1; //~ ERROR refutable pattern in local binding\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "ca8c2a16d323f9fcbca2c72d7c4a8377438e9ae1", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/40d933a19a9dd6718bbe59fd473372cde9515a3a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40d933a19a9dd6718bbe59fd473372cde9515a3a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr?ref=40d933a19a9dd6718bbe59fd473372cde9515a3a", "patch": "@@ -0,0 +1,113 @@\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:13:13\n+   |\n+LL |         let 0 = v1;\n+   |             ^ pattern `1_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 0 = v1 { todo!() };\n+   |         ++            +++++++++++\n+help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+   |\n+LL |         let _0 = v1;\n+   |             +\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:14:14\n+   |\n+LL |         let (0 | 1) = v1;\n+   |              ^^^^^ pattern `2_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let (0 | 1) = v1 { todo!() };\n+   |         ++                  +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:15:13\n+   |\n+LL |         let 1.. = v1;\n+   |             ^^^ pattern `0_u32` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 1.. = v1 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:16:13\n+   |\n+LL |         let [0, 0, 0, 0] = v2;\n+   |             ^^^^^^^^^^^^ pattern `[1_u32..=u32::MAX, _, _, _]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `[u32; 4]`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let [0, 0, 0, 0] = v2 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:17:13\n+   |\n+LL |         let [0] = v4;\n+   |             ^^^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `&[u32]`\n+help: you might want to use `if let` to ignore the variants that aren't matched\n+   |\n+LL |         if let [0] = v4 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:18:13\n+   |\n+LL |         let Refutable::A = v3;\n+   |             ^^^^^^^^^^^^ pattern `Refutable::B` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Refutable` defined here\n+  --> $DIR/bad-pattern.rs:4:6\n+   |\n+LL | enum Refutable {\n+   |      ^^^^^^^^^\n+LL |     A,\n+LL |     B,\n+   |     - not covered\n+   = note: the matched value is of type `Refutable`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let Refutable::A = v3 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:19:13\n+   |\n+LL |         let PAT = v1;\n+   |             ^^^\n+   |             |\n+   |             pattern `1_u32..=u32::MAX` not covered\n+   |             missing patterns are not covered because `PAT` is interpreted as a constant pattern, not a new variable\n+   |             help: introduce a variable instead: `PAT_var`\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0005`."}]}