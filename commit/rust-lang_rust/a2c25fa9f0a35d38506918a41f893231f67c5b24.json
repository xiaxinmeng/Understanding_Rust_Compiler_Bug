{"sha": "a2c25fa9f0a35d38506918a41f893231f67c5b24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYzI1ZmE5ZjBhMzVkMzg1MDY5MThhNDFmODkzMjMxZjY3YzViMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-23T21:56:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-23T21:56:25Z"}, "message": "Auto merge of #6573 - Jarcho:option_match_map, r=llogiq\n\nNew lint: option_manual_map\n\nfixes: #6\nchangelog: Added lint: `match_map`", "tree": {"sha": "a3748f54d242499a81f074c849a3c26e440f2733", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3748f54d242499a81f074c849a3c26e440f2733"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2c25fa9f0a35d38506918a41f893231f67c5b24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c25fa9f0a35d38506918a41f893231f67c5b24", "html_url": "https://github.com/rust-lang/rust/commit/a2c25fa9f0a35d38506918a41f893231f67c5b24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2c25fa9f0a35d38506918a41f893231f67c5b24/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5c5c8f3b06a1f21d913410ee1449f942a7839b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c5c8f3b06a1f21d913410ee1449f942a7839b6", "html_url": "https://github.com/rust-lang/rust/commit/a5c5c8f3b06a1f21d913410ee1449f942a7839b6"}, {"sha": "23aa2f880cc0bda7ea3bbef1391f7c4d86467d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/23aa2f880cc0bda7ea3bbef1391f7c4d86467d65", "html_url": "https://github.com/rust-lang/rust/commit/23aa2f880cc0bda7ea3bbef1391f7c4d86467d65"}], "stats": {"total": 657, "additions": 656, "deletions": 1}, "files": [{"sha": "d96c74b6e412650ad73369573a01abd6549fcce5", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c25fa9f0a35d38506918a41f893231f67c5b24/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2c25fa9f0a35d38506918a41f893231f67c5b24/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a2c25fa9f0a35d38506918a41f893231f67c5b24", "patch": "@@ -2162,6 +2162,7 @@ Released 2018-09-13\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n+[`manual_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_map\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or"}, {"sha": "d66e3720be0d1c7a71ddc9815efc936b61a90538", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2c25fa9f0a35d38506918a41f893231f67c5b24/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c25fa9f0a35d38506918a41f893231f67c5b24/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a2c25fa9f0a35d38506918a41f893231f67c5b24", "patch": "@@ -242,6 +242,7 @@ mod loops;\n mod macro_use;\n mod main_recursion;\n mod manual_async_fn;\n+mod manual_map;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n mod manual_strip;\n@@ -708,6 +709,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &macro_use::MACRO_USE_IMPORTS,\n         &main_recursion::MAIN_RECURSION,\n         &manual_async_fn::MANUAL_ASYNC_FN,\n+        &manual_map::MANUAL_MAP,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &manual_ok_or::MANUAL_OK_OR,\n         &manual_strip::MANUAL_STRIP,\n@@ -1265,6 +1267,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n     store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n     store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n+    store.register_late_pass(|| box manual_map::ManualMap);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1526,6 +1529,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_map::MANUAL_MAP),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n@@ -1755,6 +1759,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n+        LintId::of(&manual_map::MANUAL_MAP),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),"}, {"sha": "a50a3943bab7bd360b1b0c8bbf3122a7fb80174c", "filename": "clippy_lints/src/manual_map.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/a2c25fa9f0a35d38506918a41f893231f67c5b24/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c25fa9f0a35d38506918a41f893231f67c5b24/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=a2c25fa9f0a35d38506918a41f893231f67c5b24", "patch": "@@ -0,0 +1,274 @@\n+use crate::{\n+    map_unit_fn::OPTION_MAP_UNIT_FN,\n+    matches::MATCH_AS_REF,\n+    utils::{\n+        is_allowed, is_type_diagnostic_item, match_def_path, match_var, paths, peel_hir_expr_refs,\n+        peel_mid_ty_refs_is_mutable, snippet_with_applicability, span_lint_and_sugg,\n+    },\n+};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Mutability, Pat, PatKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::{sym, Ident};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n+    ///\n+    /// **Why is this bad?** Using the `map` method is clearer and more concise.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// match Some(0) {\n+    ///     Some(x) => Some(x + 1),\n+    ///     None => None,\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// Some(0).map(|x| x + 1);\n+    /// ```\n+    pub MANUAL_MAP,\n+    style,\n+    \"reimplementation of `map`\"\n+}\n+\n+declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n+\n+impl LateLintPass<'_> for ManualMap {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+\n+        if let ExprKind::Match(scrutinee, [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }], _) =\n+            expr.kind\n+        {\n+            let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+                peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+            if !is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+                || !is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type)\n+            {\n+                return;\n+            }\n+\n+            let (some_expr, some_pat, pat_ref_count, is_wild_none) =\n+                match (try_parse_pattern(cx, arm1.pat), try_parse_pattern(cx, arm2.pat)) {\n+                    (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n+                        if is_none_expr(cx, arm1.body) =>\n+                    {\n+                        (arm2.body, pattern, ref_count, true)\n+                    },\n+                    (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n+                        if is_none_expr(cx, arm1.body) =>\n+                    {\n+                        (arm2.body, pattern, ref_count, false)\n+                    },\n+                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n+                        if is_none_expr(cx, arm2.body) =>\n+                    {\n+                        (arm1.body, pattern, ref_count, true)\n+                    },\n+                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n+                        if is_none_expr(cx, arm2.body) =>\n+                    {\n+                        (arm1.body, pattern, ref_count, false)\n+                    },\n+                    _ => return,\n+                };\n+\n+            // Top level or patterns aren't allowed in closures.\n+            if matches!(some_pat.kind, PatKind::Or(_)) {\n+                return;\n+            }\n+\n+            let some_expr = match get_some_expr(cx, some_expr) {\n+                Some(expr) => expr,\n+                None => return,\n+            };\n+\n+            if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+                && !is_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+            {\n+                return;\n+            }\n+\n+            // Determine which binding mode to use.\n+            let explicit_ref = some_pat.contains_explicit_ref_binding();\n+            let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+\n+            let as_ref_str = match binding_ref {\n+                Some(Mutability::Mut) => \".as_mut()\",\n+                Some(Mutability::Not) => \".as_ref()\",\n+                None => \"\",\n+            };\n+\n+            let mut app = Applicability::MachineApplicable;\n+\n+            // Remove address-of expressions from the scrutinee. `as_ref` will be called,\n+            // the type is copyable, or the option is being passed by value.\n+            let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+            let scrutinee_str = snippet_with_applicability(cx, scrutinee.span, \"_\", &mut app);\n+            let scrutinee_str = if expr.precedence().order() < PREC_POSTFIX {\n+                // Parens are needed to chain method calls.\n+                format!(\"({})\", scrutinee_str)\n+            } else {\n+                scrutinee_str.into()\n+            };\n+\n+            let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n+                if let Some(func) = can_pass_as_func(cx, some_binding, some_expr) {\n+                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+                } else {\n+                    if match_var(some_expr, some_binding.name)\n+                        && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                        && binding_ref.is_some()\n+                    {\n+                        return;\n+                    }\n+\n+                    // `ref` and `ref mut` annotations were handled earlier.\n+                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                        \"mut \"\n+                    } else {\n+                        \"\"\n+                    };\n+                    format!(\n+                        \"|{}{}| {}\",\n+                        annotation,\n+                        some_binding,\n+                        snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n+                    )\n+                }\n+            } else if !is_wild_none && explicit_ref.is_none() {\n+                // TODO: handle explicit reference annotations.\n+                format!(\n+                    \"|{}| {}\",\n+                    snippet_with_applicability(cx, some_pat.span, \"..\", &mut app),\n+                    snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n+                )\n+            } else {\n+                // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+                return;\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_MAP,\n+                expr.span,\n+                \"manual implementation of `Option::map`\",\n+                \"try this\",\n+                format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str),\n+                app,\n+            );\n+        }\n+    }\n+}\n+\n+// Checks whether the expression could be passed as a function, or whether a closure is needed.\n+// Returns the function to be passed to `map` if it exists.\n+fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(func, [arg])\n+            if match_var(arg, binding.name) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+        {\n+            Some(func)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+enum OptionPat<'a> {\n+    Wild,\n+    None,\n+    Some {\n+        // The pattern contained in the `Some` tuple.\n+        pattern: &'a Pat<'a>,\n+        // The number of references before the `Some` tuple.\n+        // e.g. `&&Some(_)` has a ref count of 2.\n+        ref_count: usize,\n+    },\n+}\n+\n+// Try to parse into a recognized `Option` pattern.\n+// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n+fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<OptionPat<'tcx>> {\n+    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n+            PatKind::Wild => Some(OptionPat::Wild),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1),\n+            PatKind::Path(QPath::Resolved(None, path))\n+                if path\n+                    .res\n+                    .opt_def_id()\n+                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)) =>\n+            {\n+                Some(OptionPat::None)\n+            },\n+            PatKind::TupleStruct(QPath::Resolved(None, path), [pattern], _)\n+                if path\n+                    .res\n+                    .opt_def_id()\n+                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME)) =>\n+            {\n+                Some(OptionPat::Some { pattern, ref_count })\n+            },\n+            _ => None,\n+        }\n+    }\n+    f(cx, pat, 0)\n+}\n+\n+// Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n+fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    // TODO: Allow more complex expressions.\n+    match expr.kind {\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(QPath::Resolved(None, path)),\n+                ..\n+            },\n+            [arg],\n+        ) => {\n+            if match_def_path(cx, path.res.opt_def_id()?, &paths::OPTION_SOME) {\n+                Some(arg)\n+            } else {\n+                None\n+            }\n+        },\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) => get_some_expr(cx, expr),\n+        _ => None,\n+    }\n+}\n+\n+// Checks for the `None` value.\n+fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Path(QPath::Resolved(None, path)) => path\n+            .res\n+            .opt_def_id()\n+            .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_NONE)),\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                ..\n+            },\n+            _,\n+        ) => is_none_expr(cx, expr),\n+        _ => false,\n+    }\n+}"}, {"sha": "40771449264e72bda4b71c3901be186bffe3e05e", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2c25fa9f0a35d38506918a41f893231f67c5b24/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c25fa9f0a35d38506918a41f893231f67c5b24/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a2c25fa9f0a35d38506918a41f893231f67c5b24", "patch": "@@ -32,7 +32,7 @@ use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, Attribute, LitKind};\n+use rustc_ast::ast::{self, Attribute, BorrowKind, LitKind, Mutability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -1672,6 +1672,18 @@ pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>,\n     f(expr, 0, count)\n }\n \n+/// Peels off all references on the expression. Returns the underlying expression and the number of\n+/// references removed.\n+pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n+    fn f(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+        match expr.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, _, expr) => f(expr, count + 1),\n+            _ => (expr, count),\n+        }\n+    }\n+    f(expr, 0)\n+}\n+\n /// Peels off all references on the type. Returns the underlying type and the number of references\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n@@ -1685,6 +1697,19 @@ pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     peel(ty, 0)\n }\n \n+/// Peels off all references on the type.Returns the underlying type, the number of references\n+/// removed, and whether the pointer is ultimately mutable or not.\n+pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n+    fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n+        match ty.kind() {\n+            ty::Ref(_, ty, Mutability::Mut) => f(ty, count + 1, mutability),\n+            ty::Ref(_, ty, Mutability::Not) => f(ty, count + 1, Mutability::Not),\n+            _ => (ty, count, mutability),\n+        }\n+    }\n+    f(ty, 0, Mutability::Mut)\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{"}, {"sha": "193509067582546244233ce967985a82d9169d0d", "filename": "tests/ui/manual_map_option.fixed", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a2c25fa9f0a35d38506918a41f893231f67c5b24/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a2c25fa9f0a35d38506918a41f893231f67c5b24/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=a2c25fa9f0a35d38506918a41f893231f67c5b24", "patch": "@@ -0,0 +1,70 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+\n+fn main() {\n+    Some(0).map(|_| 2);\n+\n+    Some(0).map(|x| x + 1);\n+\n+    Some(\"\").map(|x| x.is_empty());\n+\n+    Some(0).map(|x| !x);\n+\n+    #[rustfmt::skip]\n+    Some(0).map(std::convert::identity);\n+\n+    Some(&String::new()).map(|x| str::len(x));\n+\n+    match Some(0) {\n+        Some(x) if false => Some(x + 1),\n+        _ => None,\n+    };\n+\n+    Some([0, 1]).as_ref().map(|x| x[0]);\n+\n+    Some(0).map(|x| x * 2);\n+\n+    Some(String::new()).as_ref().map(|x| x.is_empty());\n+\n+    Some(String::new()).as_ref().map(|x| x.len());\n+\n+    Some(0).map(|x| x + x);\n+\n+    #[warn(clippy::option_map_unit_fn)]\n+    match &mut Some(String::new()) {\n+        Some(x) => Some(x.push_str(\"\")),\n+        None => None,\n+    };\n+\n+    #[allow(clippy::option_map_unit_fn)]\n+    {\n+        Some(String::new()).as_mut().map(|x| x.push_str(\"\"));\n+    }\n+\n+    Some(String::new()).as_ref().map(|x| x.len());\n+\n+    Some(String::new()).as_ref().map(|x| x.is_empty());\n+\n+    Some((0, 1, 2)).map(|(x, y, z)| x + y + z);\n+\n+    Some([1, 2, 3]).map(|[first, ..]| first);\n+\n+    Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x));\n+\n+    match Some((String::new(), 0)) {\n+        Some((ref x, y)) => Some((y, x)),\n+        None => None,\n+    };\n+\n+    match Some(Some(0)) {\n+        Some(Some(_)) | Some(None) => Some(0),\n+        None => None,\n+    };\n+\n+    match Some(Some((0, 1))) {\n+        Some(Some((x, 1))) => Some(x),\n+        _ => None,\n+    };\n+}"}, {"sha": "8b8187db0a9798217c024cddf2e40f6b93a05112", "filename": "tests/ui/manual_map_option.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a2c25fa9f0a35d38506918a41f893231f67c5b24/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c25fa9f0a35d38506918a41f893231f67c5b24/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=a2c25fa9f0a35d38506918a41f893231f67c5b24", "patch": "@@ -0,0 +1,122 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_map)]\n+#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+\n+fn main() {\n+    match Some(0) {\n+        Some(_) => Some(2),\n+        None::<u32> => None,\n+    };\n+\n+    match Some(0) {\n+        Some(x) => Some(x + 1),\n+        _ => None,\n+    };\n+\n+    match Some(\"\") {\n+        Some(x) => Some(x.is_empty()),\n+        None => None,\n+    };\n+\n+    if let Some(x) = Some(0) {\n+        Some(!x)\n+    } else {\n+        None\n+    };\n+\n+    #[rustfmt::skip]\n+    match Some(0) {\n+        Some(x) => { Some(std::convert::identity(x)) }\n+        None => { None }\n+    };\n+\n+    match Some(&String::new()) {\n+        Some(x) => Some(str::len(x)),\n+        None => None,\n+    };\n+\n+    match Some(0) {\n+        Some(x) if false => Some(x + 1),\n+        _ => None,\n+    };\n+\n+    match &Some([0, 1]) {\n+        Some(x) => Some(x[0]),\n+        &None => None,\n+    };\n+\n+    match &Some(0) {\n+        &Some(x) => Some(x * 2),\n+        None => None,\n+    };\n+\n+    match Some(String::new()) {\n+        Some(ref x) => Some(x.is_empty()),\n+        _ => None,\n+    };\n+\n+    match &&Some(String::new()) {\n+        Some(x) => Some(x.len()),\n+        _ => None,\n+    };\n+\n+    match &&Some(0) {\n+        &&Some(x) => Some(x + x),\n+        &&_ => None,\n+    };\n+\n+    #[warn(clippy::option_map_unit_fn)]\n+    match &mut Some(String::new()) {\n+        Some(x) => Some(x.push_str(\"\")),\n+        None => None,\n+    };\n+\n+    #[allow(clippy::option_map_unit_fn)]\n+    {\n+        match &mut Some(String::new()) {\n+            Some(x) => Some(x.push_str(\"\")),\n+            None => None,\n+        };\n+    }\n+\n+    match &mut Some(String::new()) {\n+        Some(ref x) => Some(x.len()),\n+        None => None,\n+    };\n+\n+    match &mut &Some(String::new()) {\n+        Some(x) => Some(x.is_empty()),\n+        &mut _ => None,\n+    };\n+\n+    match Some((0, 1, 2)) {\n+        Some((x, y, z)) => Some(x + y + z),\n+        None => None,\n+    };\n+\n+    match Some([1, 2, 3]) {\n+        Some([first, ..]) => Some(first),\n+        None => None,\n+    };\n+\n+    match &Some((String::new(), \"test\")) {\n+        Some((x, y)) => Some((y, x)),\n+        None => None,\n+    };\n+\n+    match Some((String::new(), 0)) {\n+        Some((ref x, y)) => Some((y, x)),\n+        None => None,\n+    };\n+\n+    match Some(Some(0)) {\n+        Some(Some(_)) | Some(None) => Some(0),\n+        None => None,\n+    };\n+\n+    match Some(Some((0, 1))) {\n+        Some(Some((x, 1))) => Some(x),\n+        _ => None,\n+    };\n+}"}, {"sha": "210a30d05d40f30ce4c6480a1a17ccccc81524fc", "filename": "tests/ui/manual_map_option.stderr", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a2c25fa9f0a35d38506918a41f893231f67c5b24/tests%2Fui%2Fmanual_map_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2c25fa9f0a35d38506918a41f893231f67c5b24/tests%2Fui%2Fmanual_map_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.stderr?ref=a2c25fa9f0a35d38506918a41f893231f67c5b24", "patch": "@@ -0,0 +1,158 @@\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:7:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(_) => Some(2),\n+LL | |         None::<u32> => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|_| 2)`\n+   |\n+   = note: `-D clippy::manual-map` implied by `-D warnings`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:12:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(x) => Some(x + 1),\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| x + 1)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:17:5\n+   |\n+LL | /     match Some(\"\") {\n+LL | |         Some(x) => Some(x.is_empty()),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(\"\").map(|x| x.is_empty())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:22:5\n+   |\n+LL | /     if let Some(x) = Some(0) {\n+LL | |         Some(!x)\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| !x)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:29:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(x) => { Some(std::convert::identity(x)) }\n+LL | |         None => { None }\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(std::convert::identity)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:34:5\n+   |\n+LL | /     match Some(&String::new()) {\n+LL | |         Some(x) => Some(str::len(x)),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(&String::new()).map(|x| str::len(x))`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:44:5\n+   |\n+LL | /     match &Some([0, 1]) {\n+LL | |         Some(x) => Some(x[0]),\n+LL | |         &None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some([0, 1]).as_ref().map(|x| x[0])`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:49:5\n+   |\n+LL | /     match &Some(0) {\n+LL | |         &Some(x) => Some(x * 2),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| x * 2)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:54:5\n+   |\n+LL | /     match Some(String::new()) {\n+LL | |         Some(ref x) => Some(x.is_empty()),\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:59:5\n+   |\n+LL | /     match &&Some(String::new()) {\n+LL | |         Some(x) => Some(x.len()),\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:64:5\n+   |\n+LL | /     match &&Some(0) {\n+LL | |         &&Some(x) => Some(x + x),\n+LL | |         &&_ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| x + x)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:77:9\n+   |\n+LL | /         match &mut Some(String::new()) {\n+LL | |             Some(x) => Some(x.push_str(\"\")),\n+LL | |             None => None,\n+LL | |         };\n+   | |_________^ help: try this: `Some(String::new()).as_mut().map(|x| x.push_str(\"\"))`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:83:5\n+   |\n+LL | /     match &mut Some(String::new()) {\n+LL | |         Some(ref x) => Some(x.len()),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:88:5\n+   |\n+LL | /     match &mut &Some(String::new()) {\n+LL | |         Some(x) => Some(x.is_empty()),\n+LL | |         &mut _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:93:5\n+   |\n+LL | /     match Some((0, 1, 2)) {\n+LL | |         Some((x, y, z)) => Some(x + y + z),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some((0, 1, 2)).map(|(x, y, z)| x + y + z)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:98:5\n+   |\n+LL | /     match Some([1, 2, 3]) {\n+LL | |         Some([first, ..]) => Some(first),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some([1, 2, 3]).map(|[first, ..]| first)`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:103:5\n+   |\n+LL | /     match &Some((String::new(), \"test\")) {\n+LL | |         Some((x, y)) => Some((y, x)),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x))`\n+\n+error: aborting due to 17 previous errors\n+"}]}