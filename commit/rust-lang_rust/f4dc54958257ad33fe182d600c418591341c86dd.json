{"sha": "f4dc54958257ad33fe182d600c418591341c86dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZGM1NDk1ODI1N2FkMzNmZTE4MmQ2MDBjNDE4NTkxMzQxYzg2ZGQ=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-06-23T08:59:18Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-06-27T01:33:00Z"}, "message": "SSR: Allow matching within macro calls", "tree": {"sha": "a250def8c836e089a6b296db9502f24a45c92061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a250def8c836e089a6b296db9502f24a45c92061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4dc54958257ad33fe182d600c418591341c86dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4dc54958257ad33fe182d600c418591341c86dd", "html_url": "https://github.com/rust-lang/rust/commit/f4dc54958257ad33fe182d600c418591341c86dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4dc54958257ad33fe182d600c418591341c86dd/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd", "html_url": "https://github.com/rust-lang/rust/commit/9a4d02faf9c47f401b8756c3f7fcab2198f5f9cd"}], "stats": {"total": 71, "additions": 69, "deletions": 2}, "files": [{"sha": "8f149e3db656a45b15ae74dac641e33fa9f9aa07", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4dc54958257ad33fe182d600c418591341c86dd/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dc54958257ad33fe182d600c418591341c86dd/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=f4dc54958257ad33fe182d600c418591341c86dd", "patch": "@@ -12,7 +12,7 @@ mod tests;\n use crate::matching::Match;\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{AstNode, SmolStr, SyntaxNode};\n+use ra_syntax::{ast, AstNode, SmolStr, SyntaxNode};\n use ra_text_edit::TextEdit;\n use rustc_hash::FxHashMap;\n \n@@ -107,6 +107,22 @@ impl<'db> MatchFinder<'db> {\n                 return;\n             }\n         }\n+        // If we've got a macro call, we already tried matching it pre-expansion, which is the only\n+        // way to match the whole macro, now try expanding it and matching the expansion.\n+        if let Some(macro_call) = ast::MacroCall::cast(code.clone()) {\n+            if let Some(expanded) = self.sema.expand(&macro_call) {\n+                if let Some(tt) = macro_call.token_tree() {\n+                    // When matching within a macro expansion, we only want to allow matches of\n+                    // nodes that originated entirely from within the token tree of the macro call.\n+                    // i.e. we don't want to match something that came from the macro itself.\n+                    self.find_matches(\n+                        &expanded,\n+                        &Some(self.sema.original_range(tt.syntax())),\n+                        matches_out,\n+                    );\n+                }\n+            }\n+        }\n         for child in code.children() {\n             self.find_matches(&child, restrict_range, matches_out);\n         }"}, {"sha": "85420ed3ca5d806034389245af33af734b0aab87", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4dc54958257ad33fe182d600c418591341c86dd/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dc54958257ad33fe182d600c418591341c86dd/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=f4dc54958257ad33fe182d600c418591341c86dd", "patch": "@@ -343,7 +343,9 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n \n     /// Outside of token trees, a placeholder can only match a single AST node, whereas in a token\n-    /// tree it can match a sequence of tokens.\n+    /// tree it can match a sequence of tokens. Note, that this code will only be used when the\n+    /// pattern matches the macro invocation. For matches within the macro call, we'll already have\n+    /// expanded the macro.\n     fn attempt_match_token_tree(\n         &mut self,\n         match_inputs: &MatchInputs,"}, {"sha": "d7e6d817a0fa5ac12b5bb3f5b940f0096cdfc672", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f4dc54958257ad33fe182d600c418591341c86dd/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dc54958257ad33fe182d600c418591341c86dd/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=f4dc54958257ad33fe182d600c418591341c86dd", "patch": "@@ -355,6 +355,18 @@ fn match_nested_method_calls() {\n     );\n }\n \n+// Make sure that our node matching semantics don't differ within macro calls.\n+#[test]\n+fn match_nested_method_calls_with_macro_call() {\n+    assert_matches(\n+        \"$a.z().z().z()\",\n+        r#\"\n+            macro_rules! m1 { ($a:expr) => {$a}; }\n+            fn f() {m1!(h().i().j().z().z().z().d().e())}\"#,\n+        &[\"h().i().j().z().z().z()\"],\n+    );\n+}\n+\n #[test]\n fn match_complex_expr() {\n     let code = \"fn f() -> i32 {foo(bar(40, 2), 42)}\";\n@@ -547,3 +559,40 @@ fn multiple_rules() {\n         \"fn f() -> i32 {add_one(add(3, 2))}\",\n     )\n }\n+\n+#[test]\n+fn match_within_macro_invocation() {\n+    let code = r#\"\n+            macro_rules! foo {\n+                ($a:stmt; $b:expr) => {\n+                    $b\n+                };\n+            }\n+            struct A {}\n+            impl A {\n+                fn bar() {}\n+            }\n+            fn f1() {\n+                let aaa = A {};\n+                foo!(macro_ignores_this(); aaa.bar());\n+            }\n+        \"#;\n+    assert_matches(\"$a.bar()\", code, &[\"aaa.bar()\"]);\n+}\n+\n+#[test]\n+fn replace_within_macro_expansion() {\n+    assert_ssr_transform(\n+        \"$a.foo() ==>> bar($a)\",\n+        r#\"\n+            macro_rules! macro1 {\n+                ($a:expr) => {$a}\n+            }\n+            fn f() {macro1!(5.x().foo().o2())}\"#,\n+        r#\"\n+            macro_rules! macro1 {\n+                ($a:expr) => {$a}\n+            }\n+            fn f() {macro1!(bar(5.x()).o2())}\"#,\n+    )\n+}"}]}