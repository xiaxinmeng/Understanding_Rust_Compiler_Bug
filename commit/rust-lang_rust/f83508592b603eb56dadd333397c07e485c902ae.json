{"sha": "f83508592b603eb56dadd333397c07e485c902ae", "node_id": "C_kwDOAAsO6NoAKGY4MzUwODU5MmI2MDNlYjU2ZGFkZDMzMzM5N2MwN2U0ODVjOTAyYWU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-12-01T01:20:38Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-12-21T03:50:15Z"}, "message": "Suggest glob-import if we need to import a trait, but it has no visible name", "tree": {"sha": "150babb2589d3e8c96c9316996be27aa29286538", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/150babb2589d3e8c96c9316996be27aa29286538"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f83508592b603eb56dadd333397c07e485c902ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f83508592b603eb56dadd333397c07e485c902ae", "html_url": "https://github.com/rust-lang/rust/commit/f83508592b603eb56dadd333397c07e485c902ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f83508592b603eb56dadd333397c07e485c902ae/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c327627a684215b6fed9dd5ab470b56c48d34080", "url": "https://api.github.com/repos/rust-lang/rust/commits/c327627a684215b6fed9dd5ab470b56c48d34080", "html_url": "https://github.com/rust-lang/rust/commit/c327627a684215b6fed9dd5ab470b56c48d34080"}], "stats": {"total": 75, "additions": 68, "deletions": 7}, "files": [{"sha": "d5a4de86d4d1eea4d3ea32967c4aadf5fdee1903", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f83508592b603eb56dadd333397c07e485c902ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83508592b603eb56dadd333397c07e485c902ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f83508592b603eb56dadd333397c07e485c902ae", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::fast_reject::{simplify_type, SimplifyParams, StripReferences};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, MultiSpan, Span, Symbol};\n@@ -1310,25 +1310,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mut msg: String,\n         candidates: Vec<DefId>,\n     ) {\n+        let parent_map = self.tcx.visible_parent_map(());\n+\n+        // Separate out candidates that must be imported with a glob, because they are named `_`\n+        // and cannot be referred with their identifier.\n+        let (candidates, globs): (Vec<_>, Vec<_>) = candidates.into_iter().partition(|trait_did| {\n+            if let Some(parent_did) = parent_map.get(trait_did) {\n+                // If the item is re-exported as `_`, we should suggest a glob-import instead.\n+                if Some(*parent_did) != self.tcx.parent(*trait_did)\n+                    && self\n+                        .tcx\n+                        .item_children(*parent_did)\n+                        .iter()\n+                        .filter(|child| child.res.opt_def_id() == Some(*trait_did))\n+                        .all(|child| child.ident.name == kw::Underscore)\n+                {\n+                    return false;\n+                }\n+            }\n+\n+            true\n+        });\n+\n         let module_did = self.tcx.parent_module(self.body_id);\n         let (span, found_use) = find_use_placement(self.tcx, module_did);\n         if let Some(span) = span {\n-            let path_strings = candidates.iter().map(|did| {\n+            let path_strings = candidates.iter().map(|trait_did| {\n                 // Produce an additional newline to separate the new use statement\n                 // from the directly following item.\n                 let additional_newline = if found_use { \"\" } else { \"\\n\" };\n                 format!(\n                     \"use {};\\n{}\",\n-                    with_crate_prefix(|| self.tcx.def_path_str(*did)),\n+                    with_crate_prefix(|| self.tcx.def_path_str(*trait_did)),\n                     additional_newline\n                 )\n             });\n \n-            err.span_suggestions(span, &msg, path_strings, Applicability::MaybeIncorrect);\n+            let glob_path_strings = globs.iter().map(|trait_did| {\n+                let parent_did = parent_map.get(trait_did).unwrap();\n+\n+                // Produce an additional newline to separate the new use statement\n+                // from the directly following item.\n+                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n+                format!(\n+                    \"use {}::*; // trait {}\\n{}\",\n+                    with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                    self.tcx.item_name(*trait_did),\n+                    additional_newline\n+                )\n+            });\n+\n+            err.span_suggestions(\n+                span,\n+                &msg,\n+                path_strings.chain(glob_path_strings),\n+                Applicability::MaybeIncorrect,\n+            );\n         } else {\n-            let limit = if candidates.len() == 5 { 5 } else { 4 };\n+            let limit = if candidates.len() + globs.len() == 5 { 5 } else { 4 };\n             for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                if candidates.len() > 1 {\n+                if candidates.len() + globs.len() > 1 {\n                     msg.push_str(&format!(\n                         \"\\ncandidate #{}: `use {};`\",\n                         i + 1,\n@@ -1341,8 +1382,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ));\n                 }\n             }\n+            for (i, trait_did) in\n+                globs.iter().take(limit.saturating_sub(candidates.len())).enumerate()\n+            {\n+                let parent_did = parent_map.get(trait_did).unwrap();\n+\n+                if candidates.len() + globs.len() > 1 {\n+                    msg.push_str(&format!(\n+                        \"\\ncandidate #{}: `use {}::*; // trait {}`\",\n+                        candidates.len() + i + 1,\n+                        with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                        self.tcx.item_name(*trait_did),\n+                    ));\n+                } else {\n+                    msg.push_str(&format!(\n+                        \"\\n`use {}::*; // trait {}`\",\n+                        with_crate_prefix(|| self.tcx.def_path_str(*parent_did)),\n+                        self.tcx.item_name(*trait_did),\n+                    ));\n+                }\n+            }\n             if candidates.len() > limit {\n-                msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n+                msg.push_str(&format!(\"\\nand {} others\", candidates.len() + globs.len() - limit));\n             }\n             err.note(&msg);\n         }"}]}