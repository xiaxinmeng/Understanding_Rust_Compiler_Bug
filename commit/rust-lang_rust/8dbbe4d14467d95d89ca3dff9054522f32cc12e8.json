{"sha": "8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYmJlNGQxNDQ2N2Q5NWQ4OWNhM2RmZjkwNTQ1MjJmMzJjYzEyZTg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-25T00:10:40Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-03T19:42:15Z"}, "message": "Avoid scheduling repeated `StorageDead`s\n\nAlso add some comments", "tree": {"sha": "b1b8a9303d1ef0f149a88e717e9ef507d218bae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b8a9303d1ef0f149a88e717e9ef507d218bae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "html_url": "https://github.com/rust-lang/rust/commit/8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dbbe4d14467d95d89ca3dff9054522f32cc12e8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b9dafb2c8795a542e1c93036afa02889ef696f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9dafb2c8795a542e1c93036afa02889ef696f0", "html_url": "https://github.com/rust-lang/rust/commit/9b9dafb2c8795a542e1c93036afa02889ef696f0"}], "stats": {"total": 67, "additions": 52, "deletions": 15}, "files": [{"sha": "df5526ad762812cb2322277cd229a86dbb8367c4", "filename": "src/librustc_mir_build/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbe4d14467d95d89ca3dff9054522f32cc12e8/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbe4d14467d95d89ca3dff9054522f32cc12e8/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs?ref=8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             &pattern,\n                             UserTypeProjections::none(),\n                             &mut |this, _, _, _, node, span, _, _| {\n-                                this.storage_live_binding(block, node, span, OutsideGuard);\n+                                this.storage_live_binding(block, node, span, OutsideGuard, true);\n                                 this.schedule_drop_for_binding(node, span, OutsideGuard);\n                             },\n                         )"}, {"sha": "f900ae45b94d6c8382acfeb98bef66f3dbb57a5e", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbe4d14467d95d89ca3dff9054522f32cc12e8/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbe4d14467d95d89ca3dff9054522f32cc12e8/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "patch": "@@ -274,9 +274,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         end_block.unit()\n     }\n \n-    /// Binds the variables and ascribes types for a given `match` arm.\n+    /// Binds the variables and ascribes types for a given `match` arm or\n+    /// `let` binding.\n     ///\n     /// Also check if the guard matches, if it's provided.\n+    /// `arm_scope` should be `Some` if and only if this is called for a\n+    /// `match` arm.\n     fn bind_pattern(\n         &mut self,\n         outer_source_info: SourceInfo,\n@@ -298,6 +301,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 true,\n             )\n         } else {\n+            // It's helpful to avoid scheduling drops multiple times to save\n+            // drop elaboration from having to clean up the extra drops.\n+            //\n+            // If we are in a `let` then we only schedule drops for the first\n+            // candidate.\n+            //\n+            // If we're in a `match` arm then we could have a case like so:\n+            //\n+            // Ok(x) | Err(x) if return => { /* ... */ }\n+            //\n+            // In this case we don't want a drop of `x` scheduled when we\n+            // return: it isn't bound by move until right before enter the arm.\n+            // To handle this we instead unschedule it's drop after each time\n+            // we lower the guard.\n             let target_block = self.cfg.start_new_block();\n             let mut schedule_drops = true;\n             // We keep a stack of all of the bindings and type asciptions\n@@ -308,7 +325,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 &mut Vec::new(),\n                 &mut |leaf_candidate, parent_bindings| {\n                     if let Some(arm_scope) = arm_scope {\n-                        // Avoid scheduling drops multiple times by unscheduling drops.\n                         self.clear_top_scope(arm_scope);\n                     }\n                     let binding_end = self.bind_and_guard_matched_candidate(\n@@ -320,9 +336,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         schedule_drops,\n                     );\n                     if arm_scope.is_none() {\n-                        // If we aren't in a match, then our bindings may not be\n-                        // the only thing in the top scope, so only schedule\n-                        // them to drop for the first pattern instead.\n                         schedule_drops = false;\n                     }\n                     self.cfg.goto(binding_end, outer_source_info, target_block);\n@@ -350,7 +363,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Optimize the case of `let x = ...` to write directly into `x`\n             PatKind::Binding { mode: BindingMode::ByValue, var, subpattern: None, .. } => {\n                 let place =\n-                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n                 unpack!(block = self.into(&place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n@@ -385,7 +398,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     hair::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n                 let place =\n-                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n                 unpack!(block = self.into(&place, block, initializer));\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n@@ -532,12 +545,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         var: HirId,\n         span: Span,\n         for_guard: ForGuard,\n+        schedule_drop: bool,\n     ) -> Place<'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n+        if schedule_drop {\n+            self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n+        }\n         Place::from(local_id)\n     }\n \n@@ -1060,25 +1076,31 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///      |\n     ///      +----------------------------------------+------------------------------------+\n     ///      |                                        |                                    |\n+    ///      V                                        V                                    V\n     /// [ P matches ]                           [ Q matches ]                        [ otherwise ]\n     ///      |                                        |                                    |\n+    ///      V                                        V                                    |\n     /// [ match R, S ]                          [ match R, S ]                             |\n     ///      |                                        |                                    |\n     ///      +--------------+------------+            +--------------+------------+        |\n     ///      |              |            |            |              |            |        |\n+    ///      V              V            V            V              V            V        |\n     /// [ R matches ] [ S matches ] [otherwise ] [ R matches ] [ S matches ] [otherwise ]  |\n     ///      |              |            |            |              |            |        |\n     ///      +--------------+------------|------------+--------------+            |        |\n     ///      |                           |                                        |        |\n     ///      |                           +----------------------------------------+--------+\n     ///      |                           |\n+    ///      V                           V\n     /// [ Success ]                 [ Failure ]\n     /// ```\n     ///\n     /// In practice there are some complications:\n     ///\n     /// * If there's a guard, then the otherwise branch of the first match on\n-    ///   `R | S` goes to a test for whether `Q` matches.\n+    ///   `R | S` goes to a test for whether `Q` matches, and the control flow\n+    ///   doesn't merge into a single success block until after the guard is\n+    ///   tested.\n     /// * If neither `P` or `Q` has any bindings or type ascriptions and there\n     ///   isn't a match guard, then we create a smaller CFG like:\n     ///\n@@ -1658,7 +1680,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 .flat_map(|(bindings, _)| bindings)\n                 .chain(&candidate.bindings);\n \n-            self.bind_matched_candidate_for_guard(block, bindings.clone());\n+            self.bind_matched_candidate_for_guard(block, schedule_drops, bindings.clone());\n             let guard_frame = GuardFrame {\n                 locals: bindings.map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode)).collect(),\n             };\n@@ -1807,6 +1829,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_matched_candidate_for_guard<'b>(\n         &mut self,\n         block: BasicBlock,\n+        schedule_drops: bool,\n         bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n     ) where\n         'tcx: 'b,\n@@ -1825,8 +1848,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // a reference R: &T pointing to the location matched by\n             // the pattern, and every occurrence of P within a guard\n             // denotes *R.\n-            let ref_for_guard =\n-                self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n+            let ref_for_guard = self.storage_live_binding(\n+                block,\n+                binding.var_id,\n+                binding.span,\n+                RefWithinGuard,\n+                schedule_drops,\n+            );\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_erased, BorrowKind::Shared, binding.source);\n@@ -1838,6 +1866,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         binding.var_id,\n                         binding.span,\n                         OutsideGuard,\n+                        schedule_drops,\n                     );\n \n                     let rvalue = Rvalue::Ref(re_erased, borrow_kind, binding.source);\n@@ -1863,8 +1892,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local =\n-                self.storage_live_binding(block, binding.var_id, binding.span, OutsideGuard);\n+            let local = self.storage_live_binding(\n+                block,\n+                binding.var_id,\n+                binding.span,\n+                OutsideGuard,\n+                schedule_drops,\n+            );\n             if schedule_drops {\n                 self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             }"}, {"sha": "56aa150dd37d2f46db86dc8337dc4aa8f0107673", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8dbbe4d14467d95d89ca3dff9054522f32cc12e8/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbbe4d14467d95d89ca3dff9054522f32cc12e8/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=8dbbe4d14467d95d89ca3dff9054522f32cc12e8", "patch": "@@ -75,6 +75,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    /// Given `candidate` that has a single or-pattern for its match-pairs,\n+    /// creates a fresh candidate for each of its input subpatterns passed via\n+    /// `pats`.\n     fn create_or_subcandidates<'pat>(\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,"}]}