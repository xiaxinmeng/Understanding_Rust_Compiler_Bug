{"sha": "b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MTYxYWI4ODBjYjRmNThiMmIyZTc0YjdhOGJlZDI1MTRmOGE3NTM=", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-13T16:40:06Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-14T07:46:07Z"}, "message": "Do not use `DUMMY_HIR_ID` as placeholder value in node_id_to_hir_id table\n\nSome helpers functions have been introduced to deal with (buggy) cases\nwhere either a `NodeId` or a `DefId` do not have a corresponding `HirId`.\nThose cases are tracked in issue #71104.", "tree": {"sha": "b87c79e819c84e61709d76a9881c824f0006d19d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b87c79e819c84e61709d76a9881c824f0006d19d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "html_url": "https://github.com/rust-lang/rust/commit/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "513a6473d69b3af34e6cdaa4efb288fe5283c3e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/513a6473d69b3af34e6cdaa4efb288fe5283c3e9", "html_url": "https://github.com/rust-lang/rust/commit/513a6473d69b3af34e6cdaa4efb288fe5283c3e9"}], "stats": {"total": 96, "additions": 66, "deletions": 30}, "files": [{"sha": "c2c7de9d21b28875f2bd5ad7532156b14348a204", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "patch": "@@ -168,7 +168,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     current_hir_id_owner: Vec<(LocalDefId, u32)>,\n     item_local_id_counters: NodeMap<u32>,\n-    node_id_to_hir_id: IndexVec<NodeId, hir::HirId>,\n+    node_id_to_hir_id: IndexVec<NodeId, Option<hir::HirId>>,\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n@@ -522,15 +522,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         self.lower_node_id(CRATE_NODE_ID);\n-        debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == hir::CRATE_HIR_ID);\n+        debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == Some(hir::CRATE_HIR_ID));\n \n         visit::walk_crate(&mut MiscCollector { lctx: &mut self, hir_id_owner: None }, c);\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.lower_mod(&c.module);\n         let attrs = self.lower_attrs(&c.attrs);\n         let body_ids = body_ids(&self.bodies);\n-        let proc_macros = c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id]).collect();\n+        let proc_macros =\n+            c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n \n         self.resolver.definitions().init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n \n@@ -571,26 +572,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ast_node_id: NodeId,\n         alloc_hir_id: impl FnOnce(&mut Self) -> hir::HirId,\n     ) -> hir::HirId {\n-        if ast_node_id == DUMMY_NODE_ID {\n-            return hir::DUMMY_HIR_ID;\n-        }\n+        assert_ne!(ast_node_id, DUMMY_NODE_ID);\n \n         let min_size = ast_node_id.as_usize() + 1;\n \n         if min_size > self.node_id_to_hir_id.len() {\n-            self.node_id_to_hir_id.resize(min_size, hir::DUMMY_HIR_ID);\n+            self.node_id_to_hir_id.resize(min_size, None);\n         }\n \n-        let existing_hir_id = self.node_id_to_hir_id[ast_node_id];\n-\n-        if existing_hir_id == hir::DUMMY_HIR_ID {\n+        if let Some(existing_hir_id) = self.node_id_to_hir_id[ast_node_id] {\n+            existing_hir_id\n+        } else {\n             // Generate a new `HirId`.\n             let hir_id = alloc_hir_id(self);\n-            self.node_id_to_hir_id[ast_node_id] = hir_id;\n+            self.node_id_to_hir_id[ast_node_id] = Some(hir_id);\n \n             hir_id\n-        } else {\n-            existing_hir_id\n         }\n     }\n "}, {"sha": "5e57bcdc85cfa8086e045df9dcfb2707de39efc4", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "patch": "@@ -87,7 +87,7 @@ pub struct Definitions {\n     node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n     def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n \n-    pub(super) node_id_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n+    pub(super) node_id_to_hir_id: IndexVec<ast::NodeId, Option<hir::HirId>>,\n     /// The reverse mapping of `node_id_to_hir_id`.\n     pub(super) hir_id_to_node_id: FxHashMap<hir::HirId, ast::NodeId>,\n \n@@ -359,11 +359,22 @@ impl Definitions {\n \n     #[inline]\n     pub fn node_id_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+        self.node_id_to_hir_id[node_id].unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn opt_node_id_to_hir_id(&self, node_id: ast::NodeId) -> Option<hir::HirId> {\n         self.node_id_to_hir_id[node_id]\n     }\n \n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, id: LocalDefId) -> hir::HirId {\n+        let node_id = self.def_id_to_node_id[id];\n+        self.node_id_to_hir_id[node_id].unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn opt_local_def_id_to_hir_id(&self, id: LocalDefId) -> Option<hir::HirId> {\n         let node_id = self.def_id_to_node_id[id];\n         self.node_id_to_hir_id[node_id]\n     }\n@@ -470,7 +481,10 @@ impl Definitions {\n \n     /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n-    pub fn init_node_id_to_hir_id_mapping(&mut self, mapping: IndexVec<ast::NodeId, hir::HirId>) {\n+    pub fn init_node_id_to_hir_id_mapping(\n+        &mut self,\n+        mapping: IndexVec<ast::NodeId, Option<hir::HirId>>,\n+    ) {\n         assert!(\n             self.node_id_to_hir_id.is_empty(),\n             \"trying to initialize `NodeId` -> `HirId` mapping twice\"\n@@ -481,7 +495,7 @@ impl Definitions {\n         self.hir_id_to_node_id = self\n             .node_id_to_hir_id\n             .iter_enumerated()\n-            .map(|(node_id, &hir_id)| (hir_id, node_id))\n+            .filter_map(|(node_id, &hir_id)| hir_id.map(|hir_id| (hir_id, node_id)))\n             .collect();\n     }\n "}, {"sha": "ead8529fad8becd82c0163e1199e3913a93b8c04", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "patch": "@@ -214,11 +214,21 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions.node_id_to_hir_id(node_id)\n     }\n \n+    #[inline]\n+    pub fn opt_node_id_to_hir_id(&self, node_id: NodeId) -> Option<HirId> {\n+        self.tcx.definitions.opt_node_id_to_hir_id(node_id)\n+    }\n+\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.tcx.definitions.local_def_id_to_hir_id(def_id)\n     }\n \n+    #[inline]\n+    pub fn opt_local_def_id_to_hir_id(&self, def_id: LocalDefId) -> Option<HirId> {\n+        self.tcx.definitions.opt_local_def_id_to_hir_id(def_id)\n+    }\n+\n     pub fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n         let node = self.find(hir_id)?;\n "}, {"sha": "a49dc105498ed29c99d575fc384365fc64a58fc4", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "patch": "@@ -1126,13 +1126,16 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in resolutions.trait_map {\n-            let hir_id = definitions.node_id_to_hir_id(k);\n-            let map = trait_map.entry(hir_id.owner).or_default();\n-            let v = v\n-                .into_iter()\n-                .map(|tc| tc.map_import_ids(|id| definitions.node_id_to_hir_id(id)))\n-                .collect();\n-            map.insert(hir_id.local_id, StableVec::new(v));\n+            // FIXME(#71104) Should really be using just `node_id_to_hir_id` but\n+            // some `NodeId` do not seem to have a corresponding HirId.\n+            if let Some(hir_id) = definitions.opt_node_id_to_hir_id(k) {\n+                let map = trait_map.entry(hir_id.owner).or_default();\n+                let v = v\n+                    .into_iter()\n+                    .map(|tc| tc.map_import_ids(|id| definitions.node_id_to_hir_id(id)))\n+                    .collect();\n+                map.insert(hir_id.local_id, StableVec::new(v));\n+            }\n         }\n \n         GlobalCtxt {"}, {"sha": "51e1588c71c4215e01e094f5267637ab90e8b998", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "patch": "@@ -928,7 +928,12 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n         let macro_module_def_id =\n             ty::DefIdTree::parent(self.tcx, self.tcx.hir().local_def_id(md.hir_id)).unwrap();\n-        let mut module_id = match self.tcx.hir().as_local_hir_id(macro_module_def_id) {\n+        // FIXME(#71104) Should really be using just `as_local_hir_id` but\n+        // some `DefId` do not seem to have a corresponding HirId.\n+        let hir_id = macro_module_def_id\n+            .as_local()\n+            .and_then(|def_id| self.tcx.hir().opt_local_def_id_to_hir_id(def_id));\n+        let mut module_id = match hir_id {\n             Some(module_id) if self.tcx.hir().is_hir_id_module(module_id) => module_id,\n             // `module_id` doesn't correspond to a `mod`, return early (#63164, #65252).\n             _ => return,"}, {"sha": "ba2541bc6c3d905f81935caf19aceb3308f20d06", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "patch": "@@ -225,11 +225,14 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n \n             for (id, ident, ..) in collector.collected_idents {\n-                let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n-                let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n-                    Some(s) => s.to_string(),\n-                    None => continue,\n-                };\n+                // FIXME(#71104) Should really be using just `node_id_to_hir_id` but\n+                // some `NodeId` do not seem to have a corresponding HirId.\n+                let hir_id = self.tcx.hir().opt_node_id_to_hir_id(id);\n+                let typ =\n+                    match hir_id.and_then(|hir_id| self.save_ctxt.tables.node_type_opt(hir_id)) {\n+                        Some(s) => s.to_string(),\n+                        None => continue,\n+                    };\n                 if !self.span.filter_generated(ident.span) {\n                     let id = id_from_node_id(id, &self.save_ctxt);\n                     let span = self.span_from_span(ident.span);"}, {"sha": "750a6532ac9e56957f5450677f689a9f4871feda", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9161ab880cb4f58b2b2e74b7a8bed2514f8a753/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b9161ab880cb4f58b2b2e74b7a8bed2514f8a753", "patch": "@@ -838,7 +838,11 @@ fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         return tcx.has_typeck_tables(outer_def_id);\n     }\n \n-    if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n+    // FIXME(#71104) Should really be using just `as_local_hir_id` but\n+    // some `LocalDefId` do not seem to have a corresponding HirId.\n+    if let Some(id) =\n+        def_id.as_local().and_then(|def_id| tcx.hir().opt_local_def_id_to_hir_id(def_id))\n+    {\n         primary_body_of(tcx, id).is_some()\n     } else {\n         false"}]}