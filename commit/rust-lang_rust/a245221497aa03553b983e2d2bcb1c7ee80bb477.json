{"sha": "a245221497aa03553b983e2d2bcb1c7ee80bb477", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNDUyMjE0OTdhYTAzNTUzYjk4M2UyZDJiY2IxYzdlZTgwYmI0Nzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-28T16:17:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-28T16:17:28Z"}, "message": "Rollup merge of #69452 - Centril:typeck-pat, r=estebank\n\ntypeck: use `Pattern` obligation cause more for better diagnostics\n\nr? @estebank", "tree": {"sha": "98d6ce459a4067cc654297d6263946f5d7556062", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98d6ce459a4067cc654297d6263946f5d7556062"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a245221497aa03553b983e2d2bcb1c7ee80bb477", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeWT0YCRBK7hj4Ov3rIwAAdHIIAFc/X6MzrrgNQEjhJr/zv/UQ\nZkbBp6saMhH6WspxblfAIlnqyhOuPvYU9EevS7vsNKM1AvKFmSVDJl6WqKyVZQyX\nf8kgZ8dyTry4xWY5eKsglQeJp+0URk/2WLKG94Znq+oe5Dg1hP/q3F5lrJUVP4ef\ni/kU1NeEuxpA9K+rhPHTblK4ajInCxYZwEPgRlRMZTU8B2ntKs17p2IkCx5KzpKU\nUHODTCN4YxWu5p79fahFxjD/WzRObfXDeR2oN+nvJThb5xsvkSkvdlPJngOuUvJB\nLs9G8gGYEaebllt7ePxl+07DvTit+GObJ2I8ruamv46DanNS0B4vLnDAd69187U=\n=7npn\n-----END PGP SIGNATURE-----\n", "payload": "tree 98d6ce459a4067cc654297d6263946f5d7556062\nparent 3828fa2852bf5e622267b24c4eda74e4fa6cb5f9\nparent d234e131b8651ccf4bf8df05c9182e1085fa48fa\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1582906648 +0100\ncommitter GitHub <noreply@github.com> 1582906648 +0100\n\nRollup merge of #69452 - Centril:typeck-pat, r=estebank\n\ntypeck: use `Pattern` obligation cause more for better diagnostics\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a245221497aa03553b983e2d2bcb1c7ee80bb477", "html_url": "https://github.com/rust-lang/rust/commit/a245221497aa03553b983e2d2bcb1c7ee80bb477", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a245221497aa03553b983e2d2bcb1c7ee80bb477/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9", "html_url": "https://github.com/rust-lang/rust/commit/3828fa2852bf5e622267b24c4eda74e4fa6cb5f9"}, {"sha": "d234e131b8651ccf4bf8df05c9182e1085fa48fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d234e131b8651ccf4bf8df05c9182e1085fa48fa", "html_url": "https://github.com/rust-lang/rust/commit/d234e131b8651ccf4bf8df05c9182e1085fa48fa"}], "stats": {"total": 386, "additions": 284, "deletions": 102}, "files": [{"sha": "f7301280acd69ba5ead7052e5f9da2d3c9f5f2bc", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -153,17 +153,13 @@ pub struct Map<'hir> {\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n-struct ParentHirIterator<'map, 'hir> {\n+/// An iterator that walks up the ancestor tree of a given `HirId`.\n+/// Constructed using `tcx.hir().parent_iter(hir_id)`.\n+pub struct ParentHirIterator<'map, 'hir> {\n     current_id: HirId,\n     map: &'map Map<'hir>,\n }\n \n-impl<'map, 'hir> ParentHirIterator<'map, 'hir> {\n-    fn new(current_id: HirId, map: &'map Map<'hir>) -> Self {\n-        Self { current_id, map }\n-    }\n-}\n-\n impl<'hir> Iterator for ParentHirIterator<'_, 'hir> {\n     type Item = (HirId, Node<'hir>);\n \n@@ -618,6 +614,12 @@ impl<'hir> Map<'hir> {\n         self.find_entry(hir_id).and_then(|x| x.parent_node()).unwrap_or(hir_id)\n     }\n \n+    /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n+    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    pub fn parent_iter(&self, current_id: HirId) -> ParentHirIterator<'_, 'hir> {\n+        ParentHirIterator { current_id, map: self }\n+    }\n+\n     /// Checks if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: HirId) -> bool {\n@@ -684,7 +686,7 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n-        let mut iter = ParentHirIterator::new(id, &self).peekable();\n+        let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n         if let Some(entry) = self.find_entry(id) {\n             if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = entry.node {\n@@ -731,7 +733,7 @@ impl<'hir> Map<'hir> {\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (hir_id, node) in self.parent_iter(hir_id) {\n             match node {\n                 Node::Crate\n                 | Node::Item(_)\n@@ -753,7 +755,7 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (hir_id, node) in self.parent_iter(hir_id) {\n             if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return hir_id;\n             }\n@@ -767,7 +769,7 @@ impl<'hir> Map<'hir> {\n     /// Used by error reporting when there's a type error in a match arm caused by the `match`\n     /// expression needing to be unit.\n     pub fn get_match_if_cause(&self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n-        for (_, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (_, node) in self.parent_iter(hir_id) {\n             match node {\n                 Node::Item(_) | Node::ForeignItem(_) | Node::TraitItem(_) | Node::ImplItem(_) => {\n                     break;\n@@ -788,7 +790,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n-        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+        for (hir_id, node) in self.parent_iter(hir_id) {\n             if match node {\n                 Node::Item(i) => match i.kind {\n                     ItemKind::Fn(..)"}, {"sha": "7ed6cbf93dab252113c302aecfbec35a9ba8a465", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -43,7 +43,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        let cause = &self.misc(sp);\n+        self.demand_suptype_with_origin(&self.misc(sp), expected, actual)\n+    }\n+\n+    pub fn demand_suptype_with_origin(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n         match self.at(cause, self.param_env).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);"}, {"sha": "1df7c64f2c6f0e233475d100aff5a003600b5ab5", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -9,9 +9,9 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::{HirId, Pat, PatKind};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::traits::Pattern;\n+use rustc_infer::traits::{ObligationCause, Pattern};\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::Span;\n+use rustc_span::source_map::{Span, Spanned};\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -66,16 +66,19 @@ struct TopInfo<'tcx> {\n }\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n+    fn pattern_cause(&self, ti: TopInfo<'tcx>, cause_span: Span) -> ObligationCause<'tcx> {\n+        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n+        self.cause(cause_span, code)\n+    }\n+\n     fn demand_eqtype_pat_diag(\n         &self,\n         cause_span: Span,\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n-        let cause = self.cause(cause_span, code);\n-        self.demand_eqtype_with_origin(&cause, expected, actual)\n+        self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)\n     }\n \n     fn demand_eqtype_pat(\n@@ -152,7 +155,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n             PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_res.unwrap(), qpath, expected)\n+                self.check_pat_path(pat, path_res.unwrap(), qpath, expected, ti)\n             }\n             PatKind::Struct(ref qpath, fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n@@ -361,16 +364,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Byte string patterns behave the same way as array patterns\n         // They can denote both statically and dynamically-sized byte arrays.\n         let mut pat_ty = ty;\n-        if let hir::ExprKind::Lit(ref lt) = lt.kind {\n-            if let ast::LitKind::ByteStr(_) = lt.node {\n-                let expected_ty = self.structurally_resolved_type(span, expected);\n-                if let ty::Ref(_, r_ty, _) = expected_ty.kind {\n-                    if let ty::Slice(_) = r_ty.kind {\n-                        let tcx = self.tcx;\n-                        pat_ty =\n-                            tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n-                    }\n-                }\n+        if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(_), .. }) = lt.kind {\n+            let expected = self.structurally_resolved_type(span, expected);\n+            if let ty::Ref(_, ty::TyS { kind: ty::Slice(_), .. }, _) = expected.kind {\n+                let tcx = self.tcx;\n+                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n             }\n         }\n \n@@ -384,7 +382,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //     &'static str <: expected\n         //\n         // then that's equivalent to there existing a LUB.\n-        if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n+        let cause = self.pattern_cause(ti, span);\n+        if let Some(mut err) = self.demand_suptype_with_origin(&cause, expected, pat_ty) {\n             err.emit_unless(\n                 ti.span\n                     .filter(|&s| {\n@@ -543,8 +542,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // If there are multiple arms, make sure they all agree on\n         // what the type of the binding `x` ought to be.\n         if var_id != pat.hir_id {\n-            let vt = self.local_ty(pat.span, var_id).decl_ty;\n-            self.demand_eqtype_pat(pat.span, vt, local_ty, ti);\n+            self.check_binding_alt_eq_ty(pat.span, var_id, local_ty, ti);\n         }\n \n         if let Some(p) = sub {\n@@ -554,6 +552,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         local_ty\n     }\n \n+    fn check_binding_alt_eq_ty(&self, span: Span, var_id: HirId, ty: Ty<'tcx>, ti: TopInfo<'tcx>) {\n+        let var_ty = self.local_ty(span, var_id).decl_ty;\n+        if let Some(mut err) = self.demand_eqtype_pat_diag(span, var_ty, ty, ti) {\n+            let hir = self.tcx.hir();\n+            let var_ty = self.resolve_vars_with_obligations(var_ty);\n+            let msg = format!(\"first introduced with type `{}` here\", var_ty);\n+            err.span_label(hir.span(var_id), msg);\n+            let in_arm = hir.parent_iter(var_id).any(|(_, n)| matches!(n, hir::Node::Arm(..)));\n+            let pre = if in_arm { \"in the same arm, \" } else { \"\" };\n+            err.note(&format!(\"{}a binding must have the same type in all alternatives\", pre));\n+            err.emit();\n+        }\n+    }\n+\n     fn borrow_pat_suggestion(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -659,6 +671,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]),\n         qpath: &hir::QPath<'_>,\n         expected: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n@@ -684,7 +697,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type-check the path.\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n-        self.demand_suptype(pat.span, expected, pat_ty);\n+        if let Some(mut err) =\n+            self.demand_suptype_with_origin(&self.pattern_cause(ti, pat.span), expected, pat_ty)\n+        {\n+            err.emit();\n+        }\n         pat_ty\n     }\n \n@@ -901,7 +918,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n         let element_tys = tcx.mk_substs(element_tys_iter);\n         let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n-        if let Some(mut err) = self.demand_eqtype_diag(span, expected, pat_ty) {\n+        if let Some(mut err) = self.demand_eqtype_pat_diag(span, expected, pat_ty, ti) {\n             err.emit();\n             // Walk subpatterns with an expected type of `err` in this case to silence\n             // further errors being emitted when using the bindings. #50333\n@@ -1205,7 +1222,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     });\n                     let rptr_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n                     debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, rptr_ty);\n-                    let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n+                    let err = self.demand_eqtype_pat_diag(pat.span, expected, rptr_ty, ti);\n \n                     // Look for a case like `fn foo(&foo: u32)` and suggest\n                     // `fn foo(foo: &u32)`"}, {"sha": "1382cf643a17331cd7c18d2a7f8f619da16b3a2c", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -20,7 +20,7 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:32:10\n    |\n LL |     let &&x = &1isize as &dyn T;\n-   |          ^^\n+   |          ^^   ----------------- this expression has type `&dyn T`\n    |          |\n    |          expected trait object `dyn T`, found reference\n    |          help: you can probably remove the explicit borrow: `x`\n@@ -32,7 +32,7 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:36:11\n    |\n LL |     let &&&x = &(&1isize as &dyn T);\n-   |           ^^\n+   |           ^^   -------------------- this expression has type `&&dyn T`\n    |           |\n    |           expected trait object `dyn T`, found reference\n    |           help: you can probably remove the explicit borrow: `x`"}, {"sha": "e0537ff6faaf82e9463c18129d346d87aacdeaf4", "filename": "src/test/ui/elide-errors-on-mismatched-tuple.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Felide-errors-on-mismatched-tuple.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/elide-errors-on-mismatched-tuple.rs:14:9\n    |\n LL |     let (a, b, c) = (A::new(), A::new()); // This tuple is 2 elements, should be three\n-   |         ^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n+   |         ^^^^^^^^^   -------------------- this expression has type `(A, A)`\n+   |         |\n+   |         expected a tuple with 2 elements, found one with 3 elements\n    |\n    = note: expected tuple `(A, A)`\n               found tuple `(_, _, _)`"}, {"sha": "45fede4410630ebdbd5b89d9b6519eb413166064", "filename": "src/test/ui/issues/issue-12552.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -12,6 +12,9 @@ LL |     Some(k) => match k {\n error[E0308]: mismatched types\n   --> $DIR/issue-12552.rs:9:5\n    |\n+LL |   match t {\n+   |         - this expression has type `std::result::Result<_, {integer}>`\n+...\n LL |     None => ()\n    |     ^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n    |"}, {"sha": "f0285730c5a26cb43d0cb50e19788c2353e496da", "filename": "src/test/ui/issues/issue-37026.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-37026.rs:6:9\n    |\n LL |     let empty_struct::XEmpty2 = ();\n-   |         ^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `empty_struct::XEmpty2`\n+   |         ^^^^^^^^^^^^^^^^^^^^^   -- this expression has type `()`\n+   |         |\n+   |         expected `()`, found struct `empty_struct::XEmpty2`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-37026.rs:7:9"}, {"sha": "c81d6dcaf02173df0c0cfec556685c5da3b4cf7b", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:8:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),\n    |         ^^^^ expected tuple, found enum `A`\n    |\n@@ -10,6 +12,8 @@ LL |         A::B => (),\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:17:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         (true, false, false) => ()\n    |         ^^^^^^^^^^^^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n    |\n@@ -19,6 +23,8 @@ LL |         (true, false, false) => ()\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:25:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         (true, false, false) => ()\n    |         ^^^^^^^^^^^^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n    |\n@@ -39,6 +45,8 @@ LL |         box (true, false) => ()\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:40:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         &(true, false) => ()\n    |         ^^^^^^^^^^^^^^ expected tuple, found reference\n    |"}, {"sha": "4a29464aebd2b6ee7c7ffb0ff5c6b61a4fdcdbf2", "filename": "src/test/ui/issues/issue-7867.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-7867.rs:7:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),\n    |         ^^^^ expected tuple, found enum `A`\n    |"}, {"sha": "5078f03d6017a02adaf92d8eb27d2202f67ea45f", "filename": "src/test/ui/match/match-ill-type2.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmatch%2Fmatch-ill-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmatch%2Fmatch-ill-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-ill-type2.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/match-ill-type2.rs:4:9\n    |\n+LL |     match 1i32 {\n+   |           ---- this expression has type `i32`\n+LL |         1i32 => 1,\n LL |         2u32 => 1,\n    |         ^^^^ expected `i32`, found `u32`\n "}, {"sha": "3703a59edb83616d9e6382f854f4e02eaf0d4a91", "filename": "src/test/ui/match/match-tag-nullary.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/match-tag-nullary.rs:4:40\n    |\n LL | fn main() { let x: A = A::A; match x { B::B => { } } }\n-   |                                        ^^^^ expected enum `A`, found enum `B`\n+   |                                    -   ^^^^ expected enum `A`, found enum `B`\n+   |                                    |\n+   |                                    this expression has type `A`\n \n error: aborting due to previous error\n "}, {"sha": "f5c8b02ae27223c02a5ff9cae43db644e1e7b167", "filename": "src/test/ui/mismatched_types/E0409.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -12,7 +12,11 @@ error[E0308]: mismatched types\n LL |     match x {\n    |           - this expression has type `({integer}, {integer})`\n LL |         (0, ref y) | (y, 0) => {}\n-   |                       ^ expected `&{integer}`, found integer\n+   |             -----     ^ expected `&{integer}`, found integer\n+   |             |\n+   |             first introduced with type `&{integer}` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c2bce305877b4048f3ead8d07f7fcb217917cb4c", "filename": "src/test/ui/mismatched_types/issue-38371.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -3,7 +3,8 @@ error[E0308]: mismatched types\n    |\n LL | fn foo(&foo: Foo) {\n    |        ^^^^------\n-   |        |\n+   |        |     |\n+   |        |     expected due to this\n    |        expected struct `Foo`, found reference\n    |        help: did you mean `foo`: `&Foo`\n    |\n@@ -14,7 +15,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:18:9\n    |\n LL | fn agh(&&bar: &u32) {\n-   |         ^^^^\n+   |         ^^^^  ---- expected due to this\n    |         |\n    |         expected `u32`, found reference\n    |         help: you can probably remove the explicit borrow: `bar`\n@@ -26,7 +27,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:21:8\n    |\n LL | fn bgh(&&bar: u32) {\n-   |        ^^^^^ expected `u32`, found reference\n+   |        ^^^^^  --- expected due to this\n+   |        |\n+   |        expected `u32`, found reference\n    |\n    = note:   expected type `u32`\n            found reference `&_`"}, {"sha": "cad1cef5155d5f1ba54e81808a613ebbaa467129", "filename": "src/test/ui/mut/mut-pattern-mismatched.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmut%2Fmut-pattern-mismatched.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fmut%2Fmut-pattern-mismatched.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmut%2Fmut-pattern-mismatched.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -3,6 +3,9 @@ error[E0308]: mismatched types\n    |\n LL |      let &_\n    |          ^^ types differ in mutability\n+...\n+LL |         = foo;\n+   |           --- this expression has type `&mut {integer}`\n    |\n    = note: expected mutable reference `&mut {integer}`\n                       found reference `&_`\n@@ -12,6 +15,9 @@ error[E0308]: mismatched types\n    |\n LL |     let &mut _\n    |         ^^^^^^ types differ in mutability\n+...\n+LL |          = bar;\n+   |            --- this expression has type `&{integer}`\n    |\n    = note:      expected reference `&{integer}`\n            found mutable reference `&mut _`"}, {"sha": "97933ca12294400a83a5a697be987a29af544d8a", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -86,12 +86,14 @@ error[E0308]: mismatched types\n   --> $DIR/already-bound-name.rs:32:31\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |                               ^                    ------- this expression has type `E<E<{integer}>>`\n-   |                               |\n-   |                               expected integer, found enum `E`\n+   |             -                 ^                    ------- this expression has type `E<E<{integer}>>`\n+   |             |                 |\n+   |             |                 expected integer, found enum `E`\n+   |             first introduced with type `{integer}` here\n    |\n    = note: expected type `{integer}`\n               found type `E<{integer}>`\n+   = note: a binding must have the same type in all alternatives\n \n error: aborting due to 15 previous errors\n "}, {"sha": "8c01e00bae3530598cdd5e1a1b5fc3fdb13c1ad6", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -52,23 +52,27 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:11:25\n    |\n LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n-   |                         ^^^^^^^^^   -------------------- expected due to this\n-   |                         |\n-   |                         types differ in mutability\n+   |            -----        ^^^^^^^^^   -------------------- expected due to this\n+   |            |            |\n+   |            |            types differ in mutability\n+   |            first introduced with type `&&u8` here\n    |\n    = note: expected type `&&u8`\n               found type `&mut &mut u8`\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:14:31\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |                               ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`\n-   |                               |\n-   |                               types differ in mutability\n+   |             -----             ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`\n+   |             |                 |\n+   |             |                 types differ in mutability\n+   |             first introduced with type `&{integer}` here\n    |\n    = note: expected type `&{integer}`\n               found type `&mut _`\n+   = note: a binding must have the same type in all alternatives\n \n error: aborting due to 9 previous errors\n "}, {"sha": "d5e029d668d4796a6b2cb7f9b54a176bbaf25801", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.stderr", "status": "modified", "additions": 116, "deletions": 42, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -4,179 +4,253 @@ error[E0308]: mismatched types\n LL |     match Blah::A(1, 1, 2) {\n    |           ---------------- this expression has type `main::Blah`\n LL |         Blah::A(_, x, y) | Blah::B(x, y) => {}\n-   |                                       ^ expected `usize`, found `isize`\n+   |                       -               ^ expected `usize`, found `isize`\n+   |                       |\n+   |                       first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:17:44\n    |\n LL |     match Some(Blah::A(1, 1, 2)) {\n    |           ---------------------- this expression has type `std::option::Option<main::Blah>`\n LL |         Some(Blah::A(_, x, y) | Blah::B(x, y)) => {}\n-   |                                            ^ expected `usize`, found `isize`\n+   |                            -               ^ expected `usize`, found `isize`\n+   |                            |\n+   |                            first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:21:19\n    |\n LL |     match (0u8, 1u16) {\n    |           ----------- this expression has type `(u8, u16)`\n LL |         (x, y) | (y, x) => {}\n-   |                   ^ expected `u16`, found `u8`\n+   |             -     ^ expected `u16`, found `u8`\n+   |             |\n+   |             first introduced with type `u16` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:21:22\n    |\n LL |     match (0u8, 1u16) {\n    |           ----------- this expression has type `(u8, u16)`\n LL |         (x, y) | (y, x) => {}\n-   |                      ^ expected `u8`, found `u16`\n+   |          -           ^ expected `u8`, found `u16`\n+   |          |\n+   |          first introduced with type `u8` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:41\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                         ^ expected `u16`, found `u8`\n+   |                        -                ^ expected `u16`, found `u8`\n+   |                        |\n+   |                        first introduced with type `u16` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:50\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                                  ^ expected `u8`, found `u16`\n+   |               -                                  ^ expected `u8`, found `u16`\n+   |               |\n+   |               first introduced with type `u8` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:59\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                                           ^ expected `u32`, found `u16`\n+   |                           -                               ^ expected `u32`, found `u16`\n+   |                           |\n+   |                           first introduced with type `u32` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:26:62\n    |\n LL |     match Some((0u8, Some((1u16, 2u32)))) {\n    |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n-   |                                                              ^ expected `u8`, found `u32`\n+   |               - first introduced with type `u8` here         ^ expected `u8`, found `u32`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:34:42\n    |\n LL |     if let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2) {\n-   |                                          ^    ---------------- this expression has type `main::Blah`\n-   |                                          |\n-   |                                          expected `usize`, found `isize`\n+   |                          -               ^    ---------------- this expression has type `main::Blah`\n+   |                          |               |\n+   |                          |               expected `usize`, found `isize`\n+   |                          first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:38:47\n    |\n LL |     if let Some(Blah::A(_, x, y) | Blah::B(x, y)) = Some(Blah::A(1, 1, 2)) {\n-   |                                               ^     ---------------------- this expression has type `std::option::Option<main::Blah>`\n-   |                                               |\n-   |                                               expected `usize`, found `isize`\n+   |                               -               ^     ---------------------- this expression has type `std::option::Option<main::Blah>`\n+   |                               |               |\n+   |                               |               expected `usize`, found `isize`\n+   |                               first introduced with type `usize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:42:22\n    |\n LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n-   |                      ^       ----------- this expression has type `(u8, u16)`\n-   |                      |\n-   |                      expected `u16`, found `u8`\n+   |                -     ^       ----------- this expression has type `(u8, u16)`\n+   |                |     |\n+   |                |     expected `u16`, found `u8`\n+   |                first introduced with type `u16` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:42:25\n    |\n LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n-   |                         ^    ----------- this expression has type `(u8, u16)`\n-   |                         |\n-   |                         expected `u8`, found `u16`\n+   |             -           ^    ----------- this expression has type `(u8, u16)`\n+   |             |           |\n+   |             |           expected `u8`, found `u16`\n+   |             first introduced with type `u8` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:44\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                            ^ expected `u16`, found `u8`\n+   |                           -                ^ expected `u16`, found `u8`\n+   |                           |\n+   |                           first introduced with type `u16` here\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:53\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                                     ^ expected `u8`, found `u16`\n+   |                  -                                  ^ expected `u8`, found `u16`\n+   |                  |\n+   |                  first introduced with type `u8` here\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:62\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                                              ^ expected `u32`, found `u16`\n+   |                              -                               ^ expected `u32`, found `u16`\n+   |                              |\n+   |                              first introduced with type `u32` here\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:47:65\n    |\n LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n-   |                                                                 ^ expected `u8`, found `u32`\n+   |                  - first introduced with type `u8` here         ^ expected `u8`, found `u32`\n ...\n LL |     = Some((0u8, Some((1u16, 2u32))))\n    |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:55:39\n    |\n LL |     let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n-   |                                       ^    ---------------- this expression has type `main::Blah`\n-   |                                       |\n-   |                                       expected `usize`, found `isize`\n+   |                       -               ^    ---------------- this expression has type `main::Blah`\n+   |                       |               |\n+   |                       |               expected `usize`, found `isize`\n+   |                       first introduced with type `usize` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:58:19\n    |\n LL |     let (x, y) | (y, x) = (0u8, 1u16);\n-   |                   ^       ----------- this expression has type `(u8, u16)`\n-   |                   |\n-   |                   expected `u16`, found `u8`\n+   |             -     ^       ----------- this expression has type `(u8, u16)`\n+   |             |     |\n+   |             |     expected `u16`, found `u8`\n+   |             first introduced with type `u16` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:58:22\n    |\n LL |     let (x, y) | (y, x) = (0u8, 1u16);\n-   |                      ^    ----------- this expression has type `(u8, u16)`\n-   |                      |\n-   |                      expected `u8`, found `u16`\n+   |          -           ^    ----------- this expression has type `(u8, u16)`\n+   |          |           |\n+   |          |           expected `u8`, found `u16`\n+   |          first introduced with type `u8` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:62:42\n    |\n LL |     fn f1((Blah::A(_, x, y) | Blah::B(x, y)): Blah) {}\n-   |                                          ^    ---- expected due to this\n-   |                                          |\n-   |                                          expected `usize`, found `isize`\n+   |                          -               ^    ---- expected due to this\n+   |                          |               |\n+   |                          |               expected `usize`, found `isize`\n+   |                          first introduced with type `usize` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:65:22\n    |\n LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n-   |                      ^       --------- expected due to this\n-   |                      |\n-   |                      expected `u16`, found `u8`\n+   |                -     ^       --------- expected due to this\n+   |                |     |\n+   |                |     expected `u16`, found `u8`\n+   |                first introduced with type `u16` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/or-patterns-binding-type-mismatch.rs:65:25\n    |\n LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n-   |                         ^    --------- expected due to this\n-   |                         |\n-   |                         expected `u8`, found `u16`\n+   |             -           ^    --------- expected due to this\n+   |             |           |\n+   |             |           expected `u8`, found `u16`\n+   |             first introduced with type `u8` here\n+   |\n+   = note: a binding must have the same type in all alternatives\n \n error: aborting due to 22 previous errors\n "}, {"sha": "598b6a3794ef72a18d9144547447fbee7fcfe634", "filename": "src/test/ui/pattern/pat-tuple-bad-type.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-bad-type.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -12,6 +12,8 @@ LL |         (..) => {}\n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-bad-type.rs:10:9\n    |\n+LL |     match 0u8 {\n+   |           --- this expression has type `u8`\n LL |         (..) => {}\n    |         ^^^^ expected `u8`, found `()`\n "}, {"sha": "45b6fd1b4d445e97c662ab9ac0a01ed49072bd25", "filename": "src/test/ui/pattern/pat-tuple-overfield.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-overfield.rs:5:9\n    |\n+LL |     match (1, 2, 3) {\n+   |           --------- this expression has type `({integer}, {integer}, {integer})`\n LL |         (1, 2, 3, 4) => {}\n    |         ^^^^^^^^^^^^ expected a tuple with 3 elements, found one with 4 elements\n    |\n@@ -10,6 +12,9 @@ LL |         (1, 2, 3, 4) => {}\n error[E0308]: mismatched types\n   --> $DIR/pat-tuple-overfield.rs:6:9\n    |\n+LL |     match (1, 2, 3) {\n+   |           --------- this expression has type `({integer}, {integer}, {integer})`\n+LL |         (1, 2, 3, 4) => {}\n LL |         (1, 2, .., 3, 4) => {}\n    |         ^^^^^^^^^^^^^^^^ expected a tuple with 3 elements, found one with 4 elements\n    |"}, {"sha": "24b5cdf98d5e202b26cdcf32f58999f660e81589", "filename": "src/test/ui/pattern/pattern-ident-path-generics.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fpattern%2Fpattern-ident-path-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fpattern%2Fpattern-ident-path-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-ident-path-generics.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/pattern-ident-path-generics.rs:3:9\n    |\n+LL |     match Some(\"foo\") {\n+   |           ----------- this expression has type `std::option::Option<&str>`\n LL |         None::<isize> => {}\n    |         ^^^^^^^^^^^^^ expected `&str`, found `isize`\n    |"}, {"sha": "2de0b6a496958a2af0ffc39f0ddc391f4001a079", "filename": "src/test/ui/resolve/name-clash-nullary.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fresolve%2Fname-clash-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fresolve%2Fname-clash-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fname-clash-nullary.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/name-clash-nullary.rs:2:7\n    |\n LL |   let None: isize = 42;\n-   |       ^^^^ expected `isize`, found enum `std::option::Option`\n+   |       ^^^^  ----- expected due to this\n+   |       |\n+   |       expected `isize`, found enum `std::option::Option`\n    |\n    = note: expected type `isize`\n               found enum `std::option::Option<_>`"}, {"sha": "749ed131b204eacf85fee158e7fcd1e91041c45e", "filename": "src/test/ui/resolve/resolve-inconsistent-binding-mode.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -26,26 +26,37 @@ error[E0308]: mismatched types\n LL |     match x {\n    |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n-   |                                ^ expected `&isize`, found `isize`\n+   |               -----            ^ expected `&isize`, found `isize`\n+   |               |\n+   |               first introduced with type `&isize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:16:32\n    |\n LL |     match x {\n    |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n-   |                                ^ expected `&isize`, found `isize`\n+   |               -----            ^ expected `&isize`, found `isize`\n+   |               |\n+   |               first introduced with type `&isize` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:25:36\n    |\n LL |     match x {\n    |           - this expression has type `Opts`\n LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n-   |                                    ^^^^^ types differ in mutability\n+   |               ---------            ^^^^^ types differ in mutability\n+   |               |\n+   |               first introduced with type `&mut isize` here\n    |\n    = note: expected type `&mut isize`\n               found type `&isize`\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error: aborting due to 6 previous errors\n "}, {"sha": "1d3079c90baf657693c3d4b68f4fc32f69378dc5", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -89,7 +89,11 @@ error[E0308]: mismatched types\n LL |     match x {\n    |           - this expression has type `(E, E)`\n LL |         (A, B) | (ref B, c) | (c, A) => ()\n-   |                   ^^^^^ expected enum `E`, found `&E`\n+   |             -     ^^^^^ expected enum `E`, found `&E`\n+   |             |\n+   |             first introduced with type `E` here\n+   |\n+   = note: in the same arm, a binding must have the same type in all alternatives\n \n error: aborting due to 9 previous errors\n "}, {"sha": "27efd450b9471157126a4d22f72003c0dd92ea19", "filename": "src/test/ui/rfc-2005-default-binding-mode/const.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/const.rs:14:9\n    |\n+LL |     match &f {\n+   |           -- this expression has type `&Foo`\n LL |         FOO => {},\n    |         ^^^ expected `&Foo`, found struct `Foo`\n "}, {"sha": "6d18a39606ccf04362eff220d28c3fabb1ffddc8", "filename": "src/test/ui/rfc-2005-default-binding-mode/lit.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Flit.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/lit.rs:7:13\n    |\n+LL |     match &s {\n+   |           -- this expression has type `&&str`\n LL |             \"abc\" => true,\n    |             ^^^^^ expected `&str`, found `str`\n    |\n@@ -10,6 +12,8 @@ LL |             \"abc\" => true,\n error[E0308]: mismatched types\n   --> $DIR/lit.rs:16:9\n    |\n+LL |     match &s {\n+   |           -- this expression has type `&&[u8]`\n LL |         b\"abc\" => true,\n    |         ^^^^^^ expected `&[u8]`, found array `[u8; 3]`\n    |"}, {"sha": "14f01f0ebdf7386055fcdec842f0ddce5d53b26c", "filename": "src/test/ui/slightly-nice-generic-literal-messages.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fslightly-nice-generic-literal-messages.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fslightly-nice-generic-literal-messages.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fslightly-nice-generic-literal-messages.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/slightly-nice-generic-literal-messages.rs:7:9\n    |\n+LL |     match Foo(1.1, marker::PhantomData) {\n+   |           ----------------------------- this expression has type `Foo<{float}, _>`\n LL |         1 => {}\n    |         ^ expected struct `Foo`, found integer\n    |"}, {"sha": "559a2d29551d32295bc3e55c642ca7c1fb17cfb2", "filename": "src/test/ui/suggestions/match-ergonomics.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/match-ergonomics.rs:4:10\n    |\n+LL |     match &x[..] {\n+   |           ------ this expression has type `&[i32]`\n LL |         [&v] => {},\n    |          ^^\n    |          |\n@@ -25,6 +27,8 @@ LL |         [v] => {},\n error[E0308]: mismatched types\n   --> $DIR/match-ergonomics.rs:29:9\n    |\n+LL |     match y {\n+   |           - this expression has type `i32`\n LL |         &v => {},\n    |         ^^\n    |         |\n@@ -38,7 +42,7 @@ error[E0308]: mismatched types\n   --> $DIR/match-ergonomics.rs:40:13\n    |\n LL |     if let [&v] = &x[..] {}\n-   |             ^^\n+   |             ^^    ------ this expression has type `&[i32]`\n    |             |\n    |             expected `i32`, found reference\n    |             help: you can probably remove the explicit borrow: `v`"}, {"sha": "c2874ae9a14b857508c5a494d8e4b605a803127c", "filename": "src/test/ui/suppressed-error.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fsuppressed-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a245221497aa03553b983e2d2bcb1c7ee80bb477/src%2Ftest%2Fui%2Fsuppressed-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuppressed-error.stderr?ref=a245221497aa03553b983e2d2bcb1c7ee80bb477", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/suppressed-error.rs:2:9\n    |\n LL |     let (x, y) = ();\n-   |         ^^^^^^ expected `()`, found tuple\n+   |         ^^^^^^   -- this expression has type `()`\n+   |         |\n+   |         expected `()`, found tuple\n    |\n    = note: expected unit type `()`\n                   found tuple `(_, _)`"}]}