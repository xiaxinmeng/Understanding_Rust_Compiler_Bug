{"sha": "32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "node_id": "C_kwDOAAsO6NoAKDMyNDcxYTcwMzViNGQ4YmEyYjFmYjNjYWFlNWY4MjAzZjQ3ZTQzOTE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-12T05:41:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-12T05:41:23Z"}, "message": "Rollup merge of #102110 - CleanCut:migrate_rustc_passes_diagnostics, r=davidtwco\n\nMigrate rustc_passes diagnostics\n\nPicks up abandoned work from https://github.com/rust-lang/rust/pull/100870\n\nI would like to do this collaboratively, as there is a lot of work! Here's the process:\n\n- Comment below that you are willing to help and I will add you as a collaborator to my `rust` fork (that gives you write access)\n- Indicate which file/task you would like to work on (so we don't duplicate work) from the list below\n- Do the work, push up a commit, comment that you're done with that file/task\n- Repeat until done \ud83d\ude04\n\n### Files to Migrate (in `compiler/rustc_passes/src/`)\n\n- [x] check_attr.rs ``@CleanCut``\n- [x] check_const.rs ``@CleanCut``\n- [x] dead.rs ``@CleanCut``\n- [x] debugger_visualizer.rs ``@CleanCut``\n- [x] diagnostic_items.rs ``@CleanCut``\n- [x] entry.rs ``@CleanCut``\n- [x] lang_items.rs ``@CleanCut``\n- [x] layout_test.rs ``@CleanCut``\n- [x] lib_features.rs ``@CleanCut``\n- [x] ~liveness.rs~ ``@CleanCut`` Nothing to do\n- [x] loops.rs ``@CleanCut``\n- [x] naked_functions.rs ``@CleanCut``\n- [x] stability.rs ``@CleanCut``\n- [x] weak_lang_items.rs ``@CleanCut``\n\n### Tasks\n\n- [x] Rebase on current `master` ``@CleanCut``\n- [x] Review work from [the earlier PR](https://github.com/rust-lang/rust/pull/100870) and make sure it all looks good\n  - [x] compiler/rustc_error_messages/locales/en-US/passes.ftl ``@CleanCut``\n  - [x] compiler/rustc_passes/src/check_attr.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/errors.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/lang_items.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/lib.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/weak_lang_items.rs ``@CleanCut``", "tree": {"sha": "72f567c68354ad26b69dac5155bf0c50949f6e09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72f567c68354ad26b69dac5155bf0c50949f6e09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjRlODCRBK7hj4Ov3rIwAA3PwIAHpGegkdrX979hTPdZVcWMi8\ngqmdFHk2yIj86BaZ2blb8re1xa3wJUcg/o764wFhsp2y8dHAog2ceP0IcgUlgTa0\nu8yZ+deBcGztX6MqE4vtMmnj0O9MnuRnmlBlTMQjXc2eZjz7oJGaDZtxJuU6LCgI\nRxxGl5/UWrato71dl/x9o5Iag7Koe+4aYPpQ/GOiT5JIq2fhHk3qzq+qhaHg8aGJ\nC4nYX2nC3BeOapVImCokpK5tTYd0tOsPMVa++CLC5gGfx/YGtfBJ5CP2lQ+vOV+2\nqXnNge7BS/s5OsCLomUswv8Se0zNhypJ8+ZaPt3ZA4WakfFOGLtszGt8RxJ+i8E=\n=7X7L\n-----END PGP SIGNATURE-----\n", "payload": "tree 72f567c68354ad26b69dac5155bf0c50949f6e09\nparent 7e8d64e792543fedb8574ac0a27522dbab66aa52\nparent 5ef1c03bd80e40b3280f15b8285b73d5fc616776\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665553283 +0530\ncommitter GitHub <noreply@github.com> 1665553283 +0530\n\nRollup merge of #102110 - CleanCut:migrate_rustc_passes_diagnostics, r=davidtwco\n\nMigrate rustc_passes diagnostics\n\nPicks up abandoned work from https://github.com/rust-lang/rust/pull/100870\n\nI would like to do this collaboratively, as there is a lot of work! Here's the process:\n\n- Comment below that you are willing to help and I will add you as a collaborator to my `rust` fork (that gives you write access)\n- Indicate which file/task you would like to work on (so we don't duplicate work) from the list below\n- Do the work, push up a commit, comment that you're done with that file/task\n- Repeat until done \ud83d\ude04\n\n### Files to Migrate (in `compiler/rustc_passes/src/`)\n\n- [x] check_attr.rs ``@CleanCut``\n- [x] check_const.rs ``@CleanCut``\n- [x] dead.rs ``@CleanCut``\n- [x] debugger_visualizer.rs ``@CleanCut``\n- [x] diagnostic_items.rs ``@CleanCut``\n- [x] entry.rs ``@CleanCut``\n- [x] lang_items.rs ``@CleanCut``\n- [x] layout_test.rs ``@CleanCut``\n- [x] lib_features.rs ``@CleanCut``\n- [x] ~liveness.rs~ ``@CleanCut`` Nothing to do\n- [x] loops.rs ``@CleanCut``\n- [x] naked_functions.rs ``@CleanCut``\n- [x] stability.rs ``@CleanCut``\n- [x] weak_lang_items.rs ``@CleanCut``\n\n### Tasks\n\n- [x] Rebase on current `master` ``@CleanCut``\n- [x] Review work from [the earlier PR](https://github.com/rust-lang/rust/pull/100870) and make sure it all looks good\n  - [x] compiler/rustc_error_messages/locales/en-US/passes.ftl ``@CleanCut``\n  - [x] compiler/rustc_passes/src/check_attr.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/errors.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/lang_items.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/lib.rs ``@CleanCut``\n  - [x] compiler/rustc_passes/src/weak_lang_items.rs ``@CleanCut``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "html_url": "https://github.com/rust-lang/rust/commit/32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e8d64e792543fedb8574ac0a27522dbab66aa52", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e8d64e792543fedb8574ac0a27522dbab66aa52", "html_url": "https://github.com/rust-lang/rust/commit/7e8d64e792543fedb8574ac0a27522dbab66aa52"}, {"sha": "5ef1c03bd80e40b3280f15b8285b73d5fc616776", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ef1c03bd80e40b3280f15b8285b73d5fc616776", "html_url": "https://github.com/rust-lang/rust/commit/5ef1c03bd80e40b3280f15b8285b73d5fc616776"}], "stats": {"total": 2549, "additions": 1793, "deletions": 756}, "files": [{"sha": "b9e4499d47f362ab5010ced819a5c6f67f8d16d3", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -18,3 +18,12 @@ middle_limit_invalid =\n \n middle_const_eval_non_int =\n     constant evaluation of enum discriminant resulted in non-integer\n+\n+middle_unknown_layout =\n+    the type `{$ty}` has an unknown layout\n+\n+middle_values_too_big =\n+    values of the type `{$ty}` are too big for the current architecture\n+\n+middle_cannot_be_normalized =\n+    unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized"}, {"sha": "1f1c9c29d665a6184c3543fb772577435e4ba542", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 478, "deletions": 81, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -10,119 +10,159 @@ passes_outer_crate_level_attr =\n passes_inner_crate_level_attr =\n     crate-level attribute should be in the root module\n \n-passes_ignored_attr_with_macro = `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n+passes_ignored_attr_with_macro =\n+    `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_ignored_attr = `#[{$sym}]` is ignored on struct fields and match arms\n+passes_ignored_attr =\n+    `#[{$sym}]` is ignored on struct fields and match arms\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_inline_ignored_function_prototype = `#[inline]` is ignored on function prototypes\n+passes_inline_ignored_function_prototype =\n+    `#[inline]` is ignored on function prototypes\n \n-passes_inline_ignored_constants = `#[inline]` is ignored on constants\n+passes_inline_ignored_constants =\n+    `#[inline]` is ignored on constants\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"65833\")}\n \n-passes_inline_not_fn_or_closure = attribute should be applied to function or closure\n+passes_inline_not_fn_or_closure =\n+    attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_no_coverage_ignored_function_prototype = `#[no_coverage]` is ignored on function prototypes\n+passes_no_coverage_ignored_function_prototype =\n+    `#[no_coverage]` is ignored on function prototypes\n \n passes_no_coverage_propagate =\n     `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n \n-passes_no_coverage_fn_defn = `#[no_coverage]` may only be applied to function definitions\n+passes_no_coverage_fn_defn =\n+    `#[no_coverage]` may only be applied to function definitions\n \n-passes_no_coverage_not_coverable = `#[no_coverage]` must be applied to coverable code\n+passes_no_coverage_not_coverable =\n+    `#[no_coverage]` must be applied to coverable code\n     .label = not coverable code\n \n-passes_should_be_applied_to_fn = attribute should be applied to a function definition\n+passes_should_be_applied_to_fn =\n+    attribute should be applied to a function definition\n     .label = not a function definition\n \n-passes_naked_tracked_caller = cannot use `#[track_caller]` with `#[naked]`\n+passes_naked_tracked_caller =\n+    cannot use `#[track_caller]` with `#[naked]`\n \n-passes_should_be_applied_to_struct_enum = attribute should be applied to a struct or enum\n+passes_should_be_applied_to_struct_enum =\n+    attribute should be applied to a struct or enum\n     .label = not a struct or enum\n \n-passes_should_be_applied_to_trait = attribute should be applied to a trait\n+passes_should_be_applied_to_trait =\n+    attribute should be applied to a trait\n     .label = not a trait\n \n-passes_target_feature_on_statement = {passes_should_be_applied_to_fn}\n+passes_target_feature_on_statement =\n+    {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_should_be_applied_to_static = attribute should be applied to a static\n+passes_should_be_applied_to_static =\n+    attribute should be applied to a static\n     .label = not a static\n \n-passes_doc_expect_str = doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+passes_doc_expect_str =\n+    doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n \n-passes_doc_alias_empty = {$attr_str} attribute cannot have empty value\n+passes_doc_alias_empty =\n+    {$attr_str} attribute cannot have empty value\n \n-passes_doc_alias_bad_char = {$char_} character isn't allowed in {$attr_str}\n+passes_doc_alias_bad_char =\n+    {$char_} character isn't allowed in {$attr_str}\n \n-passes_doc_alias_start_end = {$attr_str} cannot start or end with ' '\n+passes_doc_alias_start_end =\n+    {$attr_str} cannot start or end with ' '\n \n-passes_doc_alias_bad_location = {$attr_str} isn't allowed on {$location}\n+passes_doc_alias_bad_location =\n+    {$attr_str} isn't allowed on {$location}\n \n-passes_doc_alias_not_an_alias = {$attr_str} is the same as the item's name\n+passes_doc_alias_not_an_alias =\n+    {$attr_str} is the same as the item's name\n \n passes_doc_alias_duplicated = doc alias is duplicated\n     .label = first defined here\n \n-passes_doc_alias_not_string_literal = `#[doc(alias(\"a\"))]` expects string literals\n+passes_doc_alias_not_string_literal =\n+    `#[doc(alias(\"a\"))]` expects string literals\n \n passes_doc_alias_malformed =\n     doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n \n-passes_doc_keyword_empty_mod = `#[doc(keyword = \"...\")]` should be used on empty modules\n+passes_doc_keyword_empty_mod =\n+    `#[doc(keyword = \"...\")]` should be used on empty modules\n \n-passes_doc_keyword_not_mod = `#[doc(keyword = \"...\")]` should be used on modules\n+passes_doc_keyword_not_mod =\n+    `#[doc(keyword = \"...\")]` should be used on modules\n \n-passes_doc_keyword_invalid_ident = `{$doc_keyword}` is not a valid identifier\n+passes_doc_keyword_invalid_ident =\n+    `{$doc_keyword}` is not a valid identifier\n \n passes_doc_fake_variadic_not_valid =\n     `#[doc(fake_variadic)]` must be used on the first of a set of tuple or fn pointer trait impls with varying arity\n \n-passes_doc_keyword_only_impl = `#[doc(keyword = \"...\")]` should be used on impl blocks\n+passes_doc_keyword_only_impl =\n+    `#[doc(keyword = \"...\")]` should be used on impl blocks\n \n-passes_doc_inline_conflict_first = this attribute...\n-passes_doc_inline_conflict_second = ...conflicts with this attribute\n-passes_doc_inline_conflict = conflicting doc inlining attributes\n+passes_doc_inline_conflict_first =\n+    this attribute...\n+\n+passes_doc_inline_conflict_second =\n+    {\".\"}..conflicts with this attribute\n+\n+passes_doc_inline_conflict =\n+    conflicting doc inlining attributes\n     .help = remove one of the conflicting attributes\n \n-passes_doc_inline_only_use = this attribute can only be applied to a `use` item\n+passes_doc_inline_only_use =\n+    this attribute can only be applied to a `use` item\n     .label = only applicable on `use` items\n     .not_a_use_item_label = not a `use` item\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n passes_doc_attr_not_crate_level =\n     `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n \n-passes_attr_crate_level = this attribute can only be applied at the crate level\n+passes_attr_crate_level =\n+    this attribute can only be applied at the crate level\n     .suggestion = to apply to the crate, use an inner attribute\n     .help = to apply to the crate, use an inner attribute\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n-passes_doc_test_unknown = unknown `doc(test)` attribute `{$path}`\n+passes_doc_test_unknown =\n+    unknown `doc(test)` attribute `{$path}`\n \n-passes_doc_test_takes_list = `#[doc(test(...)]` takes a list of attributes\n+passes_doc_test_takes_list =\n+    `#[doc(test(...)]` takes a list of attributes\n \n-passes_doc_primitive = `doc(primitive)` should never have been stable\n+passes_doc_primitive =\n+    `doc(primitive)` should never have been stable\n \n-passes_doc_test_unknown_any = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_any =\n+    unknown `doc` attribute `{$path}`\n \n-passes_doc_test_unknown_spotlight = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_spotlight =\n+    unknown `doc` attribute `{$path}`\n     .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n     .suggestion = use `notable_trait` instead\n     .no_op_note = `doc(spotlight)` is now a no-op\n \n-passes_doc_test_unknown_include = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_include =\n+    unknown `doc` attribute `{$path}`\n     .suggestion = use `doc = include_str!` instead\n \n-passes_doc_invalid = invalid `doc` attribute\n+passes_doc_invalid =\n+    invalid `doc` attribute\n \n-passes_pass_by_value = `pass_by_value` attribute should be applied to a struct, enum or type alias\n+passes_pass_by_value =\n+    `pass_by_value` attribute should be applied to a struct, enum or type alias\n     .label = is not a struct, enum or type alias\n \n passes_allow_incoherent_impl =\n@@ -137,42 +177,54 @@ passes_must_use_async =\n     `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n     .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n \n-passes_must_use_no_effect = `#[must_use]` has no effect when applied to {$article} {$target}\n+passes_must_use_no_effect =\n+    `#[must_use]` has no effect when applied to {$article} {$target}\n \n-passes_must_not_suspend = `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+passes_must_not_suspend =\n+    `must_not_suspend` attribute should be applied to a struct, enum, or trait\n     .label = is not a struct, enum, or trait\n \n-passes_cold = {passes_should_be_applied_to_fn}\n+passes_cold =\n+    {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_link = attribute should be applied to an `extern` block with non-Rust ABI\n+passes_link =\n+    attribute should be applied to an `extern` block with non-Rust ABI\n     .warn = {-passes_previously_accepted}\n     .label = not an `extern` block\n \n-passes_link_name = attribute should be applied to a foreign function or static\n+passes_link_name =\n+    attribute should be applied to a foreign function or static\n     .warn = {-passes_previously_accepted}\n     .label = not a foreign function or static\n     .help = try `#[link(name = \"{$value}\")]` instead\n \n-passes_no_link = attribute should be applied to an `extern crate` item\n+passes_no_link =\n+    attribute should be applied to an `extern crate` item\n     .label = not an `extern crate` item\n \n-passes_export_name = attribute should be applied to a free function, impl method or static\n+passes_export_name =\n+    attribute should be applied to a free function, impl method or static\n     .label = not a free function, impl method or static\n \n-passes_rustc_layout_scalar_valid_range_not_struct = attribute should be applied to a struct\n+passes_rustc_layout_scalar_valid_range_not_struct =\n+    attribute should be applied to a struct\n     .label = not a struct\n \n-passes_rustc_layout_scalar_valid_range_arg = expected exactly one integer literal argument\n+passes_rustc_layout_scalar_valid_range_arg =\n+    expected exactly one integer literal argument\n \n-passes_rustc_legacy_const_generics_only = #[rustc_legacy_const_generics] functions must only have const generics\n+passes_rustc_legacy_const_generics_only =\n+    #[rustc_legacy_const_generics] functions must only have const generics\n     .label = non-const generic parameter\n \n-passes_rustc_legacy_const_generics_index = #[rustc_legacy_const_generics] must have one index for each generic parameter\n+passes_rustc_legacy_const_generics_index =\n+    #[rustc_legacy_const_generics] must have one index for each generic parameter\n     .label = generic parameters\n \n-passes_rustc_legacy_const_generics_index_exceed = index exceeds number of arguments\n+passes_rustc_legacy_const_generics_index_exceed =\n+    index exceeds number of arguments\n     .label = there {$arg_count ->\n         [one] is\n         *[other] are\n@@ -181,93 +233,438 @@ passes_rustc_legacy_const_generics_index_exceed = index exceeds number of argume\n         *[other] arguments\n     }\n \n-passes_rustc_legacy_const_generics_index_negative = arguments should be non-negative integers\n+passes_rustc_legacy_const_generics_index_negative =\n+    arguments should be non-negative integers\n \n-passes_rustc_dirty_clean = attribute requires -Z query-dep-graph to be enabled\n+passes_rustc_dirty_clean =\n+    attribute requires -Z query-dep-graph to be enabled\n \n-passes_link_section = attribute should be applied to a function or static\n+passes_link_section =\n+    attribute should be applied to a function or static\n     .warn = {-passes_previously_accepted}\n     .label = not a function or static\n \n-passes_no_mangle_foreign = `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+passes_no_mangle_foreign =\n+    `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n     .warn = {-passes_previously_accepted}\n     .label = foreign {$foreign_item_kind}\n     .note = symbol names in extern blocks are not mangled\n     .suggestion = remove this attribute\n \n-passes_no_mangle = attribute should be applied to a free function, impl method or static\n+passes_no_mangle =\n+    attribute should be applied to a free function, impl method or static\n     .warn = {-passes_previously_accepted}\n     .label = not a free function, impl method or static\n \n-passes_repr_ident = meta item in `repr` must be an identifier\n+passes_repr_ident =\n+    meta item in `repr` must be an identifier\n \n-passes_repr_conflicting = conflicting representation hints\n+passes_repr_conflicting =\n+    conflicting representation hints\n \n-passes_used_static = attribute must be applied to a `static` variable\n+passes_used_static =\n+    attribute must be applied to a `static` variable\n \n-passes_used_compiler_linker = `used(compiler)` and `used(linker)` can't be used together\n+passes_used_compiler_linker =\n+    `used(compiler)` and `used(linker)` can't be used together\n \n-passes_allow_internal_unstable = attribute should be applied to a macro\n+passes_allow_internal_unstable =\n+    attribute should be applied to a macro\n     .label = not a macro\n \n-passes_debug_visualizer_placement = attribute should be applied to a module\n+passes_debug_visualizer_placement =\n+    attribute should be applied to a module\n \n-passes_debug_visualizer_invalid = invalid argument\n+passes_debug_visualizer_invalid =\n+    invalid argument\n     .note_1 = expected: `natvis_file = \"...\"`\n     .note_2 = OR\n     .note_3 = expected: `gdb_script_file = \"...\"`\n \n-passes_rustc_allow_const_fn_unstable = attribute should be applied to `const fn`\n+passes_debug_visualizer_unreadable =\n+    couldn't read {$file}: {$error}\n+\n+passes_rustc_allow_const_fn_unstable =\n+    attribute should be applied to `const fn`\n     .label = not a `const fn`\n \n-passes_rustc_std_internal_symbol = attribute should be applied to functions or statics\n+passes_rustc_std_internal_symbol =\n+    attribute should be applied to functions or statics\n     .label = not a function or static\n \n-passes_const_trait = attribute should be applied to a trait\n+passes_const_trait =\n+    attribute should be applied to a trait\n \n-passes_stability_promotable = attribute cannot be applied to an expression\n+passes_stability_promotable =\n+    attribute cannot be applied to an expression\n \n-passes_deprecated = attribute is ignored here\n+passes_deprecated =\n+    attribute is ignored here\n \n-passes_macro_use = `#[{$name}]` only has an effect on `extern crate` and modules\n+passes_macro_use =\n+    `#[{$name}]` only has an effect on `extern crate` and modules\n \n-passes_macro_export = `#[macro_export]` only has an effect on macro definitions\n+passes_macro_export =\n+    `#[macro_export]` only has an effect on macro definitions\n \n-passes_plugin_registrar = `#[plugin_registrar]` only has an effect on functions\n+passes_plugin_registrar =\n+    `#[plugin_registrar]` only has an effect on functions\n \n-passes_unused_empty_lints_note = attribute `{$name}` with an empty list has no effect\n+passes_unused_empty_lints_note =\n+    attribute `{$name}` with an empty list has no effect\n \n-passes_unused_no_lints_note = attribute `{$name}` without any lints has no effect\n+passes_unused_no_lints_note =\n+    attribute `{$name}` without any lints has no effect\n \n passes_unused_default_method_body_const_note =\n     `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n \n-passes_unused = unused attribute\n+passes_unused =\n+    unused attribute\n     .suggestion = remove this attribute\n \n-passes_non_exported_macro_invalid_attrs = attribute should be applied to function or closure\n+passes_non_exported_macro_invalid_attrs =\n+    attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_unused_duplicate = unused attribute\n+passes_unused_duplicate =\n+    unused attribute\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n     .warn = {-passes_previously_accepted}\n \n-passes_unused_multiple = multiple `{$name}` attributes\n+passes_unused_multiple =\n+    multiple `{$name}` attributes\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n \n-passes_rustc_lint_opt_ty = `#[rustc_lint_opt_ty]` should be applied to a struct\n+passes_rustc_lint_opt_ty =\n+    `#[rustc_lint_opt_ty]` should be applied to a struct\n     .label = not a struct\n \n-passes_rustc_lint_opt_deny_field_access = `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+passes_rustc_lint_opt_deny_field_access =\n+    `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n     .label = not a field\n \n-passes_link_ordinal = attribute should be applied to a foreign function or static\n+passes_link_ordinal =\n+    attribute should be applied to a foreign function or static\n     .label = not a foreign function or static\n \n-passes_collapse_debuginfo = `collapse_debuginfo` attribute should be applied to macro definitions\n+passes_collapse_debuginfo =\n+    `collapse_debuginfo` attribute should be applied to macro definitions\n     .label = not a macro definition\n \n-passes_deprecated_annotation_has_no_effect = this `#[deprecated]` annotation has no effect\n+passes_deprecated_annotation_has_no_effect =\n+    this `#[deprecated]` annotation has no effect\n     .suggestion = remove the unnecessary deprecation attribute\n+\n+passes_unknown_external_lang_item =\n+    unknown external lang item: `{$lang_item}`\n+\n+passes_missing_panic_handler =\n+    `#[panic_handler]` function required, but not found\n+\n+passes_alloc_func_required =\n+    `#[alloc_error_handler]` function required, but not found\n+\n+passes_missing_alloc_error_handler =\n+    use `#![feature(default_alloc_error_handler)]` for a default error handler\n+\n+passes_missing_lang_item =\n+    language item required, but not found: `{$name}`\n+    .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n+    .help = you may be able to compile for a target that doesn't need `{$name}`, specify a target with `--target` or in `.cargo/config`\n+\n+passes_lang_item_on_incorrect_target =\n+    `{$name}` language item must be applied to a {$expected_target}\n+    .label = attribute should be applied to a {$expected_target}, not a {$actual_target}\n+\n+passes_unknown_lang_item =\n+    definition of an unknown language item: `{$name}`\n+    .label = definition of unknown language item `{$name}`\n+\n+passes_invalid_attr_at_crate_level =\n+    `{$name}` attribute cannot be used at crate level\n+    .suggestion = perhaps you meant to use an outer attribute\n+\n+passes_duplicate_diagnostic_item =\n+    duplicate diagnostic item found: `{$name}`.\n+\n+passes_duplicate_diagnostic_item_in_crate =\n+    duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n+\n+passes_diagnostic_item_first_defined =\n+    the diagnostic item is first defined here\n+    .note = the diagnostic item is first defined in crate `{$orig_crate_name}`.\n+\n+passes_abi =\n+    abi: {$abi}\n+\n+passes_align =\n+    align: {$align}\n+\n+passes_size =\n+    size: {$size}\n+\n+passes_homogeneous_aggregate =\n+    homogeneous_aggregate: {$homogeneous_aggregate}\n+\n+passes_layout_of =\n+    layout_of({$normalized_ty}) = {$ty_layout}\n+\n+passes_unrecognized_field =\n+    unrecognized field name `{$name}`\n+\n+passes_layout =\n+    layout error: {$layout_error}\n+\n+passes_feature_stable_twice =\n+    feature `{$feature}` is declared stable since {$since}, but was previously declared stable since {$prev_since}\n+\n+passes_feature_previously_declared =\n+    feature `{$feature}` is declared {$declared}, but was previously declared {$prev_declared}\n+\n+passes_expr_not_allowed_in_context =\n+    {$expr} is not allowed in a `{$context}`\n+\n+passes_const_impl_const_trait =\n+    const `impl`s must be for traits marked with `#[const_trait]`\n+    .note = this trait must be annotated with `#[const_trait]`\n+\n+passes_break_non_loop =\n+    `break` with value from a `{$kind}` loop\n+    .label = can only break with a value inside `loop` or breakable block\n+    .label2 = you can't `break` with a value in a `{$kind}` loop\n+    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n+    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+\n+passes_continue_labeled_block =\n+    `continue` pointing to a labeled block\n+    .label = labeled blocks cannot be `continue`'d\n+    .block_label = labeled block the `continue` points to\n+\n+passes_break_inside_closure =\n+    `{$name}` inside of a closure\n+    .label = cannot `{$name}` inside of a closure\n+    .closure_label = enclosing closure\n+\n+passes_break_inside_async_block =\n+    `{$name}` inside of an `async` block\n+    .label = cannot `{$name}` inside of an `async` block\n+    .async_block_label = enclosing `async` block\n+\n+passes_outside_loop =\n+    `{$name}` outside of a loop\n+    .label = cannot `{$name}` outside of a loop\n+\n+passes_unlabeled_in_labeled_block =\n+    unlabeled `{$cf_type}` inside of a labeled block\n+    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n+\n+passes_unlabeled_cf_in_while_condition =\n+    `break` or `continue` with no label in the condition of a `while` loop\n+    .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n+\n+passes_cannot_inline_naked_function =\n+    naked functions cannot be inlined\n+\n+passes_undefined_naked_function_abi =\n+    Rust ABI is unsupported in naked functions\n+\n+passes_no_patterns =\n+    patterns not allowed in naked function parameters\n+\n+passes_params_not_allowed =\n+    referencing function parameters is not allowed in naked functions\n+    .help = follow the calling convention in asm block to use parameters\n+\n+passes_naked_functions_asm_block =\n+    naked functions must contain a single asm block\n+    .label_multiple_asm = multiple asm blocks are unsupported in naked functions\n+    .label_non_asm = non-asm is unsupported in naked functions\n+\n+passes_naked_functions_operands =\n+    only `const` and `sym` operands are supported in naked functions\n+\n+passes_naked_functions_asm_options =\n+    asm options unsupported in naked functions: {$unsupported_options}\n+\n+passes_naked_functions_must_use_noreturn =\n+    asm in naked functions must use `noreturn` option\n+    .suggestion = consider specifying that the asm block is responsible for returning from the function\n+\n+passes_attr_only_on_main =\n+    `{$attr}` attribute can only be used on `fn main()`\n+\n+passes_attr_only_on_root_main =\n+    `{$attr}` attribute can only be used on root `fn main()`\n+\n+passes_attr_only_in_functions =\n+    `{$attr}` attribute can only be used on functions\n+\n+passes_multiple_rustc_main =\n+    multiple functions with a `#[rustc_main]` attribute\n+    .first = first `#[rustc_main]` function\n+    .additional = additional `#[rustc_main]` function\n+\n+passes_multiple_start_functions =\n+    multiple `start` functions\n+    .label = multiple `start` functions\n+    .previous = previous `#[start]` function here\n+\n+passes_extern_main =\n+    the `main` function cannot be declared in an `extern` block\n+\n+passes_unix_sigpipe_values =\n+    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n+\n+passes_no_main_function =\n+    `main` function not found in crate `{$crate_name}`\n+    .here_is_main = here is a function named `main`\n+    .one_or_more_possible_main = you have one or more functions named `main` not defined at the crate level\n+    .consider_moving_main = consider moving the `main` function definitions\n+    .main_must_be_defined_at_crate = the main function must be defined at the crate level{$has_filename ->\n+        [true] {\" \"}(in `{$filename}`)\n+        *[false] {\"\"}\n+    }\n+    .consider_adding_main_to_file = consider adding a `main` function to `{$filename}`\n+    .consider_adding_main_at_crate = consider adding a `main` function at the crate level\n+    .teach_note = If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/\n+    .non_function_main = non-function item at `crate::main` is found\n+\n+passes_duplicate_lang_item =\n+    found duplicate lang item `{$lang_item_name}`\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_duplicate_lang_item_crate =\n+    duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_duplicate_lang_item_crate_depends =\n+    duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_incorrect_target =\n+    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n+        [true] at least {$num}\n+        *[false] {$num}\n+    } generic {$num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+\n+passes_useless_assignment =\n+    useless assignment of {$is_field_assign ->\n+        [true] field\n+        *[false] variable\n+    } of type `{$ty}` to itself\n+\n+passes_only_has_effect_on =\n+    `#[{$attr_name}]` only has an effect on {$target_name ->\n+        [function] functions\n+        [module] modules\n+        [implementation_block] implementation blocks\n+        *[unspecified] (unspecified--this is a compiler bug)\n+    }\n+\n+passes_object_lifetime_err =\n+    {$repr}\n+\n+passes_unrecognized_repr_hint =\n+    unrecognized representation hint\n+    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+\n+passes_attr_application_enum =\n+    attribute should be applied to an enum\n+    .label = not an enum\n+\n+passes_attr_application_struct =\n+    attribute should be applied to a struct\n+    .label = not a struct\n+\n+passes_attr_application_struct_union =\n+    attribute should be applied to a struct or union\n+    .label = not a struct or union\n+\n+passes_attr_application_struct_enum_union =\n+    attribute should be applied to a struct, enum, or union\n+    .label = not a struct, enum, or union\n+\n+passes_attr_application_struct_enum_function_union =\n+    attribute should be applied to a struct, enum, function, or union\n+    .label = not a struct, enum, function, or union\n+\n+passes_transparent_incompatible =\n+    transparent {$target} cannot have other repr hints\n+\n+passes_deprecated_attribute =\n+    deprecated attribute must be paired with either stable or unstable attribute\n+\n+passes_useless_stability =\n+    this stability annotation is useless\n+    .label = useless stability annotation\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_stability =\n+    invalid stability version found\n+    .label = invalid stability version\n+    .item = the stability attribute annotates this item\n+\n+passes_cannot_stabilize_deprecated =\n+    an API can't be stabilized after it is deprecated\n+    .label = invalid version\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_deprecation_version =\n+    invalid deprecation version found\n+    .label = invalid deprecation version\n+    .item = the stability attribute annotates this item\n+\n+passes_missing_stability_attr =\n+    {$descr} has missing stability attribute\n+\n+passes_missing_const_stab_attr =\n+    {$descr} has missing const stability attribute\n+\n+passes_trait_impl_const_stable =\n+    trait implementations cannot be const stable yet\n+    .note = see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\n+\n+passes_feature_only_on_nightly =\n+    `#![feature]` may not be used on the {$release_channel} release channel\n+\n+passes_unknown_feature =\n+    unknown feature `{$feature}`\n+\n+passes_implied_feature_not_exist =\n+    feature `{$implied_by}` implying `{$feature}` does not exist\n+\n+passes_duplicate_feature_err =\n+    the feature `{$feature}` has already been declared\n+\n+passes_missing_const_err =\n+    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n+    .help = make the function or method const\n+    .label = attribute specified here"}, {"sha": "9b41234dcfb6685dd77f705ba663d3a952566662", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -255,6 +255,56 @@ impl EmissionGuarantee for () {\n     }\n }\n \n+/// Marker type which enables implementation of `create_note` and `emit_note` functions for\n+/// note-without-error struct diagnostics.\n+#[derive(Copy, Clone)]\n+pub struct Noted;\n+\n+impl<'a> DiagnosticBuilder<'a, Noted> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    pub(crate) fn new_note(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Note, None, message);\n+        Self::new_diagnostic_note(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_note(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+        debug!(\"Created new diagnostic\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for Noted {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+\n+        Noted\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_note(handler, msg)\n+    }\n+}\n+\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`]."}, {"sha": "c8ccdc539af5a2b13c7ff227cf63a46e06c0fd19", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -374,7 +374,7 @@ pub use diagnostic::{\n     AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgFromDisplay,\n     DiagnosticArgValue, DiagnosticId, DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n-pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee};\n+pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output."}, {"sha": "6045c1acdd0323703b2d923e08940ae28a84c860", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -191,10 +191,29 @@ pub enum LayoutError<'tcx> {\n \n impl<'a> IntoDiagnostic<'a, !> for LayoutError<'a> {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, !> {\n-        handler.struct_fatal(self.to_string())\n+        let mut diag = handler.struct_fatal(\"\");\n+\n+        match self {\n+            LayoutError::Unknown(ty) => {\n+                diag.set_arg(\"ty\", ty);\n+                diag.set_primary_message(rustc_errors::fluent::middle::unknown_layout);\n+            }\n+            LayoutError::SizeOverflow(ty) => {\n+                diag.set_arg(\"ty\", ty);\n+                diag.set_primary_message(rustc_errors::fluent::middle::values_too_big);\n+            }\n+            LayoutError::NormalizationFailure(ty, e) => {\n+                diag.set_arg(\"ty\", ty);\n+                diag.set_arg(\"failure_ty\", e.get_type_for_failure());\n+                diag.set_primary_message(rustc_errors::fluent::middle::cannot_be_normalized);\n+            }\n+        }\n+        diag\n     }\n }\n \n+// FIXME: Once the other errors that embed this error have been converted to translateable\n+// diagnostics, this Display impl should be removed.\n impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {"}, {"sha": "73fb89bbc385e8efc78ac72de7f2eeb9b96d3058", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 61, "deletions": 90, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -4,10 +4,13 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::errors;\n+use crate::errors::{\n+    self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n+    OnlyHasEffectOn, TransparentIncompatible, UnrecognizedReprHint,\n+};\n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{fluent, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{fluent, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -164,17 +167,17 @@ impl CheckAttrVisitor<'_> {\n                 sym::no_mangle => self.check_no_mangle(hir_id, attr, span, target),\n                 sym::deprecated => self.check_deprecated(hir_id, attr, span, target),\n                 sym::macro_use | sym::macro_escape => self.check_macro_use(hir_id, attr, target),\n-                sym::path => self.check_generic_attr(hir_id, attr, target, &[Target::Mod]),\n+                sym::path => self.check_generic_attr(hir_id, attr, target, Target::Mod),\n                 sym::plugin_registrar => self.check_plugin_registrar(hir_id, attr, target),\n                 sym::macro_export => self.check_macro_export(hir_id, attr, target),\n                 sym::ignore | sym::should_panic | sym::proc_macro_derive => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Fn])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Fn)\n                 }\n                 sym::automatically_derived => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Impl])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Impl)\n                 }\n                 sym::no_implicit_prelude => {\n-                    self.check_generic_attr(hir_id, attr, target, &[Target::Mod])\n+                    self.check_generic_attr(hir_id, attr, target, Target::Mod)\n                 }\n                 sym::rustc_object_lifetime_default => self.check_object_lifetime_default(hir_id),\n                 _ => {}\n@@ -351,31 +354,17 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n         attr: &Attribute,\n         target: Target,\n-        allowed_targets: &[Target],\n+        allowed_target: Target,\n     ) {\n-        if !allowed_targets.iter().any(|t| t == &target) {\n-            let name = attr.name_or_empty();\n-            let mut i = allowed_targets.iter();\n-            // Pluralize\n-            let b = i.next().map_or_else(String::new, |t| t.to_string() + \"s\");\n-            let supported_names = i.enumerate().fold(b, |mut b, (i, allowed_target)| {\n-                if allowed_targets.len() > 2 && i == allowed_targets.len() - 2 {\n-                    b.push_str(\", and \");\n-                } else if allowed_targets.len() == 2 && i == allowed_targets.len() - 2 {\n-                    b.push_str(\" and \");\n-                } else {\n-                    b.push_str(\", \");\n-                }\n-                // Pluralize\n-                b.push_str(&(allowed_target.to_string() + \"s\"));\n-                b\n-            });\n-            self.tcx.struct_span_lint_hir(\n+        if target != allowed_target {\n+            self.tcx.emit_spanned_lint(\n                 UNUSED_ATTRIBUTES,\n                 hir_id,\n                 attr.span,\n-                &format!(\"`#[{name}]` only has an effect on {}\", supported_names),\n-                |lint| lint,\n+                OnlyHasEffectOn {\n+                    attr_name: attr.name_or_empty(),\n+                    target_name: allowed_target.name().replace(\" \", \"_\"),\n+                },\n             );\n         }\n     }\n@@ -432,7 +421,7 @@ impl CheckAttrVisitor<'_> {\n                     ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n                     ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n                 };\n-                tcx.sess.span_err(p.span, &repr);\n+                tcx.sess.emit_err(ObjectLifetimeErr { span: p.span, repr });\n             }\n         }\n     }\n@@ -1605,12 +1594,17 @@ impl CheckAttrVisitor<'_> {\n                 continue;\n             }\n \n-            let (article, allowed_targets) = match hint.name_or_empty() {\n+            match hint.name_or_empty() {\n                 sym::C => {\n                     is_c = true;\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n+                        _ => {\n+                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                                hint_span: hint.span(),\n+                                span,\n+                            });\n+                        }\n                     }\n                 }\n                 sym::align => {\n@@ -1626,20 +1620,30 @@ impl CheckAttrVisitor<'_> {\n \n                     match target {\n                         Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n-                        _ => (\"a\", \"struct, enum, function, or union\"),\n+                        _ => {\n+                            self.tcx.sess.emit_err(AttrApplication::StructEnumFunctionUnion {\n+                                hint_span: hint.span(),\n+                                span,\n+                            });\n+                        }\n                     }\n                 }\n                 sym::packed => {\n                     if target != Target::Struct && target != Target::Union {\n-                        (\"a\", \"struct or union\")\n+                        self.tcx.sess.emit_err(AttrApplication::StructUnion {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n                 }\n                 sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n-                        (\"a\", \"struct\")\n+                        self.tcx\n+                            .sess\n+                            .emit_err(AttrApplication::Struct { hint_span: hint.span(), span });\n                     } else {\n                         continue;\n                     }\n@@ -1648,7 +1652,12 @@ impl CheckAttrVisitor<'_> {\n                     is_transparent = true;\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n+                        _ => {\n+                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                                hint_span: hint.span(),\n+                                span,\n+                            });\n+                        }\n                     }\n                 }\n                 sym::i8\n@@ -1665,35 +1674,18 @@ impl CheckAttrVisitor<'_> {\n                 | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n-                        (\"an\", \"enum\")\n+                        self.tcx\n+                            .sess\n+                            .emit_err(AttrApplication::Enum { hint_span: hint.span(), span });\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        hint.span(),\n-                        E0552,\n-                        \"unrecognized representation hint\"\n-                    )\n-                    .help(\"valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, \\\n-                          `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\")\n-                    .emit();\n-\n+                    self.tcx.sess.emit_err(UnrecognizedReprHint { span: hint.span() });\n                     continue;\n                 }\n             };\n-\n-            struct_span_err!(\n-                self.tcx.sess,\n-                hint.span(),\n-                E0517,\n-                \"{}\",\n-                &format!(\"attribute should be applied to {article} {allowed_targets}\")\n-            )\n-            .span_label(span, &format!(\"not {article} {allowed_targets}\"))\n-            .emit();\n         }\n \n         // Just point at all repr hints if there are any incompatibilities.\n@@ -1703,14 +1695,9 @@ impl CheckAttrVisitor<'_> {\n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {\n             let hint_spans: Vec<_> = hint_spans.clone().collect();\n-            struct_span_err!(\n-                self.tcx.sess,\n-                hint_spans,\n-                E0692,\n-                \"transparent {} cannot have other repr hints\",\n-                target\n-            )\n-            .emit();\n+            self.tcx\n+                .sess\n+                .emit_err(TransparentIncompatible { hint_spans, target: target.to_string() });\n         }\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n@@ -1862,14 +1849,12 @@ impl CheckAttrVisitor<'_> {\n \n         match std::fs::File::open(&file) {\n             Ok(_) => true,\n-            Err(err) => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        meta_item.span,\n-                        &format!(\"couldn't read {}: {}\", file.display(), err),\n-                    )\n-                    .emit();\n+            Err(error) => {\n+                self.tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                    span: meta_item.span,\n+                    file: &file,\n+                    error,\n+                });\n                 false\n             }\n         }\n@@ -2180,25 +2165,11 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n         if attr.style == AttrStyle::Inner {\n             for attr_to_check in ATTRS_TO_CHECK {\n                 if attr.has_name(*attr_to_check) {\n-                    let mut err = tcx.sess.struct_span_err(\n-                        attr.span,\n-                        &format!(\n-                            \"`{}` attribute cannot be used at crate level\",\n-                            attr_to_check.to_ident_string()\n-                        ),\n-                    );\n-                    // Only emit an error with a suggestion if we can create a\n-                    // string out of the attribute span\n-                    if let Ok(src) = tcx.sess.source_map().span_to_snippet(attr.span) {\n-                        let replacement = src.replace(\"#!\", \"#\");\n-                        err.span_suggestion_verbose(\n-                            attr.span,\n-                            \"perhaps you meant to use an outer attribute\",\n-                            replacement,\n-                            rustc_errors::Applicability::MachineApplicable,\n-                        );\n-                    }\n-                    err.emit();\n+                    tcx.sess.emit_err(InvalidAttrAtCrateLevel {\n+                        span: attr.span,\n+                        snippet: tcx.sess.source_map().span_to_snippet(attr.span).ok(),\n+                        name: *attr_to_check,\n+                    });\n                 }\n             }\n         }"}, {"sha": "aa726d6cd92aad0b9a7ce3374f23c64c944fe7d1", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -8,7 +8,6 @@\n //! through, but errors for structured control flow in a `const` should be emitted here.\n \n use rustc_attr as attr;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n@@ -18,6 +17,8 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::parse::feature_err;\n use rustc_span::{sym, Span, Symbol};\n \n+use crate::errors::ExprNotAllowedInContext;\n+\n /// An expression that is not *always* legal in a const context.\n #[derive(Clone, Copy)]\n enum NonConstExpr {\n@@ -133,18 +134,22 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n         let const_kind =\n             const_kind.expect(\"`const_check_violated` may only be called inside a const context\");\n \n-        let msg = format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind.keyword_name());\n-\n         let required_gates = required_gates.unwrap_or(&[]);\n         let missing_gates: Vec<_> =\n             required_gates.iter().copied().filter(|&g| !features.enabled(g)).collect();\n \n         match missing_gates.as_slice() {\n             [] => {\n-                struct_span_err!(tcx.sess, span, E0744, \"{}\", msg).emit();\n+                tcx.sess.emit_err(ExprNotAllowedInContext {\n+                    span,\n+                    expr: expr.name(),\n+                    context: const_kind.keyword_name(),\n+                });\n             }\n \n             [missing_primary, ref missing_secondary @ ..] => {\n+                let msg =\n+                    format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind.keyword_name());\n                 let mut err = feature_err(&tcx.sess.parse_sess, *missing_primary, span, &msg);\n \n                 // If multiple feature gates would be required to enable this expression, include"}, {"sha": "6a97ad3fe86e2cc367a425c92490400ed1bc279f", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -4,7 +4,7 @@\n \n use itertools::Itertools;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, Applicability, DelayDm, MultiSpan};\n+use rustc_errors::{pluralize, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -18,6 +18,8 @@ use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n use std::mem;\n \n+use crate::errors::UselessAssignment;\n+\n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n@@ -180,19 +182,11 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 && !assign.span.from_expansion()\n         {\n                 let is_field_assign = matches!(lhs.kind, hir::ExprKind::Field(..));\n-                self.tcx.struct_span_lint_hir(\n+                self.tcx.emit_spanned_lint(\n                     lint::builtin::DEAD_CODE,\n                     assign.hir_id,\n                     assign.span,\n-                    DelayDm(|| format!(\n-                            \"useless assignment of {} of type `{}` to itself\",\n-                            if is_field_assign { \"field\" } else { \"variable\" },\n-                            self.typeck_results().expr_ty(lhs),\n-                        )),\n-                    |lint| {\n-                        lint\n-\n-                    },\n+                    UselessAssignment { is_field_assign, ty: self.typeck_results().expr_ty(lhs) }\n                 )\n         }\n     }"}, {"sha": "253b0a88e48aa69590a0972bc17eb29e29661c44", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -13,6 +13,8 @@ use rustc_span::{sym, DebuggerVisualizerFile, DebuggerVisualizerType};\n \n use std::sync::Arc;\n \n+use crate::errors::DebugVisualizerUnreadable;\n+\n fn check_for_debugger_visualizer<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     hir_id: HirId,\n@@ -54,13 +56,12 @@ fn check_for_debugger_visualizer<'tcx>(\n                     debugger_visualizers\n                         .insert(DebuggerVisualizerFile::new(Arc::from(contents), visualizer_type));\n                 }\n-                Err(err) => {\n-                    tcx.sess\n-                        .struct_span_err(\n-                            meta_item.span,\n-                            &format!(\"couldn't read {}: {}\", file.display(), err),\n-                        )\n-                        .emit();\n+                Err(error) => {\n+                    tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                        span: meta_item.span,\n+                        file: &file,\n+                        error,\n+                    });\n                 }\n             }\n         }"}, {"sha": "3f991cf65724128814a1bf44879299b65f702a07", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -14,7 +14,9 @@ use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{kw::Empty, sym, Symbol};\n+\n+use crate::errors::{DuplicateDiagnosticItem, DuplicateDiagnosticItemInCrate};\n \n fn observe_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -33,25 +35,22 @@ fn collect_item(tcx: TyCtxt<'_>, items: &mut DiagnosticItems, name: Symbol, item\n     items.id_to_name.insert(item_def_id, name);\n     if let Some(original_def_id) = items.name_to_id.insert(name, item_def_id) {\n         if original_def_id != item_def_id {\n-            let mut err = match tcx.hir().span_if_local(item_def_id) {\n-                Some(span) => tcx\n-                    .sess\n-                    .struct_span_err(span, &format!(\"duplicate diagnostic item found: `{name}`.\")),\n-                None => tcx.sess.struct_err(&format!(\n-                    \"duplicate diagnostic item in crate `{}`: `{}`.\",\n-                    tcx.crate_name(item_def_id.krate),\n-                    name\n-                )),\n-            };\n-            if let Some(span) = tcx.hir().span_if_local(original_def_id) {\n-                err.span_note(span, \"the diagnostic item is first defined here\");\n+            let orig_span = tcx.hir().span_if_local(original_def_id);\n+            let orig_crate_name = if orig_span.is_some() {\n+                None\n             } else {\n-                err.note(&format!(\n-                    \"the diagnostic item is first defined in crate `{}`.\",\n-                    tcx.crate_name(original_def_id.krate)\n-                ));\n-            }\n-            err.emit();\n+                Some(tcx.crate_name(original_def_id.krate))\n+            };\n+            match tcx.hir().span_if_local(item_def_id) {\n+                Some(span) => tcx.sess.emit_err(DuplicateDiagnosticItem { span, name }),\n+                None => tcx.sess.emit_err(DuplicateDiagnosticItemInCrate {\n+                    span: orig_span,\n+                    orig_crate_name: orig_crate_name.unwrap_or(Empty),\n+                    have_orig_crate_name: orig_crate_name.map(|_| ()),\n+                    crate_name: tcx.crate_name(item_def_id.krate),\n+                    name,\n+                }),\n+            };\n         }\n     }\n }"}, {"sha": "38a259ca8846f14834a0eb982f73dffd439c8025", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 55, "deletions": 90, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast::entry::EntryPointType;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::error_code;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{ItemId, Node, CRATE_HIR_ID};\n@@ -8,7 +8,12 @@ use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_session::config::{sigpipe, CrateType, EntryFnType};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{Span, Symbol};\n+\n+use crate::errors::{\n+    AttrOnlyInFunctions, AttrOnlyOnMain, AttrOnlyOnRootMain, ExternMain, MultipleRustcMain,\n+    MultipleStartFunctions, NoMainErr, UnixSigpipeValues,\n+};\n \n struct EntryContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n@@ -71,64 +76,57 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n     }\n }\n \n-fn err_if_attr_found(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol, details: &str) {\n+fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Option<Span> {\n     let attrs = ctxt.tcx.hir().attrs(id.hir_id());\n-    if let Some(attr) = ctxt.tcx.sess.find_by_name(attrs, sym) {\n-        ctxt.tcx\n-            .sess\n-            .struct_span_err(attr.span, &format!(\"`{}` attribute {}\", sym, details))\n-            .emit();\n-    }\n+    ctxt.tcx.sess.find_by_name(attrs, sym).map(|attr| attr.span)\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n     let at_root = ctxt.tcx.opt_local_parent(id.def_id.def_id) == Some(CRATE_DEF_ID);\n \n     match entry_point_type(ctxt, id, at_root) {\n         EntryPointType::None => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n+            }\n         }\n         _ if !matches!(ctxt.tcx.def_kind(id.def_id), DefKind::Fn) => {\n-            err_if_attr_found(ctxt, id, sym::start, \"can only be used on functions\");\n-            err_if_attr_found(ctxt, id, sym::rustc_main, \"can only be used on functions\");\n+            for attr in [sym::start, sym::rustc_main] {\n+                if let Some(span) = attr_span_by_symbol(ctxt, id, attr) {\n+                    ctxt.tcx.sess.emit_err(AttrOnlyInFunctions { span, attr });\n+                }\n+            }\n         }\n         EntryPointType::MainNamed => (),\n         EntryPointType::OtherMain => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on root `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnRootMain { span, attr: sym::unix_sigpipe });\n+            }\n             ctxt.non_main_fns.push(ctxt.tcx.def_span(id.def_id));\n         }\n         EntryPointType::RustcMainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n                 ctxt.attr_main_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n-                struct_span_err!(\n-                    ctxt.tcx.sess,\n-                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n-                    E0137,\n-                    \"multiple functions with a `#[rustc_main]` attribute\"\n-                )\n-                .span_label(\n-                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n-                    \"additional `#[rustc_main]` function\",\n-                )\n-                .span_label(ctxt.attr_main_fn.unwrap().1, \"first `#[rustc_main]` function\")\n-                .emit();\n+                ctxt.tcx.sess.emit_err(MultipleRustcMain {\n+                    span: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    first: ctxt.attr_main_fn.unwrap().1,\n+                    additional: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                });\n             }\n         }\n         EntryPointType::Start => {\n-            err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on `fn main()`\");\n+            if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n+                ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n+            }\n             if ctxt.start_fn.is_none() {\n                 ctxt.start_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n-                struct_span_err!(\n-                    ctxt.tcx.sess,\n-                    ctxt.tcx.def_span(id.def_id),\n-                    E0138,\n-                    \"multiple `start` functions\"\n-                )\n-                .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")\n-                .span_label(ctxt.tcx.def_span(id.def_id.to_def_id()), \"multiple `start` functions\")\n-                .emit();\n+                ctxt.tcx.sess.emit_err(MultipleStartFunctions {\n+                    span: ctxt.tcx.def_span(id.def_id),\n+                    labeled: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    previous: ctxt.start_fn.unwrap().1,\n+                });\n             }\n         }\n     }\n@@ -144,12 +142,7 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) -> Option<(DefId,\n         if let Some(main_def) = tcx.resolutions(()).main_def && let Some(def_id) = main_def.opt_fn_def_id() {\n             // non-local main imports are handled below\n             if let Some(def_id) = def_id.as_local() && matches!(tcx.hir().find_by_def_id(def_id), Some(Node::ForeignItem(_))) {\n-                tcx.sess\n-                    .struct_span_err(\n-                        tcx.def_span(def_id),\n-                        \"the `main` function cannot be declared in an `extern` block\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(ExternMain { span: tcx.def_span(def_id) });\n                 return None;\n             }\n \n@@ -182,12 +175,7 @@ fn sigpipe(tcx: TyCtxt<'_>, def_id: DefId) -> u8 {\n                 sigpipe::DEFAULT\n             }\n             _ => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"valid values for `#[unix_sigpipe = \\\"...\\\"]` are `inherit`, `sig_ign`, or `sig_dfl`\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(UnixSigpipeValues { span: attr.span });\n                 sigpipe::DEFAULT\n             }\n         }\n@@ -206,52 +194,29 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) {\n     }\n \n     // There is no main function.\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        DUMMY_SP,\n-        E0601,\n-        \"`main` function not found in crate `{}`\",\n-        tcx.crate_name(LOCAL_CRATE)\n-    );\n-    let filename = &tcx.sess.local_crate_source_file;\n-    let note = if !visitor.non_main_fns.is_empty() {\n-        for &span in &visitor.non_main_fns {\n-            err.span_note(span, \"here is a function named `main`\");\n-        }\n-        err.note(\"you have one or more functions named `main` not defined at the crate level\");\n-        err.help(\"consider moving the `main` function definitions\");\n-        // There were some functions named `main` though. Try to give the user a hint.\n-        format!(\n-            \"the main function must be defined at the crate level{}\",\n-            filename.as_ref().map(|f| format!(\" (in `{}`)\", f.display())).unwrap_or_default()\n-        )\n-    } else if let Some(filename) = filename {\n-        format!(\"consider adding a `main` function to `{}`\", filename.display())\n-    } else {\n-        String::from(\"consider adding a `main` function at the crate level\")\n-    };\n+    let mut has_filename = true;\n+    let filename = tcx.sess.local_crate_source_file.clone().unwrap_or_else(|| {\n+        has_filename = false;\n+        Default::default()\n+    });\n+    let main_def_opt = tcx.resolutions(()).main_def;\n+    let diagnostic_id = error_code!(E0601);\n+    let add_teach_note = tcx.sess.teach(&diagnostic_id);\n     // The file may be empty, which leads to the diagnostic machinery not emitting this\n     // note. This is a relatively simple way to detect that case and emit a span-less\n     // note instead.\n-    if tcx.sess.source_map().lookup_line(sp.hi()).is_ok() {\n-        err.set_span(sp.shrink_to_hi());\n-        err.span_label(sp.shrink_to_hi(), &note);\n-    } else {\n-        err.note(&note);\n-    }\n-\n-    if let Some(main_def) = tcx.resolutions(()).main_def && main_def.opt_fn_def_id().is_none(){\n-        // There is something at `crate::main`, but it is not a function definition.\n-        err.span_label(main_def.span, \"non-function item at `crate::main` is found\");\n-    }\n-\n-    if tcx.sess.teach(&err.get_code().unwrap()) {\n-        err.note(\n-            \"If you don't know the basics of Rust, you can go look to the Rust Book \\\n-                  to get started: https://doc.rust-lang.org/book/\",\n-        );\n-    }\n-    err.emit();\n+    let file_empty = !tcx.sess.source_map().lookup_line(sp.hi()).is_ok();\n+\n+    tcx.sess.emit_err(NoMainErr {\n+        sp,\n+        crate_name: tcx.crate_name(LOCAL_CRATE),\n+        has_filename,\n+        filename,\n+        file_empty,\n+        non_main_fns: visitor.non_main_fns.clone(),\n+        main_def_opt,\n+        add_teach_note,\n+    });\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "1cc81a9ab9884697fafcbedfbff7c76374c9b09a", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 783, "deletions": 2, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -1,6 +1,16 @@\n-use rustc_errors::{Applicability, MultiSpan};\n+use std::{\n+    io::Error,\n+    path::{Path, PathBuf},\n+};\n+\n+use rustc_ast::Label;\n+use rustc_errors::{error_code, Applicability, ErrorGuaranteed, IntoDiagnostic, MultiSpan};\n+use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n-use rustc_span::{Span, Symbol};\n+use rustc_middle::ty::{MainDefinition, Ty};\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n+\n+use crate::lang_items::Duplicate;\n \n #[derive(LintDiagnostic)]\n #[diag(passes::outer_crate_level_attr)]\n@@ -526,6 +536,15 @@ pub struct DebugVisualizerInvalid {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(passes::debug_visualizer_unreadable)]\n+pub struct DebugVisualizerUnreadable<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub file: &'a Path,\n+    pub error: Error,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(passes::rustc_allow_const_fn_unstable)]\n pub struct RustcAllowConstFnUnstable {\n@@ -665,3 +684,765 @@ pub struct DeprecatedAnnotationHasNoEffect {\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unknown_external_lang_item, code = \"E0264\")]\n+pub struct UnknownExternLangItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub lang_item: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_panic_handler)]\n+pub struct MissingPanicHandler;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::alloc_func_required)]\n+pub struct AllocFuncRequired;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_alloc_error_handler)]\n+pub struct MissingAllocErrorHandler;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_lang_item)]\n+#[note]\n+#[help]\n+pub struct MissingLangItem {\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::lang_item_on_incorrect_target, code = \"E0718\")]\n+pub struct LangItemOnIncorrectTarget {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub expected_target: Target,\n+    pub actual_target: Target,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unknown_lang_item, code = \"E0522\")]\n+pub struct UnknownLangItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+pub struct InvalidAttrAtCrateLevel {\n+    pub span: Span,\n+    pub snippet: Option<String>,\n+    pub name: Symbol,\n+}\n+\n+impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'_ rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag =\n+            handler.struct_err(rustc_errors::fluent::passes::invalid_attr_at_crate_level);\n+        diag.set_span(self.span);\n+        diag.set_arg(\"name\", self.name);\n+        // Only emit an error with a suggestion if we can create a string out\n+        // of the attribute span\n+        if let Some(src) = self.snippet {\n+            let replacement = src.replace(\"#!\", \"#\");\n+            diag.span_suggestion_verbose(\n+                self.span,\n+                rustc_errors::fluent::passes::suggestion,\n+                replacement,\n+                rustc_errors::Applicability::MachineApplicable,\n+            );\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::duplicate_diagnostic_item)]\n+pub struct DuplicateDiagnosticItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::duplicate_diagnostic_item_in_crate)]\n+pub struct DuplicateDiagnosticItemInCrate {\n+    #[note(passes::diagnostic_item_first_defined)]\n+    pub span: Option<Span>,\n+    pub orig_crate_name: Symbol,\n+    #[note]\n+    pub have_orig_crate_name: Option<()>,\n+    pub crate_name: Symbol,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::abi)]\n+pub struct Abi {\n+    #[primary_span]\n+    pub span: Span,\n+    pub abi: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::align)]\n+pub struct Align {\n+    #[primary_span]\n+    pub span: Span,\n+    pub align: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::size)]\n+pub struct Size {\n+    #[primary_span]\n+    pub span: Span,\n+    pub size: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::homogeneous_aggregate)]\n+pub struct HomogeneousAggregate {\n+    #[primary_span]\n+    pub span: Span,\n+    pub homogeneous_aggregate: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::layout_of)]\n+pub struct LayoutOf {\n+    #[primary_span]\n+    pub span: Span,\n+    pub normalized_ty: String,\n+    pub ty_layout: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unrecognized_field)]\n+pub struct UnrecognizedField {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::feature_stable_twice, code = \"E0711\")]\n+pub struct FeatureStableTwice {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub since: Symbol,\n+    pub prev_since: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::feature_previously_declared, code = \"E0711\")]\n+pub struct FeaturePreviouslyDeclared<'a, 'b> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub declared: &'a str,\n+    pub prev_declared: &'b str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::expr_not_allowed_in_context, code = \"E0744\")]\n+pub struct ExprNotAllowedInContext<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub expr: String,\n+    pub context: &'a str,\n+}\n+\n+pub struct BreakNonLoop<'a> {\n+    pub span: Span,\n+    pub head: Option<Span>,\n+    pub kind: &'a str,\n+    pub suggestion: String,\n+    pub loop_label: Option<Label>,\n+    pub break_label: Option<Label>,\n+    pub break_expr_kind: &'a ExprKind<'a>,\n+    pub break_expr_span: Span,\n+}\n+\n+impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::passes::break_non_loop,\n+            error_code!(E0571),\n+        );\n+        diag.set_arg(\"kind\", self.kind);\n+        diag.span_label(self.span, rustc_errors::fluent::passes::label);\n+        if let Some(head) = self.head {\n+            diag.span_label(head, rustc_errors::fluent::passes::label2);\n+        }\n+        diag.span_suggestion(\n+            self.span,\n+            rustc_errors::fluent::passes::suggestion,\n+            self.suggestion,\n+            Applicability::MaybeIncorrect,\n+        );\n+        if let (Some(label), None) = (self.loop_label, self.break_label) {\n+            match self.break_expr_kind {\n+                ExprKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    hir::Path { segments: [segment], res: hir::def::Res::Err, .. },\n+                )) if label.ident.to_string() == format!(\"'{}\", segment.ident) => {\n+                    // This error is redundant, we will have already emitted a\n+                    // suggestion to use the label when `segment` wasn't found\n+                    // (hence the `Res::Err` check).\n+                    diag.delay_as_bug();\n+                }\n+                _ => {\n+                    diag.span_suggestion(\n+                        self.break_expr_span,\n+                        rustc_errors::fluent::passes::break_expr_suggestion,\n+                        label.ident,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::continue_labeled_block, code = \"E0696\")]\n+pub struct ContinueLabeledBlock {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::block_label)]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::break_inside_closure, code = \"E0267\")]\n+pub struct BreakInsideClosure<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::closure_label)]\n+    pub closure_span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::break_inside_async_block, code = \"E0267\")]\n+pub struct BreakInsideAsyncBlock<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::async_block_label)]\n+    pub closure_span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::outside_loop, code = \"E0268\")]\n+pub struct OutsideLoop<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unlabeled_in_labeled_block, code = \"E0695\")]\n+pub struct UnlabeledInLabeledBlock<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub cf_type: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unlabeled_cf_in_while_condition, code = \"E0590\")]\n+pub struct UnlabeledCfInWhileCondition<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub cf_type: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::cannot_inline_naked_function)]\n+pub struct CannotInlineNakedFunction {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::undefined_naked_function_abi)]\n+pub struct UndefinedNakedFunctionAbi;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::no_patterns)]\n+pub struct NoPatterns {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::params_not_allowed)]\n+#[help]\n+pub struct ParamsNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+pub struct NakedFunctionsAsmBlock {\n+    pub span: Span,\n+    pub multiple_asms: Vec<Span>,\n+    pub non_asms: Vec<Span>,\n+}\n+\n+impl IntoDiagnostic<'_> for NakedFunctionsAsmBlock {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::passes::naked_functions_asm_block,\n+            error_code!(E0787),\n+        );\n+        for span in self.multiple_asms.iter() {\n+            diag.span_label(*span, rustc_errors::fluent::passes::label_multiple_asm);\n+        }\n+        for span in self.non_asms.iter() {\n+            diag.span_label(*span, rustc_errors::fluent::passes::label_non_asm);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_operands, code = \"E0787\")]\n+pub struct NakedFunctionsOperands {\n+    #[primary_span]\n+    pub unsupported_operands: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_asm_options, code = \"E0787\")]\n+pub struct NakedFunctionsAsmOptions {\n+    #[primary_span]\n+    pub span: Span,\n+    pub unsupported_options: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_must_use_noreturn, code = \"E0787\")]\n+pub struct NakedFunctionsMustUseNoreturn {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \", options(noreturn)\", applicability = \"machine-applicable\")]\n+    pub last_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_on_main)]\n+pub struct AttrOnlyOnMain {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_on_root_main)]\n+pub struct AttrOnlyOnRootMain {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::attr_only_in_functions)]\n+pub struct AttrOnlyInFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::multiple_rustc_main, code = \"E0137\")]\n+pub struct MultipleRustcMain {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(passes::first)]\n+    pub first: Span,\n+    #[label(passes::additional)]\n+    pub additional: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::multiple_start_functions, code = \"E0138\")]\n+pub struct MultipleStartFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub labeled: Span,\n+    #[label(passes::previous)]\n+    pub previous: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::extern_main)]\n+pub struct ExternMain {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unix_sigpipe_values)]\n+pub struct UnixSigpipeValues {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::no_main_function, code = \"E0601\")]\n+pub struct NoMainFunction {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+}\n+\n+pub struct NoMainErr {\n+    pub sp: Span,\n+    pub crate_name: Symbol,\n+    pub has_filename: bool,\n+    pub filename: PathBuf,\n+    pub file_empty: bool,\n+    pub non_main_fns: Vec<Span>,\n+    pub main_def_opt: Option<MainDefinition>,\n+    pub add_teach_note: bool,\n+}\n+\n+impl<'a> IntoDiagnostic<'a> for NoMainErr {\n+    fn into_diagnostic(\n+        self,\n+        handler: &'a rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            DUMMY_SP,\n+            rustc_errors::fluent::passes::no_main_function,\n+            error_code!(E0601),\n+        );\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"filename\", self.filename);\n+        diag.set_arg(\"has_filename\", self.has_filename);\n+        let note = if !self.non_main_fns.is_empty() {\n+            for &span in &self.non_main_fns {\n+                diag.span_note(span, rustc_errors::fluent::passes::here_is_main);\n+            }\n+            diag.note(rustc_errors::fluent::passes::one_or_more_possible_main);\n+            diag.help(rustc_errors::fluent::passes::consider_moving_main);\n+            // There were some functions named `main` though. Try to give the user a hint.\n+            rustc_errors::fluent::passes::main_must_be_defined_at_crate\n+        } else if self.has_filename {\n+            rustc_errors::fluent::passes::consider_adding_main_to_file\n+        } else {\n+            rustc_errors::fluent::passes::consider_adding_main_at_crate\n+        };\n+        if self.file_empty {\n+            diag.note(note);\n+        } else {\n+            diag.set_span(self.sp.shrink_to_hi());\n+            diag.span_label(self.sp.shrink_to_hi(), note);\n+        }\n+\n+        if let Some(main_def) = self.main_def_opt && main_def.opt_fn_def_id().is_none(){\n+            // There is something at `crate::main`, but it is not a function definition.\n+            diag.span_label(main_def.span, rustc_errors::fluent::passes::non_function_main);\n+        }\n+\n+        if self.add_teach_note {\n+            diag.note(rustc_errors::fluent::passes::teach_note);\n+        }\n+        diag\n+    }\n+}\n+\n+pub struct DuplicateLangItem {\n+    pub local_span: Option<Span>,\n+    pub lang_item_name: Symbol,\n+    pub crate_name: Symbol,\n+    pub dependency_of: Symbol,\n+    pub is_local: bool,\n+    pub path: String,\n+    pub first_defined_span: Option<Span>,\n+    pub orig_crate_name: Symbol,\n+    pub orig_dependency_of: Symbol,\n+    pub orig_is_local: bool,\n+    pub orig_path: String,\n+    pub(crate) duplicate: Duplicate,\n+}\n+\n+impl IntoDiagnostic<'_> for DuplicateLangItem {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_err_with_code(\n+            match self.duplicate {\n+                Duplicate::Plain => rustc_errors::fluent::passes::duplicate_lang_item,\n+\n+                Duplicate::Crate => rustc_errors::fluent::passes::duplicate_lang_item_crate,\n+                Duplicate::CrateDepends => {\n+                    rustc_errors::fluent::passes::duplicate_lang_item_crate_depends\n+                }\n+            },\n+            error_code!(E0152),\n+        );\n+        diag.set_arg(\"lang_item_name\", self.lang_item_name);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"dependency_of\", self.dependency_of);\n+        diag.set_arg(\"path\", self.path);\n+        diag.set_arg(\"orig_crate_name\", self.orig_crate_name);\n+        diag.set_arg(\"orig_dependency_of\", self.orig_dependency_of);\n+        diag.set_arg(\"orig_path\", self.orig_path);\n+        if let Some(span) = self.local_span {\n+            diag.set_span(span);\n+        }\n+        if let Some(span) = self.first_defined_span {\n+            diag.span_note(span, rustc_errors::fluent::passes::first_defined_span);\n+        } else {\n+            if self.orig_dependency_of.is_empty() {\n+                diag.note(rustc_errors::fluent::passes::first_defined_crate);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::first_defined_crate_depends);\n+            }\n+\n+            if self.orig_is_local {\n+                diag.note(rustc_errors::fluent::passes::first_definition_local);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::first_definition_path);\n+            }\n+\n+            if self.is_local {\n+                diag.note(rustc_errors::fluent::passes::second_definition_local);\n+            } else {\n+                diag.note(rustc_errors::fluent::passes::second_definition_path);\n+            }\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::incorrect_target, code = \"E0718\")]\n+pub struct IncorrectTarget<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub generics_span: Span,\n+    pub name: &'a str, // cannot be symbol because it renders e.g. `r#fn` instead of `fn`\n+    pub kind: &'static str,\n+    pub num: usize,\n+    pub actual_num: usize,\n+    pub at_least: bool,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::useless_assignment)]\n+pub struct UselessAssignment<'a> {\n+    pub is_field_assign: bool,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::only_has_effect_on)]\n+pub struct OnlyHasEffectOn {\n+    pub attr_name: Symbol,\n+    pub target_name: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::object_lifetime_err)]\n+pub struct ObjectLifetimeErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub repr: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unrecognized_repr_hint, code = \"E0552\")]\n+#[help]\n+pub struct UnrecognizedReprHint {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum AttrApplication {\n+    #[diag(passes::attr_application_enum, code = \"E0517\")]\n+    Enum {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct, code = \"E0517\")]\n+    Struct {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct_union, code = \"E0517\")]\n+    StructUnion {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct_enum_union, code = \"E0517\")]\n+    StructEnumUnion {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+    #[diag(passes::attr_application_struct_enum_function_union, code = \"E0517\")]\n+    StructEnumFunctionUnion {\n+        #[primary_span]\n+        hint_span: Span,\n+        #[label]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::transparent_incompatible, code = \"E0692\")]\n+pub struct TransparentIncompatible {\n+    #[primary_span]\n+    pub hint_spans: Vec<Span>,\n+    pub target: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::deprecated_attribute, code = \"E0549\")]\n+pub struct DeprecatedAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::useless_stability)]\n+pub struct UselessStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::invalid_stability)]\n+pub struct InvalidStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::cannot_stabilize_deprecated)]\n+pub struct CannotStabilizeDeprecated {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::invalid_deprecation_version)]\n+pub struct InvalidDeprecationVersion {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(passes::item)]\n+    pub item_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_stability_attr)]\n+pub struct MissingStabilityAttr<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_const_stab_attr)]\n+pub struct MissingConstStabAttr<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::trait_impl_const_stable)]\n+#[note]\n+pub struct TraitImplConstStable {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::feature_only_on_nightly, code = \"E0554\")]\n+pub struct FeatureOnlyOnNightly {\n+    #[primary_span]\n+    pub span: Span,\n+    pub release_channel: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::unknown_feature, code = \"E0635\")]\n+pub struct UnknownFeature {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::implied_feature_not_exist)]\n+pub struct ImpliedFeatureNotExist {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub implied_by: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::duplicate_feature_err, code = \"E0636\")]\n+pub struct DuplicateFeatureErr {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+}\n+#[derive(Diagnostic)]\n+#[diag(passes::missing_const_err)]\n+pub struct MissingConstErr {\n+    #[primary_span]\n+    #[help]\n+    pub fn_sig_span: Span,\n+    #[label]\n+    pub const_span: Span,\n+}"}, {"sha": "71b0735192ac49df244fad49b54b3d7f688c53a2", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 92, "deletions": 115, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -8,20 +8,28 @@\n //! * Functions called by the compiler itself.\n \n use crate::check_attr::target_from_impl_item;\n+use crate::errors::{\n+    DuplicateLangItem, IncorrectTarget, LangItemOnIncorrectTarget, UnknownLangItem,\n+};\n use crate::weak_lang_items;\n \n-use rustc_errors::{pluralize, struct_span_err};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{extract, GenericRequirement, ITEM_REFS};\n use rustc_hir::{HirId, LangItem, LanguageItems, Target};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ExternCrate;\n-use rustc_span::Span;\n+use rustc_span::{symbol::kw::Empty, Span};\n \n use rustc_middle::ty::query::Providers;\n \n+pub(crate) enum Duplicate {\n+    Plain,\n+    Crate,\n+    CrateDepends,\n+}\n+\n struct LanguageItemCollector<'tcx> {\n     items: LanguageItems,\n     tcx: TyCtxt<'tcx>,\n@@ -34,42 +42,24 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n \n     fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId) {\n         let attrs = self.tcx.hir().attrs(hir_id);\n-        if let Some((value, span)) = extract(&attrs) {\n-            match ITEM_REFS.get(&value).cloned() {\n+        if let Some((name, span)) = extract(&attrs) {\n+            match ITEM_REFS.get(&name).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n                     self.collect_item_extended(item_index, hir_id, span);\n                 }\n                 // Known lang item with attribute on incorrect target.\n                 Some((_, expected_target)) => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n+                    self.tcx.sess.emit_err(LangItemOnIncorrectTarget {\n                         span,\n-                        E0718,\n-                        \"`{}` language item must be applied to a {}\",\n-                        value,\n+                        name,\n                         expected_target,\n-                    )\n-                    .span_label(\n-                        span,\n-                        format!(\n-                            \"attribute should be applied to a {}, not a {}\",\n-                            expected_target, actual_target,\n-                        ),\n-                    )\n-                    .emit();\n+                        actual_target,\n+                    });\n                 }\n                 // Unknown lang item.\n                 _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0522,\n-                        \"definition of an unknown language item: `{}`\",\n-                        value\n-                    )\n-                    .span_label(span, format!(\"definition of unknown language item `{}`\", value))\n-                    .emit();\n+                    self.tcx.sess.emit_err(UnknownLangItem { span, name });\n                 }\n             }\n         }\n@@ -79,74 +69,72 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n         // Check for duplicates.\n         if let Some(original_def_id) = self.items.items[item_index] {\n             if original_def_id != item_def_id {\n-                let lang_item = LangItem::from_u32(item_index as u32).unwrap();\n-                let name = lang_item.name();\n-                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n-                    Some(span) => struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0152,\n-                        \"found duplicate lang item `{}`\",\n-                        name\n-                    ),\n-                    None => match self.tcx.extern_crate(item_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of),\n-                                name\n-                            ))\n-                        }\n-                        _ => self.tcx.sess.struct_err(&format!(\n-                            \"duplicate lang item in crate `{}`: `{}`.\",\n-                            self.tcx.crate_name(item_def_id.krate),\n-                            name\n-                        )),\n-                    },\n+                let local_span = self.tcx.hir().span_if_local(item_def_id);\n+                let lang_item_name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let crate_name = self.tcx.crate_name(item_def_id.krate);\n+                let mut dependency_of = Empty;\n+                let is_local = item_def_id.is_local();\n+                let path = if is_local {\n+                    String::new()\n+                } else {\n+                    self.tcx\n+                        .crate_extern_paths(item_def_id.krate)\n+                        .iter()\n+                        .map(|p| p.display().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                        .into()\n                 };\n-                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"the lang item is first defined here\");\n+                let first_defined_span = self.tcx.hir().span_if_local(original_def_id);\n+                let mut orig_crate_name = Empty;\n+                let mut orig_dependency_of = Empty;\n+                let orig_is_local = original_def_id.is_local();\n+                let orig_path = if orig_is_local {\n+                    String::new()\n                 } else {\n-                    match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            err.note(&format!(\n-                                \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n-                                self.tcx.crate_name(original_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of)\n-                            ));\n-                        }\n-                        _ => {\n-                            err.note(&format!(\n-                                \"the lang item is first defined in crate `{}`.\",\n-                                self.tcx.crate_name(original_def_id.krate)\n-                            ));\n-                        }\n+                    self.tcx\n+                        .crate_extern_paths(original_def_id.krate)\n+                        .iter()\n+                        .map(|p| p.display().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                        .into()\n+                };\n+                if first_defined_span.is_none() {\n+                    orig_crate_name = self.tcx.crate_name(original_def_id.krate);\n+                    if let Some(ExternCrate { dependency_of: inner_dependency_of, .. }) =\n+                        self.tcx.extern_crate(original_def_id)\n+                    {\n+                        orig_dependency_of = self.tcx.crate_name(*inner_dependency_of);\n                     }\n-                    let mut note_def = |which, def_id: DefId| {\n-                        let crate_name = self.tcx.crate_name(def_id.krate);\n-                        let note = if def_id.is_local() {\n-                            format!(\"{} definition in the local crate (`{}`)\", which, crate_name)\n-                        } else {\n-                            let paths: Vec<_> = self\n-                                .tcx\n-                                .crate_extern_paths(def_id.krate)\n-                                .iter()\n-                                .map(|p| p.display().to_string())\n-                                .collect();\n-                            format!(\n-                                \"{} definition in `{}` loaded from {}\",\n-                                which,\n-                                crate_name,\n-                                paths.join(\", \")\n-                            )\n-                        };\n-                        err.note(&note);\n-                    };\n-                    note_def(\"first\", original_def_id);\n-                    note_def(\"second\", item_def_id);\n                 }\n-                err.emit();\n+\n+                let duplicate = if local_span.is_some() {\n+                    Duplicate::Plain\n+                } else {\n+                    match self.tcx.extern_crate(item_def_id) {\n+                        Some(ExternCrate { dependency_of: inner_dependency_of, .. }) => {\n+                            dependency_of = self.tcx.crate_name(*inner_dependency_of);\n+                            Duplicate::CrateDepends\n+                        }\n+                        _ => Duplicate::Crate,\n+                    }\n+                };\n+\n+                self.tcx.sess.emit_err(DuplicateLangItem {\n+                    local_span,\n+                    lang_item_name,\n+                    crate_name,\n+                    dependency_of,\n+                    is_local,\n+                    path,\n+                    first_defined_span,\n+                    orig_crate_name,\n+                    orig_dependency_of,\n+                    orig_is_local,\n+                    orig_path,\n+                    duplicate,\n+                });\n             }\n         }\n \n@@ -179,41 +167,30 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n                 None => (0, *item_span),\n             };\n \n+            let mut at_least = false;\n             let required = match lang_item.required_generics() {\n-                GenericRequirement::Exact(num) if num != actual_num => {\n-                    Some((format!(\"{}\", num), pluralize!(num)))\n-                }\n+                GenericRequirement::Exact(num) if num != actual_num => Some(num),\n                 GenericRequirement::Minimum(num) if actual_num < num => {\n-                    Some((format!(\"at least {}\", num), pluralize!(num)))\n-                }\n+                    at_least = true;\n+                    Some(num)}\n+                ,\n                 // If the number matches, or there is no requirement, handle it normally\n                 _ => None,\n             };\n \n-            if let Some((range_str, pluralized)) = required {\n+            if let Some(num) = required {\n                 // We are issuing E0718 \"incorrect target\" here, because while the\n                 // item kind of the target is correct, the target is still wrong\n                 // because of the wrong number of generic arguments.\n-                struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(IncorrectTarget {\n                     span,\n-                    E0718,\n-                    \"`{}` language item must be applied to a {} with {} generic argument{}\",\n-                    name,\n-                    kind.descr(),\n-                    range_str,\n-                    pluralized,\n-                )\n-                .span_label(\n                     generics_span,\n-                    format!(\n-                        \"this {} has {} generic argument{}\",\n-                        kind.descr(),\n-                        actual_num,\n-                        pluralize!(actual_num),\n-                    ),\n-                )\n-                .emit();\n+                    name: name.as_str(),\n+                    kind: kind.descr(),\n+                    num,\n+                    actual_num,\n+                    at_least,\n+                });\n \n                 // return early to not collect the lang item\n                 return;"}, {"sha": "c1085094962a741110a9de703057e7c9a6a57b34", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -3,10 +3,13 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, TargetDataLayout};\n \n+use crate::errors::{Abi, Align, HomogeneousAggregate, LayoutOf, Size, UnrecognizedField};\n+\n pub fn test_layout(tcx: TyCtxt<'_>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n@@ -35,62 +38,64 @@ fn dump_layout_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: LocalDefId, attr: &Attri\n             for meta_item in meta_items {\n                 match meta_item.name_or_empty() {\n                     sym::abi => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"abi: {:?}\", ty_layout.abi),\n-                        );\n+                        tcx.sess.emit_err(Abi {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            abi: format!(\"{:?}\", ty_layout.abi),\n+                        });\n                     }\n \n                     sym::align => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"align: {:?}\", ty_layout.align),\n-                        );\n+                        tcx.sess.emit_err(Align {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            align: format!(\"{:?}\", ty_layout.align),\n+                        });\n                     }\n \n                     sym::size => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"size: {:?}\", ty_layout.size),\n-                        );\n+                        tcx.sess.emit_err(Size {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            size: format!(\"{:?}\", ty_layout.size),\n+                        });\n                     }\n \n                     sym::homogeneous_aggregate => {\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\n-                                \"homogeneous_aggregate: {:?}\",\n-                                ty_layout.homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env }),\n+                        tcx.sess.emit_err(HomogeneousAggregate {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            homogeneous_aggregate: format!(\n+                                \"{:?}\",\n+                                ty_layout.homogeneous_aggregate(&UnwrapLayoutCx { tcx, param_env })\n                             ),\n-                        );\n+                        });\n                     }\n \n                     sym::debug => {\n-                        let normalized_ty = tcx.normalize_erasing_regions(\n-                            param_env.with_reveal_all_normalized(tcx),\n-                            ty,\n-                        );\n-                        tcx.sess.span_err(\n-                            tcx.def_span(item_def_id.to_def_id()),\n-                            &format!(\"layout_of({:?}) = {:#?}\", normalized_ty, *ty_layout),\n+                        let normalized_ty = format!(\n+                            \"{:?}\",\n+                            tcx.normalize_erasing_regions(\n+                                param_env.with_reveal_all_normalized(tcx),\n+                                ty,\n+                            )\n                         );\n+                        let ty_layout = format!(\"{:#?}\", *ty_layout);\n+                        tcx.sess.emit_err(LayoutOf {\n+                            span: tcx.def_span(item_def_id.to_def_id()),\n+                            normalized_ty,\n+                            ty_layout,\n+                        });\n                     }\n \n                     name => {\n-                        tcx.sess.span_err(\n-                            meta_item.span(),\n-                            &format!(\"unrecognized field name `{}`\", name),\n-                        );\n+                        tcx.sess.emit_err(UnrecognizedField { span: meta_item.span(), name });\n                     }\n                 }\n             }\n         }\n \n         Err(layout_error) => {\n-            tcx.sess.span_err(\n-                tcx.def_span(item_def_id.to_def_id()),\n-                &format!(\"layout error: {:?}\", layout_error),\n-            );\n+            tcx.sess.emit_fatal(Spanned {\n+                node: layout_error,\n+                span: tcx.def_span(item_def_id.to_def_id()),\n+            });\n         }\n     }\n }"}, {"sha": "15f60f626c89aa54be31b73707b0a34a87f80c6d", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -5,6 +5,8 @@\n //! This API is completely unstable and subject to change.\n \n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(iter_intersperse)]\n #![feature(let_chains)]"}, {"sha": "b5843c0ae488b1f17c58d81c1ae91758baf4e8e7", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -6,7 +6,6 @@\n \n use rustc_ast::{Attribute, MetaItemKind};\n use rustc_attr::{rust_version_symbol, VERSION_PLACEHOLDER};\n-use rustc_errors::struct_span_err;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::lib_features::LibFeatures;\n@@ -15,6 +14,8 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n use rustc_span::{sym, Span};\n \n+use crate::errors::{FeaturePreviouslyDeclared, FeatureStableTwice};\n+\n fn new_lib_features() -> LibFeatures {\n     LibFeatures { stable: Default::default(), unstable: Default::default() }\n }\n@@ -92,14 +93,12 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n             (Some(since), _, false) => {\n                 if let Some((prev_since, _)) = self.lib_features.stable.get(&feature) {\n                     if *prev_since != since {\n-                        self.span_feature_error(\n+                        self.tcx.sess.emit_err(FeatureStableTwice {\n                             span,\n-                            &format!(\n-                                \"feature `{}` is declared stable since {}, \\\n-                                 but was previously declared stable since {}\",\n-                                feature, since, prev_since,\n-                            ),\n-                        );\n+                            feature,\n+                            since,\n+                            prev_since: *prev_since,\n+                        });\n                         return;\n                     }\n                 }\n@@ -110,22 +109,17 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n                 self.lib_features.unstable.insert(feature, span);\n             }\n             (Some(_), _, true) | (None, true, _) => {\n-                self.span_feature_error(\n+                let declared = if since.is_some() { \"stable\" } else { \"unstable\" };\n+                let prev_declared = if since.is_none() { \"stable\" } else { \"unstable\" };\n+                self.tcx.sess.emit_err(FeaturePreviouslyDeclared {\n                     span,\n-                    &format!(\n-                        \"feature `{}` is declared {}, but was previously declared {}\",\n-                        feature,\n-                        if since.is_some() { \"stable\" } else { \"unstable\" },\n-                        if since.is_none() { \"stable\" } else { \"unstable\" },\n-                    ),\n-                );\n+                    feature,\n+                    declared,\n+                    prev_declared,\n+                });\n             }\n         }\n     }\n-\n-    fn span_feature_error(&self, span: Span, msg: &str) {\n-        struct_span_err!(self.tcx.sess, span, E0711, \"{}\", &msg).emit();\n-    }\n }\n \n impl<'tcx> Visitor<'tcx> for LibFeatureCollector<'tcx> {"}, {"sha": "077194ec687bff4da85cddbba83e80d2357543e6", "filename": "compiler/rustc_passes/src/loops.rs", "status": "modified", "additions": 45, "deletions": 116, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Floops.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -1,6 +1,5 @@\n use Context::*;\n \n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n@@ -13,6 +12,11 @@ use rustc_session::Session;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n+use crate::errors::{\n+    BreakInsideAsyncBlock, BreakInsideClosure, BreakNonLoop, ContinueLabeledBlock, OutsideLoop,\n+    UnlabeledCfInWhileCondition, UnlabeledInLabeledBlock,\n+};\n+\n #[derive(Clone, Copy, Debug, PartialEq)]\n enum Context {\n     Normal,\n@@ -90,7 +94,10 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     Ok(loop_id) => Some(loop_id),\n                     Err(hir::LoopIdError::OutsideLoopScope) => None,\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n-                        self.emit_unlabled_cf_in_while_condition(e.span, \"break\");\n+                        self.sess.emit_err(UnlabeledCfInWhileCondition {\n+                            span: e.span,\n+                            cf_type: \"break\",\n+                        });\n                         None\n                     }\n                     Err(hir::LoopIdError::UnresolvedLabel) => None,\n@@ -116,69 +123,22 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     match loop_kind {\n                         None | Some(hir::LoopSource::Loop) => (),\n                         Some(kind) => {\n-                            let mut err = struct_span_err!(\n-                                self.sess,\n-                                e.span,\n-                                E0571,\n-                                \"`break` with value from a `{}` loop\",\n-                                kind.name()\n-                            );\n-                            err.span_label(\n-                                e.span,\n-                                \"can only break with a value inside `loop` or breakable block\",\n+                            let suggestion = format!(\n+                                \"break{}\",\n+                                break_label\n+                                    .label\n+                                    .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n                             );\n-                            if let Some(head) = head {\n-                                err.span_label(\n-                                    head,\n-                                    &format!(\n-                                        \"you can't `break` with a value in a `{}` loop\",\n-                                        kind.name()\n-                                    ),\n-                                );\n-                            }\n-                            err.span_suggestion(\n-                                e.span,\n-                                &format!(\n-                                    \"use `break` on its own without a value inside this `{}` loop\",\n-                                    kind.name(),\n-                                ),\n-                                format!(\n-                                    \"break{}\",\n-                                    break_label\n-                                        .label\n-                                        .map_or_else(String::new, |l| format!(\" {}\", l.ident))\n-                                ),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            if let (Some(label), None) = (loop_label, break_label.label) {\n-                                match break_expr.kind {\n-                                    hir::ExprKind::Path(hir::QPath::Resolved(\n-                                        None,\n-                                        hir::Path {\n-                                            segments: [segment],\n-                                            res: hir::def::Res::Err,\n-                                            ..\n-                                        },\n-                                    )) if label.ident.to_string()\n-                                        == format!(\"'{}\", segment.ident) =>\n-                                    {\n-                                        // This error is redundant, we will have already emitted a\n-                                        // suggestion to use the label when `segment` wasn't found\n-                                        // (hence the `Res::Err` check).\n-                                        err.delay_as_bug();\n-                                    }\n-                                    _ => {\n-                                        err.span_suggestion(\n-                                            break_expr.span,\n-                                            \"alternatively, you might have meant to use the \\\n-                                             available loop label\",\n-                                            label.ident,\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                    }\n-                                }\n-                            }\n-                            err.emit();\n+                            self.sess.emit_err(BreakNonLoop {\n+                                span: e.span,\n+                                head,\n+                                kind: kind.name(),\n+                                suggestion,\n+                                loop_label,\n+                                break_label: break_label.label,\n+                                break_expr_kind: &break_expr.kind,\n+                                break_expr_span: break_expr.span,\n+                            });\n                         }\n                     }\n                 }\n@@ -191,19 +151,17 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 match destination.target_id {\n                     Ok(loop_id) => {\n                         if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n-                            struct_span_err!(\n-                                self.sess,\n-                                e.span,\n-                                E0696,\n-                                \"`continue` pointing to a labeled block\"\n-                            )\n-                            .span_label(e.span, \"labeled blocks cannot be `continue`'d\")\n-                            .span_label(block.span, \"labeled block the `continue` points to\")\n-                            .emit();\n+                            self.sess.emit_err(ContinueLabeledBlock {\n+                                span: e.span,\n+                                block_span: block.span,\n+                            });\n                         }\n                     }\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n-                        self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                        self.sess.emit_err(UnlabeledCfInWhileCondition {\n+                            span: e.span,\n+                            cf_type: \"continue\",\n+                        });\n                     }\n                     Err(_) => {}\n                 }\n@@ -226,21 +184,16 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n     }\n \n     fn require_break_cx(&self, name: &str, span: Span) {\n-        let err_inside_of = |article, ty, closure_span| {\n-            struct_span_err!(self.sess, span, E0267, \"`{}` inside of {} {}\", name, article, ty)\n-                .span_label(span, format!(\"cannot `{}` inside of {} {}\", name, article, ty))\n-                .span_label(closure_span, &format!(\"enclosing {}\", ty))\n-                .emit();\n-        };\n-\n         match self.cx {\n             LabeledBlock | Loop(_) => {}\n-            Closure(closure_span) => err_inside_of(\"a\", \"closure\", closure_span),\n-            AsyncClosure(closure_span) => err_inside_of(\"an\", \"`async` block\", closure_span),\n+            Closure(closure_span) => {\n+                self.sess.emit_err(BreakInsideClosure { span, closure_span, name });\n+            }\n+            AsyncClosure(closure_span) => {\n+                self.sess.emit_err(BreakInsideAsyncBlock { span, closure_span, name });\n+            }\n             Normal | AnonConst => {\n-                struct_span_err!(self.sess, span, E0268, \"`{}` outside of a loop\", name)\n-                    .span_label(span, format!(\"cannot `{}` outside of a loop\", name))\n-                    .emit();\n+                self.sess.emit_err(OutsideLoop { span, name });\n             }\n         }\n     }\n@@ -251,37 +204,13 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         label: &Destination,\n         cf_type: &str,\n     ) -> bool {\n-        if !span.is_desugaring(DesugaringKind::QuestionMark) && self.cx == LabeledBlock {\n-            if label.label.is_none() {\n-                struct_span_err!(\n-                    self.sess,\n-                    span,\n-                    E0695,\n-                    \"unlabeled `{}` inside of a labeled block\",\n-                    cf_type\n-                )\n-                .span_label(\n-                    span,\n-                    format!(\n-                        \"`{}` statements that would diverge to or through \\\n-                                a labeled block need to bear a label\",\n-                        cf_type\n-                    ),\n-                )\n-                .emit();\n-                return true;\n-            }\n+        if !span.is_desugaring(DesugaringKind::QuestionMark)\n+            && self.cx == LabeledBlock\n+            && label.label.is_none()\n+        {\n+            self.sess.emit_err(UnlabeledInLabeledBlock { span, cf_type });\n+            return true;\n         }\n         false\n     }\n-    fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n-        struct_span_err!(\n-            self.sess,\n-            span,\n-            E0590,\n-            \"`break` or `continue` with no label in the condition of a `while` loop\"\n-        )\n-        .span_label(span, format!(\"unlabeled `{}` in the condition of a `while` loop\", cf_type))\n-        .emit();\n-    }\n }"}, {"sha": "acc54e7e11006885c3eee899c05fba4a44252295", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 25, "deletions": 59, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -1,7 +1,6 @@\n //! Checks validity of naked functions.\n \n use rustc_ast::InlineAsmOptions;\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -14,6 +13,12 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n+use crate::errors::{\n+    CannotInlineNakedFunction, NakedFunctionsAsmBlock, NakedFunctionsAsmOptions,\n+    NakedFunctionsMustUseNoreturn, NakedFunctionsOperands, NoPatterns, ParamsNotAllowed,\n+    UndefinedNakedFunctionAbi,\n+};\n+\n pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_naked_functions, ..*providers };\n }\n@@ -56,7 +61,7 @@ fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n fn check_inline(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let attrs = tcx.get_attrs(def_id.to_def_id(), sym::inline);\n     for attr in attrs {\n-        tcx.sess.struct_span_err(attr.span, \"naked functions cannot be inlined\").emit();\n+        tcx.sess.emit_err(CannotInlineNakedFunction { span: attr.span });\n     }\n }\n \n@@ -65,12 +70,11 @@ fn check_abi(tcx: TyCtxt<'_>, def_id: LocalDefId, abi: Abi) {\n     if abi == Abi::Rust {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let span = tcx.def_span(def_id);\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             UNDEFINED_NAKED_FUNCTION_ABI,\n             hir_id,\n             span,\n-            \"Rust ABI is unsupported in naked functions\",\n-            |lint| lint,\n+            UndefinedNakedFunctionAbi,\n         );\n     }\n }\n@@ -82,12 +86,7 @@ fn check_no_patterns(tcx: TyCtxt<'_>, params: &[hir::Param<'_>]) {\n             hir::PatKind::Wild\n             | hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, _, None) => {}\n             _ => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        param.pat.span,\n-                        \"patterns not allowed in naked function parameters\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(NoPatterns { span: param.pat.span });\n             }\n         }\n     }\n@@ -117,14 +116,7 @@ impl<'tcx> Visitor<'tcx> for CheckParameters<'tcx> {\n         )) = expr.kind\n         {\n             if self.params.contains(var_hir_id) {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        expr.span,\n-                        \"referencing function parameters is not allowed in naked functions\",\n-                    )\n-                    .help(\"follow the calling convention in asm block to use parameters\")\n-                    .emit();\n+                self.tcx.sess.emit_err(ParamsNotAllowed { span: expr.span });\n                 return;\n             }\n         }\n@@ -139,26 +131,21 @@ fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<\n     if let [(ItemKind::Asm | ItemKind::Err, _)] = this.items[..] {\n         // Ok.\n     } else {\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            tcx.def_span(def_id),\n-            E0787,\n-            \"naked functions must contain a single asm block\"\n-        );\n-\n         let mut must_show_error = false;\n         let mut has_asm = false;\n         let mut has_err = false;\n+        let mut multiple_asms = vec![];\n+        let mut non_asms = vec![];\n         for &(kind, span) in &this.items {\n             match kind {\n                 ItemKind::Asm if has_asm => {\n                     must_show_error = true;\n-                    diag.span_label(span, \"multiple asm blocks are unsupported in naked functions\");\n+                    multiple_asms.push(span);\n                 }\n                 ItemKind::Asm => has_asm = true,\n                 ItemKind::NonAsm => {\n                     must_show_error = true;\n-                    diag.span_label(span, \"non-asm is unsupported in naked functions\");\n+                    non_asms.push(span);\n                 }\n                 ItemKind::Err => has_err = true,\n             }\n@@ -168,9 +155,11 @@ fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<\n         // errors, then don't show an additional error. This allows for appending/prepending\n         // `compile_error!(\"...\")` statements and reduces error noise.\n         if must_show_error || !has_err {\n-            diag.emit();\n-        } else {\n-            diag.cancel();\n+            tcx.sess.emit_err(NakedFunctionsAsmBlock {\n+                span: tcx.def_span(def_id),\n+                multiple_asms,\n+                non_asms,\n+            });\n         }\n     }\n }\n@@ -251,13 +240,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n             })\n             .collect();\n         if !unsupported_operands.is_empty() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                unsupported_operands,\n-                E0787,\n-                \"only `const` and `sym` operands are supported in naked functions\",\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(NakedFunctionsOperands { unsupported_operands });\n         }\n \n         let unsupported_options: Vec<&'static str> = [\n@@ -273,14 +256,10 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n         .collect();\n \n         if !unsupported_options.is_empty() {\n-            struct_span_err!(\n-                self.tcx.sess,\n+            self.tcx.sess.emit_err(NakedFunctionsAsmOptions {\n                 span,\n-                E0787,\n-                \"asm options unsupported in naked functions: {}\",\n-                unsupported_options.join(\", \")\n-            )\n-            .emit();\n+                unsupported_options: unsupported_options.join(\", \"),\n+            });\n         }\n \n         if !asm.options.contains(InlineAsmOptions::NORETURN) {\n@@ -290,20 +269,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n                 .map_or_else(|| asm.template_strs.last().unwrap().2, |op| op.1)\n                 .shrink_to_hi();\n \n-            struct_span_err!(\n-                self.tcx.sess,\n-                span,\n-                E0787,\n-                \"asm in naked functions must use `noreturn` option\"\n-            )\n-            .span_suggestion(\n-                last_span,\n-                \"consider specifying that the asm block is responsible \\\n-                for returning from the function\",\n-                \", options(noreturn)\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(NakedFunctionsMustUseNoreturn { span, last_span });\n         }\n     }\n }"}, {"sha": "cfd6acd8d7cd0b404310d043e6838cc3768f2ffa", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 46, "deletions": 84, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -1,13 +1,18 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use crate::errors;\n+use crate::errors::{\n+    self, CannotStabilizeDeprecated, DeprecatedAttribute, DuplicateFeatureErr,\n+    FeatureOnlyOnNightly, ImpliedFeatureNotExist, InvalidDeprecationVersion, InvalidStability,\n+    MissingConstErr, MissingConstStabAttr, MissingStabilityAttr, TraitImplConstStable,\n+    UnknownFeature, UselessStability,\n+};\n use rustc_attr::{\n     self as attr, rust_version_symbol, ConstStability, Stability, StabilityLevel, Unstable,\n     UnstableReason, VERSION_PLACEHOLDER,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -20,7 +25,6 @@ use rustc_middle::middle::stability::{AllowUnstable, DeprecationEntry, Index};\n use rustc_middle::ty::{query::Providers, TyCtxt};\n use rustc_session::lint;\n use rustc_session::lint::builtin::{INEFFECTIVE_UNSTABLE_TRAIT_IMPL, USELESS_DEPRECATED};\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n@@ -179,7 +183,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 if !self.in_trait_impl\n                     || (self.in_trait_impl && !self.tcx.is_const_fn_raw(def_id.to_def_id()))\n                 {\n-                    missing_const_err(&self.tcx.sess, fn_sig.span, const_span);\n+                    self.tcx\n+                        .sess\n+                        .emit_err(MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n                 }\n             }\n         }\n@@ -197,14 +203,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         if let Some((rustc_attr::Deprecation { is_since_rustc_version: true, .. }, span)) = &depr {\n             if stab.is_none() {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    *span,\n-                    E0549,\n-                    \"deprecated attribute must be paired with \\\n-                    either stable or unstable attribute\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(DeprecatedAttribute { span: *span });\n             }\n         }\n \n@@ -220,10 +219,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             if kind == AnnotationKind::Prohibited\n                 || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n-                self.tcx.sess.struct_span_err(span,\"this stability annotation is useless\")\n-                    .span_label(span, \"useless stability annotation\")\n-                    .span_label(item_sp, \"the stability attribute annotates this item\")\n-                    .emit();\n+                self.tcx.sess.emit_err(UselessStability { span, item_sp });\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n@@ -239,30 +235,25 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {\n-                            self.tcx.sess.struct_span_err(span, \"invalid stability version found\")\n-                                .span_label(span, \"invalid stability version\")\n-                                .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                .emit();\n+                            self.tcx.sess.emit_err(InvalidStability { span, item_sp });\n                             break;\n                         }\n                         Ok(stab_vp) => match dep_v.parse::<u64>() {\n                             Ok(dep_vp) => match dep_vp.cmp(&stab_vp) {\n                                 Ordering::Less => {\n-                                    self.tcx.sess.struct_span_err(span, \"an API can't be stabilized after it is deprecated\")\n-                                        .span_label(span, \"invalid version\")\n-                                        .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                        .emit();\n+                                    self.tcx\n+                                        .sess\n+                                        .emit_err(CannotStabilizeDeprecated { span, item_sp });\n                                     break;\n                                 }\n                                 Ordering::Equal => continue,\n                                 Ordering::Greater => break,\n                             },\n                             Err(_) => {\n                                 if dep_v != \"TBD\" {\n-                                    self.tcx.sess.struct_span_err(span, \"invalid deprecation version found\")\n-                                        .span_label(span, \"invalid deprecation version\")\n-                                        .span_label(item_sp, \"the stability attribute annotates this item\")\n-                                        .emit();\n+                                    self.tcx\n+                                        .sess\n+                                        .emit_err(InvalidDeprecationVersion { span, item_sp });\n                                 }\n                                 break;\n                             }\n@@ -271,7 +262,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 }\n             }\n \n-            if let Stability { level: Unstable { implied_by: Some(implied_by), .. }, feature } = stab {\n+            if let Stability { level: Unstable { implied_by: Some(implied_by), .. }, feature } =\n+                stab\n+            {\n                 self.index.implications.insert(implied_by, feature);\n             }\n \n@@ -531,7 +524,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n         let stab = self.tcx.stability().local_stability(def_id);\n         if !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(def_id) {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", descr));\n+            self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n         }\n     }\n \n@@ -551,7 +544,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.span_err(span, &format!(\"{descr} has missing const stability attribute\"));\n+            self.tcx.sess.emit_err(MissingConstStabAttr { span, descr });\n         }\n     }\n }\n@@ -764,11 +757,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         && *constness == hir::Constness::Const\n                         && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n                     {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(item.span, \"trait implementations cannot be const stable yet\")\n-                            .note(\"see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\")\n-                            .emit();\n+                        self.tcx.sess.emit_err(TraitImplConstStable { span: item.span });\n                     }\n                 }\n \n@@ -929,26 +918,22 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n         }\n         if !lang_features.insert(feature) {\n             // Warn if the user enables a lang feature multiple times.\n-            duplicate_feature_err(tcx.sess, span, feature);\n+            tcx.sess.emit_err(DuplicateFeatureErr { span, feature });\n         }\n     }\n \n     let declared_lib_features = &tcx.features().declared_lib_features;\n     let mut remaining_lib_features = FxIndexMap::default();\n     for (feature, span) in declared_lib_features {\n         if !tcx.sess.opts.unstable_features.is_nightly_build() {\n-            struct_span_err!(\n-                tcx.sess,\n-                *span,\n-                E0554,\n-                \"`#![feature]` may not be used on the {} release channel\",\n-                env!(\"CFG_RELEASE_CHANNEL\")\n-            )\n-            .emit();\n+            tcx.sess.emit_err(FeatureOnlyOnNightly {\n+                span: *span,\n+                release_channel: env!(\"CFG_RELEASE_CHANNEL\"),\n+            });\n         }\n         if remaining_lib_features.contains_key(&feature) {\n             // Warn if the user enables a lib feature multiple times.\n-            duplicate_feature_err(tcx.sess, *span, *feature);\n+            tcx.sess.emit_err(DuplicateFeatureErr { span: *span, feature: *feature });\n         }\n         remaining_lib_features.insert(feature, *span);\n     }\n@@ -1049,23 +1034,18 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     }\n \n     for (feature, span) in remaining_lib_features {\n-        struct_span_err!(tcx.sess, span, E0635, \"unknown feature `{}`\", feature).emit();\n+        tcx.sess.emit_err(UnknownFeature { span, feature: *feature });\n     }\n \n     for (implied_by, feature) in remaining_implications {\n         let local_defined_features = tcx.lib_features(());\n-        let span = local_defined_features\n+        let span = *local_defined_features\n             .stable\n             .get(&feature)\n             .map(|(_, span)| span)\n             .or_else(|| local_defined_features.unstable.get(&feature))\n             .expect(\"feature that implied another does not exist\");\n-        tcx.sess\n-            .struct_span_err(\n-                *span,\n-                format!(\"feature `{implied_by}` implying `{feature}` does not exist\"),\n-            )\n-            .emit();\n+        tcx.sess.emit_err(ImpliedFeatureNotExist { span, feature, implied_by });\n     }\n \n     // FIXME(#44232): the `used_features` table no longer exists, so we\n@@ -1088,21 +1068,20 @@ fn unnecessary_partially_stable_feature_lint(\n              by the feature `{implies}`\"\n         ),\n         |lint| {\n-            lint\n-        .span_suggestion(\n-            span,\n-            &format!(\n+            lint.span_suggestion(\n+                span,\n+                &format!(\n                 \"if you are using features which are still unstable, change to using `{implies}`\"\n             ),\n-            implies,\n-            Applicability::MaybeIncorrect,\n-        )\n-        .span_suggestion(\n-            tcx.sess.source_map().span_extend_to_line(span),\n-            \"if you are using features which are now stable, remove this line\",\n-            \"\",\n-            Applicability::MaybeIncorrect,\n-        )\n+                implies,\n+                Applicability::MaybeIncorrect,\n+            )\n+            .span_suggestion(\n+                tcx.sess.source_map().span_extend_to_line(span),\n+                \"if you are using features which are now stable, remove this line\",\n+                \"\",\n+                Applicability::MaybeIncorrect,\n+            )\n         },\n     );\n }\n@@ -1120,20 +1099,3 @@ fn unnecessary_stable_feature_lint(\n         lint\n     });\n }\n-\n-fn duplicate_feature_err(sess: &Session, span: Span, feature: Symbol) {\n-    struct_span_err!(sess, span, E0636, \"the feature `{}` has already been declared\", feature)\n-        .emit();\n-}\n-\n-fn missing_const_err(session: &Session, fn_sig_span: Span, const_span: Span) {\n-    const ERROR_MSG: &'static str = \"attributes `#[rustc_const_unstable]` \\\n-         and `#[rustc_const_stable]` require \\\n-         the function or method to be `const`\";\n-\n-    session\n-        .struct_span_err(fn_sig_span, ERROR_MSG)\n-        .span_help(fn_sig_span, \"make the function or method const\")\n-        .span_label(const_span, \"attribute specified here\")\n-        .emit();\n-}"}, {"sha": "92024989a75e250b07226a86da559ec97602ce3c", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -1,13 +1,17 @@\n //! Validity checking for weak lang items\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n use rustc_hir::lang_items::{self, LangItem};\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::required;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n \n+use crate::errors::{\n+    AllocFuncRequired, MissingAllocErrorHandler, MissingLangItem, MissingPanicHandler,\n+    UnknownExternLangItem,\n+};\n+\n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItems) {\n@@ -31,14 +35,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n                 }\n             } else {\n                 let span = tcx.def_span(id.def_id);\n-                struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0264,\n-                    \"unknown external lang item: `{}`\",\n-                    lang_item\n-                )\n-                .emit();\n+                tcx.sess.emit_err(UnknownExternLangItem { span, lang_item });\n             }\n         }\n     }\n@@ -71,20 +68,14 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     for (name, &item) in WEAK_ITEMS_REFS.iter() {\n         if missing.contains(&item) && required(tcx, item) && items.require(item).is_err() {\n             if item == LangItem::PanicImpl {\n-                tcx.sess.err(\"`#[panic_handler]` function required, but not found\");\n+                tcx.sess.emit_err(MissingPanicHandler);\n             } else if item == LangItem::Oom {\n                 if !tcx.features().default_alloc_error_handler {\n-                    tcx.sess.err(\"`#[alloc_error_handler]` function required, but not found\");\n-                    tcx.sess.note_without_error(\"use `#![feature(default_alloc_error_handler)]` for a default error handler\");\n+                    tcx.sess.emit_err(AllocFuncRequired);\n+                    tcx.sess.emit_note(MissingAllocErrorHandler);\n                 }\n             } else {\n-                tcx\n-                    .sess\n-                    .diagnostic()\n-                    .struct_err(&format!(\"language item required, but not found: `{}`\", name))\n-                    .note(&format!(\"this can occur when a binary crate with `#![no_std]` is compiled for a target where `{}` is defined in the standard library\", name))\n-                    .help(&format!(\"you may be able to compile for a target that doesn't need `{}`, specify a target with `--target` or in `.cargo/config`\", name))\n-                    .emit();\n+                tcx.sess.emit_err(MissingLangItem { name: *name });\n             }\n         }\n     }"}, {"sha": "a199947ebed05c1791a2a7e237442898795d7323", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n     fallback_fluent_bundle, Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n-    EmissionGuarantee, ErrorGuaranteed, IntoDiagnostic, MultiSpan, StashKey,\n+    EmissionGuarantee, ErrorGuaranteed, IntoDiagnostic, MultiSpan, Noted, StashKey,\n };\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n use rustc_span::edition::Edition;\n@@ -354,6 +354,17 @@ impl ParseSess {\n         self.create_warning(warning).emit()\n     }\n \n+    pub fn create_note<'a>(\n+        &'a self,\n+        note: impl IntoDiagnostic<'a, Noted>,\n+    ) -> DiagnosticBuilder<'a, Noted> {\n+        note.into_diagnostic(&self.span_diagnostic)\n+    }\n+\n+    pub fn emit_note<'a>(&'a self, note: impl IntoDiagnostic<'a, Noted>) -> Noted {\n+        self.create_note(note).emit()\n+    }\n+\n     pub fn create_fatal<'a>(\n         &'a self,\n         fatal: impl IntoDiagnostic<'a, !>,"}, {"sha": "beb22ab3eb951a69e187126902eb6b33791689bf", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -28,7 +28,7 @@ use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n use rustc_errors::{\n     error_code, fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n-    ErrorGuaranteed, FluentBundle, IntoDiagnostic, LazyFallbackBundle, MultiSpan,\n+    ErrorGuaranteed, FluentBundle, IntoDiagnostic, LazyFallbackBundle, MultiSpan, Noted,\n };\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n@@ -489,6 +489,15 @@ impl Session {\n     pub fn emit_warning<'a>(&'a self, warning: impl IntoDiagnostic<'a, ()>) {\n         self.parse_sess.emit_warning(warning)\n     }\n+    pub fn create_note<'a>(\n+        &'a self,\n+        note: impl IntoDiagnostic<'a, Noted>,\n+    ) -> DiagnosticBuilder<'a, Noted> {\n+        self.parse_sess.create_note(note)\n+    }\n+    pub fn emit_note<'a>(&'a self, note: impl IntoDiagnostic<'a, Noted>) -> Noted {\n+        self.parse_sess.emit_note(note)\n+    }\n     pub fn create_fatal<'a>(\n         &'a self,\n         fatal: impl IntoDiagnostic<'a, !>,"}, {"sha": "9c6a419e9f72d85c5969e1a350ca95dae248fa16", "filename": "src/test/ui/associated-types/issue-85103.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.rs?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -4,6 +4,6 @@ use std::borrow::Cow;\n \n #[rustc_layout(debug)]\n type Edges<'a, E> = Cow<'a, [E]>;\n-//~^ ERROR layout error: NormalizationFailure\n+//~^ 6:1: 6:18: unable to determine layout for `<[E] as ToOwned>::Owned` because `<[E] as ToOwned>::Owned` cannot be normalized\n \n fn main() {}"}, {"sha": "17f7148074cf3fc01d757b5c44bfdeabe6eda2fd", "filename": "src/test/ui/associated-types/issue-85103.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32471a7035b4d8ba2b1fb3caae5f8203f47e4391/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-85103.stderr?ref=32471a7035b4d8ba2b1fb3caae5f8203f47e4391", "patch": "@@ -1,4 +1,4 @@\n-error: layout error: NormalizationFailure(<[E] as std::borrow::ToOwned>::Owned, Type(<[E] as std::borrow::ToOwned>::Owned))\n+error: unable to determine layout for `<[E] as ToOwned>::Owned` because `<[E] as ToOwned>::Owned` cannot be normalized\n   --> $DIR/issue-85103.rs:6:1\n    |\n LL | type Edges<'a, E> = Cow<'a, [E]>;"}]}