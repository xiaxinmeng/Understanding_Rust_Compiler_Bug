{"sha": "4a4e5f3897562c4c622981b61779d3f78e786e5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNGU1ZjM4OTc1NjJjNGM2MjI5ODFiNjE3NzlkM2Y3OGU3ODZlNWQ=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-15T09:30:44Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-20T10:00:43Z"}, "message": "hir: add and use hir_to_node_id in NodeCollector", "tree": {"sha": "ee6c95986d11643ba040dcc292996282f2fb0d1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee6c95986d11643ba040dcc292996282f2fb0d1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a4e5f3897562c4c622981b61779d3f78e786e5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4e5f3897562c4c622981b61779d3f78e786e5d", "html_url": "https://github.com/rust-lang/rust/commit/4a4e5f3897562c4c622981b61779d3f78e786e5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a4e5f3897562c4c622981b61779d3f78e786e5d/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6536dbb640232f4f61fd7c6b4b129b7564cefff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6536dbb640232f4f61fd7c6b4b129b7564cefff2", "html_url": "https://github.com/rust-lang/rust/commit/6536dbb640232f4f61fd7c6b4b129b7564cefff2"}], "stats": {"total": 66, "additions": 34, "deletions": 32}, "files": [{"sha": "85669c00fe74383399506606d83cbdf851b74d8e", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e5f3897562c4c622981b61779d3f78e786e5d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e5f3897562c4c622981b61779d3f78e786e5d/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=4a4e5f3897562c4c622981b61779d3f78e786e5d", "patch": "@@ -40,6 +40,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n \n     dep_graph: &'a DepGraph,\n     definitions: &'a definitions::Definitions,\n+    hir_to_node_id: &'a FxHashMap<HirId, NodeId>,\n \n     hcx: StableHashingContext<'a>,\n \n@@ -100,6 +101,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                        krate: &'hir Crate,\n                        dep_graph: &'a DepGraph,\n                        definitions: &'a definitions::Definitions,\n+                       hir_to_node_id: &'a FxHashMap<HirId, NodeId>,\n                        mut hcx: StableHashingContext<'a>)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n@@ -155,6 +157,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             currently_in_body: false,\n             dep_graph,\n             definitions,\n+            hir_to_node_id,\n             hcx,\n             hir_body_nodes,\n         };\n@@ -228,8 +231,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.map[id.as_usize()] = Some(entry);\n     }\n \n-    // FIXME(ljedrz): devise a way to get rid of this NodeId\n-    fn insert(&mut self, span: Span, node_id: NodeId, hir_id: HirId, node: Node<'hir>) {\n+    fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n         let entry = Entry {\n             parent: self.parent_node,\n             parent_hir: self.parent_hir,\n@@ -241,6 +243,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             node,\n         };\n \n+        let node_id = self.hir_to_node_id[&hir_id];\n+\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n@@ -361,13 +365,12 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n         self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n-            this.insert(i.span, i.id, i.hir_id, Node::Item(i));\n+            this.insert(i.span, i.hir_id, Node::Item(i));\n             this.with_parent(i.id, i.hir_id, |this| {\n                 if let ItemKind::Struct(ref struct_def, _) = i.node {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n-                        this.insert(i.span, struct_def.id(), struct_def.hir_id(),\n-                            Node::StructCtor(struct_def));\n+                        this.insert(i.span, struct_def.hir_id(), Node::StructCtor(struct_def));\n                     }\n                 }\n                 intravisit::walk_item(this, i);\n@@ -376,24 +379,23 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'hir ForeignItem) {\n-        self.insert(foreign_item.span, foreign_item.id, foreign_item.hir_id,\n-            Node::ForeignItem(foreign_item));\n+        self.insert(foreign_item.span, foreign_item.hir_id, Node::ForeignItem(foreign_item));\n \n         self.with_parent(foreign_item.id, foreign_item.hir_id, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n         });\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n-        self.insert(param.span, param.id, param.hir_id, Node::GenericParam(param));\n+        self.insert(param.span, param.hir_id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n-            this.insert(ti.span, ti.id, ti.hir_id, Node::TraitItem(ti));\n+            this.insert(ti.span, ti.hir_id, Node::TraitItem(ti));\n \n             this.with_parent(ti.id, ti.hir_id, |this| {\n                 intravisit::walk_trait_item(this, ti);\n@@ -405,7 +407,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n-            this.insert(ii.span, ii.id, ii.hir_id, Node::ImplItem(ii));\n+            this.insert(ii.span, ii.hir_id, Node::ImplItem(ii));\n \n             this.with_parent(ii.id, ii.hir_id, |this| {\n                 intravisit::walk_impl_item(this, ii);\n@@ -419,55 +421,55 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         } else {\n             Node::Pat(pat)\n         };\n-        self.insert(pat.span, pat.id, pat.hir_id, node);\n+        self.insert(pat.span, pat.hir_id, node);\n \n         self.with_parent(pat.id, pat.hir_id, |this| {\n             intravisit::walk_pat(this, pat);\n         });\n     }\n \n     fn visit_anon_const(&mut self, constant: &'hir AnonConst) {\n-        self.insert(DUMMY_SP, constant.id, constant.hir_id, Node::AnonConst(constant));\n+        self.insert(DUMMY_SP, constant.hir_id, Node::AnonConst(constant));\n \n         self.with_parent(constant.id, constant.hir_id, |this| {\n             intravisit::walk_anon_const(this, constant);\n         });\n     }\n \n     fn visit_expr(&mut self, expr: &'hir Expr) {\n-        self.insert(expr.span, expr.id, expr.hir_id, Node::Expr(expr));\n+        self.insert(expr.span, expr.hir_id, Node::Expr(expr));\n \n         self.with_parent(expr.id, expr.hir_id, |this| {\n             intravisit::walk_expr(this, expr);\n         });\n     }\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n-        self.insert(stmt.span, stmt.id, stmt.hir_id, Node::Stmt(stmt));\n+        self.insert(stmt.span, stmt.hir_id, Node::Stmt(stmt));\n \n         self.with_parent(stmt.id, stmt.hir_id, |this| {\n             intravisit::walk_stmt(this, stmt);\n         });\n     }\n \n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment) {\n-        if let Some(node_id) = path_segment.id {\n+        if path_segment.id.is_some() {\n             let hir_id = path_segment.hir_id.unwrap();\n-            self.insert(path_span, node_id, hir_id, Node::PathSegment(path_segment));\n+            self.insert(path_span, hir_id, Node::PathSegment(path_segment));\n         }\n         intravisit::walk_path_segment(self, path_span, path_segment);\n     }\n \n     fn visit_ty(&mut self, ty: &'hir Ty) {\n-        self.insert(ty.span, ty.id, ty.hir_id, Node::Ty(ty));\n+        self.insert(ty.span, ty.hir_id, Node::Ty(ty));\n \n         self.with_parent(ty.id, ty.hir_id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n-        self.insert(tr.path.span, tr.ref_id, tr.hir_ref_id, Node::TraitRef(tr));\n+        self.insert(tr.path.span, tr.hir_ref_id, Node::TraitRef(tr));\n \n         self.with_parent(tr.ref_id, tr.hir_ref_id, |this| {\n             intravisit::walk_trait_ref(this, tr);\n@@ -481,21 +483,21 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_block(&mut self, block: &'hir Block) {\n-        self.insert(block.span, block.id, block.hir_id, Node::Block(block));\n+        self.insert(block.span, block.hir_id, Node::Block(block));\n         self.with_parent(block.id, block.hir_id, |this| {\n             intravisit::walk_block(this, block);\n         });\n     }\n \n     fn visit_local(&mut self, l: &'hir Local) {\n-        self.insert(l.span, l.id, l.hir_id, Node::Local(l));\n+        self.insert(l.span, l.hir_id, Node::Local(l));\n         self.with_parent(l.id, l.hir_id, |this| {\n             intravisit::walk_local(this, l)\n         })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n-        self.insert(lifetime.span, lifetime.id, lifetime.hir_id, Node::Lifetime(lifetime));\n+        self.insert(lifetime.span, lifetime.hir_id, Node::Lifetime(lifetime));\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n@@ -504,7 +506,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             VisibilityKind::Crate(_) |\n             VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { id, hir_id, .. } => {\n-                self.insert(visibility.span, id, hir_id, Node::Visibility(visibility));\n+                self.insert(visibility.span, hir_id, Node::Visibility(visibility));\n                 self.with_parent(id, hir_id, |this| {\n                     intravisit::walk_vis(this, visibility);\n                 });\n@@ -516,19 +518,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n-            this.insert(macro_def.span, macro_def.id, macro_def.hir_id, Node::MacroDef(macro_def));\n+            this.insert(macro_def.span, macro_def.hir_id, Node::MacroDef(macro_def));\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n-        self.insert(v.span, v.node.data.id(), v.node.data.hir_id(), Node::Variant(v));\n+        self.insert(v.span, v.node.data.hir_id(), Node::Variant(v));\n         self.with_parent(v.node.data.id(), v.node.data.hir_id(), |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, field: &'hir StructField) {\n-        self.insert(field.span, field.id, field.hir_id, Node::Field(field));\n+        self.insert(field.span, field.hir_id, Node::Field(field));\n         self.with_parent(field.id, field.hir_id, |this| {\n             intravisit::walk_struct_field(this, field);\n         });"}, {"sha": "39203208855e0341ac3e103fad046f741ab23115", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a4e5f3897562c4c622981b61779d3f78e786e5d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4e5f3897562c4c622981b61779d3f78e786e5d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4a4e5f3897562c4c622981b61779d3f78e786e5d", "patch": "@@ -11,7 +11,6 @@ use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::join;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n@@ -1242,13 +1241,18 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        forest: &'hir Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n-    let ((map, crate_hash), hir_to_node_id) = join(|| {\n+    // Build the reverse mapping of `node_to_hir_id`.\n+    let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n+        .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n+\n+    let (map, crate_hash) = {\n         let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n \n         let mut collector = NodeCollector::root(sess,\n                                                 &forest.krate,\n                                                 &forest.dep_graph,\n                                                 &definitions,\n+                                                &hir_to_node_id,\n                                                 hcx);\n         intravisit::walk_crate(&mut collector, &forest.krate);\n \n@@ -1259,11 +1263,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n             cstore,\n             cmdline_args\n         )\n-    }, || {\n-        // Build the reverse mapping of `node_to_hir_id`.\n-        definitions.node_to_hir_id.iter_enumerated()\n-                    .map(|(node_id, &hir_id)| (hir_id, node_id)).collect()\n-    });\n+    };\n \n     if log_enabled!(::log::Level::Debug) {\n         // This only makes sense for ordered stores; note the"}]}