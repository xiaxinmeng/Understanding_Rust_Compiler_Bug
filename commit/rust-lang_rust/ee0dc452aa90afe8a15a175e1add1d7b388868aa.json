{"sha": "ee0dc452aa90afe8a15a175e1add1d7b388868aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMGRjNDUyYWE5MGFmZThhMTVhMTc1ZTFhZGQxZDdiMzg4ODY4YWE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-11T01:03:12Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-11T01:03:12Z"}, "message": "Move binop functions to operator module.", "tree": {"sha": "21c46dfd1b47b50894f53dec1ae189772c270215", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21c46dfd1b47b50894f53dec1ae189772c270215"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee0dc452aa90afe8a15a175e1add1d7b388868aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0dc452aa90afe8a15a175e1add1d7b388868aa", "html_url": "https://github.com/rust-lang/rust/commit/ee0dc452aa90afe8a15a175e1add1d7b388868aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee0dc452aa90afe8a15a175e1add1d7b388868aa/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0013b2ae48cb8918f4837b9ed6f7101afeecf75", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0013b2ae48cb8918f4837b9ed6f7101afeecf75", "html_url": "https://github.com/rust-lang/rust/commit/e0013b2ae48cb8918f4837b9ed6f7101afeecf75"}], "stats": {"total": 96, "additions": 51, "deletions": 45}, "files": [{"sha": "713c01602c786b58355e65f7b0c1428deb7c74a4", "filename": "src/eval_context.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ee0dc452aa90afe8a15a175e1add1d7b388868aa/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0dc452aa90afe8a15a175e1add1d7b388868aa/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=ee0dc452aa90afe8a15a175e1add1d7b388868aa", "patch": "@@ -359,51 +359,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn binop_with_overflow(\n-        &mut self,\n-        op: mir::BinOp,\n-        left: &mir::Operand<'tcx>,\n-        right: &mir::Operand<'tcx>,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        let left_ty    = self.operand_ty(left);\n-        let right_ty   = self.operand_ty(right);\n-        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n-        let left_val   = self.eval_operand_to_primval(left)?;\n-        let right_val  = self.eval_operand_to_primval(right)?;\n-        operator::binary_op(op, left_val, left_kind, right_val, right_kind)\n-    }\n-\n-    /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n-    /// and a boolean signifying the potential overflow to the destination.\n-    pub(super) fn intrinsic_with_overflow(\n-        &mut self,\n-        op: mir::BinOp,\n-        left: &mir::Operand<'tcx>,\n-        right: &mir::Operand<'tcx>,\n-        dest: Lvalue<'tcx>,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ()> {\n-        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        let val = Value::ByValPair(val, PrimVal::from_bool(overflowed));\n-        self.write_value(val, dest, dest_ty)\n-    }\n-\n-    /// Applies the binary operation `op` to the arguments and writes the result to the\n-    /// destination. Returns `true` if the operation overflowed.\n-    pub(super) fn intrinsic_overflowing(\n-        &mut self,\n-        op: mir::BinOp,\n-        left: &mir::Operand<'tcx>,\n-        right: &mir::Operand<'tcx>,\n-        dest: Lvalue<'tcx>,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        self.write_primval(dest, val, dest_ty)?;\n-        Ok(overflowed)\n-    }\n-\n     fn assign_fields<I: IntoIterator<Item = u64>>(\n         &mut self,\n         dest: Lvalue<'tcx>,"}, {"sha": "6e656d69f6558076f34105b2e594a1216b713949", "filename": "src/operator.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ee0dc452aa90afe8a15a175e1add1d7b388868aa/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0dc452aa90afe8a15a175e1add1d7b388868aa/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=ee0dc452aa90afe8a15a175e1add1d7b388868aa", "patch": "@@ -1,17 +1,68 @@\n use rustc::mir;\n+use rustc::ty::Ty;\n \n use error::{EvalError, EvalResult};\n+use eval_context::EvalContext;\n+use lvalue::Lvalue;\n use memory::Pointer;\n use value::{\n     PrimVal,\n     PrimValKind,\n+    Value,\n     bits_to_f32,\n     bits_to_f64,\n     f32_to_bits,\n     f64_to_bits,\n     bits_to_bool,\n };\n \n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    fn binop_with_overflow(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        let left_ty    = self.operand_ty(left);\n+        let right_ty   = self.operand_ty(right);\n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        let left_val   = self.eval_operand_to_primval(left)?;\n+        let right_val  = self.eval_operand_to_primval(right)?;\n+        binary_op(op, left_val, left_kind, right_val, right_kind)\n+    }\n+\n+    /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n+    /// and a boolean signifying the potential overflow to the destination.\n+    pub(super) fn intrinsic_with_overflow(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, ()> {\n+        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n+        let val = Value::ByValPair(val, PrimVal::from_bool(overflowed));\n+        self.write_value(val, dest, dest_ty)\n+    }\n+\n+    /// Applies the binary operation `op` to the arguments and writes the result to the\n+    /// destination. Returns `true` if the operation overflowed.\n+    pub(super) fn intrinsic_overflowing(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n+        self.write_primval(dest, val, dest_ty)?;\n+        Ok(overflowed)\n+    }\n+}\n+\n macro_rules! overflow {\n     ($op:ident, $l:expr, $r:expr) => ({\n         let (val, overflowed) = $l.$op($r);"}]}