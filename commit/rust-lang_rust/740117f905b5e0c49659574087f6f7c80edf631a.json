{"sha": "740117f905b5e0c49659574087f6f7c80edf631a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MDExN2Y5MDViNWUwYzQ5NjU5NTc0MDg3ZjZmN2M4MGVkZjYzMWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-31T16:10:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-31T16:10:49Z"}, "message": "fix bug in NLL error reporting\n\nAccount for incompatible universes and higher-ranked subtyping.", "tree": {"sha": "f29e8f3a529de4f7c9e521a9f8a11ebcf38fa966", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f29e8f3a529de4f7c9e521a9f8a11ebcf38fa966"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/740117f905b5e0c49659574087f6f7c80edf631a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/740117f905b5e0c49659574087f6f7c80edf631a", "html_url": "https://github.com/rust-lang/rust/commit/740117f905b5e0c49659574087f6f7c80edf631a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/740117f905b5e0c49659574087f6f7c80edf631a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9", "html_url": "https://github.com/rust-lang/rust/commit/a1be20c9ce4e5cf934f055e0dc6776ff8382f8e9"}], "stats": {"total": 119, "additions": 111, "deletions": 8}, "files": [{"sha": "9f1af50a6d5cf50a5760ebeeb1408e96da564c79", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=740117f905b5e0c49659574087f6f7c80edf631a", "patch": "@@ -1522,10 +1522,17 @@ impl UniverseIndex {\n \n     /// True if `self` can name a name from `other` -- in other words,\n     /// if the set of names in `self` is a superset of those in\n-    /// `other`.\n+    /// `other` (`self >= other`).\n     pub fn can_name(self, other: UniverseIndex) -> bool {\n         self.private >= other.private\n     }\n+\n+    /// True if `self` cannot name some names from `other` -- in other\n+    /// words, if the set of names in `self` is a strict subset of\n+    /// those in `other` (`self < other`).\n+    pub fn cannot_name(self, other: UniverseIndex) -> bool {\n+        self.private < other.private\n+    }\n }\n \n /// The \"placeholder index\" fully defines a placeholder region."}, {"sha": "3358e5851f939d10c7da2d079c8ee0fc92839f47", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=740117f905b5e0c49659574087f6f7c80edf631a", "patch": "@@ -16,6 +16,7 @@ use borrow_check::nll::ConstraintDescription;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n+use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{ConstraintCategory, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -177,6 +178,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         deque.push_back(from_region);\n \n         while let Some(r) = deque.pop_front() {\n+            debug!(\n+                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n+                from_region,\n+                r,\n+                self.region_value_str(r),\n+            );\n+\n             // Check if we reached the region we were looking for. If so,\n             // we can reconstruct the path that led to it and return it.\n             if target_test(r) {\n@@ -238,7 +246,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(mir, fr, |r| r == outlived_fr);\n+        let (category, _, span) = self.best_blame_constraint(mir, fr, |r| {\n+            self.provides_universal_region(r, fr, outlived_fr)\n+        });\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n@@ -296,6 +306,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n     }\n \n+    /// We have a constraint `fr1: fr2` that is not satisfied, where\n+    /// `fr2` represents some universal region. Here, `r` is some\n+    /// region where we know that `fr1: r` and this function has the\n+    /// job of determining whether `r` is \"to blame\" for the fact that\n+    /// `fr1: fr2` is required.\n+    ///\n+    /// This is true under two conditions:\n+    ///\n+    /// - `r == fr2`\n+    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n+    ///   that cannot be named by `fr1`; in that case, we will require\n+    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n+    ///   be satisfied. (See `add_incompatible_universe`.)\n+    fn provides_universal_region(&self, r: RegionVid, fr1: RegionVid, fr2: RegionVid) -> bool {\n+        debug!(\n+            \"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\",\n+            r, fr1, fr2\n+        );\n+        let result = {\n+            r == fr2 || {\n+                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n+            }\n+        };\n+        debug!(\"provides_universal_region: result = {:?}\", result);\n+        result\n+    }\n+\n     /// Report a specialized error when `FnMut` closures return a reference to a captured variable.\n     /// This function expects `fr` to be local and `outlived_fr` to not be local.\n     ///\n@@ -636,11 +673,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     // `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n-        // Find all paths\n-        let (_path, r) = self.find_constraint_paths_between_regions(fr1, |r| {\n+        self.find_constraint_paths_between_regions(fr1, |r| {\n+            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n+            debug!(\n+                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n+                r,\n+                self.liveness_constraints.region_value_str(r),\n+            );\n             self.liveness_constraints.contains(r, elem)\n-        }).unwrap();\n-        r\n+        }).or_else(|| {\n+                // If we fail to find that, we may find some `r` such that\n+                // `fr1: r` and `r` is a placeholder from some universe\n+                // `fr1` cannot name. This would force `fr1` to be\n+                // `'static`.\n+                self.find_constraint_paths_between_regions(fr1, |r| {\n+                    self.cannot_name_placeholder(fr1, r)\n+                })\n+            })\n+            .or_else(|| {\n+                // If we fail to find THAT, it may be that `fr1` is a\n+                // placeholder that cannot \"fit\" into its SCC. In that\n+                // case, there should be some `r` where `fr1: r`, both\n+                // `fr1` and `r` are in the same SCC, and `fr1` is a\n+                // placeholder that `r` cannot name. We can blame that\n+                // edge.\n+                self.find_constraint_paths_between_regions(fr1, |r| {\n+                    self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n+                        && self.cannot_name_placeholder(r, fr1)\n+                })\n+            })\n+            .map(|(_path, r)| r)\n+            .unwrap()\n     }\n \n     // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n@@ -650,7 +713,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n+        let (category, _, span) =\n+            self.best_blame_constraint(mir, fr1, |r| self.provides_universal_region(r, fr1, fr2));\n         (category, span)\n     }\n \n@@ -684,4 +748,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         false\n     }\n+\n+    /// If `r2` represents a placeholder region, then this returns\n+    /// true if `r1` cannot name that placeholder in its\n+    /// value. Otherwise, returns false.\n+    fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n+\n+        match self.definitions[r2].origin {\n+            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                let universe1 = self.definitions[r1].universe;\n+                debug!(\n+                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n+                    universe1, placeholder\n+                );\n+                universe1.cannot_name(placeholder.universe)\n+            }\n+\n+            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential => false,\n+        }\n+    }\n }"}, {"sha": "376f445924270b2bd130dae6f0a26cc50e3b998f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=740117f905b5e0c49659574087f6f7c80edf631a", "patch": "@@ -345,6 +345,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     if scc_universe.can_name(placeholder.universe) {\n                         self.scc_values.add_element(scc, placeholder);\n                     } else {\n+                        debug!(\n+                            \"init_free_and_bound_regions: placeholder {:?} is \\\n+                             not compatible with universe {:?} of its SCC {:?}\",\n+                            placeholder,\n+                            scc_universe,\n+                            scc,\n+                        );\n                         self.add_incompatible_universe(scc);\n                     }\n                 }\n@@ -471,6 +478,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n             constraints.sort();\n             constraints\n+                .into_iter()\n+                .map(|c| (c, self.constraint_sccs.scc(c.sup), self.constraint_sccs.scc(c.sub)))\n+                .collect::<Vec<_>>()\n         });\n \n         // To propagate constraints, we walk the DAG induced by the\n@@ -560,6 +570,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `'a` with `'b` and not `'static`. But it will have to do for\n     /// now.\n     fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {\n+        debug!(\"add_incompatible_universe(scc={:?})\", scc);\n+\n         let fr_static = self.universal_regions.fr_static;\n         self.scc_values.add_all_points(scc);\n         self.scc_values.add_element(scc, fr_static);"}, {"sha": "8ef810bba9cd6c53b74118d530a868b8f2fee089", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/740117f905b5e0c49659574087f6f7c80edf631a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=740117f905b5e0c49659574087f6f7c80edf631a", "patch": "@@ -782,7 +782,7 @@ impl MirTypeckRegionConstraints<'tcx> {\n             Some(&v) => v,\n             None => {\n                 let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n-                let region = infcx.next_nll_region_var(origin);\n+                let region = infcx.next_nll_region_var_in_universe(origin, placeholder.universe);\n                 self.placeholder_index_to_region.push(region);\n                 region\n             }"}]}