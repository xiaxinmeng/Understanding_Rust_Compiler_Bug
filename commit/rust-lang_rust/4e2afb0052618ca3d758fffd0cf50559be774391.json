{"sha": "4e2afb0052618ca3d758fffd0cf50559be774391", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMmFmYjAwNTI2MThjYTNkNzU4ZmZmZDBjZjUwNTU5YmU3NzQzOTE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-18T22:47:48Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-30T00:06:25Z"}, "message": "Remove ExprSlice by hacking the compiler\n\n[breaking-change]\n\nThe `mut` in slices is now redundant. Mutability is 'inferred' from position. This means that if mutability is only obvious from the type, you will need to use explicit calls to the slicing methods.", "tree": {"sha": "1d15ea3b8b2c53b1e8f1599578325af3840edc04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d15ea3b8b2c53b1e8f1599578325af3840edc04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e2afb0052618ca3d758fffd0cf50559be774391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2afb0052618ca3d758fffd0cf50559be774391", "html_url": "https://github.com/rust-lang/rust/commit/4e2afb0052618ca3d758fffd0cf50559be774391", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e2afb0052618ca3d758fffd0cf50559be774391/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed8f5039115308ca9d5591126e4d8a77864d4730", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed8f5039115308ca9d5591126e4d8a77864d4730", "html_url": "https://github.com/rust-lang/rust/commit/ed8f5039115308ca9d5591126e4d8a77864d4730"}], "stats": {"total": 573, "additions": 254, "deletions": 319}, "files": [{"sha": "3830a7eb9f6ac6303361679a9c1f105009154f11", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -990,7 +990,7 @@ impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T)\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail[mut 1..];\n+                self.v = tail.slice_from_mut(1);\n                 Some(head)\n             }\n         }\n@@ -1026,7 +1026,7 @@ impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail[mut 1..])\n+                Some(tail.slice_from_mut(1))\n             }\n         }\n     }"}, {"sha": "92aa70548c82bdd4d4dc3e5f8838d416fb88de4b", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -432,13 +432,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n-            ast::ExprSlice(ref base, ref start, ref end, _) => {\n-                self.call(expr,\n-                          pred,\n-                          &**base,\n-                          start.iter().chain(end.iter()).map(|x| &**x))\n-            }\n-\n             ast::ExprRange(ref start, ref end) => {\n                 let fields = start.as_ref().map(|e| &**e).into_iter()\n                     .chain(end.as_ref().map(|e| &**e).into_iter());"}, {"sha": "b7cfb22b85f8ce9812c6462a3f3957ac9c427153", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -431,24 +431,31 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], PassArgs::ByRef) {\n-                    self.select_from_expr(&**lhs);\n-                    self.consume_expr(&**rhs);\n+                match rhs.node {\n+                    ast::ExprRange(ref start, ref end) => {\n+                        // Hacked slicing syntax (KILLME).\n+                        let args = match (start, end) {\n+                            (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n+                            (&Some(ref e), &None) => vec![&**e],\n+                            (&None, &Some(ref e)) => vec![&**e],\n+                            (&None, &None) => Vec::new()\n+                        };\n+                        let overloaded =\n+                            self.walk_overloaded_operator(expr, &**lhs, args, PassArgs::ByRef);\n+                        assert!(overloaded);\n+                    }\n+                    _ => {\n+                        if !self.walk_overloaded_operator(expr,\n+                                                          &**lhs,\n+                                                          vec![&**rhs],\n+                                                          PassArgs::ByRef) {\n+                            self.select_from_expr(&**lhs);\n+                            self.consume_expr(&**rhs);\n+                        }\n+                    }\n                 }\n             }\n \n-            ast::ExprSlice(ref base, ref start, ref end, _) => {    // base[start..end]\n-                let args = match (start, end) {\n-                    (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n-                    (&Some(ref e), &None) => vec![&**e],\n-                    (&None, &Some(ref e)) => vec![&**e],\n-                    (&None, &None) => Vec::new()\n-                };\n-                let overloaded =\n-                    self.walk_overloaded_operator(expr, &**base, args, PassArgs::ByRef);\n-                assert!(overloaded);\n-            }\n-\n             ast::ExprRange(ref start, ref end) => {\n                 start.as_ref().map(|e| self.consume_expr(&**e));\n                 end.as_ref().map(|e| self.consume_expr(&**e));"}, {"sha": "d3859ca12a9711930b26f2dcaac566daf6eafabb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -514,7 +514,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n       ast::ExprMac(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n       ast::ExprParen(..) | ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-      ast::ExprSlice(..) | ast::ExprRange(..) => {\n+      ast::ExprRange(..) => {\n           visit::walk_expr(ir, expr);\n       }\n     }\n@@ -1191,12 +1191,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**l, r_succ)\n           }\n \n-          ast::ExprSlice(ref e1, ref e2, ref e3, _) => {\n-            let succ = e3.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n-            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n-            self.propagate_through_expr(&**e1, succ)\n-          }\n-\n           ast::ExprRange(ref e1, ref e2) => {\n             let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n             e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ))\n@@ -1495,7 +1489,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n       ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) |\n-      ast::ExprSlice(..) | ast::ExprRange(..) => {\n+      ast::ExprRange(..) => {\n         visit::walk_expr(this, expr);\n       }\n       ast::ExprIfLet(..) => {"}, {"sha": "b48e41ceb735874eae42efd438e4b1bd2cfcf0a9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -500,21 +500,29 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             self.cat_tup_field(expr, base_cmt, idx.node, expr_ty)\n           }\n \n-          ast::ExprIndex(ref base, _) => {\n-            let method_call = ty::MethodCall::expr(expr.id());\n-            match self.typer.node_method_ty(method_call) {\n-                Some(method_ty) => {\n-                    // If this is an index implemented by a method call, then it will\n-                    // include an implicit deref of the result.\n-                    let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n-                    self.cat_deref(expr,\n-                                   self.cat_rvalue_node(expr.id(),\n-                                                        expr.span(),\n-                                                        ret_ty), 1, true)\n+          ast::ExprIndex(ref base, ref idx) => {\n+            match idx.node {\n+                ast::ExprRange(..) => {\n+                    // Slicing syntax special case (KILLME).\n+                    self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                 }\n-                None => {\n-                    let base_cmt = self.cat_expr(&**base);\n-                    self.cat_index(expr, base_cmt)\n+                _ => {\n+                    let method_call = ty::MethodCall::expr(expr.id());\n+                    match self.typer.node_method_ty(method_call) {\n+                        Some(method_ty) => {\n+                            // If this is an index implemented by a method call, then it will\n+                            // include an implicit deref of the result.\n+                            let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                            self.cat_deref(expr,\n+                                           self.cat_rvalue_node(expr.id(),\n+                                                                expr.span(),\n+                                                                ret_ty), 1, true)\n+                        }\n+                        None => {\n+                            let base_cmt = if_ok!(self.cat_expr(&**base));\n+                            self.cat_index(expr, base_cmt)\n+                        }\n+                    }\n                 }\n             }\n           }\n@@ -531,7 +539,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n           ast::ExprClosure(..) | ast::ExprRet(..) |\n-          ast::ExprUnary(..) | ast::ExprSlice(..) | ast::ExprRange(..) |\n+          ast::ExprUnary(..) | ast::ExprRange(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |"}, {"sha": "232646f64a7d1f720945c977623754b7d3f48366", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -4322,9 +4322,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the index method invoked for `a[i]` always yields an `&T`\n             ast::ExprIndex(..) => LvalueExpr,\n \n-            // the slice method invoked for `a[..]` always yields an `&T`\n-            ast::ExprSlice(..) => LvalueExpr,\n-\n             // `for` loops are statements\n             ast::ExprForLoop(..) => RvalueStmtExpr,\n \n@@ -4389,8 +4386,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprUnary(ast::UnDeref, _) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n-        ast::ExprIndex(..) |\n-        ast::ExprSlice(..) => {\n+        ast::ExprIndex(..) => {\n             LvalueExpr\n         }\n "}, {"sha": "2374e8b340be770f28baffa6f184399448eaac70", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -246,7 +246,6 @@ mod svh_visitor {\n         SawExprAssign,\n         SawExprAssignOp(ast::BinOp),\n         SawExprIndex,\n-        SawExprSlice,\n         SawExprRange,\n         SawExprPath,\n         SawExprAddrOf(ast::Mutability),\n@@ -280,7 +279,6 @@ mod svh_visitor {\n             ExprField(_, id)         => SawExprField(content(id.node)),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n-            ExprSlice(..)            => SawExprSlice,\n             ExprRange(..)            => SawExprRange,\n             ExprPath(..)             => SawExprPath,\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),"}, {"sha": "f96aa484ffc9516887b348406138d1bbf07c7f01", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -24,7 +24,8 @@ use trans::common;\n use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n use trans::debuginfo;\n use trans::glue;\n-use middle::region;\n+// Temporary due to slicing syntax hacks (KILLME)\n+//use middle::region;\n use trans::type_::Type;\n use middle::ty::{mod, Ty};\n use std::fmt;\n@@ -128,15 +129,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // excluding id's that correspond to closure bodies only). For\n         // now we just say that if there is already an AST scope on the stack,\n         // this new AST scope had better be its immediate child.\n-        let top_scope = self.top_ast_scope();\n+        // Temporarily removed due to slicing syntax hacks (KILLME).\n+        /*let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n             assert_eq!(self.ccx\n                            .tcx()\n                            .region_maps\n                            .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n                            .map(|s|s.node_id()),\n                        top_scope);\n-        }\n+        }*/\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n                                           Some(debug_loc)));"}, {"sha": "56c42c7afdeb8bfd956c2c50f0cc44398cb72d08", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -3533,18 +3533,12 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-            ast::ExprIndex(ref lhs, ref rhs)        |\n+            ast::ExprIndex(ref lhs, ref rhs) |\n             ast::ExprBinary(_, ref lhs, ref rhs)    => {\n                 walk_expr(cx, &**lhs, scope_stack, scope_map);\n                 walk_expr(cx, &**rhs, scope_stack, scope_map);\n             }\n \n-            ast::ExprSlice(ref base, ref start, ref end, _) => {\n-                walk_expr(cx, &**base, scope_stack, scope_map);\n-                start.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n-                end.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n-            }\n-\n             ast::ExprRange(ref start, ref end) => {\n                 start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n                 end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));"}, {"sha": "c88a1b5e187363b361a2f3ddef7360db78f7ff64", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -585,36 +585,40 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_rec_tup_field(bcx, &**base, idx.node)\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n-            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n-        }\n-        ast::ExprSlice(ref base, ref start, ref end, _) => {\n-            let _icx = push_ctxt(\"trans_slice\");\n-            let ccx = bcx.ccx();\n-\n-            let method_call = MethodCall::expr(expr.id);\n-            let method_ty = ccx.tcx()\n-                               .method_map\n-                               .borrow()\n-                               .get(&method_call)\n-                               .map(|method| method.ty);\n-            let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n-\n-            let mut args = vec![];\n-            start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n-            end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n-\n-            let result_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty.unwrap())).unwrap();\n-            let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n-\n-            unpack_result!(bcx,\n-                           trans_overloaded_op(bcx,\n-                                               expr,\n-                                               method_call,\n-                                               base_datum,\n-                                               args,\n-                                               Some(SaveIn(scratch.val)),\n-                                               true));\n-            DatumBlock::new(bcx, scratch.to_expr_datum())\n+            match idx.node {\n+                ast::ExprRange(ref start, ref end) => {\n+                    // Special case for slicing syntax (KILLME).\n+                    let _icx = push_ctxt(\"trans_slice\");\n+                    let ccx = bcx.ccx();\n+\n+                    let method_call = MethodCall::expr(expr.id);\n+                    let method_ty = ccx.tcx()\n+                                       .method_map\n+                                       .borrow()\n+                                       .get(&method_call)\n+                                       .map(|method| method.ty);\n+                    let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n+\n+                    let mut args = vec![];\n+                    start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+                    end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+\n+                    let result_ty = ty::ty_fn_ret(monomorphize_type(bcx,\n+                                                                    method_ty.unwrap())).unwrap();\n+                    let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n+\n+                    unpack_result!(bcx,\n+                                   trans_overloaded_op(bcx,\n+                                                       expr,\n+                                                       method_call,\n+                                                       base_datum,\n+                                                       args,\n+                                                       Some(SaveIn(scratch.val)),\n+                                                       true));\n+                    DatumBlock::new(bcx, scratch.to_expr_datum())\n+                }\n+                _ => trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n+            }\n         }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>`"}, {"sha": "cf6715e2d73208c388bcd166adda36bfcfd67749", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -488,7 +488,6 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 ast::ExprParen(ref expr) |\n                 ast::ExprField(ref expr, _) |\n                 ast::ExprTupField(ref expr, _) |\n-                ast::ExprSlice(ref expr, _, _, _) |\n                 ast::ExprIndex(ref expr, _) |\n                 ast::ExprUnary(ast::UnDeref, ref expr) => exprs.push(&**expr),\n                 _ => break,"}, {"sha": "9ae42fed07f73ef6b51fb5673248ff4d02189efb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 150, "deletions": 187, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -2003,7 +2003,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-#[deriving(Copy, Show)]\n+#[deriving(Copy, Show,PartialEq,Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,\n     NoPreference\n@@ -2214,57 +2214,6 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Autoderefs `base_expr`, looking for a `Slice` impl. If it finds one, installs the relevant\n-/// method info and returns the result type (else None).\n-fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  method_call: MethodCall,\n-                                  expr: &ast::Expr,\n-                                  base_expr: &ast::Expr,\n-                                  base_ty: Ty<'tcx>,\n-                                  start_expr: &Option<P<ast::Expr>>,\n-                                  end_expr: &Option<P<ast::Expr>>,\n-                                  mutbl: ast::Mutability)\n-                                  -> Option<Ty<'tcx>> // return type is result of slice\n-{\n-    let lvalue_pref = match mutbl {\n-        ast::MutMutable => PreferMutLvalue,\n-        ast::MutImmutable => NoPreference\n-    };\n-\n-    let opt_method_ty =\n-        autoderef_for_index(fcx, base_expr, base_ty, lvalue_pref, |adjusted_ty, autoderefref| {\n-            try_overloaded_slice_step(fcx, method_call, expr, base_expr,\n-                                      adjusted_ty, autoderefref, mutbl,\n-                                      start_expr, end_expr)\n-        });\n-\n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_ty_or_err = opt_method_ty.unwrap_or(ty::mk_err());\n-\n-    let mut args = vec![];\n-    start_expr.as_ref().map(|x| args.push(x));\n-    end_expr.as_ref().map(|x| args.push(x));\n-\n-    check_method_argument_types(fcx,\n-                                expr.span,\n-                                method_ty_or_err,\n-                                expr,\n-                                args.as_slice(),\n-                                AutorefArgs::Yes,\n-                                DontTupleArguments);\n-\n-    opt_method_ty.map(|method_ty| {\n-        let result_ty = ty::ty_fn_ret(method_ty);\n-        match result_ty {\n-            ty::FnConverging(result_ty) => result_ty,\n-            ty::FnDiverging => {\n-                fcx.tcx().sess.span_bug(expr.span,\n-                                        \"slice trait does not define a `!` return\")\n-            }\n-        }\n-    })\n-}\n \n /// Checks for a `Slice` (or `SliceMut`) impl at the relevant level of autoderef. If it finds one,\n /// installs method info and returns type of method (else None).\n@@ -2274,65 +2223,79 @@ fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                        base_expr: &ast::Expr,\n                                        base_ty: Ty<'tcx>, // autoderef'd type\n                                        autoderefref: ty::AutoDerefRef<'tcx>,\n-                                       mutbl: ast::Mutability,\n+                                       lvalue_pref: LvaluePreference,\n                                        start_expr: &Option<P<ast::Expr>>,\n                                        end_expr: &Option<P<ast::Expr>>)\n-                                       // result type is type of method being called\n-                                       -> Option<Ty<'tcx>>\n+                                       -> Option<(Ty<'tcx>, /* index type */\n+                                                  Ty<'tcx>)> /* return type */\n {\n-    let method = if mutbl == ast::MutMutable {\n-        // Try `SliceMut` first, if preferred.\n-        match fcx.tcx().lang_items.slice_mut_trait() {\n-            Some(trait_did) => {\n-                let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_or_fail_mut\",\n-                    (&Some(_), &None) => \"slice_from_or_fail_mut\",\n-                    (&None, &Some(_)) => \"slice_to_or_fail_mut\",\n-                    (&None, &None) => \"as_mut_slice_\",\n-                };\n+    let input_ty = fcx.infcx().next_ty_var();\n+    let return_ty = fcx.infcx().next_ty_var();\n \n-                method::lookup_in_trait_adjusted(fcx,\n-                                                 expr.span,\n-                                                 Some(&*base_expr),\n-                                                 token::intern(method_name),\n-                                                 trait_did,\n-                                                 autoderefref,\n-                                                 base_ty,\n-                                                 None)\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        // Otherwise, fall back to `Slice`.\n-        // FIXME(#17293) this will not coerce base_expr, so we miss the Slice\n-        // trait for `&mut [T]`.\n-        match fcx.tcx().lang_items.slice_trait() {\n-            Some(trait_did) => {\n-                let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_or_fail\",\n-                    (&Some(_), &None) => \"slice_from_or_fail\",\n-                    (&None, &Some(_)) => \"slice_to_or_fail\",\n-                    (&None, &None) => \"as_slice_\",\n-                };\n+    let method = match lvalue_pref {\n+        PreferMutLvalue => {\n+            // Try `SliceMut` first, if preferred.\n+            match fcx.tcx().lang_items.slice_mut_trait() {\n+                Some(trait_did) => {\n+                    let method_name = match (start_expr, end_expr) {\n+                        (&Some(_), &Some(_)) => \"slice_or_fail_mut\",\n+                        (&Some(_), &None) => \"slice_from_or_fail_mut\",\n+                        (&None, &Some(_)) => \"slice_to_or_fail_mut\",\n+                        (&None, &None) => \"as_mut_slice_\",\n+                    };\n \n-                method::lookup_in_trait_adjusted(fcx,\n-                                                 expr.span,\n-                                                 Some(&*base_expr),\n-                                                 token::intern(method_name),\n-                                                 trait_did,\n-                                                 autoderefref,\n-                                                 base_ty,\n-                                                 None)\n+                    method::lookup_in_trait_adjusted(fcx,\n+                                                     expr.span,\n+                                                     Some(&*base_expr),\n+                                                     token::intern(method_name),\n+                                                     trait_did,\n+                                                     autoderefref,\n+                                                     base_ty,\n+                                                     Some(vec![input_ty, return_ty]))\n+                }\n+                _ => None,\n+            }\n+        }\n+        NoPreference => {\n+            // Otherwise, fall back to `Slice`.\n+            match fcx.tcx().lang_items.slice_trait() {\n+                Some(trait_did) => {\n+                    let method_name = match (start_expr, end_expr) {\n+                        (&Some(_), &Some(_)) => \"slice_or_fail\",\n+                        (&Some(_), &None) => \"slice_from_or_fail\",\n+                        (&None, &Some(_)) => \"slice_to_or_fail\",\n+                        (&None, &None) => \"as_slice_\",\n+                    };\n+\n+                    method::lookup_in_trait_adjusted(fcx,\n+                                                     expr.span,\n+                                                     Some(&*base_expr),\n+                                                     token::intern(method_name),\n+                                                     trait_did,\n+                                                     autoderefref,\n+                                                     base_ty,\n+                                                     Some(vec![input_ty, return_ty]))\n+                }\n+                _ => None,\n             }\n-            _ => None,\n         }\n     };\n \n     // If some lookup succeeded, install method in table\n     method.map(|method| {\n-        let ty = method.ty;\n-        fcx.inh.method_map.borrow_mut().insert(method_call, method);\n-        ty\n+        let method_ty = method.ty;\n+        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method));\n+\n+        let result_ty = ty::ty_fn_ret(method_ty);\n+        let result_ty = match result_ty {\n+            ty::FnConverging(result_ty) => result_ty,\n+            ty::FnDiverging => {\n+                fcx.tcx().sess.span_bug(expr.span,\n+                \"slice trait does not define a `!` return\")\n+            }\n+        };\n+\n+        (input_ty, result_ty)\n     })\n }\n \n@@ -4211,99 +4174,98 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprIndex(ref base, ref idx) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n-          check_expr(fcx, &**idx);\n           let base_t = fcx.expr_ty(&**base);\n-          let idx_t = fcx.expr_ty(&**idx);\n           if ty::type_is_error(base_t) {\n               fcx.write_ty(id, base_t);\n-          } else if ty::type_is_error(idx_t) {\n-              fcx.write_ty(id, idx_t);\n           } else {\n-              let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n-\n-              let result =\n-                  autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n-                      try_index_step(fcx,\n-                                     MethodCall::expr(expr.id),\n-                                     expr,\n-                                     &**base,\n-                                     adj_ty,\n-                                     adj,\n-                                     lvalue_pref)\n-                  });\n-\n-              match result {\n-                  Some((index_ty, element_ty)) => {\n-                      check_expr_has_type(fcx, &**idx, index_ty);\n-                      fcx.write_ty(id, element_ty);\n-                  }\n-                  _ => {\n-                      check_expr_has_type(fcx, &**idx, ty::mk_err());\n-                      fcx.type_error_message(\n-                          expr.span,\n-                          |actual| {\n-                              format!(\"cannot index a value of type `{}`\",\n-                                      actual)\n-                          },\n-                          base_t,\n-                          None);\n-                      fcx.write_ty(id, ty::mk_err())\n-                  }\n-              }\n-          }\n-       }\n-       ast::ExprSlice(ref base, ref start, ref end, mutbl) => {\n-          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n-          let raw_base_t = fcx.expr_ty(&**base);\n-\n-          let mut some_err = false;\n-          if ty::type_is_error(raw_base_t) {\n-              fcx.write_ty(id, raw_base_t);\n-              some_err = true;\n-          }\n+              match idx.node {\n+                ast::ExprRange(ref start, ref end) => {\n+                  // A slice, rather than an index. Special cased for now (KILLME).\n+                  let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n \n-          {\n-              let check_slice_idx = |e: &ast::Expr| {\n-                  check_expr(fcx, e);\n-                  let e_t = fcx.expr_ty(e);\n-                  if ty::type_is_error(e_t) {\n-                    fcx.write_ty(e.id, e_t);\n-                    some_err = true;\n+                  if lvalue_pref == PreferMutLvalue {\n+                    println!(\"mutable lvalue_pref\");\n                   }\n-              };\n-              start.as_ref().map(|e| check_slice_idx(&**e));\n-              end.as_ref().map(|e| check_slice_idx(&**e));\n-          }\n-\n-          if !some_err {\n-              let base_t = structurally_resolved_type(fcx,\n-                                                      expr.span,\n-                                                      raw_base_t);\n-              let method_call = MethodCall::expr(expr.id);\n-              match try_overloaded_slice(fcx,\n-                                         method_call,\n-                                         expr,\n-                                         &**base,\n-                                         base_t,\n-                                         start,\n-                                         end,\n-                                         mutbl) {\n-                  Some(ty) => fcx.write_ty(id, ty),\n-                  None => {\n-                        fcx.type_error_message(expr.span,\n-                           |actual| {\n-                                format!(\"cannot take a {}slice of a value with type `{}`\",\n-                                        if mutbl == ast::MutMutable {\n-                                            \"mutable \"\n-                                        } else {\n-                                            \"\"\n-                                        },\n-                                        actual)\n-                           },\n-                           base_t,\n-                           None);\n-                        fcx.write_ty(id, ty::mk_err())\n+                  let result =\n+                      autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n+                          try_overloaded_slice_step(fcx,\n+                                                    MethodCall::expr(expr.id),\n+                                                    expr,\n+                                                    &**base,\n+                                                    adj_ty,\n+                                                    adj,\n+                                                    lvalue_pref,\n+                                                    start,\n+                                                    end)\n+                      });\n+\n+                  let mut args = vec![];\n+                  start.as_ref().map(|x| args.push(x));\n+                  end.as_ref().map(|x| args.push(x));\n+\n+                  match result {\n+                      Some((index_ty, element_ty)) => {\n+                          for a in args.iter() {\n+                            check_expr_has_type(fcx, &***a, index_ty);\n+                          }\n+                          fcx.write_ty(idx.id, element_ty);\n+                          fcx.write_ty(id, element_ty)\n+                      }\n+                      _ => {\n+                          for a in args.iter() {\n+                            check_expr(fcx, &***a);\n+                          }\n+                          fcx.type_error_message(expr.span,\n+                             |actual| {\n+                                  format!(\"cannot take a slice of a value with type `{}`\",\n+                                          actual)\n+                             },\n+                             base_t,\n+                             None);\n+                          fcx.write_ty(idx.id, ty::mk_err());\n+                          fcx.write_ty(id, ty::mk_err())\n+                      }\n                   }\n+                }\n+                _ => {\n+                  check_expr(fcx, &**idx);\n+                  let idx_t = fcx.expr_ty(&**idx);\n+                  if ty::type_is_error(idx_t) {\n+                      fcx.write_ty(id, idx_t);\n+                  } else {\n+                      let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n+\n+                      let result =\n+                          autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n+                              try_index_step(fcx,\n+                                             MethodCall::expr(expr.id),\n+                                             expr,\n+                                             &**base,\n+                                             adj_ty,\n+                                             adj,\n+                                             lvalue_pref)\n+                          });\n+\n+                      match result {\n+                          Some((index_ty, element_ty)) => {\n+                              check_expr_has_type(fcx, &**idx, index_ty);\n+                              fcx.write_ty(id, element_ty);\n+                          }\n+                          _ => {\n+                              check_expr_has_type(fcx, &**idx, ty::mk_err());\n+                              fcx.type_error_message(\n+                                  expr.span,\n+                                  |actual| {\n+                                      format!(\"cannot index a value of type `{}`\",\n+                                              actual)\n+                                  },\n+                                  base_t,\n+                                  None);\n+                              fcx.write_ty(id, ty::mk_err())\n+                          }\n+                      }\n+                  }\n+                }\n               }\n           }\n        }\n@@ -4319,7 +4281,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           let idx_type = match (t_start, t_end) {\n             (Some(ty), None) | (None, Some(ty)) => Some(ty),\n-            (Some(t_start), Some(t_end)) if t_start == ty::mk_err() || t_end == ty::mk_err() => {\n+            (Some(t_start), Some(t_end))\n+              if ty::type_is_error(t_start) || ty::type_is_error(t_end) => {\n                 Some(ty::mk_err())\n             }\n             (Some(t_start), Some(t_end)) => {"}, {"sha": "debcbcd2154bddba0ebef01c2aadc164cde55b51", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -723,7 +723,6 @@ pub enum Expr_ {\n     ExprField(P<Expr>, SpannedIdent),\n     ExprTupField(P<Expr>, Spanned<uint>),\n     ExprIndex(P<Expr>, P<Expr>),\n-    ExprSlice(P<Expr>, Option<P<Expr>>, Option<P<Expr>>, Mutability),\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or"}, {"sha": "4607520655ea1fdb5c9e4dff307d1daf80bac353", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -307,10 +307,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprSlice(..) => {\n+            ast::ExprRange(..) => {\n                 self.gate_feature(\"slicing_syntax\",\n                                   e.span,\n-                                  \"slicing syntax is experimental\");\n+                                  \"range syntax is experimental\");\n             }\n             _ => {}\n         }"}, {"sha": "11a9fdee0b9b0cb0528b474328e80b53b30c67f1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -1384,12 +1384,6 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprSlice(e, e1, e2, m) => {\n-                ExprSlice(folder.fold_expr(e),\n-                          e1.map(|x| folder.fold_expr(x)),\n-                          e2.map(|x| folder.fold_expr(x)),\n-                          m)\n-            }\n             ExprRange(e1, e2) => {\n                 ExprRange(e1.map(|x| folder.fold_expr(x)),\n                           e2.map(|x| folder.fold_expr(x)))"}, {"sha": "2f43661eebeba7da6fad98c5a930b6381e486093", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -25,7 +25,7 @@ use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, Explicit\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n-use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n+use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex};\n use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n use ast::{ExprMethodCall, ExprParen, ExprPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n@@ -66,7 +66,7 @@ use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n use ast_util::{mod, as_prec, ident_to_path, operator_prec};\n-use codemap::{mod, Span, BytePos, Spanned, spanned, mk_sp};\n+use codemap::{mod, Span, BytePos, Spanned, spanned, mk_sp, DUMMY_SP};\n use diagnostic;\n use ext::tt::macro_parser;\n use parse;\n@@ -2135,9 +2135,16 @@ impl<'a> Parser<'a> {\n                     expr: P<Expr>,\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>,\n-                    mutbl: Mutability)\n+                    _mutbl: Mutability)\n                     -> ast::Expr_ {\n-        ExprSlice(expr, start, end, mutbl)\n+        // FIXME: we could give more accurate span info here.\n+        let (lo, hi) = match (&start, &end) {\n+            (&Some(ref s), &Some(ref e)) => (s.span.lo, e.span.hi),\n+            (&Some(ref s), &None) => (s.span.lo, s.span.hi),\n+            (&None, &Some(ref e)) => (e.span.lo, e.span.hi),\n+            (&None, &None) => (DUMMY_SP.lo, DUMMY_SP.hi),\n+        };\n+        ExprIndex(expr, self.mk_expr(lo, hi, ExprRange(start, end)))\n     }\n \n     pub fn mk_range(&mut self,"}, {"sha": "accffbc35babead701d83cf1e050d2930a6dfd6c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -1739,15 +1739,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::ExprSlice(ref e, ref start, ref end, ref mutbl) => {\n-                try!(self.print_expr(&**e));\n-                try!(word(&mut self.s, \"[\"));\n-                if mutbl == &ast::MutMutable {\n-                    try!(word(&mut self.s, \"mut\"));\n-                    if start.is_some() || end.is_some() {\n-                        try!(space(&mut self.s));\n-                    }\n-                }\n+            ast::ExprRange(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n                     try!(self.print_expr(&**e));\n                 }\n@@ -1757,16 +1749,6 @@ impl<'a> State<'a> {\n                 if let &Some(ref e) = end {\n                     try!(self.print_expr(&**e));\n                 }\n-                try!(word(&mut self.s, \"]\"));\n-            }\n-            ast::ExprRange(ref start, ref end) => {\n-                if let &Some(ref e) = start {\n-                    try!(self.print_expr(&**e));\n-                }\n-                try!(word(&mut self.s, \"..\"));\n-                if let &Some(ref e) = end {\n-                    try!(self.print_expr(&**e));\n-                }\n             }\n             ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n             ast::ExprBreak(opt_ident) => {"}, {"sha": "22cfea862517efc15fbcec1df0f07ffe8fe81bf3", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2afb0052618ca3d758fffd0cf50559be774391/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4e2afb0052618ca3d758fffd0cf50559be774391", "patch": "@@ -866,11 +866,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**main_expression);\n             visitor.visit_expr(&**index_expression)\n         }\n-        ExprSlice(ref main_expression, ref start, ref end, _) => {\n-            visitor.visit_expr(&**main_expression);\n-            walk_expr_opt(visitor, start);\n-            walk_expr_opt(visitor, end)\n-        }\n         ExprRange(ref start, ref end) => {\n             walk_expr_opt(visitor, start);\n             walk_expr_opt(visitor, end)"}]}