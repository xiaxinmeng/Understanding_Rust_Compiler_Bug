{"sha": "3a2e9e404a3042d8642084cfe391804bd924b48c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMmU5ZTQwNGEzMDQyZDg2NDIwODRjZmUzOTE4MDRiZDkyNGI0OGM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T20:29:00Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T21:18:52Z"}, "message": "manual: s/unique/owned/, s/shared/managed/, fix rval/lval more.", "tree": {"sha": "8d4c73be0f740b218d48c67e846a90cc18feddeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d4c73be0f740b218d48c67e846a90cc18feddeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a2e9e404a3042d8642084cfe391804bd924b48c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2e9e404a3042d8642084cfe391804bd924b48c", "html_url": "https://github.com/rust-lang/rust/commit/3a2e9e404a3042d8642084cfe391804bd924b48c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a2e9e404a3042d8642084cfe391804bd924b48c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8822742845fbb70de4d9cf07732058a1e7eeacb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8822742845fbb70de4d9cf07732058a1e7eeacb", "html_url": "https://github.com/rust-lang/rust/commit/d8822742845fbb70de4d9cf07732058a1e7eeacb"}], "stats": {"total": 80, "additions": 40, "deletions": 40}, "files": [{"sha": "e6671766e794b4b4196fe6669220b798c8fa6e91", "filename": "doc/rust.md", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3a2e9e404a3042d8642084cfe391804bd924b48c/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/3a2e9e404a3042d8642084cfe391804bd924b48c/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=3a2e9e404a3042d8642084cfe391804bd924b48c", "patch": "@@ -1479,12 +1479,12 @@ The evaluation of an expression depends both on its own category and the context\n [Path](#path-expressions), [field](#field-expressions) and [index](#index-expressions) expressions are lvalues.\n All other expressions are rvalues.\n \n-The left operand of an [assignment](#assignment-expressions) or\n+The left operand of an [assignment](#assignment-expressions),\n+[binary move](#binary-move-expressions) or\n [compound-assignment](#compound-assignment-expressions) expression is an lvalue context,\n as is the single operand of a unary [borrow](#unary-operator-expressions),\n or [move](#unary-move-expressions) expression,\n-and _both_ operands of a [swap](#swap-expressions)\n-or [binary move](#binary-move-expressions) expression.\n+and _both_ operands of a [swap](#swap-expressions) expression.\n All other expression contexts are rvalue contexts.\n \n When an lvalue is evaluated in an _lvalue context_, it denotes a memory location;\n@@ -1737,8 +1737,6 @@ and `&&` only when it evaluates to `true`.\n The binary comparison operators can be applied to any two operands of\n the same type, and produce a boolean value.\n \n-*TODO* details on how types are descended during comparison.\n-\n #### Type cast expressions\n \n A type cast expression is denoted with the binary operator `as`.\n@@ -1774,15 +1772,16 @@ types.\n A _binary move expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) followed by a left-pointing\n arrow (`<-`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n \n-Evaluating a move expression causes, as a side effect, the rvalue to be\n-*moved* into the lvalue. If the rvalue was itself an lvalue, it must be a\n-local variable, as it will be de-initialized in the process.\n+Evaluating a move expression causes, as a side effect,\n+the rvalue to be *moved* into the lvalue.\n+If the rvalue was itself an lvalue, it must be a local variable,\n+as it will be de-initialized in the process.\n \n-Evaluating a move expression does not change reference counts, nor does it\n-cause a deep copy of any unique structure pointed to by the moved\n-*rval*. Instead, the move expression represents an indivisible *transfer of\n-ownership* from the right-hand-side to the left-hand-side of the\n-expression. No allocation or destruction is entailed.\n+Evaluating a move expression does not change reference counts,\n+nor does it cause a deep copy of any owned structure pointed to by the moved rvalue.\n+Instead, the move expression represents an indivisible *transfer of ownership*\n+from the right-hand-side to the left-hand-side of the expression.\n+No allocation or destruction is entailed.\n \n An example of three different move expressions:\n \n@@ -1805,8 +1804,10 @@ A _swap expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) fo\n \n Evaluating a swap expression causes, as a side effect, the values held in the left-hand-side and right-hand-side [lvalues](#lvalues-rvalues-and-temporaries) to be exchanged indivisibly.\n \n-Evaluating a swap expression neither changes reference counts nor deeply copies any unique structure pointed to by the moved [rvalue](#lvalues-rvalues-and-temporaries).\n-Instead, the swap expression represents an indivisible *exchange of ownership* between the right-hand-side and the left-hand-side of the expression.\n+Evaluating a swap expression neither changes reference counts,\n+nor deeply copies any owned structure pointed to by the moved [rvalue](#lvalues-rvalues-and-temporaries).\n+Instead, the swap expression represents an indivisible *exchange of ownership*,\n+between the right-hand-side and the left-hand-side of the expression.\n No allocation or destruction is entailed.\n \n An example of three different swap expressions:\n@@ -1904,13 +1905,12 @@ Evaluating a copy expression first evaluates the argument expression, then\n copies the resulting value, allocating any memory necessary to hold the new\n copy.\n \n-[Shared boxes](#box-types) (type `@`) are, as usual, shallow-copied, as they\n-may be cyclic. [Unique boxes](#box-types), [vectors](#vector-types) and\n-similar unique types are deep-copied.\n+[Managed boxes](#pointer-types) (type `@`) are, as usual, shallow-copied,\n+as are raw and borrowed pointers.\n+[Owned boxes](#pointer-types), [owned vectors](#vector-types) and similar owned types are deep-copied.\n \n-Since the binary [assignment operator](#assignment-expressions) `=` performs a\n-copy implicitly, the unary copy operator is typically only used to cause an\n-argument to a function to be copied and passed by value.\n+Since the binary [assignment operator](#assignment-expressions) `=` performs a copy implicitly,\n+the unary copy operator is typically only used to cause an argument to a function to be copied and passed by value.\n \n An example of a copy expression:\n \n@@ -2670,15 +2670,15 @@ kinds are:\n \n Sendable\n   : Values with a sendable type can be safely sent to another task.\n-    This kind includes scalars, unique pointers, unique closures, and\n+    This kind includes scalars, owning pointers, owned closures, and\n     structural types containing only other sendable types.\n Copyable\n   : This kind includes all types that can be copied. All types with\n-    sendable kind are copyable, as are shared boxes, shared closures,\n+    sendable kind are copyable, as are managed boxes, managed closures,\n     trait types, and structural types built out of these.\n Noncopyable\n   : [Resource](#resources) types, and every type that includes a\n-    resource without storing it in a shared box, may not be copied.\n+    resource without storing it in a managed box, may not be copied.\n     Types of sendable or copyable type can always be used in places\n     where a noncopyable type is expected, so in effect this kind\n     includes all types.\n@@ -2696,7 +2696,7 @@ declared for it. For example, this is not a valid program:\n fn box<T>(x: T) -> @T { @x }\n ~~~~\n \n-Putting `x` into a shared box involves copying, and the `T` parameter\n+Putting `x` into a managed box involves copying, and the `T` parameter\n is assumed to be noncopyable. To change that, a bound is declared:\n \n ~~~~\n@@ -2746,7 +2746,7 @@ entry to each function as the task executes. A stack allocation is reclaimed\n when control leaves the frame containing it.\n \n The _heap_ is a general term that describes two separate sets of boxes:\n-shared boxes -- which may be subject to garbage collection -- and unique\n+managed boxes -- which may be subject to garbage collection -- and owned\n boxes.  The lifetime of an allocation in the heap depends on the lifetime of\n the box values pointing to it. Since box values may themselves be passed in\n and out of frames, or stored in the heap, heap allocations may outlive the\n@@ -2765,13 +2765,13 @@ it is only instantiated for (transitively) sendable kinds of data constructor an\n never including managed or borrowed pointers.\n \n When a stack frame is exited, its local allocations are all released, and its\n-references to boxes (both shared and owned) are dropped.\n+references to boxes (both managed and owned) are dropped.\n \n-A shared box may (in the case of a recursive, mutable shared type) be cyclic;\n-in this case the release of memory inside the shared structure may be deferred\n+A managed box may (in the case of a recursive, mutable managed type) be cyclic;\n+in this case the release of memory inside the managed structure may be deferred\n until task-local garbage collection can reclaim it. Code can ensure no such\n-delayed deallocation occurs by restricting itself to unique boxes and similar\n-unshared kinds of data.\n+delayed deallocation occurs by restricting itself to owned boxes and similar\n+unmanaged kinds of data.\n \n When a task finishes, its stack is necessarily empty and it therefore has no\n references to any boxes; the remainder of its heap is immediately freed.\n@@ -2820,22 +2820,22 @@ fn incr(i: &mut int) {\n ### Memory boxes\n \n A _box_ is a reference to a heap allocation holding another value. There\n-are two kinds of boxes: *shared boxes* and *unique boxes*.\n+are two kinds of boxes: *managed boxes* and *owned boxes*.\n \n-A _shared box_ type or value is constructed by the prefix *at* sigil `@`.\n+A _managed box_ type or value is constructed by the prefix *at* sigil `@`.\n \n-A _unique box_ type or value is constructed by the prefix *tilde* sigil `~`.\n+An _owned box_ type or value is constructed by the prefix *tilde* sigil `~`.\n \n-Multiple shared box values can point to the same heap allocation; copying a\n-shared box value makes a shallow copy of the pointer (optionally incrementing\n-a reference count, if the shared box is implemented through\n+Multiple managed box values can point to the same heap allocation; copying a\n+managed box value makes a shallow copy of the pointer (optionally incrementing\n+a reference count, if the managed box is implemented through\n reference-counting).\n \n-Unique box values exist in 1:1 correspondence with their heap allocation;\n-copying a unique box value makes a deep copy of the heap allocation and\n+Owned box values exist in 1:1 correspondence with their heap allocation;\n+copying an owned box value makes a deep copy of the heap allocation and\n produces a pointer to the new allocation.\n \n-An example of constructing one shared box type and value, and one unique box\n+An example of constructing one managed box type and value, and one owned box\n type and value:\n \n ~~~~~~~~"}]}