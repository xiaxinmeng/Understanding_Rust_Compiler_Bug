{"sha": "95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "node_id": "C_kwDOAAsO6NoAKDk1ZTlmNjhlYjUwY2ZkYWE4MzBiMDdiM2Q5NjBhMzExZTRhMGU1NDA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-25T19:06:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-25T19:06:34Z"}, "message": "Rollup merge of #110671 - compiler-errors:polarity, r=lcnr\n\nConsider polarity in new solver\n\nIt's kinda ugly to have a polarity check in all of the builtin impls -- I guess I could consider the polarity at the top of assemble-builtin but that would require adding a polarity fn to `GoalKind`...\n\n:shrug: putting this up just so i dont forget, since it's needed to bootstrap core during coherence (this alone does not allow core to bootstrap though, additional work is needed!)\n\nr? ``@lcnr``", "tree": {"sha": "cbdea99a2b39fc3a006ee565697ee6b90c6488c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbdea99a2b39fc3a006ee565697ee6b90c6488c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkSCS6CRBK7hj4Ov3rIwAApk0IAFjd6/FhEyFXeLqhOYshm3kE\nlXiqzWgfDuNZ0Hs6vor2sGDgkngEo1UN3tqKUbn7tvUAAoPOq9Fa76OwuCGZfakZ\nBOJri34zRikOJu7SYqqmhDJ+ahkof6YTJnCZekCboEFeoYNO/Gzd+AC01pK5bz66\nBKSYC/0CDY99+PyKads+FD/R16pWsd02HSkaIxNHChIQpdXKgeTlCHxRaKsh3mdx\no3sYks/k5Kk6OQma2OKpO7e58RT6Lc8POL/EBYf8cBhtH8rz1wrJx4xNA5MXViGK\n1lJ/ZFzX35Q84a8i3QZIdNipyFzi/sWfw+Wxz2xO1ZzXX6EEtQLY3KTNflkKfYE=\n=Uhv+\n-----END PGP SIGNATURE-----\n", "payload": "tree cbdea99a2b39fc3a006ee565697ee6b90c6488c5\nparent 94dfb3ba78e211ea2a650b7aaeff2b79e0235003\nparent bb2cb89ead84128441472ffec7e5c9174ce204e7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682449594 +0200\ncommitter GitHub <noreply@github.com> 1682449594 +0200\n\nRollup merge of #110671 - compiler-errors:polarity, r=lcnr\n\nConsider polarity in new solver\n\nIt's kinda ugly to have a polarity check in all of the builtin impls -- I guess I could consider the polarity at the top of assemble-builtin but that would require adding a polarity fn to `GoalKind`...\n\n:shrug: putting this up just so i dont forget, since it's needed to bootstrap core during coherence (this alone does not allow core to bootstrap though, additional work is needed!)\n\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "html_url": "https://github.com/rust-lang/rust/commit/95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94dfb3ba78e211ea2a650b7aaeff2b79e0235003", "url": "https://api.github.com/repos/rust-lang/rust/commits/94dfb3ba78e211ea2a650b7aaeff2b79e0235003", "html_url": "https://github.com/rust-lang/rust/commit/94dfb3ba78e211ea2a650b7aaeff2b79e0235003"}, {"sha": "bb2cb89ead84128441472ffec7e5c9174ce204e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb2cb89ead84128441472ffec7e5c9174ce204e7", "html_url": "https://github.com/rust-lang/rust/commit/bb2cb89ead84128441472ffec7e5c9174ce204e7"}], "stats": {"total": 129, "additions": 126, "deletions": 3}, "files": [{"sha": "8e4e708b73c45200ef531e68f95ff6489081c402", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "patch": "@@ -861,6 +861,11 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn is_const_if_const(self) -> bool {\n         self.skip_binder().is_const_if_const()\n     }\n+\n+    #[inline]\n+    pub fn polarity(self) -> ImplPolarity {\n+        self.skip_binder().polarity\n+    }\n }\n \n /// `A: B`"}, {"sha": "c97473e6241f28dd3f9dc2db949b5200369bede6", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "patch": "@@ -86,8 +86,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n+            && poly_trait_pred.polarity() == goal.predicate.polarity\n         {\n-            // FIXME: Constness and polarity\n+            // FIXME: Constness\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n@@ -111,6 +112,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n+            && poly_trait_pred.polarity() == goal.predicate.polarity\n         {\n             // FIXME: Constness and polarity\n             ecx.probe(|ecx| {\n@@ -147,6 +149,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if let Some(result) = ecx.disqualify_auto_trait_candidate_due_to_possible_impl(goal) {\n             return result;\n         }\n@@ -161,6 +167,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let tcx = ecx.tcx();\n \n         ecx.probe(|ecx| {\n@@ -176,6 +186,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         ecx.probe_and_evaluate_goal_for_constituent_tys(\n             goal,\n             structural_traits::instantiate_constituent_tys_for_sized_trait,\n@@ -186,6 +200,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         ecx.probe_and_evaluate_goal_for_constituent_tys(\n             goal,\n             structural_traits::instantiate_constituent_tys_for_copy_clone_trait,\n@@ -196,6 +214,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if goal.predicate.self_ty().has_non_region_infer() {\n             return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n@@ -217,6 +239,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if let ty::FnPtr(..) = goal.predicate.self_ty().kind() {\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n@@ -229,6 +255,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let tcx = ecx.tcx();\n         let tupled_inputs_and_output =\n             match structural_traits::extract_tupled_inputs_and_output_from_callable(\n@@ -259,6 +289,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n@@ -268,15 +302,23 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n     fn consider_builtin_pointee_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n+        goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_future_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let ty::Generator(def_id, _, _) = *goal.predicate.self_ty().kind() else {\n             return Err(NoSolution);\n         };\n@@ -297,6 +339,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let self_ty = goal.predicate.self_ty();\n         let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n             return Err(NoSolution);\n@@ -326,6 +372,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let tcx = ecx.tcx();\n         let a_ty = goal.predicate.self_ty();\n         let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n@@ -447,6 +497,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> Vec<CanonicalResponse<'tcx>> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return vec![];\n+        }\n+\n         let tcx = ecx.tcx();\n \n         let a_ty = goal.predicate.self_ty();\n@@ -521,8 +575,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n     fn consider_builtin_discriminant_kind_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n+        goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         // `DiscriminantKind` is automatically implemented for every type.\n         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n@@ -531,6 +589,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if !goal.param_env.is_const() {\n             // `Destruct` is automatically implemented for every type in\n             // non-const environments.\n@@ -545,6 +607,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         // `rustc_transmute` does not have support for type or const params\n         if goal.has_non_region_placeholders() {\n             return Err(NoSolution);"}, {"sha": "5436b02c3ded2d64b23101a00d2fb213e999e10b", "filename": "tests/ui/traits/new-solver/negative-coherence-bounds.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/tests%2Fui%2Ftraits%2Fnew-solver%2Fnegative-coherence-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/tests%2Fui%2Ftraits%2Fnew-solver%2Fnegative-coherence-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnegative-coherence-bounds.rs?ref=95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "patch": "@@ -0,0 +1,40 @@\n+// check-pass\n+\n+// This test verifies that negative trait predicate cannot be satisfied from a\n+// positive param-env candidate.\n+\n+// Negative coherence is one of the only places where we actually construct and\n+// evaluate negative predicates. Specifically, when verifying whether the first\n+// and second impls below overlap, we do not want to consider them disjoint,\n+// otherwise the second impl would be missing an associated type `type Item`\n+// which is provided by the first impl that it is specializing.\n+\n+#![feature(specialization)]\n+//~^ WARN the feature `specialization` is incomplete\n+#![feature(with_negative_coherence)]\n+\n+trait BoxIter {\n+    type Item;\n+\n+    fn last(self) -> Option<Self::Item>;\n+}\n+\n+impl<I: Iterator + ?Sized> BoxIter for Box<I> {\n+    type Item = I::Item;\n+\n+    default fn last(self) -> Option<I::Item> {\n+        todo!()\n+    }\n+}\n+\n+// When checking that this impl does/doesn't overlap the one above, we evaluate\n+// a negative version of all of the where-clause predicates of the impl below.\n+// For `I: !Iterator`, we should make sure that the param-env clause `I: Iterator`\n+// from above doesn't satisfy this predicate.\n+impl<I: Iterator> BoxIter for Box<I> {\n+    fn last(self) -> Option<I::Item> {\n+        (*self).last()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4127f51f56da2f417dc5beae8abad9d8453ff204", "filename": "tests/ui/traits/new-solver/negative-coherence-bounds.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/tests%2Fui%2Ftraits%2Fnew-solver%2Fnegative-coherence-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95e9f68eb50cfdaa830b07b3d960a311e4a0e540/tests%2Fui%2Ftraits%2Fnew-solver%2Fnegative-coherence-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnegative-coherence-bounds.stderr?ref=95e9f68eb50cfdaa830b07b3d960a311e4a0e540", "patch": "@@ -0,0 +1,12 @@\n+warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/negative-coherence-bounds.rs:12:12\n+   |\n+LL | #![feature(specialization)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n+   = help: consider using `min_specialization` instead, which is more stable and complete\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}