{"sha": "065852def0903296da33a9eaf557f230bcf3a61a", "node_id": "C_kwDOAAsO6NoAKDA2NTg1MmRlZjA5MDMyOTZkYTMzYTllYWY1NTdmMjMwYmNmM2E2MWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-13T20:22:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-13T20:22:52Z"}, "message": "Auto merge of #107992 - lnicola:rust-analyzer-2023-02-13, r=lnicola\n\n:arrow_up: `rust-analyzer`\n\nr? `@ghost`", "tree": {"sha": "ebbb878139884db3094a5c0dda5107b3c6d6e516", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebbb878139884db3094a5c0dda5107b3c6d6e516"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/065852def0903296da33a9eaf557f230bcf3a61a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/065852def0903296da33a9eaf557f230bcf3a61a", "html_url": "https://github.com/rust-lang/rust/commit/065852def0903296da33a9eaf557f230bcf3a61a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/065852def0903296da33a9eaf557f230bcf3a61a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3c9eede5d50be0231f229bf28a271cd509861a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c9eede5d50be0231f229bf28a271cd509861a3", "html_url": "https://github.com/rust-lang/rust/commit/a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "c4a2f065854f85fcee397d0b9e8e535e6770e1da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4a2f065854f85fcee397d0b9e8e535e6770e1da", "html_url": "https://github.com/rust-lang/rust/commit/c4a2f065854f85fcee397d0b9e8e535e6770e1da"}], "stats": {"total": 20886, "additions": 11188, "deletions": 9698}, "files": [{"sha": "a08ad07cbf8d3b5af82424d9cc78865cc5d70095", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/blank_issue.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=a3c9eede5d50be0231f229bf28a271cd509861a3", "patch": "@@ -1,10 +0,0 @@\n----\n-name: Blank Issue\n-about: Create a blank issue.\n-title: ''\n-labels: ''\n-assignees: ''\n-\n----\n-\n-"}, {"sha": "5faee21bdb6dae5d81a05eb2844fd36f93647a55", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,7 +2,7 @@\n name: Bug report\n about: Create a bug report for rust-analyzer.\n title: ''\n-labels: ''\n+labels: 'C-bug'\n assignees: ''\n \n ---\n@@ -22,4 +22,4 @@ Otherwise please try to provide information which will help us to fix the issue\n \n **rustc version**: (eg. output of `rustc -V`)\n \n-**relevant settings**: (eg. client settings, or environment variables like `CARGO`, `RUSTUP_HOME` or `CARGO_HOME`)\n+**relevant settings**: (eg. client settings, or environment variables like `CARGO`, `RUSTC`, `RUSTUP_HOME` or `CARGO_HOME`)"}, {"sha": "5207957c459264cf62ec5333245f7594ac211976", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/feature_request.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Ffeature_request.md", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Ffeature_request.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Ffeature_request.md?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,8 @@\n+---\n+name: Feature Request\n+about: Create a feature request for rust-analyzer.\n+title: ''\n+labels: 'C-feature'\n+assignees: ''\n+\n+---"}, {"sha": "a90ade882bd9e66832152cc7687e55c5cc8dcd87", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/question.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fquestion.md", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fquestion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fquestion.md?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,8 @@\n+---\n+name: Support Question\n+about: A question regarding functionality of rust-analyzer.\n+title: ''\n+labels: 'C-support'\n+assignees: ''\n+\n+---"}, {"sha": "279f86b458dffd9a858354626d1ec0c7452e5c06", "filename": "src/tools/rust-analyzer/.github/workflows/autopublish.yaml", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fautopublish.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fautopublish.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fautopublish.yaml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,4 +1,4 @@\n-name: publish\n+name: autopublish\n on:\n   workflow_dispatch: # We can add version input when 1.0 is released and scheduled releases are removed\n \n@@ -25,7 +25,7 @@ jobs:\n       - name: Install cargo-workspaces\n         run: cargo install cargo-workspaces\n \n-      - name: Release\n+      - name: Publish Crates\n         env:\n           CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n           PATCH: ${{ github.run_number }}", "previous_filename": "src/tools/rust-analyzer/.github/workflows/publish.yml"}, {"sha": "5af8aa1f77aacaa23dd25837bef17edeb71d5545", "filename": "src/tools/rust-analyzer/.github/workflows/fuzz.yml", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Ffuzz.yml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Ffuzz.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Ffuzz.yml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,43 @@\n+name: Fuzz\n+on:\n+  schedule:\n+    # Once a week\n+    - cron: '0 0 * * 0'\n+  push:\n+    paths:\n+    - '.github/workflows/fuzz.yml'\n+  # Allow manual trigger\n+  workflow_dispatch:\n+\n+env:\n+  CARGO_INCREMENTAL: 0\n+  CARGO_NET_RETRY: 10\n+  CI: 1\n+  RUST_BACKTRACE: short\n+  RUSTFLAGS: \"-D warnings -W unreachable-pub -W bare-trait-objects\"\n+  RUSTUP_MAX_RETRIES: 10\n+\n+jobs:\n+  rust:\n+    if: ${{ github.repository == 'rust-lang/rust-analyzer' || github.event.action == 'workflow_dispatch' }}\n+    name: Rust\n+    runs-on: ubuntu-latest\n+    env:\n+      CC: deny_c\n+\n+    steps:\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          ref: ${{ github.event.pull_request.head.sha }}\n+          fetch-depth: 1\n+\n+      - name: Install Rust toolchain\n+        run: |\n+          rustup install --profile minimal nightly\n+\n+      - name: Build fuzzers\n+        run: |\n+          cargo install cargo-fuzz\n+          cd crates/syntax\n+          cargo +nightly fuzz build"}, {"sha": "1b843fff1a4a1bc87861e9cd6341744226fa7a69", "filename": "src/tools/rust-analyzer/.github/workflows/publish-libs.yaml", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish-libs.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish-libs.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish-libs.yaml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,35 @@\n+name: publish-libs\n+on:\n+  workflow_dispatch:\n+  push:\n+    branches:\n+      - main\n+    paths:\n+      - 'lib/**'\n+\n+jobs:\n+  publish-libs:\n+    name: publish\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          fetch-depth: 0\n+\n+      - name: Install Rust toolchain\n+        run: rustup update --no-self-update stable\n+\n+      - name: Install cargo-workspaces\n+        run: cargo install cargo-workspaces\n+\n+      - name: Publish Crates\n+        env:\n+          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n+        shell: bash\n+        run: |\n+          git config --global user.email \"runner@gha.local\"\n+          git config --global user.name \"Github Action\"\n+          # Remove r-a crates from the workspaces so we don't auto-publish them as well\n+          sed -i 's/ \"crates\\/\\*\"//' ./Cargo.toml\n+          cargo workspaces publish --yes --exact --from-git --no-git-commit --allow-dirty"}, {"sha": "48f4c6b55ed900ff78db90cff6bc52eb25c57a57", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -28,6 +28,9 @@ jobs:\n           - os: windows-latest\n             target: x86_64-pc-windows-msvc\n             code-target: win32-x64\n+          - os: windows-latest\n+            target: i686-pc-windows-msvc\n+            code-target: win32-ia32\n           - os: windows-latest\n             target: aarch64-pc-windows-msvc\n             code-target: win32-arm64\n@@ -230,6 +233,10 @@ jobs:\n         with:\n           name: dist-x86_64-pc-windows-msvc\n           path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-i686-pc-windows-msvc\n+          path: dist\n       - uses: actions/download-artifact@v1\n         with:\n           name: dist-aarch64-pc-windows-msvc"}, {"sha": "ef0316f30fb93e1abf9092437f19127d31dcc097", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 208, "deletions": 216, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"addr2line\"\n-version = \"0.17.0\"\n+version = \"0.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n+checksum = \"a76fd60b23679b7d19bd066031410fb7e458ccc5e958eb5c325888ce4baedc97\"\n dependencies = [\n  \"gimli\",\n ]\n@@ -26,20 +26,11 @@ dependencies = [\n  \"log\",\n ]\n \n-[[package]]\n-name = \"ansi_term\"\n-version = \"0.12.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2\"\n-dependencies = [\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"anyhow\"\n-version = \"1.0.65\"\n+version = \"1.0.68\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n+checksum = \"2cb2f989d18dd141ab8ae82f64d1a8cdd37e0840f73a406896cf5e99502fab61\"\n \n [[package]]\n name = \"anymap\"\n@@ -49,9 +40,9 @@ checksum = \"8f1f8f5a6f3d50d89e3797d7593a50f96bb2aaa20ca0cc7be1fb673232c91d72\"\n \n [[package]]\n name = \"arbitrary\"\n-version = \"1.1.7\"\n+version = \"1.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d86fd10d912cab78764cc44307d9cd5f164e09abbeb87fb19fb6d95937e8da5f\"\n+checksum = \"b0224938f92e7aef515fac2ff2d18bd1115c1394ddf4a092e0c87e8be9499ee5\"\n \n [[package]]\n name = \"arrayvec\"\n@@ -65,7 +56,7 @@ version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n dependencies = [\n- \"hermit-abi\",\n+ \"hermit-abi 0.1.19\",\n  \"libc\",\n  \"winapi\",\n ]\n@@ -78,9 +69,9 @@ checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.66\"\n+version = \"0.3.67\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cab84319d616cfb654d03394f38ab7e6f0919e181b1b57e1fd15e7fb4077d9a7\"\n+checksum = \"233d376d6d185f2a3093e58f283f60f880315b6c60075b01f36b3b85154564ca\"\n dependencies = [\n  \"addr2line\",\n  \"cc\",\n@@ -120,9 +111,9 @@ checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n \n [[package]]\n name = \"camino\"\n-version = \"1.1.1\"\n+version = \"1.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"88ad0e1e3e88dd237a156ab9f571021b8a158caa0ae44b1968a241efb5144c1e\"\n+checksum = \"c77df041dc383319cc661b428b6961a005db4d6808d5e12536931b1ca9556055\"\n dependencies = [\n  \"serde\",\n ]\n@@ -138,22 +129,23 @@ dependencies = [\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.15.0\"\n+version = \"0.15.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3abb7553d5b9b8421c6de7cb02606ff15e0c6eea7d8eadd75ef013fd636bec36\"\n+checksum = \"982a0cf6a99c350d7246035613882e376d58cebe571785abc5da4f648d53ac0a\"\n dependencies = [\n  \"camino\",\n  \"cargo-platform\",\n  \"semver\",\n  \"serde\",\n  \"serde_json\",\n+ \"thiserror\",\n ]\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.73\"\n+version = \"1.0.78\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n+checksum = \"a20104e2335ce8a659d6dd92a51a767a0c062599c73b343fd152cb401e828c3d\"\n \n [[package]]\n name = \"cfg\"\n@@ -229,9 +221,9 @@ dependencies = [\n \n [[package]]\n name = \"command-group\"\n-version = \"1.0.8\"\n+version = \"2.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f7a8a86f409b4a59df3a3e4bee2de0b83f1755fdd2a25e3a9684c396fc4bed2c\"\n+checksum = \"026c3922235f9f7d78f21251a026f3acdeb7cce3deba107fe09a4bfa63d850a2\"\n dependencies = [\n  \"nix\",\n  \"winapi\",\n@@ -286,22 +278,22 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.11\"\n+version = \"0.9.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f916dfc5d356b0ed9dae65f1db9fc9770aa2851d2662b988ccf4fe3516e86348\"\n+checksum = \"01a9af1f4c2ef74bb8aa1f7e19706bc72d03598c8a570bb5de72243c7a9d9d5a\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n  \"crossbeam-utils\",\n- \"memoffset\",\n+ \"memoffset 0.7.1\",\n  \"scopeguard\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.12\"\n+version = \"0.8.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"edbafec5fa1f196ca66527c1b12c2ec4745ca14b50f1ad8f9f6f720b55d11fac\"\n+checksum = \"4fb766fa798726286dbbb842f174001dab8abc7b627a1dd86e0b7222a95d929f\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -316,14 +308,14 @@ dependencies = [\n  \"hashbrown\",\n  \"lock_api\",\n  \"once_cell\",\n- \"parking_lot_core 0.9.4\",\n+ \"parking_lot_core 0.9.6\",\n ]\n \n [[package]]\n name = \"derive_arbitrary\"\n-version = \"1.1.6\"\n+version = \"1.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"226ad66541d865d7a7173ad6a9e691c33fdb910ac723f4bc734b3e5294a1f931\"\n+checksum = \"cf460bbff5f571bfc762da5102729f59f338be7db17a21fade44c5c4f5005350\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -332,9 +324,9 @@ dependencies = [\n \n [[package]]\n name = \"dissimilar\"\n-version = \"1.0.4\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8c97b9233581d84b8e1e689cdd3a47b6f69770084fc246e86a7f78b0d9c1d4a5\"\n+checksum = \"210ec60ae7d710bed8683e333e9d2855a8a56a3e9892b38bad3bb0d4d29b0d5e\"\n \n [[package]]\n name = \"dot\"\n@@ -375,14 +367,14 @@ dependencies = [\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.18\"\n+version = \"0.2.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4b9663d381d07ae25dc88dbdf27df458faa83a9b25336bcac83d5e452b5fc9d3\"\n+checksum = \"4e884668cd0c7480504233e951174ddc3b382f7c2666e3b7310b5c4e7b0c37f9\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n- \"windows-sys 0.42.0\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -393,9 +385,9 @@ checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n \n [[package]]\n name = \"flate2\"\n-version = \"1.0.24\"\n+version = \"1.0.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f82b0f4c27ad9f8bfd1f3208d882da2b09c301bc1c828fd3a00d0216d2fbbff6\"\n+checksum = \"a8a2db397cb1c8772f31494cb8917e48cd1e64f0fa7efac59fbd741a0a8ce841\"\n dependencies = [\n  \"crc32fast\",\n  \"miniz_oxide\",\n@@ -450,9 +442,9 @@ checksum = \"7ab85b9b05e3978cc9a9cf8fea7f01b494e1a09ed3037e16ba39edc7a29eb61a\"\n \n [[package]]\n name = \"gimli\"\n-version = \"0.26.2\"\n+version = \"0.27.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n+checksum = \"dec7af912d60cdbd3677c1af9352ebae6fb8394d165568a2234df0fa00f87793\"\n \n [[package]]\n name = \"hashbrown\"\n@@ -478,6 +470,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"hir\"\n version = \"0.0.0\"\n@@ -519,6 +520,7 @@ dependencies = [\n  \"hkalbasi-rustc-ap-rustc_abi\",\n  \"hkalbasi-rustc-ap-rustc_index\",\n  \"indexmap\",\n+ \"intern\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n@@ -544,6 +546,7 @@ dependencies = [\n  \"either\",\n  \"expect-test\",\n  \"hashbrown\",\n+ \"intern\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n@@ -574,11 +577,13 @@ dependencies = [\n  \"hir-def\",\n  \"hir-expand\",\n  \"hkalbasi-rustc-ap-rustc_index\",\n+ \"intern\",\n  \"itertools\",\n  \"la-arena\",\n  \"limit\",\n  \"once_cell\",\n  \"profile\",\n+ \"project-model\",\n  \"rustc-hash\",\n  \"scoped-tls\",\n  \"smallvec\",\n@@ -642,6 +647,7 @@ dependencies = [\n  \"profile\",\n  \"pulldown-cmark\",\n  \"pulldown-cmark-to-cmark\",\n+ \"smallvec\",\n  \"stdx\",\n  \"syntax\",\n  \"test-utils\",\n@@ -766,9 +772,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.1\"\n+version = \"1.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n+checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n@@ -803,6 +809,16 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"intern\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"dashmap\",\n+ \"hashbrown\",\n+ \"once_cell\",\n+ \"rustc-hash\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.10.5\"\n@@ -814,9 +830,9 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"1.0.4\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4217ad341ebadf8d8e724e264f13e593e0648f5b3e94b3896a5df283be015ecc\"\n+checksum = \"fad582f4b9e86b6caa621cabeb0963332d92eea04729ab12892c2533951e6440\"\n \n [[package]]\n name = \"jod-thread\"\n@@ -826,9 +842,9 @@ checksum = \"8b23360e99b8717f20aaa4598f5a6541efbe30630039fbc7706cf954a87947ae\"\n \n [[package]]\n name = \"kqueue\"\n-version = \"1.0.6\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d6112e8f37b59803ac47a42d14f1f3a59bbf72fc6857ffc5be455e28a691f8e\"\n+checksum = \"2c8fc60ba15bf51257aa9807a48a61013db043fcf3a78cb0d916e8e396dcad98\"\n dependencies = [\n  \"kqueue-sys\",\n  \"libc\",\n@@ -856,27 +872,28 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.135\"\n+version = \"0.2.139\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n+checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.7.3\"\n+version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n+checksum = \"b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f\"\n dependencies = [\n  \"cfg-if\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"libmimalloc-sys\"\n-version = \"0.1.26\"\n+version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8fc093ab289b0bfda3aa1bdfab9c9542be29c7ef385cfcbe77f8c9813588eb48\"\n+checksum = \"dd8c7cbf8b89019683667e347572e6d55a7df7ea36b0c4ce69961b0cde67b174\"\n dependencies = [\n  \"cc\",\n+ \"libc\",\n ]\n \n [[package]]\n@@ -958,9 +975,9 @@ checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"memmap2\"\n-version = \"0.5.7\"\n+version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95af15f345b17af2efc8ead6080fb8bc376f8cec1b35277b935637595fe77498\"\n+checksum = \"4b182332558b18d807c4ce1ca8ca983b34c3ee32765e47b3f0f69b90355cc1dc\"\n dependencies = [\n  \"libc\",\n ]\n@@ -974,34 +991,43 @@ dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"memoffset\"\n+version = \"0.7.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n [[package]]\n name = \"mimalloc\"\n-version = \"0.1.30\"\n+version = \"0.1.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76ce6a4b40d3bff9eb3ce9881ca0737a85072f9f975886082640cd46a75cdb35\"\n+checksum = \"9dcb174b18635f7561a0c6c9fc2ce57218ac7523cf72c50af80e2d79ab8f3ba1\"\n dependencies = [\n  \"libmimalloc-sys\",\n ]\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.5.4\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"96590ba8f175222643a85693f33d26e9c8a015f599c216509b1a6894af675d34\"\n+checksum = \"b275950c28b37e794e8c55d88aeb5e139d0ce23fdbbeda68f8d7174abdf9e8fa\"\n dependencies = [\n  \"adler\",\n ]\n \n [[package]]\n name = \"mio\"\n-version = \"0.8.4\"\n+version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"57ee1c23c7c63b0c9250c339ffdc69255f110b298b901b9f6c82547b7b87caaf\"\n+checksum = \"e5d732bc30207a6423068df043e3d02e0735b155ad7ce1a6f76fe2baa5b158de\"\n dependencies = [\n  \"libc\",\n  \"log\",\n  \"wasi\",\n- \"windows-sys 0.36.1\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -1010,20 +1036,19 @@ version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"52ffbca2f655e33c08be35d87278e5b18b89550a37dbd598c20db92f6a471123\"\n dependencies = [\n- \"windows-sys 0.42.0\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n name = \"nix\"\n-version = \"0.22.3\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e4916f159ed8e5de0082076562152a76b7a1f64a01fd9d1e0fea002c37624faf\"\n+checksum = \"bfdda3d196821d6af13126e40375cdf7da646a96114af134d5f417a9a1dc8e1a\"\n dependencies = [\n  \"bitflags\",\n- \"cc\",\n  \"cfg-if\",\n  \"libc\",\n- \"memoffset\",\n+ \"static_assertions\",\n ]\n \n [[package]]\n@@ -1044,37 +1069,53 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"nu-ansi-term\"\n+version = \"0.46.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84\"\n+dependencies = [\n+ \"overload\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"num_cpus\"\n-version = \"1.13.1\"\n+version = \"1.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1\"\n+checksum = \"0fac9e2da13b5eb447a6ce3d392f23a29d8694bff781bf03a16cd9ac8697593b\"\n dependencies = [\n- \"hermit-abi\",\n+ \"hermit-abi 0.2.6\",\n  \"libc\",\n ]\n \n [[package]]\n name = \"object\"\n-version = \"0.29.0\"\n+version = \"0.30.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n+checksum = \"2b8c786513eb403643f2a88c244c2aaa270ef2153f55094587d0c48a3cf22a83\"\n dependencies = [\n  \"memchr\",\n ]\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.15.0\"\n+version = \"1.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e82dad04139b71a90c080c8463fe0dc7902db5192d939bd0950f074d014339e1\"\n+checksum = \"6f61fba1741ea2b3d6a1e3178721804bb716a68a6aeba1149b5d52e3d464ea66\"\n \n [[package]]\n name = \"oorandom\"\n version = \"11.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575\"\n \n+[[package]]\n+name = \"overload\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39\"\n+\n [[package]]\n name = \"parking_lot\"\n version = \"0.11.2\"\n@@ -1083,7 +1124,7 @@ checksum = \"7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99\"\n dependencies = [\n  \"instant\",\n  \"lock_api\",\n- \"parking_lot_core 0.8.5\",\n+ \"parking_lot_core 0.8.6\",\n ]\n \n [[package]]\n@@ -1093,14 +1134,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core 0.9.4\",\n+ \"parking_lot_core 0.9.6\",\n ]\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.8.5\"\n+version = \"0.8.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216\"\n+checksum = \"60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc\"\n dependencies = [\n  \"cfg-if\",\n  \"instant\",\n@@ -1112,15 +1153,15 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.9.4\"\n+version = \"0.9.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n+checksum = \"ba1ef8814b5c993410bb3adfad7a5ed269563e4a2f90c41f5d85be7fb47133bf\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys 0.42.0\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -1136,9 +1177,9 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"1.0.9\"\n+version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1de2e551fb905ac83f73f7aedf2f0cb4a0da7e35efa24a202a936269f1f18e1\"\n+checksum = \"d01a5bd0424d00070b0098dd17ebca6f961a959dead1dbcbbbc1d1cd8d3deeba\"\n \n [[package]]\n name = \"paths\"\n@@ -1238,9 +1279,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.47\"\n+version = \"1.0.50\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725\"\n+checksum = \"6ef7d57beacfaf2d8aee5937dab7b7f28de3cb8b1828479bb5de2a7106f2bae2\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -1322,30 +1363,28 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.21\"\n+version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179\"\n+checksum = \"8856d8364d252a14d474036ea1358d63c9e6965c8e5c1885c18f73d70bff9c7b\"\n dependencies = [\n  \"proc-macro2\",\n ]\n \n [[package]]\n name = \"rayon\"\n-version = \"1.5.3\"\n+version = \"1.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bd99e5772ead8baa5215278c9b15bf92087709e9c1b2d1f97cdb5a183c933a7d\"\n+checksum = \"6db3a213adf02b3bcfd2d3846bb41cb22857d131789e01df434fb7e7bc0759b7\"\n dependencies = [\n- \"autocfg\",\n- \"crossbeam-deque\",\n  \"either\",\n  \"rayon-core\",\n ]\n \n [[package]]\n name = \"rayon-core\"\n-version = \"1.9.3\"\n+version = \"1.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"258bcdb5ac6dad48491bb2992db6b7cf74878b0384908af124823d118c99683f\"\n+checksum = \"cac410af5d00ab6884528b4ab69d1e8e146e8d471201800fa1b4524126de6ad3\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"crossbeam-deque\",\n@@ -1364,9 +1403,9 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"1.6.0\"\n+version = \"1.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c4eb3267174b8c6c2f654116623910a0fef09c4753f8dd83db29c48a0df988b\"\n+checksum = \"48aaa5748ba571fb95cd2c85c09f629215d3a6ece942baa100950af03a34f733\"\n dependencies = [\n  \"regex-syntax\",\n ]\n@@ -1382,9 +1421,9 @@ dependencies = [\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.27\"\n+version = \"0.6.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3f87b73ce11b1619a3c6332f45341e0047173771e8b8b73f87bfeefb7b56244\"\n+checksum = \"456c603be3e8d448b072f410900c09faf164fbce2d480456f50eea6e25f9c848\"\n \n [[package]]\n name = \"rowan\"\n@@ -1394,7 +1433,7 @@ checksum = \"5811547e7ba31e903fe48c8ceab10d40d70a101f3d15523c847cce91aa71f332\"\n dependencies = [\n  \"countme\",\n  \"hashbrown\",\n- \"memoffset\",\n+ \"memoffset 0.6.5\",\n  \"rustc-hash\",\n  \"text-size\",\n ]\n@@ -1455,9 +1494,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"725.0.0\"\n+version = \"727.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f950742ef8a203aa7661aad3ab880438ddeb7f95d4b837c30d65db1a2c5df68e\"\n+checksum = \"8f40f26e7abdcd3b982f36c09a634cc6187988fbf6ec466c91f8d30a12ac0237\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1476,9 +1515,9 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"ryu\"\n-version = \"1.0.11\"\n+version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4501abdff3ae82a1c1b477a17252eb69cee9e66eb915c1abaa4f44d873df9f09\"\n+checksum = \"7b4b9743ed687d4b4bcedf9ff5eaa7398495ae14e61cba0a295704edbc7decde\"\n \n [[package]]\n name = \"salsa\"\n@@ -1529,9 +1568,9 @@ dependencies = [\n \n [[package]]\n name = \"scoped-tls\"\n-version = \"1.0.0\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea6a9290e3c9cf0f18145ef7ffa62d68ee0bf5fcd651017e586dc7fd5da448c2\"\n+checksum = \"e1cf6437eb19a8f4a6cc0f7dca544973b0b78843adbfeb3683d1a94a0024a294\"\n \n [[package]]\n name = \"scopeguard\"\n@@ -1541,27 +1580,27 @@ checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.14\"\n+version = \"1.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e25dfac463d778e353db5be2449d1cce89bd6fd23c9f1ea21310ce6e5a1b29c4\"\n+checksum = \"58bc9567378fc7690d6b2addae4e60ac2eeea07becb2c64b9f218b53865cba2a\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.145\"\n+version = \"1.0.152\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"728eb6351430bccb993660dfffc5a72f91ccc1295abaa8ce19b27ebe4f75568b\"\n+checksum = \"bb7d1f0d3021d347a83e556fc4683dea2ea09d87bccdf88ff5c12545d89d5efb\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.145\"\n+version = \"1.0.152\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"81fa1584d3d1bcacd84c277a0dfe21f5b0f6accf4a23d04d4c6d61f1af522b4c\"\n+checksum = \"af487d118eecd09402d70a5d72551860e788df87b464af30e5ea6a38c75c541e\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1570,9 +1609,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.86\"\n+version = \"1.0.91\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"41feea4228a6f1cd09ec7a3593a682276702cd67b5273544757dae23c096f074\"\n+checksum = \"877c235533714907a8c2464236f5c4b2a17262ef1bd71f38f35ea592c8da6883\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -1582,9 +1621,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_repr\"\n-version = \"0.1.9\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fe39d9fbb0ebf5eb2c7cb7e2a47e4f462fad1379f1166b8ae49ad9eae89a7ca\"\n+checksum = \"9a5ec9fa74a20ebbe5d9ac23dac1fc96ba0ecfe9f50f2843b52e537b10fbcb4e\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1617,9 +1656,9 @@ dependencies = [\n \n [[package]]\n name = \"snap\"\n-version = \"1.0.5\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45456094d1983e2ee2a18fdfebce3189fa451699d0502cb8e3b49dba5ba41451\"\n+checksum = \"5e9f0ab6ef7eb7353d9119c170a436d1bf248eea575ac42d19d12f4e34130831\"\n \n [[package]]\n name = \"sourcegen\"\n@@ -1628,6 +1667,12 @@ dependencies = [\n  \"xshell\",\n ]\n \n+[[package]]\n+name = \"static_assertions\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n+\n [[package]]\n name = \"stdx\"\n version = \"0.0.0\"\n@@ -1641,9 +1686,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.102\"\n+version = \"1.0.107\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3fcd952facd492f9be3ef0d0b7032a6e442ee9b361d4acc2b1d0c4aaa5f613a1\"\n+checksum = \"1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1714,18 +1759,18 @@ checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.37\"\n+version = \"1.0.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10deb33631e3c9018b9baf9dcbbc4f737320d2b576bac10f6aefa048fa407e3e\"\n+checksum = \"6a9cd18aa97d5c45c6603caea1da6628790b37f7a34b6ca89522331c5180fed0\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.37\"\n+version = \"1.0.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"982d17546b47146b28f7c22e3d08465f6b8903d0ea13c1660d9d84a6e7adcdbb\"\n+checksum = \"1fb327af4685e4d03fa8cbcf1716380da910eeb2bb8be417e7f9fd3fb164f36f\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1788,10 +1833,8 @@ version = \"0.3.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a561bf4617eebd33bca6434b988f39ed798e527f51a1e797d0ee4f61c0a38376\"\n dependencies = [\n- \"itoa\",\n  \"serde\",\n  \"time-core\",\n- \"time-macros\",\n ]\n \n [[package]]\n@@ -1800,15 +1843,6 @@ version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e153e1f1acaef8acc537e68b44906d2db6436e2b35ac2c6b42640fff91f00fd\"\n \n-[[package]]\n-name = \"time-macros\"\n-version = \"0.2.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d967f99f534ca7e495c575c62638eebc2898a8c84c119b89e250477bc4ba16b2\"\n-dependencies = [\n- \"time-core\",\n-]\n-\n [[package]]\n name = \"tinyvec\"\n version = \"1.6.0\"\n@@ -1893,12 +1927,12 @@ dependencies = [\n \n [[package]]\n name = \"tracing-tree\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d07e90b329c621ade432823988574e820212648aa40e7a2497777d58de0fb453\"\n+checksum = \"758e983ab7c54fee18403994507e7f212b9005e957ce7984996fac8d11facedb\"\n dependencies = [\n- \"ansi_term\",\n  \"atty\",\n+ \"nu-ansi-term\",\n  \"tracing-core\",\n  \"tracing-log\",\n  \"tracing-subscriber\",\n@@ -1914,9 +1948,9 @@ dependencies = [\n \n [[package]]\n name = \"typed-arena\"\n-version = \"2.0.1\"\n+version = \"2.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0685c84d5d54d1c26f7d3eb96cd41550adb97baed141a761cf335d3d33bcd0ae\"\n+checksum = \"6af6ae20167a9ece4bcb41af5b80f8a1f1df981f6391189ce00fd257af04126a\"\n \n [[package]]\n name = \"ungrammar\"\n@@ -1935,15 +1969,15 @@ dependencies = [\n \n [[package]]\n name = \"unicode-bidi\"\n-version = \"0.3.8\"\n+version = \"0.3.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"099b7128301d285f79ddd55b9a83d5e6b9e97c92e0ea0daebee7263e932de992\"\n+checksum = \"d54675592c1dbefd78cbd98db9bacd89886e1ca50692a0692baefffdeb92dd58\"\n \n [[package]]\n name = \"unicode-ident\"\n-version = \"1.0.5\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3\"\n+checksum = \"84a22b9f218b40614adcb3f4ff08b703773ad44fa9423e4e0d346d5db86e4ebc\"\n \n [[package]]\n name = \"unicode-normalization\"\n@@ -2062,105 +2096,62 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"windows-sys\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n-dependencies = [\n- \"windows_aarch64_msvc 0.36.1\",\n- \"windows_i686_gnu 0.36.1\",\n- \"windows_i686_msvc 0.36.1\",\n- \"windows_x86_64_gnu 0.36.1\",\n- \"windows_x86_64_msvc 0.36.1\",\n-]\n-\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n  \"windows_aarch64_gnullvm\",\n- \"windows_aarch64_msvc 0.42.0\",\n- \"windows_i686_gnu 0.42.0\",\n- \"windows_i686_msvc 0.42.0\",\n- \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n  \"windows_x86_64_gnullvm\",\n- \"windows_x86_64_msvc 0.42.0\",\n+ \"windows_x86_64_msvc\",\n ]\n \n [[package]]\n name = \"windows_aarch64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+checksum = \"8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n-\n-[[package]]\n-name = \"windows_aarch64_msvc\"\n-version = \"0.42.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n-\n-[[package]]\n-name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+checksum = \"4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.42.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n-\n-[[package]]\n-name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+checksum = \"de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n+checksum = \"bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n-\n-[[package]]\n-name = \"windows_x86_64_gnu\"\n-version = \"0.42.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+checksum = \"c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45\"\n \n [[package]]\n name = \"windows_x86_64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n+checksum = \"628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n-\n-[[package]]\n-name = \"windows_x86_64_msvc\"\n-version = \"0.42.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n+checksum = \"447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd\"\n \n [[package]]\n name = \"write-json\"\n@@ -2170,40 +2161,41 @@ checksum = \"06069a848f95fceae3e5e03c0ddc8cb78452b56654ee0c8e68f938cf790fb9e3\"\n \n [[package]]\n name = \"xflags\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cbf19f5031a1a812e96fede16f8161218883079946cea87619d3613db1efd268\"\n+checksum = \"c4554b580522d0ca238369c16b8f6ce34524d61dafe7244993754bbd05f2c2ea\"\n dependencies = [\n  \"xflags-macros\",\n ]\n \n [[package]]\n name = \"xflags-macros\"\n-version = \"0.3.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2afbd7f2039bb6cad2dd45f0c5dff49c0d4e26118398768b7a605524d4251809\"\n+checksum = \"f58e7b3ca8977093aae6b87b6a7730216fc4c53a6530bab5c43a783cd810c1a8\"\n \n [[package]]\n name = \"xshell\"\n-version = \"0.2.2\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6d47097dc5c85234b1e41851b3422dd6d19b3befdd35b4ae5ce386724aeca981\"\n+checksum = \"962c039b3a7b16cf4e9a4248397c6585c07547412e7d6a6e035389a802dcfe90\"\n dependencies = [\n  \"xshell-macros\",\n ]\n \n [[package]]\n name = \"xshell-macros\"\n-version = \"0.2.2\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"88301b56c26dd9bf5c43d858538f82d6f3f7764767defbc5d34e59459901c41a\"\n+checksum = \"1dbabb1cbd15a1d6d12d9ed6b35cc6777d4af87ab3ba155ea37215f20beab80c\"\n \n [[package]]\n name = \"xtask\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"flate2\",\n+ \"time\",\n  \"write-json\",\n  \"xflags\",\n  \"xshell\",\n@@ -2212,9 +2204,9 @@ dependencies = [\n \n [[package]]\n name = \"zip\"\n-version = \"0.6.3\"\n+version = \"0.6.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"537ce7411d25e54e8ae21a7ce0b15840e7bfcff15b51d697ec3266cc76bdf080\"\n+checksum = \"0445d0fbc924bb93539b4316c11afb121ea39296f99a3c4c9edad09e3658cdef\"\n dependencies = [\n  \"byteorder\",\n  \"crc32fast\","}, {"sha": "ef81105505b03a684820bb220d161cf69386972c", "filename": "src/tools/rust-analyzer/Cargo.toml", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,6 +2,12 @@\n members = [\"xtask/\", \"lib/*\", \"crates/*\"]\n exclude = [\"crates/proc-macro-test/imp\"]\n \n+[workspace.package]\n+rust-version = \"1.66\"\n+edition = \"2021\"\n+license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer team\"]\n+\n [profile.dev]\n # Disabling debug info speeds up builds a bunch,\n # and we don't rely on it for debugging that much.\n@@ -32,3 +38,39 @@ debug = 0\n # ungrammar = { path = \"../ungrammar\" }\n \n # salsa = { path = \"../salsa\" }\n+\n+[workspace.dependencies]\n+# local crates\n+base-db = { path = \"./crates/base-db\", version = \"0.0.0\" }\n+cfg = { path = \"./crates/cfg\", version = \"0.0.0\" }\n+flycheck = { path = \"./crates/flycheck\", version = \"0.0.0\" }\n+hir = { path = \"./crates/hir\", version = \"0.0.0\" }\n+hir-def = { path = \"./crates/hir-def\", version = \"0.0.0\" }\n+hir-expand = { path = \"./crates/hir-expand\", version = \"0.0.0\" }\n+hir-ty = { path = \"./crates/hir-ty\", version = \"0.0.0\" }\n+ide = { path = \"./crates/ide\", version = \"0.0.0\" }\n+ide-assists = { path = \"./crates/ide-assists\", version = \"0.0.0\" }\n+ide-completion = { path = \"./crates/ide-completion\", version = \"0.0.0\" }\n+ide-db = { path = \"./crates/ide-db\", version = \"0.0.0\" }\n+ide-diagnostics = { path = \"./crates/ide-diagnostics\", version = \"0.0.0\" }\n+ide-ssr = { path = \"./crates/ide-ssr\", version = \"0.0.0\" }\n+intern = { path = \"./crates/intern\", version = \"0.0.0\" }\n+limit = { path = \"./crates/limit\", version = \"0.0.0\" }\n+mbe = { path = \"./crates/mbe\", version = \"0.0.0\" }\n+parser = { path = \"./crates/parser\", version = \"0.0.0\" }\n+paths = { path = \"./crates/paths\", version = \"0.0.0\" }\n+proc-macro-api = { path = \"./crates/proc-macro-api\", version = \"0.0.0\" }\n+proc-macro-srv = { path = \"./crates/proc-macro-srv\", version = \"0.0.0\" }\n+proc-macro-srv-cli = { path = \"./crates/proc-macro-srv-cli\", version = \"0.0.0\" }\n+proc-macro-test = { path = \"./crates/proc-macro-test\", version = \"0.0.0\" }\n+profile = { path = \"./crates/profile\", version = \"0.0.0\" }\n+project-model = { path = \"./crates/project-model\", version = \"0.0.0\" }\n+sourcegen = { path = \"./crates/sourcegen\", version = \"0.0.0\" }\n+stdx = { path = \"./crates/stdx\", version = \"0.0.0\" }\n+syntax = { path = \"./crates/syntax\", version = \"0.0.0\" }\n+test-utils = { path = \"./crates/test-utils\", version = \"0.0.0\" }\n+text-edit = { path = \"./crates/text-edit\", version = \"0.0.0\" }\n+toolchain = { path = \"./crates/toolchain\", version = \"0.0.0\" }\n+tt = { path = \"./crates/tt\", version = \"0.0.0\" }\n+vfs-notify = { path = \"./crates/vfs-notify\", version = \"0.0.0\" }\n+vfs = { path = \"./crates/vfs\", version = \"0.0.0\" }"}, {"sha": "f6a1075c190a8dc4f9af11d51ade457d8ea90655", "filename": "src/tools/rust-analyzer/crates/base-db/Cargo.toml", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"base-db\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -13,10 +15,11 @@ doctest = false\n salsa = \"0.17.0-pre.2\"\n rustc-hash = \"1.1.0\"\n \n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-cfg = { path = \"../cfg\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-tt = { path = \"../tt\", version = \"0.0.0\" }\n-test-utils = { path = \"../test-utils\", version = \"0.0.0\" }\n-vfs = { path = \"../vfs\", version = \"0.0.0\" }\n+# local deps\n+cfg.workspace = true\n+profile.workspace = true\n+stdx.workspace = true\n+syntax.workspace = true\n+test-utils.workspace = true\n+tt.workspace = true\n+vfs.workspace = true"}, {"sha": "8a7e9dfadfed2b79b39f423e029425782e702598", "filename": "src/tools/rust-analyzer/crates/base-db/src/fixture.rs", "status": "modified", "additions": 76, "deletions": 10, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -6,7 +6,7 @@ use rustc_hash::FxHashMap;\n use test_utils::{\n     extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER, ESCAPED_CURSOR_MARKER,\n };\n-use tt::Subtree;\n+use tt::token_id::{Leaf, Subtree, TokenTree};\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n@@ -110,6 +110,7 @@ impl ChangeFixture {\n         let mut crates = FxHashMap::default();\n         let mut crate_deps = Vec::new();\n         let mut default_crate_root: Option<FileId> = None;\n+        let mut default_target_data_layout: Option<String> = None;\n         let mut default_cfg = CfgOptions::default();\n \n         let mut file_set = FileSet::default();\n@@ -162,7 +163,10 @@ impl ChangeFixture {\n                     Ok(Vec::new()),\n                     false,\n                     origin,\n-                    meta.target_data_layout.as_deref().map(Arc::from),\n+                    meta.target_data_layout\n+                        .as_deref()\n+                        .map(Arc::from)\n+                        .ok_or_else(|| \"target_data_layout unset\".into()),\n                 );\n                 let prev = crates.insert(crate_name.clone(), crate_id);\n                 assert!(prev.is_none());\n@@ -175,6 +179,7 @@ impl ChangeFixture {\n                 assert!(default_crate_root.is_none());\n                 default_crate_root = Some(file_id);\n                 default_cfg = meta.cfg;\n+                default_target_data_layout = meta.target_data_layout;\n             }\n \n             change.change_file(file_id, Some(Arc::new(text)));\n@@ -198,7 +203,9 @@ impl ChangeFixture {\n                 Ok(Vec::new()),\n                 false,\n                 CrateOrigin::CratesIo { repo: None, name: None },\n-                None,\n+                default_target_data_layout\n+                    .map(|x| x.into())\n+                    .ok_or_else(|| \"target_data_layout unset\".into()),\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -212,8 +219,10 @@ impl ChangeFixture {\n                     .unwrap();\n             }\n         }\n-        let target_layout =\n-            crate_graph.iter().next().and_then(|it| crate_graph[it].target_layout.clone());\n+        let target_layout = crate_graph.iter().next().map_or_else(\n+            || Err(\"target_data_layout unset\".into()),\n+            |it| crate_graph[it].target_layout.clone(),\n+        );\n \n         if let Some(mini_core) = mini_core {\n             let core_file = file_id;\n@@ -301,7 +310,7 @@ impl ChangeFixture {\n     }\n }\n \n-fn default_test_proc_macros() -> [(String, ProcMacro); 4] {\n+fn default_test_proc_macros() -> [(String, ProcMacro); 5] {\n     [\n         (\n             r#\"\n@@ -359,6 +368,20 @@ pub fn mirror(input: TokenStream) -> TokenStream {\n                 expander: Arc::new(MirrorProcMacroExpander),\n             },\n         ),\n+        (\n+            r#\"\n+#[proc_macro]\n+pub fn shorten(input: TokenStream) -> TokenStream {\n+    loop {}\n+}\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"shorten\".into(),\n+                kind: crate::ProcMacroKind::FuncLike,\n+                expander: Arc::new(ShortenProcMacroExpander),\n+            },\n+        ),\n     ]\n }\n \n@@ -486,17 +509,60 @@ impl ProcMacroExpander for MirrorProcMacroExpander {\n         _: &Env,\n     ) -> Result<Subtree, ProcMacroExpansionError> {\n         fn traverse(input: &Subtree) -> Subtree {\n-            let mut res = Subtree::default();\n-            res.delimiter = input.delimiter;\n+            let mut token_trees = vec![];\n             for tt in input.token_trees.iter().rev() {\n                 let tt = match tt {\n                     tt::TokenTree::Leaf(leaf) => tt::TokenTree::Leaf(leaf.clone()),\n                     tt::TokenTree::Subtree(sub) => tt::TokenTree::Subtree(traverse(sub)),\n                 };\n-                res.token_trees.push(tt);\n+                token_trees.push(tt);\n             }\n-            res\n+            Subtree { delimiter: input.delimiter, token_trees }\n         }\n         Ok(traverse(input))\n     }\n }\n+\n+// Replaces every literal with an empty string literal and every identifier with its first letter,\n+// but retains all tokens' span. Useful for testing we don't assume token hasn't been modified by\n+// macros even if it retains its span.\n+#[derive(Debug)]\n+struct ShortenProcMacroExpander;\n+impl ProcMacroExpander for ShortenProcMacroExpander {\n+    fn expand(\n+        &self,\n+        input: &Subtree,\n+        _: Option<&Subtree>,\n+        _: &Env,\n+    ) -> Result<Subtree, ProcMacroExpansionError> {\n+        return Ok(traverse(input));\n+\n+        fn traverse(input: &Subtree) -> Subtree {\n+            let token_trees = input\n+                .token_trees\n+                .iter()\n+                .map(|it| match it {\n+                    TokenTree::Leaf(leaf) => tt::TokenTree::Leaf(modify_leaf(leaf)),\n+                    TokenTree::Subtree(subtree) => tt::TokenTree::Subtree(traverse(subtree)),\n+                })\n+                .collect();\n+            Subtree { delimiter: input.delimiter, token_trees }\n+        }\n+\n+        fn modify_leaf(leaf: &Leaf) -> Leaf {\n+            let mut leaf = leaf.clone();\n+            match &mut leaf {\n+                Leaf::Literal(it) => {\n+                    // XXX Currently replaces any literals with an empty string, but supporting\n+                    // \"shortening\" other literals would be nice.\n+                    it.text = \"\\\"\\\"\".into();\n+                }\n+                Leaf::Punct(_) => {}\n+                Leaf::Ident(it) => {\n+                    it.text = it.text.chars().take(1).collect();\n+                }\n+            }\n+            leaf\n+        }\n+    }\n+}"}, {"sha": "43388e915b5d3defb514554e39b660bc3ed8ab01", "filename": "src/tools/rust-analyzer/crates/base-db/src/input.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -12,7 +12,7 @@ use cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::SmolStr;\n-use tt::Subtree;\n+use tt::token_id::Subtree;\n use vfs::{file_set::FileSet, AnchoredPath, FileId, VfsPath};\n \n /// Files are grouped into source roots. A source root is a directory on the\n@@ -84,15 +84,10 @@ pub struct CrateGraph {\n     arena: NoHashHashMap<CrateId, CrateData>,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct CrateId(pub u32);\n \n impl stdx::hash::NoHashHashable for CrateId {}\n-impl std::hash::Hash for CrateId {\n-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n-        self.0.hash(state);\n-    }\n-}\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CrateName(SmolStr);\n@@ -248,6 +243,7 @@ pub enum ProcMacroExpansionError {\n }\n \n pub type ProcMacroLoadResult = Result<Vec<ProcMacro>, String>;\n+pub type TargetLayoutLoadResult = Result<Arc<str>, Arc<str>>;\n \n #[derive(Debug, Clone)]\n pub struct ProcMacro {\n@@ -270,7 +266,7 @@ pub struct CrateData {\n     pub display_name: Option<CrateDisplayName>,\n     pub cfg_options: CfgOptions,\n     pub potential_cfg_options: CfgOptions,\n-    pub target_layout: Option<Arc<str>>,\n+    pub target_layout: TargetLayoutLoadResult,\n     pub env: Env,\n     pub dependencies: Vec<Dependency>,\n     pub proc_macro: ProcMacroLoadResult,\n@@ -286,7 +282,7 @@ pub enum Edition {\n }\n \n impl Edition {\n-    pub const CURRENT: Edition = Edition::Edition2018;\n+    pub const CURRENT: Edition = Edition::Edition2021;\n }\n \n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n@@ -329,7 +325,7 @@ impl CrateGraph {\n         proc_macro: ProcMacroLoadResult,\n         is_proc_macro: bool,\n         origin: CrateOrigin,\n-        target_layout: Option<Arc<str>>,\n+        target_layout: Result<Arc<str>, Arc<str>>,\n     ) -> CrateId {\n         let data = CrateData {\n             root_file_id,\n@@ -652,7 +648,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -665,7 +661,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -678,7 +674,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -705,7 +701,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -718,7 +714,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -742,7 +738,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -755,7 +751,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         let crate3 = graph.add_crate_root(\n             FileId(3u32),\n@@ -768,7 +764,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         assert!(graph\n             .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n@@ -792,7 +788,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         let crate2 = graph.add_crate_root(\n             FileId(2u32),\n@@ -805,7 +801,7 @@ mod tests {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"\".into()),\n         );\n         assert!(graph\n             .add_dep("}, {"sha": "9720db9d8ace31a418f165d2ca6cbedcf5297eb3", "filename": "src/tools/rust-analyzer/crates/base-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -17,6 +17,7 @@ pub use crate::{\n         CrateData, CrateDisplayName, CrateGraph, CrateId, CrateName, CrateOrigin, Dependency,\n         Edition, Env, LangCrateOrigin, ProcMacro, ProcMacroExpander, ProcMacroExpansionError,\n         ProcMacroId, ProcMacroKind, ProcMacroLoadResult, SourceRoot, SourceRootId,\n+        TargetLayoutLoadResult,\n     },\n };\n pub use salsa::{self, Cancelled};"}, {"sha": "0880bc239d83f3426e98f1101c6131d40ab2c472", "filename": "src/tools/rust-analyzer/crates/cfg/Cargo.toml", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,25 +2,30 @@\n name = \"cfg\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n \n [dependencies]\n rustc-hash = \"1.1.0\"\n \n-tt = { path = \"../tt\", version = \"0.0.0\" }\n+# locals deps\n+tt.workspace = true\n \n [dev-dependencies]\n-mbe = { path = \"../mbe\" }\n-syntax = { path = \"../syntax\" }\n expect-test = \"1.4.0\"\n oorandom = \"11.1.3\"\n # We depend on both individually instead of using `features = [\"derive\"]` to microoptimize the\n # build graph: if the feature was enabled, syn would be built early on in the graph if `smolstr`\n # supports `arbitrary`. This way, we avoid feature unification.\n-arbitrary = \"1.1.7\"\n-derive_arbitrary = \"1.1.6\"\n+arbitrary = \"1.2.2\"\n+derive_arbitrary = \"1.2.2\"\n+\n+# local deps\n+mbe.workspace = true\n+syntax.workspace = true"}, {"sha": "fb7505ba2dd5b0c9558e3b44f758b4ba61633de7", "filename": "src/tools/rust-analyzer/crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -66,7 +66,7 @@ impl From<CfgAtom> for CfgExpr {\n }\n \n impl CfgExpr {\n-    pub fn parse(tt: &tt::Subtree) -> CfgExpr {\n+    pub fn parse<S>(tt: &tt::Subtree<S>) -> CfgExpr {\n         next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n     }\n     /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n@@ -85,7 +85,7 @@ impl CfgExpr {\n     }\n }\n \n-fn next_cfg_expr(it: &mut SliceIter<'_, tt::TokenTree>) -> Option<CfgExpr> {\n+fn next_cfg_expr<S>(it: &mut SliceIter<'_, tt::TokenTree<S>>) -> Option<CfgExpr> {\n     let name = match it.next() {\n         None => return None,\n         Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),"}, {"sha": "609d18c4eea33164bbb2d4bf582f2c0b144894e6", "filename": "src/tools/rust-analyzer/crates/flycheck/Cargo.toml", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"flycheck\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -17,8 +19,9 @@ rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = \"1.0.86\"\n jod-thread = \"0.1.2\"\n-command-group = \"1.0.8\"\n+command-group = \"2.0.1\"\n \n-toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-paths = { path = \"../paths\", version = \"0.0.0\" }\n+# local deps\n+paths.workspace = true\n+stdx.workspace = true\n+toolchain.workspace = true"}, {"sha": "1daf0428c242f296eab7ef466516f542c4ec2676", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"hir-def\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -23,23 +25,28 @@ hashbrown = { version = \"0.12.1\", default-features = false }\n indexmap = \"1.9.1\"\n itertools = \"0.10.5\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-once_cell = \"1.15.0\"\n+once_cell = \"1.17.0\"\n rustc-hash = \"1.1.0\"\n smallvec = \"1.10.0\"\n tracing = \"0.1.35\"\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-base-db = { path = \"../base-db\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-hir-expand = { path = \"../hir-expand\", version = \"0.0.0\" }\n rustc_abi = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_abi\", default-features = false }\n rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n-mbe = { path = \"../mbe\", version = \"0.0.0\" }\n-cfg = { path = \"../cfg\", version = \"0.0.0\" }\n-tt = { path = \"../tt\", version = \"0.0.0\" }\n-limit = { path = \"../limit\", version = \"0.0.0\" }\n+\n+# local deps\n+stdx.workspace = true\n+intern.workspace = true\n+base-db.workspace = true\n+syntax.workspace = true\n+profile.workspace = true\n+hir-expand.workspace = true\n+mbe.workspace = true\n+cfg.workspace = true\n+tt.workspace = true\n+limit.workspace = true\n \n [dev-dependencies]\n-test-utils = { path = \"../test-utils\" }\n expect-test = \"1.4.0\"\n+\n+# local deps\n+test-utils.workspace = true"}, {"sha": "dcea679567a53a8c9937b904c32d99afb3693ce9", "filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,22 +2,22 @@\n \n use std::sync::Arc;\n \n+use crate::tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     name::{AsName, Name},\n     HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::{Arena, ArenaMap};\n use rustc_abi::{Integer, IntegerType};\n use syntax::ast::{self, HasName, HasVisibility};\n-use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n     builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n-    intern::Interned,\n     item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n     layout::{Align, ReprFlags, ReprOptions},\n     nameres::diagnostics::DefDiagnostic,\n@@ -82,7 +82,7 @@ fn repr_from_value(\n \n fn parse_repr_tt(tt: &Subtree) -> Option<ReprOptions> {\n     match tt.delimiter {\n-        Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n+        Delimiter { kind: DelimiterKind::Parenthesis, .. } => {}\n         _ => return None,\n     }\n "}, {"sha": "fcd92ad338583923b5522a324fe22e83dc1a8423", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr.rs", "status": "modified", "additions": 32, "deletions": 328, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,27 +1,26 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n \n-use std::{fmt, hash::Hash, ops, sync::Arc};\n+use std::{hash::Hash, ops, sync::Arc};\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n+use hir_expand::{\n+    attrs::{collect_attrs, Attr, AttrId, RawAttrs},\n+    HirFileId, InFile,\n+};\n use itertools::Itertools;\n use la_arena::{ArenaMap, Idx, RawIdx};\n-use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n-use smallvec::{smallvec, SmallVec};\n+use mbe::DelimiterKind;\n use syntax::{\n-    ast::{self, AstNode, HasAttrs, IsString},\n-    match_ast, AstPtr, AstToken, SmolStr, SyntaxNode, TextRange, TextSize,\n+    ast::{self, HasAttrs, IsString},\n+    AstPtr, AstToken, SmolStr, TextRange, TextSize,\n };\n-use tt::Subtree;\n \n use crate::{\n     db::DefDatabase,\n-    intern::Interned,\n     item_tree::{AttrOwner, Fields, ItemTreeId, ItemTreeNode},\n     nameres::{ModuleOrigin, ModuleSource},\n-    path::{ModPath, PathKind},\n     src::{HasChildSource, HasSource},\n     AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n     VariantId,\n@@ -47,12 +46,6 @@ impl From<Documentation> for String {\n     }\n }\n \n-/// Syntactical attributes, without filtering of `cfg_attr`s.\n-#[derive(Default, Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct RawAttrs {\n-    entries: Option<Arc<[Attr]>>,\n-}\n-\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct Attrs(RawAttrs);\n \n@@ -62,30 +55,21 @@ pub struct AttrsWithOwner {\n     owner: AttrDefId,\n }\n \n-impl ops::Deref for RawAttrs {\n-    type Target = [Attr];\n-\n-    fn deref(&self) -> &[Attr] {\n-        match &self.entries {\n-            Some(it) => &*it,\n-            None => &[],\n-        }\n-    }\n-}\n impl Attrs {\n     pub fn get(&self, id: AttrId) -> Option<&Attr> {\n         (**self).iter().find(|attr| attr.id == id)\n     }\n+\n+    pub(crate) fn filter(db: &dyn DefDatabase, krate: CrateId, raw_attrs: RawAttrs) -> Attrs {\n+        Attrs(raw_attrs.filter(db.upcast(), krate))\n+    }\n }\n \n impl ops::Deref for Attrs {\n     type Target = [Attr];\n \n     fn deref(&self) -> &[Attr] {\n-        match &self.0.entries {\n-            Some(it) => &*it,\n-            None => &[],\n-        }\n+        &self.0\n     }\n }\n \n@@ -97,114 +81,6 @@ impl ops::Deref for AttrsWithOwner {\n     }\n }\n \n-impl RawAttrs {\n-    pub(crate) const EMPTY: Self = Self { entries: None };\n-\n-    pub(crate) fn new(db: &dyn DefDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n-        let entries = collect_attrs(owner)\n-            .filter_map(|(id, attr)| match attr {\n-                Either::Left(attr) => {\n-                    attr.meta().and_then(|meta| Attr::from_src(db, meta, hygiene, id))\n-                }\n-                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n-                    id,\n-                    input: Some(Interned::new(AttrInput::Literal(SmolStr::new(doc)))),\n-                    path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n-                }),\n-            })\n-            .collect::<Arc<_>>();\n-\n-        Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n-    }\n-\n-    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n-        let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n-        Self::new(db, owner.value, &hygiene)\n-    }\n-\n-    pub(crate) fn merge(&self, other: Self) -> Self {\n-        // FIXME: This needs to fixup `AttrId`s\n-        match (&self.entries, other.entries) {\n-            (None, None) => Self::EMPTY,\n-            (None, entries @ Some(_)) => Self { entries },\n-            (Some(entries), None) => Self { entries: Some(entries.clone()) },\n-            (Some(a), Some(b)) => {\n-                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index + 1);\n-                Self {\n-                    entries: Some(\n-                        a.iter()\n-                            .cloned()\n-                            .chain(b.iter().map(|it| {\n-                                let mut it = it.clone();\n-                                it.id.ast_index += last_ast_index;\n-                                it\n-                            }))\n-                            .collect(),\n-                    ),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n-    pub(crate) fn filter(self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n-        let has_cfg_attrs = self.iter().any(|attr| {\n-            attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr])\n-        });\n-        if !has_cfg_attrs {\n-            return Attrs(self);\n-        }\n-\n-        let crate_graph = db.crate_graph();\n-        let new_attrs = self\n-            .iter()\n-            .flat_map(|attr| -> SmallVec<[_; 1]> {\n-                let is_cfg_attr =\n-                    attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr]);\n-                if !is_cfg_attr {\n-                    return smallvec![attr.clone()];\n-                }\n-\n-                let subtree = match attr.token_tree_value() {\n-                    Some(it) => it,\n-                    _ => return smallvec![attr.clone()],\n-                };\n-\n-                // Input subtree is: `(cfg, $(attr),+)`\n-                // Split it up into a `cfg` subtree and the `attr` subtrees.\n-                // FIXME: There should be a common API for this.\n-                let mut parts = subtree.token_trees.split(|tt| {\n-                    matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })))\n-                });\n-                let cfg = match parts.next() {\n-                    Some(it) => it,\n-                    None => return smallvec![],\n-                };\n-                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n-                let cfg = CfgExpr::parse(&cfg);\n-                let index = attr.id;\n-                let attrs = parts.filter(|a| !a.is_empty()).filter_map(|attr| {\n-                    let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n-                    // FIXME hygiene\n-                    let hygiene = Hygiene::new_unhygienic();\n-                    Attr::from_tt(db, &tree, &hygiene, index)\n-                });\n-\n-                let cfg_options = &crate_graph[krate].cfg_options;\n-                if cfg_options.check(&cfg) == Some(false) {\n-                    smallvec![]\n-                } else {\n-                    cov_mark::hit!(cfg_attr_active);\n-\n-                    attrs.collect()\n-                }\n-            })\n-            .collect();\n-\n-        Attrs(RawAttrs { entries: Some(new_attrs) })\n-    }\n-}\n-\n impl Attrs {\n     pub const EMPTY: Self = Self(RawAttrs::EMPTY);\n \n@@ -251,19 +127,18 @@ impl Attrs {\n                 let enum_ = &item_tree[loc.id.value];\n \n                 let cfg_options = &crate_graph[krate].cfg_options;\n-                let variant = 'tri: loop {\n-                    let mut idx = 0;\n-                    for variant in enum_.variants.clone() {\n-                        let attrs = item_tree.attrs(db, krate, variant.into());\n-                        if attrs.is_cfg_enabled(cfg_options) {\n-                            if it.local_id == Idx::from_raw(RawIdx::from(idx)) {\n-                                break 'tri variant;\n-                            }\n-                            idx += 1;\n-                        }\n-                    }\n+\n+                let Some(variant) = enum_.variants.clone().filter(|variant| {\n+                    let attrs = item_tree.attrs(db, krate, (*variant).into());\n+                    attrs.is_cfg_enabled(cfg_options)\n+                })\n+                .zip(0u32..)\n+                .find(|(_variant, idx)| it.local_id == Idx::from_raw(RawIdx::from(*idx)))\n+                .map(|(variant, _idx)| variant)\n+                else {\n                     return Arc::new(res);\n                 };\n+\n                 (item_tree[variant].fields.clone(), item_tree, krate)\n             }\n             VariantId::StructId(it) => {\n@@ -358,7 +233,7 @@ impl Attrs {\n \n     pub fn has_doc_hidden(&self) -> bool {\n         self.by_key(\"doc\").tt_values().any(|tt| {\n-            tt.delimiter_kind() == Some(DelimiterKind::Parenthesis) &&\n+            tt.delimiter.kind == DelimiterKind::Parenthesis &&\n                 matches!(&*tt.token_trees, [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] if ident.text == \"hidden\")\n         })\n     }\n@@ -403,7 +278,7 @@ impl AttrsWithOwner {\n                         .raw_attrs(AttrOwner::ModItem(definition_tree_id.value.into()))\n                         .clone(),\n                     ModuleOrigin::BlockExpr { block } => RawAttrs::from_attrs_owner(\n-                        db,\n+                        db.upcast(),\n                         InFile::new(block.file_id, block.to_node(db.upcast()))\n                             .as_ref()\n                             .map(|it| it as &dyn ast::HasAttrs),\n@@ -439,7 +314,7 @@ impl AttrsWithOwner {\n                 GenericParamId::ConstParamId(it) => {\n                     let src = it.parent().child_source(db);\n                     RawAttrs::from_attrs_owner(\n-                        db,\n+                        db.upcast(),\n                         src.with_value(src.value[it.local_id()].as_ref().either(\n                             |it| match it {\n                                 ast::TypeOrConstParam::Type(it) => it as _,\n@@ -452,7 +327,7 @@ impl AttrsWithOwner {\n                 GenericParamId::TypeParamId(it) => {\n                     let src = it.parent().child_source(db);\n                     RawAttrs::from_attrs_owner(\n-                        db,\n+                        db.upcast(),\n                         src.with_value(src.value[it.local_id()].as_ref().either(\n                             |it| match it {\n                                 ast::TypeOrConstParam::Type(it) => it as _,\n@@ -464,14 +339,14 @@ impl AttrsWithOwner {\n                 }\n                 GenericParamId::LifetimeParamId(it) => {\n                     let src = it.parent.child_source(db);\n-                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n+                    RawAttrs::from_attrs_owner(db.upcast(), src.with_value(&src.value[it.local_id]))\n                 }\n             },\n             AttrDefId::ExternBlockId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n         };\n \n-        let attrs = raw_attrs.filter(db, def.krate(db));\n-        Self { attrs, owner: def }\n+        let attrs = raw_attrs.filter(db.upcast(), def.krate(db));\n+        Self { attrs: Attrs(attrs), owner: def }\n     }\n \n     pub fn source_map(&self, db: &dyn DefDatabase) -> AttrSourceMap {\n@@ -627,40 +502,6 @@ fn doc_indent(attrs: &Attrs) -> usize {\n         .unwrap_or(0)\n }\n \n-fn inner_attributes(\n-    syntax: &SyntaxNode,\n-) -> Option<impl Iterator<Item = Either<ast::Attr, ast::Comment>>> {\n-    let node = match_ast! {\n-        match syntax {\n-            ast::SourceFile(_) => syntax.clone(),\n-            ast::ExternBlock(it) => it.extern_item_list()?.syntax().clone(),\n-            ast::Fn(it) => it.body()?.stmt_list()?.syntax().clone(),\n-            ast::Impl(it) => it.assoc_item_list()?.syntax().clone(),\n-            ast::Module(it) => it.item_list()?.syntax().clone(),\n-            ast::BlockExpr(it) => {\n-                use syntax::SyntaxKind::{BLOCK_EXPR , EXPR_STMT};\n-                // Block expressions accept outer and inner attributes, but only when they are the outer\n-                // expression of an expression statement or the final expression of another block expression.\n-                let may_carry_attributes = matches!(\n-                    it.syntax().parent().map(|it| it.kind()),\n-                     Some(BLOCK_EXPR | EXPR_STMT)\n-                );\n-                if !may_carry_attributes {\n-                    return None\n-                }\n-                syntax.clone()\n-            },\n-            _ => return None,\n-        }\n-    };\n-\n-    let attrs = ast::AttrDocCommentIter::from_syntax_node(&node).filter(|el| match el {\n-        Either::Left(attr) => attr.kind().is_inner(),\n-        Either::Right(comment) => comment.is_inner(),\n-    });\n-    Some(attrs)\n-}\n-\n #[derive(Debug)]\n pub struct AttrSourceMap {\n     source: Vec<Either<ast::Attr, ast::Comment>>,\n@@ -703,7 +544,7 @@ impl AttrSourceMap {\n     }\n \n     fn source_of_id(&self, id: AttrId) -> InFile<&Either<ast::Attr, ast::Comment>> {\n-        let ast_idx = id.ast_index as usize;\n+        let ast_idx = id.ast_index();\n         let file_id = match self.mod_def_site_file_id {\n             Some((file_id, def_site_cut)) if def_site_cut <= ast_idx => file_id,\n             _ => self.file_id,\n@@ -779,136 +620,14 @@ fn get_doc_string_in_attr(it: &ast::Attr) -> Option<ast::String> {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct AttrId {\n-    pub(crate) ast_index: u32,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct Attr {\n-    pub(crate) id: AttrId,\n-    pub(crate) path: Interned<ModPath>,\n-    pub(crate) input: Option<Interned<AttrInput>>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum AttrInput {\n-    /// `#[attr = \"string\"]`\n-    Literal(SmolStr),\n-    /// `#[attr(subtree)]`\n-    TokenTree(tt::Subtree, mbe::TokenMap),\n-}\n-\n-impl fmt::Display for AttrInput {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            AttrInput::Literal(lit) => write!(f, \" = \\\"{}\\\"\", lit.escape_debug()),\n-            AttrInput::TokenTree(subtree, _) => subtree.fmt(f),\n-        }\n-    }\n-}\n-\n-impl Attr {\n-    fn from_src(\n-        db: &dyn DefDatabase,\n-        ast: ast::Meta,\n-        hygiene: &Hygiene,\n-        id: AttrId,\n-    ) -> Option<Attr> {\n-        let path = Interned::new(ModPath::from_src(db.upcast(), ast.path()?, hygiene)?);\n-        let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n-            let value = match lit.kind() {\n-                ast::LiteralKind::String(string) => string.value()?.into(),\n-                _ => lit.syntax().first_token()?.text().trim_matches('\"').into(),\n-            };\n-            Some(Interned::new(AttrInput::Literal(value)))\n-        } else if let Some(tt) = ast.token_tree() {\n-            let (tree, map) = syntax_node_to_token_tree(tt.syntax());\n-            Some(Interned::new(AttrInput::TokenTree(tree, map)))\n-        } else {\n-            None\n-        };\n-        Some(Attr { id, path, input })\n-    }\n-\n-    fn from_tt(\n-        db: &dyn DefDatabase,\n-        tt: &tt::Subtree,\n-        hygiene: &Hygiene,\n-        id: AttrId,\n-    ) -> Option<Attr> {\n-        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MetaItem);\n-        let ast = ast::Meta::cast(parse.syntax_node())?;\n-\n-        Self::from_src(db, ast, hygiene, id)\n-    }\n-\n-    pub fn path(&self) -> &ModPath {\n-        &self.path\n-    }\n-}\n-\n-impl Attr {\n-    /// #[path = \"string\"]\n-    pub fn string_value(&self) -> Option<&SmolStr> {\n-        match self.input.as_deref()? {\n-            AttrInput::Literal(it) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    /// #[path(ident)]\n-    pub fn single_ident_value(&self) -> Option<&tt::Ident> {\n-        match self.input.as_deref()? {\n-            AttrInput::TokenTree(subtree, _) => match &*subtree.token_trees {\n-                [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] => Some(ident),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// #[path TokenTree]\n-    pub fn token_tree_value(&self) -> Option<&Subtree> {\n-        match self.input.as_deref()? {\n-            AttrInput::TokenTree(subtree, _) => Some(subtree),\n-            _ => None,\n-        }\n-    }\n-\n-    /// Parses this attribute as a token tree consisting of comma separated paths.\n-    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n-        let args = self.token_tree_value()?;\n-\n-        if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n-            return None;\n-        }\n-        let paths = args\n-            .token_trees\n-            .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))\n-            .filter_map(|tts| {\n-                if tts.is_empty() {\n-                    return None;\n-                }\n-                let segments = tts.iter().filter_map(|tt| match tt {\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n-                    _ => None,\n-                });\n-                Some(ModPath::from_segments(PathKind::Plain, segments))\n-            });\n-\n-        Some(paths)\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy)]\n pub struct AttrQuery<'attr> {\n     attrs: &'attr Attrs,\n     key: &'static str,\n }\n \n impl<'attr> AttrQuery<'attr> {\n-    pub fn tt_values(self) -> impl Iterator<Item = &'attr Subtree> {\n+    pub fn tt_values(self) -> impl Iterator<Item = &'attr crate::tt::Subtree> {\n         self.attrs().filter_map(|attr| attr.token_tree_value())\n     }\n \n@@ -953,21 +672,6 @@ fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase\n     tree.raw_attrs(mod_item.into()).clone()\n }\n \n-fn collect_attrs(\n-    owner: &dyn ast::HasAttrs,\n-) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {\n-    let inner_attrs = inner_attributes(owner.syntax()).into_iter().flatten();\n-    let outer_attrs =\n-        ast::AttrDocCommentIter::from_syntax_node(owner.syntax()).filter(|el| match el {\n-            Either::Left(attr) => attr.kind().is_outer(),\n-            Either::Right(comment) => comment.is_outer(),\n-        });\n-    outer_attrs\n-        .chain(inner_attrs)\n-        .enumerate()\n-        .map(|(id, attr)| (AttrId { ast_index: id as u32 }, attr))\n-}\n-\n pub(crate) fn variants_attrs_source_map(\n     db: &dyn DefDatabase,\n     def: EnumId,"}, {"sha": "9713256813eb6ce4c0d1eca93a277165c20e7150", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -12,15 +12,17 @@ use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n-use hir_expand::{hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId};\n+use hir_expand::{\n+    attrs::RawAttrs, hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId,\n+};\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n use crate::{\n-    attr::{Attrs, RawAttrs},\n+    attr::Attrs,\n     db::DefDatabase,\n     expr::{dummy_expr_id, Expr, ExprId, Label, LabelId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n@@ -64,7 +66,7 @@ impl CfgExpander {\n     }\n \n     pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n-        RawAttrs::new(db, owner, &self.hygiene).filter(db, self.krate)\n+        Attrs::filter(db, self.krate, RawAttrs::new(db.upcast(), owner, &self.hygiene))\n     }\n \n     pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> bool {"}, {"sha": "a78fa91f53bd001eea337eea93bb84c27d7371d9", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -10,6 +10,7 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     AstId, ExpandError, HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use profile::Count;\n@@ -33,7 +34,6 @@ use crate::{\n         Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n         Statement,\n     },\n-    intern::Interned,\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n@@ -67,9 +67,9 @@ impl<'a> LowerCtx<'a> {\n         Path::from_src(ast, self)\n     }\n \n-    pub(crate) fn ast_id<N: AstNode>(&self, db: &dyn DefDatabase, item: &N) -> Option<AstId<N>> {\n+    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> Option<AstId<N>> {\n         let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n-        let ast_id_map = ast_id_map.get_or_init(|| db.ast_id_map(file_id));\n+        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n         Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n     }\n }"}, {"sha": "4b4664a1cf4a6d54b4f03f7ab2ec49d695f4ec54", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -80,7 +80,7 @@ impl<'a> Write for Printer<'a> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         for line in s.split_inclusive('\\n') {\n             if self.needs_indent {\n-                match self.buf.chars().rev().skip_while(|ch| *ch == ' ').next() {\n+                match self.buf.chars().rev().find(|ch| *ch != ' ') {\n                     Some('\\n') | None => {}\n                     _ => self.buf.push('\\n'),\n                 }\n@@ -113,7 +113,7 @@ impl<'a> Printer<'a> {\n     }\n \n     fn newline(&mut self) {\n-        match self.buf.chars().rev().skip_while(|ch| *ch == ' ').next() {\n+        match self.buf.chars().rev().find(|ch| *ch != ' ') {\n             Some('\\n') | None => {}\n             _ => writeln!(self).unwrap(),\n         }"}, {"sha": "19d2fe956f098b964a6e773f57acbbcf1304b044", "filename": "src/tools/rust-analyzer/crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -117,7 +117,7 @@ impl ChildBySource for ItemScope {\n                 let adt = ast_id.to_node(db.upcast());\n                 calls.for_each(|(attr_id, call_id, calls)| {\n                     if let Some(Either::Left(attr)) =\n-                        adt.doc_comments_and_attrs().nth(attr_id.ast_index as usize)\n+                        adt.doc_comments_and_attrs().nth(attr_id.ast_index())\n                     {\n                         res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, call_id, calls.into()));\n                     }"}, {"sha": "c3c1dfd39ac0b0c4ebca76b89485574d66100eb8", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,14 +3,14 @@\n use std::sync::Arc;\n \n use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n+use intern::Interned;\n use smallvec::SmallVec;\n use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n     body::{Expander, Mark},\n     db::DefDatabase,\n-    intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n     nameres::{\n         attr_resolution::ResolvedAttr,\n@@ -142,7 +142,7 @@ impl FunctionData {\n     }\n }\n \n-fn parse_rustc_legacy_const_generics(tt: &tt::Subtree) -> Box<[u32]> {\n+fn parse_rustc_legacy_const_generics(tt: &crate::tt::Subtree) -> Box<[u32]> {\n     let mut indices = Vec::new();\n     for args in tt.token_trees.chunks(2) {\n         match &args[0] {"}, {"sha": "b23427a73b3456f307009aadc51b93bdc301f50d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,8 +4,9 @@ use std::sync::Arc;\n use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n use either::Either;\n use hir_expand::{db::AstDatabase, HirFileId};\n+use intern::Interned;\n use la_arena::ArenaMap;\n-use syntax::{ast, AstPtr, SmolStr};\n+use syntax::{ast, AstPtr};\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -17,9 +18,8 @@ use crate::{\n     },\n     generics::GenericParams,\n     import_map::ImportMap,\n-    intern::Interned,\n     item_tree::{AttrOwner, ItemTree},\n-    lang_item::{LangItemTarget, LangItems},\n+    lang_item::{LangItem, LangItemTarget, LangItems},\n     nameres::{diagnostics::DefDiagnostic, DefMap},\n     visibility::{self, Visibility},\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n@@ -183,7 +183,7 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n \n     #[salsa::invoke(LangItems::lang_item_query)]\n-    fn lang_item(&self, start_crate: CrateId, item: SmolStr) -> Option<LangItemTarget>;\n+    fn lang_item(&self, start_crate: CrateId, item: LangItem) -> Option<LangItemTarget>;\n \n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;"}, {"sha": "48028b7c6a82a5c8dc961c7f6f2ede60489a9aa7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -15,11 +15,11 @@\n use std::fmt;\n \n use hir_expand::name::Name;\n+use intern::Interned;\n use la_arena::{Idx, RawIdx};\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n-    intern::Interned,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     BlockId,"}, {"sha": "3f439232083719cc6f269695d416538be4443c9a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/find_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -811,7 +811,7 @@ pub struct S;\n     fn prelude() {\n         check_found_path(\n             r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n $0\n //- /std.rs crate:std\n pub mod prelude {\n@@ -852,7 +852,7 @@ pub mod prelude {\n     fn imported_prelude() {\n         check_found_path(\n             r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n use S;\n $0\n //- /std.rs crate:std\n@@ -872,7 +872,7 @@ pub mod prelude {\n     #[test]\n     fn enum_variant_from_prelude() {\n         let code = r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n $0\n //- /std.rs crate:std\n pub mod prelude {\n@@ -1273,7 +1273,7 @@ fn f() {\n     fn prelude_with_inner_items() {\n         check_found_path(\n             r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n fn f() {\n     fn inner() {}\n     $0"}, {"sha": "b2ab0c30e0370c02ddadba6d425c005115e8c6b4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -9,6 +9,7 @@ use hir_expand::{\n     name::{AsName, Name},\n     ExpandResult, HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::{Arena, ArenaMap, Idx};\n use once_cell::unsync::Lazy;\n use std::ops::DerefMut;\n@@ -20,7 +21,6 @@ use crate::{\n     child_by_source::ChildBySource,\n     db::DefDatabase,\n     dyn_map::DynMap,\n-    intern::Interned,\n     keys,\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},"}, {"sha": "53a4173ff4230f8c3c896200590f0875e52cb350", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,7 +4,7 @@\n use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n-use hir_expand::{name::Name, AstId, MacroCallId};\n+use hir_expand::{attrs::AttrId, name::Name, AstId, MacroCallId};\n use itertools::Itertools;\n use once_cell::sync::Lazy;\n use profile::Count;\n@@ -14,8 +14,8 @@ use stdx::format_to;\n use syntax::ast;\n \n use crate::{\n-    attr::AttrId, db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType,\n-    ConstId, HasModule, ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n+    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ConstId, HasModule,\n+    ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n };\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "19d01630ef0885bed9c4d5286d9e99d05c453f7e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -48,10 +48,12 @@ use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::FileAstId,\n+    attrs::RawAttrs,\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     ExpandTo, HirFileId, InFile,\n };\n+use intern::Interned;\n use la_arena::{Arena, Idx, IdxRange, RawIdx};\n use profile::Count;\n use rustc_hash::FxHashMap;\n@@ -60,10 +62,9 @@ use stdx::never;\n use syntax::{ast, match_ast, SyntaxKind};\n \n use crate::{\n-    attr::{Attrs, RawAttrs},\n+    attr::Attrs,\n     db::DefDatabase,\n     generics::GenericParams,\n-    intern::Interned,\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n     type_ref::{Mutability, TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -110,7 +111,8 @@ impl ItemTree {\n             Some(node) => node,\n             None => return Default::default(),\n         };\n-        if never!(syntax.kind() == SyntaxKind::ERROR) {\n+        if never!(syntax.kind() == SyntaxKind::ERROR, \"{:?} from {:?} {}\", file_id, syntax, syntax)\n+        {\n             // FIXME: not 100% sure why these crop up, but return an empty tree to avoid a panic\n             return Default::default();\n         }\n@@ -120,7 +122,7 @@ impl ItemTree {\n         let mut item_tree = match_ast! {\n             match syntax {\n                 ast::SourceFile(file) => {\n-                    top_attrs = Some(RawAttrs::new(db, &file, ctx.hygiene()));\n+                    top_attrs = Some(RawAttrs::new(db.upcast(), &file, ctx.hygiene()));\n                     ctx.lower_module_items(&file)\n                 },\n                 ast::MacroItems(items) => {\n@@ -132,7 +134,7 @@ impl ItemTree {\n                     ctx.lower_macro_stmts(stmts)\n                 },\n                 _ => {\n-                    panic!(\"cannot create item tree from {syntax:?} {syntax}\");\n+                    panic!(\"cannot create item tree for file {file_id:?} from {syntax:?} {syntax}\");\n                 },\n             }\n         };\n@@ -152,15 +154,19 @@ impl ItemTree {\n \n     /// Returns the inner attributes of the source file.\n     pub fn top_level_attrs(&self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n-        self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&RawAttrs::EMPTY).clone().filter(db, krate)\n+        Attrs::filter(\n+            db,\n+            krate,\n+            self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&RawAttrs::EMPTY).clone(),\n+        )\n     }\n \n     pub(crate) fn raw_attrs(&self, of: AttrOwner) -> &RawAttrs {\n         self.attrs.get(&of).unwrap_or(&RawAttrs::EMPTY)\n     }\n \n     pub(crate) fn attrs(&self, db: &dyn DefDatabase, krate: CrateId, of: AttrOwner) -> Attrs {\n-        self.raw_attrs(of).clone().filter(db, krate)\n+        Attrs::filter(db, krate, self.raw_attrs(of).clone())\n     }\n \n     pub fn pretty_print(&self) -> String {"}, {"sha": "27705cbbbdc587b1fffd3eaa8958893fedba3ece", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -99,7 +99,7 @@ impl<'a> Ctx<'a> {\n     }\n \n     fn lower_mod_item(&mut self, item: &ast::Item) -> Option<ModItem> {\n-        let attrs = RawAttrs::new(self.db, item, self.hygiene());\n+        let attrs = RawAttrs::new(self.db.upcast(), item, self.hygiene());\n         let item: ModItem = match item {\n             ast::Item::Struct(ast) => self.lower_struct(ast)?.into(),\n             ast::Item::Union(ast) => self.lower_union(ast)?.into(),\n@@ -173,7 +173,7 @@ impl<'a> Ctx<'a> {\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n                 let idx = self.data().fields.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &field, self.hygiene()));\n             }\n         }\n         let end = self.next_field_idx();\n@@ -194,7 +194,7 @@ impl<'a> Ctx<'a> {\n         for (i, field) in fields.fields().enumerate() {\n             let data = self.lower_tuple_field(i, &field);\n             let idx = self.data().fields.alloc(data);\n-            self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n+            self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &field, self.hygiene()));\n         }\n         let end = self.next_field_idx();\n         IdxRange::new(start..end)\n@@ -239,7 +239,10 @@ impl<'a> Ctx<'a> {\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n                 let idx = self.data().variants.alloc(data);\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &variant, self.hygiene()));\n+                self.add_attrs(\n+                    idx.into(),\n+                    RawAttrs::new(self.db.upcast(), &variant, self.hygiene()),\n+                );\n             }\n         }\n         let end = self.next_variant_idx();\n@@ -283,7 +286,10 @@ impl<'a> Ctx<'a> {\n                 };\n                 let ty = Interned::new(self_type);\n                 let idx = self.data().params.alloc(Param::Normal(None, ty));\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &self_param, self.hygiene()));\n+                self.add_attrs(\n+                    idx.into(),\n+                    RawAttrs::new(self.db.upcast(), &self_param, self.hygiene()),\n+                );\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n@@ -307,7 +313,7 @@ impl<'a> Ctx<'a> {\n                         self.data().params.alloc(Param::Normal(name, ty))\n                     }\n                 };\n-                self.add_attrs(idx.into(), RawAttrs::new(self.db, &param, self.hygiene()));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &param, self.hygiene()));\n             }\n         }\n         let end_param = self.next_param_idx();\n@@ -442,7 +448,7 @@ impl<'a> Ctx<'a> {\n         let items = trait_def.assoc_item_list().map(|list| {\n             list.assoc_items()\n                 .filter_map(|item| {\n-                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                    let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n                     self.lower_assoc_item(&item).map(|item| {\n                         self.add_attrs(ModItem::from(item).into(), attrs);\n                         item\n@@ -471,7 +477,7 @@ impl<'a> Ctx<'a> {\n             .flat_map(|it| it.assoc_items())\n             .filter_map(|item| {\n                 let assoc = self.lower_assoc_item(&item)?;\n-                let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n                 self.add_attrs(ModItem::from(assoc).into(), attrs);\n                 Some(assoc)\n             })\n@@ -541,7 +547,7 @@ impl<'a> Ctx<'a> {\n                     // (in other words, the knowledge that they're in an extern block must not be used).\n                     // This is because an extern block can contain macros whose ItemTree's top-level items\n                     // should be considered to be in an extern block too.\n-                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                    let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n                     let id: ModItem = match item {\n                         ast::ExternItem::Fn(ast) => self.lower_function(&ast)?.into(),\n                         ast::ExternItem::Static(ast) => self.lower_static(&ast)?.into(),"}, {"sha": "8f230b87d0101da7fd15ffdc22b9285b61643d4c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,7 +3,6 @@\n use std::fmt::{self, Write};\n \n use crate::{\n-    attr::RawAttrs,\n     generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n     pretty::{print_path, print_type_bounds, print_type_ref},\n     visibility::RawVisibility,"}, {"sha": "72beec8186c1fa09f14038f5a625ae77aa94bce2", "filename": "src/tools/rust-analyzer/crates/hir-def/src/keys.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fkeys.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,12 +2,11 @@\n \n use std::marker::PhantomData;\n \n-use hir_expand::MacroCallId;\n+use hir_expand::{attrs::AttrId, MacroCallId};\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstNode, AstPtr};\n \n use crate::{\n-    attr::AttrId,\n     dyn_map::{DynMap, Policy},\n     ConstId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId, Macro2Id,\n     MacroRulesId, ProcMacroId, StaticId, StructId, TraitId, TypeAliasId, TypeOrConstParamId,"}, {"sha": "ab9bc615daf55aeea42b0ab32c5f9d202f14fd20", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 269, "deletions": 29, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -8,19 +8,21 @@ use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n use crate::{\n-    db::DefDatabase, AdtId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId, ImplId,\n-    ModuleDefId, StaticId, StructId, TraitId,\n+    db::DefDatabase, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId,\n+    ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum LangItemTarget {\n     EnumId(EnumId),\n-    FunctionId(FunctionId),\n-    ImplDefId(ImplId),\n-    StaticId(StaticId),\n-    StructId(StructId),\n-    TraitId(TraitId),\n-    EnumVariantId(EnumVariantId),\n+    Function(FunctionId),\n+    ImplDef(ImplId),\n+    Static(StaticId),\n+    Struct(StructId),\n+    Union(UnionId),\n+    TypeAlias(TypeAliasId),\n+    Trait(TraitId),\n+    EnumVariant(EnumVariantId),\n }\n \n impl LangItemTarget {\n@@ -33,55 +35,55 @@ impl LangItemTarget {\n \n     pub fn as_function(self) -> Option<FunctionId> {\n         match self {\n-            LangItemTarget::FunctionId(id) => Some(id),\n+            LangItemTarget::Function(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_impl_def(self) -> Option<ImplId> {\n         match self {\n-            LangItemTarget::ImplDefId(id) => Some(id),\n+            LangItemTarget::ImplDef(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_static(self) -> Option<StaticId> {\n         match self {\n-            LangItemTarget::StaticId(id) => Some(id),\n+            LangItemTarget::Static(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_struct(self) -> Option<StructId> {\n         match self {\n-            LangItemTarget::StructId(id) => Some(id),\n+            LangItemTarget::Struct(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_trait(self) -> Option<TraitId> {\n         match self {\n-            LangItemTarget::TraitId(id) => Some(id),\n+            LangItemTarget::Trait(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_enum_variant(self) -> Option<EnumVariantId> {\n         match self {\n-            LangItemTarget::EnumVariantId(id) => Some(id),\n+            LangItemTarget::EnumVariant(id) => Some(id),\n             _ => None,\n         }\n     }\n }\n \n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct LangItems {\n-    items: FxHashMap<SmolStr, LangItemTarget>,\n+    items: FxHashMap<LangItem, LangItemTarget>,\n }\n \n impl LangItems {\n-    pub fn target(&self, item: &str) -> Option<LangItemTarget> {\n-        self.items.get(item).copied()\n+    pub fn target(&self, item: LangItem) -> Option<LangItemTarget> {\n+        self.items.get(&item).copied()\n     }\n \n     /// Salsa query. This will look for lang items in a specific crate.\n@@ -94,16 +96,27 @@ impl LangItems {\n \n         for (_, module_data) in crate_def_map.modules() {\n             for impl_def in module_data.scope.impls() {\n-                lang_items.collect_lang_item(db, impl_def, LangItemTarget::ImplDefId)\n+                lang_items.collect_lang_item(db, impl_def, LangItemTarget::ImplDef);\n+                for assoc in db.impl_data(impl_def).items.iter().copied() {\n+                    match assoc {\n+                        AssocItemId::FunctionId(f) => {\n+                            lang_items.collect_lang_item(db, f, LangItemTarget::Function)\n+                        }\n+                        AssocItemId::TypeAliasId(t) => {\n+                            lang_items.collect_lang_item(db, t, LangItemTarget::TypeAlias)\n+                        }\n+                        AssocItemId::ConstId(_) => (),\n+                    }\n+                }\n             }\n \n             for def in module_data.scope.declarations() {\n                 match def {\n                     ModuleDefId::TraitId(trait_) => {\n-                        lang_items.collect_lang_item(db, trait_, LangItemTarget::TraitId);\n+                        lang_items.collect_lang_item(db, trait_, LangItemTarget::Trait);\n                         db.trait_data(trait_).items.iter().for_each(|&(_, assoc_id)| {\n-                            if let crate::AssocItemId::FunctionId(f) = assoc_id {\n-                                lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                            if let AssocItemId::FunctionId(f) = assoc_id {\n+                                lang_items.collect_lang_item(db, f, LangItemTarget::Function);\n                             }\n                         });\n                     }\n@@ -113,18 +126,24 @@ impl LangItems {\n                             lang_items.collect_lang_item(\n                                 db,\n                                 EnumVariantId { parent: e, local_id },\n-                                LangItemTarget::EnumVariantId,\n+                                LangItemTarget::EnumVariant,\n                             );\n                         });\n                     }\n                     ModuleDefId::AdtId(AdtId::StructId(s)) => {\n-                        lang_items.collect_lang_item(db, s, LangItemTarget::StructId);\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::Struct);\n+                    }\n+                    ModuleDefId::AdtId(AdtId::UnionId(u)) => {\n+                        lang_items.collect_lang_item(db, u, LangItemTarget::Union);\n                     }\n                     ModuleDefId::FunctionId(f) => {\n-                        lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                        lang_items.collect_lang_item(db, f, LangItemTarget::Function);\n                     }\n                     ModuleDefId::StaticId(s) => {\n-                        lang_items.collect_lang_item(db, s, LangItemTarget::StaticId);\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::Static);\n+                    }\n+                    ModuleDefId::TypeAliasId(t) => {\n+                        lang_items.collect_lang_item(db, t, LangItemTarget::TypeAlias);\n                     }\n                     _ => {}\n                 }\n@@ -139,7 +158,7 @@ impl LangItems {\n     pub(crate) fn lang_item_query(\n         db: &dyn DefDatabase,\n         start_crate: CrateId,\n-        item: SmolStr,\n+        item: LangItem,\n     ) -> Option<LangItemTarget> {\n         let _p = profile::span(\"lang_item_query\");\n         let lang_items = db.crate_lang_items(start_crate);\n@@ -150,7 +169,7 @@ impl LangItems {\n         db.crate_graph()[start_crate]\n             .dependencies\n             .iter()\n-            .find_map(|dep| db.lang_item(dep.crate_id, item.clone()))\n+            .find_map(|dep| db.lang_item(dep.crate_id, item))\n     }\n \n     fn collect_lang_item<T>(\n@@ -162,8 +181,8 @@ impl LangItems {\n         T: Into<AttrDefId> + Copy,\n     {\n         let _p = profile::span(\"collect_lang_item\");\n-        if let Some(lang_item_name) = lang_attr(db, item) {\n-            self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n+        if let Some(lang_item) = lang_attr(db, item).and_then(|it| LangItem::from_str(&it)) {\n+            self.items.entry(lang_item).or_insert_with(|| constructor(item));\n         }\n     }\n }\n@@ -172,3 +191,224 @@ pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Opt\n     let attrs = db.attrs(item.into());\n     attrs.by_key(\"lang\").string_value().cloned()\n }\n+\n+pub enum GenericRequirement {\n+    None,\n+    Minimum(usize),\n+    Exact(usize),\n+}\n+\n+macro_rules! language_item_table {\n+    (\n+        $( $(#[$attr:meta])* $variant:ident, $name:ident, $method:ident, $target:expr, $generics:expr; )*\n+    ) => {\n+\n+        /// A representation of all the valid language items in Rust.\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub enum LangItem {\n+            $(\n+                #[doc = concat!(\"The `\", stringify!($name), \"` lang item.\")]\n+                $(#[$attr])*\n+                $variant,\n+            )*\n+        }\n+\n+        impl LangItem {\n+            pub fn name(self) -> SmolStr {\n+                match self {\n+                    $( LangItem::$variant => SmolStr::new(stringify!($name)), )*\n+                }\n+            }\n+\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n+                Self::from_str(name.as_str()?)\n+            }\n+\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_str(name: &str) -> Option<Self> {\n+                match name {\n+                    $( stringify!($name) => Some(LangItem::$variant), )*\n+                    _ => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+language_item_table! {\n+//  Variant name,            Name,                     Getter method name,         Target                  Generic requirements;\n+    Sized,                   sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    Unsize,                  unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n+    /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\").\n+    StructuralPeq,           structural_peq,      structural_peq_trait,       Target::Trait,          GenericRequirement::None;\n+    /// Trait injected by `#[derive(Eq)]`, (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeq,           structural_teq,      structural_teq_trait,       Target::Trait,          GenericRequirement::None;\n+    Copy,                    copy,                copy_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    Clone,                   clone,               clone_trait,                Target::Trait,          GenericRequirement::None;\n+    Sync,                    sync,                sync_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    DiscriminantKind,        discriminant_kind,   discriminant_kind_trait,    Target::Trait,          GenericRequirement::None;\n+    /// The associated item of the [`DiscriminantKind`] trait.\n+    Discriminant,            discriminant_type,   discriminant_type,          Target::AssocTy,        GenericRequirement::None;\n+\n+    PointeeTrait,            pointee_trait,       pointee_trait,              Target::Trait,          GenericRequirement::None;\n+    Metadata,                metadata_type,       metadata_type,              Target::AssocTy,        GenericRequirement::None;\n+    DynMetadata,             dyn_metadata,        dyn_metadata,               Target::Struct,         GenericRequirement::None;\n+\n+    Freeze,                  freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+\n+    Drop,                    drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n+    Destruct,                destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    CoerceUnsized,           coerce_unsized,      coerce_unsized_trait,       Target::Trait,          GenericRequirement::Minimum(1);\n+    DispatchFromDyn,         dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n+\n+    // language items relating to transmutability\n+    TransmuteOpts,           transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n+    TransmuteTrait,          transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n+\n+    Add,                     add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Sub,                     sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Mul,                     mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Div,                     div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Rem,                     rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Neg,                     neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    Not,                     not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    BitXor,                  bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitAnd,                  bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitOr,                   bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    Shl,                     shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Shr,                     shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    AddAssign,               add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    SubAssign,               sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    MulAssign,               mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    DivAssign,               div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    RemAssign,               rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    BitXorAssign,            bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitAndAssign,            bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitOrAssign,             bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n+    ShlAssign,               shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    ShrAssign,               shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    Index,                   index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    IndexMut,                index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n+\n+    UnsafeCell,              unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n+    VaList,                  va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n+\n+    Deref,                   deref,               deref_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    DerefMut,                deref_mut,           deref_mut_trait,            Target::Trait,          GenericRequirement::Exact(0);\n+    DerefTarget,             deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n+    Receiver,                receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    Fn,                      fn,                  fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut,                   fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce,                  fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+\n+    FnOnceOutput,            fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n+\n+    Future,                  future_trait,        future_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    GeneratorState,          generator_state,     gen_state,                  Target::Enum,           GenericRequirement::None;\n+    Generator,               generator,           gen_trait,                  Target::Trait,          GenericRequirement::Minimum(1);\n+    Unpin,                   unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n+    Pin,                     pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n+\n+    PartialEq,               eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd,              partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+\n+    // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n+    // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays.\n+    //\n+    // The `begin_unwind` lang item has a predefined symbol name and is sort of a \"weak lang item\"\n+    // in the sense that a crate is not required to have it defined to use it, but a final product\n+    // is required to define it somewhere. Additionally, there are restrictions on crates that use\n+    // a weak lang item, but do not have it defined.\n+    Panic,                   panic,               panic_fn,                   Target::Fn,             GenericRequirement::Exact(0);\n+    PanicNounwind,           panic_nounwind,      panic_nounwind,             Target::Fn,             GenericRequirement::Exact(0);\n+    PanicFmt,                panic_fmt,           panic_fmt,                  Target::Fn,             GenericRequirement::None;\n+    PanicDisplay,            panic_display,       panic_display,              Target::Fn,             GenericRequirement::None;\n+    ConstPanicFmt,           const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n+    PanicBoundsCheck,        panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::Exact(0);\n+    PanicInfo,               panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n+    PanicLocation,           panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n+    PanicImpl,               panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;\n+    PanicCannotUnwind,       panic_cannot_unwind, panic_cannot_unwind,        Target::Fn,             GenericRequirement::Exact(0);\n+    /// libstd panic entry point. Necessary for const eval to be able to catch it\n+    BeginPanic,              begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n+\n+    ExchangeMalloc,          exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n+    BoxFree,                 box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n+    DropInPlace,             drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n+    AllocLayout,             alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n+\n+    Start,                   start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n+\n+    EhPersonality,           eh_personality,      eh_personality,             Target::Fn,             GenericRequirement::None;\n+    EhCatchTypeinfo,         eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static,         GenericRequirement::None;\n+\n+    OwnedBox,                owned_box,           owned_box,                  Target::Struct,         GenericRequirement::Minimum(1);\n+\n+    PhantomData,             phantom_data,        phantom_data,               Target::Struct,         GenericRequirement::Exact(1);\n+\n+    ManuallyDrop,            manually_drop,       manually_drop,              Target::Struct,         GenericRequirement::None;\n+\n+    MaybeUninit,             maybe_uninit,        maybe_uninit,               Target::Union,          GenericRequirement::None;\n+\n+    /// Align offset for stride != 1; must not panic.\n+    AlignOffset,             align_offset,        align_offset_fn,            Target::Fn,             GenericRequirement::None;\n+\n+    Termination,             termination,         termination,                Target::Trait,          GenericRequirement::None;\n+\n+    Try,                     Try,                 try_trait,                  Target::Trait,          GenericRequirement::None;\n+\n+    Tuple,                   tuple_trait,         tuple_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+\n+    SliceLen,                slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+\n+    // Language items from AST lowering\n+    TryTraitFromResidual,    from_residual,       from_residual_fn,           Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromOutput,      from_output,         from_output_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitBranch,          branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromYeet,        from_yeet,           from_yeet_fn,               Target::Fn,             GenericRequirement::None;\n+\n+    PointerSized,            pointer_sized,       pointer_sized,              Target::Trait,          GenericRequirement::Exact(0);\n+\n+    Poll,                    Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n+    PollReady,               Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n+    PollPending,             Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n+\n+    // FIXME(swatinem): the following lang items are used for async lowering and\n+    // should become obsolete eventually.\n+    ResumeTy,                ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n+    IdentityFuture,          identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n+    GetContext,              get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n+\n+    Context,                 Context,             context,                    Target::Struct,         GenericRequirement::None;\n+    FuturePoll,              poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n+    FromFrom,                from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n+    OptionSome,              Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n+    OptionNone,              None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n+\n+    ResultOk,                Ok,                  result_ok_variant,          Target::Variant,        GenericRequirement::None;\n+    ResultErr,               Err,                 result_err_variant,         Target::Variant,        GenericRequirement::None;\n+\n+    ControlFlowContinue,     Continue,            cf_continue_variant,        Target::Variant,        GenericRequirement::None;\n+    ControlFlowBreak,        Break,               cf_break_variant,           Target::Variant,        GenericRequirement::None;\n+\n+    IntoFutureIntoFuture,    into_future,         into_future_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IntoIterIntoIter,        into_iter,           into_iter_fn,               Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IteratorNext,            next,                next_fn,                    Target::Method(MethodKind::Trait { body: false}), GenericRequirement::None;\n+\n+    PinNewUnchecked,         new_unchecked,       new_unchecked_fn,           Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+\n+    RangeFrom,               RangeFrom,           range_from_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeFull,               RangeFull,           range_full_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveStruct,    RangeInclusive,      range_inclusive_struct,     Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveNew,       range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+    Range,                   Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n+    RangeToInclusive,        RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n+    RangeTo,                 RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n+\n+    String,                  String,              string,                     Target::Struct,         GenericRequirement::None;\n+}"}, {"sha": "49b1190ad46a3a009e9617c9057a898a11859385", "filename": "src/tools/rust-analyzer/crates/hir-def/src/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flayout.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -90,6 +90,7 @@ impl IntegerExt for Integer {\n pub enum LayoutError {\n     UserError(String),\n     SizeOverflow,\n+    TargetLayoutNotAvailable,\n     HasPlaceholder,\n     NotImplemented,\n     Unknown,"}, {"sha": "d07c5fb67c6f605bc2dc60be7339cd1e07b2c9df", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lib.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -28,7 +28,6 @@ pub mod dyn_map;\n pub mod keys;\n \n pub mod item_tree;\n-pub mod intern;\n \n pub mod adt;\n pub mod data;\n@@ -61,10 +60,10 @@ use std::{\n     sync::Arc,\n };\n \n-use attr::Attr;\n use base_db::{impl_intern_key, salsa, CrateId, ProcMacroKind};\n use hir_expand::{\n     ast_id_map::FileAstId,\n+    attrs::{Attr, AttrId, AttrInput},\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n@@ -80,9 +79,10 @@ use nameres::DefMap;\n use stdx::impl_from;\n use syntax::ast;\n \n+use ::tt::token_id as tt;\n+\n use crate::{\n     adt::VariantData,\n-    attr::AttrId,\n     builtin_type::BuiltinType,\n     item_tree::{\n         Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, MacroDef, MacroRules, ModItem,\n@@ -292,6 +292,7 @@ pub struct Macro2Loc {\n     pub container: ModuleId,\n     pub id: ItemTreeId<MacroDef>,\n     pub expander: MacroExpander,\n+    pub allow_internal_unsafe: bool,\n }\n impl_intern!(Macro2Id, Macro2Loc, intern_macro2, lookup_intern_macro2);\n \n@@ -301,8 +302,9 @@ pub struct MacroRulesId(salsa::InternId);\n pub struct MacroRulesLoc {\n     pub container: ModuleId,\n     pub id: ItemTreeId<MacroRules>,\n-    pub local_inner: bool,\n     pub expander: MacroExpander,\n+    pub allow_internal_unsafe: bool,\n+    pub local_inner: bool,\n }\n impl_intern!(MacroRulesId, MacroRulesLoc, intern_macro_rules, lookup_intern_macro_rules);\n \n@@ -896,6 +898,7 @@ pub fn macro_id_to_def_id(db: &dyn db::DefDatabase, id: MacroId) -> MacroDefId {\n                     }\n                 },\n                 local_inner: false,\n+                allow_internal_unsafe: loc.allow_internal_unsafe,\n             }\n         }\n         MacroId::MacroRulesId(it) => {\n@@ -920,6 +923,7 @@ pub fn macro_id_to_def_id(db: &dyn db::DefDatabase, id: MacroId) -> MacroDefId {\n                     }\n                 },\n                 local_inner: loc.local_inner,\n+                allow_internal_unsafe: loc.allow_internal_unsafe,\n             }\n         }\n         MacroId::ProcMacroId(it) => {\n@@ -935,6 +939,7 @@ pub fn macro_id_to_def_id(db: &dyn db::DefDatabase, id: MacroId) -> MacroDefId {\n                     InFile::new(loc.id.file_id(), makro.ast_id),\n                 ),\n                 local_inner: false,\n+                allow_internal_unsafe: false,\n             }\n         }\n     }\n@@ -943,7 +948,7 @@ pub fn macro_id_to_def_id(db: &dyn db::DefDatabase, id: MacroId) -> MacroDefId {\n fn derive_macro_as_call_id(\n     db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Adt>,\n-    derive_attr: AttrId,\n+    derive_attr_index: AttrId,\n     derive_pos: u32,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<(MacroId, MacroDefId)>,\n@@ -956,7 +961,7 @@ fn derive_macro_as_call_id(\n         MacroCallKind::Derive {\n             ast_id: item_attr.ast_id,\n             derive_index: derive_pos,\n-            derive_attr_index: derive_attr.ast_index,\n+            derive_attr_index,\n         },\n     );\n     Ok((macro_id, def_id, call_id))\n@@ -970,23 +975,33 @@ fn attr_macro_as_call_id(\n     def: MacroDefId,\n     is_derive: bool,\n ) -> MacroCallId {\n-    let mut arg = match macro_attr.input.as_deref() {\n-        Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n-        _ => Default::default(),\n+    let arg = match macro_attr.input.as_deref() {\n+        Some(AttrInput::TokenTree(tt, map)) => (\n+            {\n+                let mut tt = tt.clone();\n+                tt.delimiter = tt::Delimiter::UNSPECIFIED;\n+                tt\n+            },\n+            map.clone(),\n+        ),\n+        _ => (tt::Subtree::empty(), Default::default()),\n     };\n \n-    // The parentheses are always disposed here.\n-    arg.0.delimiter = None;\n-\n-    let res = def.as_lazy_macro(\n+    def.as_lazy_macro(\n         db.upcast(),\n         krate,\n         MacroCallKind::Attr {\n             ast_id: item_attr.ast_id,\n             attr_args: Arc::new(arg),\n-            invoc_attr_index: macro_attr.id.ast_index,\n+            invoc_attr_index: macro_attr.id,\n             is_derive,\n         },\n-    );\n-    res\n-}\n+    )\n+}\n+intern::impl_internable!(\n+    crate::type_ref::TypeRef,\n+    crate::type_ref::TraitRef,\n+    crate::type_ref::TypeBound,\n+    crate::path::GenericArgs,\n+    generics::GenericParams,\n+);"}, {"sha": "5ab90d92d9bd1e7fd3710300fdf5bb514b1530d0", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -30,7 +30,7 @@ use syntax::{\n     SyntaxKind::{self, COMMENT, EOF, IDENT, LIFETIME_IDENT},\n     SyntaxNode, TextRange, T,\n };\n-use tt::{Subtree, TokenId};\n+use tt::token_id::{Subtree, TokenId};\n \n use crate::{\n     db::DefDatabase, macro_id_to_def_id, nameres::ModuleSource, resolver::HasResolver,\n@@ -97,7 +97,9 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n         let ast_id = AstId::new(source.file_id, file_ast_id.upcast());\n         let kind = MacroDefKind::Declarative(ast_id);\n \n-        let macro_def = db.macro_def(MacroDefId { krate, kind, local_inner: false }).unwrap();\n+        let macro_def = db\n+            .macro_def(MacroDefId { krate, kind, local_inner: false, allow_internal_unsafe: false })\n+            .unwrap();\n         if let TokenExpander::DeclarativeMacro { mac, def_site_token_map } = &*macro_def {\n             let tt = match &macro_ {\n                 ast::Macro::MacroRules(mac) => mac.token_tree().unwrap(),\n@@ -251,9 +253,9 @@ fn extract_id_ranges(ranges: &mut Vec<(TextRange, TokenId)>, map: &TokenMap, tre\n     tree.token_trees.iter().for_each(|tree| match tree {\n         tt::TokenTree::Leaf(leaf) => {\n             let id = match leaf {\n-                tt::Leaf::Literal(it) => it.id,\n-                tt::Leaf::Punct(it) => it.id,\n-                tt::Leaf::Ident(it) => it.id,\n+                tt::Leaf::Literal(it) => it.span,\n+                tt::Leaf::Punct(it) => it.span,\n+                tt::Leaf::Ident(it) => it.span,\n             };\n             ranges.extend(map.ranges_by_token(id, SyntaxKind::ERROR).map(|range| (range, id)));\n         }"}, {"sha": "49bbc64bff1807b442fefc8b842e91e97d181874", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -97,6 +97,41 @@ fn#19 main#20(#21)#21 {#22\n \"##]],\n     );\n }\n+#[test]\n+fn float_field_acces_macro_input() {\n+    check(\n+        r#\"\n+macro_rules! foo {\n+    ($expr:expr) => {\n+        fn foo() {\n+            $expr;\n+        }\n+    };\n+}\n+foo!(x .0.1);\n+foo!(x .2. 3);\n+foo!(x .4 .5);\n+\"#,\n+        expect![[r#\"\n+macro_rules! foo {\n+    ($expr:expr) => {\n+        fn foo() {\n+            $expr;\n+        }\n+    };\n+}\n+fn foo() {\n+    (x.0.1);\n+}\n+fn foo() {\n+    (x.2.3);\n+}\n+fn foo() {\n+    (x.4.5);\n+}\n+\"#]],\n+    );\n+}\n \n #[test]\n fn mbe_smoke_test() {"}, {"sha": "822bdcc122dc6633c49f34ef0d4d23d5dd45a32e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -104,7 +104,7 @@ macro_rules! id {\n         $($t)*\n     };\n }\n-id /*+errors*/! {\n+id! {\n     #[proc_macros::identity]\n     impl Foo for WrapBj {\n         async fn foo(&self) {\n@@ -113,18 +113,17 @@ id /*+errors*/! {\n     }\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n macro_rules! id {\n     ($($t:tt)*) => {\n         $($t)*\n     };\n }\n-/* parse error: expected SEMICOLON */\n #[proc_macros::identity] impl Foo for WrapBj {\n     async fn foo(&self ) {\n         self .0.id().await ;\n     }\n }\n-\"##]],\n+\"#]],\n     );\n }"}, {"sha": "79cabeb0fb7a4ca123df00c1b9f3d610b4b21633", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,10 +1,9 @@\n //! Post-nameres attribute resolution.\n \n-use hir_expand::MacroCallId;\n+use hir_expand::{attrs::Attr, MacroCallId};\n use syntax::{ast, SmolStr};\n \n use crate::{\n-    attr::Attr,\n     attr_macro_as_call_id, builtin_attr,\n     db::DefDatabase,\n     item_scope::BuiltinShadowMode,"}, {"sha": "4b39a20d86c6ef9563dbef3f5640892b93abdffa", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -10,6 +10,7 @@ use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{\n     ast_id_map::FileAstId,\n+    attrs::{Attr, AttrId},\n     builtin_attr_macro::find_builtin_attr,\n     builtin_derive_macro::find_builtin_derive,\n     builtin_fn_macro::find_builtin_macro,\n@@ -26,7 +27,7 @@ use stdx::always;\n use syntax::{ast, SmolStr};\n \n use crate::{\n-    attr::{Attr, AttrId, Attrs},\n+    attr::Attrs,\n     attr_macro_as_call_id,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n@@ -45,6 +46,7 @@ use crate::{\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n+    tt,\n     visibility::{RawVisibility, Visibility},\n     AdtId, AstId, AstIdWithPath, ConstLoc, EnumLoc, EnumVariantId, ExternBlockLoc, FunctionId,\n     FunctionLoc, ImplLoc, Intern, ItemContainerId, LocalModuleId, Macro2Id, Macro2Loc,\n@@ -82,7 +84,8 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n                 .enumerate()\n                 .map(|(idx, it)| {\n                     // FIXME: a hacky way to create a Name from string.\n-                    let name = tt::Ident { text: it.name.clone(), id: tt::TokenId::unspecified() };\n+                    let name =\n+                        tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n                     (\n                         name.as_name(),\n                         ProcMacroExpander::new(def_map.krate, base_db::ProcMacroId(idx as u32)),\n@@ -450,8 +453,11 @@ impl DefCollector<'_> {\n                         directive.module_id,\n                         MacroCallKind::Attr {\n                             ast_id: ast_id.ast_id,\n-                            attr_args: Default::default(),\n-                            invoc_attr_index: attr.id.ast_index,\n+                            attr_args: std::sync::Arc::new((\n+                                tt::Subtree::empty(),\n+                                Default::default(),\n+                            )),\n+                            invoc_attr_index: attr.id,\n                             is_derive: false,\n                         },\n                         attr.path().clone(),\n@@ -1406,7 +1412,7 @@ impl DefCollector<'_> {\n                         directive.module_id,\n                         MacroCallKind::Derive {\n                             ast_id: ast_id.ast_id,\n-                            derive_attr_index: derive_attr.ast_index,\n+                            derive_attr_index: *derive_attr,\n                             derive_index: *derive_pos as u32,\n                         },\n                         ast_id.path.clone(),\n@@ -1599,17 +1605,15 @@ impl ModCollector<'_, '_> {\n                         FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n-                    if self.def_collector.is_proc_macro {\n-                        if self.module_id == def_map.root {\n-                            if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n-                                let crate_root = def_map.module_id(def_map.root);\n-                                self.def_collector.export_proc_macro(\n-                                    proc_macro,\n-                                    ItemTreeId::new(self.tree_id, id),\n-                                    fn_id,\n-                                    crate_root,\n-                                );\n-                            }\n+                    if self.def_collector.is_proc_macro && self.module_id == def_map.root {\n+                        if let Some(proc_macro) = attrs.parse_proc_macro_decl(&it.name) {\n+                            let crate_root = def_map.module_id(def_map.root);\n+                            self.def_collector.export_proc_macro(\n+                                proc_macro,\n+                                ItemTreeId::new(self.tree_id, id),\n+                                fn_id,\n+                                crate_root,\n+                            );\n                         }\n                     }\n \n@@ -1948,7 +1952,8 @@ impl ModCollector<'_, '_> {\n             let name = match attrs.by_key(\"rustc_builtin_macro\").string_value() {\n                 Some(it) => {\n                     // FIXME: a hacky way to create a Name from string.\n-                    name = tt::Ident { text: it.clone(), id: tt::TokenId::unspecified() }.as_name();\n+                    name =\n+                        tt::Ident { text: it.clone(), span: tt::TokenId::unspecified() }.as_name();\n                     &name\n                 }\n                 None => {\n@@ -1983,11 +1988,13 @@ impl ModCollector<'_, '_> {\n             // Case 2: normal `macro_rules!` macro\n             MacroExpander::Declarative\n         };\n+        let allow_internal_unsafe = attrs.by_key(\"allow_internal_unsafe\").exists();\n \n         let macro_id = MacroRulesLoc {\n             container: module,\n             id: ItemTreeId::new(self.tree_id, id),\n             local_inner,\n+            allow_internal_unsafe,\n             expander,\n         }\n         .intern(self.def_collector.db);\n@@ -2047,10 +2054,15 @@ impl ModCollector<'_, '_> {\n             // Case 2: normal `macro`\n             MacroExpander::Declarative\n         };\n+        let allow_internal_unsafe = attrs.by_key(\"allow_internal_unsafe\").exists();\n \n-        let macro_id =\n-            Macro2Loc { container: module, id: ItemTreeId::new(self.tree_id, id), expander }\n-                .intern(self.def_collector.db);\n+        let macro_id = Macro2Loc {\n+            container: module,\n+            id: ItemTreeId::new(self.tree_id, id),\n+            expander,\n+            allow_internal_unsafe,\n+        }\n+        .intern(self.def_collector.db);\n         self.def_collector.define_macro_def(\n             self.module_id,\n             mac.name.clone(),"}, {"sha": "b024d7c6777c03ee4a4ba0b0eea4affbeea58ab7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,12 +2,11 @@\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n-use hir_expand::MacroCallKind;\n+use hir_expand::{attrs::AttrId, MacroCallKind};\n use la_arena::Idx;\n use syntax::ast::{self, AnyHasAttrs};\n \n use crate::{\n-    attr::AttrId,\n     item_tree::{self, ItemTreeId},\n     nameres::LocalModuleId,\n     path::ModPath,\n@@ -32,9 +31,9 @@ pub enum DefDiagnosticKind {\n \n     UnimplementedBuiltinMacro { ast: AstId<ast::Macro> },\n \n-    InvalidDeriveTarget { ast: AstId<ast::Item>, id: u32 },\n+    InvalidDeriveTarget { ast: AstId<ast::Item>, id: usize },\n \n-    MalformedDerive { ast: AstId<ast::Adt>, id: u32 },\n+    MalformedDerive { ast: AstId<ast::Adt>, id: usize },\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -120,7 +119,7 @@ impl DefDiagnostic {\n     ) -> Self {\n         Self {\n             in_module: container,\n-            kind: DefDiagnosticKind::InvalidDeriveTarget { ast, id: id.ast_index },\n+            kind: DefDiagnosticKind::InvalidDeriveTarget { ast, id: id.ast_index() },\n         }\n     }\n \n@@ -131,7 +130,7 @@ impl DefDiagnostic {\n     ) -> Self {\n         Self {\n             in_module: container,\n-            kind: DefDiagnosticKind::MalformedDerive { ast, id: id.ast_index },\n+            kind: DefDiagnosticKind::MalformedDerive { ast, id: id.ast_index() },\n         }\n     }\n }"}, {"sha": "51c565fe12339133512649fb7566f2047b61533e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -7,7 +7,7 @@ use syntax::SmolStr;\n \n use crate::{db::DefDatabase, HirFileId};\n \n-const MOD_DEPTH_LIMIT: Limit = Limit::new(32);\n+static MOD_DEPTH_LIMIT: Limit = Limit::new(32);\n \n #[derive(Clone, Debug)]\n pub(super) struct ModDir {"}, {"sha": "caad4a1f381721629cccf8245a04b2a564393c3c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,9 +1,9 @@\n //! Nameres-specific procedural macro data and helpers.\n \n use hir_expand::name::{AsName, Name};\n-use tt::{Leaf, TokenTree};\n \n use crate::attr::Attrs;\n+use crate::tt::{Leaf, TokenTree};\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct ProcMacroDef {"}, {"sha": "8a27c60df5c27842db0d0ca1f2d7542854c25255", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -476,7 +476,7 @@ pub struct Bar;\n fn no_std_prelude() {\n     check(\n         r#\"\n-        //- /main.rs crate:main deps:core,std\n+        //- /main.rs edition:2018 crate:main deps:core,std\n         #![cfg_attr(not(never), no_std)]\n         use Rust;\n \n@@ -544,7 +544,7 @@ fn edition_specific_preludes() {\n fn std_prelude_takes_precedence_above_core_prelude() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:core,std\n+//- /main.rs edition:2018 crate:main deps:core,std\n use {Foo, Bar};\n \n //- /std.rs crate:std deps:core\n@@ -574,7 +574,7 @@ pub mod prelude {\n fn cfg_not_test() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n use {Foo, Bar, Baz};\n \n //- /lib.rs crate:std\n@@ -602,7 +602,7 @@ pub mod prelude {\n fn cfg_test() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n use {Foo, Bar, Baz};\n \n //- /lib.rs crate:std cfg:test,feature=foo,feature=bar,opt=42"}, {"sha": "a4ccd14cbb463a6cdae02cb18e8bb94101ccd7cd", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -264,7 +264,7 @@ fn prelude_is_macro_use() {\n     cov_mark::check!(prelude_is_macro_use);\n     check(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n structs!(Foo);\n structs_priv!(Bar);\n structs_outside!(Out);\n@@ -634,7 +634,7 @@ fn macro_dollar_crate_is_correct_in_indirect_deps() {\n     // From std\n     check(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n foo!();\n \n //- /std.rs crate:std deps:core\n@@ -1034,7 +1034,7 @@ structs!(Foo);\n fn macro_in_prelude() {\n     check(\n         r#\"\n-//- /lib.rs crate:lib deps:std\n+//- /lib.rs edition:2018 crate:lib deps:std\n global_asm!();\n \n //- /std.rs crate:std"}, {"sha": "25a23fcd61a51ddc5d0d5c7c34a53bcfbdc45cf2", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -8,10 +8,10 @@ use std::{\n \n use crate::{\n     body::LowerCtx,\n-    intern::Interned,\n     type_ref::{ConstScalarOrPath, LifetimeRef},\n };\n use hir_expand::name::Name;\n+use intern::Interned;\n use syntax::ast;\n \n use crate::type_ref::{TypeBound, TypeRef};"}, {"sha": "d570191595b6800118ba1f934d1f30a7a566963c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,9 +1,10 @@\n //! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n \n-use crate::{intern::Interned, type_ref::ConstScalarOrPath};\n+use crate::type_ref::ConstScalarOrPath;\n \n use either::Either;\n use hir_expand::name::{name, AsName};\n+use intern::Interned;\n use syntax::ast::{self, AstNode, HasTypeBounds};\n \n use super::AssociatedTypeBinding;"}, {"sha": "1c0bd204d309bd9f01947d37965d7e587c949884", "filename": "src/tools/rust-analyzer/crates/hir-def/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,10 +3,10 @@\n use std::fmt::{self, Write};\n \n use hir_expand::mod_path::PathKind;\n+use intern::Interned;\n use itertools::Itertools;\n \n use crate::{\n-    intern::Interned,\n     path::{GenericArg, GenericArgs, Path},\n     type_ref::{Mutability, TraitBoundModifier, TypeBound, TypeRef},\n };"}, {"sha": "86958e3daea4d06e62319826e1c2ee0963ec6c74", "filename": "src/tools/rust-analyzer/crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,6 +4,7 @@ use std::{hash::BuildHasherDefault, sync::Arc};\n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n use indexmap::IndexMap;\n+use intern::Interned;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n \n@@ -13,7 +14,6 @@ use crate::{\n     db::DefDatabase,\n     expr::{ExprId, LabelId, PatId},\n     generics::{GenericParams, TypeOrConstParamData},\n-    intern::Interned,\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     nameres::DefMap,\n     path::{ModPath, PathKind},"}, {"sha": "8fa12c7aafda70303b6649308c8edf436822c4bf", "filename": "src/tools/rust-analyzer/crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -7,13 +7,13 @@ use hir_expand::{\n     name::{AsName, Name},\n     AstId,\n };\n+use intern::Interned;\n use syntax::ast::{self, HasName};\n \n use crate::{\n     body::LowerCtx,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     expr::Literal,\n-    intern::Interned,\n     path::Path,\n };\n \n@@ -240,7 +240,7 @@ impl TypeRef {\n                 TypeRef::DynTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n             ast::Type::MacroType(mt) => match mt.macro_call() {\n-                Some(mc) => ctx.ast_id(ctx.db, &mc).map(TypeRef::Macro).unwrap_or(TypeRef::Error),\n+                Some(mc) => ctx.ast_id(&mc).map(TypeRef::Macro).unwrap_or(TypeRef::Error),\n                 None => TypeRef::Error,\n             },\n         }"}, {"sha": "525cdc32b87516f3d4a79fb3b1f4e462b3348057", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"hir-expand\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -21,14 +23,16 @@ hashbrown = { version = \"0.12.1\", features = [\n ], default-features = false }\n smallvec = { version = \"1.10.0\", features = [\"const_new\"] }\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-base-db = { path = \"../base-db\", version = \"0.0.0\" }\n-cfg = { path = \"../cfg\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-tt = { path = \"../tt\", version = \"0.0.0\" }\n-mbe = { path = \"../mbe\", version = \"0.0.0\" }\n-limit = { path = \"../limit\", version = \"0.0.0\" }\n+# local deps\n+stdx.workspace = true\n+intern.workspace = true\n+base-db.workspace = true\n+cfg.workspace = true\n+syntax.workspace = true\n+profile.workspace = true\n+tt.workspace = true\n+mbe.workspace = true\n+limit.workspace = true\n \n [dev-dependencies]\n expect-test = \"1.4.0\""}, {"sha": "5c04f8e8b8f3718033d61ad9ec87039a9cccf750", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/attrs.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,349 @@\n+//! A higher level attributes based on TokenTree, with also some shortcuts.\n+use std::{fmt, ops, sync::Arc};\n+\n+use base_db::CrateId;\n+use cfg::CfgExpr;\n+use either::Either;\n+use intern::Interned;\n+use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n+use smallvec::{smallvec, SmallVec};\n+use syntax::{ast, match_ast, AstNode, SmolStr, SyntaxNode};\n+\n+use crate::{\n+    db::AstDatabase,\n+    hygiene::Hygiene,\n+    mod_path::{ModPath, PathKind},\n+    name::AsName,\n+    tt::{self, Subtree},\n+    InFile,\n+};\n+\n+/// Syntactical attributes, without filtering of `cfg_attr`s.\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct RawAttrs {\n+    entries: Option<Arc<[Attr]>>,\n+}\n+\n+impl ops::Deref for RawAttrs {\n+    type Target = [Attr];\n+\n+    fn deref(&self) -> &[Attr] {\n+        match &self.entries {\n+            Some(it) => &*it,\n+            None => &[],\n+        }\n+    }\n+}\n+\n+impl RawAttrs {\n+    pub const EMPTY: Self = Self { entries: None };\n+\n+    pub fn new(db: &dyn AstDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n+        let entries = collect_attrs(owner)\n+            .filter_map(|(id, attr)| match attr {\n+                Either::Left(attr) => {\n+                    attr.meta().and_then(|meta| Attr::from_src(db, meta, hygiene, id))\n+                }\n+                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n+                    id,\n+                    input: Some(Interned::new(AttrInput::Literal(SmolStr::new(doc)))),\n+                    path: Interned::new(ModPath::from(crate::name!(doc))),\n+                }),\n+            })\n+            .collect::<Arc<_>>();\n+\n+        Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n+    }\n+\n+    pub fn from_attrs_owner(db: &dyn AstDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n+        let hygiene = Hygiene::new(db, owner.file_id);\n+        Self::new(db, owner.value, &hygiene)\n+    }\n+\n+    pub fn merge(&self, other: Self) -> Self {\n+        match (&self.entries, other.entries) {\n+            (None, None) => Self::EMPTY,\n+            (None, entries @ Some(_)) => Self { entries },\n+            (Some(entries), None) => Self { entries: Some(entries.clone()) },\n+            (Some(a), Some(b)) => {\n+                let last_ast_index = a.last().map_or(0, |it| it.id.ast_index() + 1) as u32;\n+                Self {\n+                    entries: Some(\n+                        a.iter()\n+                            .cloned()\n+                            .chain(b.iter().map(|it| {\n+                                let mut it = it.clone();\n+                                it.id.id = it.id.ast_index() as u32 + last_ast_index\n+                                    | (it.id.cfg_attr_index().unwrap_or(0) as u32)\n+                                        << AttrId::AST_INDEX_BITS;\n+                                it\n+                            }))\n+                            .collect(),\n+                    ),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n+    // FIXME: This should return a different type\n+    pub fn filter(self, db: &dyn AstDatabase, krate: CrateId) -> RawAttrs {\n+        let has_cfg_attrs = self\n+            .iter()\n+            .any(|attr| attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]));\n+        if !has_cfg_attrs {\n+            return self;\n+        }\n+\n+        let crate_graph = db.crate_graph();\n+        let new_attrs = self\n+            .iter()\n+            .flat_map(|attr| -> SmallVec<[_; 1]> {\n+                let is_cfg_attr =\n+                    attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]);\n+                if !is_cfg_attr {\n+                    return smallvec![attr.clone()];\n+                }\n+\n+                let subtree = match attr.token_tree_value() {\n+                    Some(it) => it,\n+                    _ => return smallvec![attr.clone()],\n+                };\n+\n+                let (cfg, parts) = match parse_cfg_attr_input(subtree) {\n+                    Some(it) => it,\n+                    None => return smallvec![attr.clone()],\n+                };\n+                let index = attr.id;\n+                let attrs =\n+                    parts.enumerate().take(1 << AttrId::CFG_ATTR_BITS).filter_map(|(idx, attr)| {\n+                        let tree = Subtree {\n+                            delimiter: tt::Delimiter::unspecified(),\n+                            token_trees: attr.to_vec(),\n+                        };\n+                        // FIXME hygiene\n+                        let hygiene = Hygiene::new_unhygienic();\n+                        Attr::from_tt(db, &tree, &hygiene, index.with_cfg_attr(idx))\n+                    });\n+\n+                let cfg_options = &crate_graph[krate].cfg_options;\n+                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n+                let cfg = CfgExpr::parse(&cfg);\n+                if cfg_options.check(&cfg) == Some(false) {\n+                    smallvec![]\n+                } else {\n+                    cov_mark::hit!(cfg_attr_active);\n+\n+                    attrs.collect()\n+                }\n+            })\n+            .collect();\n+\n+        RawAttrs { entries: Some(new_attrs) }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AttrId {\n+    id: u32,\n+}\n+\n+// FIXME: This only handles a single level of cfg_attr nesting\n+// that is `#[cfg_attr(all(), cfg_attr(all(), cfg(any())))]` breaks again\n+impl AttrId {\n+    const CFG_ATTR_BITS: usize = 7;\n+    const AST_INDEX_MASK: usize = 0x00FF_FFFF;\n+    const AST_INDEX_BITS: usize = Self::AST_INDEX_MASK.count_ones() as usize;\n+    const CFG_ATTR_SET_BITS: u32 = 1 << 31;\n+\n+    pub fn ast_index(&self) -> usize {\n+        self.id as usize & Self::AST_INDEX_MASK\n+    }\n+\n+    pub fn cfg_attr_index(&self) -> Option<usize> {\n+        if self.id & Self::CFG_ATTR_SET_BITS == 0 {\n+            None\n+        } else {\n+            Some(self.id as usize >> Self::AST_INDEX_BITS)\n+        }\n+    }\n+\n+    pub fn with_cfg_attr(self, idx: usize) -> AttrId {\n+        AttrId { id: self.id | (idx as u32) << Self::AST_INDEX_BITS | Self::CFG_ATTR_SET_BITS }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Attr {\n+    pub id: AttrId,\n+    pub path: Interned<ModPath>,\n+    pub input: Option<Interned<AttrInput>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum AttrInput {\n+    /// `#[attr = \"string\"]`\n+    Literal(SmolStr),\n+    /// `#[attr(subtree)]`\n+    TokenTree(tt::Subtree, mbe::TokenMap),\n+}\n+\n+impl fmt::Display for AttrInput {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AttrInput::Literal(lit) => write!(f, \" = \\\"{}\\\"\", lit.escape_debug()),\n+            AttrInput::TokenTree(subtree, _) => subtree.fmt(f),\n+        }\n+    }\n+}\n+\n+impl Attr {\n+    fn from_src(\n+        db: &dyn AstDatabase,\n+        ast: ast::Meta,\n+        hygiene: &Hygiene,\n+        id: AttrId,\n+    ) -> Option<Attr> {\n+        let path = Interned::new(ModPath::from_src(db, ast.path()?, hygiene)?);\n+        let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n+            let value = match lit.kind() {\n+                ast::LiteralKind::String(string) => string.value()?.into(),\n+                _ => lit.syntax().first_token()?.text().trim_matches('\"').into(),\n+            };\n+            Some(Interned::new(AttrInput::Literal(value)))\n+        } else if let Some(tt) = ast.token_tree() {\n+            let (tree, map) = syntax_node_to_token_tree(tt.syntax());\n+            Some(Interned::new(AttrInput::TokenTree(tree, map)))\n+        } else {\n+            None\n+        };\n+        Some(Attr { id, path, input })\n+    }\n+\n+    fn from_tt(\n+        db: &dyn AstDatabase,\n+        tt: &tt::Subtree,\n+        hygiene: &Hygiene,\n+        id: AttrId,\n+    ) -> Option<Attr> {\n+        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MetaItem);\n+        let ast = ast::Meta::cast(parse.syntax_node())?;\n+\n+        Self::from_src(db, ast, hygiene, id)\n+    }\n+\n+    pub fn path(&self) -> &ModPath {\n+        &self.path\n+    }\n+}\n+\n+impl Attr {\n+    /// #[path = \"string\"]\n+    pub fn string_value(&self) -> Option<&SmolStr> {\n+        match self.input.as_deref()? {\n+            AttrInput::Literal(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    /// #[path(ident)]\n+    pub fn single_ident_value(&self) -> Option<&tt::Ident> {\n+        match self.input.as_deref()? {\n+            AttrInput::TokenTree(subtree, _) => match &*subtree.token_trees {\n+                [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] => Some(ident),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// #[path TokenTree]\n+    pub fn token_tree_value(&self) -> Option<&Subtree> {\n+        match self.input.as_deref()? {\n+            AttrInput::TokenTree(subtree, _) => Some(subtree),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Parses this attribute as a token tree consisting of comma separated paths.\n+    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+        let args = self.token_tree_value()?;\n+\n+        if args.delimiter.kind != DelimiterKind::Parenthesis {\n+            return None;\n+        }\n+        let paths = args\n+            .token_trees\n+            .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))\n+            .filter_map(|tts| {\n+                if tts.is_empty() {\n+                    return None;\n+                }\n+                let segments = tts.iter().filter_map(|tt| match tt {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n+                    _ => None,\n+                });\n+                Some(ModPath::from_segments(PathKind::Plain, segments))\n+            });\n+\n+        Some(paths)\n+    }\n+}\n+\n+pub fn collect_attrs(\n+    owner: &dyn ast::HasAttrs,\n+) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {\n+    let inner_attrs = inner_attributes(owner.syntax()).into_iter().flatten();\n+    let outer_attrs =\n+        ast::AttrDocCommentIter::from_syntax_node(owner.syntax()).filter(|el| match el {\n+            Either::Left(attr) => attr.kind().is_outer(),\n+            Either::Right(comment) => comment.is_outer(),\n+        });\n+    outer_attrs.chain(inner_attrs).enumerate().map(|(id, attr)| (AttrId { id: id as u32 }, attr))\n+}\n+\n+fn inner_attributes(\n+    syntax: &SyntaxNode,\n+) -> Option<impl Iterator<Item = Either<ast::Attr, ast::Comment>>> {\n+    let node = match_ast! {\n+        match syntax {\n+            ast::SourceFile(_) => syntax.clone(),\n+            ast::ExternBlock(it) => it.extern_item_list()?.syntax().clone(),\n+            ast::Fn(it) => it.body()?.stmt_list()?.syntax().clone(),\n+            ast::Impl(it) => it.assoc_item_list()?.syntax().clone(),\n+            ast::Module(it) => it.item_list()?.syntax().clone(),\n+            ast::BlockExpr(it) => {\n+                use syntax::SyntaxKind::{BLOCK_EXPR , EXPR_STMT};\n+                // Block expressions accept outer and inner attributes, but only when they are the outer\n+                // expression of an expression statement or the final expression of another block expression.\n+                let may_carry_attributes = matches!(\n+                    it.syntax().parent().map(|it| it.kind()),\n+                     Some(BLOCK_EXPR | EXPR_STMT)\n+                );\n+                if !may_carry_attributes {\n+                    return None\n+                }\n+                syntax.clone()\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let attrs = ast::AttrDocCommentIter::from_syntax_node(&node).filter(|el| match el {\n+        Either::Left(attr) => attr.kind().is_inner(),\n+        Either::Right(comment) => comment.is_inner(),\n+    });\n+    Some(attrs)\n+}\n+\n+// Input subtree is: `(cfg, $(attr),+)`\n+// Split it up into a `cfg` subtree and the `attr` subtrees.\n+pub fn parse_cfg_attr_input(\n+    subtree: &Subtree,\n+) -> Option<(&[tt::TokenTree], impl Iterator<Item = &[tt::TokenTree]>)> {\n+    let mut parts = subtree\n+        .token_trees\n+        .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))));\n+    let cfg = parts.next()?;\n+    Some((cfg, parts.filter(|it| !it.is_empty())))\n+}"}, {"sha": "906ca991d73be7d4129be6d5928f20128bf3c78d", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,6 +1,6 @@\n //! Builtin attributes.\n \n-use crate::{db::AstDatabase, name, ExpandResult, MacroCallId, MacroCallKind};\n+use crate::{db::AstDatabase, name, tt, ExpandResult, MacroCallId, MacroCallKind};\n \n macro_rules! register_builtin {\n     ( $(($name:ident, $variant:ident) => $expand:ident),* ) => {\n@@ -97,7 +97,7 @@ fn derive_attr_expand(\n     let loc = db.lookup_intern_macro_call(id);\n     let derives = match &loc.kind {\n         MacroCallKind::Attr { attr_args, is_derive: true, .. } => &attr_args.0,\n-        _ => return ExpandResult::ok(Default::default()),\n+        _ => return ExpandResult::ok(tt::Subtree::empty()),\n     };\n     pseudo_derive_attr_expansion(tt, derives)\n }\n@@ -110,7 +110,7 @@ pub fn pseudo_derive_attr_expansion(\n         tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n             char,\n             spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))\n     };\n "}, {"sha": "060a680542fd9b2ad42c0c52f1352f7beda01fb0", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,11 +3,11 @@\n use base_db::{CrateOrigin, LangCrateOrigin};\n use tracing::debug;\n \n+use crate::tt::{self, TokenId};\n use syntax::{\n     ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName},\n     match_ast,\n };\n-use tt::TokenId;\n \n use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId};\n \n@@ -92,7 +92,7 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n     })?;\n     let name_token_id =\n         token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n-    let name_token = tt::Ident { id: name_token_id, text: name.text().into() };\n+    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n     let param_types = params\n         .into_iter()\n         .flat_map(|param_list| param_list.type_or_const_params())\n@@ -101,7 +101,7 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n                 let ty = param\n                     .ty()\n                     .map(|ty| mbe::syntax_node_to_token_tree(ty.syntax()).0)\n-                    .unwrap_or_default();\n+                    .unwrap_or_else(tt::Subtree::empty);\n                 Some(ty)\n             } else {\n                 None\n@@ -114,15 +114,15 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => return ExpandResult::with_err(tt::Subtree::empty(), e),\n     };\n     let (params, args): (Vec<_>, Vec<_>) = info\n         .param_types\n         .into_iter()\n         .enumerate()\n         .map(|(idx, param_ty)| {\n             let ident = tt::Leaf::Ident(tt::Ident {\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n                 text: format!(\"T{idx}\").into(),\n             });\n             let ident_ = ident.clone();"}, {"sha": "9f3fa73d4e60edadac66107ceb7743eacfc816fd", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -9,7 +9,9 @@ use syntax::{\n     SmolStr,\n };\n \n-use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId, MacroCallLoc};\n+use crate::{\n+    db::AstDatabase, name, quote, tt, ExpandError, ExpandResult, MacroCallId, MacroCallLoc,\n+};\n \n macro_rules! register_builtin {\n     ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n@@ -61,7 +63,7 @@ macro_rules! register_builtin {\n     };\n }\n \n-#[derive(Debug, Default)]\n+#[derive(Debug)]\n pub struct ExpandedEager {\n     pub(crate) subtree: tt::Subtree,\n     /// The included file ID of the include macro.\n@@ -116,7 +118,7 @@ register_builtin! {\n }\n \n const DOLLAR_CRATE: tt::Ident =\n-    tt::Ident { text: SmolStr::new_inline(\"$crate\"), id: tt::TokenId::unspecified() };\n+    tt::Ident { text: SmolStr::new_inline(\"$crate\"), span: tt::TokenId::unspecified() };\n \n fn module_path_expand(\n     _db: &dyn AstDatabase,\n@@ -162,7 +164,7 @@ fn stringify_expand(\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let pretty = tt::pretty(&tt.token_trees);\n+    let pretty = ::tt::pretty(&tt.token_trees);\n \n     let expanded = quote! {\n         #pretty\n@@ -194,11 +196,11 @@ fn assert_expand(\n     let expanded = match &*args {\n         [cond, panic_args @ ..] => {\n             let comma = tt::Subtree {\n-                delimiter: None,\n+                delimiter: tt::Delimiter::unspecified(),\n                 token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n                     char: ',',\n                     spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n+                    span: tt::TokenId::unspecified(),\n                 }))],\n             };\n             let cond = cond.clone();\n@@ -247,7 +249,10 @@ fn format_args_expand(\n     let mut args = parse_exprs_with_sep(tt, ',');\n \n     if args.is_empty() {\n-        return ExpandResult::only_err(mbe::ExpandError::NoMatchingRule.into());\n+        return ExpandResult::with_err(\n+            tt::Subtree::empty(),\n+            mbe::ExpandError::NoMatchingRule.into(),\n+        );\n     }\n     for arg in &mut args {\n         // Remove `key =`.\n@@ -282,7 +287,7 @@ fn asm_expand(\n     for tt in tt.token_trees.chunks(2) {\n         match tt {\n             [tt::TokenTree::Leaf(tt::Leaf::Literal(lit))]\n-            | [tt::TokenTree::Leaf(tt::Leaf::Literal(lit)), tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', id: _, spacing: _ }))] =>\n+            | [tt::TokenTree::Leaf(tt::Leaf::Literal(lit)), tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', span: _, spacing: _ }))] =>\n             {\n                 let krate = DOLLAR_CRATE.clone();\n                 literals.push(quote!(#krate::format_args!(#lit);));\n@@ -400,7 +405,7 @@ fn concat_expand(\n         // FIXME: hack on top of a hack: `$e:expr` captures get surrounded in parentheses\n         // to ensure the right parsing order, so skip the parentheses here. Ideally we'd\n         // implement rustc's model. cc https://github.com/rust-lang/rust-analyzer/pull/10623\n-        if let tt::TokenTree::Subtree(tt::Subtree { delimiter: Some(delim), token_trees }) = t {\n+        if let tt::TokenTree::Subtree(tt::Subtree { delimiter: delim, token_trees }) = t {\n             if let [tt] = &**token_trees {\n                 if delim.kind == tt::DelimiterKind::Parenthesis {\n                     t = tt;\n@@ -459,9 +464,7 @@ fn concat_bytes_expand(\n                 }\n             }\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if i % 2 == 1 && punct.char == ',' => (),\n-            tt::TokenTree::Subtree(tree)\n-                if tree.delimiter_kind() == Some(tt::DelimiterKind::Bracket) =>\n-            {\n+            tt::TokenTree::Subtree(tree) if tree.delimiter.kind == tt::DelimiterKind::Bracket => {\n                 if let Err(e) = concat_bytes_expand_subtree(tree, &mut bytes) {\n                     err.get_or_insert(e);\n                     break;\n@@ -473,7 +476,7 @@ fn concat_bytes_expand(\n             }\n         }\n     }\n-    let ident = tt::Ident { text: bytes.join(\", \").into(), id: tt::TokenId::unspecified() };\n+    let ident = tt::Ident { text: bytes.join(\", \").into(), span: tt::TokenId::unspecified() };\n     ExpandResult { value: ExpandedEager::new(quote!([#ident])), err }\n }\n \n@@ -521,7 +524,7 @@ fn concat_idents_expand(\n             }\n         }\n     }\n-    let ident = tt::Ident { text: ident.into(), id: tt::TokenId::unspecified() };\n+    let ident = tt::Ident { text: ident.into(), span: tt::TokenId::unspecified() };\n     ExpandResult { value: ExpandedEager::new(quote!(#ident)), err }\n }\n \n@@ -572,7 +575,10 @@ fn include_expand(\n         Ok((subtree, file_id)) => {\n             ExpandResult::ok(ExpandedEager { subtree, included_file: Some(file_id) })\n         }\n-        Err(e) => ExpandResult::only_err(e),\n+        Err(e) => ExpandResult::with_err(\n+            ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+            e,\n+        ),\n     }\n }\n \n@@ -582,15 +588,18 @@ fn include_bytes_expand(\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n     if let Err(e) = parse_string(tt) {\n-        return ExpandResult::only_err(e);\n+        return ExpandResult::with_err(\n+            ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+            e,\n+        );\n     }\n \n     // FIXME: actually read the file here if the user asked for macro expansion\n     let res = tt::Subtree {\n-        delimiter: None,\n+        delimiter: tt::Delimiter::unspecified(),\n         token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Literal(tt::Literal {\n             text: r#\"b\"\"\"#.into(),\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))],\n     };\n     ExpandResult::ok(ExpandedEager::new(res))\n@@ -603,7 +612,12 @@ fn include_str_expand(\n ) -> ExpandResult<ExpandedEager> {\n     let path = match parse_string(tt) {\n         Ok(it) => it,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => {\n+            return ExpandResult::with_err(\n+                ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+                e,\n+            )\n+        }\n     };\n \n     // FIXME: we're not able to read excluded files (which is most of them because\n@@ -635,7 +649,12 @@ fn env_expand(\n ) -> ExpandResult<ExpandedEager> {\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => {\n+            return ExpandResult::with_err(\n+                ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+                e,\n+            )\n+        }\n     };\n \n     let mut err = None;\n@@ -666,7 +685,12 @@ fn option_env_expand(\n ) -> ExpandResult<ExpandedEager> {\n     let key = match parse_string(tt) {\n         Ok(it) => it,\n-        Err(e) => return ExpandResult::only_err(e),\n+        Err(e) => {\n+            return ExpandResult::with_err(\n+                ExpandedEager { subtree: tt::Subtree::empty(), included_file: None },\n+                e,\n+            )\n+        }\n     };\n \n     let expanded = match get_env_inner(db, arg_id, &key) {"}, {"sha": "76016274f0e85a971373d1ad5962da93d10013b6", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/db.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n \n use crate::{\n     ast_id_map::AstIdMap, builtin_attr_macro::pseudo_derive_attr_expansion, fixup,\n-    hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n+    hygiene::HygieneFrame, tt, BuiltinAttrExpander, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n     ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind,\n     MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n@@ -25,7 +25,7 @@ use crate::{\n /// an error will be emitted.\n ///\n /// Actual max for `analysis-stats .` at some point: 30672.\n-static TOKEN_LIMIT: Limit = Limit::new(524_288);\n+static TOKEN_LIMIT: Limit = Limit::new(1_048_576);\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum TokenExpander {\n@@ -168,12 +168,14 @@ pub fn expand_speculative(\n                 // Attributes may have an input token tree, build the subtree and map for this as well\n                 // then try finding a token id for our token if it is inside this input subtree.\n                 let item = ast::Item::cast(speculative_args.clone())?;\n-                item.doc_comments_and_attrs().nth(invoc_attr_index as usize).and_then(Either::left)\n+                item.doc_comments_and_attrs()\n+                    .nth(invoc_attr_index.ast_index())\n+                    .and_then(Either::left)\n             }?;\n             match attr.token_tree() {\n                 Some(token_tree) => {\n                     let (mut tree, map) = syntax_node_to_token_tree(attr.token_tree()?.syntax());\n-                    tree.delimiter = None;\n+                    tree.delimiter = tt::Delimiter::unspecified();\n \n                     let shift = mbe::Shift::new(&tt);\n                     shift.shift_all(&mut tree);\n@@ -208,7 +210,7 @@ pub fn expand_speculative(\n     // Otherwise the expand query will fetch the non speculative attribute args and pass those instead.\n     let mut speculative_expansion = match loc.def.kind {\n         MacroDefKind::ProcMacro(expander, ..) => {\n-            tt.delimiter = None;\n+            tt.delimiter = tt::Delimiter::unspecified();\n             expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n         }\n         MacroDefKind::BuiltInAttr(BuiltinAttrExpander::Derive, _) => {\n@@ -314,21 +316,21 @@ fn macro_arg(\n \n     if loc.def.is_proc_macro() {\n         // proc macros expect their inputs without parentheses, MBEs expect it with them included\n-        tt.delimiter = None;\n+        tt.delimiter = tt::Delimiter::unspecified();\n     }\n-\n     Some(Arc::new((tt, tmap, fixups.undo_info)))\n }\n \n fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<SyntaxNode> {\n+    // FIXME: handle `cfg_attr`\n     (|| {\n         let censor = match loc.kind {\n             MacroCallKind::FnLike { .. } => return None,\n             MacroCallKind::Derive { derive_attr_index, .. } => {\n                 cov_mark::hit!(derive_censoring);\n                 ast::Item::cast(node.clone())?\n                     .attrs()\n-                    .take(derive_attr_index as usize + 1)\n+                    .take(derive_attr_index.ast_index() + 1)\n                     // FIXME, this resolution should not be done syntactically\n                     // derive is a proper macro now, no longer builtin\n                     // But we do not have resolution at this stage, this means\n@@ -343,7 +345,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                 cov_mark::hit!(attribute_macro_attr_censoring);\n                 ast::Item::cast(node.clone())?\n                     .doc_comments_and_attrs()\n-                    .nth(invoc_attr_index as usize)\n+                    .nth(invoc_attr_index.ast_index())\n                     .and_then(Either::left)\n                     .map(|attr| attr.syntax().clone())\n                     .into_iter()\n@@ -476,7 +478,10 @@ fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::\n     let macro_arg = match db.macro_arg(id) {\n         Some(it) => it,\n         None => {\n-            return ExpandResult::only_err(ExpandError::Other(\"No arguments for proc-macro\".into()))\n+            return ExpandResult::with_err(\n+                tt::Subtree::empty(),\n+                ExpandError::Other(\"No arguments for proc-macro\".into()),\n+            )\n         }\n     };\n "}, {"sha": "dfab7ec92c763c00aa73fa56fa8d45446cf44eb1", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/eager.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -108,7 +108,7 @@ pub fn expand_eager_macro(\n         .value\n         .token_tree()\n         .map(|tt| mbe::syntax_node_to_token_tree(tt.syntax()).0)\n-        .unwrap_or_default();\n+        .unwrap_or_else(tt::Subtree::empty);\n \n     let ast_map = db.ast_id_map(macro_call.file_id);\n     let call_id = InFile::new(macro_call.file_id, ast_map.ast_id(&macro_call.value));\n@@ -165,9 +165,9 @@ pub fn expand_eager_macro(\n     }\n }\n \n-fn to_subtree(node: &SyntaxNode) -> tt::Subtree {\n+fn to_subtree(node: &SyntaxNode) -> crate::tt::Subtree {\n     let mut subtree = mbe::syntax_node_to_token_tree(node).0;\n-    subtree.delimiter = None;\n+    subtree.delimiter = crate::tt::Delimiter::unspecified();\n     subtree\n }\n "}, {"sha": "c811d1c66a82daa069d8b466c352da7dc2cd98d7", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -9,7 +9,7 @@ use syntax::{\n     ast::{self, AstNode, HasLoopBody},\n     match_ast, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n };\n-use tt::Subtree;\n+use tt::token_id::Subtree;\n \n /// The result of calculating fixes for a syntax node -- a bunch of changes\n /// (appending to and replacing nodes), the information that is needed to\n@@ -297,9 +297,11 @@ pub(crate) fn reverse_fixups(\n     tt.token_trees = tts\n         .into_iter()\n         .filter(|tt| match tt {\n-            tt::TokenTree::Leaf(leaf) => token_map.synthetic_token_id(leaf.id()) != Some(EMPTY_ID),\n+            tt::TokenTree::Leaf(leaf) => {\n+                token_map.synthetic_token_id(*leaf.span()) != Some(EMPTY_ID)\n+            }\n             tt::TokenTree::Subtree(st) => {\n-                st.delimiter.map_or(true, |d| token_map.synthetic_token_id(d.id) != Some(EMPTY_ID))\n+                token_map.synthetic_token_id(st.delimiter.open) != Some(EMPTY_ID)\n             }\n         })\n         .flat_map(|tt| match tt {\n@@ -308,9 +310,9 @@ pub(crate) fn reverse_fixups(\n                 SmallVec::from_const([tt.into()])\n             }\n             tt::TokenTree::Leaf(leaf) => {\n-                if let Some(id) = token_map.synthetic_token_id(leaf.id()) {\n+                if let Some(id) = token_map.synthetic_token_id(*leaf.span()) {\n                     let original = undo_info.original[id.0 as usize].clone();\n-                    if original.delimiter.is_none() {\n+                    if original.delimiter.kind == tt::DelimiterKind::Invisible {\n                         original.token_trees.into()\n                     } else {\n                         SmallVec::from_const([original.into()])\n@@ -327,6 +329,8 @@ pub(crate) fn reverse_fixups(\n mod tests {\n     use expect_test::{expect, Expect};\n \n+    use crate::tt;\n+\n     use super::reverse_fixups;\n \n     // The following three functions are only meant to check partial structural equivalence of\n@@ -341,7 +345,7 @@ mod tests {\n     }\n \n     fn check_subtree_eq(a: &tt::Subtree, b: &tt::Subtree) -> bool {\n-        a.delimiter.map(|it| it.kind) == b.delimiter.map(|it| it.kind)\n+        a.delimiter.kind == b.delimiter.kind\n             && a.token_trees.len() == b.token_trees.len()\n             && a.token_trees.iter().zip(&b.token_trees).all(|(a, b)| check_tt_eq(a, b))\n     }\n@@ -386,7 +390,7 @@ mod tests {\n         let (original_as_tt, _) = mbe::syntax_node_to_token_tree(&parsed.syntax_node());\n         assert!(\n             check_subtree_eq(&tt, &original_as_tt),\n-            \"different token tree: {tt:?}, {original_as_tt:?}\"\n+            \"different token tree: {tt:?},\\n{original_as_tt:?}\"\n         );\n     }\n "}, {"sha": "2300ee9d089983ec7affd1cd2f97d5b58e914f88", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -128,7 +128,7 @@ struct HygieneInfo {\n     attr_input_or_mac_def_start: Option<InFile<TextSize>>,\n \n     macro_def: Arc<TokenExpander>,\n-    macro_arg: Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupUndoInfo)>,\n+    macro_arg: Arc<(crate::tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupUndoInfo)>,\n     macro_arg_shift: mbe::Shift,\n     exp_map: Arc<mbe::TokenMap>,\n }\n@@ -191,7 +191,7 @@ fn make_hygiene_info(\n             let tt = ast_id\n                 .to_node(db)\n                 .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .and_then(Either::left)?\n                 .token_tree()?;\n             Some(InFile::new(ast_id.file_id, tt))"}, {"sha": "bc941b541724271b88c90f551d39ba42396bb50b", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -17,10 +17,13 @@ pub mod proc_macro;\n pub mod quote;\n pub mod eager;\n pub mod mod_path;\n+pub mod attrs;\n mod fixup;\n \n pub use mbe::{Origin, ValueResult};\n \n+use ::tt::token_id as tt;\n+\n use std::{fmt, hash::Hash, iter, sync::Arc};\n \n use base_db::{\n@@ -37,6 +40,7 @@ use syntax::{\n \n use crate::{\n     ast_id_map::FileAstId,\n+    attrs::AttrId,\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n@@ -114,6 +118,7 @@ pub struct MacroDefId {\n     pub krate: CrateId,\n     pub kind: MacroDefKind,\n     pub local_inner: bool,\n+    pub allow_internal_unsafe: bool,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -145,7 +150,7 @@ pub enum MacroCallKind {\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n-        derive_attr_index: u32,\n+        derive_attr_index: AttrId,\n         /// Index of the derive macro in the derive attribute\n         derive_index: u32,\n     },\n@@ -156,7 +161,7 @@ pub enum MacroCallKind {\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n-        invoc_attr_index: u32,\n+        invoc_attr_index: AttrId,\n         /// Whether this attribute is the `#[derive]` attribute.\n         is_derive: bool,\n     },\n@@ -261,10 +266,11 @@ impl HirFileId {\n         });\n         let attr_input_or_mac_def = def.or_else(|| match loc.kind {\n             MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+                // FIXME: handle `cfg_attr`\n                 let tt = ast_id\n                     .to_node(db)\n                     .doc_comments_and_attrs()\n-                    .nth(invoc_attr_index as usize)\n+                    .nth(invoc_attr_index.ast_index())\n                     .and_then(Either::left)?\n                     .token_tree()?;\n                 Some(InFile::new(ast_id.file_id, tt))\n@@ -353,6 +359,14 @@ impl HirFileId {\n         }\n     }\n \n+    #[inline]\n+    pub fn file_id(self) -> Option<FileId> {\n+        match self.0 & Self::MACRO_FILE_TAG_MASK {\n+            0 => Some(FileId(self.0)),\n+            _ => None,\n+        }\n+    }\n+\n     fn repr(self) -> HirFileIdRepr {\n         match self.0 & Self::MACRO_FILE_TAG_MASK {\n             0 => HirFileIdRepr::FileId(FileId(self.0)),\n@@ -397,8 +411,7 @@ impl MacroDefId {\n     }\n }\n \n-// FIXME: attribute indices do not account for `cfg_attr`, which means that we'll strip the whole\n-// `cfg_attr` instead of just one of the attributes it expands to\n+// FIXME: attribute indices do not account for nested `cfg_attr`\n \n impl MacroCallKind {\n     /// Returns the file containing the macro invocation.\n@@ -419,7 +432,7 @@ impl MacroCallKind {\n                 // FIXME: handle `cfg_attr`\n                 ast_id.with_value(ast_id.to_node(db)).map(|it| {\n                     it.doc_comments_and_attrs()\n-                        .nth(*derive_attr_index as usize)\n+                        .nth(derive_attr_index.ast_index())\n                         .and_then(|it| match it {\n                             Either::Left(attr) => Some(attr.syntax().clone()),\n                             Either::Right(_) => None,\n@@ -431,7 +444,7 @@ impl MacroCallKind {\n                 // FIXME: handle `cfg_attr`\n                 ast_id.with_value(ast_id.to_node(db)).map(|it| {\n                     it.doc_comments_and_attrs()\n-                        .nth(*invoc_attr_index as usize)\n+                        .nth(invoc_attr_index.ast_index())\n                         .and_then(|it| match it {\n                             Either::Left(attr) => Some(attr.syntax().clone()),\n                             Either::Right(_) => None,\n@@ -488,19 +501,21 @@ impl MacroCallKind {\n             MacroCallKind::FnLike { ast_id, .. } => ast_id.to_node(db).syntax().text_range(),\n             MacroCallKind::Derive { ast_id, derive_attr_index, .. } => {\n                 // FIXME: should be the range of the macro name, not the whole derive\n+                // FIXME: handle `cfg_attr`\n                 ast_id\n                     .to_node(db)\n                     .doc_comments_and_attrs()\n-                    .nth(derive_attr_index as usize)\n+                    .nth(derive_attr_index.ast_index())\n                     .expect(\"missing derive\")\n                     .expect_left(\"derive is a doc comment?\")\n                     .syntax()\n                     .text_range()\n             }\n+            // FIXME: handle `cfg_attr`\n             MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => ast_id\n                 .to_node(db)\n                 .doc_comments_and_attrs()\n-                .nth(invoc_attr_index as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .expect(\"missing attribute\")\n                 .expect_left(\"attribute macro is a doc comment?\")\n                 .syntax()\n@@ -592,9 +607,10 @@ impl ExpansionInfo {\n             let token_range = token.value.text_range();\n             match &loc.kind {\n                 MacroCallKind::Attr { attr_args, invoc_attr_index, is_derive, .. } => {\n+                    // FIXME: handle `cfg_attr`\n                     let attr = item\n                         .doc_comments_and_attrs()\n-                        .nth(*invoc_attr_index as usize)\n+                        .nth(invoc_attr_index.ast_index())\n                         .and_then(Either::left)?;\n                     match attr.token_tree() {\n                         Some(token_tree)\n@@ -1031,3 +1047,5 @@ impl ExpandTo {\n pub struct UnresolvedMacro {\n     pub path: ModPath,\n }\n+\n+intern::impl_internable!(ModPath, attrs::AttrInput);"}, {"sha": "c3462beac73c5bd9a6f17bd7105a6a635440f652", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt;\n \n-use syntax::{ast, SmolStr, SyntaxKind};\n+use syntax::{ast, utils::is_raw_identifier, SmolStr};\n \n /// `Name` is a wrapper around string, which is used in hir for both references\n /// and declarations. In theory, names should also carry hygiene info, but we are\n@@ -33,11 +33,6 @@ impl fmt::Display for Name {\n     }\n }\n \n-fn is_raw_identifier(name: &str) -> bool {\n-    let is_keyword = SyntaxKind::from_keyword(name).is_some();\n-    is_keyword && !matches!(name, \"self\" | \"crate\" | \"super\" | \"Self\")\n-}\n-\n impl<'a> fmt::Display for UnescapedName<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match &self.0 .0 {\n@@ -133,6 +128,14 @@ impl Name {\n         }\n     }\n \n+    /// Returns the text this name represents if it isn't a tuple field.\n+    pub fn as_str(&self) -> Option<&str> {\n+        match &self.0 {\n+            Repr::Text(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns the textual representation of this name as a [`SmolStr`].\n     /// Prefer using this over [`ToString::to_string`] if possible as this conversion is cheaper in\n     /// the general case.\n@@ -183,7 +186,7 @@ impl AsName for ast::NameOrNameRef {\n     }\n }\n \n-impl AsName for tt::Ident {\n+impl<Span> AsName for tt::Ident<Span> {\n     fn as_name(&self) -> Name {\n         Name::resolve(&self.text)\n     }\n@@ -339,6 +342,7 @@ pub mod known {\n         recursion_limit,\n         feature,\n         // known methods of lang items\n+        call_once,\n         eq,\n         ne,\n         ge,"}, {"sha": "3f4d2540c099a9f66ffae8fafccb176ccc8ce89a", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/proc_macro.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,7 +3,7 @@\n use base_db::{CrateId, ProcMacroExpansionError, ProcMacroId, ProcMacroKind};\n use stdx::never;\n \n-use crate::{db::AstDatabase, ExpandError, ExpandResult};\n+use crate::{db::AstDatabase, tt, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n@@ -39,7 +39,10 @@ impl ProcMacroExpander {\n                     Ok(proc_macros) => proc_macros,\n                     Err(_) => {\n                         never!(\"Non-dummy expander even though there are no proc macros\");\n-                        return ExpandResult::only_err(ExpandError::Other(\"Internal error\".into()));\n+                        return ExpandResult::with_err(\n+                            tt::Subtree::empty(),\n+                            ExpandError::Other(\"Internal error\".into()),\n+                        );\n                     }\n                 };\n                 let proc_macro = match proc_macros.get(id.0 as usize) {\n@@ -50,7 +53,10 @@ impl ProcMacroExpander {\n                             proc_macros.len(),\n                             id.0\n                         );\n-                        return ExpandResult::only_err(ExpandError::Other(\"Internal error\".into()));\n+                        return ExpandResult::with_err(\n+                            tt::Subtree::empty(),\n+                            ExpandError::Other(\"Internal error\".into()),\n+                        );\n                     }\n                 };\n \n@@ -69,13 +75,17 @@ impl ProcMacroExpander {\n                             }\n                         }\n                         ProcMacroExpansionError::System(text)\n-                        | ProcMacroExpansionError::Panic(text) => {\n-                            ExpandResult::only_err(ExpandError::Other(text.into()))\n-                        }\n+                        | ProcMacroExpansionError::Panic(text) => ExpandResult::with_err(\n+                            tt::Subtree::empty(),\n+                            ExpandError::Other(text.into()),\n+                        ),\n                     },\n                 }\n             }\n-            None => ExpandResult::only_err(ExpandError::UnresolvedProcMacro(self.krate)),\n+            None => ExpandResult::with_err(\n+                tt::Subtree::empty(),\n+                ExpandError::UnresolvedProcMacro(self.krate),\n+            ),\n         }\n     }\n }"}, {"sha": "63586f9daf0695b4a5538666b075ab96bbcd34f6", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/quote.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -9,17 +9,18 @@\n #[macro_export]\n macro_rules! __quote {\n     () => {\n-        Vec::<tt::TokenTree>::new()\n+        Vec::<crate::tt::TokenTree>::new()\n     };\n \n     ( @SUBTREE $delim:ident $($tt:tt)* ) => {\n         {\n             let children = $crate::__quote!($($tt)*);\n-            tt::Subtree {\n-                delimiter: Some(tt::Delimiter {\n-                    kind: tt::DelimiterKind::$delim,\n-                    id: tt::TokenId::unspecified(),\n-                }),\n+            crate::tt::Subtree {\n+                delimiter: crate::tt::Delimiter {\n+                    kind: crate::tt::DelimiterKind::$delim,\n+                    open: crate::tt::TokenId::unspecified(),\n+                    close: crate::tt::TokenId::unspecified(),\n+                },\n                 token_trees: $crate::quote::IntoTt::to_tokens(children),\n             }\n         }\n@@ -28,10 +29,10 @@ macro_rules! __quote {\n     ( @PUNCT $first:literal ) => {\n         {\n             vec![\n-                tt::Leaf::Punct(tt::Punct {\n+                crate::tt::Leaf::Punct(crate::tt::Punct {\n                     char: $first,\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n+                    spacing: crate::tt::Spacing::Alone,\n+                    span: crate::tt::TokenId::unspecified(),\n                 }).into()\n             ]\n         }\n@@ -40,15 +41,15 @@ macro_rules! __quote {\n     ( @PUNCT $first:literal, $sec:literal ) => {\n         {\n             vec![\n-                tt::Leaf::Punct(tt::Punct {\n+                crate::tt::Leaf::Punct(crate::tt::Punct {\n                     char: $first,\n-                    spacing: tt::Spacing::Joint,\n-                    id: tt::TokenId::unspecified(),\n+                    spacing: crate::tt::Spacing::Joint,\n+                    span: crate::tt::TokenId::unspecified(),\n                 }).into(),\n-                tt::Leaf::Punct(tt::Punct {\n+                crate::tt::Leaf::Punct(crate::tt::Punct {\n                     char: $sec,\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n+                    spacing: crate::tt::Spacing::Alone,\n+                    span: crate::tt::TokenId::unspecified(),\n                 }).into()\n             ]\n         }\n@@ -67,7 +68,7 @@ macro_rules! __quote {\n \n     ( ## $first:ident $($tail:tt)* ) => {\n         {\n-            let mut tokens = $first.into_iter().map($crate::quote::ToTokenTree::to_token).collect::<Vec<tt::TokenTree>>();\n+            let mut tokens = $first.into_iter().map($crate::quote::ToTokenTree::to_token).collect::<Vec<crate::tt::TokenTree>>();\n             let mut tail_tokens = $crate::quote::IntoTt::to_tokens($crate::__quote!($($tail)*));\n             tokens.append(&mut tail_tokens);\n             tokens\n@@ -86,9 +87,9 @@ macro_rules! __quote {\n     // Ident\n     ( $tt:ident ) => {\n         vec![ {\n-            tt::Leaf::Ident(tt::Ident {\n+            crate::tt::Leaf::Ident(crate::tt::Ident {\n                 text: stringify!($tt).into(),\n-                id: tt::TokenId::unspecified(),\n+                span: crate::tt::TokenId::unspecified(),\n             }).into()\n         }]\n     };\n@@ -127,42 +128,42 @@ macro_rules! quote {\n }\n \n pub(crate) trait IntoTt {\n-    fn to_subtree(self) -> tt::Subtree;\n-    fn to_tokens(self) -> Vec<tt::TokenTree>;\n+    fn to_subtree(self) -> crate::tt::Subtree;\n+    fn to_tokens(self) -> Vec<crate::tt::TokenTree>;\n }\n \n-impl IntoTt for Vec<tt::TokenTree> {\n-    fn to_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: None, token_trees: self }\n+impl IntoTt for Vec<crate::tt::TokenTree> {\n+    fn to_subtree(self) -> crate::tt::Subtree {\n+        crate::tt::Subtree { delimiter: crate::tt::Delimiter::unspecified(), token_trees: self }\n     }\n \n-    fn to_tokens(self) -> Vec<tt::TokenTree> {\n+    fn to_tokens(self) -> Vec<crate::tt::TokenTree> {\n         self\n     }\n }\n \n-impl IntoTt for tt::Subtree {\n-    fn to_subtree(self) -> tt::Subtree {\n+impl IntoTt for crate::tt::Subtree {\n+    fn to_subtree(self) -> crate::tt::Subtree {\n         self\n     }\n \n-    fn to_tokens(self) -> Vec<tt::TokenTree> {\n-        vec![tt::TokenTree::Subtree(self)]\n+    fn to_tokens(self) -> Vec<crate::tt::TokenTree> {\n+        vec![crate::tt::TokenTree::Subtree(self)]\n     }\n }\n \n pub(crate) trait ToTokenTree {\n-    fn to_token(self) -> tt::TokenTree;\n+    fn to_token(self) -> crate::tt::TokenTree;\n }\n \n-impl ToTokenTree for tt::TokenTree {\n-    fn to_token(self) -> tt::TokenTree {\n+impl ToTokenTree for crate::tt::TokenTree {\n+    fn to_token(self) -> crate::tt::TokenTree {\n         self\n     }\n }\n \n-impl ToTokenTree for tt::Subtree {\n-    fn to_token(self) -> tt::TokenTree {\n+impl ToTokenTree for crate::tt::Subtree {\n+    fn to_token(self) -> crate::tt::TokenTree {\n         self.into()\n     }\n }\n@@ -171,15 +172,15 @@ macro_rules! impl_to_to_tokentrees {\n     ($($ty:ty => $this:ident $im:block);*) => {\n         $(\n             impl ToTokenTree for $ty {\n-                fn to_token($this) -> tt::TokenTree {\n-                    let leaf: tt::Leaf = $im.into();\n+                fn to_token($this) -> crate::tt::TokenTree {\n+                    let leaf: crate::tt::Leaf = $im.into();\n                     leaf.into()\n                 }\n             }\n \n             impl ToTokenTree for &$ty {\n-                fn to_token($this) -> tt::TokenTree {\n-                    let leaf: tt::Leaf = $im.clone().into();\n+                fn to_token($this) -> crate::tt::TokenTree {\n+                    let leaf: crate::tt::Leaf = $im.clone().into();\n                     leaf.into()\n                 }\n             }\n@@ -188,16 +189,16 @@ macro_rules! impl_to_to_tokentrees {\n }\n \n impl_to_to_tokentrees! {\n-    u32 => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    usize => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    i32 => self { tt::Literal{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    bool => self { tt::Ident{text: self.to_string().into(), id: tt::TokenId::unspecified()} };\n-    tt::Leaf => self { self };\n-    tt::Literal => self { self };\n-    tt::Ident => self { self };\n-    tt::Punct => self { self };\n-    &str => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), id: tt::TokenId::unspecified()}};\n-    String => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), id: tt::TokenId::unspecified()}}\n+    u32 => self { crate::tt::Literal{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    usize => self { crate::tt::Literal{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    i32 => self { crate::tt::Literal{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    bool => self { crate::tt::Ident{text: self.to_string().into(), span: crate::tt::TokenId::unspecified()} };\n+    crate::tt::Leaf => self { self };\n+    crate::tt::Literal => self { self };\n+    crate::tt::Ident => self { self };\n+    crate::tt::Punct => self { self };\n+    &str => self { crate::tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), span: crate::tt::TokenId::unspecified()}};\n+    String => self { crate::tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), span: crate::tt::TokenId::unspecified()}}\n }\n \n #[cfg(test)]\n@@ -223,8 +224,8 @@ mod tests {\n         assert_eq!(quote!(#s).to_string(), \"\\\"hello\\\"\");\n     }\n \n-    fn mk_ident(name: &str) -> tt::Ident {\n-        tt::Ident { text: name.into(), id: tt::TokenId::unspecified() }\n+    fn mk_ident(name: &str) -> crate::tt::Ident {\n+        crate::tt::Ident { text: name.into(), span: crate::tt::TokenId::unspecified() }\n     }\n \n     #[test]\n@@ -234,7 +235,7 @@ mod tests {\n         let quoted = quote!(#a);\n         assert_eq!(quoted.to_string(), \"hello\");\n         let t = format!(\"{quoted:?}\");\n-        assert_eq!(t, \"SUBTREE $\\n  IDENT   hello 4294967295\");\n+        assert_eq!(t, \"SUBTREE $$ 4294967295 4294967295\\n  IDENT   hello 4294967295\");\n     }\n \n     #[test]\n@@ -263,11 +264,12 @@ mod tests {\n         let fields = [mk_ident(\"name\"), mk_ident(\"id\")];\n         let fields = fields.iter().flat_map(|it| quote!(#it: self.#it.clone(), ).token_trees);\n \n-        let list = tt::Subtree {\n-            delimiter: Some(tt::Delimiter {\n-                kind: tt::DelimiterKind::Brace,\n-                id: tt::TokenId::unspecified(),\n-            }),\n+        let list = crate::tt::Subtree {\n+            delimiter: crate::tt::Delimiter {\n+                kind: crate::tt::DelimiterKind::Brace,\n+                open: crate::tt::TokenId::unspecified(),\n+                close: crate::tt::TokenId::unspecified(),\n+            },\n             token_trees: fields.collect(),\n         };\n "}, {"sha": "490bbe1e7240de86f4fdbcd799f2684520a2f4e3", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"hir-ty\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -24,24 +26,29 @@ chalk-ir = \"0.88.0\"\n chalk-recursive = { version = \"0.88.0\", default-features = false }\n chalk-derive = \"0.88.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-once_cell = \"1.15.0\"\n+once_cell = \"1.17.0\"\n typed-arena = \"2.0.1\"\n rustc_index = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_index\", default-features = false }\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-hir-def = { path = \"../hir-def\", version = \"0.0.0\" }\n-hir-expand = { path = \"../hir-expand\", version = \"0.0.0\" }\n-base-db = { path = \"../base-db\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-limit = { path = \"../limit\", version = \"0.0.0\" }\n+# local deps\n+stdx.workspace = true\n+intern.workspace = true\n+hir-def.workspace = true\n+hir-expand.workspace = true\n+base-db.workspace = true\n+profile.workspace = true\n+syntax.workspace = true\n+limit.workspace = true\n \n [dev-dependencies]\n-test-utils = { path = \"../test-utils\" }\n expect-test = \"1.4.0\"\n tracing = \"0.1.35\"\n tracing-subscriber = { version = \"0.3.16\", default-features = false, features = [\n     \"env-filter\",\n     \"registry\",\n ] }\n tracing-tree = \"0.2.1\"\n+project-model = { path = \"../project-model\" }\n+\n+# local deps\n+test-utils.workspace = true"}, {"sha": "58744dd0c0f9858176d9ee1d2b4e05479611bf74", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -6,9 +6,9 @@\n use std::sync::Arc;\n \n use chalk_ir::cast::Cast;\n+use hir_def::lang_item::LangItem;\n use hir_expand::name::name;\n use limit::Limit;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, Canonical, Goal, Interner, ProjectionTyExt,\n@@ -17,11 +17,13 @@ use crate::{\n \n static AUTODEREF_RECURSION_LIMIT: Limit = Limit::new(10);\n \n+#[derive(Debug)]\n pub(crate) enum AutoderefKind {\n     Builtin,\n     Overloaded,\n }\n \n+#[derive(Debug)]\n pub(crate) struct Autoderef<'a, 'db> {\n     pub(crate) table: &'a mut InferenceTable<'db>,\n     ty: Ty,\n@@ -117,9 +119,8 @@ fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     }\n \n     let db = table.db;\n-    let deref_trait = db\n-        .lang_item(table.trait_env.krate, SmolStr::new_inline(\"deref\"))\n-        .and_then(|l| l.as_trait())?;\n+    let deref_trait =\n+        db.lang_item(table.trait_env.krate, LangItem::Deref).and_then(|l| l.as_trait())?;\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {"}, {"sha": "8faef7bf71e9815fd0dd3bd512c85332d31b9cb6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/builder.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -63,7 +63,7 @@ impl<D> TyBuilder<D> {\n     }\n \n     fn build_internal(self) -> (D, Substitution) {\n-        assert_eq!(self.vec.len(), self.param_kinds.len());\n+        assert_eq!(self.vec.len(), self.param_kinds.len(), \"{:?}\", &self.param_kinds);\n         for (a, e) in self.vec.iter().zip(self.param_kinds.iter()) {\n             self.assert_match_kind(a, e);\n         }\n@@ -282,6 +282,21 @@ impl TyBuilder<Tuple> {\n         let (Tuple(size), subst) = self.build_internal();\n         TyKind::Tuple(size, subst).intern(Interner)\n     }\n+\n+    pub fn tuple_with<I>(elements: I) -> Ty\n+    where\n+        I: IntoIterator<Item = Ty>,\n+        <I as IntoIterator>::IntoIter: ExactSizeIterator,\n+    {\n+        let elements = elements.into_iter();\n+        let len = elements.len();\n+        let mut b =\n+            TyBuilder::new(Tuple(len), iter::repeat(ParamKind::Type).take(len).collect(), None);\n+        for e in elements {\n+            b = b.push(e);\n+        }\n+        b.build()\n+    }\n }\n \n impl TyBuilder<TraitId> {"}, {"sha": "6989e9fb9be5c126c1dcf98fafa78376c05e014b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,7 +3,6 @@\n use std::sync::Arc;\n \n use cov_mark::hit;\n-use syntax::SmolStr;\n use tracing::debug;\n \n use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n@@ -12,7 +11,7 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n use base_db::CrateId;\n use hir_def::{\n     expr::Movability,\n-    lang_item::{lang_attr, LangItemTarget},\n+    lang_item::{lang_attr, LangItem, LangItemTarget},\n     AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n };\n use hir_expand::name::name;\n@@ -182,9 +181,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         &self,\n         well_known_trait: rust_ir::WellKnownTrait,\n     ) -> Option<chalk_ir::TraitId<Interner>> {\n-        let lang_attr = lang_attr_from_well_known_trait(well_known_trait);\n+        let lang_attr = lang_item_from_well_known_trait(well_known_trait);\n         let trait_ = match self.db.lang_item(self.krate, lang_attr.into()) {\n-            Some(LangItemTarget::TraitId(trait_)) => trait_,\n+            Some(LangItemTarget::Trait(trait_)) => trait_,\n             _ => return None,\n         };\n         Some(to_chalk_trait_id(trait_))\n@@ -206,7 +205,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     .return_type_impl_traits(func)\n                     .expect(\"impl trait id without impl traits\");\n                 let (datas, binders) = (*datas).as_ref().into_value_and_skipped_binders();\n-                let data = &datas.impl_traits[idx as usize];\n+                let data = &datas.impl_traits[idx];\n                 let bound = OpaqueTyDatumBound {\n                     bounds: make_single_type_binders(data.bounds.skip_binders().to_vec()),\n                     where_clauses: chalk_ir::Binders::empty(Interner, vec![]),\n@@ -216,7 +215,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             crate::ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                 if let Some((future_trait, future_output)) = self\n                     .db\n-                    .lang_item(self.krate, SmolStr::new_inline(\"future_trait\"))\n+                    .lang_item(self.krate, LangItem::Future)\n                     .and_then(|item| item.as_trait())\n                     .and_then(|trait_| {\n                         let alias =\n@@ -246,7 +245,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     binder.push(crate::wrap_empty_binders(impl_bound));\n                     let sized_trait = self\n                         .db\n-                        .lang_item(self.krate, SmolStr::new_inline(\"sized\"))\n+                        .lang_item(self.krate, LangItem::Sized)\n                         .and_then(|item| item.as_trait());\n                     if let Some(sized_trait_) = sized_trait {\n                         let sized_bound = WhereClause::Implemented(TraitRef {\n@@ -493,7 +492,7 @@ pub(crate) fn associated_ty_data_query(\n \n     if !ctx.unsized_types.borrow().contains(&self_ty) {\n         let sized_trait = db\n-            .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n+            .lang_item(resolver.krate(), LangItem::Sized)\n             .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n         let sized_bound = sized_trait.into_iter().map(|sized_trait| {\n             let trait_bound =\n@@ -541,8 +540,8 @@ pub(crate) fn trait_datum_query(\n     let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n     let associated_ty_ids = trait_data.associated_types().map(to_assoc_type_id).collect();\n     let trait_datum_bound = rust_ir::TraitDatumBound { where_clauses };\n-    let well_known =\n-        lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n+    let well_known = lang_attr(db.upcast(), trait_)\n+        .and_then(|name| well_known_trait_from_lang_item(LangItem::from_str(&name)?));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n         binders: make_binders(db, &generic_params, trait_datum_bound),\n@@ -553,42 +552,42 @@ pub(crate) fn trait_datum_query(\n     Arc::new(trait_datum)\n }\n \n-fn well_known_trait_from_lang_attr(name: &str) -> Option<WellKnownTrait> {\n-    Some(match name {\n-        \"clone\" => WellKnownTrait::Clone,\n-        \"coerce_unsized\" => WellKnownTrait::CoerceUnsized,\n-        \"copy\" => WellKnownTrait::Copy,\n-        \"discriminant_kind\" => WellKnownTrait::DiscriminantKind,\n-        \"dispatch_from_dyn\" => WellKnownTrait::DispatchFromDyn,\n-        \"drop\" => WellKnownTrait::Drop,\n-        \"fn\" => WellKnownTrait::Fn,\n-        \"fn_mut\" => WellKnownTrait::FnMut,\n-        \"fn_once\" => WellKnownTrait::FnOnce,\n-        \"generator\" => WellKnownTrait::Generator,\n-        \"sized\" => WellKnownTrait::Sized,\n-        \"unpin\" => WellKnownTrait::Unpin,\n-        \"unsize\" => WellKnownTrait::Unsize,\n-        \"tuple_trait\" => WellKnownTrait::Tuple,\n+fn well_known_trait_from_lang_item(item: LangItem) -> Option<WellKnownTrait> {\n+    Some(match item {\n+        LangItem::Clone => WellKnownTrait::Clone,\n+        LangItem::CoerceUnsized => WellKnownTrait::CoerceUnsized,\n+        LangItem::Copy => WellKnownTrait::Copy,\n+        LangItem::DiscriminantKind => WellKnownTrait::DiscriminantKind,\n+        LangItem::DispatchFromDyn => WellKnownTrait::DispatchFromDyn,\n+        LangItem::Drop => WellKnownTrait::Drop,\n+        LangItem::Fn => WellKnownTrait::Fn,\n+        LangItem::FnMut => WellKnownTrait::FnMut,\n+        LangItem::FnOnce => WellKnownTrait::FnOnce,\n+        LangItem::Generator => WellKnownTrait::Generator,\n+        LangItem::Sized => WellKnownTrait::Sized,\n+        LangItem::Unpin => WellKnownTrait::Unpin,\n+        LangItem::Unsize => WellKnownTrait::Unsize,\n+        LangItem::Tuple => WellKnownTrait::Tuple,\n         _ => return None,\n     })\n }\n \n-fn lang_attr_from_well_known_trait(attr: WellKnownTrait) -> &'static str {\n-    match attr {\n-        WellKnownTrait::Clone => \"clone\",\n-        WellKnownTrait::CoerceUnsized => \"coerce_unsized\",\n-        WellKnownTrait::Copy => \"copy\",\n-        WellKnownTrait::DiscriminantKind => \"discriminant_kind\",\n-        WellKnownTrait::DispatchFromDyn => \"dispatch_from_dyn\",\n-        WellKnownTrait::Drop => \"drop\",\n-        WellKnownTrait::Fn => \"fn\",\n-        WellKnownTrait::FnMut => \"fn_mut\",\n-        WellKnownTrait::FnOnce => \"fn_once\",\n-        WellKnownTrait::Generator => \"generator\",\n-        WellKnownTrait::Sized => \"sized\",\n-        WellKnownTrait::Tuple => \"tuple_trait\",\n-        WellKnownTrait::Unpin => \"unpin\",\n-        WellKnownTrait::Unsize => \"unsize\",\n+fn lang_item_from_well_known_trait(trait_: WellKnownTrait) -> LangItem {\n+    match trait_ {\n+        WellKnownTrait::Clone => LangItem::Clone,\n+        WellKnownTrait::CoerceUnsized => LangItem::CoerceUnsized,\n+        WellKnownTrait::Copy => LangItem::Copy,\n+        WellKnownTrait::DiscriminantKind => LangItem::DiscriminantKind,\n+        WellKnownTrait::DispatchFromDyn => LangItem::DispatchFromDyn,\n+        WellKnownTrait::Drop => LangItem::Drop,\n+        WellKnownTrait::Fn => LangItem::Fn,\n+        WellKnownTrait::FnMut => LangItem::FnMut,\n+        WellKnownTrait::FnOnce => LangItem::FnOnce,\n+        WellKnownTrait::Generator => LangItem::Generator,\n+        WellKnownTrait::Sized => LangItem::Sized,\n+        WellKnownTrait::Tuple => LangItem::Tuple,\n+        WellKnownTrait::Unpin => LangItem::Unpin,\n+        WellKnownTrait::Unsize => LangItem::Unsize,\n     }\n }\n "}, {"sha": "45c975dfcdc32033d1bd6c50f2565de8fb79376d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,13 +1,13 @@\n //! Various extensions traits for Chalk types.\n \n-use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, UintTy};\n+use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n     generics::TypeOrConstParamData,\n+    lang_item::LangItem,\n     type_ref::Rawness,\n     FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n };\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n@@ -18,6 +18,8 @@ use crate::{\n \n pub trait TyExt {\n     fn is_unit(&self) -> bool;\n+    fn is_integral(&self) -> bool;\n+    fn is_floating_point(&self) -> bool;\n     fn is_never(&self) -> bool;\n     fn is_unknown(&self) -> bool;\n     fn is_ty_var(&self) -> bool;\n@@ -51,6 +53,21 @@ impl TyExt for Ty {\n         matches!(self.kind(Interner), TyKind::Tuple(0, _))\n     }\n \n+    fn is_integral(&self) -> bool {\n+        matches!(\n+            self.kind(Interner),\n+            TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n+                | TyKind::InferenceVar(_, TyVariableKind::Integer)\n+        )\n+    }\n+\n+    fn is_floating_point(&self) -> bool {\n+        matches!(\n+            self.kind(Interner),\n+            TyKind::Scalar(Scalar::Float(_)) | TyKind::InferenceVar(_, TyVariableKind::Float)\n+        )\n+    }\n+\n     fn is_never(&self) -> bool {\n         matches!(self.kind(Interner), TyKind::Never)\n     }\n@@ -197,9 +214,8 @@ impl TyExt for Ty {\n                 match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n                     ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n                         let krate = def.module(db.upcast()).krate();\n-                        if let Some(future_trait) = db\n-                            .lang_item(krate, SmolStr::new_inline(\"future_trait\"))\n-                            .and_then(|item| item.as_trait())\n+                        if let Some(future_trait) =\n+                            db.lang_item(krate, LangItem::Future).and_then(|item| item.as_trait())\n                         {\n                             // This is only used by type walking.\n                             // Parameters will be walked outside, and projection predicate is not used.\n@@ -218,9 +234,8 @@ impl TyExt for Ty {\n                     }\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         db.return_type_impl_traits(func).map(|it| {\n-                            let data = (*it)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            let data =\n+                                (*it).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                             data.substitute(Interner, &subst).into_value_and_skipped_binders().0\n                         })\n                     }\n@@ -231,9 +246,8 @@ impl TyExt for Ty {\n                 {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         db.return_type_impl_traits(func).map(|it| {\n-                            let data = (*it)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            let data =\n+                                (*it).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                             data.substitute(Interner, &opaque_ty.substitution)\n                         })\n                     }"}, {"sha": "d45e2a943addf94a59358be99251536135414bfc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -65,7 +65,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn layout_of_adt(&self, def: AdtId, subst: Substitution) -> Result<Layout, LayoutError>;\n \n     #[salsa::invoke(crate::layout::target_data_layout_query)]\n-    fn target_data_layout(&self, krate: CrateId) -> Arc<TargetDataLayout>;\n+    fn target_data_layout(&self, krate: CrateId) -> Option<Arc<TargetDataLayout>>;\n \n     #[salsa::invoke(crate::lower::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDefId) -> PolyFnSig;"}, {"sha": "2c136896209242b391e769d5e0e3c37d663f7e75", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/decl_check/case_conv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -162,6 +162,7 @@ mod tests {\n         check(to_lower_snake_case, \"a\", expect![[\"\"]]);\n         check(to_lower_snake_case, \"abc\", expect![[\"\"]]);\n         check(to_lower_snake_case, \"foo__bar\", expect![[\"foo_bar\"]]);\n+        check(to_lower_snake_case, \"\u0394\", expect![\"\u03b4\"]);\n     }\n \n     #[test]\n@@ -195,5 +196,6 @@ mod tests {\n         check(to_upper_snake_case, \"X86_64\", expect![[\"\"]]);\n         check(to_upper_snake_case, \"FOO_BAr\", expect![[\"FOO_BAR\"]]);\n         check(to_upper_snake_case, \"FOO__BAR\", expect![[\"FOO_BAR\"]]);\n+        check(to_upper_snake_case, \"\u00df\", expect![\"SS\"]);\n     }\n }"}, {"sha": "3286dcb5afd7eed31db7b6195e1f63b4eb0e49e3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -5,7 +5,9 @@\n use std::fmt;\n use std::sync::Arc;\n \n-use hir_def::{path::path, resolver::HasResolver, AdtId, AssocItemId, DefWithBodyId, HasModule};\n+use hir_def::lang_item::LangItem;\n+use hir_def::{resolver::HasResolver, AdtId, AssocItemId, DefWithBodyId, HasModule};\n+use hir_def::{ItemContainerId, Lookup};\n use hir_expand::name;\n use itertools::Either;\n use itertools::Itertools;\n@@ -245,26 +247,25 @@ struct FilterMapNextChecker {\n impl FilterMapNextChecker {\n     fn new(resolver: &hir_def::resolver::Resolver, db: &dyn HirDatabase) -> Self {\n         // Find and store the FunctionIds for Iterator::filter_map and Iterator::next\n-        let iterator_path = path![core::iter::Iterator];\n-        let mut filter_map_function_id = None;\n-        let mut next_function_id = None;\n-\n-        if let Some(iterator_trait_id) = resolver.resolve_known_trait(db.upcast(), &iterator_path) {\n-            let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n-            for item in iterator_trait_items.iter() {\n-                if let (name, AssocItemId::FunctionId(id)) = item {\n-                    if *name == name![filter_map] {\n-                        filter_map_function_id = Some(*id);\n+        let (next_function_id, filter_map_function_id) = match db\n+            .lang_item(resolver.krate(), LangItem::IteratorNext)\n+            .and_then(|it| it.as_function())\n+        {\n+            Some(next_function_id) => (\n+                Some(next_function_id),\n+                match next_function_id.lookup(db.upcast()).container {\n+                    ItemContainerId::TraitId(iterator_trait_id) => {\n+                        let iterator_trait_items = &db.trait_data(iterator_trait_id).items;\n+                        iterator_trait_items.iter().find_map(|(name, it)| match it {\n+                            &AssocItemId::FunctionId(id) if *name == name![filter_map] => Some(id),\n+                            _ => None,\n+                        })\n                     }\n-                    if *name == name![next] {\n-                        next_function_id = Some(*id);\n-                    }\n-                }\n-                if filter_map_function_id.is_some() && next_function_id.is_some() {\n-                    break;\n-                }\n-            }\n-        }\n+                    _ => None,\n+                },\n+            ),\n+            None => (None, None),\n+        };\n         Self { filter_map_function_id, next_function_id, prev_filter_map_expr_id: None }\n     }\n "}, {"sha": "5fcbdf34f3cbbdaf4fc5073837fe8f8be105eab5", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 141, "deletions": 89, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -11,17 +11,17 @@ use hir_def::{\n     db::DefDatabase,\n     find_path,\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n-    intern::{Internable, Interned},\n     item_scope::ItemInNs,\n+    lang_item::{LangItem, LangItemTarget},\n     path::{Path, PathKind},\n     type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n     HasModule, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n+use intern::{Internable, Interned};\n use itertools::Itertools;\n use smallvec::SmallVec;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase,\n@@ -325,7 +325,7 @@ impl HirDisplay for ProjectionTy {\n \n         let trait_ref = self.trait_ref(f.db);\n         write!(f, \"<\")?;\n-        fmt_trait_ref(&trait_ref, f, true)?;\n+        fmt_trait_ref(f, &trait_ref, true)?;\n         write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n         let proj_params_count =\n             self.substitution.len(Interner) - trait_ref.substitution.len(Interner);\n@@ -383,7 +383,10 @@ impl HirDisplay for BoundVar {\n }\n \n impl HirDisplay for Ty {\n-    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n+    fn hir_fmt(\n+        &self,\n+        f @ &mut HirFormatter { db, .. }: &mut HirFormatter<'_>,\n+    ) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n             return write!(f, \"{TYPE_HINT_TRUNCATION}\");\n         }\n@@ -434,7 +437,7 @@ impl HirDisplay for Ty {\n                     bounds.iter().any(|bound| {\n                         if let WhereClause::Implemented(trait_ref) = bound.skip_binders() {\n                             let trait_ = trait_ref.hir_trait_id();\n-                            fn_traits(f.db.upcast(), trait_).any(|it| it == trait_)\n+                            fn_traits(db.upcast(), trait_).any(|it| it == trait_)\n                         } else {\n                             false\n                         }\n@@ -450,22 +453,20 @@ impl HirDisplay for Ty {\n                         substitution: parameters,\n                     }))\n                     | TyKind::OpaqueType(opaque_ty_id, parameters) => {\n-                        let impl_trait_id =\n-                            f.db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n+                        let impl_trait_id = db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n                         if let ImplTraitId::ReturnTypeImplTrait(func, idx) = impl_trait_id {\n-                            let datas =\n-                                f.db.return_type_impl_traits(func)\n-                                    .expect(\"impl trait id without data\");\n-                            let data = (*datas)\n-                                .as_ref()\n-                                .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            let datas = db\n+                                .return_type_impl_traits(func)\n+                                .expect(\"impl trait id without data\");\n+                            let data =\n+                                (*datas).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                             let bounds = data.substitute(Interner, parameters);\n                             let mut len = bounds.skip_binders().len();\n \n                             // Don't count Sized but count when it absent\n                             // (i.e. when explicit ?Sized bound is set).\n                             let default_sized = SizedByDefault::Sized {\n-                                anchor: func.lookup(f.db.upcast()).module(f.db.upcast()).krate(),\n+                                anchor: func.lookup(db.upcast()).module(db.upcast()).krate(),\n                             };\n                             let sized_bounds = bounds\n                                 .skip_binders()\n@@ -476,7 +477,7 @@ impl HirDisplay for Ty {\n                                         WhereClause::Implemented(trait_ref)\n                                             if default_sized.is_sized_trait(\n                                                 trait_ref.hir_trait_id(),\n-                                                f.db.upcast(),\n+                                                db.upcast(),\n                                             ),\n                                     )\n                                 })\n@@ -524,19 +525,19 @@ impl HirDisplay for Ty {\n                 sig.hir_fmt(f)?;\n             }\n             TyKind::FnDef(def, parameters) => {\n-                let def = from_chalk(f.db, *def);\n-                let sig = f.db.callable_item_signature(def).substitute(Interner, parameters);\n+                let def = from_chalk(db, *def);\n+                let sig = db.callable_item_signature(def).substitute(Interner, parameters);\n+                f.start_location_link(def.into());\n                 match def {\n-                    CallableDefId::FunctionId(ff) => {\n-                        write!(f, \"fn {}\", f.db.function_data(ff).name)?\n-                    }\n-                    CallableDefId::StructId(s) => write!(f, \"{}\", f.db.struct_data(s).name)?,\n+                    CallableDefId::FunctionId(ff) => write!(f, \"fn {}\", db.function_data(ff).name)?,\n+                    CallableDefId::StructId(s) => write!(f, \"{}\", db.struct_data(s).name)?,\n                     CallableDefId::EnumVariantId(e) => {\n-                        write!(f, \"{}\", f.db.enum_data(e.parent).variants[e.local_id].name)?\n+                        write!(f, \"{}\", db.enum_data(e.parent).variants[e.local_id].name)?\n                     }\n                 };\n+                f.end_location_link();\n                 if parameters.len(Interner) > 0 {\n-                    let generics = generics(f.db.upcast(), def.into());\n+                    let generics = generics(db.upcast(), def.into());\n                     let (parent_params, self_param, type_params, const_params, _impl_trait_params) =\n                         generics.provenance_split();\n                     let total_len = parent_params + self_param + type_params + const_params;\n@@ -568,15 +569,15 @@ impl HirDisplay for Ty {\n                 match f.display_target {\n                     DisplayTarget::Diagnostics | DisplayTarget::Test => {\n                         let name = match *def_id {\n-                            hir_def::AdtId::StructId(it) => f.db.struct_data(it).name.clone(),\n-                            hir_def::AdtId::UnionId(it) => f.db.union_data(it).name.clone(),\n-                            hir_def::AdtId::EnumId(it) => f.db.enum_data(it).name.clone(),\n+                            hir_def::AdtId::StructId(it) => db.struct_data(it).name.clone(),\n+                            hir_def::AdtId::UnionId(it) => db.union_data(it).name.clone(),\n+                            hir_def::AdtId::EnumId(it) => db.enum_data(it).name.clone(),\n                         };\n                         write!(f, \"{name}\")?;\n                     }\n                     DisplayTarget::SourceCode { module_id } => {\n                         if let Some(path) = find_path::find_path(\n-                            f.db.upcast(),\n+                            db.upcast(),\n                             ItemInNs::Types((*def_id).into()),\n                             module_id,\n                             false,\n@@ -596,8 +597,8 @@ impl HirDisplay for Ty {\n                         || f.omit_verbose_types()\n                     {\n                         match self\n-                            .as_generic_def(f.db)\n-                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                            .as_generic_def(db)\n+                            .map(|generic_def_id| db.generic_defaults(generic_def_id))\n                             .filter(|defaults| !defaults.is_empty())\n                         {\n                             None => parameters.as_slice(Interner),\n@@ -669,16 +670,23 @@ impl HirDisplay for Ty {\n             }\n             TyKind::AssociatedType(assoc_type_id, parameters) => {\n                 let type_alias = from_assoc_type_id(*assoc_type_id);\n-                let trait_ = match type_alias.lookup(f.db.upcast()).container {\n+                let trait_ = match type_alias.lookup(db.upcast()).container {\n                     ItemContainerId::TraitId(it) => it,\n                     _ => panic!(\"not an associated type\"),\n                 };\n-                let trait_ = f.db.trait_data(trait_);\n-                let type_alias_data = f.db.type_alias_data(type_alias);\n+                let trait_data = db.trait_data(trait_);\n+                let type_alias_data = db.type_alias_data(type_alias);\n \n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n-                    write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n+                    f.start_location_link(trait_.into());\n+                    write!(f, \"{}\", trait_data.name)?;\n+                    f.end_location_link();\n+                    write!(f, \"::\")?;\n+\n+                    f.start_location_link(type_alias.into());\n+                    write!(f, \"{}\", type_alias_data.name)?;\n+                    f.end_location_link();\n                     // Note that the generic args for the associated type come before those for the\n                     // trait (including the self type).\n                     // FIXME: reconsider the generic args order upon formatting?\n@@ -697,30 +705,54 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::Foreign(type_alias) => {\n-                let type_alias = f.db.type_alias_data(from_foreign_def_id(*type_alias));\n+                let alias = from_foreign_def_id(*type_alias);\n+                let type_alias = db.type_alias_data(alias);\n+                f.start_location_link(alias.into());\n                 write!(f, \"{}\", type_alias.name)?;\n+                f.end_location_link();\n             }\n             TyKind::OpaqueType(opaque_ty_id, parameters) => {\n-                let impl_trait_id = f.db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n+                let impl_trait_id = db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n                 match impl_trait_id {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n-                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n-                        let data = (*datas)\n-                            .as_ref()\n-                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data =\n+                            (*datas).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                         let bounds = data.substitute(Interner, &parameters);\n-                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n+                        let krate = func.lookup(db.upcast()).module(db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n+                            f,\n                             \"impl\",\n                             bounds.skip_binders(),\n                             SizedByDefault::Sized { anchor: krate },\n-                            f,\n                         )?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n-                    ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n-                        write!(f, \"impl Future<Output = \")?;\n+                    ImplTraitId::AsyncBlockTypeImplTrait(body, ..) => {\n+                        let future_trait = db\n+                            .lang_item(body.module(db.upcast()).krate(), LangItem::Future)\n+                            .and_then(LangItemTarget::as_trait);\n+                        let output = future_trait.and_then(|t| {\n+                            db.trait_data(t).associated_type_by_name(&hir_expand::name!(Output))\n+                        });\n+                        write!(f, \"impl \")?;\n+                        if let Some(t) = future_trait {\n+                            f.start_location_link(t.into());\n+                        }\n+                        write!(f, \"Future\")?;\n+                        if let Some(_) = future_trait {\n+                            f.end_location_link();\n+                        }\n+                        write!(f, \"<\")?;\n+                        if let Some(t) = output {\n+                            f.start_location_link(t.into());\n+                        }\n+                        write!(f, \"Output\")?;\n+                        if let Some(_) = output {\n+                            f.end_location_link();\n+                        }\n+                        write!(f, \" = \")?;\n                         parameters.at(Interner, 0).hir_fmt(f)?;\n                         write!(f, \">\")?;\n                     }\n@@ -732,7 +764,7 @@ impl HirDisplay for Ty {\n                         DisplaySourceCodeError::Closure,\n                     ));\n                 }\n-                let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(f.db);\n+                let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db);\n                 if let Some(sig) = sig {\n                     if sig.params().is_empty() {\n                         write!(f, \"||\")?;\n@@ -751,37 +783,37 @@ impl HirDisplay for Ty {\n                 }\n             }\n             TyKind::Placeholder(idx) => {\n-                let id = from_placeholder_idx(f.db, *idx);\n-                let generics = generics(f.db.upcast(), id.parent);\n+                let id = from_placeholder_idx(db, *idx);\n+                let generics = generics(db.upcast(), id.parent);\n                 let param_data = &generics.params.type_or_consts[id.local_id];\n                 match param_data {\n                     TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n                         TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n                             write!(f, \"{}\", p.name.clone().unwrap_or_else(Name::missing))?\n                         }\n                         TypeParamProvenance::ArgumentImplTrait => {\n-                            let substs = generics.placeholder_subst(f.db);\n-                            let bounds =\n-                                f.db.generic_predicates(id.parent)\n-                                    .iter()\n-                                    .map(|pred| pred.clone().substitute(Interner, &substs))\n-                                    .filter(|wc| match &wc.skip_binders() {\n-                                        WhereClause::Implemented(tr) => {\n-                                            &tr.self_type_parameter(Interner) == self\n-                                        }\n-                                        WhereClause::AliasEq(AliasEq {\n-                                            alias: AliasTy::Projection(proj),\n-                                            ty: _,\n-                                        }) => &proj.self_type_parameter(f.db) == self,\n-                                        _ => false,\n-                                    })\n-                                    .collect::<Vec<_>>();\n-                            let krate = id.parent.module(f.db.upcast()).krate();\n+                            let substs = generics.placeholder_subst(db);\n+                            let bounds = db\n+                                .generic_predicates(id.parent)\n+                                .iter()\n+                                .map(|pred| pred.clone().substitute(Interner, &substs))\n+                                .filter(|wc| match &wc.skip_binders() {\n+                                    WhereClause::Implemented(tr) => {\n+                                        &tr.self_type_parameter(Interner) == self\n+                                    }\n+                                    WhereClause::AliasEq(AliasEq {\n+                                        alias: AliasTy::Projection(proj),\n+                                        ty: _,\n+                                    }) => &proj.self_type_parameter(db) == self,\n+                                    _ => false,\n+                                })\n+                                .collect::<Vec<_>>();\n+                            let krate = id.parent.module(db.upcast()).krate();\n                             write_bounds_like_dyn_trait_with_prefix(\n+                                f,\n                                 \"impl\",\n                                 &bounds,\n                                 SizedByDefault::Sized { anchor: krate },\n-                                f,\n                             )?;\n                         }\n                     },\n@@ -803,29 +835,28 @@ impl HirDisplay for Ty {\n                 bounds.extend(auto_traits);\n \n                 write_bounds_like_dyn_trait_with_prefix(\n+                    f,\n                     \"dyn\",\n                     &bounds,\n                     SizedByDefault::NotSized,\n-                    f,\n                 )?;\n             }\n             TyKind::Alias(AliasTy::Projection(p_ty)) => p_ty.hir_fmt(f)?,\n             TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                let impl_trait_id = f.db.lookup_intern_impl_trait_id(opaque_ty.opaque_ty_id.into());\n+                let impl_trait_id = db.lookup_intern_impl_trait_id(opaque_ty.opaque_ty_id.into());\n                 match impl_trait_id {\n                     ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n-                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n-                        let data = (*datas)\n-                            .as_ref()\n-                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                            db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data =\n+                            (*datas).as_ref().map(|rpit| rpit.impl_traits[idx].bounds.clone());\n                         let bounds = data.substitute(Interner, &opaque_ty.substitution);\n-                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n+                        let krate = func.lookup(db.upcast()).module(db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n+                            f,\n                             \"impl\",\n                             bounds.skip_binders(),\n                             SizedByDefault::Sized { anchor: krate },\n-                            f,\n                         )?;\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n@@ -848,7 +879,6 @@ impl HirDisplay for Ty {\n                         DisplaySourceCodeError::Generator,\n                     ));\n                 }\n-\n                 let subst = subst.as_slice(Interner);\n                 let a: Option<SmallVec<[&Ty; 3]>> = subst\n                     .get(subst.len() - 3..)\n@@ -897,7 +927,7 @@ impl HirDisplay for CallableSig {\n     }\n }\n \n-fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = TraitId> {\n+fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = TraitId> + '_ {\n     let krate = trait_.lookup(db).container.krate();\n     utils::fn_traits(db, krate)\n }\n@@ -914,7 +944,7 @@ impl SizedByDefault {\n             Self::NotSized => false,\n             Self::Sized { anchor } => {\n                 let sized_trait = db\n-                    .lang_item(anchor, SmolStr::new_inline(\"sized\"))\n+                    .lang_item(anchor, LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait());\n                 Some(trait_) == sized_trait\n             }\n@@ -923,26 +953,26 @@ impl SizedByDefault {\n }\n \n pub fn write_bounds_like_dyn_trait_with_prefix(\n+    f: &mut HirFormatter<'_>,\n     prefix: &str,\n     predicates: &[QuantifiedWhereClause],\n     default_sized: SizedByDefault,\n-    f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n     write!(f, \"{prefix}\")?;\n     if !predicates.is_empty()\n         || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })\n     {\n         write!(f, \" \")?;\n-        write_bounds_like_dyn_trait(predicates, default_sized, f)\n+        write_bounds_like_dyn_trait(f, predicates, default_sized)\n     } else {\n         Ok(())\n     }\n }\n \n fn write_bounds_like_dyn_trait(\n+    f: &mut HirFormatter<'_>,\n     predicates: &[QuantifiedWhereClause],\n     default_sized: SizedByDefault,\n-    f: &mut HirFormatter<'_>,\n ) -> Result<(), HirDisplayError> {\n     // Note: This code is written to produce nice results (i.e.\n     // corresponding to surface Rust) for types that can occur in\n@@ -978,7 +1008,9 @@ fn write_bounds_like_dyn_trait(\n                 // We assume that the self type is ^0.0 (i.e. the\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n+                f.start_location_link(trait_.into());\n                 write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+                f.end_location_link();\n                 if let [_, params @ ..] = &*trait_ref.substitution.as_slice(Interner) {\n                     if is_fn_trait {\n                         if let Some(args) =\n@@ -1015,7 +1047,9 @@ fn write_bounds_like_dyn_trait(\n                 if let AliasTy::Projection(proj) = alias {\n                     let assoc_ty_id = from_assoc_type_id(proj.associated_ty_id);\n                     let type_alias = f.db.type_alias_data(assoc_ty_id);\n+                    f.start_location_link(assoc_ty_id.into());\n                     write!(f, \"{}\", type_alias.name)?;\n+                    f.end_location_link();\n \n                     let proj_arg_count = generics(f.db.upcast(), assoc_ty_id.into()).len_self();\n                     if proj_arg_count > 0 {\n@@ -1040,19 +1074,33 @@ fn write_bounds_like_dyn_trait(\n     if angle_open {\n         write!(f, \">\")?;\n     }\n-    if matches!(default_sized, SizedByDefault::Sized { .. }) {\n+    if let SizedByDefault::Sized { anchor } = default_sized {\n+        let sized_trait =\n+            f.db.lang_item(anchor, LangItem::Sized).and_then(|lang_item| lang_item.as_trait());\n         if !is_sized {\n-            write!(f, \"{}?Sized\", if first { \"\" } else { \" + \" })?;\n+            if !first {\n+                write!(f, \" + \")?;\n+            }\n+            if let Some(sized_trait) = sized_trait {\n+                f.start_location_link(sized_trait.into());\n+            }\n+            write!(f, \"?Sized\")?;\n         } else if first {\n+            if let Some(sized_trait) = sized_trait {\n+                f.start_location_link(sized_trait.into());\n+            }\n             write!(f, \"Sized\")?;\n         }\n+        if let Some(_) = sized_trait {\n+            f.end_location_link();\n+        }\n     }\n     Ok(())\n }\n \n fn fmt_trait_ref(\n-    tr: &TraitRef,\n     f: &mut HirFormatter<'_>,\n+    tr: &TraitRef,\n     use_as: bool,\n ) -> Result<(), HirDisplayError> {\n     if f.should_truncate() {\n@@ -1065,7 +1113,10 @@ fn fmt_trait_ref(\n     } else {\n         write!(f, \": \")?;\n     }\n-    write!(f, \"{}\", f.db.trait_data(tr.hir_trait_id()).name)?;\n+    let trait_ = tr.hir_trait_id();\n+    f.start_location_link(trait_.into());\n+    write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+    f.end_location_link();\n     if tr.substitution.len(Interner) > 1 {\n         write!(f, \"<\")?;\n         f.write_joined(&tr.substitution.as_slice(Interner)[1..], \", \")?;\n@@ -1076,7 +1127,7 @@ fn fmt_trait_ref(\n \n impl HirDisplay for TraitRef {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        fmt_trait_ref(self, f, false)\n+        fmt_trait_ref(f, self, false)\n     }\n }\n \n@@ -1090,12 +1141,13 @@ impl HirDisplay for WhereClause {\n             WhereClause::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n             WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n                 write!(f, \"<\")?;\n-                fmt_trait_ref(&projection_ty.trait_ref(f.db), f, true)?;\n-                write!(\n-                    f,\n-                    \">::{} = \",\n-                    f.db.type_alias_data(from_assoc_type_id(projection_ty.associated_ty_id)).name,\n-                )?;\n+                fmt_trait_ref(f, &projection_ty.trait_ref(f.db), true)?;\n+                write!(f, \">::\",)?;\n+                let type_alias = from_assoc_type_id(projection_ty.associated_ty_id);\n+                f.start_location_link(type_alias.into());\n+                write!(f, \"{}\", f.db.type_alias_data(type_alias).name,)?;\n+                f.end_location_link();\n+                write!(f, \" = \")?;\n                 ty.hir_fmt(f)?;\n             }\n             WhereClause::AliasEq(_) => write!(f, \"{{error}}\")?,"}, {"sha": "767afdf9eb4e835b29e09cc0ce888d6a8f4953ba", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "modified", "additions": 63, "deletions": 59, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -22,15 +22,15 @@ use hir_def::{\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n     expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n-    lang_item::LangItemTarget,\n+    lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n-    path::{path, Path},\n+    path::Path,\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n     ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::name;\n use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n@@ -39,7 +39,7 @@ use stdx::always;\n use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n     lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal,\n-    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, Substitution,\n+    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId, Substitution,\n     TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n@@ -219,6 +219,7 @@ struct InternedStandardTypes {\n     unknown: Ty,\n     bool_: Ty,\n     unit: Ty,\n+    never: Ty,\n }\n \n impl Default for InternedStandardTypes {\n@@ -227,6 +228,7 @@ impl Default for InternedStandardTypes {\n             unknown: TyKind::Error.intern(Interner),\n             bool_: TyKind::Scalar(Scalar::Bool).intern(Interner),\n             unit: TyKind::Tuple(0, Substitution::empty(Interner)).intern(Interner),\n+            never: TyKind::Never.intern(Interner),\n         }\n     }\n }\n@@ -352,6 +354,7 @@ pub struct InferenceResult {\n     /// **Note**: When a pattern type is resolved it may still contain\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n+    pub type_of_rpit: ArenaMap<RpitId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n     /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n@@ -525,6 +528,9 @@ impl<'a> InferenceContext<'a> {\n         for ty in result.type_of_pat.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n+        for ty in result.type_of_rpit.iter_mut().map(|x| x.1) {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n         for mismatch in result.type_mismatches.values_mut() {\n             mismatch.expected = table.resolve_completely(mismatch.expected.clone());\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());\n@@ -603,7 +609,7 @@ impl<'a> InferenceContext<'a> {\n                         _ => unreachable!(),\n                     };\n                     let bounds = (*rpits).map_ref(|rpits| {\n-                        rpits.impl_traits[idx as usize].bounds.map_ref(|it| it.into_iter())\n+                        rpits.impl_traits[idx].bounds.map_ref(|it| it.into_iter())\n                     });\n                     let var = self.table.new_type_var();\n                     let var_subst = Substitution::from1(Interner, var.clone());\n@@ -616,6 +622,7 @@ impl<'a> InferenceContext<'a> {\n                         always!(binders.is_empty(Interner)); // quantified where clauses not yet handled\n                         self.push_obligation(var_predicate.cast(Interner));\n                     }\n+                    self.result.type_of_rpit.insert(idx, var.clone());\n                     var\n                 },\n                 DebruijnIndex::INNERMOST,\n@@ -917,104 +924,98 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn resolve_lang_item(&self, name: Name) -> Option<LangItemTarget> {\n+    fn resolve_lang_item(&self, item: LangItem) -> Option<LangItemTarget> {\n         let krate = self.resolver.krate();\n-        self.db.lang_item(krate, name.to_smol_str())\n+        self.db.lang_item(krate, item)\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let path = path![core::iter::IntoIterator];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+        let ItemContainerId::TraitId(trait_) = self.resolve_lang_item(LangItem::IntoIterIntoIter)?\n+            .as_function()?\n+            .lookup(self.db.upcast()).container\n+        else { return None };\n         self.db.trait_data(trait_).associated_type_by_name(&name![IntoIter])\n     }\n \n     fn resolve_iterator_item(&self) -> Option<TypeAliasId> {\n-        let path = path![core::iter::Iterator];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+        let ItemContainerId::TraitId(trait_) = self.resolve_lang_item(LangItem::IteratorNext)?\n+            .as_function()?\n+            .lookup(self.db.upcast()).container\n+        else { return None };\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n-    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        // FIXME resolve via lang_item once try v2 is stable\n-        let path = path![core::ops::Try];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n-        let trait_data = self.db.trait_data(trait_);\n-        trait_data\n-            // FIXME remove once try v2 is stable\n-            .associated_type_by_name(&name![Ok])\n-            .or_else(|| trait_data.associated_type_by_name(&name![Output]))\n+    fn resolve_output_on(&self, trait_: TraitId) -> Option<TypeAliasId> {\n+        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+    }\n+\n+    fn resolve_lang_trait(&self, lang: LangItem) -> Option<TraitId> {\n+        self.resolve_lang_item(lang)?.as_trait()\n+    }\n+\n+    fn resolve_ops_try_output(&self) -> Option<TypeAliasId> {\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Try)?)\n     }\n \n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(name![neg])?.as_trait()?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Neg)?)\n     }\n \n     fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(name![not])?.as_trait()?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Not)?)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self\n-            .resolver\n-            .resolve_known_trait(self.db.upcast(), &path![core::future::IntoFuture])\n-            .or_else(|| self.resolve_lang_item(name![future_trait])?.as_trait())?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        let ItemContainerId::TraitId(trait_) = self\n+            .resolve_lang_item(LangItem::IntoFutureIntoFuture)?\n+            .as_function()?\n+            .lookup(self.db.upcast())\n+            .container\n+        else { return None };\n+        self.resolve_output_on(trait_)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n-        let struct_ = self.resolve_lang_item(name![owned_box])?.as_struct()?;\n+        let struct_ = self.resolve_lang_item(LangItem::OwnedBox)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_full(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeFull];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeFull)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range(&self) -> Option<AdtId> {\n-        let path = path![core::ops::Range];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::Range)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_inclusive(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeInclusive];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeInclusiveStruct)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_from(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeFrom];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeFrom)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeTo];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeTo)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n-        let path = path![core::ops::RangeToInclusive];\n-        let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n+        let struct_ = self.resolve_lang_item(LangItem::RangeToInclusive)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n-    fn resolve_ops_index(&self) -> Option<TraitId> {\n-        self.resolve_lang_item(name![index])?.as_trait()\n-    }\n-\n     fn resolve_ops_index_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_ops_index()?;\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n+        self.resolve_output_on(self.resolve_lang_trait(LangItem::Index)?)\n     }\n \n     fn resolve_va_list(&self) -> Option<AdtId> {\n-        let struct_ = self.resolve_lang_item(name![va_list])?.as_struct()?;\n+        let struct_ = self.resolve_lang_item(LangItem::VaList)?.as_struct()?;\n         Some(struct_.into())\n     }\n }\n@@ -1025,7 +1026,8 @@ impl<'a> InferenceContext<'a> {\n pub(crate) enum Expectation {\n     None,\n     HasType(Ty),\n-    // Castable(Ty), // rustc has this, we currently just don't propagate an expectation for casts\n+    #[allow(dead_code)]\n+    Castable(Ty),\n     RValueLikeUnsized(Ty),\n }\n \n@@ -1041,10 +1043,6 @@ impl Expectation {\n         }\n     }\n \n-    fn from_option(ty: Option<Ty>) -> Self {\n-        ty.map_or(Expectation::None, Expectation::HasType)\n-    }\n-\n     /// The following explanation is copied straight from rustc:\n     /// Provides an expectation for an rvalue expression given an *optional*\n     /// hint, which is not required for type safety (the resulting type might\n@@ -1082,6 +1080,7 @@ impl Expectation {\n         match self {\n             Expectation::None => Expectation::None,\n             Expectation::HasType(t) => Expectation::HasType(table.resolve_ty_shallow(t)),\n+            Expectation::Castable(t) => Expectation::Castable(table.resolve_ty_shallow(t)),\n             Expectation::RValueLikeUnsized(t) => {\n                 Expectation::RValueLikeUnsized(table.resolve_ty_shallow(t))\n             }\n@@ -1091,20 +1090,25 @@ impl Expectation {\n     fn to_option(&self, table: &mut unify::InferenceTable<'_>) -> Option<Ty> {\n         match self.resolve(table) {\n             Expectation::None => None,\n-            Expectation::HasType(t) |\n-            // Expectation::Castable(t) |\n-            Expectation::RValueLikeUnsized(t) => Some(t),\n+            Expectation::HasType(t)\n+            | Expectation::Castable(t)\n+            | Expectation::RValueLikeUnsized(t) => Some(t),\n         }\n     }\n \n     fn only_has_type(&self, table: &mut unify::InferenceTable<'_>) -> Option<Ty> {\n         match self {\n             Expectation::HasType(t) => Some(table.resolve_ty_shallow(t)),\n-            // Expectation::Castable(_) |\n-            Expectation::RValueLikeUnsized(_) | Expectation::None => None,\n+            Expectation::Castable(_) | Expectation::RValueLikeUnsized(_) | Expectation::None => {\n+                None\n+            }\n         }\n     }\n \n+    fn coercion_target_type(&self, table: &mut unify::InferenceTable<'_>) -> Ty {\n+        self.only_has_type(table).unwrap_or_else(|| table.new_type_var())\n+    }\n+\n     /// Comment copied from rustc:\n     /// Disregard \"castable to\" expectations because they\n     /// can lead us astray. Consider for example `if cond"}, {"sha": "a6449d019ff6a07dcaf185d62f80c72f3dee3edc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -51,7 +51,7 @@ impl InferenceContext<'_> {\n                 .map(to_chalk_trait_id)\n                 .collect();\n \n-        let self_ty = TyKind::Error.intern(Interner);\n+        let self_ty = self.result.standard_types.unknown.clone();\n         let bounds = dyn_ty.bounds.clone().substitute(Interner, &[self_ty.cast(Interner)]);\n         for bound in bounds.iter(Interner) {\n             // NOTE(skip_binders): the extracted types are rebound by the returned `FnPointer`\n@@ -67,7 +67,7 @@ impl InferenceContext<'_> {\n                 let arg = projection.substitution.as_slice(Interner).get(1)?;\n                 if let Some(subst) = arg.ty(Interner)?.as_tuple() {\n                     let generic_args = subst.as_slice(Interner);\n-                    let mut sig_tys = Vec::new();\n+                    let mut sig_tys = Vec::with_capacity(generic_args.len() + 1);\n                     for arg in generic_args {\n                         sig_tys.push(arg.ty(Interner)?.clone());\n                     }"}, {"sha": "3293534a068bd7dba56c0e4ff0e79a304ad68fdb", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -8,9 +8,11 @@\n use std::{iter, sync::Arc};\n \n use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyVariableKind};\n-use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n+use hir_def::{\n+    expr::ExprId,\n+    lang_item::{LangItem, LangItemTarget},\n+};\n use stdx::always;\n-use syntax::SmolStr;\n \n use crate::{\n     autoderef::{Autoderef, AutoderefKind},\n@@ -570,11 +572,10 @@ impl<'a> InferenceTable<'a> {\n             reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n         let krate = self.trait_env.krate;\n-        let coerce_unsized_trait =\n-            match self.db.lang_item(krate, SmolStr::new_inline(\"coerce_unsized\")) {\n-                Some(LangItemTarget::TraitId(trait_)) => trait_,\n-                _ => return Err(TypeError),\n-            };\n+        let coerce_unsized_trait = match self.db.lang_item(krate, LangItem::CoerceUnsized) {\n+            Some(LangItemTarget::Trait(trait_)) => trait_,\n+            _ => return Err(TypeError),\n+        };\n \n         let coerce_unsized_tref = {\n             let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);"}, {"sha": "175fded8ccae10882528093fcb4ea25e6afdb200", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 222, "deletions": 156, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -10,15 +10,15 @@ use chalk_ir::{\n };\n use hir_def::{\n     expr::{\n-        ArithOp, Array, BinaryOp, ClosureKind, CmpOp, Expr, ExprId, LabelId, Literal, Statement,\n-        UnaryOp,\n+        ArithOp, Array, BinaryOp, ClosureKind, Expr, ExprId, LabelId, Literal, Statement, UnaryOp,\n     },\n     generics::TypeOrConstParamData,\n+    lang_item::LangItem,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::name::Name;\n+use hir_expand::name::{name, Name};\n use stdx::always;\n use syntax::ast::RangeOp;\n \n@@ -30,7 +30,7 @@ use crate::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n-    method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n+    method_resolution::{self, lang_items_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n@@ -87,16 +87,15 @@ impl<'a> InferenceContext<'a> {\n                 let expected = &expected.adjust_for_branches(&mut self.table);\n                 self.infer_expr(\n                     condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                    &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                 );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n \n-                let result_ty = self.table.new_type_var();\n                 let then_ty = self.infer_expr_inner(then_branch, expected);\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n-                let mut coerce = CoerceMany::new(result_ty);\n+                let mut coerce = CoerceMany::new(expected.coercion_target_type(&mut self.table));\n                 coerce.coerce(self, Some(then_branch), &then_ty);\n                 let else_ty = match else_branch {\n                     Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n@@ -113,7 +112,7 @@ impl<'a> InferenceContext<'a> {\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n                 self.infer_pat(pat, &input_ty, BindingMode::default());\n-                TyKind::Scalar(Scalar::Bool).intern(Interner)\n+                self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n                 let old_resolver = mem::replace(\n@@ -158,7 +157,8 @@ impl<'a> InferenceContext<'a> {\n                 }\n \n                 // The ok-ish type that is expected from the last expression\n-                let ok_ty = self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_ok());\n+                let ok_ty =\n+                    self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n \n                 self.with_breakable_ctx(BreakableKind::Block, ok_ty.clone(), None, |this| {\n                     this.infer_expr(*body, &Expectation::has_type(ok_ty));\n@@ -187,27 +187,29 @@ impl<'a> InferenceContext<'a> {\n                     .intern(Interner)\n             }\n             &Expr::Loop { body, label } => {\n+                // FIXME: should be:\n+                // let ty = expected.coercion_target_type(&mut self.table);\n                 let ty = self.table.new_type_var();\n                 let (breaks, ()) =\n                     self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n-                        this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                        this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                     });\n \n                 match breaks {\n                     Some(breaks) => {\n                         self.diverges = Diverges::Maybe;\n                         breaks\n                     }\n-                    None => TyKind::Never.intern(Interner),\n+                    None => self.result.standard_types.never.clone(),\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n                     this.infer_expr(\n                         condition,\n-                        &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                        &Expectation::HasType(this.result.standard_types.bool_.clone()),\n                     );\n-                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -223,7 +225,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.infer_pat(pat, &pat_ty, BindingMode::default());\n                 self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n-                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -233,7 +235,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n-                let mut sig_tys = Vec::new();\n+                let mut sig_tys = Vec::with_capacity(arg_types.len() + 1);\n \n                 // collect explicitly written argument types\n                 for arg_type in arg_types.iter() {\n@@ -254,7 +256,8 @@ impl<'a> InferenceContext<'a> {\n                     num_binders: 0,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n                     substitution: FnSubst(\n-                        Substitution::from_iter(Interner, sig_tys.clone()).shifted_in(Interner),\n+                        Substitution::from_iter(Interner, sig_tys.iter().cloned())\n+                            .shifted_in(Interner),\n                     ),\n                 })\n                 .intern(Interner);\n@@ -316,27 +319,34 @@ impl<'a> InferenceContext<'a> {\n             Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let mut derefs = Autoderef::new(&mut self.table, callee_ty.clone());\n-                let mut res = None;\n-                let mut derefed_callee = callee_ty.clone();\n-                // manual loop to be able to access `derefs.table`\n-                while let Some((callee_deref_ty, _)) = derefs.next() {\n-                    res = derefs.table.callable_sig(&callee_deref_ty, args.len());\n-                    if res.is_some() {\n-                        derefed_callee = callee_deref_ty;\n-                        break;\n+                let (res, derefed_callee) = 'b: {\n+                    // manual loop to be able to access `derefs.table`\n+                    while let Some((callee_deref_ty, _)) = derefs.next() {\n+                        let res = derefs.table.callable_sig(&callee_deref_ty, args.len());\n+                        if res.is_some() {\n+                            break 'b (res, callee_deref_ty);\n+                        }\n                     }\n-                }\n+                    (None, callee_ty.clone())\n+                };\n                 // if the function is unresolved, we use is_varargs=true to\n                 // suppress the arg count diagnostic here\n                 let is_varargs =\n                     derefed_callee.callable_sig(self.db).map_or(false, |sig| sig.is_varargs)\n                         || res.is_none();\n                 let (param_tys, ret_ty) = match res {\n-                    Some(res) => {\n+                    Some((func, params, ret_ty)) => {\n                         let adjustments = auto_deref_adjust_steps(&derefs);\n                         // FIXME: Handle call adjustments for Fn/FnMut\n                         self.write_expr_adj(*callee, adjustments);\n-                        res\n+                        if let Some((trait_, func)) = func {\n+                            let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+                                .push(callee_ty.clone())\n+                                .push(TyBuilder::tuple_with(params.iter().cloned()))\n+                                .build();\n+                            self.write_method_resolution(tgt_expr, func, subst.clone());\n+                        }\n+                        (params, ret_ty)\n                     }\n                     None => (Vec::new(), self.err_ty()), // FIXME diagnostic\n                 };\n@@ -374,12 +384,9 @@ impl<'a> InferenceContext<'a> {\n                 let expected = expected.adjust_for_branches(&mut self.table);\n \n                 let result_ty = if arms.is_empty() {\n-                    TyKind::Never.intern(Interner)\n+                    self.result.standard_types.never.clone()\n                 } else {\n-                    match &expected {\n-                        Expectation::HasType(ty) => ty.clone(),\n-                        _ => self.table.new_type_var(),\n-                    }\n+                    expected.coercion_target_type(&mut self.table)\n                 };\n                 let mut coerce = CoerceMany::new(result_ty);\n \n@@ -392,7 +399,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                            &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                         );\n                     }\n \n@@ -417,7 +424,7 @@ impl<'a> InferenceContext<'a> {\n                         is_break: false,\n                     });\n                 };\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n@@ -431,7 +438,7 @@ impl<'a> InferenceContext<'a> {\n                         // avoiding the borrowck\n                         let mut coerce = mem::replace(\n                             &mut ctxt.coerce,\n-                            CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                            CoerceMany::new(expected.coercion_target_type(&mut self.table)),\n                         );\n \n                         // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n@@ -449,7 +456,7 @@ impl<'a> InferenceContext<'a> {\n                         });\n                     }\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -458,7 +465,7 @@ impl<'a> InferenceContext<'a> {\n                     let unit = TyBuilder::unit();\n                     let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::Yield { expr } => {\n                 if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n@@ -471,14 +478,14 @@ impl<'a> InferenceContext<'a> {\n                     resume_ty\n                 } else {\n                     // FIXME: report error (yield expr in non-generator)\n-                    TyKind::Error.intern(Interner)\n+                    self.result.standard_types.unknown.clone()\n                 }\n             }\n             Expr::Yeet { expr } => {\n                 if let &Some(expr) = expr {\n                     self.infer_expr_inner(expr, &Expectation::None);\n                 }\n-                TyKind::Never.intern(Interner)\n+                self.result.standard_types.never.clone()\n             }\n             Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n@@ -588,12 +595,23 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Try { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n+                if let Some(trait_) = self.resolve_lang_trait(LangItem::Try) {\n+                    if let Some(func) = self.db.trait_data(trait_).method_by_name(&name!(branch)) {\n+                        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+                            .push(inner_ty.clone())\n+                            .build();\n+                        self.write_method_resolution(tgt_expr, func, subst.clone());\n+                    }\n+                    let try_output = self.resolve_output_on(trait_);\n+                    self.resolve_associated_type(inner_ty, try_output)\n+                } else {\n+                    self.err_ty()\n+                }\n             }\n             Expr::Cast { expr, type_ref } => {\n-                // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n-                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n+                // FIXME: propagate the \"castable to\" expectation\n+                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::None);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n@@ -627,6 +645,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::UnaryOp { expr, op } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let inner_ty = self.resolve_ty_shallow(&inner_ty);\n+                // FIXME: Note down method resolution her\n                 match op {\n                     UnaryOp::Deref => {\n                         autoderef::deref(&mut self.table, inner_ty).unwrap_or_else(|| self.err_ty())\n@@ -736,7 +755,7 @@ impl<'a> InferenceContext<'a> {\n                 let base_ty = self.infer_expr_inner(*base, &Expectation::none());\n                 let index_ty = self.infer_expr(*index, &Expectation::none());\n \n-                if let Some(index_trait) = self.resolve_ops_index() {\n+                if let Some(index_trait) = self.resolve_lang_trait(LangItem::Index) {\n                     let canonicalized = self.canonicalize(base_ty.clone());\n                     let receiver_adjustments = method_resolution::resolve_indexing_op(\n                         self.db,\n@@ -749,6 +768,15 @@ impl<'a> InferenceContext<'a> {\n                             adj.apply(&mut self.table, base_ty)\n                         });\n                     self.write_expr_adj(*base, adj);\n+                    if let Some(func) =\n+                        self.db.trait_data(index_trait).method_by_name(&name!(index))\n+                    {\n+                        let substs = TyBuilder::subst_for_def(self.db, index_trait, None)\n+                            .push(self_ty.clone())\n+                            .push(index_ty.clone())\n+                            .build();\n+                        self.write_method_resolution(tgt_expr, func, substs.clone());\n+                    }\n                     self.resolve_associated_type_with_params(\n                         self_ty,\n                         self.resolve_ops_index_output(),\n@@ -800,7 +828,7 @@ impl<'a> InferenceContext<'a> {\n                         self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n                         self.infer_expr(\n                             repeat,\n-                            &Expectation::has_type(\n+                            &Expectation::HasType(\n                                 TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n                             ),\n                         );\n@@ -823,7 +851,7 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::Array(coerce.complete(), len).intern(Interner)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n+                Literal::Bool(..) => self.result.standard_types.bool_.clone(),\n                 Literal::String(..) => {\n                     TyKind::Ref(Mutability::Not, static_lifetime(), TyKind::Str.intern(Interner))\n                         .intern(Interner)\n@@ -1009,19 +1037,29 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let trait_func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+        let trait_func = lang_items_for_bin_op(op).and_then(|(name, lang_item)| {\n             let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;\n             let func = self.db.trait_data(trait_id).method_by_name(&name)?;\n             Some((trait_id, func))\n         });\n         let (trait_, func) = match trait_func {\n             Some(it) => it,\n             None => {\n-                let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n-                let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n-                return self\n-                    .builtin_binary_op_return_ty(op, lhs_ty, rhs_ty)\n-                    .unwrap_or_else(|| self.err_ty());\n+                // HACK: `rhs_ty` is a general inference variable with no clue at all at this\n+                // point. Passing `lhs_ty` as both operands just to check if `lhs_ty` is a builtin\n+                // type applicable to `op`.\n+                let ret_ty = if self.is_builtin_binop(&lhs_ty, &lhs_ty, op) {\n+                    // Assume both operands are builtin so we can continue inference. No guarantee\n+                    // on the correctness, rustc would complain as necessary lang items don't seem\n+                    // to exist anyway.\n+                    self.enforce_builtin_binop_types(&lhs_ty, &rhs_ty, op)\n+                } else {\n+                    self.err_ty()\n+                };\n+\n+                self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty));\n+\n+                return ret_ty;\n             }\n         };\n \n@@ -1071,11 +1109,9 @@ impl<'a> InferenceContext<'a> {\n \n         let ret_ty = self.normalize_associated_types_in(ret_ty);\n \n-        // use knowledge of built-in binary ops, which can sometimes help inference\n-        if let Some(builtin_rhs) = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone()) {\n-            self.unify(&builtin_rhs, &rhs_ty);\n-        }\n-        if let Some(builtin_ret) = self.builtin_binary_op_return_ty(op, lhs_ty, rhs_ty) {\n+        if self.is_builtin_binop(&lhs_ty, &rhs_ty, op) {\n+            // use knowledge of built-in binary ops, which can sometimes help inference\n+            let builtin_ret = self.enforce_builtin_binop_types(&lhs_ty, &rhs_ty, op);\n             self.unify(&builtin_ret, &ret_ty);\n         }\n \n@@ -1111,7 +1147,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(expr) = else_branch {\n                         self.infer_expr_coerce(\n                             *expr,\n-                            &Expectation::has_type(Ty::new(Interner, TyKind::Never)),\n+                            &Expectation::HasType(self.result.standard_types.never.clone()),\n                         );\n                     }\n \n@@ -1136,18 +1172,16 @@ impl<'a> InferenceContext<'a> {\n             if self.diverges.is_always() {\n                 // we don't even make an attempt at coercion\n                 self.table.new_maybe_never_var()\n-            } else {\n-                if let Some(t) = expected.only_has_type(&mut self.table) {\n-                    if self.coerce(Some(expr), &TyBuilder::unit(), &t).is_err() {\n-                        self.result.type_mismatches.insert(\n-                            expr.into(),\n-                            TypeMismatch { expected: t.clone(), actual: TyBuilder::unit() },\n-                        );\n-                    }\n-                    t\n-                } else {\n-                    TyBuilder::unit()\n+            } else if let Some(t) = expected.only_has_type(&mut self.table) {\n+                if self.coerce(Some(expr), &TyBuilder::unit(), &t).is_err() {\n+                    self.result.type_mismatches.insert(\n+                        expr.into(),\n+                        TypeMismatch { expected: t.clone(), actual: TyBuilder::unit() },\n+                    );\n                 }\n+                t\n+            } else {\n+                TyBuilder::unit()\n             }\n         }\n     }\n@@ -1271,7 +1305,7 @@ impl<'a> InferenceContext<'a> {\n         // that are not closures, then we type-check the closures. This is so\n         // that we have more information about the types of arguments when we\n         // type-check the functions. This isn't really the right way to do this.\n-        for &check_closures in &[false, true] {\n+        for check_closures in [false, true] {\n             let mut skip_indices = skip_indices.into_iter().copied().fuse().peekable();\n             let param_iter = param_tys.iter().cloned().chain(repeat(self.err_ty()));\n             let expected_iter = expected_inputs\n@@ -1314,13 +1348,13 @@ impl<'a> InferenceContext<'a> {\n                 } else {\n                     param_ty\n                 };\n-                if !coercion_target.is_unknown() {\n-                    if self.coerce(Some(arg), &ty, &coercion_target).is_err() {\n-                        self.result.type_mismatches.insert(\n-                            arg.into(),\n-                            TypeMismatch { expected: coercion_target, actual: ty.clone() },\n-                        );\n-                    }\n+                if !coercion_target.is_unknown()\n+                    && self.coerce(Some(arg), &ty, &coercion_target).is_err()\n+                {\n+                    self.result.type_mismatches.insert(\n+                        arg.into(),\n+                        TypeMismatch { expected: coercion_target, actual: ty.clone() },\n+                    );\n                 }\n             }\n         }\n@@ -1479,92 +1513,124 @@ impl<'a> InferenceContext<'a> {\n         indices\n     }\n \n-    fn builtin_binary_op_return_ty(&mut self, op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Option<Ty> {\n-        let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n-        let rhs_ty = self.resolve_ty_shallow(&rhs_ty);\n-        match op {\n-            BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => {\n-                Some(TyKind::Scalar(Scalar::Bool).intern(Interner))\n+    /// Dereferences a single level of immutable referencing.\n+    fn deref_ty_if_possible(&mut self, ty: &Ty) -> Ty {\n+        let ty = self.resolve_ty_shallow(ty);\n+        match ty.kind(Interner) {\n+            TyKind::Ref(Mutability::Not, _, inner) => self.resolve_ty_shallow(inner),\n+            _ => ty,\n+        }\n+    }\n+\n+    /// Enforces expectations on lhs type and rhs type depending on the operator and returns the\n+    /// output type of the binary op.\n+    fn enforce_builtin_binop_types(&mut self, lhs: &Ty, rhs: &Ty, op: BinaryOp) -> Ty {\n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).\n+        let lhs = self.deref_ty_if_possible(lhs);\n+        let rhs = self.deref_ty_if_possible(rhs);\n+\n+        let (op, is_assign) = match op {\n+            BinaryOp::Assignment { op: Some(inner) } => (BinaryOp::ArithOp(inner), true),\n+            _ => (op, false),\n+        };\n+\n+        let output_ty = match op {\n+            BinaryOp::LogicOp(_) => {\n+                let bool_ = self.result.standard_types.bool_.clone();\n+                self.unify(&lhs, &bool_);\n+                self.unify(&rhs, &bool_);\n+                bool_\n             }\n-            BinaryOp::Assignment { .. } => Some(TyBuilder::unit()),\n+\n             BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n-                // all integer combinations are valid here\n-                if matches!(\n-                    lhs_ty.kind(Interner),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-                ) && matches!(\n-                    rhs_ty.kind(Interner),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-                ) {\n-                    Some(lhs_ty)\n-                } else {\n-                    None\n-                }\n+                // result type is same as LHS always\n+                lhs\n             }\n-            BinaryOp::ArithOp(_) => match (lhs_ty.kind(Interner), rhs_ty.kind(Interner)) {\n-                // (int, int) | (uint, uint) | (float, float)\n-                (TyKind::Scalar(Scalar::Int(_)), TyKind::Scalar(Scalar::Int(_)))\n-                | (TyKind::Scalar(Scalar::Uint(_)), TyKind::Scalar(Scalar::Uint(_)))\n-                | (TyKind::Scalar(Scalar::Float(_)), TyKind::Scalar(Scalar::Float(_))) => {\n-                    Some(rhs_ty)\n-                }\n-                // ({int}, int) | ({int}, uint)\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-                ) => Some(rhs_ty),\n-                // (int, {int}) | (uint, {int})\n-                (\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                ) => Some(lhs_ty),\n-                // ({float} | float)\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                    TyKind::Scalar(Scalar::Float(_)),\n-                ) => Some(rhs_ty),\n-                // (float, {float})\n-                (\n-                    TyKind::Scalar(Scalar::Float(_)),\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                ) => Some(lhs_ty),\n-                // ({int}, {int}) | ({float}, {float})\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                )\n-                | (\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                ) => Some(rhs_ty),\n-                _ => None,\n-            },\n+\n+            BinaryOp::ArithOp(_) => {\n+                // LHS, RHS, and result will have the same type\n+                self.unify(&lhs, &rhs);\n+                lhs\n+            }\n+\n+            BinaryOp::CmpOp(_) => {\n+                // LHS and RHS will have the same type\n+                self.unify(&lhs, &rhs);\n+                self.result.standard_types.bool_.clone()\n+            }\n+\n+            BinaryOp::Assignment { op: None } => {\n+                stdx::never!(\"Simple assignment operator is not binary op.\");\n+                lhs\n+            }\n+\n+            BinaryOp::Assignment { .. } => unreachable!(\"handled above\"),\n+        };\n+\n+        if is_assign {\n+            self.result.standard_types.unit.clone()\n+        } else {\n+            output_ty\n         }\n     }\n \n-    fn builtin_binary_op_rhs_expectation(&mut self, op: BinaryOp, lhs_ty: Ty) -> Option<Ty> {\n-        Some(match op {\n-            BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n-            BinaryOp::Assignment { op: None } => lhs_ty,\n-            BinaryOp::CmpOp(CmpOp::Eq { .. }) => match self\n-                .resolve_ty_shallow(&lhs_ty)\n-                .kind(Interner)\n-            {\n-                TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n-                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-                _ => return None,\n-            },\n-            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => return None,\n-            BinaryOp::CmpOp(CmpOp::Ord { .. })\n-            | BinaryOp::Assignment { op: Some(_) }\n-            | BinaryOp::ArithOp(_) => match self.resolve_ty_shallow(&lhs_ty).kind(Interner) {\n-                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_) | Scalar::Float(_)) => lhs_ty,\n-                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-                _ => return None,\n-            },\n-        })\n+    fn is_builtin_binop(&mut self, lhs: &Ty, rhs: &Ty, op: BinaryOp) -> bool {\n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).\n+        let lhs = self.deref_ty_if_possible(lhs);\n+        let rhs = self.deref_ty_if_possible(rhs);\n+\n+        let op = match op {\n+            BinaryOp::Assignment { op: Some(inner) } => BinaryOp::ArithOp(inner),\n+            _ => op,\n+        };\n+\n+        match op {\n+            BinaryOp::LogicOp(_) => true,\n+\n+            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n+                lhs.is_integral() && rhs.is_integral()\n+            }\n+\n+            BinaryOp::ArithOp(\n+                ArithOp::Add | ArithOp::Sub | ArithOp::Mul | ArithOp::Div | ArithOp::Rem,\n+            ) => {\n+                lhs.is_integral() && rhs.is_integral()\n+                    || lhs.is_floating_point() && rhs.is_floating_point()\n+            }\n+\n+            BinaryOp::ArithOp(ArithOp::BitAnd | ArithOp::BitOr | ArithOp::BitXor) => {\n+                lhs.is_integral() && rhs.is_integral()\n+                    || lhs.is_floating_point() && rhs.is_floating_point()\n+                    || matches!(\n+                        (lhs.kind(Interner), rhs.kind(Interner)),\n+                        (TyKind::Scalar(Scalar::Bool), TyKind::Scalar(Scalar::Bool))\n+                    )\n+            }\n+\n+            BinaryOp::CmpOp(_) => {\n+                let is_scalar = |kind| {\n+                    matches!(\n+                        kind,\n+                        &TyKind::Scalar(_)\n+                            | TyKind::FnDef(..)\n+                            | TyKind::Function(_)\n+                            | TyKind::Raw(..)\n+                            | TyKind::InferenceVar(\n+                                _,\n+                                TyVariableKind::Integer | TyVariableKind::Float\n+                            )\n+                    )\n+                };\n+                is_scalar(lhs.kind(Interner)) && is_scalar(rhs.kind(Interner))\n+            }\n+\n+            BinaryOp::Assignment { op: None } => {\n+                stdx::never!(\"Simple assignment operator is not binary op.\");\n+                false\n+            }\n+\n+            BinaryOp::Assignment { .. } => unreachable!(\"handled above\"),\n+        }\n     }\n \n     fn with_breakable_ctx<T>("}, {"sha": "0a8527afbd0430bf0baa9c4431594cf9b9f20d07", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -112,7 +112,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n-                    ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n+                    ParamKind::Type => self.result.standard_types.unknown.clone().cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })"}, {"sha": "46ed3533c8c7b41d38aeb51f23bedcfa84c45409", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -8,6 +8,7 @@ use chalk_ir::{\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n+use hir_def::{FunctionId, TraitId};\n use hir_expand::name;\n use stdx::never;\n \n@@ -626,18 +627,26 @@ impl<'a> InferenceTable<'a> {\n         }\n     }\n \n-    pub(crate) fn callable_sig(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n+    pub(crate) fn callable_sig(\n+        &mut self,\n+        ty: &Ty,\n+        num_args: usize,\n+    ) -> Option<(Option<(TraitId, FunctionId)>, Vec<Ty>, Ty)> {\n         match ty.callable_sig(self.db) {\n-            Some(sig) => Some((sig.params().to_vec(), sig.ret().clone())),\n+            Some(sig) => Some((None, sig.params().to_vec(), sig.ret().clone())),\n             None => self.callable_sig_from_fn_trait(ty, num_args),\n         }\n     }\n \n-    fn callable_sig_from_fn_trait(&mut self, ty: &Ty, num_args: usize) -> Option<(Vec<Ty>, Ty)> {\n+    fn callable_sig_from_fn_trait(\n+        &mut self,\n+        ty: &Ty,\n+        num_args: usize,\n+    ) -> Option<(Option<(TraitId, FunctionId)>, Vec<Ty>, Ty)> {\n         let krate = self.trait_env.krate;\n         let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n-        let output_assoc_type =\n-            self.db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n+        let trait_data = self.db.trait_data(fn_once_trait);\n+        let output_assoc_type = trait_data.associated_type_by_name(&name![Output])?;\n \n         let mut arg_tys = vec![];\n         let arg_ty = TyBuilder::tuple(num_args)\n@@ -675,7 +684,11 @@ impl<'a> InferenceTable<'a> {\n         if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n             self.register_obligation(obligation.goal);\n             let return_ty = self.normalize_projection_ty(projection);\n-            Some((arg_tys, return_ty))\n+            Some((\n+                Some(fn_once_trait).zip(trait_data.method_by_name(&name!(call_once))),\n+                arg_tys,\n+                return_ty,\n+            ))\n         } else {\n             None\n         }"}, {"sha": "7bf73560cbe6fb19a7312942d52ef3f9adb8ee95", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/interner.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,11 +4,8 @@\n use crate::{chalk_db, tls, GenericArg};\n use base_db::salsa::InternId;\n use chalk_ir::{Goal, GoalData};\n-use hir_def::{\n-    intern::{impl_internable, InternStorage, Internable, Interned},\n-    type_ref::ConstScalar,\n-    TypeAliasId,\n-};\n+use hir_def::{type_ref::ConstScalar, TypeAliasId};\n+use intern::{impl_internable, Interned};\n use smallvec::SmallVec;\n use std::{fmt, sync::Arc};\n "}, {"sha": "5308c72161b26bb233a0566b0cddbb2f0ea2deae", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lang_items.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,20 +1,19 @@\n //! Functions to detect special lang items\n \n-use hir_def::{AdtId, HasModule};\n-use hir_expand::name;\n+use hir_def::{lang_item::LangItem, AdtId, HasModule};\n \n use crate::db::HirDatabase;\n \n pub fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![owned_box].to_smol_str();\n     let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    let box_adt =\n+        db.lang_item(krate, LangItem::OwnedBox).and_then(|it| it.as_struct()).map(AdtId::from);\n     Some(adt) == box_adt\n }\n \n pub fn is_unsafe_cell(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![unsafe_cell].to_smol_str();\n     let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    let box_adt =\n+        db.lang_item(krate, LangItem::UnsafeCell).and_then(|it| it.as_struct()).map(AdtId::from);\n     Some(adt) == box_adt\n }"}, {"sha": "c82c274524acd0015d627d8dfd9bf36f621764f6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,7 +1,5 @@\n //! Compute the binary representation of a type\n \n-use std::sync::Arc;\n-\n use base_db::CrateId;\n use chalk_ir::{AdtId, TyKind};\n use hir_def::{\n@@ -31,19 +29,19 @@ mod adt;\n mod target;\n \n struct LayoutCx<'a> {\n-    db: &'a dyn HirDatabase,\n     krate: CrateId,\n+    target: &'a TargetDataLayout,\n }\n \n-impl LayoutCalculator for LayoutCx<'_> {\n-    type TargetDataLayoutRef = Arc<TargetDataLayout>;\n+impl<'a> LayoutCalculator for LayoutCx<'a> {\n+    type TargetDataLayoutRef = &'a TargetDataLayout;\n \n     fn delay_bug(&self, txt: &str) {\n         never!(\"{}\", txt);\n     }\n \n-    fn current_data_layout(&self) -> Arc<TargetDataLayout> {\n-        self.db.target_data_layout(self.krate)\n+    fn current_data_layout(&self) -> &'a TargetDataLayout {\n+        self.target\n     }\n }\n \n@@ -56,7 +54,8 @@ fn scalar(dl: &TargetDataLayout, value: Primitive) -> Layout {\n }\n \n pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Layout, LayoutError> {\n-    let cx = LayoutCx { db, krate };\n+    let Some(target) = db.target_data_layout(krate) else { return Err(LayoutError::TargetLayoutNotAvailable) };\n+    let cx = LayoutCx { krate, target: &target };\n     let dl = &*cx.current_data_layout();\n     Ok(match ty.kind(Interner) {\n         TyKind::Adt(AdtId(def), subst) => db.layout_of_adt(*def, subst.clone())?,\n@@ -226,10 +225,21 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             ptr.valid_range_mut().start = 1;\n             Layout::scalar(dl, ptr)\n         }\n-        TyKind::Closure(_, _)\n-        | TyKind::OpaqueType(_, _)\n-        | TyKind::Generator(_, _)\n-        | TyKind::GeneratorWitness(_, _) => return Err(LayoutError::NotImplemented),\n+        TyKind::OpaqueType(opaque_ty_id, _) => {\n+            let impl_trait_id = db.lookup_intern_impl_trait_id((*opaque_ty_id).into());\n+            match impl_trait_id {\n+                crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n+                    let infer = db.infer(func.into());\n+                    layout_of_ty(db, &infer.type_of_rpit[idx], krate)?\n+                }\n+                crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n+                    return Err(LayoutError::NotImplemented)\n+                }\n+            }\n+        }\n+        TyKind::Closure(_, _) | TyKind::Generator(_, _) | TyKind::GeneratorWitness(_, _) => {\n+            return Err(LayoutError::NotImplemented)\n+        }\n         TyKind::AssociatedType(_, _)\n         | TyKind::Error\n         | TyKind::Alias(_)\n@@ -251,17 +261,14 @@ fn layout_of_unit(cx: &LayoutCx<'_>, dl: &TargetDataLayout) -> Result<Layout, La\n \n fn struct_tail_erasing_lifetimes(db: &dyn HirDatabase, pointee: Ty) -> Ty {\n     match pointee.kind(Interner) {\n-        TyKind::Adt(AdtId(adt), subst) => match adt {\n-            &hir_def::AdtId::StructId(i) => {\n-                let data = db.struct_data(i);\n-                let mut it = data.variant_data.fields().iter().rev();\n-                match it.next() {\n-                    Some((f, _)) => field_ty(db, i.into(), f, subst),\n-                    None => pointee,\n-                }\n+        TyKind::Adt(AdtId(hir_def::AdtId::StructId(i)), subst) => {\n+            let data = db.struct_data(*i);\n+            let mut it = data.variant_data.fields().iter().rev();\n+            match it.next() {\n+                Some((f, _)) => field_ty(db, (*i).into(), f, subst),\n+                None => pointee,\n             }\n-            _ => pointee,\n-        },\n+        }\n         _ => pointee,\n     }\n }"}, {"sha": "cb7968c1446590df19913a37a746b0db35387dc5", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/adt.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -23,7 +23,9 @@ pub fn layout_of_adt_query(\n     def: AdtId,\n     subst: Substitution,\n ) -> Result<Layout, LayoutError> {\n-    let cx = LayoutCx { db, krate: def.module(db.upcast()).krate() };\n+    let krate = def.module(db.upcast()).krate();\n+    let Some(target) = db.target_data_layout(krate) else { return Err(LayoutError::TargetLayoutNotAvailable) };\n+    let cx = LayoutCx { krate, target: &target };\n     let dl = cx.current_data_layout();\n     let handle_variant = |def: VariantId, var: &VariantData| {\n         var.fields()"}, {"sha": "adfae0a1abb387eafc9ff7bb14c6ca6b7da6d982", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/target.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftarget.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,34 +3,22 @@\n use std::sync::Arc;\n \n use base_db::CrateId;\n-use hir_def::layout::{Endian, Size, TargetDataLayout};\n+use hir_def::layout::TargetDataLayout;\n \n use crate::db::HirDatabase;\n \n-pub fn target_data_layout_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<TargetDataLayout> {\n+pub fn target_data_layout_query(\n+    db: &dyn HirDatabase,\n+    krate: CrateId,\n+) -> Option<Arc<TargetDataLayout>> {\n     let crate_graph = db.crate_graph();\n-    let target_layout = &crate_graph[krate].target_layout;\n-    let cfg_options = &crate_graph[krate].cfg_options;\n-    Arc::new(\n-        target_layout\n-            .as_ref()\n-            .and_then(|it| TargetDataLayout::parse_from_llvm_datalayout_string(it).ok())\n-            .unwrap_or_else(|| {\n-                let endian = match cfg_options.get_cfg_values(\"target_endian\").next() {\n-                    Some(x) if x.as_str() == \"big\" => Endian::Big,\n-                    _ => Endian::Little,\n-                };\n-                let pointer_size = Size::from_bytes(\n-                    match cfg_options.get_cfg_values(\"target_pointer_width\").next() {\n-                        Some(x) => match x.as_str() {\n-                            \"16\" => 2,\n-                            \"32\" => 4,\n-                            _ => 8,\n-                        },\n-                        _ => 8,\n-                    },\n-                );\n-                TargetDataLayout { endian, pointer_size, ..TargetDataLayout::default() }\n-            }),\n-    )\n+    let target_layout = crate_graph[krate].target_layout.as_ref().ok()?;\n+    let res = TargetDataLayout::parse_from_llvm_datalayout_string(&target_layout);\n+    if let Err(_e) = &res {\n+        // FIXME: Print the error here once it implements debug/display\n+        // also logging here is somewhat wrong, but unfortunately this is the earliest place we can\n+        // parse that doesn't impose a dependency to the rust-abi crate for project-model\n+        tracing::error!(\"Failed to parse target data layout for {krate:?}\");\n+    }\n+    res.ok().map(Arc::new)\n }"}, {"sha": "067bdc960dadfe18d38a8707ed8db3b831186b9d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 105, "deletions": 10, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,24 +1,22 @@\n+use std::collections::HashMap;\n+\n use base_db::fixture::WithFixture;\n use chalk_ir::{AdtId, TyKind};\n use hir_def::{\n     db::DefDatabase,\n     layout::{Layout, LayoutError},\n };\n \n-use crate::{test_db::TestDB, Interner, Substitution};\n+use crate::{db::HirDatabase, test_db::TestDB, Interner, Substitution};\n \n use super::layout_of_ty;\n \n-fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n-    // using unstable cargo features failed, fall back to using plain rustc\n-    let mut cmd = std::process::Command::new(\"rustc\");\n-    cmd.args([\"-Z\", \"unstable-options\", \"--print\", \"target-spec-json\"]).env(\"RUSTC_BOOTSTRAP\", \"1\");\n-    let output = cmd.output().unwrap();\n-    assert!(output.status.success(), \"{}\", output.status);\n-    let stdout = String::from_utf8(output.stdout).unwrap();\n-    let target_data_layout =\n-        stdout.split_once(r#\"\"data-layout\": \"\"#).unwrap().1.split_once('\"').unwrap().0.to_owned();\n+fn current_machine_data_layout() -> String {\n+    project_model::target_data_layout::get(None, None, &HashMap::default()).unwrap()\n+}\n \n+fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n+    let target_data_layout = current_machine_data_layout();\n     let ra_fixture = format!(\n         \"{minicore}//- /main.rs crate:test target_data_layout:{target_data_layout}\\n{ra_fixture}\",\n     );\n@@ -45,13 +43,56 @@ fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n     layout_of_ty(&db, &goal_ty, module_id.krate())\n }\n \n+/// A version of `eval_goal` for types that can not be expressed in ADTs, like closures and `impl Trait`\n+fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n+    let target_data_layout = current_machine_data_layout();\n+    let ra_fixture = format!(\n+        \"{minicore}//- /main.rs crate:test target_data_layout:{target_data_layout}\\nfn main(){{let goal = {{{ra_fixture}}};}}\",\n+    );\n+\n+    let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n+    let module_id = db.module_for_file(file_id);\n+    let def_map = module_id.def_map(&db);\n+    let scope = &def_map[module_id.local_id].scope;\n+    let adt_id = scope\n+        .declarations()\n+        .find_map(|x| match x {\n+            hir_def::ModuleDefId::FunctionId(x) => {\n+                let name = db.function_data(x).name.to_smol_str();\n+                (name == \"main\").then_some(x)\n+            }\n+            _ => None,\n+        })\n+        .unwrap();\n+    let hir_body = db.body(adt_id.into());\n+    let pat = hir_body\n+        .pats\n+        .iter()\n+        .find(|x| match x.1 {\n+            hir_def::expr::Pat::Bind { name, .. } => name.to_smol_str() == \"goal\",\n+            _ => false,\n+        })\n+        .unwrap()\n+        .0;\n+    let infer = db.infer(adt_id.into());\n+    let goal_ty = infer.type_of_pat[pat].clone();\n+    layout_of_ty(&db, &goal_ty, module_id.krate())\n+}\n+\n #[track_caller]\n fn check_size_and_align(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n     let l = eval_goal(ra_fixture, minicore).unwrap();\n     assert_eq!(l.size.bytes(), size);\n     assert_eq!(l.align.abi.bytes(), align);\n }\n \n+#[track_caller]\n+fn check_size_and_align_expr(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n+    let l = eval_expr(ra_fixture, minicore).unwrap();\n+    assert_eq!(l.size.bytes(), size);\n+    assert_eq!(l.align.abi.bytes(), align);\n+}\n+\n #[track_caller]\n fn check_fail(ra_fixture: &str, e: LayoutError) {\n     let r = eval_goal(ra_fixture, \"\");\n@@ -85,11 +126,31 @@ macro_rules! size_and_align {\n     };\n }\n \n+macro_rules! size_and_align_expr {\n+    ($($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            {\n+                let val = { $($t)* };\n+                check_size_and_align_expr(\n+                    stringify!($($t)*),\n+                    \"\",\n+                    ::std::mem::size_of_val(&val) as u64,\n+                    ::std::mem::align_of_val(&val) as u64,\n+                );\n+            }\n+        }\n+    };\n+}\n+\n #[test]\n fn hello_world() {\n     size_and_align! {\n         struct Goal(i32);\n     }\n+    size_and_align_expr! {\n+        2i32\n+    }\n }\n \n #[test]\n@@ -143,6 +204,40 @@ fn generic() {\n     }\n }\n \n+#[test]\n+fn return_position_impl_trait() {\n+    size_and_align_expr! {\n+        trait T {}\n+        impl T for i32 {}\n+        impl T for i64 {}\n+        fn foo() -> impl T { 2i64 }\n+        foo()\n+    }\n+    size_and_align_expr! {\n+        trait T {}\n+        impl T for i32 {}\n+        impl T for i64 {}\n+        fn foo() -> (impl T, impl T, impl T) { (2i64, 5i32, 7i32) }\n+        foo()\n+    }\n+    size_and_align_expr! {\n+        struct Foo<T>(T, T, (T, T));\n+        trait T {}\n+        impl T for Foo<i32> {}\n+        impl T for Foo<i64> {}\n+\n+        fn foo() -> Foo<impl T> { Foo(\n+            Foo(1i64, 2, (3, 4)),\n+            Foo(5, 6, (7, 8)),\n+            (\n+                Foo(1i64, 2, (3, 4)),\n+                Foo(5, 6, (7, 8)),\n+            ),\n+        ) }\n+        foo()\n+    }\n+}\n+\n #[test]\n fn enums() {\n     size_and_align! {"}, {"sha": "59a5ef8c14dae2435f84a57892c8406ecaf6f248", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -20,7 +20,6 @@ mod lower;\n mod mapping;\n mod tls;\n mod utils;\n-mod walk;\n pub mod db;\n pub mod diagnostics;\n pub mod display;\n@@ -40,11 +39,14 @@ use std::sync::Arc;\n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n     interner::HasInterner,\n-    NoSolution,\n+    visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n+    NoSolution, TyData,\n };\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n use itertools::Either;\n+use la_arena::{Arena, Idx};\n+use rustc_hash::FxHashSet;\n use traits::FnTrait;\n use utils::Generics;\n \n@@ -71,7 +73,6 @@ pub use mapping::{\n };\n pub use traits::TraitEnvironment;\n pub use utils::{all_super_traits, is_fn_unsafe_to_call};\n-pub use walk::TypeWalk;\n \n pub use chalk_ir::{\n     cast::Cast, AdtId, BoundVar, DebruijnIndex, Mutability, Safety, Scalar, TyVariableKind,\n@@ -107,6 +108,7 @@ pub type GenericArgData = chalk_ir::GenericArgData<Interner>;\n \n pub type Ty = chalk_ir::Ty<Interner>;\n pub type TyKind = chalk_ir::TyKind<Interner>;\n+pub type TypeFlags = chalk_ir::TypeFlags;\n pub type DynTy = chalk_ir::DynTy<Interner>;\n pub type FnPointer = chalk_ir::FnPointer<Interner>;\n // pub type FnSubst = chalk_ir::FnSubst<Interner>;\n@@ -289,22 +291,24 @@ impl TypeFoldable<Interner> for CallableSig {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum ImplTraitId {\n-    ReturnTypeImplTrait(hir_def::FunctionId, u16),\n+    ReturnTypeImplTrait(hir_def::FunctionId, RpitId),\n     AsyncBlockTypeImplTrait(hir_def::DefWithBodyId, ExprId),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ReturnTypeImplTraits {\n-    pub(crate) impl_traits: Vec<ReturnTypeImplTrait>,\n+    pub(crate) impl_traits: Arena<ReturnTypeImplTrait>,\n }\n \n has_interner!(ReturnTypeImplTraits);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub(crate) struct ReturnTypeImplTrait {\n+pub struct ReturnTypeImplTrait {\n     pub(crate) bounds: Binders<Vec<QuantifiedWhereClause>>,\n }\n \n+pub type RpitId = Idx<ReturnTypeImplTrait>;\n+\n pub fn static_lifetime() -> Lifetime {\n     LifetimeData::Static.intern(Interner)\n }\n@@ -563,3 +567,68 @@ pub fn callable_sig_from_fnonce(\n \n     Some(CallableSig::from_params_and_return(params, ret_ty, false, Safety::Safe))\n }\n+\n+struct PlaceholderCollector<'db> {\n+    db: &'db dyn HirDatabase,\n+    placeholders: FxHashSet<TypeOrConstParamId>,\n+}\n+\n+impl PlaceholderCollector<'_> {\n+    fn collect(&mut self, idx: PlaceholderIndex) {\n+        let id = from_placeholder_idx(self.db, idx);\n+        self.placeholders.insert(id);\n+    }\n+}\n+\n+impl TypeVisitor<Interner> for PlaceholderCollector<'_> {\n+    type BreakTy = ();\n+\n+    fn as_dyn(&mut self) -> &mut dyn TypeVisitor<Interner, BreakTy = Self::BreakTy> {\n+        self\n+    }\n+\n+    fn interner(&self) -> Interner {\n+        Interner\n+    }\n+\n+    fn visit_ty(\n+        &mut self,\n+        ty: &Ty,\n+        outer_binder: DebruijnIndex,\n+    ) -> std::ops::ControlFlow<Self::BreakTy> {\n+        let has_placeholder_bits = TypeFlags::HAS_TY_PLACEHOLDER | TypeFlags::HAS_CT_PLACEHOLDER;\n+        let TyData { kind, flags } = ty.data(Interner);\n+\n+        if let TyKind::Placeholder(idx) = kind {\n+            self.collect(*idx);\n+        } else if flags.intersects(has_placeholder_bits) {\n+            return ty.super_visit_with(self, outer_binder);\n+        } else {\n+            // Fast path: don't visit inner types (e.g. generic arguments) when `flags` indicate\n+            // that there are no placeholders.\n+        }\n+\n+        std::ops::ControlFlow::Continue(())\n+    }\n+\n+    fn visit_const(\n+        &mut self,\n+        constant: &chalk_ir::Const<Interner>,\n+        _outer_binder: DebruijnIndex,\n+    ) -> std::ops::ControlFlow<Self::BreakTy> {\n+        if let chalk_ir::ConstValue::Placeholder(idx) = constant.data(Interner).value {\n+            self.collect(idx);\n+        }\n+        std::ops::ControlFlow::Continue(())\n+    }\n+}\n+\n+/// Returns unique placeholders for types and consts contained in `value`.\n+pub fn collect_placeholders<T>(value: &T, db: &dyn HirDatabase) -> Vec<TypeOrConstParamId>\n+where\n+    T: ?Sized + TypeVisitable<Interner>,\n+{\n+    let mut collector = PlaceholderCollector { db, placeholders: FxHashSet::default() };\n+    value.visit_with(&mut collector, DebruijnIndex::INNERMOST);\n+    collector.placeholders.into_iter().collect()\n+}"}, {"sha": "7cce13a793e02800c5177c0f0b3c333b41e9dd65", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -23,24 +23,24 @@ use hir_def::{\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n-    intern::Interned,\n-    lang_item::lang_attr,\n+    lang_item::{lang_attr, LangItem},\n     path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{\n         ConstScalarOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef,\n     },\n     AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n-    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n-    TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n+    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId, StructId,\n+    TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n+use intern::Interned;\n use itertools::Either;\n-use la_arena::ArenaMap;\n+use la_arena::{Arena, ArenaMap};\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::{impl_from, never};\n-use syntax::{ast, SmolStr};\n+use syntax::ast;\n \n use crate::{\n     all_super_traits,\n@@ -57,6 +57,51 @@ use crate::{\n     Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n+#[derive(Debug)]\n+enum ImplTraitLoweringState {\n+    /// When turning `impl Trait` into opaque types, we have to collect the\n+    /// bounds at the same time to get the IDs correct (without becoming too\n+    /// complicated). I don't like using interior mutability (as for the\n+    /// counter), but I've tried and failed to make the lifetimes work for\n+    /// passing around a `&mut TyLoweringContext`. The core problem is that\n+    /// we're grouping the mutable data (the counter and this field) together\n+    /// with the immutable context (the references to the DB and resolver).\n+    /// Splitting this up would be a possible fix.\n+    Opaque(RefCell<Arena<ReturnTypeImplTrait>>),\n+    Param(Cell<u16>),\n+    Variable(Cell<u16>),\n+    Disallowed,\n+}\n+impl ImplTraitLoweringState {\n+    fn new(impl_trait_mode: ImplTraitLoweringMode) -> ImplTraitLoweringState {\n+        match impl_trait_mode {\n+            ImplTraitLoweringMode::Opaque => Self::Opaque(RefCell::new(Arena::new())),\n+            ImplTraitLoweringMode::Param => Self::Param(Cell::new(0)),\n+            ImplTraitLoweringMode::Variable => Self::Variable(Cell::new(0)),\n+            ImplTraitLoweringMode::Disallowed => Self::Disallowed,\n+        }\n+    }\n+\n+    fn take(&self) -> Self {\n+        match self {\n+            Self::Opaque(x) => Self::Opaque(RefCell::new(x.take())),\n+            Self::Param(x) => Self::Param(Cell::new(x.get())),\n+            Self::Variable(x) => Self::Variable(Cell::new(x.get())),\n+            Self::Disallowed => Self::Disallowed,\n+        }\n+    }\n+\n+    fn swap(&self, impl_trait_mode: &Self) {\n+        match (self, impl_trait_mode) {\n+            (Self::Opaque(x), Self::Opaque(y)) => x.swap(y),\n+            (Self::Param(x), Self::Param(y)) => x.swap(y),\n+            (Self::Variable(x), Self::Variable(y)) => x.swap(y),\n+            (Self::Disallowed, Self::Disallowed) => (),\n+            _ => panic!(\"mismatched lowering mode\"),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct TyLoweringContext<'a> {\n     pub db: &'a dyn HirDatabase,\n@@ -67,37 +112,23 @@ pub struct TyLoweringContext<'a> {\n     /// should be converted to variables. I think in practice, this isn't\n     /// possible currently, so this should be fine for now.\n     pub type_param_mode: ParamLoweringMode,\n-    pub impl_trait_mode: ImplTraitLoweringMode,\n-    impl_trait_counter: Cell<u16>,\n-    /// When turning `impl Trait` into opaque types, we have to collect the\n-    /// bounds at the same time to get the IDs correct (without becoming too\n-    /// complicated). I don't like using interior mutability (as for the\n-    /// counter), but I've tried and failed to make the lifetimes work for\n-    /// passing around a `&mut TyLoweringContext`. The core problem is that\n-    /// we're grouping the mutable data (the counter and this field) together\n-    /// with the immutable context (the references to the DB and resolver).\n-    /// Splitting this up would be a possible fix.\n-    opaque_type_data: RefCell<Vec<ReturnTypeImplTrait>>,\n+    impl_trait_mode: ImplTraitLoweringState,\n     expander: RefCell<Option<Expander>>,\n     /// Tracks types with explicit `?Sized` bounds.\n     pub(crate) unsized_types: RefCell<FxHashSet<Ty>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n     pub fn new(db: &'a dyn HirDatabase, resolver: &'a Resolver) -> Self {\n-        let impl_trait_counter = Cell::new(0);\n-        let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n+        let impl_trait_mode = ImplTraitLoweringState::Disallowed;\n         let type_param_mode = ParamLoweringMode::Placeholder;\n         let in_binders = DebruijnIndex::INNERMOST;\n-        let opaque_type_data = RefCell::new(Vec::new());\n         Self {\n             db,\n             resolver,\n             in_binders,\n             impl_trait_mode,\n-            impl_trait_counter,\n             type_param_mode,\n-            opaque_type_data,\n             expander: RefCell::new(None),\n             unsized_types: RefCell::default(),\n         }\n@@ -108,20 +139,18 @@ impl<'a> TyLoweringContext<'a> {\n         debruijn: DebruijnIndex,\n         f: impl FnOnce(&TyLoweringContext<'_>) -> T,\n     ) -> T {\n-        let opaque_ty_data_vec = self.opaque_type_data.take();\n+        let impl_trait_mode = self.impl_trait_mode.take();\n         let expander = self.expander.take();\n         let unsized_types = self.unsized_types.take();\n         let new_ctx = Self {\n             in_binders: debruijn,\n-            impl_trait_counter: Cell::new(self.impl_trait_counter.get()),\n-            opaque_type_data: RefCell::new(opaque_ty_data_vec),\n+            impl_trait_mode,\n             expander: RefCell::new(expander),\n             unsized_types: RefCell::new(unsized_types),\n             ..*self\n         };\n         let result = f(&new_ctx);\n-        self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n-        self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n+        self.impl_trait_mode.swap(&new_ctx.impl_trait_mode);\n         self.expander.replace(new_ctx.expander.into_inner());\n         self.unsized_types.replace(new_ctx.unsized_types.into_inner());\n         result\n@@ -136,7 +165,7 @@ impl<'a> TyLoweringContext<'a> {\n     }\n \n     pub fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {\n-        Self { impl_trait_mode, ..self }\n+        Self { impl_trait_mode: ImplTraitLoweringState::new(impl_trait_mode), ..self }\n     }\n \n     pub fn with_type_param_mode(self, type_param_mode: ParamLoweringMode) -> Self {\n@@ -244,20 +273,17 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeRef::DynTrait(bounds) => self.lower_dyn_trait(bounds),\n             TypeRef::ImplTrait(bounds) => {\n-                match self.impl_trait_mode {\n-                    ImplTraitLoweringMode::Opaque => {\n-                        let idx = self.impl_trait_counter.get();\n-                        self.impl_trait_counter.set(idx + 1);\n+                match &self.impl_trait_mode {\n+                    ImplTraitLoweringState::Opaque(opaque_type_data) => {\n                         let func = match self.resolver.generic_def() {\n                             Some(GenericDefId::FunctionId(f)) => f,\n                             _ => panic!(\"opaque impl trait lowering in non-function\"),\n                         };\n \n-                        assert!(idx as usize == self.opaque_type_data.borrow().len());\n                         // this dance is to make sure the data is in the right\n                         // place even if we encounter more opaque types while\n                         // lowering the bounds\n-                        self.opaque_type_data.borrow_mut().push(ReturnTypeImplTrait {\n+                        let idx = opaque_type_data.borrow_mut().alloc(ReturnTypeImplTrait {\n                             bounds: crate::make_single_type_binders(Vec::new()),\n                         });\n                         // We don't want to lower the bounds inside the binders\n@@ -273,18 +299,18 @@ impl<'a> TyLoweringContext<'a> {\n                             .with_debruijn(DebruijnIndex::INNERMOST, |ctx| {\n                                 ctx.lower_impl_trait(bounds, func)\n                             });\n-                        self.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n+                        opaque_type_data.borrow_mut()[idx] = actual_opaque_type_data;\n \n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n                         let parameters = generics.bound_vars_subst(self.db, self.in_binders);\n                         TyKind::OpaqueType(opaque_ty_id, parameters).intern(Interner)\n                     }\n-                    ImplTraitLoweringMode::Param => {\n-                        let idx = self.impl_trait_counter.get();\n+                    ImplTraitLoweringState::Param(counter) => {\n+                        let idx = counter.get();\n                         // FIXME we're probably doing something wrong here\n-                        self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n+                        counter.set(idx + count_impl_traits(type_ref) as u16);\n                         if let Some(def) = self.resolver.generic_def() {\n                             let generics = generics(self.db.upcast(), def);\n                             let param = generics\n@@ -305,10 +331,10 @@ impl<'a> TyLoweringContext<'a> {\n                             TyKind::Error.intern(Interner)\n                         }\n                     }\n-                    ImplTraitLoweringMode::Variable => {\n-                        let idx = self.impl_trait_counter.get();\n+                    ImplTraitLoweringState::Variable(counter) => {\n+                        let idx = counter.get();\n                         // FIXME we're probably doing something wrong here\n-                        self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n+                        counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (\n                             _parent_params,\n                             self_params,\n@@ -327,7 +353,7 @@ impl<'a> TyLoweringContext<'a> {\n                         ))\n                         .intern(Interner)\n                     }\n-                    ImplTraitLoweringMode::Disallowed => {\n+                    ImplTraitLoweringState::Disallowed => {\n                         // FIXME: report error\n                         TyKind::Error.intern(Interner)\n                     }\n@@ -954,7 +980,7 @@ impl<'a> TyLoweringContext<'a> {\n             TypeBound::Path(path, TraitBoundModifier::Maybe) => {\n                 let sized_trait = self\n                     .db\n-                    .lang_item(self.resolver.krate(), SmolStr::new_inline(\"sized\"))\n+                    .lang_item(self.resolver.krate(), LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait());\n                 // Don't lower associated type bindings as the only possible relaxed trait bound\n                 // `?Sized` has no of them.\n@@ -1150,7 +1176,7 @@ impl<'a> TyLoweringContext<'a> {\n                 let krate = func.lookup(ctx.db.upcast()).module(ctx.db.upcast()).krate();\n                 let sized_trait = ctx\n                     .db\n-                    .lang_item(krate, SmolStr::new_inline(\"sized\"))\n+                    .lang_item(krate, LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n                 let sized_clause = sized_trait.map(|trait_id| {\n                     let clause = WhereClause::Implemented(TraitRef {\n@@ -1209,7 +1235,7 @@ fn named_associated_type_shorthand_candidates<R>(\n     mut cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n ) -> Option<R> {\n     let mut search = |t| {\n-        for t in all_super_trait_refs(db, t) {\n+        all_super_trait_refs(db, t, |t| {\n             let data = db.trait_data(t.hir_trait_id());\n \n             for (name, assoc_id) in &data.items {\n@@ -1219,8 +1245,8 @@ fn named_associated_type_shorthand_candidates<R>(\n                     }\n                 }\n             }\n-        }\n-        None\n+            None\n+        })\n     };\n \n     match res {\n@@ -1489,7 +1515,7 @@ fn implicitly_sized_clauses<'a>(\n     let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n     let generic_args = &substitution.as_slice(Interner)[is_trait_def as usize..];\n     let sized_trait = db\n-        .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n+        .lang_item(resolver.krate(), LangItem::Sized)\n         .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n \n     sized_trait.into_iter().flat_map(move |sized_trait| {\n@@ -1704,6 +1730,15 @@ pub enum CallableDefId {\n     EnumVariantId(EnumVariantId),\n }\n impl_from!(FunctionId, StructId, EnumVariantId for CallableDefId);\n+impl From<CallableDefId> for ModuleDefId {\n+    fn from(def: CallableDefId) -> ModuleDefId {\n+        match def {\n+            CallableDefId::FunctionId(f) => ModuleDefId::FunctionId(f),\n+            CallableDefId::StructId(s) => ModuleDefId::AdtId(AdtId::StructId(s)),\n+            CallableDefId::EnumVariantId(e) => ModuleDefId::EnumVariantId(e),\n+        }\n+    }\n+}\n \n impl CallableDefId {\n     pub fn krate(self, db: &dyn HirDatabase) -> CrateId {\n@@ -1854,8 +1889,12 @@ pub(crate) fn return_type_impl_traits(\n         .with_type_param_mode(ParamLoweringMode::Variable);\n     let _ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let return_type_impl_traits =\n-        ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n+    let return_type_impl_traits = ReturnTypeImplTraits {\n+        impl_traits: match ctx_ret.impl_trait_mode {\n+            ImplTraitLoweringState::Opaque(x) => x.into_inner(),\n+            _ => unreachable!(),\n+        },\n+    };\n     if return_type_impl_traits.impl_traits.is_empty() {\n         None\n     } else {\n@@ -1931,7 +1970,7 @@ pub(crate) fn const_or_path_to_chalk(\n     debruijn: DebruijnIndex,\n ) -> Const {\n     match value {\n-        ConstScalarOrPath::Scalar(s) => intern_const_scalar(s.clone(), expected_ty),\n+        ConstScalarOrPath::Scalar(s) => intern_const_scalar(*s, expected_ty),\n         ConstScalarOrPath::Path(n) => {\n             let path = ModPath::from_segments(PathKind::Plain, Some(n.clone()));\n             path_to_const(db, resolver, &path, mode, args, debruijn)"}, {"sha": "8c7714b9a697b2315fd67b4e3c5d3b3a47f5f489", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 62, "deletions": 50, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -5,10 +5,11 @@\n use std::{ops::ControlFlow, sync::Arc};\n \n use base_db::{CrateId, Edition};\n-use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n+use chalk_ir::{cast::Cast, Mutability, TyKind, UniverseIndex};\n use hir_def::{\n-    data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n-    FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    data::ImplData, item_scope::ItemScope, lang_item::LangItem, nameres::DefMap, AssocItemId,\n+    BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n+    ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -24,7 +25,7 @@ use crate::{\n     static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt,\n };\n \n /// This is used as a key for indexing impls.\n@@ -437,49 +438,49 @@ pub fn def_crates(\n     }\n }\n \n-pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)> {\n+pub fn lang_items_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, LangItem)> {\n     use hir_expand::name;\n     use syntax::ast::{ArithOp, BinaryOp, CmpOp, Ordering};\n     Some(match op {\n         BinaryOp::LogicOp(_) => return None,\n         BinaryOp::ArithOp(aop) => match aop {\n-            ArithOp::Add => (name!(add), name!(add)),\n-            ArithOp::Mul => (name!(mul), name!(mul)),\n-            ArithOp::Sub => (name!(sub), name!(sub)),\n-            ArithOp::Div => (name!(div), name!(div)),\n-            ArithOp::Rem => (name!(rem), name!(rem)),\n-            ArithOp::Shl => (name!(shl), name!(shl)),\n-            ArithOp::Shr => (name!(shr), name!(shr)),\n-            ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n-            ArithOp::BitOr => (name!(bitor), name!(bitor)),\n-            ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n+            ArithOp::Add => (name![add], LangItem::Add),\n+            ArithOp::Mul => (name![mul], LangItem::Mul),\n+            ArithOp::Sub => (name![sub], LangItem::Sub),\n+            ArithOp::Div => (name![div], LangItem::Div),\n+            ArithOp::Rem => (name![rem], LangItem::Rem),\n+            ArithOp::Shl => (name![shl], LangItem::Shl),\n+            ArithOp::Shr => (name![shr], LangItem::Shr),\n+            ArithOp::BitXor => (name![bitxor], LangItem::BitXor),\n+            ArithOp::BitOr => (name![bitor], LangItem::BitOr),\n+            ArithOp::BitAnd => (name![bitand], LangItem::BitAnd),\n         },\n         BinaryOp::Assignment { op: Some(aop) } => match aop {\n-            ArithOp::Add => (name!(add_assign), name!(add_assign)),\n-            ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n-            ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n-            ArithOp::Div => (name!(div_assign), name!(div_assign)),\n-            ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n-            ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n-            ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n-            ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n-            ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n-            ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n+            ArithOp::Add => (name![add_assign], LangItem::AddAssign),\n+            ArithOp::Mul => (name![mul_assign], LangItem::MulAssign),\n+            ArithOp::Sub => (name![sub_assign], LangItem::SubAssign),\n+            ArithOp::Div => (name![div_assign], LangItem::DivAssign),\n+            ArithOp::Rem => (name![rem_assign], LangItem::RemAssign),\n+            ArithOp::Shl => (name![shl_assign], LangItem::ShlAssign),\n+            ArithOp::Shr => (name![shr_assign], LangItem::ShrAssign),\n+            ArithOp::BitXor => (name![bitxor_assign], LangItem::BitXorAssign),\n+            ArithOp::BitOr => (name![bitor_assign], LangItem::BitOrAssign),\n+            ArithOp::BitAnd => (name![bitand_assign], LangItem::BitAndAssign),\n         },\n         BinaryOp::CmpOp(cop) => match cop {\n-            CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n-            CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n+            CmpOp::Eq { negated: false } => (name![eq], LangItem::PartialEq),\n+            CmpOp::Eq { negated: true } => (name![ne], LangItem::PartialEq),\n             CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n-                (name!(le), name!(partial_ord))\n+                (name![le], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n-                (name!(lt), name!(partial_ord))\n+                (name![lt], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n-                (name!(ge), name!(partial_ord))\n+                (name![ge], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n-                (name!(gt), name!(partial_ord))\n+                (name![gt], LangItem::PartialOrd)\n             }\n         },\n         BinaryOp::Assignment { op: None } => return None,\n@@ -587,25 +588,31 @@ impl ReceiverAdjustments {\n                 }\n             }\n         }\n+        if let Some(m) = self.autoref {\n+            ty = TyKind::Ref(m, static_lifetime(), ty).intern(Interner);\n+            adjust\n+                .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(m)), target: ty.clone() });\n+        }\n         if self.unsize_array {\n-            ty = match ty.kind(Interner) {\n-                TyKind::Array(inner, _) => TyKind::Slice(inner.clone()).intern(Interner),\n-                _ => {\n-                    never!(\"unsize_array with non-array {:?}\", ty);\n-                    ty\n+            ty = 'x: {\n+                if let TyKind::Ref(m, l, inner) = ty.kind(Interner) {\n+                    if let TyKind::Array(inner, _) = inner.kind(Interner) {\n+                        break 'x TyKind::Ref(\n+                            m.clone(),\n+                            l.clone(),\n+                            TyKind::Slice(inner.clone()).intern(Interner),\n+                        )\n+                        .intern(Interner);\n+                    }\n                 }\n+                never!(\"unsize_array with non-reference-to-array {:?}\", ty);\n+                ty\n             };\n-            // FIXME this is kind of wrong since the unsize needs to happen to a pointer/reference\n             adjust.push(Adjustment {\n                 kind: Adjust::Pointer(PointerCast::Unsize),\n                 target: ty.clone(),\n             });\n         }\n-        if let Some(m) = self.autoref {\n-            ty = TyKind::Ref(m, static_lifetime(), ty).intern(Interner);\n-            adjust\n-                .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(m)), target: ty.clone() });\n-        }\n         (ty, adjust)\n     }\n \n@@ -712,17 +719,17 @@ fn lookup_impl_assoc_item_for_trait_ref(\n     let table = InferenceTable::new(db, env);\n \n     let impl_data = find_matching_impl(impls, table, trait_ref)?;\n-    impl_data.items.iter().find_map(|it| match it {\n+    impl_data.items.iter().find_map(|&it| match it {\n         AssocItemId::FunctionId(f) => {\n-            (db.function_data(*f).name == *name).then_some(AssocItemId::FunctionId(*f))\n+            (db.function_data(f).name == *name).then_some(AssocItemId::FunctionId(f))\n         }\n         AssocItemId::ConstId(c) => db\n-            .const_data(*c)\n+            .const_data(c)\n             .name\n             .as_ref()\n-            .map(|n| *n == *name)\n-            .and_then(|result| if result { Some(AssocItemId::ConstId(*c)) } else { None }),\n-        _ => None,\n+            .map(|n| n == name)\n+            .and_then(|result| if result { Some(AssocItemId::ConstId(c)) } else { None }),\n+        AssocItemId::TypeAliasId(_) => None,\n     })\n }\n \n@@ -1094,13 +1101,13 @@ fn iterate_inherent_methods(\n         None => return ControlFlow::Continue(()),\n     };\n \n-    let (module, block) = match visible_from_module {\n+    let (module, mut block) = match visible_from_module {\n         VisibleFromModule::Filter(module) => (Some(module), module.containing_block()),\n         VisibleFromModule::IncludeBlock(block) => (None, Some(block)),\n         VisibleFromModule::None => (None, None),\n     };\n \n-    if let Some(block_id) = block {\n+    while let Some(block_id) = block {\n         if let Some(impls) = db.inherent_impls_in_block(block_id) {\n             impls_for_self_ty(\n                 &impls,\n@@ -1113,6 +1120,11 @@ fn iterate_inherent_methods(\n                 callback,\n             )?;\n         }\n+\n+        block = db\n+            .block_def_map(block_id)\n+            .and_then(|map| map.parent())\n+            .and_then(|module| module.containing_block());\n     }\n \n     for krate in def_crates {"}, {"sha": "41c53701df6c66fca76d202454880f59dcbdc077", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -813,7 +813,7 @@ fn test() {\n fn method_resolution_trait_from_prelude() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- /main.rs edition:2018 crate:main deps:core\n struct S;\n impl Clone for S {}\n \n@@ -986,14 +986,13 @@ fn main() {\n }\n \n #[test]\n-fn method_resolution_encountering_fn_type() {\n+fn explicit_fn_once_call_fn_item() {\n     check_types(\n         r#\"\n-//- /main.rs\n+//- minicore: fn\n fn foo() {}\n-trait FnOnce { fn call(self); }\n-fn test() { foo.call(); }\n-          //^^^^^^^^^^ {unknown}\n+fn test() { foo.call_once(); }\n+          //^^^^^^^^^^^^^^^ ()\n \"#,\n     );\n }\n@@ -1527,7 +1526,7 @@ fn f(x: U2) {\n fn skip_array_during_method_dispatch() {\n     check_types(\n         r#\"\n-//- /main2018.rs crate:main2018 deps:core\n+//- /main2018.rs crate:main2018 deps:core edition:2018\n use core::IntoIterator;\n \n fn f() {\n@@ -1725,14 +1724,13 @@ fn test() {\n \n #[test]\n fn receiver_adjustment_unsize_array() {\n-    // FIXME not quite correct\n     check(\n         r#\"\n //- minicore: slice\n fn test() {\n     let a = [1, 2, 3];\n     a.len();\n-} //^ adjustments: Pointer(Unsize), Borrow(Ref(Not))\n+} //^ adjustments: Borrow(Ref(Not)), Pointer(Unsize)\n \"#,\n     );\n }"}, {"sha": "2e5787b701cae3e29023c779dc02e33868fd3ef3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3200,3 +3200,86 @@ fn func() {\n     \"#,\n     );\n }\n+\n+// FIXME\n+#[test]\n+fn castable_to() {\n+    check_infer(\n+        r#\"\n+//- minicore: sized\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized> {\n+    inner: *mut T,\n+}\n+impl<T> Box<T> {\n+    fn new(t: T) -> Self { loop {} }\n+}\n+\n+fn func() {\n+    let x = Box::new([]) as Box<[i32; 0]>;\n+}\n+\"#,\n+        expect![[r#\"\n+            99..100 't': T\n+            113..124 '{ loop {} }': Box<T>\n+            115..122 'loop {}': !\n+            120..122 '{}': ()\n+            138..184 '{     ...0]>; }': ()\n+            148..149 'x': Box<[i32; 0]>\n+            152..160 'Box::new': fn new<[{unknown}; 0]>([{unknown}; 0]) -> Box<[{unknown}; 0]>\n+            152..164 'Box::new([])': Box<[{unknown}; 0]>\n+            152..181 'Box::n...2; 0]>': Box<[i32; 0]>\n+            161..163 '[]': [{unknown}; 0]\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn castable_to1() {\n+    check_infer(\n+        r#\"\n+struct Ark<T>(T);\n+impl<T> Ark<T> {\n+    fn foo(&self) -> *const T {\n+        &self.0\n+    }\n+}\n+fn f<T>(t: Ark<T>) {\n+    Ark::foo(&t) as *const ();\n+}\n+\"#,\n+        expect![[r#\"\n+            47..51 'self': &Ark<T>\n+            65..88 '{     ...     }': *const T\n+            75..82 '&self.0': &T\n+            76..80 'self': &Ark<T>\n+            76..82 'self.0': T\n+            99..100 't': Ark<T>\n+            110..144 '{     ... (); }': ()\n+            116..124 'Ark::foo': fn foo<T>(&Ark<T>) -> *const T\n+            116..128 'Ark::foo(&t)': *const T\n+            116..141 'Ark::f...nst ()': *const ()\n+            125..127 '&t': &Ark<T>\n+            126..127 't': Ark<T>\n+        \"#]],\n+    );\n+}\n+\n+// FIXME\n+#[test]\n+fn castable_to2() {\n+    check_infer(\n+        r#\"\n+fn func() {\n+    let x = &0u32 as *const _;\n+}\n+\"#,\n+        expect![[r#\"\n+            10..44 '{     ...t _; }': ()\n+            20..21 'x': *const {unknown}\n+            24..29 '&0u32': &u32\n+            24..41 '&0u32 ...onst _': *const {unknown}\n+            25..29 '0u32': u32\n+        \"#]],\n+    );\n+}"}, {"sha": "015085bde45637d2de570eb37dec4569a95caca1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 140, "deletions": 197, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -163,98 +163,22 @@ fn test() {\n }\n \n #[test]\n-fn infer_try() {\n+fn infer_try_trait() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: try, result\n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n     v;\n } //^ i32\n \n-//- /core.rs crate:core\n-pub mod ops {\n-    pub trait Try {\n-        type Ok;\n-        type Error;\n-    }\n-}\n-\n-pub mod result {\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> crate::ops::Try for Result<O, E> {\n-        type Ok = O;\n-        type Error = E;\n-    }\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::{result::*, ops::*};\n-    }\n-}\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn infer_try_trait_v2() {\n-    check_types(\n-        r#\"\n-//- /main.rs crate:main deps:core\n-fn test() {\n-    let r: Result<i32, u64> = Result::Ok(1);\n-    let v = r?;\n-    v;\n-} //^ i32\n-\n-//- /core.rs crate:core\n-mod ops {\n-    mod try_trait {\n-        pub trait Try: FromResidual {\n-            type Output;\n-            type Residual;\n-        }\n-        pub trait FromResidual<R = <Self as Try>::Residual> {}\n-    }\n-\n-    pub use self::try_trait::FromResidual;\n-    pub use self::try_trait::Try;\n+impl<O, E> core::ops::Try for Result<O, E> {\n+    type Output = O;\n+    type Error = Result<core::convert::Infallible, E>;\n }\n \n-mod convert {\n-    pub trait From<T> {}\n-    impl<T> From<T> for T {}\n-}\n-\n-pub mod result {\n-    use crate::convert::From;\n-    use crate::ops::{Try, FromResidual};\n-\n-    pub enum Infallible {}\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> Try for Result<O, E> {\n-        type Output = O;\n-        type Error = Result<Infallible, E>;\n-    }\n-\n-    impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {}\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::result::*;\n-    }\n-}\n+impl<T, E, F: From<E>> core::ops::FromResidual<Result<core::convert::Infallible, E>> for Result<T, F> {}\n \"#,\n     );\n }\n@@ -263,7 +187,8 @@ pub mod prelude {\n fn infer_for_loop() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core,alloc\n+//- minicore: iterator\n+//- /main.rs crate:main deps:alloc\n #![no_std]\n use alloc::collections::Vec;\n \n@@ -275,23 +200,7 @@ fn test() {\n     } //^ &str\n }\n \n-//- /core.rs crate:core\n-pub mod iter {\n-    pub trait IntoIterator {\n-        type Item;\n-        type IntoIter: Iterator<Item = Self::Item>;\n-    }\n-    pub trait Iterator {\n-        type Item;\n-    }\n-}\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::iter::*;\n-    }\n-}\n-\n-//- /alloc.rs crate:alloc deps:core\n+//- /alloc.rs crate:alloc\n #![no_std]\n pub mod collections {\n     pub struct Vec<T> {}\n@@ -1848,25 +1757,19 @@ fn test() {\n fn fn_trait() {\n     check_infer_with_mismatches(\n         r#\"\n-trait FnOnce<Args> {\n-    type Output;\n-\n-    fn call_once(self, args: Args) -> <Self as FnOnce<Args>>::Output;\n-}\n+//- minicore: fn\n \n fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n     f.call_once((1, 2));\n }\"#,\n         expect![[r#\"\n-            56..60 'self': Self\n-            62..66 'args': Args\n-            149..150 'f': F\n-            155..183 '{     ...2)); }': ()\n-            161..162 'f': F\n-            161..180 'f.call...1, 2))': u128\n-            173..179 '(1, 2)': (u32, u64)\n-            174..175 '1': u32\n-            177..178 '2': u64\n+            38..39 'f': F\n+            44..72 '{     ...2)); }': ()\n+            50..51 'f': F\n+            50..69 'f.call...1, 2))': u128\n+            62..68 '(1, 2)': (u32, u64)\n+            63..64 '1': u32\n+            66..67 '2': u64\n         \"#]],\n     );\n }\n@@ -1875,12 +1778,7 @@ fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n fn fn_ptr_and_item() {\n     check_infer_with_mismatches(\n         r#\"\n-#[lang=\"fn_once\"]\n-trait FnOnce<Args> {\n-    type Output;\n-\n-    fn call_once(self, args: Args) -> Self::Output;\n-}\n+//- minicore: fn\n \n trait Foo<T> {\n     fn foo(&self) -> T;\n@@ -1906,27 +1804,25 @@ fn test() {\n     opt.map(f);\n }\"#,\n         expect![[r#\"\n-            74..78 'self': Self\n-            80..84 'args': Args\n-            139..143 'self': &Self\n-            243..247 'self': &Bar<F>\n-            260..271 '{ loop {} }': (A1, R)\n-            262..269 'loop {}': !\n-            267..269 '{}': ()\n-            355..359 'self': Opt<T>\n-            361..362 'f': F\n-            377..388 '{ loop {} }': Opt<U>\n-            379..386 'loop {}': !\n-            384..386 '{}': ()\n-            402..518 '{     ...(f); }': ()\n-            412..415 'bar': Bar<fn(u8) -> u32>\n-            441..444 'bar': Bar<fn(u8) -> u32>\n-            441..450 'bar.foo()': (u8, u32)\n-            461..464 'opt': Opt<u8>\n-            483..484 'f': fn(u8) -> u32\n-            505..508 'opt': Opt<u8>\n-            505..515 'opt.map(f)': Opt<u32>\n-            513..514 'f': fn(u8) -> u32\n+            28..32 'self': &Self\n+            132..136 'self': &Bar<F>\n+            149..160 '{ loop {} }': (A1, R)\n+            151..158 'loop {}': !\n+            156..158 '{}': ()\n+            244..248 'self': Opt<T>\n+            250..251 'f': F\n+            266..277 '{ loop {} }': Opt<U>\n+            268..275 'loop {}': !\n+            273..275 '{}': ()\n+            291..407 '{     ...(f); }': ()\n+            301..304 'bar': Bar<fn(u8) -> u32>\n+            330..333 'bar': Bar<fn(u8) -> u32>\n+            330..339 'bar.foo()': (u8, u32)\n+            350..353 'opt': Opt<u8>\n+            372..373 'f': fn(u8) -> u32\n+            394..397 'opt': Opt<u8>\n+            394..404 'opt.map(f)': Opt<u32>\n+            402..403 'f': fn(u8) -> u32\n         \"#]],\n     );\n }\n@@ -2399,10 +2295,8 @@ fn unselected_projection_in_trait_env_no_cycle() {\n     // this is not a cycle\n     check_types(\n         r#\"\n-//- /main.rs\n-trait Index {\n-    type Output;\n-}\n+//- minicore: index\n+use core::ops::Index;\n \n type Key<S: UnificationStoreBase> = <S as UnificationStoreBase>::Key;\n \n@@ -2999,40 +2893,17 @@ fn test() {\n fn integer_range_iterate() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: range, iterator\n+//- /main.rs crate:main\n fn test() {\n     for x in 0..100 { x; }\n }                   //^ i32\n \n-//- /core.rs crate:core\n-pub mod ops {\n-    pub struct Range<Idx> {\n-        pub start: Idx,\n-        pub end: Idx,\n-    }\n-}\n-\n-pub mod iter {\n-    pub trait Iterator {\n-        type Item;\n-    }\n-\n-    pub trait IntoIterator {\n-        type Item;\n-        type IntoIter: Iterator<Item = Self::Item>;\n-    }\n-\n-    impl<T> IntoIterator for T where T: Iterator {\n-        type Item = <T as Iterator>::Item;\n-        type IntoIter = Self;\n-    }\n-}\n-\n trait Step {}\n impl Step for i32 {}\n impl Step for i64 {}\n \n-impl<A: Step> iter::Iterator for ops::Range<A> {\n+impl<A: Step> core::iter::Iterator for core::ops::Range<A> {\n     type Item = A;\n }\n \"#,\n@@ -3507,14 +3378,9 @@ trait Request {\n fn bin_op_adt_with_rhs_primitive() {\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"add\"]\n-pub trait Add<Rhs = Self> {\n-    type Output;\n-    fn add(self, rhs: Rhs) -> Self::Output;\n-}\n-\n+//- minicore: add\n struct Wrapper(u32);\n-impl Add<u32> for Wrapper {\n+impl core::ops::Add<u32> for Wrapper {\n     type Output = Self;\n     fn add(self, rhs: u32) -> Wrapper {\n         Wrapper(rhs)\n@@ -3527,29 +3393,106 @@ fn main(){\n \n }\"#,\n         expect![[r#\"\n-            72..76 'self': Self\n-            78..81 'rhs': Rhs\n-            192..196 'self': Wrapper\n-            198..201 'rhs': u32\n-            219..247 '{     ...     }': Wrapper\n-            229..236 'Wrapper': Wrapper(u32) -> Wrapper\n-            229..241 'Wrapper(rhs)': Wrapper\n-            237..240 'rhs': u32\n-            259..345 '{     ...um;  }': ()\n-            269..276 'wrapped': Wrapper\n-            279..286 'Wrapper': Wrapper(u32) -> Wrapper\n-            279..290 'Wrapper(10)': Wrapper\n-            287..289 '10': u32\n-            300..303 'num': u32\n-            311..312 '2': u32\n-            322..325 'res': Wrapper\n-            328..335 'wrapped': Wrapper\n-            328..341 'wrapped + num': Wrapper\n-            338..341 'num': u32\n+            95..99 'self': Wrapper\n+            101..104 'rhs': u32\n+            122..150 '{     ...     }': Wrapper\n+            132..139 'Wrapper': Wrapper(u32) -> Wrapper\n+            132..144 'Wrapper(rhs)': Wrapper\n+            140..143 'rhs': u32\n+            162..248 '{     ...um;  }': ()\n+            172..179 'wrapped': Wrapper\n+            182..189 'Wrapper': Wrapper(u32) -> Wrapper\n+            182..193 'Wrapper(10)': Wrapper\n+            190..192 '10': u32\n+            203..206 'num': u32\n+            214..215 '2': u32\n+            225..228 'res': Wrapper\n+            231..238 'wrapped': Wrapper\n+            231..244 'wrapped + num': Wrapper\n+            241..244 'num': u32\n         \"#]],\n     )\n }\n \n+#[test]\n+fn builtin_binop_expectation_works_on_single_reference() {\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+impl Add<i32> for i32 { type Output = i32 }\n+impl Add<&i32> for i32 { type Output = i32 }\n+impl Add<u32> for u32 { type Output = u32 }\n+impl Add<&u32> for u32 { type Output = u32 }\n+\n+struct V<T>;\n+impl<T> V<T> {\n+    fn default() -> Self { loop {} }\n+    fn get(&self, _: &T) -> &T { loop {} }\n+}\n+\n+fn take_u32(_: u32) {}\n+fn minimized() {\n+    let v = V::default();\n+    let p = v.get(&0);\n+      //^ &u32\n+    take_u32(42 + p);\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_builtin_binop_expectation_for_general_ty_var() {\n+    // FIXME: Ideally type mismatch should be reported on `take_u32(42 - p)`.\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+impl Add<i32> for i32 { type Output = i32; }\n+impl Add<&i32> for i32 { type Output = i32; }\n+// This is needed to prevent chalk from giving unique solution to `i32: Add<&?0>` after applying\n+// fallback to integer type variable for `42`.\n+impl Add<&()> for i32 { type Output = (); }\n+\n+struct V<T>;\n+impl<T> V<T> {\n+    fn default() -> Self { loop {} }\n+    fn get(&self) -> &T { loop {} }\n+}\n+\n+fn take_u32(_: u32) {}\n+fn minimized() {\n+    let v = V::default();\n+    let p = v.get();\n+      //^ &{unknown}\n+    take_u32(42 + p);\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_builtin_binop_expectation_for_non_builtin_types() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: default, eq\n+struct S;\n+impl Default for S { fn default() -> Self { S } }\n+impl Default for i32 { fn default() -> Self { 0 } }\n+impl PartialEq<S> for i32 { fn eq(&self, _: &S) -> bool { true } }\n+impl PartialEq<i32> for i32 { fn eq(&self, _: &S) -> bool { true } }\n+\n+fn take_s(_: S) {}\n+fn test() {\n+    let s = Default::default();\n+    let _eq = 0 == s;\n+    take_s(s);\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn array_length() {\n     check_infer("}, {"sha": "3ab85c68f5b9db67e809a8d60c8ff1a821c570cf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/traits.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -7,9 +7,11 @@ use chalk_recursive::Cache;\n use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n \n use base_db::CrateId;\n-use hir_def::{lang_item::LangItemTarget, TraitId};\n+use hir_def::{\n+    lang_item::{LangItem, LangItemTarget},\n+    TraitId,\n+};\n use stdx::panic_context;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n@@ -177,18 +179,18 @@ pub enum FnTrait {\n }\n \n impl FnTrait {\n-    const fn lang_item_name(self) -> &'static str {\n+    const fn lang_item(self) -> LangItem {\n         match self {\n-            FnTrait::FnOnce => \"fn_once\",\n-            FnTrait::FnMut => \"fn_mut\",\n-            FnTrait::Fn => \"fn\",\n+            FnTrait::FnOnce => LangItem::FnOnce,\n+            FnTrait::FnMut => LangItem::FnMut,\n+            FnTrait::Fn => LangItem::Fn,\n         }\n     }\n \n     pub fn get_id(&self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n-        let target = db.lang_item(krate, SmolStr::new_inline(self.lang_item_name()))?;\n+        let target = db.lang_item(krate, self.lang_item())?;\n         match target {\n-            LangItemTarget::TraitId(t) => Some(t),\n+            LangItemTarget::Trait(t) => Some(t),\n             _ => None,\n         }\n     }"}, {"sha": "70d2d5efa6cdee5e33f11a66801d2fb909acef4b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/utils.rs", "status": "modified", "additions": 94, "deletions": 91, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -11,39 +11,100 @@ use hir_def::{\n         GenericParams, TypeOrConstParamData, TypeParamProvenance, WherePredicate,\n         WherePredicateTypeTarget,\n     },\n-    intern::Interned,\n+    lang_item::LangItem,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n     ConstParamId, FunctionId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId,\n     TypeOrConstParamId, TypeParamId,\n };\n use hir_expand::name::Name;\n+use intern::Interned;\n use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n };\n \n-pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n-    [\n-        db.lang_item(krate, SmolStr::new_inline(\"fn\")),\n-        db.lang_item(krate, SmolStr::new_inline(\"fn_mut\")),\n-        db.lang_item(krate, SmolStr::new_inline(\"fn_once\")),\n-    ]\n-    .into_iter()\n-    .flatten()\n-    .flat_map(|it| it.as_trait())\n+pub(crate) fn fn_traits(\n+    db: &dyn DefDatabase,\n+    krate: CrateId,\n+) -> impl Iterator<Item = TraitId> + '_ {\n+    [LangItem::Fn, LangItem::FnMut, LangItem::FnOnce]\n+        .into_iter()\n+        .filter_map(move |lang| db.lang_item(krate, lang))\n+        .flat_map(|it| it.as_trait())\n }\n \n-fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n+/// Returns an iterator over the whole super trait hierarchy (including the\n+/// trait itself).\n+pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n+    // we need to take care a bit here to avoid infinite loops in case of cycles\n+    // (i.e. if we have `trait A: B; trait B: A;`)\n+\n+    let mut result = smallvec![trait_];\n+    let mut i = 0;\n+    while let Some(&t) = result.get(i) {\n+        // yeah this is quadratic, but trait hierarchies should be flat\n+        // enough that this doesn't matter\n+        direct_super_traits(db, t, |tt| {\n+            if !result.contains(&tt) {\n+                result.push(tt);\n+            }\n+        });\n+        i += 1;\n+    }\n+    result\n+}\n+\n+/// Given a trait ref (`Self: Trait`), builds all the implied trait refs for\n+/// super traits. The original trait ref will be included. So the difference to\n+/// `all_super_traits` is that we keep track of type parameters; for example if\n+/// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n+/// `Self: OtherTrait<i32>`.\n+pub(super) fn all_super_trait_refs<T>(\n+    db: &dyn HirDatabase,\n+    trait_ref: TraitRef,\n+    cb: impl FnMut(TraitRef) -> Option<T>,\n+) -> Option<T> {\n+    let seen = iter::once(trait_ref.trait_id).collect();\n+    let mut stack = Vec::new();\n+    stack.push(trait_ref);\n+    SuperTraits { db, seen, stack }.find_map(cb)\n+}\n+\n+struct SuperTraits<'a> {\n+    db: &'a dyn HirDatabase,\n+    stack: Vec<TraitRef>,\n+    seen: FxHashSet<ChalkTraitId>,\n+}\n+\n+impl<'a> SuperTraits<'a> {\n+    fn elaborate(&mut self, trait_ref: &TraitRef) {\n+        direct_super_trait_refs(self.db, trait_ref, |trait_ref| {\n+            if !self.seen.contains(&trait_ref.trait_id) {\n+                self.stack.push(trait_ref);\n+            }\n+        });\n+    }\n+}\n+\n+impl<'a> Iterator for SuperTraits<'a> {\n+    type Item = TraitRef;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(next) = self.stack.pop() {\n+            self.elaborate(&next);\n+            Some(next)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId, cb: impl FnMut(TraitId)) {\n     let resolver = trait_.resolver(db);\n-    // returning the iterator directly doesn't easily work because of\n-    // lifetime problems, but since there usually shouldn't be more than a\n-    // few direct traits this should be fine (we could even use some kind of\n-    // SmallVec if performance is a concern)\n     let generic_params = db.generic_params(trait_.into());\n     let trait_self = generic_params.find_trait_self_param();\n     generic_params\n@@ -73,18 +134,14 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[Trait\n             Some(TypeNs::TraitId(t)) => Some(t),\n             _ => None,\n         })\n-        .collect()\n+        .for_each(cb);\n }\n \n-fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<TraitRef> {\n-    // returning the iterator directly doesn't easily work because of\n-    // lifetime problems, but since there usually shouldn't be more than a\n-    // few direct traits this should be fine (we could even use some kind of\n-    // SmallVec if performance is a concern)\n+fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef, cb: impl FnMut(TraitRef)) {\n     let generic_params = db.generic_params(trait_ref.hir_trait_id().into());\n     let trait_self = match generic_params.find_trait_self_param() {\n         Some(p) => TypeOrConstParamId { parent: trait_ref.hir_trait_id().into(), local_id: p },\n-        None => return Vec::new(),\n+        None => return,\n     };\n     db.generic_predicates_for_param(trait_self.parent, trait_self, None)\n         .iter()\n@@ -100,72 +157,15 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n             })\n         })\n         .map(|pred| pred.substitute(Interner, &trait_ref.substitution))\n-        .collect()\n-}\n-\n-/// Returns an iterator over the whole super trait hierarchy (including the\n-/// trait itself).\n-pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n-    // we need to take care a bit here to avoid infinite loops in case of cycles\n-    // (i.e. if we have `trait A: B; trait B: A;`)\n-\n-    let mut result = smallvec![trait_];\n-    let mut i = 0;\n-    while let Some(&t) = result.get(i) {\n-        // yeah this is quadratic, but trait hierarchies should be flat\n-        // enough that this doesn't matter\n-        for tt in direct_super_traits(db, t) {\n-            if !result.contains(&tt) {\n-                result.push(tt);\n-            }\n-        }\n-        i += 1;\n-    }\n-    result\n-}\n-\n-/// Given a trait ref (`Self: Trait`), builds all the implied trait refs for\n-/// super traits. The original trait ref will be included. So the difference to\n-/// `all_super_traits` is that we keep track of type parameters; for example if\n-/// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n-/// `Self: OtherTrait<i32>`.\n-pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> SuperTraits<'_> {\n-    SuperTraits { db, seen: iter::once(trait_ref.trait_id).collect(), stack: vec![trait_ref] }\n-}\n-\n-pub(super) struct SuperTraits<'a> {\n-    db: &'a dyn HirDatabase,\n-    stack: Vec<TraitRef>,\n-    seen: FxHashSet<ChalkTraitId>,\n-}\n-\n-impl<'a> SuperTraits<'a> {\n-    fn elaborate(&mut self, trait_ref: &TraitRef) {\n-        let mut trait_refs = direct_super_trait_refs(self.db, trait_ref);\n-        trait_refs.retain(|tr| !self.seen.contains(&tr.trait_id));\n-        self.stack.extend(trait_refs);\n-    }\n-}\n-\n-impl<'a> Iterator for SuperTraits<'a> {\n-    type Item = TraitRef;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if let Some(next) = self.stack.pop() {\n-            self.elaborate(&next);\n-            Some(next)\n-        } else {\n-            None\n-        }\n-    }\n+        .for_each(cb);\n }\n \n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &dyn HirDatabase,\n     trait_ref: TraitRef,\n     name: &Name,\n ) -> Option<(TraitRef, TypeAliasId)> {\n-    all_super_trait_refs(db, trait_ref).find_map(|t| {\n+    all_super_trait_refs(db, trait_ref, |t| {\n         let assoc_type = db.trait_data(t.hir_trait_id()).associated_type_by_name(name)?;\n         Some((t, assoc_type))\n     })\n@@ -238,15 +238,18 @@ impl Generics {\n \n     /// (parent total, self param, type param list, const param list, impl trait)\n     pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize, usize) {\n-        let ty_iter = || self.params.iter().filter_map(|x| x.1.type_param());\n-\n-        let self_params =\n-            ty_iter().filter(|p| p.provenance == TypeParamProvenance::TraitSelf).count();\n-        let type_params =\n-            ty_iter().filter(|p| p.provenance == TypeParamProvenance::TypeParamList).count();\n-        let impl_trait_params =\n-            ty_iter().filter(|p| p.provenance == TypeParamProvenance::ArgumentImplTrait).count();\n-        let const_params = self.params.iter().filter_map(|x| x.1.const_param()).count();\n+        let mut self_params = 0;\n+        let mut type_params = 0;\n+        let mut impl_trait_params = 0;\n+        let mut const_params = 0;\n+        self.params.iter().for_each(|(_, data)| match data {\n+            TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n+                TypeParamProvenance::TypeParamList => type_params += 1,\n+                TypeParamProvenance::TraitSelf => self_params += 1,\n+                TypeParamProvenance::ArgumentImplTrait => impl_trait_params += 1,\n+            },\n+            TypeOrConstParamData::ConstParamData(_) => const_params += 1,\n+        });\n \n         let parent_len = self.parent_generics().map_or(0, Generics::len);\n         (parent_len, self_params, type_params, const_params, impl_trait_params)"}, {"sha": "c476894552e6c879e2a1d18841ad5e594bf2bac3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/walk.rs", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fwalk.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3", "patch": "@@ -1,147 +0,0 @@\n-//! The `TypeWalk` trait (probably to be replaced by Chalk's `Fold` and\n-//! `Visit`).\n-\n-use chalk_ir::interner::HasInterner;\n-\n-use crate::{\n-    AliasEq, AliasTy, Binders, CallableSig, FnSubst, GenericArg, GenericArgData, Interner,\n-    OpaqueTy, ProjectionTy, Substitution, TraitRef, Ty, TyKind, WhereClause,\n-};\n-\n-/// This allows walking structures that contain types to do something with those\n-/// types, similar to Chalk's `Fold` trait.\n-pub trait TypeWalk {\n-    fn walk(&self, f: &mut impl FnMut(&Ty));\n-}\n-\n-impl TypeWalk for Ty {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self.kind(Interner) {\n-            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                for t in p_ty.substitution.iter(Interner) {\n-                    t.walk(f);\n-                }\n-            }\n-            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                for t in o_ty.substitution.iter(Interner) {\n-                    t.walk(f);\n-                }\n-            }\n-            TyKind::Dyn(dyn_ty) => {\n-                for p in dyn_ty.bounds.skip_binders().interned().iter() {\n-                    p.walk(f);\n-                }\n-            }\n-            TyKind::Slice(ty)\n-            | TyKind::Array(ty, _)\n-            | TyKind::Ref(_, _, ty)\n-            | TyKind::Raw(_, ty) => {\n-                ty.walk(f);\n-            }\n-            TyKind::Function(fn_pointer) => {\n-                fn_pointer.substitution.0.walk(f);\n-            }\n-            TyKind::Adt(_, substs)\n-            | TyKind::FnDef(_, substs)\n-            | TyKind::Tuple(_, substs)\n-            | TyKind::OpaqueType(_, substs)\n-            | TyKind::AssociatedType(_, substs)\n-            | TyKind::Closure(.., substs) => {\n-                substs.walk(f);\n-            }\n-            _ => {}\n-        }\n-        f(self);\n-    }\n-}\n-\n-impl<T: TypeWalk> TypeWalk for Vec<T> {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self {\n-            t.walk(f);\n-        }\n-    }\n-}\n-\n-impl TypeWalk for OpaqueTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substitution.walk(f);\n-    }\n-}\n-\n-impl TypeWalk for ProjectionTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substitution.walk(f);\n-    }\n-}\n-\n-impl TypeWalk for AliasTy {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            AliasTy::Projection(it) => it.walk(f),\n-            AliasTy::Opaque(it) => it.walk(f),\n-        }\n-    }\n-}\n-\n-impl TypeWalk for GenericArg {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        if let GenericArgData::Ty(ty) = &self.interned() {\n-            ty.walk(f);\n-        }\n-    }\n-}\n-\n-impl TypeWalk for Substitution {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.iter(Interner) {\n-            t.walk(f);\n-        }\n-    }\n-}\n-\n-impl<T: TypeWalk + HasInterner<Interner = Interner>> TypeWalk for Binders<T> {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.skip_binders().walk(f);\n-    }\n-}\n-\n-impl TypeWalk for TraitRef {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.substitution.walk(f);\n-    }\n-}\n-\n-impl TypeWalk for WhereClause {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            WhereClause::Implemented(trait_ref) => trait_ref.walk(f),\n-            WhereClause::AliasEq(alias_eq) => alias_eq.walk(f),\n-            _ => {}\n-        }\n-    }\n-}\n-\n-impl TypeWalk for CallableSig {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.params_and_return.iter() {\n-            t.walk(f);\n-        }\n-    }\n-}\n-\n-impl TypeWalk for AliasEq {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.ty.walk(f);\n-        match &self.alias {\n-            AliasTy::Projection(projection_ty) => projection_ty.walk(f),\n-            AliasTy::Opaque(opaque) => opaque.walk(f),\n-        }\n-    }\n-}\n-\n-impl TypeWalk for FnSubst<Interner> {\n-    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.0.walk(f)\n-    }\n-}"}, {"sha": "32cde8a77325cbe67bbcf5d09c985510419cf40c", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"hir\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -15,14 +17,15 @@ either = \"1.7.0\"\n arrayvec = \"0.7.2\"\n itertools = \"0.10.5\"\n smallvec = \"1.10.0\"\n-once_cell = \"1.15.0\"\n+once_cell = \"1.17.0\"\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-base-db = { path = \"../base-db\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-hir-expand = { path = \"../hir-expand\", version = \"0.0.0\" }\n-hir-def = { path = \"../hir-def\", version = \"0.0.0\" }\n-hir-ty = { path = \"../hir-ty\", version = \"0.0.0\" }\n-tt = { path = \"../tt\", version = \"0.0.0\" }\n-cfg = { path = \"../cfg\", version = \"0.0.0\" }\n+# local deps\n+base-db.workspace = true\n+cfg.workspace = true\n+hir-def.workspace = true\n+hir-expand.workspace = true\n+hir-ty.workspace = true\n+profile.workspace = true\n+stdx.workspace = true\n+syntax.workspace = true\n+tt.workspace = true"}, {"sha": "0d19420127f54fd171dccb521161b1ed0db9c900", "filename": "src/tools/rust-analyzer/crates/hir/src/display.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,6 +4,7 @@ use hir_def::{\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n+    lang_item::LangItem,\n     type_ref::{TypeBound, TypeRef},\n     AdtId, GenericDefId,\n };\n@@ -14,7 +15,6 @@ use hir_ty::{\n     },\n     Interner, TraitRefExt, WhereClause,\n };\n-use syntax::SmolStr;\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n@@ -261,16 +261,15 @@ impl HirDisplay for TypeParam {\n             bounds.iter().cloned().map(|b| b.substitute(Interner, &substs)).collect();\n         let krate = self.id.parent().krate(f.db).id;\n         let sized_trait =\n-            f.db.lang_item(krate, SmolStr::new_inline(\"sized\"))\n-                .and_then(|lang_item| lang_item.as_trait());\n+            f.db.lang_item(krate, LangItem::Sized).and_then(|lang_item| lang_item.as_trait());\n         let has_only_sized_bound = predicates.iter().all(move |pred| match pred.skip_binders() {\n             WhereClause::Implemented(it) => Some(it.hir_trait_id()) == sized_trait,\n             _ => false,\n         });\n         let has_only_not_sized_bound = predicates.is_empty();\n         if !has_only_sized_bound || has_only_not_sized_bound {\n             let default_sized = SizedByDefault::Sized { anchor: krate };\n-            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, default_sized, f)?;\n+            write_bounds_like_dyn_trait_with_prefix(f, \":\", &predicates, default_sized)?;\n         }\n         Ok(())\n     }"}, {"sha": "2cb4ed2c33518d170a9bae52a78dbde26364186f", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 141, "deletions": 45, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -44,12 +44,13 @@ use hir_def::{\n     expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n-    lang_item::LangItemTarget,\n+    lang_item::{LangItem, LangItemTarget},\n     layout::{Layout, LayoutError, ReprOptions},\n     nameres::{self, diagnostics::DefDiagnostic},\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n+    type_ref::ConstScalar,\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n     EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, MacroExpander, MacroId, ModuleId, StaticId, StructId,\n@@ -65,8 +66,9 @@ use hir_ty::{\n     primitive::UintTy,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n-    GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n-    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, WhereClause,\n+    ConcreteConst, ConstValue, GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar,\n+    Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind,\n+    WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -107,7 +109,7 @@ pub use {\n     cfg::{CfgAtom, CfgExpr, CfgOptions},\n     hir_def::{\n         adt::StructKind,\n-        attr::{Attr, Attrs, AttrsWithOwner, Documentation},\n+        attr::{Attrs, AttrsWithOwner, Documentation},\n         builtin_attr::AttributeTemplate,\n         find_path::PrefixKind,\n         import_map,\n@@ -122,11 +124,12 @@ pub use {\n         ModuleDefId,\n     },\n     hir_expand::{\n+        attrs::Attr,\n         name::{known, Name},\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n     hir_ty::{\n-        display::{HirDisplay, HirWrite},\n+        display::{HirDisplay, HirDisplayError, HirWrite},\n         PointerCast, Safety,\n     },\n };\n@@ -471,8 +474,8 @@ impl Module {\n         let def_map = self.id.def_map(db.upcast());\n         let children = def_map[self.id.local_id]\n             .children\n-            .iter()\n-            .map(|(_, module_id)| Module { id: def_map.module_id(*module_id) })\n+            .values()\n+            .map(|module_id| Module { id: def_map.module_id(*module_id) })\n             .collect::<Vec<_>>();\n         children.into_iter()\n     }\n@@ -784,7 +787,7 @@ fn precise_macro_call_location(\n             let token = (|| {\n                 let derive_attr = node\n                     .doc_comments_and_attrs()\n-                    .nth(*derive_attr_index as usize)\n+                    .nth(derive_attr_index.ast_index())\n                     .and_then(Either::left)?;\n                 let token_tree = derive_attr.meta()?.token_tree()?;\n                 let group_by = token_tree\n@@ -812,9 +815,11 @@ fn precise_macro_call_location(\n             let node = ast_id.to_node(db.upcast());\n             let attr = node\n                 .doc_comments_and_attrs()\n-                .nth((*invoc_attr_index) as usize)\n+                .nth(invoc_attr_index.ast_index())\n                 .and_then(Either::left)\n-                .unwrap_or_else(|| panic!(\"cannot find attribute #{invoc_attr_index}\"));\n+                .unwrap_or_else(|| {\n+                    panic!(\"cannot find attribute #{}\", invoc_attr_index.ast_index())\n+                });\n \n             (\n                 ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),\n@@ -920,7 +925,7 @@ impl Struct {\n     }\n \n     pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprOptions> {\n-        db.struct_data(self.id).repr.clone()\n+        db.struct_data(self.id).repr\n     }\n \n     pub fn kind(self, db: &dyn HirDatabase) -> StructKind {\n@@ -1831,7 +1836,7 @@ pub struct Trait {\n \n impl Trait {\n     pub fn lang(db: &dyn HirDatabase, krate: Crate, name: &Name) -> Option<Trait> {\n-        db.lang_item(krate.into(), name.to_smol_str())\n+        db.lang_item(krate.into(), LangItem::from_name(name)?)\n             .and_then(LangItemTarget::as_trait)\n             .map(Into::into)\n     }\n@@ -2126,7 +2131,7 @@ pub enum AssocItem {\n     Const(Const),\n     TypeAlias(TypeAlias),\n }\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum AssocItemContainer {\n     Trait(Trait),\n     Impl(Impl),\n@@ -2160,6 +2165,16 @@ impl AsAssocItem for ModuleDef {\n         }\n     }\n }\n+impl AsAssocItem for DefWithBody {\n+    fn as_assoc_item(self, db: &dyn HirDatabase) -> Option<AssocItem> {\n+        match self {\n+            DefWithBody::Function(it) => it.as_assoc_item(db),\n+            DefWithBody::Const(it) => it.as_assoc_item(db),\n+            DefWithBody::Static(_) | DefWithBody::Variant(_) => None,\n+        }\n+    }\n+}\n+\n fn as_assoc_item<ID, DEF, CTOR, AST>(db: &dyn HirDatabase, ctor: CTOR, id: ID) -> Option<AssocItem>\n where\n     ID: Lookup<Data = AssocItemLoc<AST>>,\n@@ -2406,7 +2421,7 @@ impl Local {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct DeriveHelper {\n     pub(crate) derive: MacroId,\n-    pub(crate) idx: usize,\n+    pub(crate) idx: u32,\n }\n \n impl DeriveHelper {\n@@ -2416,15 +2431,18 @@ impl DeriveHelper {\n \n     pub fn name(&self, db: &dyn HirDatabase) -> Name {\n         match self.derive {\n-            MacroId::Macro2Id(it) => {\n-                db.macro2_data(it).helpers.as_deref().and_then(|it| it.get(self.idx)).cloned()\n-            }\n+            MacroId::Macro2Id(it) => db\n+                .macro2_data(it)\n+                .helpers\n+                .as_deref()\n+                .and_then(|it| it.get(self.idx as usize))\n+                .cloned(),\n             MacroId::MacroRulesId(_) => None,\n             MacroId::ProcMacroId(proc_macro) => db\n                 .proc_macro_data(proc_macro)\n                 .helpers\n                 .as_deref()\n-                .and_then(|it| it.get(self.idx))\n+                .and_then(|it| it.get(self.idx as usize))\n                 .cloned(),\n         }\n         .unwrap_or_else(|| Name::missing())\n@@ -2435,7 +2453,7 @@ impl DeriveHelper {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct BuiltinAttr {\n     krate: Option<CrateId>,\n-    idx: usize,\n+    idx: u32,\n }\n \n impl BuiltinAttr {\n@@ -2444,37 +2462,38 @@ impl BuiltinAttr {\n         if let builtin @ Some(_) = Self::builtin(name) {\n             return builtin;\n         }\n-        let idx = db.crate_def_map(krate.id).registered_attrs().iter().position(|it| it == name)?;\n+        let idx =\n+            db.crate_def_map(krate.id).registered_attrs().iter().position(|it| it == name)? as u32;\n         Some(BuiltinAttr { krate: Some(krate.id), idx })\n     }\n \n     fn builtin(name: &str) -> Option<Self> {\n         hir_def::builtin_attr::INERT_ATTRIBUTES\n             .iter()\n             .position(|tool| tool.name == name)\n-            .map(|idx| BuiltinAttr { krate: None, idx })\n+            .map(|idx| BuiltinAttr { krate: None, idx: idx as u32 })\n     }\n \n     pub fn name(&self, db: &dyn HirDatabase) -> SmolStr {\n         // FIXME: Return a `Name` here\n         match self.krate {\n-            Some(krate) => db.crate_def_map(krate).registered_attrs()[self.idx].clone(),\n-            None => SmolStr::new(hir_def::builtin_attr::INERT_ATTRIBUTES[self.idx].name),\n+            Some(krate) => db.crate_def_map(krate).registered_attrs()[self.idx as usize].clone(),\n+            None => SmolStr::new(hir_def::builtin_attr::INERT_ATTRIBUTES[self.idx as usize].name),\n         }\n     }\n \n     pub fn template(&self, _: &dyn HirDatabase) -> Option<AttributeTemplate> {\n         match self.krate {\n             Some(_) => None,\n-            None => Some(hir_def::builtin_attr::INERT_ATTRIBUTES[self.idx].template),\n+            None => Some(hir_def::builtin_attr::INERT_ATTRIBUTES[self.idx as usize].template),\n         }\n     }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct ToolModule {\n     krate: Option<CrateId>,\n-    idx: usize,\n+    idx: u32,\n }\n \n impl ToolModule {\n@@ -2483,22 +2502,23 @@ impl ToolModule {\n         if let builtin @ Some(_) = Self::builtin(name) {\n             return builtin;\n         }\n-        let idx = db.crate_def_map(krate.id).registered_tools().iter().position(|it| it == name)?;\n+        let idx =\n+            db.crate_def_map(krate.id).registered_tools().iter().position(|it| it == name)? as u32;\n         Some(ToolModule { krate: Some(krate.id), idx })\n     }\n \n     fn builtin(name: &str) -> Option<Self> {\n         hir_def::builtin_attr::TOOL_MODULES\n             .iter()\n             .position(|&tool| tool == name)\n-            .map(|idx| ToolModule { krate: None, idx })\n+            .map(|idx| ToolModule { krate: None, idx: idx as u32 })\n     }\n \n     pub fn name(&self, db: &dyn HirDatabase) -> SmolStr {\n         // FIXME: Return a `Name` here\n         match self.krate {\n-            Some(krate) => db.crate_def_map(krate).registered_tools()[self.idx].clone(),\n-            None => SmolStr::new(hir_def::builtin_attr::TOOL_MODULES[self.idx]),\n+            Some(krate) => db.crate_def_map(krate).registered_tools()[self.idx as usize].clone(),\n+            None => SmolStr::new(hir_def::builtin_attr::TOOL_MODULES[self.idx as usize]),\n         }\n     }\n }\n@@ -2555,6 +2575,14 @@ impl GenericParam {\n             GenericParam::LifetimeParam(it) => it.name(db),\n         }\n     }\n+\n+    pub fn parent(self) -> GenericDef {\n+        match self {\n+            GenericParam::TypeParam(it) => it.id.parent().into(),\n+            GenericParam::ConstParam(it) => it.id.parent().into(),\n+            GenericParam::LifetimeParam(it) => it.id.parent.into(),\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -2788,14 +2816,19 @@ impl Impl {\n         all\n     }\n \n-    // FIXME: the return type is wrong. This should be a hir version of\n-    // `TraitRef` (to account for parameters and qualifiers)\n     pub fn trait_(self, db: &dyn HirDatabase) -> Option<Trait> {\n-        let trait_ref = db.impl_trait(self.id)?.skip_binders().clone();\n-        let id = hir_ty::from_chalk_trait_id(trait_ref.trait_id);\n+        let trait_ref = db.impl_trait(self.id)?;\n+        let id = trait_ref.skip_binders().hir_trait_id();\n         Some(Trait { id })\n     }\n \n+    pub fn trait_ref(self, db: &dyn HirDatabase) -> Option<TraitRef> {\n+        let substs = TyBuilder::placeholder_subst(db, self.id);\n+        let trait_ref = db.impl_trait(self.id)?.substitute(Interner, &substs);\n+        let resolver = self.id.resolver(db.upcast());\n+        Some(TraitRef::new_with_resolver(db, &resolver, trait_ref))\n+    }\n+\n     pub fn self_ty(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.resolver(db.upcast());\n         let substs = TyBuilder::placeholder_subst(db, self.id);\n@@ -2821,6 +2854,48 @@ impl Impl {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TraitRef {\n+    env: Arc<TraitEnvironment>,\n+    trait_ref: hir_ty::TraitRef,\n+}\n+\n+impl TraitRef {\n+    pub(crate) fn new_with_resolver(\n+        db: &dyn HirDatabase,\n+        resolver: &Resolver,\n+        trait_ref: hir_ty::TraitRef,\n+    ) -> TraitRef {\n+        let env = resolver.generic_def().map_or_else(\n+            || Arc::new(TraitEnvironment::empty(resolver.krate())),\n+            |d| db.trait_environment(d),\n+        );\n+        TraitRef { env, trait_ref }\n+    }\n+\n+    pub fn trait_(&self) -> Trait {\n+        let id = self.trait_ref.hir_trait_id();\n+        Trait { id }\n+    }\n+\n+    pub fn self_ty(&self) -> Type {\n+        let ty = self.trait_ref.self_type_parameter(Interner);\n+        Type { env: self.env.clone(), ty }\n+    }\n+\n+    /// Returns `idx`-th argument of this trait reference if it is a type argument. Note that the\n+    /// first argument is the `Self` type.\n+    pub fn get_type_argument(&self, idx: usize) -> Option<Type> {\n+        self.trait_ref\n+            .substitution\n+            .as_slice(Interner)\n+            .get(idx)\n+            .and_then(|arg| arg.ty(Interner))\n+            .cloned()\n+            .map(|ty| Type { env: self.env.clone(), ty })\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Type {\n     env: Arc<TraitEnvironment>,\n@@ -2957,16 +3032,15 @@ impl Type {\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_into_future(&self, db: &dyn HirDatabase) -> bool {\n         let trait_ = db\n-            .lang_item(self.env.krate, SmolStr::new_inline(\"into_future\"))\n+            .lang_item(self.env.krate, LangItem::IntoFutureIntoFuture)\n             .and_then(|it| {\n                 let into_future_fn = it.as_function()?;\n                 let assoc_item = as_assoc_item(db, AssocItem::Function, into_future_fn)?;\n                 let into_future_trait = assoc_item.containing_trait_or_trait_impl(db)?;\n                 Some(into_future_trait.id)\n             })\n             .or_else(|| {\n-                let future_trait =\n-                    db.lang_item(self.env.krate, SmolStr::new_inline(\"future_trait\"))?;\n+                let future_trait = db.lang_item(self.env.krate, LangItem::Future)?;\n                 future_trait.as_trait()\n             });\n \n@@ -3059,9 +3133,9 @@ impl Type {\n     }\n \n     pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n-        let lang_item = db.lang_item(self.env.krate, SmolStr::new_inline(\"copy\"));\n+        let lang_item = db.lang_item(self.env.krate, LangItem::Copy);\n         let copy_trait = match lang_item {\n-            Some(LangItemTarget::TraitId(it)) => it,\n+            Some(LangItemTarget::Trait(it)) => it,\n             _ => return false,\n         };\n         self.impls_trait(db, copy_trait.into(), &[])\n@@ -3088,15 +3162,15 @@ impl Type {\n     }\n \n     pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::Closure { .. })\n+        matches!(self.ty.kind(Interner), TyKind::Closure { .. })\n     }\n \n     pub fn is_fn(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n+        matches!(self.ty.kind(Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n     }\n \n     pub fn is_array(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::Array(..))\n+        matches!(self.ty.kind(Interner), TyKind::Array(..))\n     }\n \n     pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n@@ -3113,10 +3187,12 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.kind(Interner), TyKind::Raw(..))\n+        matches!(self.ty.kind(Interner), TyKind::Raw(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n+        // FIXME: When we get rid of `ConstScalar::Unknown`, we can just look at precomputed\n+        // `TypeFlags` in `TyData`.\n         return go(&self.ty);\n \n         fn go(ty: &Ty) -> bool {\n@@ -3182,6 +3258,19 @@ impl Type {\n         }\n     }\n \n+    pub fn as_array(&self, _db: &dyn HirDatabase) -> Option<(Type, usize)> {\n+        if let TyKind::Array(ty, len) = &self.ty.kind(Interner) {\n+            match len.data(Interner).value {\n+                ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(len) }) => {\n+                    Some((self.derived(ty.clone()), len as usize))\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         self.autoderef_(db).map(move |ty| self.derived(ty))\n     }\n@@ -3418,10 +3507,9 @@ impl Type {\n         Type { env: self.env.clone(), ty }\n     }\n \n+    /// Visits every type, including generic arguments, in this type. `cb` is called with type\n+    /// itself first, and then with its generic arguments.\n     pub fn walk(&self, db: &dyn HirDatabase, mut cb: impl FnMut(Type)) {\n-        // TypeWalk::walk for a Ty at first visits parameters and only after that the Ty itself.\n-        // We need a different order here.\n-\n         fn walk_substs(\n             db: &dyn HirDatabase,\n             type_: &Type,\n@@ -3534,6 +3622,14 @@ impl Type {\n             _ => None,\n         }\n     }\n+\n+    /// Returns unique `GenericParam`s contained in this type.\n+    pub fn generic_params(&self, db: &dyn HirDatabase) -> FxHashSet<GenericParam> {\n+        hir_ty::collect_placeholders(&self.ty, db)\n+            .into_iter()\n+            .map(|id| TypeOrConstParam { id }.split(db).either_into())\n+            .collect()\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "486b7ee62ed3ad0383872e7da8184ecb141f5235", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1319,10 +1319,7 @@ impl<'db> SemanticsImpl<'db> {\n         let _p = profile::span(\"Semantics::analyze_impl\");\n         let node = self.find_file(node);\n \n-        let container = match self.with_ctx(|ctx| ctx.find_container(node)) {\n-            Some(it) => it,\n-            None => return None,\n-        };\n+        let container = self.with_ctx(|ctx| ctx.find_container(node))?;\n \n         let resolver = match container {\n             ChildContainer::DefWithBodyId(def) => {\n@@ -1472,14 +1469,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn is_inside_unsafe(&self, expr: &ast::Expr) -> bool {\n-        let item_or_variant = |ancestor: SyntaxNode| {\n-            if ast::Item::can_cast(ancestor.kind()) {\n-                ast::Item::cast(ancestor).map(Either::Left)\n-            } else {\n-                ast::Variant::cast(ancestor).map(Either::Right)\n-            }\n-        };\n-        let Some(enclosing_item) = expr.syntax().ancestors().find_map(item_or_variant) else { return false };\n+        let Some(enclosing_item) = expr.syntax().ancestors().find_map(Either::<ast::Item, ast::Variant>::cast) else { return false };\n \n         let def = match &enclosing_item {\n             Either::Left(ast::Item::Fn(it)) if it.unsafe_token().is_some() => return true,\n@@ -1589,7 +1579,7 @@ fn find_root(node: &SyntaxNode) -> SyntaxNode {\n     node.ancestors().last().unwrap()\n }\n \n-/// `SemanticScope` encapsulates the notion of a scope (the set of visible\n+/// `SemanticsScope` encapsulates the notion of a scope (the set of visible\n /// names) at a particular program point.\n ///\n /// It is a bit tricky, as scopes do not really exist inside the compiler."}, {"sha": "2b5bfda1d4347ef959f143663534c9e9bfb5256d", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -87,7 +87,6 @@\n \n use base_db::FileId;\n use hir_def::{\n-    attr::AttrId,\n     child_by_source::ChildBySource,\n     dyn_map::DynMap,\n     expr::{LabelId, PatId},\n@@ -96,7 +95,7 @@ use hir_def::{\n     GenericDefId, GenericParamId, ImplId, LifetimeParamId, MacroId, ModuleId, StaticId, StructId,\n     TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n-use hir_expand::{name::AsName, HirFileId, MacroCallId};\n+use hir_expand::{attrs::AttrId, name::AsName, HirFileId, MacroCallId};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use stdx::impl_from;"}, {"sha": "3b39e9fa919a1b4e943fb7f195709c5df270aa70", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -17,6 +17,7 @@ use hir_def::{\n         Body, BodySourceMap,\n     },\n     expr::{ExprId, Pat, PatId},\n+    lang_item::LangItem,\n     macro_id_to_def_id,\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n@@ -37,7 +38,7 @@ use hir_ty::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    method_resolution::{self, lang_names_for_bin_op},\n+    method_resolution::{self, lang_items_for_bin_op},\n     Adjustment, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind, TyLoweringContext,\n };\n use itertools::Itertools;\n@@ -294,12 +295,8 @@ impl SourceAnalyzer {\n             }\n         }\n \n-        let future_trait = db\n-            .lang_item(self.resolver.krate(), hir_expand::name![future_trait].to_smol_str())?\n-            .as_trait()?;\n-        let poll_fn = db\n-            .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n-            .as_function()?;\n+        let future_trait = db.lang_item(self.resolver.krate(), LangItem::Future)?.as_trait()?;\n+        let poll_fn = db.lang_item(self.resolver.krate(), LangItem::FuturePoll)?.as_function()?;\n         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n@@ -311,14 +308,14 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         prefix_expr: &ast::PrefixExpr,\n     ) -> Option<FunctionId> {\n-        let lang_item_name = match prefix_expr.op_kind()? {\n-            ast::UnaryOp::Deref => name![deref],\n-            ast::UnaryOp::Not => name![not],\n-            ast::UnaryOp::Neg => name![neg],\n+        let (lang_item, fn_name) = match prefix_expr.op_kind()? {\n+            ast::UnaryOp::Deref => (LangItem::Deref, name![deref]),\n+            ast::UnaryOp::Not => (LangItem::Not, name![not]),\n+            ast::UnaryOp::Neg => (LangItem::Neg, name![neg]),\n         };\n         let ty = self.ty_of_expr(db, &prefix_expr.expr()?)?;\n \n-        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, lang_item, &fn_name)?;\n         // HACK: subst for all methods coincides with that for their trait because the methods\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n@@ -334,9 +331,7 @@ impl SourceAnalyzer {\n         let base_ty = self.ty_of_expr(db, &index_expr.base()?)?;\n         let index_ty = self.ty_of_expr(db, &index_expr.index()?)?;\n \n-        let lang_item_name = name![index];\n-\n-        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, LangItem::Index, &name![index])?;\n         // HACK: subst for all methods coincides with that for their trait because the methods\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n@@ -355,8 +350,8 @@ impl SourceAnalyzer {\n         let lhs = self.ty_of_expr(db, &binop_expr.lhs()?)?;\n         let rhs = self.ty_of_expr(db, &binop_expr.rhs()?)?;\n \n-        let (op_trait, op_fn) = lang_names_for_bin_op(op)\n-            .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n+        let (op_trait, op_fn) = lang_items_for_bin_op(op)\n+            .and_then(|(name, lang_item)| self.lang_trait_fn(db, lang_item, &name))?;\n         // HACK: subst for `index()` coincides with that for `Index` because `index()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `index()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n@@ -374,8 +369,7 @@ impl SourceAnalyzer {\n     ) -> Option<FunctionId> {\n         let ty = self.ty_of_expr(db, &try_expr.expr()?)?;\n \n-        let op_fn =\n-            db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n+        let op_fn = db.lang_item(self.resolver.krate(), LangItem::TryTraitBranch)?.as_function()?;\n         let op_trait = match op_fn.lookup(db.upcast()).container {\n             ItemContainerId::TraitId(id) => id,\n             _ => return None,\n@@ -504,7 +498,7 @@ impl SourceAnalyzer {\n                         AssocItemId::ConstId(const_id) => {\n                             self.resolve_impl_const_or_trait_def(db, const_id, subs).into()\n                         }\n-                        _ => assoc,\n+                        assoc => assoc,\n                     };\n \n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n@@ -517,7 +511,13 @@ impl SourceAnalyzer {\n                 prefer_value_ns = true;\n             } else if let Some(path_pat) = parent().and_then(ast::PathPat::cast) {\n                 let pat_id = self.pat_id(&path_pat.into())?;\n-                if let Some((assoc, _)) = infer.assoc_resolutions_for_pat(pat_id) {\n+                if let Some((assoc, subs)) = infer.assoc_resolutions_for_pat(pat_id) {\n+                    let assoc = match assoc {\n+                        AssocItemId::ConstId(const_id) => {\n+                            self.resolve_impl_const_or_trait_def(db, const_id, subs).into()\n+                        }\n+                        assoc => assoc,\n+                    };\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n@@ -628,7 +628,7 @@ impl SourceAnalyzer {\n                                 {\n                                     return Some(PathResolution::DeriveHelper(DeriveHelper {\n                                         derive: *macro_id,\n-                                        idx,\n+                                        idx: idx as u32,\n                                     }));\n                                 }\n                             }\n@@ -815,10 +815,10 @@ impl SourceAnalyzer {\n     fn lang_trait_fn(\n         &self,\n         db: &dyn HirDatabase,\n-        lang_trait: &Name,\n+        lang_trait: LangItem,\n         method_name: &Name,\n     ) -> Option<(TraitId, FunctionId)> {\n-        let trait_id = db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?;\n+        let trait_id = db.lang_item(self.resolver.krate(), lang_trait)?.as_trait()?;\n         let fn_id = db.trait_data(trait_id).method_by_name(method_name)?;\n         Some((trait_id, fn_id))\n     }"}, {"sha": "3954abfdb7c43dad26f8eb51582610a1d2bc5d11", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"ide-assists\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -16,17 +18,20 @@ itertools = \"0.10.5\"\n either = \"1.7.0\"\n smallvec = \"1.10.0\"\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-ide-db = { path = \"../ide-db\", version = \"0.0.0\" }\n-hir = { path = \"../hir\", version = \"0.0.0\" }\n+# local deps\n+stdx.workspace = true\n+syntax.workspace = true\n+text-edit.workspace = true\n+profile.workspace = true\n+ide-db.workspace = true\n+hir.workspace = true\n \n [dev-dependencies]\n-test-utils = { path = \"../test-utils\" }\n-sourcegen = { path = \"../sourcegen\" }\n expect-test = \"1.4.0\"\n \n+# local deps\n+test-utils.workspace = true\n+sourcegen.workspace = true\n+\n [features]\n in-rust-tree = []"}, {"sha": "2f4a263ee07007230ac682ce85b340f2f6e38d3b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_braces.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_braces.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,155 @@\n+use syntax::{\n+    ast::{self, edit::AstNodeEdit, make},\n+    AstNode,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: add_braces\n+//\n+// Adds braces to lambda and match arm expressions.\n+//\n+// ```\n+// fn foo(n: i32) -> i32 {\n+//     match n {\n+//         1 =>$0 n + 1,\n+//         _ => 0\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo(n: i32) -> i32 {\n+//     match n {\n+//         1 => {\n+//             n + 1\n+//         },\n+//         _ => 0\n+//     }\n+// }\n+// ```\n+pub(crate) fn add_braces(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let (expr_type, expr) = get_replacement_node(ctx)?;\n+\n+    acc.add(\n+        AssistId(\"add_braces\", AssistKind::RefactorRewrite),\n+        match expr_type {\n+            ParentType::ClosureExpr => \"Add braces to closure body\",\n+            ParentType::MatchArmExpr => \"Add braces to arm expression\",\n+        },\n+        expr.syntax().text_range(),\n+        |builder| {\n+            let block_expr = AstNodeEdit::indent(\n+                &make::block_expr(None, Some(expr.clone())),\n+                AstNodeEdit::indent_level(&expr),\n+            );\n+\n+            builder.replace(expr.syntax().text_range(), block_expr.syntax().text());\n+        },\n+    )\n+}\n+\n+enum ParentType {\n+    MatchArmExpr,\n+    ClosureExpr,\n+}\n+\n+fn get_replacement_node(ctx: &AssistContext<'_>) -> Option<(ParentType, ast::Expr)> {\n+    if let Some(match_arm) = ctx.find_node_at_offset::<ast::MatchArm>() {\n+        let match_arm_expr = match_arm.expr()?;\n+\n+        if matches!(match_arm_expr, ast::Expr::BlockExpr(_)) {\n+            return None;\n+        }\n+\n+        return Some((ParentType::MatchArmExpr, match_arm_expr));\n+    } else if let Some(closure_expr) = ctx.find_node_at_offset::<ast::ClosureExpr>() {\n+        let body = closure_expr.body()?;\n+\n+        if matches!(body, ast::Expr::BlockExpr(_)) {\n+            return None;\n+        }\n+\n+        return Some((ParentType::ClosureExpr, body));\n+    }\n+\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn suggest_add_braces_for_closure() {\n+        check_assist(\n+            add_braces,\n+            r#\"\n+fn foo() {\n+    t(|n|$0 n + 100);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    t(|n| {\n+        n + 100\n+    });\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_assist_for_closures_with_braces() {\n+        check_assist_not_applicable(\n+            add_braces,\n+            r#\"\n+fn foo() {\n+    t(|n|$0 { n + 100 });\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn suggest_add_braces_for_match() {\n+        check_assist(\n+            add_braces,\n+            r#\"\n+fn foo() {\n+    match n {\n+        Some(n) $0=> 29,\n+        _ => ()\n+    };\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    match n {\n+        Some(n) => {\n+            29\n+        },\n+        _ => ()\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_assist_for_match_with_braces() {\n+        check_assist_not_applicable(\n+            add_braces,\n+            r#\"\n+fn foo() {\n+    match n {\n+        Some(n) $0=> { return 29; },\n+        _ => ()\n+    };\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "4e11b31deb02ba16aec968f3dbd04b6b52531343", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 84, "deletions": 8, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,7 +1,5 @@\n use hir::HasSource;\n-use ide_db::{\n-    syntax_helpers::insert_whitespace_into_node::insert_ws_into, traits::resolve_target_trait,\n-};\n+use ide_db::syntax_helpers::insert_whitespace_into_node::insert_ws_into;\n use syntax::ast::{self, make, AstNode};\n \n use crate::{\n@@ -107,16 +105,19 @@ fn add_missing_impl_members_inner(\n ) -> Option<()> {\n     let _p = profile::span(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n+    let impl_ = ctx.sema.to_def(&impl_def)?;\n \n     if ctx.token_at_offset().all(|t| {\n         t.parent_ancestors()\n+            .take_while(|node| node != impl_def.syntax())\n             .any(|s| ast::BlockExpr::can_cast(s.kind()) || ast::ParamList::can_cast(s.kind()))\n     }) {\n         return None;\n     }\n \n     let target_scope = ctx.sema.scope(impl_def.syntax())?;\n-    let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n+    let trait_ref = impl_.trait_ref(ctx.db())?;\n+    let trait_ = trait_ref.trait_();\n \n     let missing_items = filter_assoc_items(\n         &ctx.sema,\n@@ -155,7 +156,7 @@ fn add_missing_impl_members_inner(\n                 let placeholder;\n                 if let DefaultMethods::No = mode {\n                     if let ast::AssocItem::Fn(func) = &first_new_item {\n-                        if try_gen_trait_body(ctx, func, &trait_, &impl_def).is_none() {\n+                        if try_gen_trait_body(ctx, func, trait_ref, &impl_def).is_none() {\n                             if let Some(m) =\n                                 func.syntax().descendants().find_map(ast::MacroCall::cast)\n                             {\n@@ -180,13 +181,13 @@ fn add_missing_impl_members_inner(\n fn try_gen_trait_body(\n     ctx: &AssistContext<'_>,\n     func: &ast::Fn,\n-    trait_: &hir::Trait,\n+    trait_ref: hir::TraitRef,\n     impl_def: &ast::Impl,\n ) -> Option<()> {\n-    let trait_path = make::ext::ident_path(&trait_.name(ctx.db()).to_string());\n+    let trait_path = make::ext::ident_path(&trait_ref.trait_().name(ctx.db()).to_string());\n     let hir_ty = ctx.sema.resolve_type(&impl_def.self_ty()?)?;\n     let adt = hir_ty.as_adt()?.source(ctx.db())?;\n-    gen_trait_fn_body(func, &trait_path, &adt.value)\n+    gen_trait_fn_body(func, &trait_path, &adt.value, Some(trait_ref))\n }\n \n #[cfg(test)]\n@@ -1352,6 +1353,50 @@ impl PartialEq for SomeStruct {\n         );\n     }\n \n+    #[test]\n+    fn test_partial_eq_body_when_types_semantically_match() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+//- minicore: eq\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, T> {$0}\n+\"#,\n+            r#\"\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, T> {\n+    $0fn eq(&self, other: &Alias<T>) -> bool {\n+        self.0 == other.0 && self.1 == other.1\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_partial_eq_body_when_types_dont_match() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+//- minicore: eq\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, i32> {$0}\n+\"#,\n+            r#\"\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, i32> {\n+    fn eq(&self, other: &Alias<T>) -> bool {\n+        ${0:todo!()}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_ignore_function_body() {\n         check_assist_not_applicable(\n@@ -1442,4 +1487,35 @@ impl Trait for () {\n }\"#,\n         )\n     }\n+\n+    #[test]\n+    fn test_works_inside_function() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Tr {\n+    fn method();\n+}\n+fn main() {\n+    struct S;\n+    impl Tr for S {\n+        $0\n+    }\n+}\n+\"#,\n+            r#\"\n+trait Tr {\n+    fn method();\n+}\n+fn main() {\n+    struct S;\n+    impl Tr for S {\n+        fn method() {\n+        ${0:todo!()}\n+    }\n+    }\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "5d81e8cfeacbc644bd68ac09acff16780c437484", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 192, "deletions": 9, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -140,6 +140,31 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n             })\n             .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n         ((Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable(), is_non_exhaustive)\n+    } else if let Some((enum_def, len)) = resolve_array_of_enum_def(&ctx.sema, &expr) {\n+        let is_non_exhaustive = enum_def.is_non_exhaustive(ctx.db(), module.krate());\n+        let variants = enum_def.variants(ctx.db());\n+\n+        if len.pow(variants.len() as u32) > 256 {\n+            return None;\n+        }\n+\n+        let variants_of_enums = vec![variants.clone(); len];\n+\n+        let missing_pats = variants_of_enums\n+            .into_iter()\n+            .multi_cartesian_product()\n+            .inspect(|_| cov_mark::hit!(add_missing_match_arms_lazy_computation))\n+            .map(|variants| {\n+                let is_hidden = variants\n+                    .iter()\n+                    .any(|variant| variant.should_be_hidden(ctx.db(), module.krate()));\n+                let patterns = variants.into_iter().filter_map(|variant| {\n+                    build_pat(ctx.db(), module, variant.clone(), ctx.config.prefer_no_std)\n+                });\n+                (ast::Pat::from(make::slice_pat(patterns)), is_hidden)\n+            })\n+            .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n+        ((Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable(), is_non_exhaustive)\n     } else {\n         return None;\n     };\n@@ -266,9 +291,13 @@ fn is_variant_missing(existing_pats: &[Pat], var: &Pat) -> bool {\n fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n     match (pat, var) {\n         (Pat::WildcardPat(_), _) => true,\n+        (Pat::SlicePat(spat), Pat::SlicePat(svar)) => {\n+            spat.pats().zip(svar.pats()).all(|(p, v)| does_pat_match_variant(&p, &v))\n+        }\n         (Pat::TuplePat(tpat), Pat::TuplePat(tvar)) => {\n             tpat.fields().zip(tvar.fields()).all(|(p, v)| does_pat_match_variant(&p, &v))\n         }\n+        (Pat::OrPat(opat), _) => opat.pats().any(|p| does_pat_match_variant(&p, var)),\n         _ => utils::does_pat_match_variant(pat, var),\n     }\n }\n@@ -279,7 +308,7 @@ enum ExtendedEnum {\n     Enum(hir::Enum),\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n enum ExtendedVariant {\n     True,\n     False,\n@@ -339,15 +368,30 @@ fn resolve_tuple_of_enum_def(\n         .tuple_fields(sema.db)\n         .iter()\n         .map(|ty| {\n-            ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n-                Some(Adt::Enum(e)) => Some(lift_enum(e)),\n-                // For now we only handle expansion for a tuple of enums. Here\n-                // we map non-enum items to None and rely on `collect` to\n-                // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n-                _ => ty.is_bool().then_some(ExtendedEnum::Bool),\n+            ty.autoderef(sema.db).find_map(|ty| {\n+                match ty.as_adt() {\n+                    Some(Adt::Enum(e)) => Some(lift_enum(e)),\n+                    // For now we only handle expansion for a tuple of enums. Here\n+                    // we map non-enum items to None and rely on `collect` to\n+                    // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n+                    _ => ty.is_bool().then_some(ExtendedEnum::Bool),\n+                }\n             })\n         })\n-        .collect()\n+        .collect::<Option<Vec<ExtendedEnum>>>()\n+        .and_then(|list| if list.is_empty() { None } else { Some(list) })\n+}\n+\n+fn resolve_array_of_enum_def(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expr: &ast::Expr,\n+) -> Option<(ExtendedEnum, usize)> {\n+    sema.type_of_expr(expr)?.adjusted().as_array(sema.db).and_then(|(ty, len)| {\n+        ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n+            Some(Adt::Enum(e)) => Some((lift_enum(e), len)),\n+            _ => ty.is_bool().then_some((ExtendedEnum::Bool, len)),\n+        })\n+    })\n }\n \n fn build_pat(\n@@ -376,7 +420,6 @@ fn build_pat(\n                 }\n                 ast::StructKind::Unit => make::path_pat(path),\n             };\n-\n             Some(pat)\n         }\n         ExtendedVariant::True => Some(ast::Pat::from(make::literal_pat(\"true\"))),\n@@ -525,6 +568,19 @@ fn foo(a: bool) {\n             add_missing_match_arms,\n             r#\"\n fn foo(a: bool) {\n+    match (a, a)$0 {\n+        (true | false, true) => {}\n+        (true, false) => {}\n+        (false, false) => {}\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist_not_applicable(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n     match (a, a)$0 {\n         (true, true) => {}\n         (true, false) => {}\n@@ -559,12 +615,112 @@ fn foo(a: bool) {\n         )\n     }\n \n+    #[test]\n+    fn fill_boolean_array() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a]$0 {\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a] {\n+        $0[true] => todo!(),\n+        [false] => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a,]$0 {\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a,] {\n+        $0[true] => todo!(),\n+        [false] => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a]$0 {\n+        [true, true] => todo!(),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a] {\n+        [true, true] => todo!(),\n+        $0[true, false] => todo!(),\n+        [false, true] => todo!(),\n+        [false, false] => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a]$0 {\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a] {\n+        $0[true, true] => todo!(),\n+        [true, false] => todo!(),\n+        [false, true] => todo!(),\n+        [false, false] => todo!(),\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn partial_fill_boolean_tuple() {\n         check_assist(\n             add_missing_match_arms,\n             r#\"\n fn foo(a: bool) {\n+    match (a, a)$0 {\n+        (true | false, true) => {}\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match (a, a) {\n+        (true | false, true) => {}\n+        $0(true, false) => todo!(),\n+        (false, false) => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n     match (a, a)$0 {\n         (false, true) => {}\n     }\n@@ -882,6 +1038,33 @@ fn main() {\n }\n \"#,\n         );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+enum E { A, B, C }\n+fn main() {\n+    use E::*;\n+    match (A, B, C)$0 {\n+        (A | B , A, A | B | C) => (),\n+        (A | B | C , B | C, A | B | C) => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+enum E { A, B, C }\n+fn main() {\n+    use E::*;\n+    match (A, B, C) {\n+        (A | B , A, A | B | C) => (),\n+        (A | B | C , B | C, A | B | C) => (),\n+        $0(C, A, A) => todo!(),\n+        (C, A, B) => todo!(),\n+        (C, A, C) => todo!(),\n+    }\n+}\n+\"#,\n+        )\n     }\n \n     #[test]"}, {"sha": "1acd5ee97283fcefa57524e347ef62b3ae7d5053", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_comment_block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -107,7 +107,7 @@ fn line_to_block(acc: &mut Assists, comment: ast::Comment) -> Option<()> {\n /// The line -> block assist can  be invoked from anywhere within a sequence of line comments.\n /// relevant_line_comments crawls backwards and forwards finding the complete sequence of comments that will\n /// be joined.\n-fn relevant_line_comments(comment: &ast::Comment) -> Vec<Comment> {\n+pub(crate) fn relevant_line_comments(comment: &ast::Comment) -> Vec<Comment> {\n     // The prefix identifies the kind of comment we're dealing with\n     let prefix = comment.prefix();\n     let same_prefix = |c: &ast::Comment| c.prefix() == prefix;\n@@ -159,7 +159,7 @@ fn relevant_line_comments(comment: &ast::Comment) -> Vec<Comment> {\n //              */\n //\n // But since such comments aren't idiomatic we're okay with this.\n-fn line_comment_text(indentation: IndentLevel, comm: ast::Comment) -> String {\n+pub(crate) fn line_comment_text(indentation: IndentLevel, comm: ast::Comment) -> String {\n     let contents_without_prefix = comm.text().strip_prefix(comm.prefix()).unwrap();\n     let contents = contents_without_prefix.strip_prefix(' ').unwrap_or(contents_without_prefix);\n "}, {"sha": "65c2479e9f29bb8ba560bc05bf686f1bf40eae3e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 63, "deletions": 24, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -30,24 +30,23 @@ use crate::{\n // ```\n pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let let_stmt: ast::LetStmt = ctx.find_node_at_offset()?;\n-    let binding = find_binding(let_stmt.pat()?)?;\n+    let binding = let_stmt.pat()?;\n \n-    let initializer = match let_stmt.initializer() {\n-        Some(ast::Expr::MatchExpr(it)) => it,\n-        _ => return None,\n-    };\n+    let Some(ast::Expr::MatchExpr(initializer)) = let_stmt.initializer() else { return None };\n     let initializer_expr = initializer.expr()?;\n \n-    let (extracting_arm, diverging_arm) = match find_arms(ctx, &initializer) {\n-        Some(it) => it,\n-        None => return None,\n-    };\n+    let Some((extracting_arm, diverging_arm)) = find_arms(ctx, &initializer) else { return None };\n     if extracting_arm.guard().is_some() {\n         cov_mark::hit!(extracting_arm_has_guard);\n         return None;\n     }\n \n-    let diverging_arm_expr = diverging_arm.expr()?;\n+    let diverging_arm_expr = match diverging_arm.expr()? {\n+        ast::Expr::BlockExpr(block) if block.modifier().is_none() && block.label().is_none() => {\n+            block.to_string()\n+        }\n+        other => format!(\"{{ {other} }}\"),\n+    };\n     let extracting_arm_pat = extracting_arm.pat()?;\n     let extracted_variable = find_extracted_variable(ctx, &extracting_arm)?;\n \n@@ -56,24 +55,16 @@ pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'\n         \"Convert match to let-else\",\n         let_stmt.syntax().text_range(),\n         |builder| {\n-            let extracting_arm_pat = rename_variable(&extracting_arm_pat, extracted_variable, binding);\n+            let extracting_arm_pat =\n+                rename_variable(&extracting_arm_pat, extracted_variable, binding);\n             builder.replace(\n                 let_stmt.syntax().text_range(),\n-                format!(\"let {extracting_arm_pat} = {initializer_expr} else {{ {diverging_arm_expr} }};\")\n+                format!(\"let {extracting_arm_pat} = {initializer_expr} else {diverging_arm_expr};\"),\n             )\n         },\n     )\n }\n \n-// Given a pattern, find the name introduced to the surrounding scope.\n-fn find_binding(pat: ast::Pat) -> Option<ast::IdentPat> {\n-    if let ast::Pat::IdentPat(ident) = pat {\n-        Some(ident)\n-    } else {\n-        None\n-    }\n-}\n-\n // Given a match expression, find extracting and diverging arms.\n fn find_arms(\n     ctx: &AssistContext<'_>,\n@@ -87,7 +78,7 @@ fn find_arms(\n     let mut extracting = None;\n     let mut diverging = None;\n     for arm in arms {\n-        if ctx.sema.type_of_expr(&arm.expr().unwrap()).unwrap().original().is_never() {\n+        if ctx.sema.type_of_expr(&arm.expr()?)?.original().is_never() {\n             diverging = Some(arm);\n         } else {\n             extracting = Some(arm);\n@@ -124,7 +115,7 @@ fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Opti\n }\n \n // Rename `extracted` with `binding` in `pat`.\n-fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::IdentPat) -> SyntaxNode {\n+fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::Pat) -> SyntaxNode {\n     let syntax = pat.syntax().clone_for_update();\n     let extracted_syntax = syntax.covering_element(extracted.syntax().text_range());\n \n@@ -136,7 +127,7 @@ fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::IdentPat)\n         if let Some(name_ref) = record_pat_field.field_name() {\n             ted::replace(\n                 record_pat_field.syntax(),\n-                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding.into())\n+                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding)\n                     .syntax()\n                     .clone_for_update(),\n             );\n@@ -410,4 +401,52 @@ fn foo(opt: Option<i32>) -> Option<i32> {\n     \"#,\n         );\n     }\n+\n+    #[test]\n+    fn complex_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn f() {\n+    let (x, y) = $0match Some((0, 1)) {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let Some((x, y)) = Some((0, 1)) else { return };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn diverging_block() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn f() {\n+    let x = $0match Some(()) {\n+        Some(it) => it,\n+        None => {//comment\n+            println!(\"nope\");\n+            return\n+        },\n+    };\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let Some(x) = Some(()) else {//comment\n+            println!(\"nope\");\n+            return\n+        };\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "9dc1da2461a3415086b5c07d237dd58f41c2b4a3", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -52,10 +52,7 @@ pub(crate) fn convert_named_struct_to_tuple_struct(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n ) -> Option<()> {\n-    let strukt = ctx\n-        .find_node_at_offset::<ast::Struct>()\n-        .map(Either::Left)\n-        .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;\n+    let strukt = ctx.find_node_at_offset::<Either<ast::Struct, ast::Variant>>()?;\n     let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n     let record_fields = match field_list {\n         ast::FieldList::RecordFieldList(it) => it,"}, {"sha": "772e032fb29342aea0b9ed2e79472e4d1f84ff1b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -50,10 +50,7 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n ) -> Option<()> {\n-    let strukt = ctx\n-        .find_node_at_offset::<ast::Struct>()\n-        .map(Either::Left)\n-        .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;\n+    let strukt = ctx.find_node_at_offset::<Either<ast::Struct, ast::Variant>>()?;\n     let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n     let tuple_fields = match field_list {\n         ast::FieldList::TupleFieldList(it) => it,"}, {"sha": "226a5dd9fa8b7c09b1eddff4d500c10cb34d3e74", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/desugar_doc_comment.rs", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdesugar_doc_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdesugar_doc_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdesugar_doc_comment.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,312 @@\n+use either::Either;\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, edit::IndentLevel, CommentPlacement, Whitespace},\n+    AstToken, TextRange,\n+};\n+\n+use crate::{\n+    handlers::convert_comment_block::{line_comment_text, relevant_line_comments},\n+    utils::required_hashes,\n+    AssistContext, AssistId, AssistKind, Assists,\n+};\n+\n+// Assist: desugar_doc_comment\n+//\n+// Desugars doc-comments to the attribute form.\n+//\n+// ```\n+// /// Multi-line$0\n+// /// comment\n+// ```\n+// ->\n+// ```\n+// #[doc = r\"Multi-line\n+// comment\"]\n+// ```\n+pub(crate) fn desugar_doc_comment(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let comment = ctx.find_token_at_offset::<ast::Comment>()?;\n+    // Only allow doc comments\n+    let Some(placement) = comment.kind().doc else { return None; };\n+\n+    // Only allow comments which are alone on their line\n+    if let Some(prev) = comment.syntax().prev_token() {\n+        if Whitespace::cast(prev).filter(|w| w.text().contains('\\n')).is_none() {\n+            return None;\n+        }\n+    }\n+\n+    let indentation = IndentLevel::from_token(comment.syntax()).to_string();\n+\n+    let (target, comments) = match comment.kind().shape {\n+        ast::CommentShape::Block => (comment.syntax().text_range(), Either::Left(comment)),\n+        ast::CommentShape::Line => {\n+            // Find all the comments we'll be desugaring\n+            let comments = relevant_line_comments(&comment);\n+\n+            // Establish the target of our edit based on the comments we found\n+            (\n+                TextRange::new(\n+                    comments[0].syntax().text_range().start(),\n+                    comments.last().unwrap().syntax().text_range().end(),\n+                ),\n+                Either::Right(comments),\n+            )\n+        }\n+    };\n+\n+    acc.add(\n+        AssistId(\"desugar_doc_comment\", AssistKind::RefactorRewrite),\n+        \"Desugar doc-comment to attribute macro\",\n+        target,\n+        |edit| {\n+            let text = match comments {\n+                Either::Left(comment) => {\n+                    let text = comment.text();\n+                    text[comment.prefix().len()..(text.len() - \"*/\".len())]\n+                        .trim()\n+                        .lines()\n+                        .map(|l| l.strip_prefix(&indentation).unwrap_or(l))\n+                        .join(\"\\n\")\n+                }\n+                Either::Right(comments) => {\n+                    comments.into_iter().map(|c| line_comment_text(IndentLevel(0), c)).join(\"\\n\")\n+                }\n+            };\n+\n+            let hashes = \"#\".repeat(required_hashes(&text));\n+\n+            let prefix = match placement {\n+                CommentPlacement::Inner => \"#!\",\n+                CommentPlacement::Outer => \"#\",\n+            };\n+\n+            let output = format!(r#\"{prefix}[doc = r{hashes}\"{text}\"{hashes}]\"#);\n+\n+            edit.replace(target, output)\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn single_line() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+/// line$0 comment\n+fn main() {\n+    foo();\n+}\n+\"#,\n+            r#\"\n+#[doc = r\"line comment\"]\n+fn main() {\n+    foo();\n+}\n+\"#,\n+        );\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+//! line$0 comment\n+fn main() {\n+    foo();\n+}\n+\"#,\n+            r#\"\n+#![doc = r\"line comment\"]\n+fn main() {\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn single_line_indented() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+fn main() {\n+    /// line$0 comment\n+    struct Foo;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    #[doc = r\"line comment\"]\n+    struct Foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn multiline() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+fn main() {\n+    /// above\n+    /// line$0 comment\n+    ///\n+    /// below\n+    struct Foo;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    #[doc = r\"above\n+line comment\n+\n+below\"]\n+    struct Foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn end_of_line() {\n+        check_assist_not_applicable(\n+            desugar_doc_comment,\n+            r#\"\n+fn main() { /// end-of-line$0 comment\n+    struct Foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn single_line_different_kinds() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+fn main() {\n+    //! different prefix\n+    /// line$0 comment\n+    /// below\n+    struct Foo;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    //! different prefix\n+    #[doc = r\"line comment\n+below\"]\n+    struct Foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn single_line_separate_chunks() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+/// different chunk\n+\n+/// line$0 comment\n+/// below\n+\"#,\n+            r#\"\n+/// different chunk\n+\n+#[doc = r\"line comment\n+below\"]\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn block_comment() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+/**\n+ hi$0 there\n+*/\n+\"#,\n+            r#\"\n+#[doc = r\"hi there\"]\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inner_doc_block() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+/*!\n+ hi$0 there\n+*/\n+\"#,\n+            r#\"\n+#![doc = r\"hi there\"]\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn block_indent() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r#\"\n+fn main() {\n+    /*!\n+    hi$0 there\n+\n+    ```\n+      code_sample\n+    ```\n+    */\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    #![doc = r\"hi there\n+\n+```\n+  code_sample\n+```\"]\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn end_of_line_block() {\n+        check_assist_not_applicable(\n+            desugar_doc_comment,\n+            r#\"\n+fn main() {\n+    foo(); /** end-of-line$0 comment */\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn regular_comment() {\n+        check_assist_not_applicable(desugar_doc_comment, r#\"// some$0 comment\"#);\n+        check_assist_not_applicable(desugar_doc_comment, r#\"/* some$0 comment*/\"#);\n+    }\n+\n+    #[test]\n+    fn quotes_and_escapes() {\n+        check_assist(\n+            desugar_doc_comment,\n+            r###\"/// some$0 \"\\ \"## comment\"###,\n+            r####\"#[doc = r###\"some \"\\ \"## comment\"###]\"####,\n+        );\n+    }\n+}"}, {"sha": "b310c2db9fab09bf273f0a5394723beab9e3d373", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,9 +1,6 @@\n use either::Either;\n use ide_db::syntax_helpers::node_ext::walk_ty;\n-use syntax::{\n-    ast::{self, edit::IndentLevel, make, AstNode, HasGenericParams, HasName},\n-    match_ast,\n-};\n+use syntax::ast::{self, edit::IndentLevel, make, AstNode, HasGenericParams, HasName};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -31,15 +28,8 @@ pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n \n     let ty = ctx.find_node_at_range::<ast::Type>()?;\n     let item = ty.syntax().ancestors().find_map(ast::Item::cast)?;\n-    let assoc_owner = item.syntax().ancestors().nth(2).and_then(|it| {\n-        match_ast! {\n-            match it {\n-                ast::Trait(tr) => Some(Either::Left(tr)),\n-                ast::Impl(impl_) => Some(Either::Right(impl_)),\n-                _ => None,\n-            }\n-        }\n-    });\n+    let assoc_owner =\n+        item.syntax().ancestors().nth(2).and_then(Either::<ast::Trait, ast::Impl>::cast);\n     let node = assoc_owner.as_ref().map_or_else(\n         || item.syntax(),\n         |impl_| impl_.as_ref().either(AstNode::syntax, AstNode::syntax),\n@@ -161,19 +151,17 @@ fn collect_used_generics<'gp>(\n                     .and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n             ),\n             ast::Type::ArrayType(ar) => {\n-                if let Some(expr) = ar.expr() {\n-                    if let ast::Expr::PathExpr(p) = expr {\n-                        if let Some(path) = p.path() {\n-                            if let Some(name_ref) = path.as_single_name_ref() {\n-                                if let Some(param) = known_generics.iter().find(|gp| {\n-                                    if let ast::GenericParam::ConstParam(cp) = gp {\n-                                        cp.name().map_or(false, |n| n.text() == name_ref.text())\n-                                    } else {\n-                                        false\n-                                    }\n-                                }) {\n-                                    generics.push(param);\n+                if let Some(ast::Expr::PathExpr(p)) = ar.expr() {\n+                    if let Some(path) = p.path() {\n+                        if let Some(name_ref) = path.as_single_name_ref() {\n+                            if let Some(param) = known_generics.iter().find(|gp| {\n+                                if let ast::GenericParam::ConstParam(cp) = gp {\n+                                    cp.name().map_or(false, |n| n.text() == name_ref.text())\n+                                } else {\n+                                    false\n                                 }\n+                            }) {\n+                                generics.push(param);\n                             }\n                         }\n                     }"}, {"sha": "860372941f7948d2709ca0cd78591ac54c86fae9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_default_from_new.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -82,18 +82,18 @@ fn generate_trait_impl_text_from_impl(impl_: &ast::Impl, trait_text: &str, code:\n     let generic_params = impl_.generic_param_list().map(|generic_params| {\n         let lifetime_params =\n             generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);\n-        let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {\n+        let ty_or_const_params = generic_params.type_or_const_params().map(|param| {\n             // remove defaults since they can't be specified in impls\n             match param {\n                 ast::TypeOrConstParam::Type(param) => {\n                     let param = param.clone_for_update();\n                     param.remove_default();\n-                    Some(ast::GenericParam::TypeParam(param))\n+                    ast::GenericParam::TypeParam(param)\n                 }\n                 ast::TypeOrConstParam::Const(param) => {\n                     let param = param.clone_for_update();\n                     param.remove_default();\n-                    Some(ast::GenericParam::ConstParam(param))\n+                    ast::GenericParam::ConstParam(param)\n                 }\n             }\n         });"}, {"sha": "ed1b8f4e28d304eb4a62edde2bb5f0c910227b03", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -109,7 +109,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                 let tail_expr_finished =\n                     if is_async { make::expr_await(tail_expr) } else { tail_expr };\n                 let body = make::block_expr([], Some(tail_expr_finished));\n-                let f = make::fn_(vis, name, type_params, params, body, ret_type, is_async)\n+                let f = make::fn_(vis, name, type_params, None, params, body, ret_type, is_async)\n                     .indent(ast::edit::IndentLevel(1))\n                     .clone_for_update();\n "}, {"sha": "45b27a63ce26d43b7c60ebf5cc0601bec415147a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 854, "deletions": 47, "changes": 901, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,23 +1,25 @@\n-use hir::{Adt, HasSource, HirDisplay, Module, Semantics, TypeInfo};\n+use hir::{\n+    Adt, AsAssocItem, HasSource, HirDisplay, Module, PathResolution, Semantics, Type, TypeInfo,\n+};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameRefClass},\n     famous_defs::FamousDefs,\n+    path_transform::PathTransform,\n     FxHashMap, FxHashSet, RootDatabase, SnippetCap,\n };\n use stdx::to_lower_snake_case;\n use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        make, AstNode, CallExpr, HasArgList, HasModuleItem,\n+        make, AstNode, CallExpr, HasArgList, HasGenericParams, HasModuleItem, HasTypeBounds,\n     },\n     SyntaxKind, SyntaxNode, TextRange, TextSize,\n };\n \n use crate::{\n-    utils::convert_reference_type,\n-    utils::{find_struct_impl, render_snippet, Cursor},\n+    utils::{convert_reference_type, find_struct_impl, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n@@ -107,7 +109,7 @@ fn fn_target_info(\n     match path.qualifier() {\n         Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n             Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => {\n-                get_fn_target_info(ctx, &Some(module), call.clone())\n+                get_fn_target_info(ctx, Some(module), call.clone())\n             }\n             Some(hir::PathResolution::Def(hir::ModuleDef::Adt(adt))) => {\n                 if let hir::Adt::Enum(_) = adt {\n@@ -125,7 +127,7 @@ fn fn_target_info(\n             }\n             _ => None,\n         },\n-        _ => get_fn_target_info(ctx, &None, call.clone()),\n+        _ => get_fn_target_info(ctx, None, call.clone()),\n     }\n }\n \n@@ -136,7 +138,8 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     }\n \n     let fn_name = call.name_ref()?;\n-    let adt = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references().as_adt()?;\n+    let receiver_ty = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references();\n+    let adt = receiver_ty.as_adt()?;\n \n     let current_module = ctx.sema.scope(call.syntax())?.module();\n     let target_module = adt.module(ctx.sema.db);\n@@ -147,8 +150,14 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n     let (target, insert_offset) = get_method_target(ctx, &impl_, &adt)?;\n \n-    let function_builder =\n-        FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n+    let function_builder = FunctionBuilder::from_method_call(\n+        ctx,\n+        &call,\n+        &fn_name,\n+        receiver_ty,\n+        target_module,\n+        target,\n+    )?;\n     let text_range = call.syntax().text_range();\n     let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n     let label = format!(\"Generate {} method\", function_builder.fn_name);\n@@ -179,6 +188,7 @@ fn add_func_to_accumulator(\n         let function_template = function_builder.render(adt_name.is_some());\n         let mut func = function_template.to_string(ctx.config.snippet_cap);\n         if let Some(name) = adt_name {\n+            // FIXME: adt may have generic params.\n             func = format!(\"\\n{indent}impl {name} {{\\n{func}\\n{indent}}}\");\n         }\n         builder.edit_file(file);\n@@ -238,7 +248,8 @@ impl FunctionTemplate {\n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n-    type_params: Option<ast::GenericParamList>,\n+    generic_param_list: Option<ast::GenericParamList>,\n+    where_clause: Option<ast::WhereClause>,\n     params: ast::ParamList,\n     ret_type: Option<ast::RetType>,\n     should_focus_return_type: bool,\n@@ -260,19 +271,32 @@ impl FunctionBuilder {\n         let target_module =\n             target_module.or_else(|| ctx.sema.scope(target.syntax()).map(|it| it.module()))?;\n         let fn_name = make::name(fn_name);\n-        let (type_params, params) =\n-            fn_args(ctx, target_module, ast::CallableExpr::Call(call.clone()))?;\n+        let mut necessary_generic_params = FxHashSet::default();\n+        let params = fn_args(\n+            ctx,\n+            target_module,\n+            ast::CallableExpr::Call(call.clone()),\n+            &mut necessary_generic_params,\n+        )?;\n \n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        let (ret_type, should_focus_return_type) =\n-            make_return_type(ctx, &ast::Expr::CallExpr(call.clone()), target_module);\n+        let (ret_type, should_focus_return_type) = make_return_type(\n+            ctx,\n+            &ast::Expr::CallExpr(call.clone()),\n+            target_module,\n+            &mut necessary_generic_params,\n+        );\n+\n+        let (generic_param_list, where_clause) =\n+            fn_generic_params(ctx, necessary_generic_params, &target)?;\n \n         Some(Self {\n             target,\n             fn_name,\n-            type_params,\n+            generic_param_list,\n+            where_clause,\n             params,\n             ret_type,\n             should_focus_return_type,\n@@ -285,25 +309,40 @@ impl FunctionBuilder {\n         ctx: &AssistContext<'_>,\n         call: &ast::MethodCallExpr,\n         name: &ast::NameRef,\n+        receiver_ty: Type,\n         target_module: Module,\n         target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n         let needs_pub =\n             !module_is_descendant(&ctx.sema.scope(call.syntax())?.module(), &target_module, ctx);\n         let fn_name = make::name(&name.text());\n-        let (type_params, params) =\n-            fn_args(ctx, target_module, ast::CallableExpr::MethodCall(call.clone()))?;\n+        let mut necessary_generic_params = FxHashSet::default();\n+        necessary_generic_params.extend(receiver_ty.generic_params(ctx.db()));\n+        let params = fn_args(\n+            ctx,\n+            target_module,\n+            ast::CallableExpr::MethodCall(call.clone()),\n+            &mut necessary_generic_params,\n+        )?;\n \n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        let (ret_type, should_focus_return_type) =\n-            make_return_type(ctx, &ast::Expr::MethodCallExpr(call.clone()), target_module);\n+        let (ret_type, should_focus_return_type) = make_return_type(\n+            ctx,\n+            &ast::Expr::MethodCallExpr(call.clone()),\n+            target_module,\n+            &mut necessary_generic_params,\n+        );\n+\n+        let (generic_param_list, where_clause) =\n+            fn_generic_params(ctx, necessary_generic_params, &target)?;\n \n         Some(Self {\n             target,\n             fn_name,\n-            type_params,\n+            generic_param_list,\n+            where_clause,\n             params,\n             ret_type,\n             should_focus_return_type,\n@@ -319,7 +358,8 @@ impl FunctionBuilder {\n         let mut fn_def = make::fn_(\n             visibility,\n             self.fn_name,\n-            self.type_params,\n+            self.generic_param_list,\n+            self.where_clause,\n             self.params,\n             fn_body,\n             self.ret_type,\n@@ -375,13 +415,15 @@ fn make_return_type(\n     ctx: &AssistContext<'_>,\n     call: &ast::Expr,\n     target_module: Module,\n+    necessary_generic_params: &mut FxHashSet<hir::GenericParam>,\n ) -> (Option<ast::RetType>, bool) {\n     let (ret_ty, should_focus_return_type) = {\n         match ctx.sema.type_of_expr(call).map(TypeInfo::original) {\n             Some(ty) if ty.is_unknown() => (Some(make::ty_placeholder()), true),\n             None => (Some(make::ty_placeholder()), true),\n             Some(ty) if ty.is_unit() => (None, false),\n             Some(ty) => {\n+                necessary_generic_params.extend(ty.generic_params(ctx.db()));\n                 let rendered = ty.display_source_code(ctx.db(), target_module.into());\n                 match rendered {\n                     Ok(rendered) => (Some(make::ty(&rendered)), false),\n@@ -396,16 +438,16 @@ fn make_return_type(\n \n fn get_fn_target_info(\n     ctx: &AssistContext<'_>,\n-    target_module: &Option<Module>,\n+    target_module: Option<Module>,\n     call: CallExpr,\n ) -> Option<TargetInfo> {\n     let (target, file, insert_offset) = get_fn_target(ctx, target_module, call)?;\n-    Some(TargetInfo::new(*target_module, None, target, file, insert_offset))\n+    Some(TargetInfo::new(target_module, None, target, file, insert_offset))\n }\n \n fn get_fn_target(\n     ctx: &AssistContext<'_>,\n-    target_module: &Option<Module>,\n+    target_module: Option<Module>,\n     call: CallExpr,\n ) -> Option<(GeneratedFunctionTarget, FileId, TextSize)> {\n     let mut file = ctx.file_id();\n@@ -473,37 +515,386 @@ impl GeneratedFunctionTarget {\n             GeneratedFunctionTarget::InEmptyItemList(it) => it,\n         }\n     }\n+\n+    fn parent(&self) -> SyntaxNode {\n+        match self {\n+            GeneratedFunctionTarget::BehindItem(it) => it.parent().expect(\"item without parent\"),\n+            GeneratedFunctionTarget::InEmptyItemList(it) => it.clone(),\n+        }\n+    }\n }\n \n-/// Computes the type variables and arguments required for the generated function\n+/// Computes parameter list for the generated function.\n fn fn_args(\n     ctx: &AssistContext<'_>,\n     target_module: hir::Module,\n     call: ast::CallableExpr,\n-) -> Option<(Option<ast::GenericParamList>, ast::ParamList)> {\n+    necessary_generic_params: &mut FxHashSet<hir::GenericParam>,\n+) -> Option<ast::ParamList> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n         arg_names.push(fn_arg_name(&ctx.sema, &arg));\n-        arg_types.push(fn_arg_type(ctx, target_module, &arg));\n+        arg_types.push(fn_arg_type(ctx, target_module, &arg, necessary_generic_params));\n     }\n     deduplicate_arg_names(&mut arg_names);\n     let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n         make::param(make::ext::simple_ident_pat(make::name(&name)).into(), make::ty(&ty))\n     });\n \n-    Some((\n-        None,\n-        make::param_list(\n-            match call {\n-                ast::CallableExpr::Call(_) => None,\n-                ast::CallableExpr::MethodCall(_) => Some(make::self_param()),\n-            },\n-            params,\n-        ),\n+    Some(make::param_list(\n+        match call {\n+            ast::CallableExpr::Call(_) => None,\n+            ast::CallableExpr::MethodCall(_) => Some(make::self_param()),\n+        },\n+        params,\n     ))\n }\n \n+/// Gets parameter bounds and where predicates in scope and filters out irrelevant ones. Returns\n+/// `None` when it fails to get scope information.\n+///\n+/// See comment on `filter_unnecessary_bounds()` for what bounds we consider relevant.\n+///\n+/// NOTE: Generic parameters returned from this function may cause name clash at `target`. We don't\n+/// currently do anything about it because it's actually easy to resolve it after the assist: just\n+/// use the Rename functionality.\n+fn fn_generic_params(\n+    ctx: &AssistContext<'_>,\n+    necessary_params: FxHashSet<hir::GenericParam>,\n+    target: &GeneratedFunctionTarget,\n+) -> Option<(Option<ast::GenericParamList>, Option<ast::WhereClause>)> {\n+    if necessary_params.is_empty() {\n+        // Not really needed but fast path.\n+        return Some((None, None));\n+    }\n+\n+    // 1. Get generic parameters (with bounds) and where predicates in scope.\n+    let (generic_params, where_preds) = params_and_where_preds_in_scope(ctx);\n+\n+    // 2. Extract type parameters included in each bound.\n+    let mut generic_params = generic_params\n+        .into_iter()\n+        .filter_map(|it| compute_contained_params_in_generic_param(ctx, it))\n+        .collect();\n+    let mut where_preds = where_preds\n+        .into_iter()\n+        .filter_map(|it| compute_contained_params_in_where_pred(ctx, it))\n+        .collect();\n+\n+    // 3. Filter out unnecessary bounds.\n+    filter_unnecessary_bounds(&mut generic_params, &mut where_preds, necessary_params);\n+    filter_bounds_in_scope(&mut generic_params, &mut where_preds, ctx, target);\n+\n+    let generic_params: Vec<_> =\n+        generic_params.into_iter().map(|it| it.node.clone_for_update()).collect();\n+    let where_preds: Vec<_> =\n+        where_preds.into_iter().map(|it| it.node.clone_for_update()).collect();\n+\n+    // 4. Rewrite paths\n+    if let Some(param) = generic_params.first() {\n+        let source_scope = ctx.sema.scope(param.syntax())?;\n+        let target_scope = ctx.sema.scope(&target.parent())?;\n+        if source_scope.module() != target_scope.module() {\n+            let transform = PathTransform::generic_transformation(&target_scope, &source_scope);\n+            let generic_params = generic_params.iter().map(|it| it.syntax());\n+            let where_preds = where_preds.iter().map(|it| it.syntax());\n+            transform.apply_all(generic_params.chain(where_preds));\n+        }\n+    }\n+\n+    let generic_param_list = make::generic_param_list(generic_params);\n+    let where_clause =\n+        if where_preds.is_empty() { None } else { Some(make::where_clause(where_preds)) };\n+\n+    Some((Some(generic_param_list), where_clause))\n+}\n+\n+fn params_and_where_preds_in_scope(\n+    ctx: &AssistContext<'_>,\n+) -> (Vec<ast::GenericParam>, Vec<ast::WherePred>) {\n+    let Some(body) = containing_body(ctx) else { return Default::default(); };\n+\n+    let mut generic_params = Vec::new();\n+    let mut where_clauses = Vec::new();\n+\n+    // There are two items where generic parameters currently in scope may be declared: the item\n+    // the cursor is at, and its parent (if any).\n+    //\n+    // We handle parent first so that their generic parameters appear first in the generic\n+    // parameter list of the function we're generating.\n+    let db = ctx.db();\n+    if let Some(parent) = body.as_assoc_item(db).map(|it| it.container(db)) {\n+        match parent {\n+            hir::AssocItemContainer::Impl(it) => {\n+                let (params, clauses) = get_bounds_in_scope(ctx, it);\n+                generic_params.extend(params);\n+                where_clauses.extend(clauses);\n+            }\n+            hir::AssocItemContainer::Trait(it) => {\n+                let (params, clauses) = get_bounds_in_scope(ctx, it);\n+                generic_params.extend(params);\n+                where_clauses.extend(clauses);\n+            }\n+        }\n+    }\n+\n+    // Other defs with body may inherit generic parameters from its parent, but never have their\n+    // own generic parameters.\n+    if let hir::DefWithBody::Function(it) = body {\n+        let (params, clauses) = get_bounds_in_scope(ctx, it);\n+        generic_params.extend(params);\n+        where_clauses.extend(clauses);\n+    }\n+\n+    (generic_params, where_clauses)\n+}\n+\n+fn containing_body(ctx: &AssistContext<'_>) -> Option<hir::DefWithBody> {\n+    let item: ast::Item = ctx.find_node_at_offset()?;\n+    let def = match item {\n+        ast::Item::Fn(it) => ctx.sema.to_def(&it)?.into(),\n+        ast::Item::Const(it) => ctx.sema.to_def(&it)?.into(),\n+        ast::Item::Static(it) => ctx.sema.to_def(&it)?.into(),\n+        _ => return None,\n+    };\n+    Some(def)\n+}\n+\n+fn get_bounds_in_scope<D>(\n+    ctx: &AssistContext<'_>,\n+    def: D,\n+) -> (impl Iterator<Item = ast::GenericParam>, impl Iterator<Item = ast::WherePred>)\n+where\n+    D: HasSource,\n+    D::Ast: HasGenericParams,\n+{\n+    // This function should be only called with `Impl`, `Trait`, or `Function`, for which it's\n+    // infallible to get source ast.\n+    let node = ctx.sema.source(def).unwrap().value;\n+    let generic_params = node.generic_param_list().into_iter().flat_map(|it| it.generic_params());\n+    let where_clauses = node.where_clause().into_iter().flat_map(|it| it.predicates());\n+    (generic_params, where_clauses)\n+}\n+\n+#[derive(Debug)]\n+struct ParamBoundWithParams {\n+    node: ast::GenericParam,\n+    /// Generic parameter `node` introduces.\n+    ///\n+    /// ```text\n+    /// impl<T> S<T> {\n+    ///     fn f<U: Trait<T>>() {}\n+    ///          ^ this\n+    /// }\n+    /// ```\n+    ///\n+    /// `U` in this example.\n+    self_ty_param: hir::GenericParam,\n+    /// Generic parameters contained in the trait reference of this bound.\n+    ///\n+    /// ```text\n+    /// impl<T> S<T> {\n+    ///     fn f<U: Trait<T>>() {}\n+    ///             ^^^^^^^^ params in this part\n+    /// }\n+    /// ```\n+    ///\n+    /// `T` in this example.\n+    other_params: FxHashSet<hir::GenericParam>,\n+}\n+\n+#[derive(Debug)]\n+struct WherePredWithParams {\n+    node: ast::WherePred,\n+    /// Generic parameters contained in the \"self type\" of this where predicate.\n+    ///\n+    /// ```text\n+    /// Struct<T, U>: Trait<T, Assoc = V>,\n+    /// ^^^^^^^^^^^^ params in this part\n+    /// ```\n+    ///\n+    /// `T` and `U` in this example.\n+    self_ty_params: FxHashSet<hir::GenericParam>,\n+    /// Generic parameters contained in the trait reference of this where predicate.\n+    ///\n+    /// ```text\n+    /// Struct<T, U>: Trait<T, Assoc = V>,\n+    ///               ^^^^^^^^^^^^^^^^^^^ params in this part\n+    /// ```\n+    ///\n+    /// `T` and `V` in this example.\n+    other_params: FxHashSet<hir::GenericParam>,\n+}\n+\n+fn compute_contained_params_in_generic_param(\n+    ctx: &AssistContext<'_>,\n+    node: ast::GenericParam,\n+) -> Option<ParamBoundWithParams> {\n+    match &node {\n+        ast::GenericParam::TypeParam(ty) => {\n+            let self_ty_param = ctx.sema.to_def(ty)?.into();\n+\n+            let other_params = ty\n+                .type_bound_list()\n+                .into_iter()\n+                .flat_map(|it| it.bounds())\n+                .flat_map(|bound| bound.syntax().descendants())\n+                .filter_map(|node| filter_generic_params(ctx, node))\n+                .collect();\n+\n+            Some(ParamBoundWithParams { node, self_ty_param, other_params })\n+        }\n+        ast::GenericParam::ConstParam(ct) => {\n+            let self_ty_param = ctx.sema.to_def(ct)?.into();\n+            Some(ParamBoundWithParams { node, self_ty_param, other_params: FxHashSet::default() })\n+        }\n+        ast::GenericParam::LifetimeParam(_) => {\n+            // FIXME: It might be a good idea to handle lifetime parameters too.\n+            None\n+        }\n+    }\n+}\n+\n+fn compute_contained_params_in_where_pred(\n+    ctx: &AssistContext<'_>,\n+    node: ast::WherePred,\n+) -> Option<WherePredWithParams> {\n+    let self_ty = node.ty()?;\n+    let bound_list = node.type_bound_list()?;\n+\n+    let self_ty_params = self_ty\n+        .syntax()\n+        .descendants()\n+        .filter_map(|node| filter_generic_params(ctx, node))\n+        .collect();\n+\n+    let other_params = bound_list\n+        .bounds()\n+        .flat_map(|bound| bound.syntax().descendants())\n+        .filter_map(|node| filter_generic_params(ctx, node))\n+        .collect();\n+\n+    Some(WherePredWithParams { node, self_ty_params, other_params })\n+}\n+\n+fn filter_generic_params(ctx: &AssistContext<'_>, node: SyntaxNode) -> Option<hir::GenericParam> {\n+    let path = ast::Path::cast(node)?;\n+    match ctx.sema.resolve_path(&path)? {\n+        PathResolution::TypeParam(it) => Some(it.into()),\n+        PathResolution::ConstParam(it) => Some(it.into()),\n+        _ => None,\n+    }\n+}\n+\n+/// Filters out irrelevant bounds from `generic_params` and `where_preds`.\n+///\n+/// Say we have a trait bound `Struct<T>: Trait<U>`. Given `necessary_params`, when is it relevant\n+/// and when not? Some observations:\n+/// - When `necessary_params` contains `T`, it's likely that we want this bound, but now we have\n+/// an extra param to consider: `U`.\n+/// - On the other hand, when `necessary_params` contains `U` (but not `T`), then it's unlikely\n+/// that we want this bound because it doesn't really constrain `U`.\n+///\n+/// (FIXME?: The latter clause might be overstating. We may want to include the bound if the self\n+/// type does *not* include generic params at all - like `Option<i32>: From<U>`)\n+///\n+/// Can we make this a bit more formal? Let's define \"dependency\" between generic parameters and\n+/// trait bounds:\n+/// - A generic parameter `T` depends on a trait bound if `T` appears in the self type (i.e. left\n+/// part) of the bound.\n+/// - A trait bound depends on a generic parameter `T` if `T` appears in the bound.\n+///\n+/// Using the notion, what we want is all the bounds that params in `necessary_params`\n+/// *transitively* depend on!\n+///\n+/// Now it's not hard to solve: we build a dependency graph and compute all reachable nodes from\n+/// nodes that represent params in `necessary_params` by usual and boring DFS.\n+///\n+/// The time complexity is O(|generic_params| + |where_preds| + |necessary_params|).\n+fn filter_unnecessary_bounds(\n+    generic_params: &mut Vec<ParamBoundWithParams>,\n+    where_preds: &mut Vec<WherePredWithParams>,\n+    necessary_params: FxHashSet<hir::GenericParam>,\n+) {\n+    // All `self_ty_param` should be unique as they were collected from `ast::GenericParamList`s.\n+    let param_map: FxHashMap<hir::GenericParam, usize> =\n+        generic_params.iter().map(|it| it.self_ty_param).zip(0..).collect();\n+    let param_count = param_map.len();\n+    let generic_params_upper_bound = param_count + generic_params.len();\n+    let node_count = generic_params_upper_bound + where_preds.len();\n+\n+    // | node index range                        | what the node represents |\n+    // |-----------------------------------------|--------------------------|\n+    // | 0..param_count                          | generic parameter        |\n+    // | param_count..generic_params_upper_bound | `ast::GenericParam`      |\n+    // | generic_params_upper_bound..node_count  | `ast::WherePred`         |\n+    let mut graph = Graph::new(node_count);\n+    for (pred, pred_idx) in generic_params.iter().zip(param_count..) {\n+        let param_idx = param_map[&pred.self_ty_param];\n+        graph.add_edge(param_idx, pred_idx);\n+        graph.add_edge(pred_idx, param_idx);\n+\n+        for param in &pred.other_params {\n+            let param_idx = param_map[param];\n+            graph.add_edge(pred_idx, param_idx);\n+        }\n+    }\n+    for (pred, pred_idx) in where_preds.iter().zip(generic_params_upper_bound..) {\n+        for param in &pred.self_ty_params {\n+            let param_idx = param_map[param];\n+            graph.add_edge(param_idx, pred_idx);\n+            graph.add_edge(pred_idx, param_idx);\n+        }\n+        for param in &pred.other_params {\n+            let param_idx = param_map[param];\n+            graph.add_edge(pred_idx, param_idx);\n+        }\n+    }\n+\n+    let starting_nodes = necessary_params.iter().map(|param| param_map[param]);\n+    let reachable = graph.compute_reachable_nodes(starting_nodes);\n+\n+    // Not pretty, but effective. If only there were `Vec::retain_index()`...\n+    let mut idx = param_count;\n+    generic_params.retain(|_| {\n+        idx += 1;\n+        reachable[idx - 1]\n+    });\n+    stdx::always!(idx == generic_params_upper_bound, \"inconsistent index\");\n+    where_preds.retain(|_| {\n+        idx += 1;\n+        reachable[idx - 1]\n+    });\n+}\n+\n+/// Filters out bounds from impl if we're generating the function into the same impl we're\n+/// generating from.\n+fn filter_bounds_in_scope(\n+    generic_params: &mut Vec<ParamBoundWithParams>,\n+    where_preds: &mut Vec<WherePredWithParams>,\n+    ctx: &AssistContext<'_>,\n+    target: &GeneratedFunctionTarget,\n+) -> Option<()> {\n+    let target_impl = target.parent().ancestors().find_map(ast::Impl::cast)?;\n+    let target_impl = ctx.sema.to_def(&target_impl)?;\n+    // It's sufficient to test only the first element of `generic_params` because of the order of\n+    // insertion (see `relevant_parmas_and_where_clauses()`).\n+    let def = generic_params.first()?.self_ty_param.parent();\n+    if def != hir::GenericDef::Impl(target_impl) {\n+        return None;\n+    }\n+\n+    // Now we know every element that belongs to an impl would be in scope at `target`, we can\n+    // filter them out just by lookint at their parent.\n+    generic_params.retain(|it| !matches!(it.self_ty_param.parent(), hir::GenericDef::Impl(_)));\n+    where_preds.retain(|it| {\n+        it.node.syntax().parent().and_then(|it| it.parent()).and_then(ast::Impl::cast).is_none()\n+    });\n+\n+    Some(())\n+}\n+\n /// Makes duplicate argument names unique by appending incrementing numbers.\n ///\n /// ```\n@@ -564,17 +955,25 @@ fn fn_arg_name(sema: &Semantics<'_, RootDatabase>, arg_expr: &ast::Expr) -> Stri\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistContext<'_>, target_module: hir::Module, fn_arg: &ast::Expr) -> String {\n+fn fn_arg_type(\n+    ctx: &AssistContext<'_>,\n+    target_module: hir::Module,\n+    fn_arg: &ast::Expr,\n+    generic_params: &mut FxHashSet<hir::GenericParam>,\n+) -> String {\n     fn maybe_displayed_type(\n         ctx: &AssistContext<'_>,\n         target_module: hir::Module,\n         fn_arg: &ast::Expr,\n+        generic_params: &mut FxHashSet<hir::GenericParam>,\n     ) -> Option<String> {\n         let ty = ctx.sema.type_of_expr(fn_arg)?.adjusted();\n         if ty.is_unknown() {\n             return None;\n         }\n \n+        generic_params.extend(ty.generic_params(ctx.db()));\n+\n         if ty.is_reference() || ty.is_mutable_reference() {\n             let famous_defs = &FamousDefs(&ctx.sema, ctx.sema.scope(fn_arg.syntax())?.krate());\n             convert_reference_type(ty.strip_references(), ctx.db(), famous_defs)\n@@ -585,7 +984,8 @@ fn fn_arg_type(ctx: &AssistContext<'_>, target_module: hir::Module, fn_arg: &ast\n         }\n     }\n \n-    maybe_displayed_type(ctx, target_module, fn_arg).unwrap_or_else(|| String::from(\"_\"))\n+    maybe_displayed_type(ctx, target_module, fn_arg, generic_params)\n+        .unwrap_or_else(|| String::from(\"_\"))\n }\n \n /// Returns the position inside the current mod or file\n@@ -640,10 +1040,11 @@ fn next_space_for_fn_in_module(\n }\n \n fn next_space_for_fn_in_impl(impl_: &ast::Impl) -> Option<GeneratedFunctionTarget> {\n-    if let Some(last_item) = impl_.assoc_item_list().and_then(|it| it.assoc_items().last()) {\n+    let assoc_item_list = impl_.assoc_item_list()?;\n+    if let Some(last_item) = assoc_item_list.assoc_items().last() {\n         Some(GeneratedFunctionTarget::BehindItem(last_item.syntax().clone()))\n     } else {\n-        Some(GeneratedFunctionTarget::InEmptyItemList(impl_.assoc_item_list()?.syntax().clone()))\n+        Some(GeneratedFunctionTarget::InEmptyItemList(assoc_item_list.syntax().clone()))\n     }\n }\n \n@@ -659,6 +1060,73 @@ fn module_is_descendant(module: &hir::Module, ans: &hir::Module, ctx: &AssistCon\n     false\n }\n \n+// This is never intended to be used as a generic graph strucuture. If there's ever another need of\n+// graph algorithm, consider adding a library for that (and replace the following).\n+/// Minimally implemented directed graph structure represented by adjacency list.\n+struct Graph {\n+    edges: Vec<Vec<usize>>,\n+}\n+\n+impl Graph {\n+    fn new(node_count: usize) -> Self {\n+        Self { edges: vec![Vec::new(); node_count] }\n+    }\n+\n+    fn add_edge(&mut self, from: usize, to: usize) {\n+        self.edges[from].push(to);\n+    }\n+\n+    fn edges_for(&self, node_idx: usize) -> &[usize] {\n+        &self.edges[node_idx]\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.edges.len()\n+    }\n+\n+    fn compute_reachable_nodes(\n+        &self,\n+        starting_nodes: impl IntoIterator<Item = usize>,\n+    ) -> Vec<bool> {\n+        let mut visitor = Visitor::new(self);\n+        for idx in starting_nodes {\n+            visitor.mark_reachable(idx);\n+        }\n+        visitor.visited\n+    }\n+}\n+\n+struct Visitor<'g> {\n+    graph: &'g Graph,\n+    visited: Vec<bool>,\n+    // Stack is held in this struct so we can reuse its buffer.\n+    stack: Vec<usize>,\n+}\n+\n+impl<'g> Visitor<'g> {\n+    fn new(graph: &'g Graph) -> Self {\n+        let visited = vec![false; graph.len()];\n+        Self { graph, visited, stack: Vec::new() }\n+    }\n+\n+    fn mark_reachable(&mut self, start_idx: usize) {\n+        // non-recursive DFS\n+        stdx::always!(self.stack.is_empty());\n+\n+        self.stack.push(start_idx);\n+        while let Some(idx) = self.stack.pop() {\n+            if !self.visited[idx] {\n+                self.visited[idx] = true;\n+                for &neighbor in self.graph.edges_for(idx) {\n+                    if !self.visited[neighbor] {\n+                        self.stack.push(neighbor);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -1087,27 +1555,302 @@ fn bar(baz: Baz::Bof) {\n     }\n \n     #[test]\n-    fn add_function_with_generic_arg() {\n-        // FIXME: This is wrong, generated `bar` should include generic parameter.\n+    fn generate_function_with_generic_param() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+fn foo<T, const N: usize>(t: [T; N]) { $0bar(t) }\n+\",\n+            r\"\n+fn foo<T, const N: usize>(t: [T; N]) { bar(t) }\n+\n+fn bar<T, const N: usize>(t: [T; N]) {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generate_function_with_parent_generic_param() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn foo<U>(t: T, u: U) { $0bar(t, u) }\n+}\n+\",\n+            r\"\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn foo<U>(t: T, u: U) { bar(t, u) }\n+}\n+\n+fn bar<T, U>(t: T, u: U) {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generic_param_in_receiver_type() {\n+        // FIXME: Generic parameter `T` should be part of impl, not method.\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S<T>(T);\n+fn foo<T, U>(s: S<T>, u: U) { s.$0foo(u) }\n+\",\n+            r\"\n+struct S<T>(T);\n+impl S {\n+    fn foo<T, U>(&self, u: U) {\n+        ${0:todo!()}\n+    }\n+}\n+fn foo<T, U>(s: S<T>, u: U) { s.foo(u) }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generic_param_in_return_type() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+fn foo<T, const N: usize>() -> [T; N] { $0bar() }\n+\",\n+            r\"\n+fn foo<T, const N: usize>() -> [T; N] { bar() }\n+\n+fn bar<T, const N: usize>() -> [T; N] {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn generate_fn_with_bounds() {\n+        // FIXME: where predicates should be on next lines.\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<i64>,\n+{\n+    fn foo<U>(t: T, u: U)\n+    where\n+        T: A<()>,\n+        U: A<i32> + A<i64>,\n+    {\n+        $0bar(t, u)\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<i64>,\n+{\n+    fn foo<U>(t: T, u: U)\n+    where\n+        T: A<()>,\n+        U: A<i32> + A<i64>,\n+    {\n+        bar(t, u)\n+    }\n+}\n+\n+fn bar<T: A<i32>, U>(t: T, u: U) where T: A<i64>, T: A<()>, U: A<i32> + A<i64> {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn include_transitive_param_dependency() {\n+        // FIXME: where predicates should be on next lines.\n         check_assist(\n             generate_function,\n             r\"\n-fn foo<T>(t: T) {\n-    $0bar(t)\n+trait A<T> { type Assoc; }\n+trait B { type Item; }\n+struct S<T>(T);\n+impl<T, U, V: B, W> S<(T, U, V, W)>\n+where\n+    T: A<U, Assoc = V>,\n+    S<V::Item>: A<U, Assoc = W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T, Assoc = I>,\n+    {\n+        $0bar(u)\n+    }\n }\n \",\n             r\"\n-fn foo<T>(t: T) {\n-    bar(t)\n+trait A<T> { type Assoc; }\n+trait B { type Item; }\n+struct S<T>(T);\n+impl<T, U, V: B, W> S<(T, U, V, W)>\n+where\n+    T: A<U, Assoc = V>,\n+    S<V::Item>: A<U, Assoc = W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T, Assoc = I>,\n+    {\n+        bar(u)\n+    }\n }\n \n-fn bar(t: T) {\n+fn bar<T, U, V: B, W, I>(u: U) where T: A<U, Assoc = V>, S<V::Item>: A<U, Assoc = W>, U: A<T, Assoc = I> {\n     ${0:todo!()}\n }\n \",\n         )\n     }\n \n+    #[test]\n+    fn irrelevant_bounds_are_filtered_out() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U, V, W> S<(T, U, V, W)>\n+where\n+    T: A<U>,\n+    V: A<W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T> + A<I>,\n+    {\n+        $0bar(u)\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U, V, W> S<(T, U, V, W)>\n+where\n+    T: A<U>,\n+    V: A<W>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        U: A<T> + A<I>,\n+    {\n+        bar(u)\n+    }\n+}\n+\n+fn bar<T, U, I>(u: U) where T: A<U>, U: A<T> + A<I> {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn params_in_trait_arg_are_not_dependency() {\n+        // Even though `bar` depends on `U` and `I`, we don't have to copy these bounds:\n+        // `T: A<I>` and `T: A<U>`.\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U> S<(T, U)>\n+where\n+    T: A<U>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        T: A<I>,\n+        U: A<I>,\n+    {\n+        $0bar(u)\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T, U> S<(T, U)>\n+where\n+    T: A<U>,\n+{\n+    fn foo<I>(t: T, u: U)\n+    where\n+        T: A<I>,\n+        U: A<I>,\n+    {\n+        bar(u)\n+    }\n+}\n+\n+fn bar<U, I>(u: U) where U: A<I> {\n+    ${0:todo!()}\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_copy_bounds_already_in_scope() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<usize>,\n+{\n+    fn foo<U: A<()>>(t: T, u: U)\n+    where\n+        T: A<S<i32>>,\n+    {\n+        Self::$0bar(t, u);\n+    }\n+}\n+\",\n+            r\"\n+trait A<T> {}\n+struct S<T>(T);\n+impl<T: A<i32>> S<T>\n+where\n+    T: A<usize>,\n+{\n+    fn foo<U: A<()>>(t: T, u: U)\n+    where\n+        T: A<S<i32>>,\n+    {\n+        Self::bar(t, u);\n+    }\n+\n+    fn bar<U: A<()>>(t: T, u: U) ${0:-> _} where T: A<S<i32>> {\n+        todo!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_with_fn_arg() {\n         // FIXME: The argument in `bar` is wrong.\n@@ -1289,6 +2032,50 @@ fn baz(foo: foo::Foo) {\n         )\n     }\n \n+    #[test]\n+    fn qualified_path_in_generic_bounds_uses_correct_scope() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+mod a {\n+    pub trait A {};\n+}\n+pub mod b {\n+    pub struct S<T>(T);\n+}\n+struct S<T>(T);\n+impl<T> S<T>\n+where\n+    T: a::A,\n+{\n+    fn foo<U: a::A>(t: b::S<T>, u: S<U>) {\n+        a::$0bar(t, u);\n+    }\n+}\n+\",\n+            r\"\n+mod a {\n+    pub trait A {}\n+\n+    pub(crate) fn bar<T, U: self::A>(t: crate::b::S<T>, u: crate::S<U>) ${0:-> _} where T: self::A {\n+        todo!()\n+    };\n+}\n+pub mod b {\n+    pub struct S<T>(T);\n+}\n+struct S<T>(T);\n+impl<T> S<T>\n+where\n+    T: a::A,\n+{\n+    fn foo<U: a::A>(t: b::S<T>, u: S<U>) {\n+        a::bar(t, u);\n+    }\n+}\n+\",\n+        )\n+    }\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n@@ -1606,6 +2393,26 @@ fn foo() {S::bar();}\n         )\n     }\n \n+    #[test]\n+    fn create_generic_static_method() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+fn foo<T, const N: usize>(t: [T; N]) { S::bar$0(t); }\n+\",\n+            r\"\n+struct S;\n+impl S {\n+    fn bar<T, const N: usize>(t: [T; N]) ${0:-> _} {\n+        todo!()\n+    }\n+}\n+fn foo<T, const N: usize>(t: [T; N]) { S::bar(t); }\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn create_static_method_within_an_impl() {\n         check_assist("}, {"sha": "3fc552306a6ffa33ca130156dccfbbc79ad4950f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_macro.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_macro.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,3 +1,4 @@\n+use ide_db::syntax_helpers::insert_whitespace_into_node::insert_ws_into;\n use syntax::ast::{self, AstNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -35,7 +36,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // ```\n pub(crate) fn inline_macro(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let unexpanded = ctx.find_node_at_offset::<ast::MacroCall>()?;\n-    let expanded = ctx.sema.expand(&unexpanded)?.clone_for_update();\n+    let expanded = insert_ws_into(ctx.sema.expand(&unexpanded)?.clone_for_update());\n \n     let text_range = unexpanded.syntax().text_range();\n \n@@ -230,4 +231,27 @@ fn f() { let result = foo$0(); }\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn inline_macro_with_whitespace() {\n+        check_assist(\n+            inline_macro,\n+            r#\"\n+macro_rules! whitespace {\n+    () => {\n+        if true {}\n+    };\n+}\n+fn f() { whitespace$0!(); }\n+\"#,\n+            r#\"\n+macro_rules! whitespace {\n+    () => {\n+        if true {}\n+    };\n+}\n+fn f() { if true{}; }\n+\"#,\n+        )\n+    }\n }"}, {"sha": "d7ddc5f23f5dc5b3a743ad112482193d8e8954fd", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -92,7 +92,7 @@ trait Merge: AstNode + Clone {\n     fn try_merge_from(self, items: &mut dyn Iterator<Item = Self>) -> Option<Vec<Edit>> {\n         let mut edits = Vec::new();\n         let mut merged = self.clone();\n-        while let Some(item) = items.next() {\n+        for item in items {\n             merged = merged.try_merge(&item)?;\n             edits.push(Edit::Remove(item.into_either()));\n         }"}, {"sha": "d848fce4be821b79585bd3854c1dff06ccb3bc41", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_const_to_impl.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -5,10 +5,7 @@ use syntax::{\n     SyntaxKind,\n };\n \n-use crate::{\n-    assist_context::{AssistContext, Assists},\n-    utils,\n-};\n+use crate::assist_context::{AssistContext, Assists};\n \n // NOTE: Code may break if the self type implements a trait that has associated const with the same\n // name, but it's pretty expensive to check that (`hir::Impl::all_for_type()`) and we assume that's\n@@ -130,9 +127,7 @@ pub(crate) fn move_const_to_impl(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n \n             let const_ = const_.clone_for_update();\n             const_.reindent_to(indent);\n-            let mut const_text = format!(\"\\n{indent}{const_}{fixup}\");\n-            utils::escape_non_snippet(&mut const_text);\n-            builder.insert(insert_offset, const_text);\n+            builder.insert(insert_offset, format!(\"\\n{indent}{const_}{fixup}\"));\n         },\n     )\n }\n@@ -443,39 +438,4 @@ impl S {\n \"#,\n         );\n     }\n-\n-    #[test]\n-    fn moved_const_body_is_escaped() {\n-        // Note that the last argument is what *lsp clients would see* rather than\n-        // what users would see. Unescaping happens thereafter.\n-        check_assist(\n-            move_const_to_impl,\n-            r#\"\n-struct S;\n-impl S {\n-    fn f() -> usize {\n-        /// doc comment\n-        /// \\\\\n-        /// ${snippet}\n-        const C$0: &str = \"\\ and $1\";\n-\n-        C.len()\n-    }\n-}\n-\"#,\n-            r#\"\n-struct S;\n-impl S {\n-    /// doc comment\n-    /// \\\\\\\\\n-    /// \\${snippet}\n-    const C: &str = \"\\\\ and \\$1\";\n-\n-    fn f() -> usize {\n-        Self::C.len()\n-    }\n-}\n-\"#,\n-        )\n-    }\n }"}, {"sha": "01420430bb41987fa33859813fbe425a45a42350", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/raw_string.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,7 +2,7 @@ use std::borrow::Cow;\n \n use syntax::{ast, ast::IsString, AstToken, TextRange, TextSize};\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::required_hashes, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: make_raw_string\n //\n@@ -155,33 +155,12 @@ pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<\n     })\n }\n \n-fn required_hashes(s: &str) -> usize {\n-    let mut res = 0usize;\n-    for idx in s.match_indices('\"').map(|(i, _)| i) {\n-        let (_, sub) = s.split_at(idx + 1);\n-        let n_hashes = sub.chars().take_while(|c| *c == '#').count();\n-        res = res.max(n_hashes + 1)\n-    }\n-    res\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::*;\n \n-    #[test]\n-    fn test_required_hashes() {\n-        assert_eq!(0, required_hashes(\"abc\"));\n-        assert_eq!(0, required_hashes(\"###\"));\n-        assert_eq!(1, required_hashes(\"\\\"\"));\n-        assert_eq!(2, required_hashes(\"\\\"#abc\"));\n-        assert_eq!(0, required_hashes(\"#abc\"));\n-        assert_eq!(3, required_hashes(\"#ab\\\"##c\"));\n-        assert_eq!(5, required_hashes(\"#ab\\\"##\\\"####c\"));\n-    }\n-\n     #[test]\n     fn make_raw_string_target() {\n         check_assist_target("}, {"sha": "58dcaf9a221d8d65222e6b4d5458ecf727d88799", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -20,10 +20,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let record = ctx\n-        .find_node_at_offset::<ast::RecordExpr>()\n-        .map(Either::Left)\n-        .or_else(|| ctx.find_node_at_offset::<ast::RecordPat>().map(Either::Right))?;\n+    let record = ctx.find_node_at_offset::<Either<ast::RecordExpr, ast::RecordPat>>()?;\n \n     let path = record.as_ref().either(|it| it.path(), |it| it.path())?;\n     let ranks = compute_fields_ranks(&path, ctx)?;"}, {"sha": "4b20b35c44624ceed6d3e617d33e9f327dbf2e5c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_arith_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_arith_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_arith_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_arith_op.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -81,7 +81,7 @@ fn replace_arith(acc: &mut Assists, ctx: &AssistContext<'_>, kind: ArithKind) ->\n     let range = TextRange::new(start, end);\n \n     acc.add_group(\n-        &GroupLabel(\"replace_arith\".into()),\n+        &GroupLabel(\"Replace arithmetic...\".into()),\n         kind.assist_id(),\n         kind.label(),\n         range,"}, {"sha": "4cfae0c7212c2c2c48d00f343bf06b6364c5a9f5", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -214,7 +214,7 @@ fn impl_def_from_trait(\n \n     // Generate a default `impl` function body for the derived trait.\n     if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n-        let _ = gen_trait_fn_body(func, trait_path, adt);\n+        let _ = gen_trait_fn_body(func, trait_path, adt, None);\n     };\n \n     Some((impl_def, first_assoc_item))"}, {"sha": "457559656a42b29bc10306f7d7975556ec6a93c8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 159, "deletions": 24, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -13,7 +13,7 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         make, HasName,\n     },\n-    AstNode, TextRange,\n+    AstNode, TextRange, T,\n };\n \n use crate::{\n@@ -96,8 +96,9 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext<'\n         cond_bodies.push((cond, body));\n     }\n \n-    if !pat_seen {\n-        // Don't offer turning an if (chain) without patterns into a match\n+    if !pat_seen && cond_bodies.len() != 1 {\n+        // Don't offer turning an if (chain) without patterns into a match,\n+        // unless its a simple `if cond { .. } (else { .. })`\n         return None;\n     }\n \n@@ -114,6 +115,11 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext<'\n                         Either::Left(pat) => {\n                             make::match_arm(iter::once(pat), None, unwrap_trivial_block(body))\n                         }\n+                        Either::Right(_) if !pat_seen => make::match_arm(\n+                            iter::once(make::literal_pat(\"true\").into()),\n+                            None,\n+                            unwrap_trivial_block(body),\n+                        ),\n                         Either::Right(expr) => make::match_arm(\n                             iter::once(make::wildcard_pat().into()),\n                             Some(expr),\n@@ -144,31 +150,36 @@ fn make_else_arm(\n     else_block: Option<ast::BlockExpr>,\n     conditionals: &[(Either<ast::Pat, ast::Expr>, ast::BlockExpr)],\n ) -> ast::MatchArm {\n-    if let Some(else_block) = else_block {\n-        let pattern = if let [(Either::Left(pat), _)] = conditionals {\n-            ctx.sema\n+    let (pattern, expr) = if let Some(else_block) = else_block {\n+        let pattern = match conditionals {\n+            [(Either::Right(_), _)] => make::literal_pat(\"false\").into(),\n+            [(Either::Left(pat), _)] => match ctx\n+                .sema\n                 .type_of_pat(pat)\n                 .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty.adjusted()))\n-                .zip(Some(pat))\n-        } else {\n-            None\n-        };\n-        let pattern = match pattern {\n-            Some((it, pat)) => {\n-                if does_pat_match_variant(pat, &it.sad_pattern()) {\n-                    it.happy_pattern_wildcard()\n-                } else if does_nested_pattern(pat) {\n-                    make::wildcard_pat().into()\n-                } else {\n-                    it.sad_pattern()\n+            {\n+                Some(it) => {\n+                    if does_pat_match_variant(pat, &it.sad_pattern()) {\n+                        it.happy_pattern_wildcard()\n+                    } else if does_nested_pattern(pat) {\n+                        make::wildcard_pat().into()\n+                    } else {\n+                        it.sad_pattern()\n+                    }\n                 }\n-            }\n-            None => make::wildcard_pat().into(),\n+                None => make::wildcard_pat().into(),\n+            },\n+            _ => make::wildcard_pat().into(),\n         };\n-        make::match_arm(iter::once(pattern), None, unwrap_trivial_block(else_block))\n+        (pattern, unwrap_trivial_block(else_block))\n     } else {\n-        make::match_arm(iter::once(make::wildcard_pat().into()), None, make::expr_unit())\n-    }\n+        let pattern = match conditionals {\n+            [(Either::Right(_), _)] => make::literal_pat(\"false\").into(),\n+            _ => make::wildcard_pat().into(),\n+        };\n+        (pattern, make::expr_unit())\n+    };\n+    make::match_arm(iter::once(pattern), None, expr)\n }\n \n // Assist: replace_match_with_if_let\n@@ -231,7 +242,19 @@ pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext<'\n                 }\n             }\n \n-            let condition = make::expr_let(if_let_pat, scrutinee);\n+            let condition = match if_let_pat {\n+                ast::Pat::LiteralPat(p)\n+                    if p.literal().map_or(false, |it| it.token().kind() == T![true]) =>\n+                {\n+                    scrutinee\n+                }\n+                ast::Pat::LiteralPat(p)\n+                    if p.literal().map_or(false, |it| it.token().kind() == T![false]) =>\n+                {\n+                    make::expr_prefix(T![!], scrutinee)\n+                }\n+                _ => make::expr_let(if_let_pat, scrutinee).into(),\n+            };\n             let then_block = make_block_expr(then_expr.reset_indent());\n             let else_expr = if is_empty_expr(&else_expr) { None } else { Some(else_expr) };\n             let if_let_expr = make::expr_if(\n@@ -327,6 +350,58 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn test_if_with_match_no_else() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+pub fn foo(foo: bool) {\n+    if foo$0 {\n+        self.foo();\n+    }\n+}\n+\"#,\n+            r#\"\n+pub fn foo(foo: bool) {\n+    match foo {\n+        true => {\n+            self.foo();\n+        }\n+        false => (),\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_if_with_match_with_else() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+pub fn foo(foo: bool) {\n+    if foo$0 {\n+        self.foo();\n+    } else {\n+        self.bar();\n+    }\n+}\n+\"#,\n+            r#\"\n+pub fn foo(foo: bool) {\n+    match foo {\n+        true => {\n+            self.foo();\n+        }\n+        false => {\n+            self.bar();\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn test_if_let_with_match_no_else() {\n         check_assist(\n@@ -993,6 +1068,66 @@ fn main() {\n         code()\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_replace_match_with_if_bool() {\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn main() {\n+    match$0 b {\n+        true => (),\n+        _ => code(),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    if b {\n+        ()\n+    } else {\n+        code()\n+    }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn main() {\n+    match$0 b {\n+        false => code(),\n+        true => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    if !b {\n+        code()\n+    }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            replace_match_with_if_let,\n+            r#\"\n+fn main() {\n+    match$0 b {\n+        false => (),\n+        true => code(),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    if b {\n+        code()\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "db789cfa334289421d7c3f118c4a969c5398a791", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unmerge_match_arm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -86,8 +86,7 @@ pub(crate) fn unmerge_match_arm(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n                     it.prev_sibling_or_token()\n                 })\n                 .map(|it| it.kind())\n-                .skip_while(|it| it.is_trivia())\n-                .next()\n+                .find(|it| !it.is_trivia())\n                     == Some(T![,]);\n             let has_arms_after = neighbor(&match_arm, Direction::Next).is_some();\n             if !has_comma_after && !has_arms_after {"}, {"sha": "33b19a354b9aacaa087adfaae928011dd5f1e8e0", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 116, "deletions": 46, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,6 +2,7 @@ use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n+        make,\n     },\n     AstNode, SyntaxKind, TextRange, T,\n };\n@@ -37,61 +38,89 @@ pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n         parent = parent.ancestors().find(|it| ast::MatchExpr::can_cast(it.kind()))?\n     }\n \n-    if matches!(parent.kind(), SyntaxKind::STMT_LIST | SyntaxKind::EXPR_STMT | SyntaxKind::LET_STMT)\n-    {\n-        return acc.add(assist_id, assist_label, target, |builder| {\n+    let kind = parent.kind();\n+    if matches!(kind, SyntaxKind::STMT_LIST | SyntaxKind::EXPR_STMT) {\n+        acc.add(assist_id, assist_label, target, |builder| {\n             builder.replace(block.syntax().text_range(), update_expr_string(block.to_string()));\n-        });\n-    }\n-\n-    let parent = ast::Expr::cast(parent)?;\n-\n-    match parent.clone() {\n-        ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::LoopExpr(_) => (),\n-        ast::Expr::MatchExpr(_) => block = block.dedent(IndentLevel(1)),\n-        ast::Expr::IfExpr(if_expr) => {\n-            let then_branch = if_expr.then_branch()?;\n-            if then_branch == block {\n-                if let Some(ancestor) = if_expr.syntax().parent().and_then(ast::IfExpr::cast) {\n-                    // For `else if` blocks\n-                    let ancestor_then_branch = ancestor.then_branch()?;\n-\n+        })\n+    } else if matches!(kind, SyntaxKind::LET_STMT) {\n+        let parent = ast::LetStmt::cast(parent)?;\n+        let pattern = ast::Pat::cast(parent.syntax().first_child()?)?;\n+        let ty = parent.ty();\n+        let list = block.stmt_list()?;\n+        let replaced = match list.syntax().last_child() {\n+            Some(last) => {\n+                let stmts: Vec<ast::Stmt> = list.statements().collect();\n+                let initializer = ast::Expr::cast(last.clone())?;\n+                let let_stmt = make::let_stmt(pattern, ty, Some(initializer));\n+                if stmts.len() > 0 {\n+                    let block = make::block_expr(stmts, None);\n+                    format!(\n+                        \"{}\\n    {}\",\n+                        update_expr_string(block.to_string()),\n+                        let_stmt.to_string()\n+                    )\n+                } else {\n+                    let_stmt.to_string()\n+                }\n+            }\n+            None => {\n+                let empty_tuple = make::expr_tuple([]);\n+                make::let_stmt(pattern, ty, Some(empty_tuple)).to_string()\n+            }\n+        };\n+        acc.add(assist_id, assist_label, target, |builder| {\n+            builder.replace(parent.syntax().text_range(), replaced);\n+        })\n+    } else {\n+        let parent = ast::Expr::cast(parent)?;\n+        match parent.clone() {\n+            ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::LoopExpr(_) => (),\n+            ast::Expr::MatchExpr(_) => block = block.dedent(IndentLevel(1)),\n+            ast::Expr::IfExpr(if_expr) => {\n+                let then_branch = if_expr.then_branch()?;\n+                if then_branch == block {\n+                    if let Some(ancestor) = if_expr.syntax().parent().and_then(ast::IfExpr::cast) {\n+                        // For `else if` blocks\n+                        let ancestor_then_branch = ancestor.then_branch()?;\n+\n+                        return acc.add(assist_id, assist_label, target, |edit| {\n+                            let range_to_del_else_if = TextRange::new(\n+                                ancestor_then_branch.syntax().text_range().end(),\n+                                l_curly_token.text_range().start(),\n+                            );\n+                            let range_to_del_rest = TextRange::new(\n+                                then_branch.syntax().text_range().end(),\n+                                if_expr.syntax().text_range().end(),\n+                            );\n+\n+                            edit.delete(range_to_del_rest);\n+                            edit.delete(range_to_del_else_if);\n+                            edit.replace(\n+                                target,\n+                                update_expr_string_without_newline(then_branch.to_string()),\n+                            );\n+                        });\n+                    }\n+                } else {\n                     return acc.add(assist_id, assist_label, target, |edit| {\n-                        let range_to_del_else_if = TextRange::new(\n-                            ancestor_then_branch.syntax().text_range().end(),\n-                            l_curly_token.text_range().start(),\n-                        );\n-                        let range_to_del_rest = TextRange::new(\n+                        let range_to_del = TextRange::new(\n                             then_branch.syntax().text_range().end(),\n-                            if_expr.syntax().text_range().end(),\n+                            l_curly_token.text_range().start(),\n                         );\n \n-                        edit.delete(range_to_del_rest);\n-                        edit.delete(range_to_del_else_if);\n-                        edit.replace(\n-                            target,\n-                            update_expr_string_without_newline(then_branch.to_string()),\n-                        );\n+                        edit.delete(range_to_del);\n+                        edit.replace(target, update_expr_string_without_newline(block.to_string()));\n                     });\n                 }\n-            } else {\n-                return acc.add(assist_id, assist_label, target, |edit| {\n-                    let range_to_del = TextRange::new(\n-                        then_branch.syntax().text_range().end(),\n-                        l_curly_token.text_range().start(),\n-                    );\n-\n-                    edit.delete(range_to_del);\n-                    edit.replace(target, update_expr_string_without_newline(block.to_string()));\n-                });\n             }\n-        }\n-        _ => return None,\n-    };\n+            _ => return None,\n+        };\n \n-    acc.add(assist_id, assist_label, target, |builder| {\n-        builder.replace(parent.syntax().text_range(), update_expr_string(block.to_string()));\n-    })\n+        acc.add(assist_id, assist_label, target, |builder| {\n+            builder.replace(parent.syntax().text_range(), update_expr_string(block.to_string()));\n+        })\n+    }\n }\n \n fn update_expr_string(expr_string: String) -> String {\n@@ -724,6 +753,19 @@ fn main() -> i32 {\n         check_assist(\n             unwrap_block,\n             r#\"\n+fn main() {\n+    let x = {$0};\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = ();\n+}\n+\"#,\n+        );\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n fn main() {\n     let x = {$0\n         bar\n@@ -734,6 +776,34 @@ fn main() {\n fn main() {\n     let x = bar;\n }\n+\"#,\n+        );\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+fn main() -> i32 {\n+    let _ = {$01; 2};\n+}\n+\"#,\n+            r#\"\n+fn main() -> i32 {\n+    1;\n+    let _ = 2;\n+}\n+\"#,\n+        );\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+fn main() -> i32 {\n+    let mut a = {$01; 2};\n+}\n+\"#,\n+            r#\"\n+fn main() -> i32 {\n+    1;\n+    let mut a = 2;\n+}\n \"#,\n         );\n     }"}, {"sha": "276cf5f5dd018711234438f079a42f40de96616b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -106,6 +106,7 @@ mod handlers {\n \n     pub(crate) type Handler = fn(&mut Assists, &AssistContext<'_>) -> Option<()>;\n \n+    mod add_braces;\n     mod add_explicit_type;\n     mod add_label_to_loop;\n     mod add_lifetime_to_type;\n@@ -126,6 +127,7 @@ mod handlers {\n     mod convert_to_guarded_return;\n     mod convert_two_arm_bool_match_to_matches_macro;\n     mod convert_while_to_loop;\n+    mod desugar_doc_comment;\n     mod destructure_tuple_binding;\n     mod expand_glob_import;\n     mod extract_expressions_from_format_string;\n@@ -208,6 +210,7 @@ mod handlers {\n     pub(crate) fn all() -> &'static [Handler] {\n         &[\n             // These are alphabetic for the foolish consistency\n+            add_braces::add_braces,\n             add_explicit_type::add_explicit_type,\n             add_label_to_loop::add_label_to_loop,\n             add_missing_match_arms::add_missing_match_arms,\n@@ -231,6 +234,7 @@ mod handlers {\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,\n             convert_while_to_loop::convert_while_to_loop,\n+            desugar_doc_comment::desugar_doc_comment,\n             destructure_tuple_binding::destructure_tuple_binding,\n             expand_glob_import::expand_glob_import,\n             extract_expressions_from_format_string::extract_expressions_from_format_string,"}, {"sha": "8a25e1f648ae00ebeb9d3101aae88ae968f9b071", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,6 +2,31 @@\n \n use super::check_doc_test;\n \n+#[test]\n+fn doctest_add_braces() {\n+    check_doc_test(\n+        \"add_braces\",\n+        r#####\"\n+fn foo(n: i32) -> i32 {\n+    match n {\n+        1 =>$0 n + 1,\n+        _ => 0\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn foo(n: i32) -> i32 {\n+    match n {\n+        1 => {\n+            n + 1\n+        },\n+        _ => 0\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_add_explicit_type() {\n     check_doc_test(\n@@ -597,6 +622,21 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_desugar_doc_comment() {\n+    check_doc_test(\n+        \"desugar_doc_comment\",\n+        r#####\"\n+/// Multi-line$0\n+/// comment\n+\"#####,\n+        r#####\"\n+#[doc = r\"Multi-line\n+comment\"]\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_expand_glob_import() {\n     check_doc_test("}, {"sha": "f323ebcf7a3bdc76af45069d353d20557daf44ec", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -208,23 +208,6 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n     }\n }\n \n-/// Escapes text that should be rendered as-is, typically those that we're copy-pasting what the\n-/// users wrote.\n-///\n-/// This function should only be used when the text doesn't contain snippet **AND** the text\n-/// wouldn't be included in a snippet.\n-pub(crate) fn escape_non_snippet(text: &mut String) {\n-    // While we *can* escape `}`, we don't really have to in this specific case. We only need to\n-    // escape it inside `${}` to disambiguate it from the ending token of the syntax, but after we\n-    // escape every occurrence of `$`, we wouldn't have `${}` in the first place.\n-    //\n-    // This will break if the text contains snippet or it will be included in a snippet (hence doc\n-    // comment). Compare `fn escape(buf)` in `render_snippet()` above, where the escaped text is\n-    // included in a snippet.\n-    stdx::replace(text, '\\\\', r\"\\\\\");\n-    stdx::replace(text, '$', r\"\\$\");\n-}\n-\n pub(crate) fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .find(|it| !matches!(it.kind(), WHITESPACE | COMMENT | ATTR))\n@@ -758,3 +741,24 @@ pub(crate) fn convert_param_list_to_arg_list(list: ast::ParamList) -> ast::ArgLi\n     }\n     make::arg_list(args)\n }\n+\n+/// Calculate the number of hashes required for a raw string containing `s`\n+pub(crate) fn required_hashes(s: &str) -> usize {\n+    let mut res = 0usize;\n+    for idx in s.match_indices('\"').map(|(i, _)| i) {\n+        let (_, sub) = s.split_at(idx + 1);\n+        let n_hashes = sub.chars().take_while(|c| *c == '#').count();\n+        res = res.max(n_hashes + 1)\n+    }\n+    res\n+}\n+#[test]\n+fn test_required_hashes() {\n+    assert_eq!(0, required_hashes(\"abc\"));\n+    assert_eq!(0, required_hashes(\"###\"));\n+    assert_eq!(1, required_hashes(\"\\\"\"));\n+    assert_eq!(2, required_hashes(\"\\\"#abc\"));\n+    assert_eq!(0, required_hashes(\"#abc\"));\n+    assert_eq!(3, required_hashes(\"#ab\\\"##c\"));\n+    assert_eq!(5, required_hashes(\"#ab\\\"##\\\"####c\"));\n+}"}, {"sha": "808b23405951c6f0910087ada1081123e2e615b8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,27 +1,31 @@\n //! This module contains functions to generate default trait impl function bodies where possible.\n \n+use hir::TraitRef;\n use syntax::{\n     ast::{self, edit::AstNodeEdit, make, AstNode, BinaryOp, CmpOp, HasName, LogicOp},\n     ted,\n };\n \n /// Generate custom trait bodies without default implementation where possible.\n ///\n+/// If `func` is defined within an existing impl block, pass [`TraitRef`]. Otherwise pass `None`.\n+///\n /// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n /// `None` means that generating a custom trait body failed, and the body will remain\n /// as `todo!` instead.\n pub(crate) fn gen_trait_fn_body(\n     func: &ast::Fn,\n     trait_path: &ast::Path,\n     adt: &ast::Adt,\n+    trait_ref: Option<TraitRef>,\n ) -> Option<()> {\n     match trait_path.segment()?.name_ref()?.text().as_str() {\n         \"Clone\" => gen_clone_impl(adt, func),\n         \"Debug\" => gen_debug_impl(adt, func),\n         \"Default\" => gen_default_impl(adt, func),\n         \"Hash\" => gen_hash_impl(adt, func),\n-        \"PartialEq\" => gen_partial_eq(adt, func),\n-        \"PartialOrd\" => gen_partial_ord(adt, func),\n+        \"PartialEq\" => gen_partial_eq(adt, func, trait_ref),\n+        \"PartialOrd\" => gen_partial_ord(adt, func, trait_ref),\n         _ => None,\n     }\n }\n@@ -395,7 +399,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n }\n \n /// Generate a `PartialEq` impl based on the fields and members of the target type.\n-fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn, trait_ref: Option<TraitRef>) -> Option<()> {\n     stdx::always!(func.name().map_or(false, |name| name.text() == \"eq\"));\n     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n         match expr {\n@@ -423,8 +427,15 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n     }\n \n-    // FIXME: return `None` if the trait carries a generic type; we can only\n-    // generate this code `Self` for the time being.\n+    // Check that self type and rhs type match. We don't know how to implement the method\n+    // automatically otherwise.\n+    if let Some(trait_ref) = trait_ref {\n+        let self_ty = trait_ref.self_ty();\n+        let rhs_ty = trait_ref.get_type_argument(1)?;\n+        if self_ty != rhs_ty {\n+            return None;\n+        }\n+    }\n \n     let body = match adt {\n         // `PartialEq` cannot be derived for unions, so no default impl can be provided.\n@@ -568,7 +579,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // No fields in the body means there's nothing to hash.\n+            // No fields in the body means there's nothing to compare.\n             None => {\n                 let expr = make::expr_literal(\"true\").into();\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n@@ -580,7 +591,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     Some(())\n }\n \n-fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn, trait_ref: Option<TraitRef>) -> Option<()> {\n     stdx::always!(func.name().map_or(false, |name| name.text() == \"partial_cmp\"));\n     fn gen_partial_eq_match(match_target: ast::Expr) -> Option<ast::Stmt> {\n         let mut arms = vec![];\n@@ -605,8 +616,15 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         make::expr_method_call(lhs, method, make::arg_list(Some(rhs)))\n     }\n \n-    // FIXME: return `None` if the trait carries a generic type; we can only\n-    // generate this code `Self` for the time being.\n+    // Check that self type and rhs type match. We don't know how to implement the method\n+    // automatically otherwise.\n+    if let Some(trait_ref) = trait_ref {\n+        let self_ty = trait_ref.self_ty();\n+        let rhs_ty = trait_ref.get_type_argument(1)?;\n+        if self_ty != rhs_ty {\n+            return None;\n+        }\n+    }\n \n     let body = match adt {\n         // `PartialOrd` cannot be derived for unions, so no default impl can be provided."}, {"sha": "34ef092cfc44cd3a91accecdfaa2d01f02ab0d7e", "filename": "src/tools/rust-analyzer/crates/ide-completion/Cargo.toml", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"ide-completion\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -13,21 +15,23 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n \n-once_cell = \"1.15.0\"\n+once_cell = \"1.17.0\"\n smallvec = \"1.10.0\"\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n-base-db = { path = \"../base-db\", version = \"0.0.0\" }\n-ide-db = { path = \"../ide-db\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n \n+# local deps\n+base-db.workspace = true\n+ide-db.workspace = true\n+profile.workspace = true\n+stdx.workspace = true\n+syntax.workspace = true\n+text-edit.workspace = true\n # completions crate should depend only on the top-level `hir` package. if you need\n # something from some `hir-xxx` subpackage, reexport the API via `hir`.\n-hir = { path = \"../hir\", version = \"0.0.0\" }\n+hir.workspace = true\n \n [dev-dependencies]\n expect-test = \"1.4.0\"\n \n-test-utils = { path = \"../test-utils\" }\n+# local deps\n+test-utils.workspace = true"}, {"sha": "889d90095fab1cd0d3364c1e39a053d2b8459b8a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -869,7 +869,7 @@ impl Test for T {{\n         };\n \n         // Enumerate some possible next siblings.\n-        for next_sibling in &[\n+        for next_sibling in [\n             \"\",\n             \"fn other_fn() {}\", // `const $0 fn` -> `const fn`\n             \"type OtherType = i32;\","}, {"sha": "b9ab2afca2b59da81b8b0589eb5b2599f2029e1b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -86,6 +86,7 @@ fn foo(a: A) { a.$0 }\n                 sn match                  match expr {}\n                 sn ref                    &expr\n                 sn refm                   &mut expr\n+                sn unsafe                 unsafe {}\n             \"#]],\n         );\n \n@@ -110,6 +111,7 @@ fn foo() {\n                 sn match                  match expr {}\n                 sn ref                    &expr\n                 sn refm                   &mut expr\n+                sn unsafe                 unsafe {}\n             \"#]],\n         );\n     }\n@@ -136,6 +138,7 @@ fn foo(a: A) { a.$0 }\n                 sn match                  match expr {}\n                 sn ref                    &expr\n                 sn refm                   &mut expr\n+                sn unsafe                 unsafe {}\n             \"#]],\n         );\n     }"}, {"sha": "90c523735da80e505bed930d0eeb409990116203", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 107, "deletions": 44, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -6,7 +6,7 @@ use hir::{Documentation, HasAttrs};\n use ide_db::{imports::insert_use::ImportScope, ty_filter::TryEnum, SnippetCap};\n use syntax::{\n     ast::{self, make, AstNode, AstToken},\n-    SyntaxKind::{EXPR_STMT, STMT_LIST},\n+    SyntaxKind::{BLOCK_EXPR, EXPR_STMT, FOR_EXPR, IF_EXPR, LOOP_EXPR, STMT_LIST, WHILE_EXPR},\n     TextRange, TextSize,\n };\n use text_edit::TextEdit;\n@@ -123,6 +123,22 @@ pub(crate) fn complete_postfix(\n     postfix_snippet(\"ref\", \"&expr\", &format!(\"&{receiver_text}\")).add_to(acc);\n     postfix_snippet(\"refm\", \"&mut expr\", &format!(\"&mut {receiver_text}\")).add_to(acc);\n \n+    let mut unsafe_should_be_wrapped = true;\n+    if dot_receiver.syntax().kind() == BLOCK_EXPR {\n+        unsafe_should_be_wrapped = false;\n+        if let Some(parent) = dot_receiver.syntax().parent() {\n+            if matches!(parent.kind(), IF_EXPR | WHILE_EXPR | LOOP_EXPR | FOR_EXPR) {\n+                unsafe_should_be_wrapped = true;\n+            }\n+        }\n+    };\n+    let unsafe_completion_string = if unsafe_should_be_wrapped {\n+        format!(\"unsafe {{ {receiver_text} }}\")\n+    } else {\n+        format!(\"unsafe {receiver_text}\")\n+    };\n+    postfix_snippet(\"unsafe\", \"unsafe {}\", &unsafe_completion_string).add_to(acc);\n+\n     // The rest of the postfix completions create an expression that moves an argument,\n     // so it's better to consider references now to avoid breaking the compilation\n \n@@ -329,18 +345,19 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                sn box   Box::new(expr)\n-                sn call  function(expr)\n-                sn dbg   dbg!(expr)\n-                sn dbgr  dbg!(&expr)\n-                sn if    if expr {}\n-                sn let   let\n-                sn letm  let mut\n-                sn match match expr {}\n-                sn not   !expr\n-                sn ref   &expr\n-                sn refm  &mut expr\n-                sn while while expr {}\n+                sn box    Box::new(expr)\n+                sn call   function(expr)\n+                sn dbg    dbg!(expr)\n+                sn dbgr   dbg!(&expr)\n+                sn if     if expr {}\n+                sn let    let\n+                sn letm   let mut\n+                sn match  match expr {}\n+                sn not    !expr\n+                sn ref    &expr\n+                sn refm   &mut expr\n+                sn unsafe unsafe {}\n+                sn while  while expr {}\n             \"#]],\n         );\n     }\n@@ -359,16 +376,17 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                sn box   Box::new(expr)\n-                sn call  function(expr)\n-                sn dbg   dbg!(expr)\n-                sn dbgr  dbg!(&expr)\n-                sn if    if expr {}\n-                sn match match expr {}\n-                sn not   !expr\n-                sn ref   &expr\n-                sn refm  &mut expr\n-                sn while while expr {}\n+                sn box    Box::new(expr)\n+                sn call   function(expr)\n+                sn dbg    dbg!(expr)\n+                sn dbgr   dbg!(&expr)\n+                sn if     if expr {}\n+                sn match  match expr {}\n+                sn not    !expr\n+                sn ref    &expr\n+                sn refm   &mut expr\n+                sn unsafe unsafe {}\n+                sn while  while expr {}\n             \"#]],\n         );\n     }\n@@ -383,15 +401,16 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                sn box   Box::new(expr)\n-                sn call  function(expr)\n-                sn dbg   dbg!(expr)\n-                sn dbgr  dbg!(&expr)\n-                sn let   let\n-                sn letm  let mut\n-                sn match match expr {}\n-                sn ref   &expr\n-                sn refm  &mut expr\n+                sn box    Box::new(expr)\n+                sn call   function(expr)\n+                sn dbg    dbg!(expr)\n+                sn dbgr   dbg!(&expr)\n+                sn let    let\n+                sn letm   let mut\n+                sn match  match expr {}\n+                sn ref    &expr\n+                sn refm   &mut expr\n+                sn unsafe unsafe {}\n             \"#]],\n         )\n     }\n@@ -406,18 +425,19 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                sn box   Box::new(expr)\n-                sn call  function(expr)\n-                sn dbg   dbg!(expr)\n-                sn dbgr  dbg!(&expr)\n-                sn if    if expr {}\n-                sn let   let\n-                sn letm  let mut\n-                sn match match expr {}\n-                sn not   !expr\n-                sn ref   &expr\n-                sn refm  &mut expr\n-                sn while while expr {}\n+                sn box    Box::new(expr)\n+                sn call   function(expr)\n+                sn dbg    dbg!(expr)\n+                sn dbgr   dbg!(&expr)\n+                sn if     if expr {}\n+                sn let    let\n+                sn letm   let mut\n+                sn match  match expr {}\n+                sn not    !expr\n+                sn ref    &expr\n+                sn refm   &mut expr\n+                sn unsafe unsafe {}\n+                sn while  while expr {}\n             \"#]],\n         );\n     }\n@@ -517,6 +537,49 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn postfix_completion_for_unsafe() {\n+        check_edit(\"unsafe\", r#\"fn main() { foo.$0 }\"#, r#\"fn main() { unsafe { foo } }\"#);\n+        check_edit(\"unsafe\", r#\"fn main() { { foo }.$0 }\"#, r#\"fn main() { unsafe { foo } }\"#);\n+        check_edit(\n+            \"unsafe\",\n+            r#\"fn main() { if x { foo }.$0 }\"#,\n+            r#\"fn main() { unsafe { if x { foo } } }\"#,\n+        );\n+        check_edit(\n+            \"unsafe\",\n+            r#\"fn main() { loop { foo }.$0 }\"#,\n+            r#\"fn main() { unsafe { loop { foo } } }\"#,\n+        );\n+        check_edit(\n+            \"unsafe\",\n+            r#\"fn main() { if true {}.$0 }\"#,\n+            r#\"fn main() { unsafe { if true {} } }\"#,\n+        );\n+        check_edit(\n+            \"unsafe\",\n+            r#\"fn main() { while true {}.$0 }\"#,\n+            r#\"fn main() { unsafe { while true {} } }\"#,\n+        );\n+        check_edit(\n+            \"unsafe\",\n+            r#\"fn main() { for i in 0..10 {}.$0 }\"#,\n+            r#\"fn main() { unsafe { for i in 0..10 {} } }\"#,\n+        );\n+        check_edit(\n+            \"unsafe\",\n+            r#\"fn main() { let x = if true {1} else {2}.$0 }\"#,\n+            r#\"fn main() { let x = unsafe { if true {1} else {2} } }\"#,\n+        );\n+\n+        // completion will not be triggered\n+        check_edit(\n+            \"unsafe\",\n+            r#\"fn main() { let x = true else {panic!()}.$0}\"#,\n+            r#\"fn main() { let x = true else {panic!()}.unsafe}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn custom_postfix_completion() {\n         let config = CompletionConfig {"}, {"sha": "8f6a97e1e09d89634fed3ed95a534286b30f4448", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -19,6 +19,7 @@ pub struct CompletionConfig {\n     pub insert_use: InsertUseConfig,\n     pub prefer_no_std: bool,\n     pub snippets: Vec<Snippet>,\n+    pub limit: Option<usize>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "4bff665ab1d770815e1502f1a87772c753bd1b13", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -48,7 +48,9 @@ pub(super) fn expand_and_analyze(\n     // make the offset point to the start of the original token, as that is what the\n     // intermediate offsets calculated in expansion always points to\n     let offset = offset - relative_offset;\n-    let expansion = expand(sema, original_file, speculative_file, offset, fake_ident_token);\n+    let expansion =\n+        expand(sema, original_file, speculative_file, offset, fake_ident_token, relative_offset);\n+\n     // add the relative offset back, so that left_biased finds the proper token\n     let offset = expansion.offset + relative_offset;\n     let token = expansion.original_file.token_at_offset(offset).left_biased()?;\n@@ -67,6 +69,7 @@ fn expand(\n     mut speculative_file: SyntaxNode,\n     mut offset: TextSize,\n     mut fake_ident_token: SyntaxToken,\n+    relative_offset: TextSize,\n ) -> ExpansionResult {\n     let _p = profile::span(\"CompletionContext::expand\");\n     let mut derive_ctx = None;\n@@ -97,7 +100,7 @@ fn expand(\n                 // successful expansions\n                 (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n                     let new_offset = fake_mapped_token.text_range().start();\n-                    if new_offset > actual_expansion.text_range().end() {\n+                    if new_offset + relative_offset > actual_expansion.text_range().end() {\n                         // offset outside of bounds from the original expansion,\n                         // stop here to prevent problems from happening\n                         break 'expansion;\n@@ -176,7 +179,7 @@ fn expand(\n                 // successful expansions\n                 (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n                     let new_offset = fake_mapped_token.text_range().start();\n-                    if new_offset > actual_expansion.text_range().end() {\n+                    if new_offset + relative_offset > actual_expansion.text_range().end() {\n                         // offset outside of bounds from the original expansion,\n                         // stop here to prevent problems from happening\n                         break 'expansion;\n@@ -672,10 +675,10 @@ fn classify_name_ref(\n         {\n             if let Some(item) = ast::Item::cast(n) {\n                 let is_inbetween = match &item {\n-                    ast::Item::Const(it) => it.body().is_none(),\n+                    ast::Item::Const(it) => it.body().is_none() && it.semicolon_token().is_none(),\n                     ast::Item::Enum(it) => it.variant_list().is_none(),\n                     ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n-                    ast::Item::Fn(it) => it.body().is_none(),\n+                    ast::Item::Fn(it) => it.body().is_none() && it.semicolon_token().is_none(),\n                     ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n                     ast::Item::Module(it) => {\n                         it.item_list().is_none() && it.semicolon_token().is_none()\n@@ -685,7 +688,7 @@ fn classify_name_ref(\n                         it.field_list().is_none() && it.semicolon_token().is_none()\n                     }\n                     ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n-                    ast::Item::TypeAlias(it) => it.ty().is_none(),\n+                    ast::Item::TypeAlias(it) => it.ty().is_none() && it.semicolon_token().is_none(),\n                     ast::Item::Union(it) => it.record_field_list().is_none(),\n                     _ => false,\n                 };"}, {"sha": "d6476c10258ecde9a428c954307541d7416f4545", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1691,6 +1691,7 @@ fn main() {\n                 sn while []\n                 sn ref []\n                 sn refm []\n+                sn unsafe []\n                 sn match []\n                 sn box []\n                 sn dbg []\n@@ -1718,6 +1719,7 @@ fn main() {\n                 me f() []\n                 sn ref []\n                 sn refm []\n+                sn unsafe []\n                 sn match []\n                 sn box []\n                 sn dbg []"}, {"sha": "540b0fd0ef7d9dab0b7ba4a0daaa83d843c79a0d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -75,6 +75,7 @@ pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {\n         skip_glob_imports: true,\n     },\n     snippets: Vec::new(),\n+    limit: None,\n };\n \n pub(crate) fn completion_list(ra_fixture: &str) -> String {"}, {"sha": "0b485eb776d8a8fc4f30a400cb0a64c89086f74f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -541,9 +541,9 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-                fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n-                ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n-            \"#]],\n+            ct SPECIAL_CONST (use dep::test_mod::TestTrait) DEPRECATED\n+            fn weird_function() (use dep::test_mod::TestTrait) fn() DEPRECATED\n+        \"#]],\n     );\n }\n "}, {"sha": "9fc731bb11d576604604c335e975244888a45cfe", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/item_list.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -214,6 +214,57 @@ fn in_trait_assoc_item_list() {\n     );\n }\n \n+#[test]\n+fn in_trait_assoc_fn_missing_body() {\n+    check(\n+        r#\"trait Foo { fn function(); $0 }\"#,\n+        expect![[r#\"\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            kw const\n+            kw crate::\n+            kw fn\n+            kw self::\n+            kw type\n+            kw unsafe\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_trait_assoc_const_missing_body() {\n+    check(\n+        r#\"trait Foo { const CONST: (); $0 }\"#,\n+        expect![[r#\"\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            kw const\n+            kw crate::\n+            kw fn\n+            kw self::\n+            kw type\n+            kw unsafe\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_trait_assoc_type_aliases_missing_ty() {\n+    check(\n+        r#\"trait Foo { type Type; $0 }\"#,\n+        expect![[r#\"\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            kw const\n+            kw crate::\n+            kw fn\n+            kw self::\n+            kw type\n+            kw unsafe\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn in_trait_impl_assoc_item_list() {\n     check("}, {"sha": "92ea4d15b85128ff8300aa9f80c012071bfbaf43", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/proc_macros.rs", "status": "modified", "additions": 74, "deletions": 40, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fproc_macros.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -24,16 +24,17 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-            me foo() fn(&self)\n-            sn box   Box::new(expr)\n-            sn call  function(expr)\n-            sn dbg   dbg!(expr)\n-            sn dbgr  dbg!(&expr)\n-            sn let   let\n-            sn letm  let mut\n-            sn match match expr {}\n-            sn ref   &expr\n-            sn refm  &mut expr\n+            me foo()  fn(&self)\n+            sn box    Box::new(expr)\n+            sn call   function(expr)\n+            sn dbg    dbg!(expr)\n+            sn dbgr   dbg!(&expr)\n+            sn let    let\n+            sn letm   let mut\n+            sn match  match expr {}\n+            sn ref    &expr\n+            sn refm   &mut expr\n+            sn unsafe unsafe {}\n         \"#]],\n     )\n }\n@@ -54,16 +55,17 @@ fn main() {\n }\n \"#,\n         expect![[r#\"\n-            me foo() fn(&self)\n-            sn box   Box::new(expr)\n-            sn call  function(expr)\n-            sn dbg   dbg!(expr)\n-            sn dbgr  dbg!(&expr)\n-            sn let   let\n-            sn letm  let mut\n-            sn match match expr {}\n-            sn ref   &expr\n-            sn refm  &mut expr\n+            me foo()  fn(&self)\n+            sn box    Box::new(expr)\n+            sn call   function(expr)\n+            sn dbg    dbg!(expr)\n+            sn dbgr   dbg!(&expr)\n+            sn let    let\n+            sn letm   let mut\n+            sn match  match expr {}\n+            sn ref    &expr\n+            sn refm   &mut expr\n+            sn unsafe unsafe {}\n         \"#]],\n     )\n }\n@@ -86,16 +88,17 @@ impl Foo {\n fn main() {}\n \"#,\n         expect![[r#\"\n-            me foo() fn(&self)\n-            sn box   Box::new(expr)\n-            sn call  function(expr)\n-            sn dbg   dbg!(expr)\n-            sn dbgr  dbg!(&expr)\n-            sn let   let\n-            sn letm  let mut\n-            sn match match expr {}\n-            sn ref   &expr\n-            sn refm  &mut expr\n+            me foo()  fn(&self)\n+            sn box    Box::new(expr)\n+            sn call   function(expr)\n+            sn dbg    dbg!(expr)\n+            sn dbgr   dbg!(&expr)\n+            sn let    let\n+            sn letm   let mut\n+            sn match  match expr {}\n+            sn ref    &expr\n+            sn refm   &mut expr\n+            sn unsafe unsafe {}\n         \"#]],\n     )\n }\n@@ -118,16 +121,47 @@ impl Foo {\n fn main() {}\n \"#,\n         expect![[r#\"\n-            me foo() fn(&self)\n-            sn box   Box::new(expr)\n-            sn call  function(expr)\n-            sn dbg   dbg!(expr)\n-            sn dbgr  dbg!(&expr)\n-            sn let   let\n-            sn letm  let mut\n-            sn match match expr {}\n-            sn ref   &expr\n-            sn refm  &mut expr\n+            me foo()  fn(&self)\n+            sn box    Box::new(expr)\n+            sn call   function(expr)\n+            sn dbg    dbg!(expr)\n+            sn dbgr   dbg!(&expr)\n+            sn let    let\n+            sn letm   let mut\n+            sn match  match expr {}\n+            sn ref    &expr\n+            sn refm   &mut expr\n+            sn unsafe unsafe {}\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn issue_13836_str() {\n+    check(\n+        r#\"\n+//- proc_macros: shorten\n+fn main() {\n+    let s = proc_macros::shorten!(\"text.$0\");\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    )\n+}\n+\n+#[test]\n+fn issue_13836_ident() {\n+    check(\n+        r#\"\n+//- proc_macros: shorten\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn main() {\n+    let s = proc_macros::shorten!(S.fo$0);\n+}\n+\"#,\n+        expect![[r#\"\"#]],\n+    )\n+}"}, {"sha": "6052b0623204e56283c7e9efbb8db5c3f586263c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -61,7 +61,7 @@ fn _alpha() {}\n fn completes_prelude() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n fn foo() { let x: $0 }\n \n //- /std/lib.rs crate:std\n@@ -83,7 +83,7 @@ pub mod prelude {\n fn completes_prelude_macros() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs edition:2018 crate:main deps:std\n fn f() {$0}\n \n //- /std/lib.rs crate:std\n@@ -117,14 +117,14 @@ fn foo() { let x: $0 }\n \n //- /core/lib.rs crate:core\n pub mod prelude {\n-    pub mod rust_2018 {\n+    pub mod rust_2021 {\n         pub struct Option;\n     }\n }\n \n //- /std/lib.rs crate:std deps:core\n pub mod prelude {\n-    pub mod rust_2018 {\n+    pub mod rust_2021 {\n         pub struct String;\n     }\n }"}, {"sha": "9672bb9b7b59a2fdaf86a16043fcc0a842fed6e8", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,39 +2,44 @@\n name = \"ide-db\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n tracing = \"0.1.35\"\n-rayon = \"1.5.3\"\n+rayon = \"1.6.1\"\n fst = { version = \"0.4.7\", default-features = false }\n rustc-hash = \"1.1.0\"\n-once_cell = \"1.15.0\"\n+once_cell = \"1.17.0\"\n either = \"1.7.0\"\n itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n indexmap = \"1.9.1\"\n memchr = \"2.5.0\"\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-parser = { path = \"../parser\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n-base-db = { path = \"../base-db\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n+# local deps\n+base-db.workspace = true\n+limit.workspace = true\n+parser.workspace = true\n+profile.workspace = true\n+stdx.workspace = true\n+syntax.workspace = true\n+text-edit.workspace = true\n # ide should depend only on the top-level `hir` package. if you need\n # something from some `hir-xxx` subpackage, reexport the API via `hir`.\n-hir = { path = \"../hir\", version = \"0.0.0\" }\n-limit = { path = \"../limit\", version = \"0.0.0\" }\n+hir.workspace = true\n \n [dev-dependencies]\n-test-utils = { path = \"../test-utils\" }\n-sourcegen = { path = \"../sourcegen\" }\n xshell = \"0.2.2\"\n expect-test = \"1.4.0\"\n+\n+# local deps\n+test-utils.workspace = true\n+sourcegen.workspace = true"}, {"sha": "ed7f04fd8e7fe56e9e86b8449e26b559506bb857", "filename": "src/tools/rust-analyzer/crates/ide-db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -34,8 +34,8 @@ pub enum Definition {\n     TypeAlias(TypeAlias),\n     BuiltinType(BuiltinType),\n     SelfType(Impl),\n-    Local(Local),\n     GenericParam(GenericParam),\n+    Local(Local),\n     Label(Label),\n     DeriveHelper(DeriveHelper),\n     BuiltinAttr(BuiltinAttr),"}, {"sha": "8f12ab334094a6d444ecca91a26bcc4b47152724", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -185,14 +185,14 @@ mod tests {\n         ];\n \n         let index = LineIndex::new(text);\n-        for &(offset, line, col) in &table {\n+        for (offset, line, col) in table {\n             assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n         }\n \n         let text = \"\\nhello\\nworld\";\n         let table = [(0, 0, 0), (1, 1, 0), (2, 1, 1), (6, 1, 5), (7, 2, 0)];\n         let index = LineIndex::new(text);\n-        for &(offset, line, col) in &table {\n+        for (offset, line, col) in table {\n             assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n         }\n     }"}, {"sha": "6402a84a68bb350045286fba2896bd694c94766d", "filename": "src/tools/rust-analyzer/crates/ide-db/src/path_transform.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fpath_transform.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -33,7 +33,7 @@ use syntax::{\n /// }\n /// ```\n pub struct PathTransform<'a> {\n-    generic_def: hir::GenericDef,\n+    generic_def: Option<hir::GenericDef>,\n     substs: Vec<ast::Type>,\n     target_scope: &'a SemanticsScope<'a>,\n     source_scope: &'a SemanticsScope<'a>,\n@@ -49,7 +49,7 @@ impl<'a> PathTransform<'a> {\n         PathTransform {\n             source_scope,\n             target_scope,\n-            generic_def: trait_.into(),\n+            generic_def: Some(trait_.into()),\n             substs: get_syntactic_substs(impl_).unwrap_or_default(),\n         }\n     }\n@@ -63,28 +63,42 @@ impl<'a> PathTransform<'a> {\n         PathTransform {\n             source_scope,\n             target_scope,\n-            generic_def: function.into(),\n+            generic_def: Some(function.into()),\n             substs: get_type_args_from_arg_list(generic_arg_list).unwrap_or_default(),\n         }\n     }\n \n+    pub fn generic_transformation(\n+        target_scope: &'a SemanticsScope<'a>,\n+        source_scope: &'a SemanticsScope<'a>,\n+    ) -> PathTransform<'a> {\n+        PathTransform { source_scope, target_scope, generic_def: None, substs: Vec::new() }\n+    }\n+\n     pub fn apply(&self, syntax: &SyntaxNode) {\n         self.build_ctx().apply(syntax)\n     }\n \n+    pub fn apply_all<'b>(&self, nodes: impl IntoIterator<Item = &'b SyntaxNode>) {\n+        let ctx = self.build_ctx();\n+        for node in nodes {\n+            ctx.apply(node);\n+        }\n+    }\n+\n     fn build_ctx(&self) -> Ctx<'a> {\n         let db = self.source_scope.db;\n         let target_module = self.target_scope.module();\n         let source_module = self.source_scope.module();\n         let skip = match self.generic_def {\n             // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n-            hir::GenericDef::Trait(_) => 1,\n+            Some(hir::GenericDef::Trait(_)) => 1,\n             _ => 0,\n         };\n         let substs_by_param: FxHashMap<_, _> = self\n             .generic_def\n-            .type_params(db)\n             .into_iter()\n+            .flat_map(|it| it.type_params(db))\n             .skip(skip)\n             // The actual list of trait type parameters may be longer than the one\n             // used in the `impl` block due to trailing default type parameters."}, {"sha": "84d70b258ff86537432be125fe2ab3523302b539", "filename": "src/tools/rust-analyzer/crates/ide-db/src/rename.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Frename.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -190,6 +190,7 @@ fn rename_mod(\n \n     let InFile { file_id, value: def_source } = module.definition_source(sema.db);\n     if let ModuleSource::SourceFile(..) = def_source {\n+        let new_name = new_name.trim_start_matches(\"r#\");\n         let anchor = file_id.original_file(sema.db);\n \n         let is_mod_rs = module.is_mod_rs(sema.db);\n@@ -207,9 +208,13 @@ fn rename_mod(\n         //  - Module has submodules defined in separate files\n         let dir_paths = match (is_mod_rs, has_detached_child, module.name(sema.db)) {\n             // Go up one level since the anchor is inside the dir we're trying to rename\n-            (true, _, Some(mod_name)) => Some((format!(\"../{mod_name}\"), format!(\"../{new_name}\"))),\n+            (true, _, Some(mod_name)) => {\n+                Some((format!(\"../{}\", mod_name.unescaped()), format!(\"../{new_name}\")))\n+            }\n             // The anchor is on the same level as target dir\n-            (false, true, Some(mod_name)) => Some((mod_name.to_string(), new_name.to_string())),\n+            (false, true, Some(mod_name)) => {\n+                Some((mod_name.unescaped().to_string(), new_name.to_string()))\n+            }\n             _ => None,\n         };\n \n@@ -263,11 +268,10 @@ fn rename_reference(\n         Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n     ) {\n         match ident_kind {\n-            IdentifierKind::Ident | IdentifierKind::Underscore => {\n-                cov_mark::hit!(rename_not_a_lifetime_ident_ref);\n+            IdentifierKind::Underscore => {\n                 bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name);\n             }\n-            IdentifierKind::Lifetime => cov_mark::hit!(rename_lifetime),\n+            _ => cov_mark::hit!(rename_lifetime),\n         }\n     } else {\n         match ident_kind {\n@@ -334,11 +338,17 @@ pub fn source_edit_from_references(\n             }\n             _ => false,\n         };\n-        if !has_emitted_edit {\n-            if !edited_ranges.contains(&range.start()) {\n-                edit.replace(range, new_name.to_string());\n-                edited_ranges.push(range.start());\n-            }\n+        if !has_emitted_edit && !edited_ranges.contains(&range.start()) {\n+            let (range, new_name) = match name {\n+                ast::NameLike::Lifetime(_) => (\n+                    TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n+                    new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n+                ),\n+                _ => (range, new_name.to_owned()),\n+            };\n+\n+            edit.replace(range, new_name);\n+            edited_ranges.push(range.start());\n         }\n     }\n \n@@ -391,19 +401,17 @@ fn source_edit_from_name_ref(\n                         edit.delete(TextRange::new(s, e));\n                         return true;\n                     }\n-                } else if init == name_ref {\n-                    if field_name.text() == new_name {\n-                        cov_mark::hit!(test_rename_local_put_init_shorthand);\n-                        // Foo { field: local } -> Foo { field }\n-                        //            ^^^^^^^ delete this\n-\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().end();\n-                        let e = init.syntax().text_range().end();\n-                        edit.delete(TextRange::new(s, e));\n-                        return true;\n-                    }\n+                } else if init == name_ref && field_name.text() == new_name {\n+                    cov_mark::hit!(test_rename_local_put_init_shorthand);\n+                    // Foo { field: local } -> Foo { field }\n+                    //            ^^^^^^^ delete this\n+\n+                    // same names, we can use a shorthand here instead.\n+                    // we do not want to erase attributes hence this range start\n+                    let s = field_name.syntax().text_range().end();\n+                    let e = init.syntax().text_range().end();\n+                    edit.delete(TextRange::new(s, e));\n+                    return true;\n                 }\n             }\n             // init shorthand\n@@ -505,7 +513,15 @@ fn source_edit_from_def(\n         }\n     }\n     if edit.is_empty() {\n-        edit.replace(range, new_name.to_string());\n+        let (range, new_name) = match def {\n+            Definition::GenericParam(hir::GenericParam::LifetimeParam(_))\n+            | Definition::Label(_) => (\n+                TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n+                new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n+            ),\n+            _ => (range, new_name.to_owned()),\n+        };\n+        edit.replace(range, new_name);\n     }\n     Ok((file_id, edit.finish()))\n }\n@@ -521,14 +537,18 @@ impl IdentifierKind {\n     pub fn classify(new_name: &str) -> Result<IdentifierKind> {\n         match parser::LexedStr::single_token(new_name) {\n             Some(res) => match res {\n-                (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n+                (SyntaxKind::IDENT, _) => {\n+                    if let Some(inner) = new_name.strip_prefix(\"r#\") {\n+                        if matches!(inner, \"self\" | \"crate\" | \"super\" | \"Self\") {\n+                            bail!(\"Invalid name: `{}` cannot be a raw identifier\", inner);\n+                        }\n+                    }\n+                    Ok(IdentifierKind::Ident)\n+                }\n                 (T![_], _) => Ok(IdentifierKind::Underscore),\n                 (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n                     Ok(IdentifierKind::Lifetime)\n                 }\n-                (SyntaxKind::LIFETIME_IDENT, _) => {\n-                    bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n-                }\n                 (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n                 (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n             },"}, {"sha": "ada2821d6b14e7279a1567f4aa30107c0a63ea78", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -7,7 +7,9 @@\n use std::{mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n-use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n+use hir::{\n+    AsAssocItem, DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility,\n+};\n use memchr::memmem::Finder;\n use once_cell::unsync::Lazy;\n use parser::SyntaxKind;\n@@ -311,15 +313,15 @@ impl Definition {\n \n     pub fn usages<'a>(self, sema: &'a Semantics<'_, RootDatabase>) -> FindUsages<'a> {\n         FindUsages {\n-            local_repr: match self {\n-                Definition::Local(local) => Some(local.representative(sema.db)),\n-                _ => None,\n-            },\n             def: self,\n-            trait_assoc_def: as_trait_assoc_def(sema.db, self),\n+            assoc_item_container: self.as_assoc_item(sema.db).map(|a| a.container(sema.db)),\n             sema,\n             scope: None,\n             include_self_kw_refs: None,\n+            local_repr: match self {\n+                Definition::Local(local) => Some(local.representative(sema.db)),\n+                _ => None,\n+            },\n             search_self_mod: false,\n         }\n     }\n@@ -328,12 +330,16 @@ impl Definition {\n #[derive(Clone)]\n pub struct FindUsages<'a> {\n     def: Definition,\n-    /// If def is an assoc item from a trait or trait impl, this is the corresponding item of the trait definition\n-    trait_assoc_def: Option<Definition>,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n+    /// The container of our definition should it be an assoc item\n+    assoc_item_container: Option<hir::AssocItemContainer>,\n+    /// whether to search for the `Self` type of the definition\n     include_self_kw_refs: Option<hir::Type>,\n+    /// the local representative for the local definition we are searching for\n+    /// (this is required for finding all local declarations in a or-pattern)\n     local_repr: Option<hir::Local>,\n+    /// whether to search for the `self` module\n     search_self_mod: bool,\n }\n \n@@ -380,7 +386,9 @@ impl<'a> FindUsages<'a> {\n         let sema = self.sema;\n \n         let search_scope = {\n-            let base = self.trait_assoc_def.unwrap_or(self.def).search_scope(sema.db);\n+            // FIXME: Is the trait scope needed for trait impl assoc items?\n+            let base =\n+                as_trait_assoc_def(sema.db, self.def).unwrap_or(self.def).search_scope(sema.db);\n             match &self.scope {\n                 None => base,\n                 Some(scope) => base.intersection(scope),\n@@ -494,41 +502,37 @@ impl<'a> FindUsages<'a> {\n         }\n \n         // Search for `super` and `crate` resolving to our module\n-        match self.def {\n-            Definition::Module(module) => {\n-                let scope = search_scope\n-                    .intersection(&SearchScope::module_and_children(self.sema.db, module));\n+        if let Definition::Module(module) = self.def {\n+            let scope =\n+                search_scope.intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n-                let is_crate_root =\n-                    module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n-                let finder = &Finder::new(\"super\");\n+            let is_crate_root = module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n+            let finder = &Finder::new(\"super\");\n \n-                for (text, file_id, search_range) in scope_files(sema, &scope) {\n-                    let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n+            for (text, file_id, search_range) in scope_files(sema, &scope) {\n+                let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n+                for offset in match_indices(&text, finder, search_range) {\n+                    if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n+                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                            if self.found_name_ref(&name_ref, sink) {\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(finder) = &is_crate_root {\n                     for offset in match_indices(&text, finder, search_range) {\n-                        if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n+                        if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n                             for name_ref in iter.filter_map(ast::NameRef::cast) {\n                                 if self.found_name_ref(&name_ref, sink) {\n                                     return;\n                                 }\n                             }\n                         }\n                     }\n-                    if let Some(finder) = &is_crate_root {\n-                        for offset in match_indices(&text, finder, search_range) {\n-                            if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n-                                for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                                    if self.found_name_ref(&name_ref, sink) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n                 }\n             }\n-            _ => (),\n         }\n \n         // search for module `self` references in our module's definition source\n@@ -655,13 +659,26 @@ impl<'a> FindUsages<'a> {\n                 sink(file_id, reference)\n             }\n             Some(NameRefClass::Definition(def))\n-                if match self.trait_assoc_def {\n-                    Some(trait_assoc_def) => {\n-                        // we have a trait assoc item, so force resolve all assoc items to their trait version\n-                        convert_to_def_in_trait(self.sema.db, def) == trait_assoc_def\n-                    }\n-                    None => self.def == def,\n-                } =>\n+                if self.def == def\n+                    // is our def a trait assoc item? then we want to find all assoc items from trait impls of our trait\n+                    || matches!(self.assoc_item_container, Some(hir::AssocItemContainer::Trait(_)))\n+                        && convert_to_def_in_trait(self.sema.db, def) == self.def =>\n+            {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    category: ReferenceCategory::new(&def, name_ref),\n+                };\n+                sink(file_id, reference)\n+            }\n+            // FIXME: special case type aliases, we can't filter between impl and trait defs here as we lack the substitutions\n+            // so we always resolve all assoc type aliases to both their trait def and impl defs\n+            Some(NameRefClass::Definition(def))\n+                if self.assoc_item_container.is_some()\n+                    && matches!(self.def, Definition::TypeAlias(_))\n+                    && convert_to_def_in_trait(self.sema.db, def)\n+                        == convert_to_def_in_trait(self.sema.db, self.def) =>\n             {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n@@ -752,13 +769,21 @@ impl<'a> FindUsages<'a> {\n                 false\n             }\n             Some(NameClass::Definition(def)) if def != self.def => {\n-                // if the def we are looking for is a trait (impl) assoc item, we'll have to resolve the items to trait definition assoc item\n-                if !matches!(\n-                    self.trait_assoc_def,\n-                    Some(trait_assoc_def)\n-                        if convert_to_def_in_trait(self.sema.db, def) == trait_assoc_def\n-                ) {\n-                    return false;\n+                match (&self.assoc_item_container, self.def) {\n+                    // for type aliases we always want to reference the trait def and all the trait impl counterparts\n+                    // FIXME: only until we can resolve them correctly, see FIXME above\n+                    (Some(_), Definition::TypeAlias(_))\n+                        if convert_to_def_in_trait(self.sema.db, def)\n+                            != convert_to_def_in_trait(self.sema.db, self.def) =>\n+                    {\n+                        return false\n+                    }\n+                    (Some(_), Definition::TypeAlias(_)) => {}\n+                    // We looking at an assoc item of a trait definition, so reference all the\n+                    // corresponding assoc items belonging to this trait's trait implementations\n+                    (Some(hir::AssocItemContainer::Trait(_)), _)\n+                        if convert_to_def_in_trait(self.sema.db, def) == self.def => {}\n+                    _ => return false,\n                 }\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n                 let reference = FileReference {"}, {"sha": "a91ffd1ec4fd17fc9293775f4bc4b253ab6f46a4", "filename": "src/tools/rust-analyzer/crates/ide-db/src/symbol_index.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsymbol_index.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -323,10 +323,10 @@ impl Query {\n                         if symbol.name != self.query {\n                             continue;\n                         }\n-                    } else if self.case_sensitive {\n-                        if self.query.chars().any(|c| !symbol.name.contains(c)) {\n-                            continue;\n-                        }\n+                    } else if self.case_sensitive\n+                        && self.query.chars().any(|c| !symbol.name.contains(c))\n+                    {\n+                        continue;\n                     }\n \n                     res.push(symbol.clone());"}, {"sha": "e18624fcc267e706d3cd2d40a677a8ea94b8de55", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/Cargo.toml", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"ide-diagnostics\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -15,19 +17,21 @@ either = \"1.7.0\"\n itertools = \"0.10.5\"\n serde_json = \"1.0.86\"\n \n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n-cfg = { path = \"../cfg\", version = \"0.0.0\" }\n-hir = { path = \"../hir\", version = \"0.0.0\" }\n-ide-db = { path = \"../ide-db\", version = \"0.0.0\" }\n+# local deps\n+profile.workspace = true\n+stdx.workspace = true\n+syntax.workspace = true\n+text-edit.workspace = true\n+cfg.workspace = true\n+hir.workspace = true\n+ide-db.workspace = true\n \n [dev-dependencies]\n expect-test = \"1.4.0\"\n \n-test-utils = { path = \"../test-utils\" }\n-sourcegen = { path = \"../sourcegen\" }\n+# local deps\n+test-utils.workspace = true\n+sourcegen.workspace = true\n \n [features]\n in-rust-tree = []"}, {"sha": "04ce1e0feeed4f300f27807d19c3e5bf97cf1738", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/json_is_not_rust.rs", "status": "modified", "additions": 56, "deletions": 66, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -99,76 +99,66 @@ pub(crate) fn json_in_items(\n             && node.last_token().map(|x| x.kind()) == Some(SyntaxKind::R_CURLY)\n         {\n             let node_string = node.to_string();\n-            if let Ok(it) = serde_json::from_str(&node_string) {\n-                if let serde_json::Value::Object(it) = it {\n-                    let import_scope = ImportScope::find_insert_use_container(node, sema)?;\n-                    let range = node.text_range();\n-                    let mut edit = TextEdit::builder();\n-                    edit.delete(range);\n-                    let mut state = State::default();\n-                    let semantics_scope = sema.scope(node)?;\n-                    let scope_resolve =\n-                        |it| semantics_scope.speculative_resolve(&make::path_from_text(it));\n-                    let scope_has = |it| scope_resolve(it).is_some();\n-                    let deserialize_resolved = scope_resolve(\"::serde::Deserialize\");\n-                    let serialize_resolved = scope_resolve(\"::serde::Serialize\");\n-                    state.has_deserialize = deserialize_resolved.is_some();\n-                    state.has_serialize = serialize_resolved.is_some();\n-                    state.build_struct(&it);\n-                    edit.insert(range.start(), state.result);\n-                    acc.push(\n-                        Diagnostic::new(\n-                            \"json-is-not-rust\",\n-                            \"JSON syntax is not valid as a Rust item\",\n-                            range,\n-                        )\n-                        .severity(Severity::WeakWarning)\n-                        .with_fixes(Some(vec![{\n-                            let mut scb = SourceChangeBuilder::new(file_id);\n-                            let scope = match import_scope {\n-                                ImportScope::File(it) => ImportScope::File(scb.make_mut(it)),\n-                                ImportScope::Module(it) => ImportScope::Module(scb.make_mut(it)),\n-                                ImportScope::Block(it) => ImportScope::Block(scb.make_mut(it)),\n-                            };\n-                            let current_module = semantics_scope.module();\n-                            if !scope_has(\"Serialize\") {\n-                                if let Some(PathResolution::Def(it)) = serialize_resolved {\n-                                    if let Some(it) = current_module.find_use_path_prefixed(\n-                                        sema.db,\n-                                        it,\n-                                        config.insert_use.prefix_kind,\n-                                        config.prefer_no_std,\n-                                    ) {\n-                                        insert_use(\n-                                            &scope,\n-                                            mod_path_to_ast(&it),\n-                                            &config.insert_use,\n-                                        );\n-                                    }\n+            if let Ok(serde_json::Value::Object(it)) = serde_json::from_str(&node_string) {\n+                let import_scope = ImportScope::find_insert_use_container(node, sema)?;\n+                let range = node.text_range();\n+                let mut edit = TextEdit::builder();\n+                edit.delete(range);\n+                let mut state = State::default();\n+                let semantics_scope = sema.scope(node)?;\n+                let scope_resolve =\n+                    |it| semantics_scope.speculative_resolve(&make::path_from_text(it));\n+                let scope_has = |it| scope_resolve(it).is_some();\n+                let deserialize_resolved = scope_resolve(\"::serde::Deserialize\");\n+                let serialize_resolved = scope_resolve(\"::serde::Serialize\");\n+                state.has_deserialize = deserialize_resolved.is_some();\n+                state.has_serialize = serialize_resolved.is_some();\n+                state.build_struct(&it);\n+                edit.insert(range.start(), state.result);\n+                acc.push(\n+                    Diagnostic::new(\n+                        \"json-is-not-rust\",\n+                        \"JSON syntax is not valid as a Rust item\",\n+                        range,\n+                    )\n+                    .severity(Severity::WeakWarning)\n+                    .with_fixes(Some(vec![{\n+                        let mut scb = SourceChangeBuilder::new(file_id);\n+                        let scope = match import_scope {\n+                            ImportScope::File(it) => ImportScope::File(scb.make_mut(it)),\n+                            ImportScope::Module(it) => ImportScope::Module(scb.make_mut(it)),\n+                            ImportScope::Block(it) => ImportScope::Block(scb.make_mut(it)),\n+                        };\n+                        let current_module = semantics_scope.module();\n+                        if !scope_has(\"Serialize\") {\n+                            if let Some(PathResolution::Def(it)) = serialize_resolved {\n+                                if let Some(it) = current_module.find_use_path_prefixed(\n+                                    sema.db,\n+                                    it,\n+                                    config.insert_use.prefix_kind,\n+                                    config.prefer_no_std,\n+                                ) {\n+                                    insert_use(&scope, mod_path_to_ast(&it), &config.insert_use);\n                                 }\n                             }\n-                            if !scope_has(\"Deserialize\") {\n-                                if let Some(PathResolution::Def(it)) = deserialize_resolved {\n-                                    if let Some(it) = current_module.find_use_path_prefixed(\n-                                        sema.db,\n-                                        it,\n-                                        config.insert_use.prefix_kind,\n-                                        config.prefer_no_std,\n-                                    ) {\n-                                        insert_use(\n-                                            &scope,\n-                                            mod_path_to_ast(&it),\n-                                            &config.insert_use,\n-                                        );\n-                                    }\n+                        }\n+                        if !scope_has(\"Deserialize\") {\n+                            if let Some(PathResolution::Def(it)) = deserialize_resolved {\n+                                if let Some(it) = current_module.find_use_path_prefixed(\n+                                    sema.db,\n+                                    it,\n+                                    config.insert_use.prefix_kind,\n+                                    config.prefer_no_std,\n+                                ) {\n+                                    insert_use(&scope, mod_path_to_ast(&it), &config.insert_use);\n                                 }\n                             }\n-                            let mut sc = scb.finish();\n-                            sc.insert_source_edit(file_id, edit.finish());\n-                            fix(\"convert_json_to_struct\", \"Convert JSON to struct\", sc, range)\n-                        }])),\n-                    );\n-                }\n+                        }\n+                        let mut sc = scb.finish();\n+                        sc.insert_source_edit(file_id, edit.finish());\n+                        fix(\"convert_json_to_struct\", \"Convert JSON to struct\", sc, range)\n+                    }])),\n+                );\n             }\n         }\n         Some(())"}, {"sha": "0b3121c765d8d2448f283a21d7d10259623c44e8", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/private_assoc_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -11,10 +11,7 @@ pub(crate) fn private_assoc_item(\n     d: &hir::PrivateAssocItem,\n ) -> Diagnostic {\n     // FIXME: add quickfix\n-    let name = match d.item.name(ctx.sema.db) {\n-        Some(name) => format!(\"`{}` \", name),\n-        None => String::new(),\n-    };\n+    let name = d.item.name(ctx.sema.db).map(|name| format!(\"`{name}` \")).unwrap_or_default();\n     Diagnostic::new(\n         \"private-assoc-item\",\n         format!("}, {"sha": "3d45a75913ad8f68d9591902e869a8cd17ce8381", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 179, "deletions": 51, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1,13 +1,15 @@\n //! Diagnostic emitted for files that aren't part of any crate.\n \n-use hir::db::DefDatabase;\n+use std::iter;\n+\n+use hir::{db::DefDatabase, InFile, ModuleSource};\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n     RootDatabase,\n };\n use syntax::{\n-    ast::{self, HasModuleItem, HasName},\n+    ast::{self, edit::IndentLevel, HasModuleItem, HasName},\n     AstNode, TextRange, TextSize,\n };\n use text_edit::TextEdit;\n@@ -42,47 +44,99 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n \n     let source_root = ctx.sema.db.source_root(ctx.sema.db.file_source_root(file_id));\n     let our_path = source_root.path_for_file(&file_id)?;\n-    let (mut module_name, _) = our_path.name_and_extension()?;\n-\n-    // Candidates to look for:\n-    // - `mod.rs`, `main.rs` and `lib.rs` in the same folder\n-    // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n     let parent = our_path.parent()?;\n-    let paths = {\n-        let parent = if module_name == \"mod\" {\n-            // for mod.rs we need to actually look up one higher\n-            // and take the parent as our to be module name\n-            let (name, _) = parent.name_and_extension()?;\n-            module_name = name;\n-            parent.parent()?\n-        } else {\n-            parent\n-        };\n-        let mut paths =\n-            vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];\n-\n-        // `submod/bla.rs` -> `submod.rs`\n-        let parent_mod = (|| {\n+    let (module_name, _) = our_path.name_and_extension()?;\n+    let (parent, module_name) = match module_name {\n+        // for mod.rs we need to actually look up one higher\n+        // and take the parent as our to be module name\n+        \"mod\" => {\n             let (name, _) = parent.name_and_extension()?;\n-            parent.parent()?.join(&format!(\"{name}.rs\"))\n-        })();\n-        paths.extend(parent_mod);\n-        paths\n+            (parent.parent()?, name.to_owned())\n+        }\n+        _ => (parent, module_name.to_owned()),\n     };\n \n-    for &parent_id in paths.iter().filter_map(|path| source_root.file_for_path(path)) {\n-        for &krate in ctx.sema.db.relevant_crates(parent_id).iter() {\n-            let crate_def_map = ctx.sema.db.crate_def_map(krate);\n-            for (_, module) in crate_def_map.modules() {\n-                if module.origin.is_inline() {\n-                    // We don't handle inline `mod parent {}`s, they use different paths.\n-                    continue;\n-                }\n+    // check crate roots, i.e. main.rs, lib.rs, ...\n+    'crates: for &krate in &*ctx.sema.db.relevant_crates(file_id) {\n+        let crate_def_map = ctx.sema.db.crate_def_map(krate);\n+\n+        let root_module = &crate_def_map[crate_def_map.root()];\n+        let Some(root_file_id) = root_module.origin.file_id() else { continue };\n+        let Some(crate_root_path) = source_root.path_for_file(&root_file_id) else { continue };\n+        let Some(rel) = parent.strip_prefix(&crate_root_path.parent()?) else { continue };\n+\n+        // try resolving the relative difference of the paths as inline modules\n+        let mut current = root_module;\n+        for ele in rel.as_ref().components() {\n+            let seg = match ele {\n+                std::path::Component::Normal(seg) => seg.to_str()?,\n+                std::path::Component::RootDir => continue,\n+                // shouldn't occur\n+                _ => continue 'crates,\n+            };\n+            match current.children.iter().find(|(name, _)| name.to_smol_str() == seg) {\n+                Some((_, &child)) => current = &crate_def_map[child],\n+                None => continue 'crates,\n+            }\n+            if !current.origin.is_inline() {\n+                continue 'crates;\n+            }\n+        }\n+\n+        let InFile { file_id: parent_file_id, value: source } =\n+            current.definition_source(ctx.sema.db);\n+        let parent_file_id = parent_file_id.file_id()?;\n+        return make_fixes(ctx.sema.db, parent_file_id, source, &module_name, file_id);\n+    }\n \n-                if module.origin.file_id() == Some(parent_id) {\n-                    return make_fixes(ctx.sema.db, parent_id, module_name, file_id);\n+    // if we aren't adding to a crate root, walk backwards such that we support `#[path = ...]` overrides if possible\n+\n+    // build all parent paths of the form `../module_name/mod.rs` and `../module_name.rs`\n+    let paths = iter::successors(Some(parent.clone()), |prev| prev.parent()).filter_map(|path| {\n+        let parent = path.parent()?;\n+        let (name, _) = path.name_and_extension()?;\n+        Some(([parent.join(&format!(\"{name}.rs\"))?, path.join(\"mod.rs\")?], name.to_owned()))\n+    });\n+    let mut stack = vec![];\n+    let &parent_id =\n+        paths.inspect(|(_, name)| stack.push(name.clone())).find_map(|(paths, _)| {\n+            paths.into_iter().find_map(|path| source_root.file_for_path(&path))\n+        })?;\n+    stack.pop();\n+    'crates: for &krate in ctx.sema.db.relevant_crates(parent_id).iter() {\n+        let crate_def_map = ctx.sema.db.crate_def_map(krate);\n+        let Some((_, module)) =\n+            crate_def_map.modules()\n+            .find(|(_, module)| module.origin.file_id() == Some(parent_id) && !module.origin.is_inline())\n+        else { continue };\n+\n+        if stack.is_empty() {\n+            return make_fixes(\n+                ctx.sema.db,\n+                parent_id,\n+                module.definition_source(ctx.sema.db).value,\n+                &module_name,\n+                file_id,\n+            );\n+        } else {\n+            // direct parent file is missing,\n+            // try finding a parent that has an inline tree from here on\n+            let mut current = module;\n+            for s in stack.iter().rev() {\n+                match module.children.iter().find(|(name, _)| name.to_smol_str() == s) {\n+                    Some((_, child)) => {\n+                        current = &crate_def_map[*child];\n+                    }\n+                    None => continue 'crates,\n+                }\n+                if !current.origin.is_inline() {\n+                    continue 'crates;\n                 }\n             }\n+            let InFile { file_id: parent_file_id, value: source } =\n+                current.definition_source(ctx.sema.db);\n+            let parent_file_id = parent_file_id.file_id()?;\n+            return make_fixes(ctx.sema.db, parent_file_id, source, &module_name, file_id);\n         }\n     }\n \n@@ -92,6 +146,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n fn make_fixes(\n     db: &RootDatabase,\n     parent_file_id: FileId,\n+    source: ModuleSource,\n     new_mod_name: &str,\n     added_file_id: FileId,\n ) -> Option<Vec<Assist>> {\n@@ -102,14 +157,18 @@ fn make_fixes(\n     let mod_decl = format!(\"mod {new_mod_name};\");\n     let pub_mod_decl = format!(\"pub mod {new_mod_name};\");\n \n-    let ast: ast::SourceFile = db.parse(parent_file_id).tree();\n-\n     let mut mod_decl_builder = TextEdit::builder();\n     let mut pub_mod_decl_builder = TextEdit::builder();\n \n+    let mut items = match &source {\n+        ModuleSource::SourceFile(it) => it.items(),\n+        ModuleSource::Module(it) => it.item_list()?.items(),\n+        ModuleSource::BlockExpr(_) => return None,\n+    };\n+\n     // If there's an existing `mod m;` statement matching the new one, don't emit a fix (it's\n     // probably `#[cfg]`d out).\n-    for item in ast.items() {\n+    for item in items.clone() {\n         if let ast::Item::Module(m) = item {\n             if let Some(name) = m.name() {\n                 if m.item_list().is_none() && name.to_string() == new_mod_name {\n@@ -121,28 +180,40 @@ fn make_fixes(\n     }\n \n     // If there are existing `mod m;` items, append after them (after the first group of them, rather).\n-    match ast.items().skip_while(|item| !is_outline_mod(item)).take_while(is_outline_mod).last() {\n+    match items.clone().skip_while(|item| !is_outline_mod(item)).take_while(is_outline_mod).last() {\n         Some(last) => {\n             cov_mark::hit!(unlinked_file_append_to_existing_mods);\n             let offset = last.syntax().text_range().end();\n-            mod_decl_builder.insert(offset, format!(\"\\n{mod_decl}\"));\n-            pub_mod_decl_builder.insert(offset, format!(\"\\n{pub_mod_decl}\"));\n+            let indent = IndentLevel::from_node(last.syntax());\n+            mod_decl_builder.insert(offset, format!(\"\\n{indent}{mod_decl}\"));\n+            pub_mod_decl_builder.insert(offset, format!(\"\\n{indent}{pub_mod_decl}\"));\n         }\n         None => {\n             // Prepend before the first item in the file.\n-            match ast.items().next() {\n-                Some(item) => {\n+            match items.next() {\n+                Some(first) => {\n                     cov_mark::hit!(unlinked_file_prepend_before_first_item);\n-                    let offset = item.syntax().text_range().start();\n-                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\\n\"));\n-                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\\n\"));\n+                    let offset = first.syntax().text_range().start();\n+                    let indent = IndentLevel::from_node(first.syntax());\n+                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\\n{indent}\"));\n+                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\\n{indent}\"));\n                 }\n                 None => {\n                     // No items in the file, so just append at the end.\n                     cov_mark::hit!(unlinked_file_empty_file);\n-                    let offset = ast.syntax().text_range().end();\n-                    mod_decl_builder.insert(offset, format!(\"{mod_decl}\\n\"));\n-                    pub_mod_decl_builder.insert(offset, format!(\"{pub_mod_decl}\\n\"));\n+                    let mut indent = IndentLevel::from(0);\n+                    let offset = match &source {\n+                        ModuleSource::SourceFile(it) => it.syntax().text_range().end(),\n+                        ModuleSource::Module(it) => {\n+                            indent = IndentLevel::from_node(it.syntax()) + 1;\n+                            it.item_list()?.r_curly_token()?.text_range().start()\n+                        }\n+                        ModuleSource::BlockExpr(it) => {\n+                            it.stmt_list()?.r_curly_token()?.text_range().start()\n+                        }\n+                    };\n+                    mod_decl_builder.insert(offset, format!(\"{indent}{mod_decl}\\n\"));\n+                    pub_mod_decl_builder.insert(offset, format!(\"{indent}{pub_mod_decl}\\n\"));\n                 }\n             }\n         }\n@@ -167,7 +238,6 @@ fn make_fixes(\n \n #[cfg(test)]\n mod tests {\n-\n     use crate::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};\n \n     #[test]\n@@ -330,6 +400,64 @@ $0\n mod foo;\n \n //- /foo.rs\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar;\n+//- /bar.rs\n+mod foo {\n+}\n+//- /bar/foo/baz.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo {\n+    mod baz;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple_modrs() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar;\n+//- /bar.rs\n+mod baz {\n+}\n+//- /bar/baz/foo/mod.rs\n+$0\n+\"#,\n+            r#\"\n+mod baz {\n+    mod foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_into_inline_simple_modrs_main() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod bar {\n+}\n+//- /bar/foo/mod.rs\n+$0\n+\"#,\n+            r#\"\n+mod bar {\n+    mod foo;\n+}\n \"#,\n         );\n     }"}, {"sha": "9a984ba6bf07afadbe83427aa6e7aa0591664e78", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_proc_macro.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -34,10 +34,7 @@ pub(crate) fn unresolved_proc_macro(\n     let message = format!(\n         \"{message}: {}\",\n         if config_enabled {\n-            match def_map.proc_macro_loading_error() {\n-                Some(e) => e,\n-                None => \"proc macro not found in the built dylib\",\n-            }\n+            def_map.proc_macro_loading_error().unwrap_or(\"proc macro not found in the built dylib\")\n         } else {\n             match d.kind {\n                 hir::MacroKind::Attr if proc_macros_enabled => {"}, {"sha": "04efa7b91d8248f36ea13abb44de229269fd333d", "filename": "src/tools/rust-analyzer/crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,10 +2,12 @@\n name = \"ide-ssr\"\n version = \"0.0.0\"\n description = \"Structural search and replace of Rust code\"\n-license = \"MIT OR Apache-2.0\"\n repository = \"https://github.com/rust-lang/rust-analyzer\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -14,13 +16,16 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n \n-text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n-parser = { path = \"../parser\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-ide-db = { path = \"../ide-db\", version = \"0.0.0\" }\n-hir = { path = \"../hir\", version = \"0.0.0\" }\n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+# local deps\n+hir.workspace = true\n+ide-db.workspace = true\n+parser.workspace = true\n+stdx.workspace = true\n+syntax.workspace = true\n+text-edit.workspace = true\n \n [dev-dependencies]\n-test-utils = { path = \"../test-utils\" }\n expect-test = \"1.4.0\"\n+\n+# local deps\n+test-utils.workspace = true"}, {"sha": "414c08ff7e037f55571747497dd7ed96e77f1294", "filename": "src/tools/rust-analyzer/crates/ide/Cargo.toml", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"ide\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -20,28 +22,31 @@ pulldown-cmark-to-cmark = \"10.0.4\"\n pulldown-cmark = { version = \"0.9.1\", default-features = false }\n url = \"2.3.1\"\n dot = \"0.1.4\"\n+smallvec = \"1.10.0\"\n \n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n-ide-db = { path = \"../ide-db\", version = \"0.0.0\" }\n-cfg = { path = \"../cfg\", version = \"0.0.0\" }\n-profile = { path = \"../profile\", version = \"0.0.0\" }\n-ide-assists = { path = \"../ide-assists\", version = \"0.0.0\" }\n-ide-diagnostics = { path = \"../ide-diagnostics\", version = \"0.0.0\" }\n-ide-ssr = { path = \"../ide-ssr\", version = \"0.0.0\" }\n-ide-completion = { path = \"../ide-completion\", version = \"0.0.0\" }\n-\n+# local deps\n+cfg.workspace = true\n+ide-assists.workspace = true\n+ide-completion.workspace = true\n+ide-db.workspace = true\n+ide-diagnostics.workspace = true\n+ide-ssr.workspace = true\n+profile.workspace = true\n+stdx.workspace = true\n+syntax.workspace = true\n+text-edit.workspace = true\n # ide should depend only on the top-level `hir` package. if you need\n # something from some `hir-xxx` subpackage, reexport the API via `hir`.\n-hir = { path = \"../hir\", version = \"0.0.0\" }\n+hir.workspace = true\n \n [target.'cfg(not(any(target_arch = \"wasm32\", target_os = \"emscripten\")))'.dependencies]\n-toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n+toolchain.workspace = true\n \n [dev-dependencies]\n-test-utils = { path = \"../test-utils\" }\n expect-test = \"1.4.0\"\n \n+# local deps\n+test-utils.workspace = true\n+\n [features]\n in-rust-tree = [\"ide-assists/in-rust-tree\", \"ide-diagnostics/in-rust-tree\"]"}, {"sha": "b23763dce8679684ed1bc1500df8ae03a495983a", "filename": "src/tools/rust-analyzer/crates/ide/src/file_structure.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ffile_structure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ffile_structure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ffile_structure.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -160,7 +160,11 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n                 let label = match target_trait {\n                     None => format!(\"impl {}\", target_type.syntax().text()),\n                     Some(t) => {\n-                        format!(\"impl {} for {}\", t.syntax().text(), target_type.syntax().text(),)\n+                        format!(\"impl {}{} for {}\",\n+                            it.excl_token().map(|x| x.to_string()).unwrap_or_default(),\n+                            t.syntax().text(),\n+                            target_type.syntax().text(),\n+                        )\n                     }\n                 };\n \n@@ -213,6 +217,29 @@ mod tests {\n         expect.assert_debug_eq(&structure)\n     }\n \n+    #[test]\n+    fn test_nagative_trait_bound() {\n+        let txt = r#\"impl !Unpin for Test {}\"#;\n+        check(\n+            txt,\n+            expect![[r#\"\n+        [\n+            StructureNode {\n+                parent: None,\n+                label: \"impl !Unpin for Test\",\n+                navigation_range: 16..20,\n+                node_range: 0..23,\n+                kind: SymbolKind(\n+                    Impl,\n+                ),\n+                detail: None,\n+                deprecated: false,\n+            },\n+        ]\n+        \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_file_structure() {\n         check("}, {"sha": "e70bc2ec54172aa563a3068b7c6f09b47d414467", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_declaration.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_declaration.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -17,6 +17,7 @@ use crate::{\n // This is the same as `Go to Definition` with the following exceptions:\n // - outline modules will navigate to the `mod name;` item declaration\n // - trait assoc items will navigate to the assoc item of the trait declaration opposed to the trait impl\n+// - fields in patterns will navigate to the field declaration of the struct, union or variant\n pub(crate) fn goto_declaration(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "93019527f44da40a1a7136755e1d74b61d023a1a", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1916,4 +1916,68 @@ fn main() {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn query_impls_in_nearest_block() {\n+        check(\n+            r#\"\n+struct S1;\n+impl S1 {\n+    fn e() -> () {}\n+}\n+fn f1() {\n+    struct S1;\n+    impl S1 {\n+        fn e() -> () {}\n+         //^\n+    }\n+    fn f2() {\n+        fn f3() {\n+            S1::e$0();\n+        }\n+    }\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+struct S1;\n+impl S1 {\n+    fn e() -> () {}\n+}\n+fn f1() {\n+    struct S1;\n+    impl S1 {\n+        fn e() -> () {}\n+         //^\n+    }\n+    fn f2() {\n+        struct S2;\n+        S1::e$0();\n+    }\n+}\n+fn f12() {\n+    struct S1;\n+    impl S1 {\n+        fn e() -> () {}\n+    }\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+struct S1;\n+impl S1 {\n+    fn e() -> () {}\n+     //^\n+}\n+fn f2() {\n+    struct S2;\n+    S1::e$0();\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "c889eb930f30b4834e944b6155812dbff0b2d2bd", "filename": "src/tools/rust-analyzer/crates/ide/src/highlight_related.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1356,7 +1356,6 @@ fn main() {\n             r#\"\n trait Trait {\n     fn func(self) {}\n-     //^^^^\n }\n \n impl Trait for () {\n@@ -1376,7 +1375,6 @@ fn main() {\n             r#\"\n trait Trait {\n     fn func(self) {}\n-     //^^^^\n }\n \n impl Trait for () {"}, {"sha": "2058a4f5f190a239fb8d2817fd50b3b5f12916b5", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 71, "deletions": 95, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -15,25 +15,21 @@ use ide_db::{\n     FxIndexSet, RootDatabase,\n };\n use itertools::Itertools;\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, T};\n+use syntax::{ast, AstNode, SyntaxKind::*, SyntaxNode, T};\n \n use crate::{\n     doc_links::token_as_doc_comment,\n+    markdown_remove::remove_markdown,\n     markup::Markup,\n     runnables::{runnable_fn, runnable_mod},\n     FileId, FilePosition, NavigationTarget, RangeInfo, Runnable, TryToNav,\n };\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct HoverConfig {\n     pub links_in_hover: bool,\n-    pub documentation: Option<HoverDocFormat>,\n+    pub documentation: bool,\n     pub keywords: bool,\n-}\n-\n-impl HoverConfig {\n-    fn markdown(&self) -> bool {\n-        matches!(self.documentation, Some(HoverDocFormat::Markdown))\n-    }\n+    pub format: HoverDocFormat,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -90,19 +86,38 @@ pub struct HoverResult {\n // image::https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif[]\n pub(crate) fn hover(\n     db: &RootDatabase,\n-    FileRange { file_id, range }: FileRange,\n+    frange @ FileRange { file_id, range }: FileRange,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     let sema = &hir::Semantics::new(db);\n     let file = sema.parse(file_id).syntax().clone();\n+    let mut res = if range.is_empty() {\n+        hover_simple(sema, FilePosition { file_id, offset: range.start() }, file, config)\n+    } else {\n+        hover_ranged(sema, frange, file, config)\n+    }?;\n \n-    if !range.is_empty() {\n-        return hover_ranged(&file, range, sema, config);\n+    if let HoverDocFormat::PlainText = config.format {\n+        res.info.markup = remove_markdown(res.info.markup.as_str()).into();\n     }\n-    let offset = range.start();\n+    Some(res)\n+}\n \n+fn hover_simple(\n+    sema: &Semantics<'_, RootDatabase>,\n+    FilePosition { file_id, offset }: FilePosition,\n+    file: SyntaxNode,\n+    config: &HoverConfig,\n+) -> Option<RangeInfo<HoverResult>> {\n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 4,\n+        IDENT\n+        | INT_NUMBER\n+        | LIFETIME_IDENT\n+        | T![self]\n+        | T![super]\n+        | T![crate]\n+        | T![Self]\n+        | T![_] => 4,\n         // index and prefix ops\n         T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n         kind if kind.is_keyword() => 2,\n@@ -135,19 +150,18 @@ pub(crate) fn hover(\n     } else {\n         sema.descend_into_macros_with_same_text(original_token.clone())\n     };\n+    let descended = || descended.iter();\n \n-    // try lint hover\n-    let result = descended\n-        .iter()\n+    let result = descended()\n+        // try lint hover\n         .find_map(|token| {\n             // FIXME: Definition should include known lints and the like instead of having this special case here\n             let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;\n             render::try_for_lint(&attr, token)\n         })\n-        // try item definitions\n+        // try definitions\n         .or_else(|| {\n-            descended\n-                .iter()\n+            descended()\n                 .filter_map(|token| {\n                     let node = token.parent()?;\n                     let class = IdentClass::classify_token(sema, token)?;\n@@ -168,10 +182,12 @@ pub(crate) fn hover(\n                 })\n         })\n         // try keywords\n-        .or_else(|| descended.iter().find_map(|token| render::keyword(sema, config, token)))\n-        // try rest item hover\n+        .or_else(|| descended().find_map(|token| render::keyword(sema, config, token)))\n+        // try _ hovers\n+        .or_else(|| descended().find_map(|token| render::underscore(sema, config, token)))\n+        // try rest pattern hover\n         .or_else(|| {\n-            descended.iter().find_map(|token| {\n+            descended().find_map(|token| {\n                 if token.kind() != DOT2 {\n                     return None;\n                 }\n@@ -187,58 +203,24 @@ pub(crate) fn hover(\n             })\n         });\n \n-    result\n-        .map(|mut res: HoverResult| {\n-            res.actions = dedupe_or_merge_hover_actions(res.actions);\n-            RangeInfo::new(original_token.text_range(), res)\n-        })\n-        // fallback to type hover if there aren't any other suggestions\n-        // this finds its own range instead of using the closest token's range\n-        .or_else(|| {\n-            descended.iter().find_map(|token| hover_type_fallback(sema, config, token, token))\n-        })\n-}\n-\n-pub(crate) fn hover_for_definition(\n-    sema: &Semantics<'_, RootDatabase>,\n-    file_id: FileId,\n-    definition: Definition,\n-    node: &SyntaxNode,\n-    config: &HoverConfig,\n-) -> Option<HoverResult> {\n-    let famous_defs = match &definition {\n-        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node)?.krate())),\n-        _ => None,\n-    };\n-    render::definition(sema.db, definition, famous_defs.as_ref(), config).map(|markup| {\n-        HoverResult {\n-            markup: render::process_markup(sema.db, definition, &markup, config),\n-            actions: show_implementations_action(sema.db, definition)\n-                .into_iter()\n-                .chain(show_fn_references_action(sema.db, definition))\n-                .chain(runnable_action(sema, definition, file_id))\n-                .chain(goto_type_action_for_def(sema.db, definition))\n-                .collect(),\n-        }\n+    result.map(|mut res: HoverResult| {\n+        res.actions = dedupe_or_merge_hover_actions(res.actions);\n+        RangeInfo::new(original_token.text_range(), res)\n     })\n }\n \n fn hover_ranged(\n-    file: &SyntaxNode,\n-    range: syntax::TextRange,\n     sema: &Semantics<'_, RootDatabase>,\n+    FileRange { range, .. }: FileRange,\n+    file: SyntaxNode,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     // FIXME: make this work in attributes\n-    let expr_or_pat = file.covering_element(range).ancestors().find_map(|it| {\n-        match_ast! {\n-            match it {\n-                ast::Expr(expr) => Some(Either::Left(expr)),\n-                ast::Pat(pat) => Some(Either::Right(pat)),\n-                _ => None,\n-            }\n-        }\n-    })?;\n+    let expr_or_pat = file\n+        .covering_element(range)\n+        .ancestors()\n+        .take_while(|it| ast::MacroCall::can_cast(it.kind()) || !ast::Item::can_cast(it.kind()))\n+        .find_map(Either::<ast::Expr, ast::Pat>::cast)?;\n     let res = match &expr_or_pat {\n         Either::Left(ast::Expr::TryExpr(try_expr)) => render::try_expr(sema, config, try_expr),\n         Either::Left(ast::Expr::PrefixExpr(prefix_expr))\n@@ -248,7 +230,7 @@ fn hover_ranged(\n         }\n         _ => None,\n     };\n-    let res = res.or_else(|| render::type_info(sema, config, &expr_or_pat));\n+    let res = res.or_else(|| render::type_info_of(sema, config, &expr_or_pat));\n     res.map(|it| {\n         let range = match expr_or_pat {\n             Either::Left(it) => it.syntax().text_range(),\n@@ -258,37 +240,31 @@ fn hover_ranged(\n     })\n }\n \n-fn hover_type_fallback(\n+pub(crate) fn hover_for_definition(\n     sema: &Semantics<'_, RootDatabase>,\n+    file_id: FileId,\n+    definition: Definition,\n+    node: &SyntaxNode,\n     config: &HoverConfig,\n-    token: &SyntaxToken,\n-    original_token: &SyntaxToken,\n-) -> Option<RangeInfo<HoverResult>> {\n-    let node =\n-        token.parent_ancestors().take_while(|it| !ast::Item::can_cast(it.kind())).find(|n| {\n-            ast::Expr::can_cast(n.kind())\n-                || ast::Pat::can_cast(n.kind())\n-                || ast::Type::can_cast(n.kind())\n-        })?;\n-\n-    let expr_or_pat = match_ast! {\n-        match node {\n-            ast::Expr(it) => Either::Left(it),\n-            ast::Pat(it) => Either::Right(it),\n-            // If this node is a MACRO_CALL, it means that `descend_into_macros_many` failed to resolve.\n-            // (e.g expanding a builtin macro). So we give up here.\n-            ast::MacroCall(_it) => return None,\n-            _ => return None,\n-        }\n+) -> Option<HoverResult> {\n+    let famous_defs = match &definition {\n+        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node)?.krate())),\n+        _ => None,\n     };\n-\n-    let res = render::type_info(sema, config, &expr_or_pat)?;\n-\n-    let range = sema\n-        .original_range_opt(&node)\n-        .map(|frange| frange.range)\n-        .unwrap_or_else(|| original_token.text_range());\n-    Some(RangeInfo::new(range, res))\n+    render::definition(sema.db, definition, famous_defs.as_ref(), config).map(|markup| {\n+        HoverResult {\n+            markup: render::process_markup(sema.db, definition, &markup, config),\n+            actions: [\n+                show_implementations_action(sema.db, definition),\n+                show_fn_references_action(sema.db, definition),\n+                runnable_action(sema, definition, file_id),\n+                goto_type_action_for_def(sema.db, definition),\n+            ]\n+            .into_iter()\n+            .flatten()\n+            .collect(),\n+        }\n+    })\n }\n \n fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {"}, {"sha": "22611cfb892f8de5a174a3829934f78c855ffd6e", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/render.rs", "status": "modified", "additions": 95, "deletions": 68, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -26,58 +26,24 @@ use syntax::{\n use crate::{\n     doc_links::{remove_links, rewrite_links},\n     hover::walk_and_push_ty,\n-    markdown_remove::remove_markdown,\n     HoverAction, HoverConfig, HoverResult, Markup,\n };\n \n-pub(super) fn type_info(\n+pub(super) fn type_info_of(\n     sema: &Semantics<'_, RootDatabase>,\n-    config: &HoverConfig,\n+    _config: &HoverConfig,\n     expr_or_pat: &Either<ast::Expr, ast::Pat>,\n ) -> Option<HoverResult> {\n     let TypeInfo { original, adjusted } = match expr_or_pat {\n         Either::Left(expr) => sema.type_of_expr(expr)?,\n         Either::Right(pat) => sema.type_of_pat(pat)?,\n     };\n-\n-    let mut res = HoverResult::default();\n-    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n-    let mut push_new_def = |item: hir::ModuleDef| {\n-        if !targets.contains(&item) {\n-            targets.push(item);\n-        }\n-    };\n-    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n-\n-    res.markup = if let Some(adjusted_ty) = adjusted {\n-        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n-        let original = original.display(sema.db).to_string();\n-        let adjusted = adjusted_ty.display(sema.db).to_string();\n-        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n-        format!(\n-            \"{bt_start}Type: {:>apad$}\\nCoerced to: {:>opad$}\\n{bt_end}\",\n-            original,\n-            adjusted,\n-            apad = static_text_diff_len + adjusted.len().max(original.len()),\n-            opad = original.len(),\n-            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n-            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n-        )\n-        .into()\n-    } else {\n-        if config.markdown() {\n-            Markup::fenced_block(&original.display(sema.db))\n-        } else {\n-            original.display(sema.db).to_string().into()\n-        }\n-    };\n-    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n-    Some(res)\n+    type_info(sema, _config, original, adjusted)\n }\n \n pub(super) fn try_expr(\n     sema: &Semantics<'_, RootDatabase>,\n-    config: &HoverConfig,\n+    _config: &HoverConfig,\n     try_expr: &ast::TryExpr,\n ) -> Option<HoverResult> {\n     let inner_ty = sema.type_of_expr(&try_expr.expr()?)?.original;\n@@ -153,22 +119,20 @@ pub(super) fn try_expr(\n     let ppad = static_text_len_diff.min(0).abs() as usize;\n \n     res.markup = format!(\n-        \"{bt_start}{} Type: {:>pad0$}\\nPropagated as: {:>pad1$}\\n{bt_end}\",\n+        \"```text\\n{} Type: {:>pad0$}\\nPropagated as: {:>pad1$}\\n```\\n\",\n         s,\n         inner_ty,\n         body_ty,\n         pad0 = ty_len_max + tpad,\n         pad1 = ty_len_max + ppad,\n-        bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n-        bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n     )\n     .into();\n     Some(res)\n }\n \n pub(super) fn deref_expr(\n     sema: &Semantics<'_, RootDatabase>,\n-    config: &HoverConfig,\n+    _config: &HoverConfig,\n     deref_expr: &ast::PrefixExpr,\n ) -> Option<HoverResult> {\n     let inner_ty = sema.type_of_expr(&deref_expr.expr()?)?.original;\n@@ -197,15 +161,13 @@ pub(super) fn deref_expr(\n             .max(adjusted.len() + coerced_len)\n             .max(inner.len() + deref_len);\n         format!(\n-            \"{bt_start}Dereferenced from: {:>ipad$}\\nTo type: {:>apad$}\\nCoerced to: {:>opad$}\\n{bt_end}\",\n+            \"```text\\nDereferenced from: {:>ipad$}\\nTo type: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n             inner,\n             original,\n             adjusted,\n             ipad = max_len - deref_len,\n             apad = max_len - type_len,\n             opad = max_len - coerced_len,\n-            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n-            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n         )\n         .into()\n     } else {\n@@ -215,13 +177,11 @@ pub(super) fn deref_expr(\n         let deref_len = \"Dereferenced from: \".len();\n         let max_len = (original.len() + type_len).max(inner.len() + deref_len);\n         format!(\n-            \"{bt_start}Dereferenced from: {:>ipad$}\\nTo type: {:>apad$}\\n{bt_end}\",\n+            \"```text\\nDereferenced from: {:>ipad$}\\nTo type: {:>apad$}\\n```\\n\",\n             inner,\n             original,\n             ipad = max_len - deref_len,\n             apad = max_len - type_len,\n-            bt_start = if config.markdown() { \"```text\\n\" } else { \"\" },\n-            bt_end = if config.markdown() { \"```\\n\" } else { \"\" }\n         )\n         .into()\n     };\n@@ -230,12 +190,54 @@ pub(super) fn deref_expr(\n     Some(res)\n }\n \n+pub(super) fn underscore(\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+) -> Option<HoverResult> {\n+    if token.kind() != T![_] {\n+        return None;\n+    }\n+    let parent = token.parent()?;\n+    let _it = match_ast! {\n+        match parent {\n+            ast::InferType(it) => it,\n+            ast::UnderscoreExpr(it) => return type_info_of(sema, config, &Either::Left(ast::Expr::UnderscoreExpr(it))),\n+            ast::WildcardPat(it) => return type_info_of(sema, config, &Either::Right(ast::Pat::WildcardPat(it))),\n+            _ => return None,\n+        }\n+    };\n+    // let it = infer_type.syntax().parent()?;\n+    // match_ast! {\n+    //     match it {\n+    //         ast::LetStmt(_it) => (),\n+    //         ast::Param(_it) => (),\n+    //         ast::RetType(_it) => (),\n+    //         ast::TypeArg(_it) => (),\n+\n+    //         ast::CastExpr(_it) => (),\n+    //         ast::ParenType(_it) => (),\n+    //         ast::TupleType(_it) => (),\n+    //         ast::PtrType(_it) => (),\n+    //         ast::RefType(_it) => (),\n+    //         ast::ArrayType(_it) => (),\n+    //         ast::SliceType(_it) => (),\n+    //         ast::ForType(_it) => (),\n+    //         _ => return None,\n+    //     }\n+    // }\n+\n+    // FIXME: https://github.com/rust-lang/rust-analyzer/issues/11762, this currently always returns Unknown\n+    // type_info(sema, config, sema.resolve_type(&ast::Type::InferType(it))?, None)\n+    None\n+}\n+\n pub(super) fn keyword(\n     sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n     token: &SyntaxToken,\n ) -> Option<HoverResult> {\n-    if !token.kind().is_keyword() || !config.documentation.is_some() || !config.keywords {\n+    if !token.kind().is_keyword() || !config.documentation || !config.keywords {\n         return None;\n     }\n     let parent = token.parent()?;\n@@ -259,7 +261,7 @@ pub(super) fn keyword(\n /// i.e. `let S {a, ..} = S {a: 1, b: 2}`\n pub(super) fn struct_rest_pat(\n     sema: &Semantics<'_, RootDatabase>,\n-    config: &HoverConfig,\n+    _config: &HoverConfig,\n     pattern: &RecordPat,\n ) -> HoverResult {\n     let missing_fields = sema.record_pattern_missing_fields(pattern);\n@@ -288,11 +290,7 @@ pub(super) fn struct_rest_pat(\n         // get rid of trailing comma\n         s.truncate(s.len() - 2);\n \n-        if config.markdown() {\n-            Markup::fenced_block(&s)\n-        } else {\n-            s.into()\n-        }\n+        Markup::fenced_block(&s)\n     };\n     res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n     res\n@@ -346,13 +344,8 @@ pub(super) fn process_markup(\n     config: &HoverConfig,\n ) -> Markup {\n     let markup = markup.as_str();\n-    let markup = if !config.markdown() {\n-        remove_markdown(markup)\n-    } else if config.links_in_hover {\n-        rewrite_links(db, markup, def)\n-    } else {\n-        remove_links(markup)\n-    };\n+    let markup =\n+        if config.links_in_hover { rewrite_links(db, markup, def) } else { remove_links(markup) };\n     Markup::from(markup)\n }\n \n@@ -465,22 +458,56 @@ pub(super) fn definition(\n         Definition::DeriveHelper(it) => (format!(\"derive_helper {}\", it.name(db)), None),\n     };\n \n-    let docs = match config.documentation {\n-        Some(_) => docs.or_else(|| {\n+    let docs = docs\n+        .filter(|_| config.documentation)\n+        .or_else(|| {\n             // docs are missing, for assoc items of trait impls try to fall back to the docs of the\n             // original item of the trait\n             let assoc = def.as_assoc_item(db)?;\n             let trait_ = assoc.containing_trait_impl(db)?;\n             let name = Some(assoc.name(db)?);\n             let item = trait_.items(db).into_iter().find(|it| it.name(db) == name)?;\n             item.docs(db)\n-        }),\n-        None => None,\n-    };\n-    let docs = docs.filter(|_| config.documentation.is_some()).map(Into::into);\n+        })\n+        .map(Into::into);\n     markup(docs, label, mod_path)\n }\n \n+fn type_info(\n+    sema: &Semantics<'_, RootDatabase>,\n+    _config: &HoverConfig,\n+    original: hir::Type,\n+    adjusted: Option<hir::Type>,\n+) -> Option<HoverResult> {\n+    let mut res = HoverResult::default();\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n+\n+    res.markup = if let Some(adjusted_ty) = adjusted {\n+        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n+        let original = original.display(sema.db).to_string();\n+        let adjusted = adjusted_ty.display(sema.db).to_string();\n+        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n+        format!(\n+            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n+            original,\n+            adjusted,\n+            apad = static_text_diff_len + adjusted.len().max(original.len()),\n+            opad = original.len(),\n+        )\n+        .into()\n+    } else {\n+        Markup::fenced_block(&original.display(sema.db))\n+    };\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+    Some(res)\n+}\n+\n fn render_builtin_attr(db: &RootDatabase, attr: hir::BuiltinAttr) -> Option<Markup> {\n     let name = attr.name(db);\n     let desc = format!(\"#[{name}]\");"}, {"sha": "2830212add8ebd40033d6c318c2351210b3ce28c", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 126, "deletions": 87, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,16 +2,17 @@ use expect_test::{expect, Expect};\n use ide_db::base_db::{FileLoader, FileRange};\n use syntax::TextRange;\n \n-use crate::{fixture, hover::HoverDocFormat, HoverConfig};\n+use crate::{fixture, HoverConfig, HoverDocFormat};\n \n fn check_hover_no_result(ra_fixture: &str) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n             &HoverConfig {\n                 links_in_hover: true,\n-                documentation: Some(HoverDocFormat::Markdown),\n+                documentation: true,\n                 keywords: true,\n+                format: HoverDocFormat::Markdown,\n             },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n@@ -26,8 +27,9 @@ fn check(ra_fixture: &str, expect: Expect) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: true,\n-                documentation: Some(HoverDocFormat::Markdown),\n+                documentation: true,\n                 keywords: true,\n+                format: HoverDocFormat::Markdown,\n             },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n@@ -47,8 +49,9 @@ fn check_hover_no_links(ra_fixture: &str, expect: Expect) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: false,\n-                documentation: Some(HoverDocFormat::Markdown),\n+                documentation: true,\n                 keywords: true,\n+                format: HoverDocFormat::Markdown,\n             },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n@@ -68,8 +71,9 @@ fn check_hover_no_markdown(ra_fixture: &str, expect: Expect) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: true,\n-                documentation: Some(HoverDocFormat::PlainText),\n+                documentation: true,\n                 keywords: true,\n+                format: HoverDocFormat::PlainText,\n             },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n@@ -89,8 +93,9 @@ fn check_actions(ra_fixture: &str, expect: Expect) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: true,\n-                documentation: Some(HoverDocFormat::Markdown),\n+                documentation: true,\n                 keywords: true,\n+                format: HoverDocFormat::Markdown,\n             },\n             FileRange { file_id, range: position.range_or_empty() },\n         )\n@@ -105,8 +110,9 @@ fn check_hover_range(ra_fixture: &str, expect: Expect) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: false,\n-                documentation: Some(HoverDocFormat::Markdown),\n+                documentation: true,\n                 keywords: true,\n+                format: HoverDocFormat::Markdown,\n             },\n             range,\n         )\n@@ -121,8 +127,9 @@ fn check_hover_range_no_results(ra_fixture: &str) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: false,\n-                documentation: Some(HoverDocFormat::Markdown),\n+                documentation: true,\n                 keywords: true,\n+                format: HoverDocFormat::Markdown,\n             },\n             range,\n         )\n@@ -206,38 +213,21 @@ m!(ab$0c);\n     );\n }\n \n-#[test]\n-fn hover_shows_type_of_an_expression() {\n-    check(\n-        r#\"\n-pub fn foo() -> u32 { 1 }\n-\n-fn main() {\n-    let foo_test = foo()$0;\n-}\n-\"#,\n-        expect![[r#\"\n-            *foo()*\n-            ```rust\n-            u32\n-            ```\n-        \"#]],\n-    );\n-}\n-\n #[test]\n fn hover_remove_markdown_if_configured() {\n     check_hover_no_markdown(\n         r#\"\n pub fn foo() -> u32 { 1 }\n \n fn main() {\n-    let foo_test = foo()$0;\n+    let foo_test = foo$0();\n }\n \"#,\n         expect![[r#\"\n-            *foo()*\n-            u32\n+            *foo*\n+            test\n+\n+            pub fn foo() -> u32\n         \"#]],\n     );\n }\n@@ -297,33 +287,6 @@ fn main() { let foo_test = fo$0o(); }\n             \"#]],\n     );\n \n-    // Multiple candidates but results are ambiguous.\n-    check(\n-        r#\"\n-//- /a.rs\n-pub fn foo() -> u32 { 1 }\n-\n-//- /b.rs\n-pub fn foo() -> &str { \"\" }\n-\n-//- /c.rs\n-pub fn foo(a: u32, b: u32) {}\n-\n-//- /main.rs\n-mod a;\n-mod b;\n-mod c;\n-\n-fn main() { let foo_test = fo$0o(); }\n-        \"#,\n-        expect![[r#\"\n-                *foo*\n-                ```rust\n-                {unknown}\n-                ```\n-            \"#]],\n-    );\n-\n     // Use literal `crate` in path\n     check(\n         r#\"\n@@ -527,6 +490,7 @@ fn hover_field_offset() {\n     // Hovering over the field when instantiating\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { fiel$0d_a: u8, field_b: i32, field_c: i16 }\n \"#,\n         expect![[r#\"\n@@ -548,6 +512,7 @@ fn hover_shows_struct_field_info() {\n     // Hovering over the field when instantiating\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { field_a: u32 }\n \n fn main() {\n@@ -570,6 +535,7 @@ fn main() {\n     // Hovering over the field in the definition\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { field_a$0: u32 }\n \n fn main() {\n@@ -1184,33 +1150,19 @@ fn test_hover_through_func_in_macro_recursive() {\n macro_rules! id_deep { ($($tt:tt)*) => { $($tt)* } }\n macro_rules! id { ($($tt:tt)*) => { id_deep!($($tt)*) } }\n fn bar() -> u32 { 0 }\n-fn foo() { let a = id!([0u32, bar($0)] ); }\n+fn foo() { let a = id!([0u32, bar$0()] ); }\n \"#,\n         expect![[r#\"\n-                *bar()*\n-                ```rust\n-                u32\n-                ```\n-            \"#]],\n-    );\n-}\n+            *bar*\n \n-#[test]\n-fn test_hover_through_literal_string_in_macro() {\n-    check(\n-        r#\"\n-macro_rules! arr { ($($tt:tt)*) => { [$($tt)*] } }\n-fn foo() {\n-    let mastered_for_itunes = \"\";\n-    let _ = arr!(\"Tr$0acks\", &mastered_for_itunes);\n-}\n-\"#,\n-        expect![[r#\"\n-                *\"Tracks\"*\n-                ```rust\n-                &str\n-                ```\n-            \"#]],\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            fn bar() -> u32\n+            ```\n+        \"#]],\n     );\n }\n \n@@ -1515,6 +1467,8 @@ fn my() {}\n fn test_hover_struct_doc_comment() {\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n+\n /// This is an example\n /// multiline doc\n ///\n@@ -1573,7 +1527,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar // size = 0, align = 1\n+            struct Bar\n             ```\n \n             ---\n@@ -1602,7 +1556,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar // size = 0, align = 1\n+            struct Bar\n             ```\n \n             ---\n@@ -1630,7 +1584,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar // size = 0, align = 1\n+            pub struct Bar\n             ```\n \n             ---\n@@ -1657,7 +1611,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar // size = 0, align = 1\n+            pub struct Bar\n             ```\n \n             ---\n@@ -2959,6 +2913,8 @@ fn main() { let foo_test = name_with_dashes::wrapper::Thing::new$0(); }\n fn hover_field_pat_shorthand_ref_match_ergonomics() {\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n+\n struct S {\n     f: i32,\n }\n@@ -4398,6 +4354,7 @@ fn main() {\n fn hover_intra_doc_links() {\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n \n pub mod theitem {\n     /// This is the item. Cool!\n@@ -4539,7 +4496,7 @@ trait A where\n fn string_shadowed_with_inner_items() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:alloc\n+//- /main.rs crate:main deps:alloc target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n \n /// Custom `String` type.\n struct String;\n@@ -5234,7 +5191,7 @@ foo_macro!(\n             ```\n \n             ```rust\n-            pub struct Foo // size = 0, align = 1\n+            pub struct Foo\n             ```\n \n             ---\n@@ -5248,6 +5205,8 @@ foo_macro!(\n fn hover_intra_in_attr() {\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n+\n #[doc = \"Doc comment for [`Foo$0`]\"]\n pub struct Foo(i32);\n \"#,\n@@ -5368,6 +5327,8 @@ enum Enum {\n fn hover_record_variant_field() {\n     check(\n         r#\"\n+//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n+\n enum Enum {\n     RecordV { field$0: u32 }\n }\n@@ -5573,3 +5534,81 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn hover_underscore_pat() {\n+    check(\n+        r#\"\n+fn main() {\n+    let _$0 = 0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn main() {\n+    let (_$0,) = (0,);\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_underscore_expr() {\n+    check(\n+        r#\"\n+fn main() {\n+    _$0 = 0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn main() {\n+    (_$0,) = (0,);\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_underscore_type() {\n+    check_hover_no_result(\n+        r#\"\n+fn main() {\n+    let x: _$0 = 0;\n+}\n+\"#,\n+    );\n+    check_hover_no_result(\n+        r#\"\n+fn main() {\n+    let x: (_$0,) = (0,);\n+}\n+\"#,\n+    );\n+}"}, {"sha": "ac477339ec23395233fea462333d73584792bec0", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 116, "deletions": 75, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,13 +4,16 @@ use std::{\n };\n \n use either::Either;\n-use hir::{known, HasVisibility, HirDisplay, HirWrite, ModuleDef, ModuleDefId, Semantics};\n+use hir::{\n+    known, HasVisibility, HirDisplay, HirDisplayError, HirWrite, ModuleDef, ModuleDefId, Semantics,\n+};\n use ide_db::{base_db::FileRange, famous_defs::FamousDefs, RootDatabase};\n use itertools::Itertools;\n+use smallvec::{smallvec, SmallVec};\n use stdx::never;\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, NodeOrToken, SyntaxNode, TextRange, TextSize,\n+    match_ast, NodeOrToken, SyntaxNode, TextRange,\n };\n \n use crate::{navigation_target::TryToNav, FileId};\n@@ -28,7 +31,6 @@ mod discriminant;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct InlayHintsConfig {\n-    pub location_links: bool,\n     pub render_colons: bool,\n     pub type_hints: bool,\n     pub discriminant_hints: DiscriminantHints,\n@@ -83,75 +85,108 @@ pub enum AdjustmentHintsMode {\n     PreferPostfix,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum InlayKind {\n-    BindingModeHint,\n-    ChainingHint,\n-    ClosingBraceHint,\n-    ClosureReturnTypeHint,\n-    GenericParamListHint,\n-    AdjustmentHint,\n-    AdjustmentHintPostfix,\n-    LifetimeHint,\n-    ParameterHint,\n-    TypeHint,\n-    DiscriminantHint,\n+    BindingMode,\n+    Chaining,\n+    ClosingBrace,\n+    ClosureReturnType,\n+    GenericParamList,\n+    Adjustment,\n+    AdjustmentPostfix,\n+    Lifetime,\n+    Parameter,\n+    Type,\n+    Discriminant,\n     OpeningParenthesis,\n     ClosingParenthesis,\n }\n \n #[derive(Debug)]\n pub struct InlayHint {\n+    /// The text range this inlay hint applies to.\n     pub range: TextRange,\n+    /// The kind of this inlay hint. This is used to determine side and padding of the hint for\n+    /// rendering purposes.\n     pub kind: InlayKind,\n+    /// The actual label to show in the inlay hint.\n     pub label: InlayHintLabel,\n-    pub tooltip: Option<InlayTooltip>,\n+}\n+\n+impl InlayHint {\n+    fn closing_paren(range: TextRange) -> InlayHint {\n+        InlayHint { range, kind: InlayKind::ClosingParenthesis, label: InlayHintLabel::from(\")\") }\n+    }\n+    fn opening_paren(range: TextRange) -> InlayHint {\n+        InlayHint { range, kind: InlayKind::OpeningParenthesis, label: InlayHintLabel::from(\"(\") }\n+    }\n }\n \n #[derive(Debug)]\n pub enum InlayTooltip {\n     String(String),\n-    HoverRanged(FileId, TextRange),\n-    HoverOffset(FileId, TextSize),\n+    Markdown(String),\n }\n \n #[derive(Default)]\n pub struct InlayHintLabel {\n-    pub parts: Vec<InlayHintLabelPart>,\n+    pub parts: SmallVec<[InlayHintLabelPart; 1]>,\n }\n \n impl InlayHintLabel {\n-    pub fn as_simple_str(&self) -> Option<&str> {\n-        match &*self.parts {\n-            [part] => part.as_simple_str(),\n-            _ => None,\n+    pub fn simple(\n+        s: impl Into<String>,\n+        tooltip: Option<InlayTooltip>,\n+        linked_location: Option<FileRange>,\n+    ) -> InlayHintLabel {\n+        InlayHintLabel {\n+            parts: smallvec![InlayHintLabelPart { text: s.into(), linked_location, tooltip }],\n         }\n     }\n \n     pub fn prepend_str(&mut self, s: &str) {\n         match &mut *self.parts {\n-            [part, ..] if part.as_simple_str().is_some() => part.text = format!(\"{s}{}\", part.text),\n-            _ => self.parts.insert(0, InlayHintLabelPart { text: s.into(), linked_location: None }),\n+            [InlayHintLabelPart { text, linked_location: None, tooltip: None }, ..] => {\n+                text.insert_str(0, s)\n+            }\n+            _ => self.parts.insert(\n+                0,\n+                InlayHintLabelPart { text: s.into(), linked_location: None, tooltip: None },\n+            ),\n         }\n     }\n \n     pub fn append_str(&mut self, s: &str) {\n         match &mut *self.parts {\n-            [.., part] if part.as_simple_str().is_some() => part.text.push_str(s),\n-            _ => self.parts.push(InlayHintLabelPart { text: s.into(), linked_location: None }),\n+            [.., InlayHintLabelPart { text, linked_location: None, tooltip: None }] => {\n+                text.push_str(s)\n+            }\n+            _ => self.parts.push(InlayHintLabelPart {\n+                text: s.into(),\n+                linked_location: None,\n+                tooltip: None,\n+            }),\n         }\n     }\n }\n \n impl From<String> for InlayHintLabel {\n     fn from(s: String) -> Self {\n-        Self { parts: vec![InlayHintLabelPart { text: s, linked_location: None }] }\n+        Self {\n+            parts: smallvec![InlayHintLabelPart { text: s, linked_location: None, tooltip: None }],\n+        }\n     }\n }\n \n impl From<&str> for InlayHintLabel {\n     fn from(s: &str) -> Self {\n-        Self { parts: vec![InlayHintLabelPart { text: s.into(), linked_location: None }] }\n+        Self {\n+            parts: smallvec![InlayHintLabelPart {\n+                text: s.into(),\n+                linked_location: None,\n+                tooltip: None\n+            }],\n+        }\n     }\n }\n \n@@ -175,25 +210,25 @@ pub struct InlayHintLabelPart {\n     /// When setting this, no tooltip must be set on the containing hint, or VS Code will display\n     /// them both.\n     pub linked_location: Option<FileRange>,\n-}\n-\n-impl InlayHintLabelPart {\n-    pub fn as_simple_str(&self) -> Option<&str> {\n-        match self {\n-            Self { text, linked_location: None } => Some(text),\n-            _ => None,\n-        }\n-    }\n+    /// The tooltip to show when hovering over the inlay hint, this may invoke other actions like\n+    /// hover requests to show.\n+    pub tooltip: Option<InlayTooltip>,\n }\n \n impl fmt::Debug for InlayHintLabelPart {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.as_simple_str() {\n-            Some(string) => string.fmt(f),\n-            None => f\n+        match self {\n+            Self { text, linked_location: None, tooltip: None } => text.fmt(f),\n+            Self { text, linked_location, tooltip } => f\n                 .debug_struct(\"InlayHintLabelPart\")\n-                .field(\"text\", &self.text)\n-                .field(\"linked_location\", &self.linked_location)\n+                .field(\"text\", text)\n+                .field(\"linked_location\", linked_location)\n+                .field(\n+                    \"tooltip\",\n+                    &tooltip.as_ref().map_or(\"\", |it| match it {\n+                        InlayTooltip::String(it) | InlayTooltip::Markdown(it) => it,\n+                    }),\n+                )\n                 .finish(),\n         }\n     }\n@@ -204,7 +239,6 @@ struct InlayHintLabelBuilder<'a> {\n     db: &'a RootDatabase,\n     result: InlayHintLabel,\n     last_part: String,\n-    location_link_enabled: bool,\n     location: Option<FileRange>,\n }\n \n@@ -216,9 +250,6 @@ impl fmt::Write for InlayHintLabelBuilder<'_> {\n \n impl HirWrite for InlayHintLabelBuilder<'_> {\n     fn start_location_link(&mut self, def: ModuleDefId) {\n-        if !self.location_link_enabled {\n-            return;\n-        }\n         if self.location.is_some() {\n             never!(\"location link is already started\");\n         }\n@@ -230,9 +261,6 @@ impl HirWrite for InlayHintLabelBuilder<'_> {\n     }\n \n     fn end_location_link(&mut self) {\n-        if !self.location_link_enabled {\n-            return;\n-        }\n         self.make_new_part();\n     }\n }\n@@ -242,6 +270,7 @@ impl InlayHintLabelBuilder<'_> {\n         self.result.parts.push(InlayHintLabelPart {\n             text: take(&mut self.last_part),\n             linked_location: self.location.take(),\n+            tooltip: None,\n         });\n     }\n \n@@ -262,34 +291,51 @@ fn label_of_ty(\n         mut max_length: Option<usize>,\n         ty: hir::Type,\n         label_builder: &mut InlayHintLabelBuilder<'_>,\n-    ) {\n+    ) -> Result<(), HirDisplayError> {\n         let iter_item_type = hint_iterator(sema, famous_defs, &ty);\n         match iter_item_type {\n-            Some(ty) => {\n-                const LABEL_START: &str = \"impl Iterator<Item = \";\n+            Some((iter_trait, item, ty)) => {\n+                const LABEL_START: &str = \"impl \";\n+                const LABEL_ITERATOR: &str = \"Iterator\";\n+                const LABEL_MIDDLE: &str = \"<\";\n+                const LABEL_ITEM: &str = \"Item\";\n+                const LABEL_MIDDLE2: &str = \" = \";\n                 const LABEL_END: &str = \">\";\n \n-                max_length =\n-                    max_length.map(|len| len.saturating_sub(LABEL_START.len() + LABEL_END.len()));\n-\n-                label_builder.write_str(LABEL_START).unwrap();\n-                rec(sema, famous_defs, max_length, ty, label_builder);\n-                label_builder.write_str(LABEL_END).unwrap();\n-            }\n-            None => {\n-                let _ = ty.display_truncated(sema.db, max_length).write_to(label_builder);\n+                max_length = max_length.map(|len| {\n+                    len.saturating_sub(\n+                        LABEL_START.len()\n+                            + LABEL_ITERATOR.len()\n+                            + LABEL_MIDDLE.len()\n+                            + LABEL_MIDDLE2.len()\n+                            + LABEL_END.len(),\n+                    )\n+                });\n+\n+                label_builder.write_str(LABEL_START)?;\n+                label_builder.start_location_link(ModuleDef::from(iter_trait).into());\n+                label_builder.write_str(LABEL_ITERATOR)?;\n+                label_builder.end_location_link();\n+                label_builder.write_str(LABEL_MIDDLE)?;\n+                label_builder.start_location_link(ModuleDef::from(item).into());\n+                label_builder.write_str(LABEL_ITEM)?;\n+                label_builder.end_location_link();\n+                label_builder.write_str(LABEL_MIDDLE2)?;\n+                rec(sema, famous_defs, max_length, ty, label_builder)?;\n+                label_builder.write_str(LABEL_END)?;\n+                Ok(())\n             }\n-        };\n+            None => ty.display_truncated(sema.db, max_length).write_to(label_builder),\n+        }\n     }\n \n     let mut label_builder = InlayHintLabelBuilder {\n         db: sema.db,\n         last_part: String::new(),\n         location: None,\n-        location_link_enabled: config.location_links,\n         result: InlayHintLabel::default(),\n     };\n-    rec(sema, famous_defs, config.max_length, ty, &mut label_builder);\n+    let _ = rec(sema, famous_defs, config.max_length, ty, &mut label_builder);\n     let r = label_builder.finish();\n     Some(r)\n }\n@@ -383,24 +429,22 @@ fn hints(\n                 // static type elisions\n                 ast::Item::Static(it) => implicit_static::hints(hints, config, Either::Left(it)),\n                 ast::Item::Const(it) => implicit_static::hints(hints, config, Either::Right(it)),\n+                ast::Item::Enum(it) => discriminant::enum_hints(hints, famous_defs, config, file_id, it),\n                 _ => None,\n             },\n-            ast::Variant(v) => {\n-                discriminant::hints(hints, famous_defs, config, file_id, &v)\n-            },\n             // FIXME: fn-ptr type, dyn fn type, and trait object type elisions\n             ast::Type(_) => None,\n             _ => None,\n         }\n     };\n }\n \n-/// Checks if the type is an Iterator from std::iter and returns its item type.\n+/// Checks if the type is an Iterator from std::iter and returns the iterator trait and the item type of the concrete iterator.\n fn hint_iterator(\n     sema: &Semantics<'_, RootDatabase>,\n     famous_defs: &FamousDefs<'_, '_>,\n     ty: &hir::Type,\n-) -> Option<hir::Type> {\n+) -> Option<(hir::Trait, hir::TypeAlias, hir::Type)> {\n     let db = sema.db;\n     let strukt = ty.strip_references().as_adt()?;\n     let krate = strukt.module(db).krate();\n@@ -423,7 +467,7 @@ fn hint_iterator(\n             _ => None,\n         })?;\n         if let Some(ty) = ty.normalize_trait_assoc_type(db, &[], assoc_type_item) {\n-            return Some(ty);\n+            return Some((iter_trait, assoc_type_item, ty));\n         }\n     }\n \n@@ -447,7 +491,6 @@ mod tests {\n     use super::ClosureReturnTypeHints;\n \n     pub(super) const DISABLED_CONFIG: InlayHintsConfig = InlayHintsConfig {\n-        location_links: false,\n         discriminant_hints: DiscriminantHints::Never,\n         render_colons: false,\n         type_hints: false,\n@@ -465,16 +508,14 @@ mod tests {\n         max_length: None,\n         closing_brace_hints_min_lines: None,\n     };\n-    pub(super) const DISABLED_CONFIG_WITH_LINKS: InlayHintsConfig =\n-        InlayHintsConfig { location_links: true, ..DISABLED_CONFIG };\n     pub(super) const TEST_CONFIG: InlayHintsConfig = InlayHintsConfig {\n         type_hints: true,\n         parameter_hints: true,\n         chaining_hints: true,\n         closure_return_type_hints: ClosureReturnTypeHints::WithBlock,\n         binding_mode_hints: true,\n         lifetime_elision_hints: LifetimeElisionHints::Always,\n-        ..DISABLED_CONFIG_WITH_LINKS\n+        ..DISABLED_CONFIG\n     };\n \n     #[track_caller]"}, {"sha": "188eb7f977ba66b2b5727f56514cdfa5a65f1588", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 64, "deletions": 71, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,15 +3,19 @@\n //! let _: u32  = /* <never-to-any> */ loop {};\n //! let _: &u32 = /* &* */ &mut 0;\n //! ```\n-use hir::{Adjust, AutoBorrow, Mutability, OverloadedDeref, PointerCast, Safety, Semantics};\n+use hir::{Adjust, Adjustment, AutoBorrow, HirDisplay, Mutability, PointerCast, Safety, Semantics};\n use ide_db::RootDatabase;\n \n+use stdx::never;\n use syntax::{\n     ast::{self, make, AstNode},\n     ted,\n };\n \n-use crate::{AdjustmentHints, AdjustmentHintsMode, InlayHint, InlayHintsConfig, InlayKind};\n+use crate::{\n+    AdjustmentHints, AdjustmentHintsMode, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind,\n+    InlayTooltip,\n+};\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n@@ -44,27 +48,12 @@ pub(super) fn hints(\n         mode_and_needs_parens_for_adjustment_hints(expr, config.adjustment_hints_mode);\n \n     if needs_outer_parens {\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::OpeningParenthesis,\n-            label: \"(\".into(),\n-            tooltip: None,\n-        });\n+        acc.push(InlayHint::opening_paren(expr.syntax().text_range()));\n     }\n \n     if postfix && needs_inner_parens {\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::OpeningParenthesis,\n-            label: \"(\".into(),\n-            tooltip: None,\n-        });\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::ClosingParenthesis,\n-            label: \")\".into(),\n-            tooltip: None,\n-        });\n+        acc.push(InlayHint::opening_paren(expr.syntax().text_range()));\n+        acc.push(InlayHint::closing_paren(expr.syntax().text_range()));\n     }\n \n     let (mut tmp0, mut tmp1);\n@@ -76,72 +65,71 @@ pub(super) fn hints(\n         &mut tmp1\n     };\n \n-    for adjustment in iter {\n-        if adjustment.source == adjustment.target {\n+    for Adjustment { source, target, kind } in iter {\n+        if source == target {\n             continue;\n         }\n \n         // FIXME: Add some nicer tooltips to each of these\n-        let text = match adjustment.kind {\n+        let (text, coercion) = match kind {\n             Adjust::NeverToAny if config.adjustment_hints == AdjustmentHints::Always => {\n-                \"<never-to-any>\"\n+                (\"<never-to-any>\", \"never to any\")\n+            }\n+            Adjust::Deref(_) => (\"*\", \"dereference\"),\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => (\"&\", \"borrow\"),\n+            Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => (\"&mut \", \"unique borrow\"),\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => {\n+                (\"&raw const \", \"const pointer borrow\")\n+            }\n+            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Mut)) => {\n+                (\"&raw mut \", \"mut pointer borrow\")\n             }\n-            Adjust::Deref(None) => \"*\",\n-            Adjust::Deref(Some(OverloadedDeref(Mutability::Mut))) => \"*\",\n-            Adjust::Deref(Some(OverloadedDeref(Mutability::Shared))) => \"*\",\n-            Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => \"&\",\n-            Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => \"&mut \",\n-            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => \"&raw const \",\n-            Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Mut)) => \"&raw mut \",\n             // some of these could be represented via `as` casts, but that's not too nice and\n             // handling everything as a prefix expr makes the `(` and `)` insertion easier\n             Adjust::Pointer(cast) if config.adjustment_hints == AdjustmentHints::Always => {\n                 match cast {\n-                    PointerCast::ReifyFnPointer => \"<fn-item-to-fn-pointer>\",\n-                    PointerCast::UnsafeFnPointer => \"<safe-fn-pointer-to-unsafe-fn-pointer>\",\n+                    PointerCast::ReifyFnPointer => {\n+                        (\"<fn-item-to-fn-pointer>\", \"fn item to fn pointer\")\n+                    }\n+                    PointerCast::UnsafeFnPointer => (\n+                        \"<safe-fn-pointer-to-unsafe-fn-pointer>\",\n+                        \"safe fn pointer to unsafe fn pointer\",\n+                    ),\n                     PointerCast::ClosureFnPointer(Safety::Unsafe) => {\n-                        \"<closure-to-unsafe-fn-pointer>\"\n+                        (\"<closure-to-unsafe-fn-pointer>\", \"closure to unsafe fn pointer\")\n+                    }\n+                    PointerCast::ClosureFnPointer(Safety::Safe) => {\n+                        (\"<closure-to-fn-pointer>\", \"closure to fn pointer\")\n+                    }\n+                    PointerCast::MutToConstPointer => {\n+                        (\"<mut-ptr-to-const-ptr>\", \"mut ptr to const ptr\")\n                     }\n-                    PointerCast::ClosureFnPointer(Safety::Safe) => \"<closure-to-fn-pointer>\",\n-                    PointerCast::MutToConstPointer => \"<mut-ptr-to-const-ptr>\",\n-                    PointerCast::ArrayToPointer => \"<array-ptr-to-element-ptr>\",\n-                    PointerCast::Unsize => \"<unsize>\",\n+                    PointerCast::ArrayToPointer => (\"<array-ptr-to-element-ptr>\", \"\"),\n+                    PointerCast::Unsize => (\"<unsize>\", \"unsize\"),\n                 }\n             }\n             _ => continue,\n         };\n         acc.push(InlayHint {\n             range: expr.syntax().text_range(),\n-            kind: if postfix {\n-                InlayKind::AdjustmentHintPostfix\n-            } else {\n-                InlayKind::AdjustmentHint\n-            },\n-            label: if postfix { format!(\".{}\", text.trim_end()).into() } else { text.into() },\n-            tooltip: None,\n+            kind: if postfix { InlayKind::AdjustmentPostfix } else { InlayKind::Adjustment },\n+            label: InlayHintLabel::simple(\n+                if postfix { format!(\".{}\", text.trim_end()) } else { text.to_owned() },\n+                Some(InlayTooltip::Markdown(format!(\n+                    \"`{}` \u2192 `{}` ({coercion} coercion)\",\n+                    source.display(sema.db),\n+                    target.display(sema.db),\n+                ))),\n+                None,\n+            ),\n         });\n     }\n     if !postfix && needs_inner_parens {\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::OpeningParenthesis,\n-            label: \"(\".into(),\n-            tooltip: None,\n-        });\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::ClosingParenthesis,\n-            label: \")\".into(),\n-            tooltip: None,\n-        });\n+        acc.push(InlayHint::opening_paren(expr.syntax().text_range()));\n+        acc.push(InlayHint::closing_paren(expr.syntax().text_range()));\n     }\n     if needs_outer_parens {\n-        acc.push(InlayHint {\n-            range: expr.syntax().text_range(),\n-            kind: InlayKind::ClosingParenthesis,\n-            label: \")\".into(),\n-            tooltip: None,\n-        });\n+        acc.push(InlayHint::closing_paren(expr.syntax().text_range()));\n     }\n     Some(())\n }\n@@ -223,16 +211,21 @@ fn needs_parens_for_adjustment_hints(expr: &ast::Expr, postfix: bool) -> (bool,\n     ted::replace(expr.syntax(), dummy_expr.syntax());\n \n     let parent = dummy_expr.syntax().parent();\n-    let expr = if postfix {\n-        let ast::Expr::TryExpr(e) = &dummy_expr else { unreachable!() };\n-        let Some(ast::Expr::ParenExpr(e)) = e.expr() else { unreachable!() };\n+    let Some(expr) = (|| {\n+        if postfix {\n+            let ast::Expr::TryExpr(e) = &dummy_expr else { return None };\n+            let Some(ast::Expr::ParenExpr(e)) = e.expr() else { return None };\n \n-        e.expr().unwrap()\n-    } else {\n-        let ast::Expr::RefExpr(e) = &dummy_expr else { unreachable!() };\n-        let Some(ast::Expr::ParenExpr(e)) = e.expr() else { unreachable!() };\n+            e.expr()\n+        } else {\n+            let ast::Expr::RefExpr(e) = &dummy_expr else { return None };\n+            let Some(ast::Expr::ParenExpr(e)) = e.expr() else { return None };\n \n-        e.expr().unwrap()\n+            e.expr()\n+        }\n+    })() else {\n+        never!(\"broken syntax tree?\\n{:?}\\n{:?}\", expr, dummy_expr);\n+        return (true, true)\n     };\n \n     // At this point"}, {"sha": "4af7f9bdb73b5eb0453f227c59d77cc3724c7140", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 89, "deletions": 48, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -12,17 +12,15 @@ use syntax::{\n     match_ast,\n };\n \n-use crate::{\n-    inlay_hints::closure_has_block_body, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip,\n-};\n+use crate::{inlay_hints::closure_has_block_body, InlayHint, InlayHintsConfig, InlayKind};\n \n use super::label_of_ty;\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n     famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n-    file_id: FileId,\n+    _file_id: FileId,\n     pat: &ast::IdentPat,\n ) -> Option<()> {\n     if !config.type_hints {\n@@ -50,12 +48,8 @@ pub(super) fn hints(\n             Some(name) => name.syntax().text_range(),\n             None => pat.syntax().text_range(),\n         },\n-        kind: InlayKind::TypeHint,\n+        kind: InlayKind::Type,\n         label,\n-        tooltip: pat\n-            .name()\n-            .map(|it| it.syntax().text_range())\n-            .map(|it| InlayTooltip::HoverRanged(file_id, it)),\n     });\n \n     Some(())\n@@ -73,28 +67,23 @@ fn should_not_display_type_hint(\n         return true;\n     }\n \n-    if let Some(hir::Adt::Struct(s)) = pat_ty.as_adt() {\n-        if s.fields(db).is_empty() && s.name(db).to_smol_str() == bind_pat.to_string() {\n-            return true;\n-        }\n-    }\n-\n-    if config.hide_closure_initialization_hints {\n-        if let Some(parent) = bind_pat.syntax().parent() {\n-            if let Some(it) = ast::LetStmt::cast(parent) {\n-                if let Some(ast::Expr::ClosureExpr(closure)) = it.initializer() {\n-                    if closure_has_block_body(&closure) {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n+    if sema.resolve_bind_pat_to_const(bind_pat).is_some() {\n+        return true;\n     }\n \n     for node in bind_pat.syntax().ancestors() {\n         match_ast! {\n             match node {\n-                ast::LetStmt(it) => return it.ty().is_some(),\n+                ast::LetStmt(it) => {\n+                    if config.hide_closure_initialization_hints {\n+                        if let Some(ast::Expr::ClosureExpr(closure)) = it.initializer() {\n+                            if closure_has_block_body(&closure) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    return it.ty().is_some()\n+                },\n                 // FIXME: We might wanna show type hints in parameters for non-top level patterns as well\n                 ast::Param(it) => return it.ty().is_some(),\n                 ast::MatchArm(_) => return pat_is_enum_variant(db, bind_pat, pat_ty),\n@@ -194,8 +183,7 @@ mod tests {\n     use crate::{fixture, inlay_hints::InlayHintsConfig};\n \n     use crate::inlay_hints::tests::{\n-        check, check_expect, check_with_config, DISABLED_CONFIG, DISABLED_CONFIG_WITH_LINKS,\n-        TEST_CONFIG,\n+        check, check_expect, check_with_config, DISABLED_CONFIG, TEST_CONFIG,\n     };\n     use crate::ClosureReturnTypeHints;\n \n@@ -291,7 +279,7 @@ fn main() {\n     fn iterator_hint_regression_issue_12674() {\n         // Ensure we don't crash while solving the projection type of iterators.\n         check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n             r#\"\n //- minicore: iterators\n struct S<T>(T);\n@@ -322,22 +310,66 @@ fn main(a: SliceIter<'_, Container>) {\n                 [\n                     InlayHint {\n                         range: 484..554,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = impl Iterator<Item = &&str>>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2611..2619,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"Item\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2643..2647,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \" = impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2611..2619,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"Item\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2643..2647,\n+                                    },\n                                 ),\n-                                484..554,\n-                            ),\n-                        ),\n+                                tooltip: \"\",\n+                            },\n+                            \" = &&str>>\",\n+                        ],\n                     },\n                     InlayHint {\n                         range: 484..485,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -350,6 +382,7 @@ fn main(a: SliceIter<'_, Container>) {\n                                         range: 289..298,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"<\",\n                             InlayHintLabelPart {\n@@ -362,17 +395,10 @@ fn main(a: SliceIter<'_, Container>) {\n                                         range: 238..247,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \">\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                484..485,\n-                            ),\n-                        ),\n                     },\n                 ]\n             \"#]],\n@@ -536,6 +562,21 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn const_pats_have_no_type_hints() {\n+        check_types(\n+            r#\"\n+const FOO: usize = 0;\n+\n+fn main() {\n+    match 0 {\n+        FOO => (),\n+        _ => ()\n+    }\n+}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn let_statement() {\n         check_types("}, {"sha": "11b9cd269bfa8c77b2005f28842a99a743a3c586", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/binding_mode.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -7,7 +7,7 @@ use ide_db::RootDatabase;\n \n use syntax::ast::{self, AstNode};\n \n-use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+use crate::{InlayHint, InlayHintsConfig, InlayKind};\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n@@ -40,12 +40,7 @@ pub(super) fn hints(\n             (true, false) => \"&\",\n             _ => return,\n         };\n-        acc.push(InlayHint {\n-            range,\n-            kind: InlayKind::BindingModeHint,\n-            label: r.to_string().into(),\n-            tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n-        });\n+        acc.push(InlayHint { range, kind: InlayKind::BindingMode, label: r.to_string().into() });\n     });\n     match pat {\n         ast::Pat::IdentPat(pat) if pat.ref_token().is_none() && pat.mut_token().is_none() => {\n@@ -57,24 +52,13 @@ pub(super) fn hints(\n             };\n             acc.push(InlayHint {\n                 range: pat.syntax().text_range(),\n-                kind: InlayKind::BindingModeHint,\n+                kind: InlayKind::BindingMode,\n                 label: bm.to_string().into(),\n-                tooltip: Some(InlayTooltip::String(\"Inferred binding mode\".into())),\n             });\n         }\n         ast::Pat::OrPat(pat) if !pattern_adjustments.is_empty() && outer_paren_pat.is_none() => {\n-            acc.push(InlayHint {\n-                range: pat.syntax().text_range(),\n-                kind: InlayKind::OpeningParenthesis,\n-                label: \"(\".into(),\n-                tooltip: None,\n-            });\n-            acc.push(InlayHint {\n-                range: pat.syntax().text_range(),\n-                kind: InlayKind::ClosingParenthesis,\n-                label: \")\".into(),\n-                tooltip: None,\n-            });\n+            acc.push(InlayHint::opening_paren(pat.syntax().text_range()));\n+            acc.push(InlayHint::closing_paren(pat.syntax().text_range()));\n         }\n         _ => (),\n     }"}, {"sha": "0c54f084c19eb3396435d7cdba09eb455fe927be", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 157, "deletions": 166, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -5,15 +5,15 @@ use syntax::{\n     Direction, NodeOrToken, SyntaxKind, T,\n };\n \n-use crate::{FileId, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+use crate::{FileId, InlayHint, InlayHintsConfig, InlayKind};\n \n use super::label_of_ty;\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n     famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n-    file_id: FileId,\n+    _file_id: FileId,\n     expr: &ast::Expr,\n ) -> Option<()> {\n     if !config.chaining_hints {\n@@ -59,9 +59,8 @@ pub(super) fn hints(\n             }\n             acc.push(InlayHint {\n                 range: expr.syntax().text_range(),\n-                kind: InlayKind::ChainingHint,\n+                kind: InlayKind::Chaining,\n                 label: label_of_ty(famous_defs, config, ty)?,\n-                tooltip: Some(InlayTooltip::HoverRanged(file_id, expr.syntax().text_range())),\n             });\n         }\n     }\n@@ -73,10 +72,7 @@ mod tests {\n     use expect_test::expect;\n \n     use crate::{\n-        inlay_hints::tests::{\n-            check_expect, check_with_config, DISABLED_CONFIG, DISABLED_CONFIG_WITH_LINKS,\n-            TEST_CONFIG,\n-        },\n+        inlay_hints::tests::{check_expect, check_with_config, DISABLED_CONFIG, TEST_CONFIG},\n         InlayHintsConfig,\n     };\n \n@@ -88,11 +84,7 @@ mod tests {\n     #[test]\n     fn chaining_hints_ignore_comments() {\n         check_expect(\n-            InlayHintsConfig {\n-                type_hints: false,\n-                chaining_hints: true,\n-                ..DISABLED_CONFIG_WITH_LINKS\n-            },\n+            InlayHintsConfig { type_hints: false, chaining_hints: true, ..DISABLED_CONFIG },\n             r#\"\n struct A(B);\n impl A { fn into_b(self) -> B { self.0 } }\n@@ -111,7 +103,7 @@ fn main() {\n                 [\n                     InlayHint {\n                         range: 147..172,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -124,21 +116,14 @@ fn main() {\n                                         range: 63..64,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                147..172,\n-                            ),\n-                        ),\n                     },\n                     InlayHint {\n                         range: 147..154,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -151,17 +136,10 @@ fn main() {\n                                         range: 7..8,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                147..154,\n-                            ),\n-                        ),\n                     },\n                 ]\n             \"#]],\n@@ -210,33 +188,43 @@ fn main() {\n                 [\n                     InlayHint {\n                         range: 143..190,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n-                            \"C\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"C\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 51..52,\n+                                    },\n                                 ),\n-                                143..190,\n-                            ),\n-                        ),\n+                                tooltip: \"\",\n+                            },\n+                            \"\",\n+                        ],\n                     },\n                     InlayHint {\n                         range: 143..179,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n-                            \"B\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n+                            \"\",\n+                            InlayHintLabelPart {\n+                                text: \"B\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 29..30,\n+                                    },\n                                 ),\n-                                143..179,\n-                            ),\n-                        ),\n+                                tooltip: \"\",\n+                            },\n+                            \"\",\n+                        ],\n                     },\n                 ]\n             \"#]],\n@@ -246,7 +234,7 @@ fn main() {\n     #[test]\n     fn struct_access_chaining_hints() {\n         check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n             r#\"\n struct A { pub b: B }\n struct B { pub c: C }\n@@ -269,7 +257,7 @@ fn main() {\n                 [\n                     InlayHint {\n                         range: 143..190,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -282,21 +270,14 @@ fn main() {\n                                         range: 51..52,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                143..190,\n-                            ),\n-                        ),\n                     },\n                     InlayHint {\n                         range: 143..179,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -309,17 +290,10 @@ fn main() {\n                                         range: 29..30,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                143..179,\n-                            ),\n-                        ),\n                     },\n                 ]\n             \"#]],\n@@ -329,7 +303,7 @@ fn main() {\n     #[test]\n     fn generic_chaining_hints() {\n         check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n             r#\"\n struct A<T>(T);\n struct B<T>(T);\n@@ -353,7 +327,7 @@ fn main() {\n                 [\n                     InlayHint {\n                         range: 246..283,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -366,6 +340,7 @@ fn main() {\n                                         range: 23..24,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"<\",\n                             InlayHintLabelPart {\n@@ -378,21 +353,14 @@ fn main() {\n                                         range: 55..56,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"<i32, bool>>\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                246..283,\n-                            ),\n-                        ),\n                     },\n                     InlayHint {\n                         range: 246..265,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -405,6 +373,7 @@ fn main() {\n                                         range: 7..8,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"<\",\n                             InlayHintLabelPart {\n@@ -417,17 +386,10 @@ fn main() {\n                                         range: 55..56,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"<i32, bool>>\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                246..265,\n-                            ),\n-                        ),\n                     },\n                 ]\n             \"#]],\n@@ -437,7 +399,7 @@ fn main() {\n     #[test]\n     fn shorten_iterator_chaining_hints() {\n         check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG_WITH_LINKS },\n+            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n             r#\"\n //- minicore: iterators\n use core::iter;\n@@ -463,52 +425,106 @@ fn main() {\n                 [\n                     InlayHint {\n                         range: 174..241,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = ()>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2611..2619,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"Item\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2643..2647,\n+                                    },\n                                 ),\n-                                174..241,\n-                            ),\n-                        ),\n+                                tooltip: \"\",\n+                            },\n+                            \" = ()>\",\n+                        ],\n                     },\n                     InlayHint {\n                         range: 174..224,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = ()>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2611..2619,\n+                                    },\n                                 ),\n-                                174..224,\n-                            ),\n-                        ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"Item\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2643..2647,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \" = ()>\",\n+                        ],\n                     },\n                     InlayHint {\n                         range: 174..206,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n-                            \"impl Iterator<Item = ()>\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n+                            \"impl \",\n+                            InlayHintLabelPart {\n+                                text: \"Iterator\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2611..2619,\n+                                    },\n                                 ),\n-                                174..206,\n-                            ),\n-                        ),\n+                                tooltip: \"\",\n+                            },\n+                            \"<\",\n+                            InlayHintLabelPart {\n+                                text: \"Item\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            1,\n+                                        ),\n+                                        range: 2643..2647,\n+                                    },\n+                                ),\n+                                tooltip: \"\",\n+                            },\n+                            \" = ()>\",\n+                        ],\n                     },\n                     InlayHint {\n                         range: 174..189,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"&mut \",\n                             InlayHintLabelPart {\n@@ -521,17 +537,10 @@ fn main() {\n                                         range: 24..30,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                174..189,\n-                            ),\n-                        ),\n                     },\n                 ]\n             \"#]],\n@@ -564,7 +573,7 @@ fn main() {\n                 [\n                     InlayHint {\n                         range: 124..130,\n-                        kind: TypeHint,\n+                        kind: Type,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -577,21 +586,14 @@ fn main() {\n                                         range: 7..13,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                124..130,\n-                            ),\n-                        ),\n                     },\n                     InlayHint {\n                         range: 145..185,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -604,21 +606,14 @@ fn main() {\n                                         range: 7..13,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                145..185,\n-                            ),\n-                        ),\n                     },\n                     InlayHint {\n                         range: 145..168,\n-                        kind: ChainingHint,\n+                        kind: Chaining,\n                         label: [\n                             \"\",\n                             InlayHintLabelPart {\n@@ -631,32 +626,28 @@ fn main() {\n                                         range: 7..13,\n                                     },\n                                 ),\n+                                tooltip: \"\",\n                             },\n                             \"\",\n                         ],\n-                        tooltip: Some(\n-                            HoverRanged(\n-                                FileId(\n-                                    0,\n-                                ),\n-                                145..168,\n-                            ),\n-                        ),\n                     },\n                     InlayHint {\n                         range: 222..228,\n-                        kind: ParameterHint,\n+                        kind: Parameter,\n                         label: [\n-                            \"self\",\n-                        ],\n-                        tooltip: Some(\n-                            HoverOffset(\n-                                FileId(\n-                                    0,\n+                            InlayHintLabelPart {\n+                                text: \"self\",\n+                                linked_location: Some(\n+                                    FileRange {\n+                                        file_id: FileId(\n+                                            0,\n+                                        ),\n+                                        range: 42..46,\n+                                    },\n                                 ),\n-                                42,\n-                            ),\n-                        ),\n+                                tooltip: \"\",\n+                            },\n+                        ],\n                     },\n                 ]\n             \"#]],"}, {"sha": "14c11be54ef54b19829905c9a9ed0765e52ef8ff", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/closing_brace.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -10,9 +10,7 @@ use syntax::{\n     match_ast, SyntaxKind, SyntaxNode, T,\n };\n \n-use crate::{\n-    inlay_hints::InlayHintLabelPart, FileId, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind,\n-};\n+use crate::{FileId, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind};\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n@@ -109,15 +107,11 @@ pub(super) fn hints(\n         return None;\n     }\n \n-    let linked_location = config\n-        .location_links\n-        .then(|| name_range.map(|range| FileRange { file_id, range }))\n-        .flatten();\n+    let linked_location = name_range.map(|range| FileRange { file_id, range });\n     acc.push(InlayHint {\n         range: closing_token.text_range(),\n-        kind: InlayKind::ClosingBraceHint,\n-        label: InlayHintLabel { parts: vec![InlayHintLabelPart { text: label, linked_location }] },\n-        tooltip: None, // provided by label part location\n+        kind: InlayKind::ClosingBrace,\n+        label: InlayHintLabel::simple(label, None, linked_location),\n     });\n \n     None"}, {"sha": "f03a18b8e960faf176c805064bb04ecdffc00a5e", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/closure_ret.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fclosure_ret.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::{self, AstNode};\n \n use crate::{\n     inlay_hints::closure_has_block_body, ClosureReturnTypeHints, InlayHint, InlayHintsConfig,\n-    InlayKind, InlayTooltip,\n+    InlayKind,\n };\n \n use super::label_of_ty;\n@@ -13,7 +13,7 @@ pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n     famous_defs @ FamousDefs(sema, _): &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n-    file_id: FileId,\n+    _file_id: FileId,\n     closure: ast::ClosureExpr,\n ) -> Option<()> {\n     if config.closure_return_type_hints == ClosureReturnTypeHints::Never {\n@@ -41,9 +41,8 @@ pub(super) fn hints(\n     }\n     acc.push(InlayHint {\n         range: param_list.syntax().text_range(),\n-        kind: InlayKind::ClosureReturnTypeHint,\n+        kind: InlayKind::ClosureReturnType,\n         label: label_of_ty(famous_defs, config, ty)?,\n-        tooltip: Some(InlayTooltip::HoverRanged(file_id, param_list.syntax().text_range())),\n     });\n     Some(())\n }"}, {"sha": "5dd51ad11f44143389df562cd2280ab40870bc58", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/discriminant.rs", "status": "modified", "additions": 78, "deletions": 30, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,27 +4,43 @@\n //!    Bar/* = 0*/,\n //! }\n //! ```\n-use ide_db::{base_db::FileId, famous_defs::FamousDefs};\n+use hir::Semantics;\n+use ide_db::{base_db::FileId, famous_defs::FamousDefs, RootDatabase};\n use syntax::ast::{self, AstNode, HasName};\n \n-use crate::{DiscriminantHints, InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+use crate::{\n+    DiscriminantHints, InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind, InlayTooltip,\n+};\n \n-pub(super) fn hints(\n+pub(super) fn enum_hints(\n     acc: &mut Vec<InlayHint>,\n     FamousDefs(sema, _): &FamousDefs<'_, '_>,\n     config: &InlayHintsConfig,\n     _: FileId,\n-    variant: &ast::Variant,\n+    enum_: ast::Enum,\n ) -> Option<()> {\n-    let field_list = match config.discriminant_hints {\n-        DiscriminantHints::Always => variant.field_list(),\n-        DiscriminantHints::Fieldless => match variant.field_list() {\n-            Some(_) => return None,\n-            None => None,\n-        },\n-        DiscriminantHints::Never => return None,\n+    let enabled = match config.discriminant_hints {\n+        DiscriminantHints::Always => true,\n+        DiscriminantHints::Fieldless => {\n+            !sema.to_def(&enum_)?.is_data_carrying(sema.db)\n+                || enum_.variant_list()?.variants().any(|v| v.expr().is_some())\n+        }\n+        DiscriminantHints::Never => false,\n     };\n+    if !enabled {\n+        return None;\n+    }\n+    for variant in enum_.variant_list()?.variants() {\n+        variant_hints(acc, sema, &variant);\n+    }\n+    None\n+}\n \n+fn variant_hints(\n+    acc: &mut Vec<InlayHint>,\n+    sema: &Semantics<'_, RootDatabase>,\n+    variant: &ast::Variant,\n+) -> Option<()> {\n     if variant.eq_token().is_some() {\n         return None;\n     }\n@@ -37,19 +53,22 @@ pub(super) fn hints(\n     let d = v.eval(sema.db);\n \n     acc.push(InlayHint {\n-        range: match field_list {\n+        range: match variant.field_list() {\n             Some(field_list) => name.syntax().text_range().cover(field_list.syntax().text_range()),\n             None => name.syntax().text_range(),\n         },\n-        kind: InlayKind::DiscriminantHint,\n-        label: match &d {\n-            Ok(v) => format!(\"{}\", v).into(),\n-            Err(_) => \"?\".into(),\n-        },\n-        tooltip: Some(InlayTooltip::String(match &d {\n-            Ok(_) => \"enum variant discriminant\".into(),\n-            Err(e) => format!(\"{e:?}\").into(),\n-        })),\n+        kind: InlayKind::Discriminant,\n+        label: InlayHintLabel::simple(\n+            match &d {\n+                Ok(v) => format!(\"{}\", v),\n+                Err(_) => \"?\".into(),\n+            },\n+            Some(InlayTooltip::String(match &d {\n+                Ok(_) => \"enum variant discriminant\".into(),\n+                Err(e) => format!(\"{e:?}\").into(),\n+            })),\n+            None,\n+        ),\n     });\n \n     Some(())\n@@ -86,15 +105,30 @@ mod tests {\n         check_discriminants(\n             r#\"\n enum Enum {\n-    Variant,\n-  //^^^^^^^0\n-    Variant1,\n-  //^^^^^^^^1\n-    Variant2,\n-  //^^^^^^^^2\n-    Variant5 = 5,\n-    Variant6,\n-  //^^^^^^^^6\n+  Variant,\n+//^^^^^^^0\n+  Variant1,\n+//^^^^^^^^1\n+  Variant2,\n+//^^^^^^^^2\n+  Variant5 = 5,\n+  Variant6,\n+//^^^^^^^^6\n+}\n+\"#,\n+        );\n+        check_discriminants_fieldless(\n+            r#\"\n+enum Enum {\n+  Variant,\n+//^^^^^^^0\n+  Variant1,\n+//^^^^^^^^1\n+  Variant2,\n+//^^^^^^^^2\n+  Variant5 = 5,\n+  Variant6,\n+//^^^^^^^^6\n }\n \"#,\n         );\n@@ -128,8 +162,22 @@ enum Enum {\n enum Enum {\n     Variant(),\n     Variant1,\n+    Variant2 {},\n+    Variant3,\n+    Variant5,\n+    Variant6,\n+}\n+\"#,\n+        );\n+        check_discriminants_fieldless(\n+            r#\"\n+enum Enum {\n+    Variant(),\n+  //^^^^^^^^^0\n+    Variant1,\n   //^^^^^^^^1\n     Variant2 {},\n+  //^^^^^^^^^^^2\n     Variant3,\n   //^^^^^^^^3\n     Variant5 = 5,"}, {"sha": "b7182085b312ee2a964f2524f93999c57bcb4f4e", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/fn_lifetime_fn.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -10,7 +10,7 @@ use syntax::{\n     SyntaxToken,\n };\n \n-use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints};\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, LifetimeElisionHints};\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n@@ -23,9 +23,8 @@ pub(super) fn hints(\n \n     let mk_lt_hint = |t: SyntaxToken, label: String| InlayHint {\n         range: t.text_range(),\n-        kind: InlayKind::LifetimeHint,\n+        kind: InlayKind::Lifetime,\n         label: label.into(),\n-        tooltip: Some(InlayTooltip::String(\"Elided lifetime\".into())),\n     };\n \n     let param_list = func.param_list()?;\n@@ -183,21 +182,19 @@ pub(super) fn hints(\n             let is_empty = gpl.generic_params().next().is_none();\n             acc.push(InlayHint {\n                 range: angle_tok.text_range(),\n-                kind: InlayKind::LifetimeHint,\n+                kind: InlayKind::Lifetime,\n                 label: format!(\n                     \"{}{}\",\n                     allocated_lifetimes.iter().format(\", \"),\n                     if is_empty { \"\" } else { \", \" }\n                 )\n                 .into(),\n-                tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n             });\n         }\n         (None, allocated_lifetimes) => acc.push(InlayHint {\n             range: func.name()?.syntax().text_range(),\n-            kind: InlayKind::GenericParamListHint,\n+            kind: InlayKind::GenericParamList,\n             label: format!(\"<{}>\", allocated_lifetimes.iter().format(\", \"),).into(),\n-            tooltip: Some(InlayTooltip::String(\"Elided lifetimes\".into())),\n         }),\n     }\n     Some(())"}, {"sha": "1122ee2e3925dfde7e827c66548c8265a7cc4f62", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/implicit_static.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fimplicit_static.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n     SyntaxKind,\n };\n \n-use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints};\n+use crate::{InlayHint, InlayHintsConfig, InlayKind, LifetimeElisionHints};\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n@@ -32,9 +32,8 @@ pub(super) fn hints(\n             let t = ty.amp_token()?;\n             acc.push(InlayHint {\n                 range: t.text_range(),\n-                kind: InlayKind::LifetimeHint,\n+                kind: InlayKind::Lifetime,\n                 label: \"'static\".to_owned().into(),\n-                tooltip: Some(InlayTooltip::String(\"Elided static lifetime\".into())),\n             });\n         }\n     }"}, {"sha": "9cdae6324104480a0280435b63685629d323cfeb", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/param_name.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fparam_name.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -10,7 +10,7 @@ use ide_db::{base_db::FileRange, RootDatabase};\n use stdx::to_lower_snake_case;\n use syntax::ast::{self, AstNode, HasArgList, HasName, UnaryOp};\n \n-use crate::{InlayHint, InlayHintsConfig, InlayKind, InlayTooltip};\n+use crate::{InlayHint, InlayHintLabel, InlayHintsConfig, InlayKind};\n \n pub(super) fn hints(\n     acc: &mut Vec<InlayHint>,\n@@ -43,21 +43,20 @@ pub(super) fn hints(\n             !should_hide_param_name_hint(sema, &callable, param_name, arg)\n         })\n         .map(|(param, param_name, _, FileRange { range, .. })| {\n-            let mut tooltip = None;\n+            let mut linked_location = None;\n             if let Some(name) = param {\n                 if let hir::CallableKind::Function(f) = callable.kind() {\n                     // assert the file is cached so we can map out of macros\n                     if let Some(_) = sema.source(f) {\n-                        tooltip = sema.original_range_opt(name.syntax());\n+                        linked_location = sema.original_range_opt(name.syntax());\n                     }\n                 }\n             }\n \n             InlayHint {\n                 range,\n-                kind: InlayKind::ParameterHint,\n-                label: param_name.into(),\n-                tooltip: tooltip.map(|it| InlayTooltip::HoverOffset(it.file_id, it.range.start())),\n+                kind: InlayKind::Parameter,\n+                label: InlayHintLabel::simple(param_name, None, linked_location),\n             }\n         });\n "}, {"sha": "1cfde2362455868eb4e1f82dc35971b59640778f", "filename": "src/tools/rust-analyzer/crates/ide/src/join_lines.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -161,10 +161,8 @@ fn remove_newline(\n         }\n     }\n \n-    if config.join_assignments {\n-        if join_assignments(edit, &prev, &next).is_some() {\n-            return;\n-        }\n+    if config.join_assignments && join_assignments(edit, &prev, &next).is_some() {\n+        return;\n     }\n \n     if config.unwrap_trivial_blocks {"}, {"sha": "4ead9d4d0a869640c4c3a3e8b055b625af7eabdf", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -82,7 +82,8 @@ pub use crate::{\n     hover::{HoverAction, HoverConfig, HoverDocFormat, HoverGotoTypeData, HoverResult},\n     inlay_hints::{\n         AdjustmentHints, AdjustmentHintsMode, ClosureReturnTypeHints, DiscriminantHints, InlayHint,\n-        InlayHintLabel, InlayHintsConfig, InlayKind, InlayTooltip, LifetimeElisionHints,\n+        InlayHintLabel, InlayHintLabelPart, InlayHintsConfig, InlayKind, InlayTooltip,\n+        LifetimeElisionHints,\n     },\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n@@ -236,7 +237,7 @@ impl Analysis {\n             Ok(Vec::new()),\n             false,\n             CrateOrigin::CratesIo { repo: None, name: None },\n-            None,\n+            Err(\"Analysis::from_single_file has no target layout\".into()),\n         );\n         change.change_file(file_id, Some(Arc::new(text)));\n         change.set_crate_graph(crate_graph);"}, {"sha": "718868c8747b16f7d90fec97a8a8363a6e140f48", "filename": "src/tools/rust-analyzer/crates/ide/src/markdown_remove.rs", "status": "modified", "additions": 137, "deletions": 3, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmarkdown_remove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmarkdown_remove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmarkdown_remove.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -11,12 +11,146 @@ pub(crate) fn remove_markdown(markdown: &str) -> String {\n     for event in parser {\n         match event {\n             Event::Text(text) | Event::Code(text) => out.push_str(&text),\n-            Event::SoftBreak | Event::HardBreak | Event::Rule | Event::End(Tag::CodeBlock(_)) => {\n-                out.push('\\n')\n+            Event::SoftBreak => out.push(' '),\n+            Event::HardBreak | Event::Rule | Event::End(Tag::CodeBlock(_)) => out.push('\\n'),\n+            Event::End(Tag::Paragraph) => {\n+                out.push('\\n');\n+                out.push('\\n');\n             }\n-            _ => {}\n+            Event::Start(_)\n+            | Event::End(_)\n+            | Event::Html(_)\n+            | Event::FootnoteReference(_)\n+            | Event::TaskListMarker(_) => (),\n         }\n     }\n \n+    if let Some(p) = out.rfind(|c| c != '\\n') {\n+        out.drain(p + 1..);\n+    }\n+\n     out\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::expect;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn smoke_test() {\n+        let res = remove_markdown(\n+            r##\"\n+A function or function pointer.\n+\n+Functions are the primary way code is executed within Rust. Function blocks, usually just\n+called functions, can be defined in a variety of different places and be assigned many\n+different attributes and modifiers.\n+\n+Standalone functions that just sit within a module not attached to anything else are common,\n+but most functions will end up being inside [`impl`] blocks, either on another type itself, or\n+as a trait impl for that type.\n+\n+```rust\n+fn standalone_function() {\n+    // code\n+}\n+\n+pub fn public_thing(argument: bool) -> String {\n+    // code\n+    # \"\".to_string()\n+}\n+\n+struct Thing {\n+    foo: i32,\n+}\n+\n+impl Thing {\n+    pub fn new() -> Self {\n+        Self {\n+            foo: 42,\n+        }\n+    }\n+}\n+```\n+\n+In addition to presenting fixed types in the form of `fn name(arg: type, ..) -> return_type`,\n+functions can also declare a list of type parameters along with trait bounds that they fall\n+into.\n+\n+```rust\n+fn generic_function<T: Clone>(x: T) -> (T, T, T) {\n+    (x.clone(), x.clone(), x.clone())\n+}\n+\n+fn generic_where<T>(x: T) -> T\n+    where T: std::ops::Add<Output = T> + Copy\n+{\n+    x + x + x\n+}\n+```\n+\n+Declaring trait bounds in the angle brackets is functionally identical to using a `where`\n+clause. It's up to the programmer to decide which works better in each situation, but `where`\n+tends to be better when things get longer than one line.\n+\n+Along with being made public via `pub`, `fn` can also have an [`extern`] added for use in\n+FFI.\n+\n+For more information on the various types of functions and how they're used, consult the [Rust\n+book] or the [Reference].\n+\n+[`impl`]: keyword.impl.html\n+[`extern`]: keyword.extern.html\n+[Rust book]: ../book/ch03-03-how-functions-work.html\n+[Reference]: ../reference/items/functions.html\n+\"##,\n+        );\n+        expect![[r#\"\n+            A function or function pointer.\n+\n+            Functions are the primary way code is executed within Rust. Function blocks, usually just called functions, can be defined in a variety of different places and be assigned many different attributes and modifiers.\n+\n+            Standalone functions that just sit within a module not attached to anything else are common, but most functions will end up being inside impl blocks, either on another type itself, or as a trait impl for that type.\n+\n+            fn standalone_function() {\n+                // code\n+            }\n+\n+            pub fn public_thing(argument: bool) -> String {\n+                // code\n+                # \"\".to_string()\n+            }\n+\n+            struct Thing {\n+                foo: i32,\n+            }\n+\n+            impl Thing {\n+                pub fn new() -> Self {\n+                    Self {\n+                        foo: 42,\n+                    }\n+                }\n+            }\n+\n+            In addition to presenting fixed types in the form of fn name(arg: type, ..) -> return_type, functions can also declare a list of type parameters along with trait bounds that they fall into.\n+\n+            fn generic_function<T: Clone>(x: T) -> (T, T, T) {\n+                (x.clone(), x.clone(), x.clone())\n+            }\n+\n+            fn generic_where<T>(x: T) -> T\n+                where T: std::ops::Add<Output = T> + Copy\n+            {\n+                x + x + x\n+            }\n+\n+            Declaring trait bounds in the angle brackets is functionally identical to using a where clause. It's up to the programmer to decide which works better in each situation, but where tends to be better when things get longer than one line.\n+\n+            Along with being made public via pub, fn can also have an extern added for use in FFI.\n+\n+            For more information on the various types of functions and how they're used, consult the Rust book or the Reference.\"#]].assert_eq(&res);\n+    }\n+}"}, {"sha": "60fb1544a8fe5770aed9661adef5eca4aba78c2d", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -1636,4 +1636,384 @@ pub fn deri$0ve(_stream: TokenStream) -> TokenStream {}\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn assoc_items_trait_def() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const CONST$0: usize;\n+}\n+\n+impl Trait for () {\n+    const CONST: usize = 0;\n+}\n+\n+impl Trait for ((),) {\n+    const CONST: usize = 0;\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::CONST;\n+\n+    let _ = T::CONST;\n+}\n+\"#,\n+            expect![[r#\"\n+                CONST Const FileId(0) 18..37 24..29\n+\n+                FileId(0) 71..76\n+                FileId(0) 125..130\n+                FileId(0) 183..188\n+                FileId(0) 206..211\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    type TypeAlias$0;\n+}\n+\n+impl Trait for () {\n+    type TypeAlias = ();\n+}\n+\n+impl Trait for ((),) {\n+    type TypeAlias = ();\n+}\n+\n+fn f<T: Trait>() {\n+    let _: <() as Trait>::TypeAlias;\n+\n+    let _: T::TypeAlias;\n+}\n+\"#,\n+            expect![[r#\"\n+                TypeAlias TypeAlias FileId(0) 18..33 23..32\n+\n+                FileId(0) 66..75\n+                FileId(0) 117..126\n+                FileId(0) 181..190\n+                FileId(0) 207..216\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn function$0() {}\n+}\n+\n+impl Trait for () {\n+    fn function() {}\n+}\n+\n+impl Trait for ((),) {\n+    fn function() {}\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::function;\n+\n+    let _ = T::function;\n+}\n+\"#,\n+            expect![[r#\"\n+                function Function FileId(0) 18..34 21..29\n+\n+                FileId(0) 65..73\n+                FileId(0) 112..120\n+                FileId(0) 166..174\n+                FileId(0) 192..200\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_items_trait_impl_def() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const CONST: usize;\n+}\n+\n+impl Trait for () {\n+    const CONST$0: usize = 0;\n+}\n+\n+impl Trait for ((),) {\n+    const CONST: usize = 0;\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::CONST;\n+\n+    let _ = T::CONST;\n+}\n+\"#,\n+            expect![[r#\"\n+                CONST Const FileId(0) 65..88 71..76\n+\n+                FileId(0) 183..188\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    type TypeAlias;\n+}\n+\n+impl Trait for () {\n+    type TypeAlias$0 = ();\n+}\n+\n+impl Trait for ((),) {\n+    type TypeAlias = ();\n+}\n+\n+fn f<T: Trait>() {\n+    let _: <() as Trait>::TypeAlias;\n+\n+    let _: T::TypeAlias;\n+}\n+\"#,\n+            expect![[r#\"\n+                TypeAlias TypeAlias FileId(0) 61..81 66..75\n+\n+                FileId(0) 23..32\n+                FileId(0) 117..126\n+                FileId(0) 181..190\n+                FileId(0) 207..216\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn function() {}\n+}\n+\n+impl Trait for () {\n+    fn function$0() {}\n+}\n+\n+impl Trait for ((),) {\n+    fn function() {}\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::function;\n+\n+    let _ = T::function;\n+}\n+\"#,\n+            expect![[r#\"\n+                function Function FileId(0) 62..78 65..73\n+\n+                FileId(0) 166..174\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_items_ref() {\n+        check(\n+            r#\"\n+trait Trait {\n+    const CONST: usize;\n+}\n+\n+impl Trait for () {\n+    const CONST: usize = 0;\n+}\n+\n+impl Trait for ((),) {\n+    const CONST: usize = 0;\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::CONST$0;\n+\n+    let _ = T::CONST;\n+}\n+\"#,\n+            expect![[r#\"\n+                CONST Const FileId(0) 65..88 71..76\n+\n+                FileId(0) 183..188\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    type TypeAlias;\n+}\n+\n+impl Trait for () {\n+    type TypeAlias = ();\n+}\n+\n+impl Trait for ((),) {\n+    type TypeAlias = ();\n+}\n+\n+fn f<T: Trait>() {\n+    let _: <() as Trait>::TypeAlias$0;\n+\n+    let _: T::TypeAlias;\n+}\n+\"#,\n+            expect![[r#\"\n+                TypeAlias TypeAlias FileId(0) 18..33 23..32\n+\n+                FileId(0) 66..75\n+                FileId(0) 117..126\n+                FileId(0) 181..190\n+                FileId(0) 207..216\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn function() {}\n+}\n+\n+impl Trait for () {\n+    fn function() {}\n+}\n+\n+impl Trait for ((),) {\n+    fn function() {}\n+}\n+\n+fn f<T: Trait>() {\n+    let _ = <()>::function$0;\n+\n+    let _ = T::function;\n+}\n+\"#,\n+            expect![[r#\"\n+                function Function FileId(0) 62..78 65..73\n+\n+                FileId(0) 166..174\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn name_clashes() {\n+        check(\n+            r#\"\n+trait Foo {\n+    fn method$0(&self) -> u8;\n+}\n+\n+struct Bar {\n+    method: u8,\n+}\n+\n+impl Foo for Bar {\n+    fn method(&self) -> u8 {\n+        self.method\n+    }\n+}\n+fn method() {}\n+\"#,\n+            expect![[r#\"\n+                method Function FileId(0) 16..39 19..25\n+\n+                FileId(0) 101..107\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Foo {\n+    fn method(&self) -> u8;\n+}\n+\n+struct Bar {\n+    method$0: u8,\n+}\n+\n+impl Foo for Bar {\n+    fn method(&self) -> u8 {\n+        self.method\n+    }\n+}\n+fn method() {}\n+\"#,\n+            expect![[r#\"\n+                method Field FileId(0) 60..70 60..66\n+\n+                FileId(0) 136..142 Read\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Foo {\n+    fn method(&self) -> u8;\n+}\n+\n+struct Bar {\n+    method: u8,\n+}\n+\n+impl Foo for Bar {\n+    fn method$0(&self) -> u8 {\n+        self.method\n+    }\n+}\n+fn method() {}\n+\"#,\n+            expect![[r#\"\n+                method Function FileId(0) 98..148 101..107\n+\n+                (no references)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Foo {\n+    fn method(&self) -> u8;\n+}\n+\n+struct Bar {\n+    method: u8,\n+}\n+\n+impl Foo for Bar {\n+    fn method(&self) -> u8 {\n+        self.method$0\n+    }\n+}\n+fn method() {}\n+\"#,\n+            expect![[r#\"\n+                method Field FileId(0) 60..70 60..66\n+\n+                FileId(0) 136..142 Read\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Foo {\n+    fn method(&self) -> u8;\n+}\n+\n+struct Bar {\n+    method: u8,\n+}\n+\n+impl Foo for Bar {\n+    fn method(&self) -> u8 {\n+        self.method\n+    }\n+}\n+fn method$0() {}\n+\"#,\n+            expect![[r#\"\n+                method Function FileId(0) 151..165 154..160\n+\n+                (no references)\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "8e89160ef5e05d9099f3b05941aa926d418efd59", "filename": "src/tools/rust-analyzer/crates/ide/src/rename.rs", "status": "modified", "additions": 192, "deletions": 7, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -13,7 +13,7 @@ use ide_db::{\n };\n use itertools::Itertools;\n use stdx::{always, never};\n-use syntax::{ast, AstNode, SyntaxNode};\n+use syntax::{ast, utils::is_raw_identifier, AstNode, SmolStr, SyntaxNode, TextRange, TextSize};\n \n use text_edit::TextEdit;\n \n@@ -48,7 +48,13 @@ pub(crate) fn prepare_rename(\n                 frange.range.contains_inclusive(position.offset)\n                     && frange.file_id == position.file_id\n             );\n-            Ok(frange.range)\n+\n+            Ok(match name_like {\n+                ast::NameLike::Lifetime(_) => {\n+                    TextRange::new(frange.range.start() + TextSize::from(1), frange.range.end())\n+                }\n+                _ => frange.range,\n+            })\n         })\n         .reduce(|acc, cur| match (acc, cur) {\n             // ensure all ranges are the same\n@@ -116,7 +122,11 @@ pub(crate) fn will_rename_file(\n     let sema = Semantics::new(db);\n     let module = sema.to_module_def(file_id)?;\n     let def = Definition::Module(module);\n-    let mut change = def.rename(&sema, new_name_stem).ok()?;\n+    let mut change = if is_raw_identifier(new_name_stem) {\n+        def.rename(&sema, &SmolStr::from_iter([\"r#\", new_name_stem])).ok()?\n+    } else {\n+        def.rename(&sema, new_name_stem).ok()?\n+    };\n     change.file_system_edits.clear();\n     Some(change)\n }\n@@ -407,7 +417,7 @@ mod tests {\n     #[test]\n     fn test_prepare_rename_namelikes() {\n         check_prepare(r\"fn name$0<'lifetime>() {}\", expect![[r#\"3..7: name\"#]]);\n-        check_prepare(r\"fn name<'lifetime$0>() {}\", expect![[r#\"8..17: 'lifetime\"#]]);\n+        check_prepare(r\"fn name<'lifetime$0>() {}\", expect![[r#\"9..17: lifetime\"#]]);\n         check_prepare(r\"fn name<'lifetime>() { name$0(); }\", expect![[r#\"23..27: name\"#]]);\n     }\n \n@@ -521,14 +531,18 @@ impl Foo {\n \n     #[test]\n     fn test_rename_to_invalid_identifier_lifetime2() {\n-        cov_mark::check!(rename_not_a_lifetime_ident_ref);\n         check(\n-            \"foo\",\n+            \"_\",\n             r#\"fn main<'a>(_: &'a$0 ()) {}\"#,\n-            \"error: Invalid name `foo`: not a lifetime identifier\",\n+            r#\"error: Invalid name `_`: not a lifetime identifier\"#,\n         );\n     }\n \n+    #[test]\n+    fn test_rename_accepts_lifetime_without_apostrophe() {\n+        check(\"foo\", r#\"fn main<'a>(_: &'a$0 ()) {}\"#, r#\"fn main<'foo>(_: &'foo ()) {}\"#);\n+    }\n+\n     #[test]\n     fn test_rename_to_underscore_invalid() {\n         cov_mark::check!(rename_underscore_multiple);\n@@ -548,6 +562,15 @@ impl Foo {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_mod_invalid_raw_ident() {\n+        check(\n+            \"r#self\",\n+            r#\"mod foo$0 {}\"#,\n+            \"error: Invalid name: `self` cannot be a raw identifier\",\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_for_local() {\n         check(\n@@ -1276,6 +1299,143 @@ mod bar$0;\n         )\n     }\n \n+    #[test]\n+    fn test_rename_mod_to_raw_ident() {\n+        check_expect(\n+            \"r#fn\",\n+            r#\"\n+//- /lib.rs\n+mod foo$0;\n+\n+fn main() { foo::bar::baz(); }\n+\n+//- /foo.rs\n+pub mod bar;\n+\n+//- /foo/bar.rs\n+pub fn baz() {}\n+\"#,\n+            expect![[r#\"\n+                SourceChange {\n+                    source_file_edits: {\n+                        FileId(\n+                            0,\n+                        ): TextEdit {\n+                            indels: [\n+                                Indel {\n+                                    insert: \"r#fn\",\n+                                    delete: 4..7,\n+                                },\n+                                Indel {\n+                                    insert: \"r#fn\",\n+                                    delete: 22..25,\n+                                },\n+                            ],\n+                        },\n+                    },\n+                    file_system_edits: [\n+                        MoveFile {\n+                            src: FileId(\n+                                1,\n+                            ),\n+                            dst: AnchoredPathBuf {\n+                                anchor: FileId(\n+                                    1,\n+                                ),\n+                                path: \"fn.rs\",\n+                            },\n+                        },\n+                        MoveDir {\n+                            src: AnchoredPathBuf {\n+                                anchor: FileId(\n+                                    1,\n+                                ),\n+                                path: \"foo\",\n+                            },\n+                            src_id: FileId(\n+                                1,\n+                            ),\n+                            dst: AnchoredPathBuf {\n+                                anchor: FileId(\n+                                    1,\n+                                ),\n+                                path: \"fn\",\n+                            },\n+                        },\n+                    ],\n+                    is_snippet: false,\n+                }\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_mod_from_raw_ident() {\n+        // FIXME: `r#fn` in path expression is not renamed.\n+        check_expect(\n+            \"foo\",\n+            r#\"\n+//- /lib.rs\n+mod r#fn$0;\n+\n+fn main() { r#fn::bar::baz(); }\n+\n+//- /fn.rs\n+pub mod bar;\n+\n+//- /fn/bar.rs\n+pub fn baz() {}\n+\"#,\n+            expect![[r#\"\n+                SourceChange {\n+                    source_file_edits: {\n+                        FileId(\n+                            0,\n+                        ): TextEdit {\n+                            indels: [\n+                                Indel {\n+                                    insert: \"foo\",\n+                                    delete: 4..8,\n+                                },\n+                            ],\n+                        },\n+                    },\n+                    file_system_edits: [\n+                        MoveFile {\n+                            src: FileId(\n+                                1,\n+                            ),\n+                            dst: AnchoredPathBuf {\n+                                anchor: FileId(\n+                                    1,\n+                                ),\n+                                path: \"foo.rs\",\n+                            },\n+                        },\n+                        MoveDir {\n+                            src: AnchoredPathBuf {\n+                                anchor: FileId(\n+                                    1,\n+                                ),\n+                                path: \"fn\",\n+                            },\n+                            src_id: FileId(\n+                                1,\n+                            ),\n+                            dst: AnchoredPathBuf {\n+                                anchor: FileId(\n+                                    1,\n+                                ),\n+                                path: \"foo\",\n+                            },\n+                        },\n+                    ],\n+                    is_snippet: false,\n+                }\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_enum_variant_from_module_1() {\n         cov_mark::check!(rename_non_local);\n@@ -1831,6 +1991,31 @@ fn foo<'a>() -> &'a () {\n         )\n     }\n \n+    #[test]\n+    fn test_rename_label_new_name_without_apostrophe() {\n+        check(\n+            \"foo\",\n+            r#\"\n+fn main() {\n+    'outer$0: loop {\n+        'inner: loop {\n+            break 'outer;\n+        }\n+    }\n+}\n+        \"#,\n+            r#\"\n+fn main() {\n+    'foo: loop {\n+        'inner: loop {\n+            break 'foo;\n+        }\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_self_to_self() {\n         cov_mark::check!(rename_self_to_self);"}, {"sha": "a666562f1010c2d02e23c6378be8422b51829aea", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 196, "deletions": 7, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,13 +4,15 @@\n use std::collections::BTreeSet;\n \n use either::Either;\n-use hir::{AssocItem, GenericParam, HasAttrs, HirDisplay, Semantics, Trait};\n-use ide_db::{active_parameter::callable_for_node, base_db::FilePosition};\n+use hir::{\n+    AssocItem, GenericParam, HasAttrs, HirDisplay, ModuleDef, PathResolution, Semantics, Trait,\n+};\n+use ide_db::{active_parameter::callable_for_node, base_db::FilePosition, FxIndexMap};\n use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxKind, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -37,14 +39,18 @@ impl SignatureHelp {\n     }\n \n     fn push_call_param(&mut self, param: &str) {\n-        self.push_param('(', param);\n+        self.push_param(\"(\", param);\n     }\n \n     fn push_generic_param(&mut self, param: &str) {\n-        self.push_param('<', param);\n+        self.push_param(\"<\", param);\n+    }\n+\n+    fn push_record_field(&mut self, param: &str) {\n+        self.push_param(\"{ \", param);\n     }\n \n-    fn push_param(&mut self, opening_delim: char, param: &str) {\n+    fn push_param(&mut self, opening_delim: &str, param: &str) {\n         if !self.signature.ends_with(opening_delim) {\n             self.signature.push_str(\", \");\n         }\n@@ -85,14 +91,23 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_generics(&sema, garg_list, token);\n                 },\n+                ast::RecordExpr(record) => {\n+                    let cursor_outside = record.record_expr_field_list().and_then(|list| list.r_curly_token()).as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_record_lit(&sema, record, token);\n+                },\n                 _ => (),\n             }\n         }\n \n         // Stop at multi-line expressions, since the signature of the outer call is not very\n         // helpful inside them.\n         if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            if expr.syntax().text().contains_char('\\n') {\n+            if expr.syntax().text().contains_char('\\n')\n+                && expr.syntax().kind() != SyntaxKind::RECORD_EXPR\n+            {\n                 return None;\n             }\n         }\n@@ -368,6 +383,86 @@ fn add_assoc_type_bindings(\n     }\n }\n \n+fn signature_help_for_record_lit(\n+    sema: &Semantics<'_, RootDatabase>,\n+    record: ast::RecordExpr,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let arg_list = record\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::RecordExpr::cast)\n+        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n+\n+    let active_parameter = arg_list\n+        .record_expr_field_list()?\n+        .fields()\n+        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .count();\n+\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: Some(active_parameter),\n+    };\n+\n+    let fields;\n+\n+    let db = sema.db;\n+    let path_res = sema.resolve_path(&record.path()?)?;\n+    if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n+        fields = variant.fields(db);\n+        let en = variant.parent_enum(db);\n+\n+        res.doc = en.docs(db).map(|it| it.into());\n+        format_to!(res.signature, \"enum {}::{} {{ \", en.name(db), variant.name(db));\n+    } else {\n+        let adt = match path_res {\n+            PathResolution::SelfType(imp) => imp.self_ty(db).as_adt()?,\n+            PathResolution::Def(ModuleDef::Adt(adt)) => adt,\n+            _ => return None,\n+        };\n+\n+        match adt {\n+            hir::Adt::Struct(it) => {\n+                fields = it.fields(db);\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"struct {} {{ \", it.name(db));\n+            }\n+            hir::Adt::Union(it) => {\n+                fields = it.fields(db);\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"union {} {{ \", it.name(db));\n+            }\n+            _ => return None,\n+        }\n+    }\n+\n+    let mut fields =\n+        fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();\n+    let mut buf = String::new();\n+    for field in record.record_expr_field_list()?.fields() {\n+        let Some((field, _, ty)) = sema.resolve_record_field(&field) else { continue };\n+        let name = field.name(db);\n+        format_to!(buf, \"{name}: {}\", ty.display_truncated(db, Some(20)));\n+        res.push_record_field(&buf);\n+        buf.clear();\n+\n+        if let Some(field) = fields.get_mut(&name) {\n+            *field = None;\n+        }\n+    }\n+    for (name, field) in fields {\n+        let Some(field) = field else { continue };\n+        format_to!(buf, \"{name}: {}\", field.ty(db).display_truncated(db, Some(20)));\n+        res.push_record_field(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\" }\");\n+    Some(res)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::iter;\n@@ -1405,4 +1500,98 @@ fn take<C, Error>(\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn record_literal() {\n+        check(\n+            r#\"\n+struct Strukt<T, U = ()> {\n+    t: T,\n+    u: U,\n+    unit: (),\n+}\n+fn f() {\n+    Strukt {\n+        u: 0,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { u: i32, t: T, unit: () }\n+                                ------  ^^^^  --------\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_literal_nonexistent_field() {\n+        check(\n+            r#\"\n+struct Strukt {\n+    a: u8,\n+}\n+fn f() {\n+    Strukt {\n+        b: 8,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { a: u8 }\n+                                -----\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_variant_record_literal() {\n+        check(\n+            r#\"\n+enum Opt {\n+    Some(u8),\n+}\n+fn f() {\n+    Opt::Some {$0}\n+}\n+\"#,\n+            expect![[r#\"\n+                enum Opt::Some { 0: u8 }\n+                                 ^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+enum Opt {\n+    Some(u8),\n+}\n+fn f() {\n+    Opt::Some {0:0,$0}\n+}\n+\"#,\n+            expect![[r#\"\n+                enum Opt::Some { 0: u8 }\n+                                 -----\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_literal_self() {\n+        check(\n+            r#\"\n+struct S { t: u8 }\n+impl S {\n+    fn new() -> Self {\n+        Self { $0 }\n+    }\n+}\n+        \"#,\n+            expect![[r#\"\n+                struct S { t: u8 }\n+                           ^^^^^\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "3f7f6885f611e3b4a2598f2cd5b15e00dc735801", "filename": "src/tools/rust-analyzer/crates/ide/src/static_index.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -16,8 +16,7 @@ use crate::{\n     inlay_hints::AdjustmentHintsMode,\n     moniker::{def_to_moniker, MonikerResult},\n     parent_module::crates_for,\n-    Analysis, Fold, HoverConfig, HoverDocFormat, HoverResult, InlayHint, InlayHintsConfig,\n-    TryToNav,\n+    Analysis, Fold, HoverConfig, HoverResult, InlayHint, InlayHintsConfig, TryToNav,\n };\n \n /// A static representation of fully analyzed source code.\n@@ -107,7 +106,6 @@ impl StaticIndex<'_> {\n             .analysis\n             .inlay_hints(\n                 &InlayHintsConfig {\n-                    location_links: true,\n                     render_colons: true,\n                     discriminant_hints: crate::DiscriminantHints::Fieldless,\n                     type_hints: true,\n@@ -138,8 +136,9 @@ impl StaticIndex<'_> {\n         });\n         let hover_config = HoverConfig {\n             links_in_hover: true,\n-            documentation: Some(HoverDocFormat::Markdown),\n+            documentation: true,\n             keywords: true,\n+            format: crate::HoverDocFormat::Markdown,\n         };\n         let tokens = tokens.filter(|token| {\n             matches!("}, {"sha": "454a250f3ded4c046b5ceaf17f65f7133c54052c", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -413,11 +413,10 @@ fn traverse(\n                 let string = ast::String::cast(token);\n                 let string_to_highlight = ast::String::cast(descended_token.clone());\n                 if let Some((string, expanded_string)) = string.zip(string_to_highlight) {\n-                    if string.is_raw() {\n-                        if inject::ra_fixture(hl, sema, config, &string, &expanded_string).is_some()\n-                        {\n-                            continue;\n-                        }\n+                    if string.is_raw()\n+                        && inject::ra_fixture(hl, sema, config, &string, &expanded_string).is_some()\n+                    {\n+                        continue;\n                     }\n                     highlight_format_string(hl, &string, &expanded_string, range);\n                     highlight_escape_string(hl, &string, range.start());"}, {"sha": "c7e403f6b1ab9d5a2619ca0d72f4c1daf023f47c", "filename": "src/tools/rust-analyzer/crates/ide/src/typing.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Ftyping.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -205,10 +205,8 @@ fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n             if expr_stmt.semicolon_token().is_some() {\n                 return None;\n             }\n-        } else {\n-            if !ast::StmtList::can_cast(binop.syntax().parent()?.kind()) {\n-                return None;\n-            }\n+        } else if !ast::StmtList::can_cast(binop.syntax().parent()?.kind()) {\n+            return None;\n         }\n \n         let expr = binop.rhs()?;\n@@ -255,6 +253,10 @@ fn on_eq_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n         if file.syntax().text().slice(offset..expr_range.start()).contains_char('\\n') {\n             return None;\n         }\n+        // Good indicator that we will insert into a bad spot, so bail out.\n+        if expr.syntax().descendants().any(|it| it.kind() == SyntaxKind::ERROR) {\n+            return None;\n+        }\n         let offset = let_stmt.syntax().text_range().end();\n         Some(TextEdit::insert(offset, \";\".to_string()))\n     }\n@@ -409,15 +411,14 @@ mod tests {\n \n     #[test]\n     fn test_semi_after_let() {\n-        //     do_check(r\"\n-        // fn foo() {\n-        //     let foo =$0\n-        // }\n-        // \", r\"\n-        // fn foo() {\n-        //     let foo =;\n-        // }\n-        // \");\n+        type_char_noop(\n+            '=',\n+            r\"\n+fn foo() {\n+    let foo =$0\n+}\n+\",\n+        );\n         type_char(\n             '=',\n             r#\"\n@@ -431,17 +432,25 @@ fn foo() {\n }\n \"#,\n         );\n-        //     do_check(r\"\n-        // fn foo() {\n-        //     let foo =$0\n-        //     let bar = 1;\n-        // }\n-        // \", r\"\n-        // fn foo() {\n-        //     let foo =;\n-        //     let bar = 1;\n-        // }\n-        // \");\n+        type_char_noop(\n+            '=',\n+            r#\"\n+fn foo() {\n+    let difference $0(counts: &HashMap<(char, char), u64>, last: char) -> u64 {\n+        // ...\n+    }\n+}\n+\"#,\n+        );\n+        type_char_noop(\n+            '=',\n+            r\"\n+fn foo() {\n+    let foo =$0\n+    let bar = 1;\n+}\n+\",\n+        );\n     }\n \n     #[test]"}, {"sha": "c73c368a14e0cc8696adf63107a13f3190de7ada", "filename": "src/tools/rust-analyzer/crates/intern/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fintern%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fintern%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fintern%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -0,0 +1,20 @@\n+[package]\n+name = \"intern\"\n+version = \"0.0.0\"\n+description = \"TBD\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n+\n+[lib]\n+doctest = false\n+\n+\n+[dependencies]\n+# We need to freeze the version of the crate, as the raw-api feature is considered unstable\n+dashmap = { version = \"=5.4.0\", features = [\"raw-api\"] }\n+hashbrown = { version = \"0.12.1\", default-features = false }\n+once_cell = \"1.17.0\"\n+rustc-hash = \"1.1.0\""}, {"sha": "fb2903696b37352939db88c79b869266724a88ea", "filename": "src/tools/rust-analyzer/crates/intern/src/lib.rs", "status": "renamed", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fintern%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fintern%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fintern%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -14,8 +14,6 @@ use hashbrown::HashMap;\n use once_cell::sync::OnceCell;\n use rustc_hash::FxHasher;\n \n-use crate::generics::GenericParams;\n-\n type InternMap<T> = DashMap<Arc<T>, (), BuildHasherDefault<FxHasher>>;\n type Guard<T> = dashmap::RwLockWriteGuard<\n     'static,\n@@ -204,9 +202,9 @@ pub trait Internable: Hash + Eq + 'static {\n #[doc(hidden)]\n macro_rules! _impl_internable {\n     ( $($t:path),+ $(,)? ) => { $(\n-        impl Internable for $t {\n-            fn storage() -> &'static InternStorage<Self> {\n-                static STORAGE: InternStorage<$t> = InternStorage::new();\n+        impl $crate::Internable for $t {\n+            fn storage() -> &'static $crate::InternStorage<Self> {\n+                static STORAGE: $crate::InternStorage<$t> = $crate::InternStorage::new();\n                 &STORAGE\n             }\n         }\n@@ -215,13 +213,4 @@ macro_rules! _impl_internable {\n \n pub use crate::_impl_internable as impl_internable;\n \n-impl_internable!(\n-    crate::type_ref::TypeRef,\n-    crate::type_ref::TraitRef,\n-    crate::type_ref::TypeBound,\n-    crate::path::ModPath,\n-    crate::path::GenericArgs,\n-    crate::attr::AttrInput,\n-    GenericParams,\n-    str,\n-);\n+impl_internable!(str,);", "previous_filename": "src/tools/rust-analyzer/crates/hir-def/src/intern.rs"}, {"sha": "c08886909922771a8290e4afcf93272add615c3c", "filename": "src/tools/rust-analyzer/crates/limit/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Flimit%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"limit\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [features]\n tracking = []"}, {"sha": "280ffc219bac543c101941410e9d734869140ec9", "filename": "src/tools/rust-analyzer/crates/mbe/Cargo.toml", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,9 +2,11 @@\n name = \"mbe\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n@@ -15,10 +17,11 @@ rustc-hash = \"1.1.0\"\n smallvec = \"1.10.0\"\n tracing = \"0.1.35\"\n \n-syntax = { path = \"../syntax\", version = \"0.0.0\" }\n-parser = { path = \"../parser\", version = \"0.0.0\" }\n-tt = { path = \"../tt\", version = \"0.0.0\" }\n-stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+# local deps\n+syntax.workspace = true\n+parser.workspace = true\n+tt.workspace = true\n+stdx.workspace = true\n \n [dev-dependencies]\n-test-utils = { path = \"../test-utils\" }\n+test-utils.workspace = true"}, {"sha": "894355fcbc9b32c0cde5a7c4d5e858dea9b1a8ad", "filename": "src/tools/rust-analyzer/crates/mbe/src/benchmark.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -9,7 +9,7 @@ use test_utils::{bench, bench_fixture, skip_slow_tests};\n \n use crate::{\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n-    syntax_node_to_token_tree, DeclarativeMacro,\n+    syntax_node_to_token_tree, tt, DeclarativeMacro,\n };\n \n #[test]\n@@ -91,7 +91,14 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n                 // So we just skip any error cases and try again\n                 let mut try_cnt = 0;\n                 loop {\n-                    let mut subtree = tt::Subtree::default();\n+                    let mut subtree = tt::Subtree {\n+                        delimiter: tt::Delimiter {\n+                            open: tt::TokenId::UNSPECIFIED,\n+                            close: tt::TokenId::UNSPECIFIED,\n+                            kind: tt::DelimiterKind::Invisible,\n+                        },\n+                        token_trees: vec![],\n+                    };\n                     for op in rule.lhs.iter() {\n                         collect_from_op(op, &mut subtree, &mut seed);\n                     }\n@@ -145,7 +152,7 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n             Op::Ident(it) => parent.token_trees.push(tt::Leaf::from(it.clone()).into()),\n             Op::Punct(puncts) => {\n                 for punct in puncts {\n-                    parent.token_trees.push(tt::Leaf::from(punct.clone()).into());\n+                    parent.token_trees.push(tt::Leaf::from(*punct).into());\n                 }\n             }\n             Op::Repeat { tokens, kind, separator } => {\n@@ -196,20 +203,23 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n             *seed\n         }\n         fn make_ident(ident: &str) -> tt::TokenTree {\n-            tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), text: SmolStr::new(ident) })\n-                .into()\n+            tt::Leaf::Ident(tt::Ident {\n+                span: tt::TokenId::unspecified(),\n+                text: SmolStr::new(ident),\n+            })\n+            .into()\n         }\n         fn make_punct(char: char) -> tt::TokenTree {\n             tt::Leaf::Punct(tt::Punct {\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n                 char,\n                 spacing: tt::Spacing::Alone,\n             })\n             .into()\n         }\n         fn make_literal(lit: &str) -> tt::TokenTree {\n             tt::Leaf::Literal(tt::Literal {\n-                id: tt::TokenId::unspecified(),\n+                span: tt::TokenId::unspecified(),\n                 text: SmolStr::new(lit),\n             })\n             .into()\n@@ -219,7 +229,11 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n             token_trees: Option<Vec<tt::TokenTree>>,\n         ) -> tt::TokenTree {\n             tt::Subtree {\n-                delimiter: Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind }),\n+                delimiter: tt::Delimiter {\n+                    open: tt::TokenId::unspecified(),\n+                    close: tt::TokenId::unspecified(),\n+                    kind,\n+                },\n                 token_trees: token_trees.unwrap_or_default(),\n             }\n             .into()"}, {"sha": "7537dc32261491485a39ea2ccba980bee9784729", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -8,7 +8,7 @@ mod transcriber;\n use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n-use crate::{parser::MetaVarKind, ExpandError, ExpandResult};\n+use crate::{parser::MetaVarKind, tt, ExpandError, ExpandResult};\n \n pub(crate) fn expand_rules(\n     rules: &[crate::Rule],\n@@ -45,7 +45,10 @@ pub(crate) fn expand_rules(\n             transcriber::transcribe(&rule.rhs, &match_.bindings);\n         ExpandResult { value, err: match_.err.or(transcribe_err) }\n     } else {\n-        ExpandResult::only_err(ExpandError::NoMatchingRule)\n+        ExpandResult::with_err(\n+            tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] },\n+            ExpandError::NoMatchingRule,\n+        )\n     }\n }\n "}, {"sha": "f4ea9e5c8165807e6e5a3dabee76413c7bb3ce27", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -67,6 +67,7 @@ use syntax::SmolStr;\n use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n+    tt,\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate, ValueResult,\n };\n@@ -75,7 +76,8 @@ impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n         // FIXME: Do we have a better way to represent an empty token ?\n         // Insert an empty subtree for empty token\n-        let tt = tt::Subtree::default().into();\n+        let tt =\n+            tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] }.into();\n         self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n     }\n \n@@ -462,9 +464,9 @@ fn match_loop_inner<'t>(\n             }\n             OpDelimited::Op(Op::Subtree { tokens, delimiter }) => {\n                 if let Ok(subtree) = src.clone().expect_subtree() {\n-                    if subtree.delimiter_kind() == delimiter.map(|it| it.kind) {\n+                    if subtree.delimiter.kind == delimiter.kind {\n                         item.stack.push(item.dot);\n-                        item.dot = tokens.iter_delimited(delimiter.as_ref());\n+                        item.dot = tokens.iter_delimited(Some(delimiter));\n                         cur_items.push(item);\n                     }\n                 }\n@@ -663,8 +665,8 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n             }\n             res.add_err(ExpandError::LeftoverTokens);\n \n-            if let Some(error_reover_item) = error_recover_item {\n-                res.bindings = bindings_builder.build(&error_reover_item);\n+            if let Some(error_recover_item) = error_recover_item {\n+                res.bindings = bindings_builder.build(&error_recover_item);\n             }\n             return res;\n         }\n@@ -782,7 +784,7 @@ fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Opt\n                             match neg {\n                                 None => lit.into(),\n                                 Some(neg) => tt::TokenTree::Subtree(tt::Subtree {\n-                                    delimiter: None,\n+                                    delimiter: tt::Delimiter::unspecified(),\n                                     token_trees: vec![neg, lit.into()],\n                                 }),\n                             }\n@@ -810,7 +812,11 @@ fn collect_vars(collector_fun: &mut impl FnMut(SmolStr), pattern: &MetaTemplate)\n }\n impl MetaTemplate {\n     fn iter_delimited<'a>(&'a self, delimited: Option<&'a tt::Delimiter>) -> OpDelimitedIter<'a> {\n-        OpDelimitedIter { inner: &self.0, idx: 0, delimited }\n+        OpDelimitedIter {\n+            inner: &self.0,\n+            idx: 0,\n+            delimited: delimited.unwrap_or(&tt::Delimiter::UNSPECIFIED),\n+        }\n     }\n }\n \n@@ -824,20 +830,21 @@ enum OpDelimited<'a> {\n #[derive(Debug, Clone, Copy)]\n struct OpDelimitedIter<'a> {\n     inner: &'a [Op],\n-    delimited: Option<&'a tt::Delimiter>,\n+    delimited: &'a tt::Delimiter,\n     idx: usize,\n }\n \n impl<'a> OpDelimitedIter<'a> {\n     fn is_eof(&self) -> bool {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        let len = self.inner.len()\n+            + if self.delimited.kind != tt::DelimiterKind::Invisible { 2 } else { 0 };\n         self.idx >= len\n     }\n \n     fn peek(&self) -> Option<OpDelimited<'a>> {\n-        match self.delimited {\n-            None => self.inner.get(self.idx).map(OpDelimited::Op),\n-            Some(_) => match self.idx {\n+        match self.delimited.kind {\n+            tt::DelimiterKind::Invisible => self.inner.get(self.idx).map(OpDelimited::Op),\n+            _ => match self.idx {\n                 0 => Some(OpDelimited::Open),\n                 i if i == self.inner.len() + 1 => Some(OpDelimited::Close),\n                 i => self.inner.get(i - 1).map(OpDelimited::Op),\n@@ -860,7 +867,8 @@ impl<'a> Iterator for OpDelimitedIter<'a> {\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        let len = self.inner.len()\n+            + if self.delimited.kind != tt::DelimiterKind::Invisible { 2 } else { 0 };\n         let remain = len.saturating_sub(self.idx);\n         (remain, Some(remain))\n     }\n@@ -904,7 +912,10 @@ impl<'a> TtIter<'a> {\n             } else {\n                 let puncts = self.expect_glued_punct()?;\n                 let token_trees = puncts.into_iter().map(|p| tt::Leaf::Punct(p).into()).collect();\n-                Ok(tt::TokenTree::Subtree(tt::Subtree { delimiter: None, token_trees }))\n+                Ok(tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: tt::Delimiter::unspecified(),\n+                    token_trees,\n+                }))\n             }\n         } else {\n             self.next().ok_or(()).cloned()\n@@ -919,7 +930,7 @@ impl<'a> TtIter<'a> {\n         let ident = self.expect_ident_or_underscore()?;\n \n         Ok(tt::Subtree {\n-            delimiter: None,\n+            delimiter: tt::Delimiter::unspecified(),\n             token_trees: vec![\n                 tt::Leaf::Punct(*punct).into(),\n                 tt::Leaf::Ident(ident.clone()).into(),"}, {"sha": "dffb40d4bc8867de5d5b92b40034395046bb7caa", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,11 +2,11 @@\n //! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n \n use syntax::SmolStr;\n-use tt::{Delimiter, Subtree};\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n     parser::{MetaVarKind, Op, RepeatKind, Separator},\n+    tt::{self, Delimiter},\n     ExpandError, ExpandResult, MetaTemplate,\n };\n \n@@ -44,22 +44,23 @@ impl Bindings {\n             Binding::Missing(it) => Ok(match it {\n                 MetaVarKind::Stmt => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                         char: ';',\n                         spacing: tt::Spacing::Alone,\n                     })))\n                 }\n                 MetaVarKind::Block => Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: Some(tt::Delimiter {\n-                        id: tt::TokenId::unspecified(),\n+                    delimiter: tt::Delimiter {\n+                        open: tt::TokenId::unspecified(),\n+                        close: tt::TokenId::unspecified(),\n                         kind: tt::DelimiterKind::Brace,\n-                    }),\n+                    },\n                     token_trees: vec![],\n                 })),\n                 // FIXME: Meta and Item should get proper defaults\n                 MetaVarKind::Meta | MetaVarKind::Item | MetaVarKind::Tt | MetaVarKind::Vis => {\n                     Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n-                        delimiter: None,\n+                        delimiter: tt::Delimiter::UNSPECIFIED,\n                         token_trees: vec![],\n                     }))\n                 }\n@@ -71,19 +72,19 @@ impl Bindings {\n                 | MetaVarKind::Ident => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                         text: SmolStr::new_inline(\"missing\"),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })))\n                 }\n                 MetaVarKind::Lifetime => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                         text: SmolStr::new_inline(\"'missing\"),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })))\n                 }\n                 MetaVarKind::Literal => {\n                     Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n                         text: SmolStr::new_inline(\"\\\"missing\\\"\"),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })))\n                 }\n             }),\n@@ -138,12 +139,12 @@ fn expand_subtree(\n             Op::Ident(it) => arena.push(tt::Leaf::from(it.clone()).into()),\n             Op::Punct(puncts) => {\n                 for punct in puncts {\n-                    arena.push(tt::Leaf::from(punct.clone()).into());\n+                    arena.push(tt::Leaf::from(*punct).into());\n                 }\n             }\n             Op::Subtree { tokens, delimiter } => {\n                 let ExpandResult { value: tt, err: e } =\n-                    expand_subtree(ctx, tokens, *delimiter, arena);\n+                    expand_subtree(ctx, tokens, Some(*delimiter), arena);\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n@@ -170,7 +171,7 @@ fn expand_subtree(\n                 arena.push(\n                     tt::Leaf::Literal(tt::Literal {\n                         text: index.to_string().into(),\n-                        id: tt::TokenId::unspecified(),\n+                        span: tt::TokenId::unspecified(),\n                     })\n                     .into(),\n                 );\n@@ -179,7 +180,13 @@ fn expand_subtree(\n     }\n     // drain the elements added in this instance of expand_subtree\n     let tts = arena.drain(start_elements..).collect();\n-    ExpandResult { value: tt::Subtree { delimiter, token_trees: tts }, err }\n+    ExpandResult {\n+        value: tt::Subtree {\n+            delimiter: delimiter.unwrap_or_else(tt::Delimiter::unspecified),\n+            token_trees: tts,\n+        },\n+        err,\n+    }\n }\n \n fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n@@ -201,18 +208,25 @@ fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandRe\n         // ```\n         // We just treat it a normal tokens\n         let tt = tt::Subtree {\n-            delimiter: None,\n+            delimiter: tt::Delimiter::UNSPECIFIED,\n             token_trees: vec![\n-                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone, id }).into(),\n-                tt::Leaf::from(tt::Ident { text: v.clone(), id }).into(),\n+                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone, span: id })\n+                    .into(),\n+                tt::Leaf::from(tt::Ident { text: v.clone(), span: id }).into(),\n             ],\n         }\n         .into();\n         ExpandResult::ok(Fragment::Tokens(tt))\n     } else {\n         ctx.bindings.get(v, &mut ctx.nesting).map_or_else(\n-            |e| ExpandResult { value: Fragment::Tokens(tt::TokenTree::empty()), err: Some(e) },\n-            |it| ExpandResult::ok(it),\n+            |e| ExpandResult {\n+                value: Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: tt::Delimiter::unspecified(),\n+                    token_trees: vec![],\n+                })),\n+                err: Some(e),\n+            },\n+            ExpandResult::ok,\n         )\n     }\n }\n@@ -249,7 +263,10 @@ fn expand_repeat(\n                 ctx\n             );\n             return ExpandResult {\n-                value: Fragment::Tokens(Subtree::default().into()),\n+                value: Fragment::Tokens(\n+                    tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] }\n+                        .into(),\n+                ),\n                 err: Some(ExpandError::LimitExceeded),\n             };\n         }\n@@ -258,7 +275,7 @@ fn expand_repeat(\n             continue;\n         }\n \n-        t.delimiter = None;\n+        t.delimiter = tt::Delimiter::unspecified();\n         push_subtree(&mut buf, t);\n \n         if let Some(sep) = separator {\n@@ -292,7 +309,7 @@ fn expand_repeat(\n \n     // Check if it is a single token subtree without any delimiter\n     // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n-    let tt = tt::Subtree { delimiter: None, token_trees: buf }.into();\n+    let tt = tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: buf }.into();\n \n     if RepeatKind::OneOrMore == kind && counter == 0 {\n         return ExpandResult {\n@@ -307,11 +324,12 @@ fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n     match fragment {\n         Fragment::Tokens(tt::TokenTree::Subtree(tt)) => push_subtree(buf, tt),\n         Fragment::Expr(tt::TokenTree::Subtree(mut tt)) => {\n-            if tt.delimiter.is_none() {\n-                tt.delimiter = Some(tt::Delimiter {\n-                    id: tt::TokenId::unspecified(),\n+            if tt.delimiter.kind == tt::DelimiterKind::Invisible {\n+                tt.delimiter = tt::Delimiter {\n+                    open: tt::TokenId::UNSPECIFIED,\n+                    close: tt::TokenId::UNSPECIFIED,\n                     kind: tt::DelimiterKind::Parenthesis,\n-                })\n+                };\n             }\n             buf.push(tt.into())\n         }\n@@ -320,8 +338,8 @@ fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n }\n \n fn push_subtree(buf: &mut Vec<tt::TokenTree>, tt: tt::Subtree) {\n-    match tt.delimiter {\n-        None => buf.extend(tt.token_trees),\n-        Some(_) => buf.push(tt.into()),\n+    match tt.delimiter.kind {\n+        tt::DelimiterKind::Invisible => buf.extend(tt.token_trees),\n+        _ => buf.push(tt.into()),\n     }\n }"}, {"sha": "ac107a0d6d6d1a723b12afcc67f239c477f1e067", "filename": "src/tools/rust-analyzer/crates/mbe/src/lib.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -18,6 +18,8 @@ mod to_parser_input;\n mod benchmark;\n mod token_map;\n \n+use ::tt::token_id as tt;\n+\n use std::fmt;\n \n use crate::{\n@@ -26,8 +28,8 @@ use crate::{\n };\n \n // FIXME: we probably should re-think  `token_tree_to_syntax_node` interfaces\n+pub use self::tt::{Delimiter, DelimiterKind, Punct};\n pub use ::parser::TopEntryPoint;\n-pub use tt::{Delimiter, DelimiterKind, Punct};\n \n pub use crate::{\n     syntax_bridge::{\n@@ -125,24 +127,26 @@ impl Shift {\n \n         // Find the max token id inside a subtree\n         fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n-            let filter = |tt: &_| match tt {\n-                tt::TokenTree::Subtree(subtree) => {\n-                    let tree_id = max_id(subtree);\n-                    match subtree.delimiter {\n-                        Some(it) if it.id != tt::TokenId::unspecified() => {\n-                            Some(tree_id.map_or(it.id.0, |t| t.max(it.id.0)))\n+            let filter =\n+                |tt: &_| match tt {\n+                    tt::TokenTree::Subtree(subtree) => {\n+                        let tree_id = max_id(subtree);\n+                        if subtree.delimiter.open != tt::TokenId::unspecified() {\n+                            Some(tree_id.map_or(subtree.delimiter.open.0, |t| {\n+                                t.max(subtree.delimiter.open.0)\n+                            }))\n+                        } else {\n+                            tree_id\n                         }\n-                        _ => tree_id,\n                     }\n-                }\n-                tt::TokenTree::Leaf(leaf) => {\n-                    let &(tt::Leaf::Ident(tt::Ident { id, .. })\n-                    | tt::Leaf::Punct(tt::Punct { id, .. })\n-                    | tt::Leaf::Literal(tt::Literal { id, .. })) = leaf;\n+                    tt::TokenTree::Leaf(leaf) => {\n+                        let &(tt::Leaf::Ident(tt::Ident { span, .. })\n+                        | tt::Leaf::Punct(tt::Punct { span, .. })\n+                        | tt::Leaf::Literal(tt::Literal { span, .. })) = leaf;\n \n-                    (id != tt::TokenId::unspecified()).then_some(id.0)\n-                }\n-            };\n+                        (span != tt::TokenId::unspecified()).then_some(span.0)\n+                    }\n+                };\n             subtree.token_trees.iter().filter_map(filter).max()\n         }\n     }\n@@ -152,14 +156,13 @@ impl Shift {\n         for t in &mut tt.token_trees {\n             match t {\n                 tt::TokenTree::Leaf(\n-                    tt::Leaf::Ident(tt::Ident { id, .. })\n-                    | tt::Leaf::Punct(tt::Punct { id, .. })\n-                    | tt::Leaf::Literal(tt::Literal { id, .. }),\n-                ) => *id = self.shift(*id),\n+                    tt::Leaf::Ident(tt::Ident { span, .. })\n+                    | tt::Leaf::Punct(tt::Punct { span, .. })\n+                    | tt::Leaf::Literal(tt::Literal { span, .. }),\n+                ) => *span = self.shift(*span),\n                 tt::TokenTree::Subtree(tt) => {\n-                    if let Some(it) = tt.delimiter.as_mut() {\n-                        it.id = self.shift(it.id);\n-                    }\n+                    tt.delimiter.open = self.shift(tt.delimiter.open);\n+                    tt.delimiter.close = self.shift(tt.delimiter.close);\n                     self.shift_all(tt)\n                 }\n             }\n@@ -216,7 +219,7 @@ impl DeclarativeMacro {\n         let mut src = TtIter::new(tt);\n         let mut rules = Vec::new();\n \n-        if Some(tt::DelimiterKind::Brace) == tt.delimiter_kind() {\n+        if tt::DelimiterKind::Brace == tt.delimiter.kind {\n             cov_mark::hit!(parse_macro_def_rules);\n             while src.len() > 0 {\n                 let rule = Rule::parse(&mut src, true)?;\n@@ -325,6 +328,10 @@ impl<T, E> ValueResult<T, E> {\n         Self { value, err: None }\n     }\n \n+    pub fn with_err(value: T, err: E) -> Self {\n+        Self { value, err: Some(err) }\n+    }\n+\n     pub fn only_err(err: E) -> Self\n     where\n         T: Default,"}, {"sha": "fd3d64719ac9a38ab329f762643a8d894b164608", "filename": "src/tools/rust-analyzer/crates/mbe/src/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -4,7 +4,7 @@\n use smallvec::{smallvec, SmallVec};\n use syntax::SmolStr;\n \n-use crate::{tt_iter::TtIter, ParseError};\n+use crate::{tt, tt_iter::TtIter, ParseError};\n \n /// Consider\n ///\n@@ -54,7 +54,7 @@ pub(crate) enum Op {\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n-    Subtree { tokens: MetaTemplate, delimiter: Option<tt::Delimiter> },\n+    Subtree { tokens: MetaTemplate, delimiter: tt::Delimiter },\n     Literal(tt::Literal),\n     Punct(SmallVec<[tt::Punct; 3]>),\n     Ident(tt::Ident),\n@@ -126,17 +126,17 @@ fn next_op(\n             src.next().expect(\"first token already peeked\");\n             // Note that the '$' itself is a valid token inside macro_rules.\n             let second = match src.next() {\n-                None => return Ok(Op::Punct(smallvec![p.clone()])),\n+                None => return Ok(Op::Punct(smallvec![*p])),\n                 Some(it) => it,\n             };\n             match second {\n-                tt::TokenTree::Subtree(subtree) => match subtree.delimiter_kind() {\n-                    Some(tt::DelimiterKind::Parenthesis) => {\n+                tt::TokenTree::Subtree(subtree) => match subtree.delimiter.kind {\n+                    tt::DelimiterKind::Parenthesis => {\n                         let (separator, kind) = parse_repeat(src)?;\n                         let tokens = MetaTemplate::parse(subtree, mode)?;\n                         Op::Repeat { tokens, separator, kind }\n                     }\n-                    Some(tt::DelimiterKind::Brace) => match mode {\n+                    tt::DelimiterKind::Brace => match mode {\n                         Mode::Template => {\n                             parse_metavar_expr(&mut TtIter::new(subtree)).map_err(|()| {\n                                 ParseError::unexpected(\"invalid metavariable expression\")\n@@ -157,18 +157,18 @@ fn next_op(\n                 tt::TokenTree::Leaf(leaf) => match leaf {\n                     tt::Leaf::Ident(ident) if ident.text == \"crate\" => {\n                         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-                        Op::Ident(tt::Ident { text: \"$crate\".into(), id: ident.id })\n+                        Op::Ident(tt::Ident { text: \"$crate\".into(), span: ident.span })\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let kind = eat_fragment_kind(src, mode)?;\n                         let name = ident.text.clone();\n-                        let id = ident.id;\n+                        let id = ident.span;\n                         Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Literal(lit) if is_boolean_literal(lit) => {\n                         let kind = eat_fragment_kind(src, mode)?;\n                         let name = lit.text.clone();\n-                        let id = lit.id;\n+                        let id = lit.span;\n                         Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Punct(punct @ tt::Punct { char: '$', .. }) => match mode {\n@@ -284,7 +284,7 @@ fn parse_metavar_expr(src: &mut TtIter<'_>) -> Result<Op, ()> {\n     let func = src.expect_ident()?;\n     let args = src.expect_subtree()?;\n \n-    if args.delimiter_kind() != Some(tt::DelimiterKind::Parenthesis) {\n+    if args.delimiter.kind != tt::DelimiterKind::Parenthesis {\n         return Err(());\n     }\n \n@@ -293,7 +293,7 @@ fn parse_metavar_expr(src: &mut TtIter<'_>) -> Result<Op, ()> {\n     let op = match &*func.text {\n         \"ignore\" => {\n             let ident = args.expect_ident()?;\n-            Op::Ignore { name: ident.text.clone(), id: ident.id }\n+            Op::Ignore { name: ident.text.clone(), id: ident.span }\n         }\n         \"index\" => {\n             let depth = if args.len() == 0 { 0 } else { args.expect_u32_literal()? };"}, {"sha": "fb5313401088d1d0b5eaf35710dc6eff6df4ad2b", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 119, "deletions": 47, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -8,9 +8,16 @@ use syntax::{\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, SyntaxTreeBuilder, TextRange, TextSize, WalkEvent, T,\n };\n-use tt::buffer::{Cursor, TokenBuffer};\n \n-use crate::{to_parser_input::to_parser_input, tt_iter::TtIter, TokenMap};\n+use crate::{\n+    to_parser_input::to_parser_input,\n+    tt::{\n+        self,\n+        buffer::{Cursor, TokenBuffer},\n+    },\n+    tt_iter::TtIter,\n+    TokenMap,\n+};\n \n #[cfg(test)]\n mod tests;\n@@ -74,9 +81,10 @@ pub fn token_tree_to_syntax_node(\n     entry_point: parser::TopEntryPoint,\n ) -> (Parse<SyntaxNode>, TokenMap) {\n     let buffer = match tt {\n-        tt::Subtree { delimiter: None, token_trees } => {\n-            TokenBuffer::from_tokens(token_trees.as_slice())\n-        }\n+        tt::Subtree {\n+            delimiter: tt::Delimiter { kind: tt::DelimiterKind::Invisible, .. },\n+            token_trees,\n+        } => TokenBuffer::from_tokens(token_trees.as_slice()),\n         _ => TokenBuffer::from_subtree(tt),\n     };\n     let parser_input = to_parser_input(&buffer);\n@@ -87,13 +95,15 @@ pub fn token_tree_to_syntax_node(\n             parser::Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n                 tree_sink.token(kind, n_raw_tokens)\n             }\n+            parser::Step::FloatSplit { ends_in_dot: has_pseudo_dot } => {\n+                tree_sink.float_split(has_pseudo_dot)\n+            }\n             parser::Step::Enter { kind } => tree_sink.start_node(kind),\n             parser::Step::Exit => tree_sink.finish_node(),\n             parser::Step::Error { msg } => tree_sink.error(msg.to_string()),\n         }\n     }\n-    let (parse, range_map) = tree_sink.finish();\n-    (parse, range_map)\n+    tree_sink.finish()\n }\n \n /// Convert a string to a `TokenTree`\n@@ -132,7 +142,7 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n         res.push(match expanded.value {\n             None => break,\n             Some(tt @ tt::TokenTree::Leaf(_)) => {\n-                tt::Subtree { delimiter: None, token_trees: vec![tt] }\n+                tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![tt] }\n             }\n             Some(tt::TokenTree::Subtree(tt)) => tt,\n         });\n@@ -145,7 +155,10 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n     }\n \n     if iter.peek_n(0).is_some() {\n-        res.push(tt::Subtree { delimiter: None, token_trees: iter.cloned().collect() });\n+        res.push(tt::Subtree {\n+            delimiter: tt::Delimiter::unspecified(),\n+            token_trees: iter.cloned().collect(),\n+        });\n     }\n \n     res\n@@ -159,7 +172,7 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n     }\n \n     let entry = StackEntry {\n-        subtree: tt::Subtree { delimiter: None, ..Default::default() },\n+        subtree: tt::Subtree { delimiter: tt::Delimiter::unspecified(), token_trees: vec![] },\n         // never used (delimiter is `None`)\n         idx: !0,\n         open_range: TextRange::empty(TextSize::of('.')),\n@@ -186,7 +199,7 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                         if let Some(tt::TokenTree::Leaf(tt::Leaf::Literal(lit))) =\n                             sub.token_trees.get_mut(2)\n                         {\n-                            lit.id = id\n+                            lit.span = id\n                         }\n                     }\n                     tt\n@@ -199,13 +212,14 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                 assert_eq!(range.len(), TextSize::of('.'));\n             }\n \n-            if let Some(delim) = subtree.delimiter {\n-                let expected = match delim.kind {\n-                    tt::DelimiterKind::Parenthesis => T![')'],\n-                    tt::DelimiterKind::Brace => T!['}'],\n-                    tt::DelimiterKind::Bracket => T![']'],\n-                };\n+            let expected = match subtree.delimiter.kind {\n+                tt::DelimiterKind::Parenthesis => Some(T![')']),\n+                tt::DelimiterKind::Brace => Some(T!['}']),\n+                tt::DelimiterKind::Bracket => Some(T![']']),\n+                tt::DelimiterKind::Invisible => None,\n+            };\n \n+            if let Some(expected) = expected {\n                 if kind == expected {\n                     if let Some(entry) = stack.pop() {\n                         conv.id_alloc().close_delim(entry.idx, Some(range));\n@@ -223,9 +237,11 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n             };\n \n             if let Some(kind) = delim {\n-                let mut subtree = tt::Subtree::default();\n                 let (id, idx) = conv.id_alloc().open_delim(range, synth_id);\n-                subtree.delimiter = Some(tt::Delimiter { id, kind });\n+                let subtree = tt::Subtree {\n+                    delimiter: tt::Delimiter { open: id, close: tt::TokenId::UNSPECIFIED, kind },\n+                    token_trees: vec![],\n+                };\n                 stack.push(StackEntry { subtree, idx, open_range: range });\n                 continue;\n             }\n@@ -240,13 +256,20 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                     panic!(\"Token from lexer must be single char: token = {token:#?}\");\n                 }\n             };\n-            tt::Leaf::from(tt::Punct { char, spacing, id: conv.id_alloc().alloc(range, synth_id) })\n-                .into()\n+            tt::Leaf::from(tt::Punct {\n+                char,\n+                spacing,\n+                span: conv.id_alloc().alloc(range, synth_id),\n+            })\n+            .into()\n         } else {\n             macro_rules! make_leaf {\n                 ($i:ident) => {\n-                    tt::$i { id: conv.id_alloc().alloc(range, synth_id), text: token.to_text(conv) }\n-                        .into()\n+                    tt::$i {\n+                        span: conv.id_alloc().alloc(range, synth_id),\n+                        text: token.to_text(conv),\n+                    }\n+                    .into()\n                 };\n             }\n             let leaf: tt::Leaf = match kind {\n@@ -261,14 +284,14 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n                     let apostrophe = tt::Leaf::from(tt::Punct {\n                         char: '\\'',\n                         spacing: tt::Spacing::Joint,\n-                        id: conv.id_alloc().alloc(r, synth_id),\n+                        span: conv.id_alloc().alloc(r, synth_id),\n                     });\n                     result.push(apostrophe.into());\n \n                     let r = TextRange::at(range.start() + char_unit, range.len() - char_unit);\n                     let ident = tt::Leaf::from(tt::Ident {\n                         text: SmolStr::new(&token.to_text(conv)[1..]),\n-                        id: conv.id_alloc().alloc(r, synth_id),\n+                        span: conv.id_alloc().alloc(r, synth_id),\n                     });\n                     result.push(ident.into());\n                     continue;\n@@ -289,11 +312,12 @@ fn convert_tokens<C: TokenConverter>(conv: &mut C) -> tt::Subtree {\n \n         conv.id_alloc().close_delim(entry.idx, None);\n         let leaf: tt::Leaf = tt::Punct {\n-            id: conv.id_alloc().alloc(entry.open_range, None),\n-            char: match entry.subtree.delimiter.unwrap().kind {\n+            span: conv.id_alloc().alloc(entry.open_range, None),\n+            char: match entry.subtree.delimiter.kind {\n                 tt::DelimiterKind::Parenthesis => '(',\n                 tt::DelimiterKind::Brace => '{',\n                 tt::DelimiterKind::Bracket => '[',\n+                tt::DelimiterKind::Invisible => '$',\n             },\n             spacing: tt::Spacing::Alone,\n         }\n@@ -373,10 +397,11 @@ fn convert_doc_comment(token: &syntax::SyntaxToken) -> Option<Vec<tt::TokenTree>\n         token_trees.push(mk_punct('!'));\n     }\n     token_trees.push(tt::TokenTree::from(tt::Subtree {\n-        delimiter: Some(tt::Delimiter {\n+        delimiter: tt::Delimiter {\n+            open: tt::TokenId::UNSPECIFIED,\n+            close: tt::TokenId::UNSPECIFIED,\n             kind: tt::DelimiterKind::Bracket,\n-            id: tt::TokenId::unspecified(),\n-        }),\n+        },\n         token_trees: meta_tkns,\n     }));\n \n@@ -386,20 +411,20 @@ fn convert_doc_comment(token: &syntax::SyntaxToken) -> Option<Vec<tt::TokenTree>\n     fn mk_ident(s: &str) -> tt::TokenTree {\n         tt::TokenTree::from(tt::Leaf::from(tt::Ident {\n             text: s.into(),\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))\n     }\n \n     fn mk_punct(c: char) -> tt::TokenTree {\n         tt::TokenTree::from(tt::Leaf::from(tt::Punct {\n             char: c,\n             spacing: tt::Spacing::Alone,\n-            id: tt::TokenId::unspecified(),\n+            span: tt::TokenId::unspecified(),\n         }))\n     }\n \n     fn mk_doc_literal(comment: &ast::Comment) -> tt::TokenTree {\n-        let lit = tt::Literal { text: doc_comment_text(comment), id: tt::TokenId::unspecified() };\n+        let lit = tt::Literal { text: doc_comment_text(comment), span: tt::TokenId::unspecified() };\n \n         tt::TokenTree::from(tt::Leaf::from(lit))\n     }\n@@ -761,18 +786,56 @@ impl<'a> TtTreeSink<'a> {\n     }\n }\n \n-fn delim_to_str(d: tt::DelimiterKind, closing: bool) -> &'static str {\n+fn delim_to_str(d: tt::DelimiterKind, closing: bool) -> Option<&'static str> {\n     let texts = match d {\n         tt::DelimiterKind::Parenthesis => \"()\",\n         tt::DelimiterKind::Brace => \"{}\",\n         tt::DelimiterKind::Bracket => \"[]\",\n+        tt::DelimiterKind::Invisible => return None,\n     };\n \n     let idx = closing as usize;\n-    &texts[idx..texts.len() - (1 - idx)]\n+    Some(&texts[idx..texts.len() - (1 - idx)])\n }\n \n impl<'a> TtTreeSink<'a> {\n+    /// Parses a float literal as if it was a one to two name ref nodes with a dot inbetween.\n+    /// This occurs when a float literal is used as a field access.\n+    fn float_split(&mut self, has_pseudo_dot: bool) {\n+        let (text, _span) = match self.cursor.token_tree() {\n+            Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Literal(lit), _)) => {\n+                (lit.text.as_str(), lit.span)\n+            }\n+            _ => unreachable!(),\n+        };\n+        match text.split_once('.') {\n+            Some((left, right)) => {\n+                assert!(!left.is_empty());\n+                self.inner.start_node(SyntaxKind::NAME_REF);\n+                self.inner.token(SyntaxKind::INT_NUMBER, left);\n+                self.inner.finish_node();\n+\n+                // here we move the exit up, the original exit has been deleted in process\n+                self.inner.finish_node();\n+\n+                self.inner.token(SyntaxKind::DOT, \".\");\n+\n+                if has_pseudo_dot {\n+                    assert!(right.is_empty(), \"{left}.{right}\");\n+                } else {\n+                    self.inner.start_node(SyntaxKind::NAME_REF);\n+                    self.inner.token(SyntaxKind::INT_NUMBER, right);\n+                    self.inner.finish_node();\n+\n+                    // the parser creates an unbalanced start node, we are required to close it here\n+                    self.inner.finish_node();\n+                }\n+            }\n+            None => unreachable!(),\n+        }\n+        self.cursor = self.cursor.bump();\n+    }\n+\n     fn token(&mut self, kind: SyntaxKind, mut n_tokens: u8) {\n         if kind == LIFETIME_IDENT {\n             n_tokens = 2;\n@@ -790,13 +853,16 @@ impl<'a> TtTreeSink<'a> {\n                     Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n                         // Mark the range if needed\n                         let (text, id) = match leaf {\n-                            tt::Leaf::Ident(ident) => (ident.text.as_str(), ident.id),\n+                            tt::Leaf::Ident(ident) => (ident.text.as_str(), ident.span),\n                             tt::Leaf::Punct(punct) => {\n                                 assert!(punct.char.is_ascii());\n                                 tmp = punct.char as u8;\n-                                (std::str::from_utf8(std::slice::from_ref(&tmp)).unwrap(), punct.id)\n+                                (\n+                                    std::str::from_utf8(std::slice::from_ref(&tmp)).unwrap(),\n+                                    punct.span,\n+                                )\n                             }\n-                            tt::Leaf::Literal(lit) => (lit.text.as_str(), lit.id),\n+                            tt::Leaf::Literal(lit) => (lit.text.as_str(), lit.span),\n                         };\n                         let range = TextRange::at(self.text_pos, TextSize::of(text));\n                         self.token_map.insert(id, range);\n@@ -805,26 +871,32 @@ impl<'a> TtTreeSink<'a> {\n                     }\n                     Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n                         self.cursor = self.cursor.subtree().unwrap();\n-                        match subtree.delimiter {\n-                            Some(d) => {\n-                                self.open_delims.insert(d.id, self.text_pos);\n-                                delim_to_str(d.kind, false)\n+                        match delim_to_str(subtree.delimiter.kind, false) {\n+                            Some(it) => {\n+                                self.open_delims.insert(subtree.delimiter.open, self.text_pos);\n+                                it\n                             }\n                             None => continue,\n                         }\n                     }\n                     None => {\n                         let parent = self.cursor.end().unwrap();\n                         self.cursor = self.cursor.bump();\n-                        match parent.delimiter {\n-                            Some(d) => {\n-                                if let Some(open_delim) = self.open_delims.get(&d.id) {\n+                        match delim_to_str(parent.delimiter.kind, true) {\n+                            Some(it) => {\n+                                if let Some(open_delim) =\n+                                    self.open_delims.get(&parent.delimiter.open)\n+                                {\n                                     let open_range = TextRange::at(*open_delim, TextSize::of('('));\n                                     let close_range =\n                                         TextRange::at(self.text_pos, TextSize::of('('));\n-                                    self.token_map.insert_delim(d.id, open_range, close_range);\n+                                    self.token_map.insert_delim(\n+                                        parent.delimiter.open,\n+                                        open_range,\n+                                        close_range,\n+                                    );\n                                 }\n-                                delim_to_str(d.kind, true)\n+                                it\n                             }\n                             None => continue,\n                         }"}, {"sha": "fa0125f3e9e04d8c2f91b0615378c7cb60e58123", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge%2Ftests.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -29,8 +29,8 @@ fn check_punct_spacing(fixture: &str) {\n     let mut cursor = buf.begin();\n     while !cursor.eof() {\n         while let Some(token_tree) = cursor.token_tree() {\n-            if let TokenTreeRef::Leaf(Leaf::Punct(Punct { spacing, id, .. }), _) = token_tree {\n-                if let Some(expected) = annotations.remove(id) {\n+            if let TokenTreeRef::Leaf(Leaf::Punct(Punct { spacing, span, .. }), _) = token_tree {\n+                if let Some(expected) = annotations.remove(span) {\n                     assert_eq!(expected, *spacing);\n                 }\n             }"}, {"sha": "051e20b3a3f9c21b0b9efe8983b5f2b872bac307", "filename": "src/tools/rust-analyzer/crates/mbe/src/to_parser_input.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fto_parser_input.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,7 +2,8 @@\n //! format that works for our parser.\n \n use syntax::{SyntaxKind, SyntaxKind::*, T};\n-use tt::buffer::TokenBuffer;\n+\n+use crate::tt::buffer::TokenBuffer;\n \n pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n     let mut res = parser::Input::default();\n@@ -44,6 +45,13 @@ pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n                             .unwrap_or_else(|| panic!(\"Fail to convert given literal {:#?}\", &lit));\n \n                         res.push(kind);\n+\n+                        if kind == FLOAT_NUMBER && !inner_text.ends_with('.') {\n+                            // Tag the token as joint if it is float with a fractional part\n+                            // we use this jointness to inform the parser about what token split\n+                            // event to emit when we encounter a float literal in a field access\n+                            res.was_joint();\n+                        }\n                     }\n                     tt::Leaf::Ident(ident) => match ident.text.as_ref() {\n                         \"_\" => res.push(T![_]),\n@@ -70,23 +78,25 @@ pub(crate) fn to_parser_input(buffer: &TokenBuffer<'_>) -> parser::Input {\n                 cursor.bump()\n             }\n             Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n-                if let Some(d) = subtree.delimiter_kind() {\n-                    res.push(match d {\n-                        tt::DelimiterKind::Parenthesis => T!['('],\n-                        tt::DelimiterKind::Brace => T!['{'],\n-                        tt::DelimiterKind::Bracket => T!['['],\n-                    });\n+                if let Some(kind) = match subtree.delimiter.kind {\n+                    tt::DelimiterKind::Parenthesis => Some(T!['(']),\n+                    tt::DelimiterKind::Brace => Some(T!['{']),\n+                    tt::DelimiterKind::Bracket => Some(T!['[']),\n+                    tt::DelimiterKind::Invisible => None,\n+                } {\n+                    res.push(kind);\n                 }\n                 cursor.subtree().unwrap()\n             }\n             None => match cursor.end() {\n                 Some(subtree) => {\n-                    if let Some(d) = subtree.delimiter_kind() {\n-                        res.push(match d {\n-                            tt::DelimiterKind::Parenthesis => T![')'],\n-                            tt::DelimiterKind::Brace => T!['}'],\n-                            tt::DelimiterKind::Bracket => T![']'],\n-                        })\n+                    if let Some(kind) = match subtree.delimiter.kind {\n+                        tt::DelimiterKind::Parenthesis => Some(T![')']),\n+                        tt::DelimiterKind::Brace => Some(T!['}']),\n+                        tt::DelimiterKind::Bracket => Some(T![']']),\n+                        tt::DelimiterKind::Invisible => None,\n+                    } {\n+                        res.push(kind);\n                     }\n                     cursor.bump()\n                 }"}, {"sha": "f744481f3aecbe9019c14296f7525f92d6e995f1", "filename": "src/tools/rust-analyzer/crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -3,9 +3,8 @@\n \n use smallvec::{smallvec, SmallVec};\n use syntax::SyntaxKind;\n-use tt::buffer::TokenBuffer;\n \n-use crate::{to_parser_input::to_parser_input, ExpandError, ExpandResult};\n+use crate::{to_parser_input::to_parser_input, tt, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone)]\n pub(crate) struct TtIter<'a> {\n@@ -114,7 +113,7 @@ impl<'a> TtIter<'a> {\n             ('.', '.', Some('.' | '=')) | ('<', '<', Some('=')) | ('>', '>', Some('=')) => {\n                 let _ = self.next().unwrap();\n                 let _ = self.next().unwrap();\n-                Ok(smallvec![first, second.clone(), third.unwrap().clone()])\n+                Ok(smallvec![first, *second, *third.unwrap()])\n             }\n             ('-' | '!' | '*' | '/' | '&' | '%' | '^' | '+' | '<' | '=' | '>' | '|', '=', _)\n             | ('-' | '=' | '>', '>', _)\n@@ -125,7 +124,7 @@ impl<'a> TtIter<'a> {\n             | ('<', '<', _)\n             | ('|', '|', _) => {\n                 let _ = self.next().unwrap();\n-                Ok(smallvec![first, second.clone()])\n+                Ok(smallvec![first, *second])\n             }\n             _ => Ok(smallvec![first]),\n         }\n@@ -135,7 +134,7 @@ impl<'a> TtIter<'a> {\n         &mut self,\n         entry_point: parser::PrefixEntryPoint,\n     ) -> ExpandResult<Option<tt::TokenTree>> {\n-        let buffer = TokenBuffer::from_tokens(self.inner.as_slice());\n+        let buffer = tt::buffer::TokenBuffer::from_tokens(self.inner.as_slice());\n         let parser_input = to_parser_input(&buffer);\n         let tree_traversal = entry_point.parse(&parser_input);\n \n@@ -151,6 +150,11 @@ impl<'a> TtIter<'a> {\n                         cursor = cursor.bump_subtree();\n                     }\n                 }\n+                parser::Step::FloatSplit { .. } => {\n+                    // FIXME: We need to split the tree properly here, but mutating the token trees\n+                    // in the buffer is somewhat tricky to pull off.\n+                    cursor = cursor.bump_subtree();\n+                }\n                 parser::Step::Enter { .. } | parser::Step::Exit => (),\n                 parser::Step::Error { .. } => error = true,\n             }\n@@ -167,19 +171,18 @@ impl<'a> TtIter<'a> {\n \n         if cursor.is_root() {\n             while curr != cursor {\n-                if let Some(token) = curr.token_tree() {\n-                    res.push(token);\n-                }\n+                let Some(token) = curr.token_tree() else { break };\n+                res.push(token.cloned());\n                 curr = curr.bump();\n             }\n         }\n+\n         self.inner = self.inner.as_slice()[res.len()..].iter();\n         let res = match res.len() {\n-            1 => Some(res[0].cloned()),\n-            0 => None,\n+            0 | 1 => res.pop(),\n             _ => Some(tt::TokenTree::Subtree(tt::Subtree {\n-                delimiter: None,\n-                token_trees: res.into_iter().map(|it| it.cloned()).collect(),\n+                delimiter: tt::Delimiter::unspecified(),\n+                token_trees: res,\n             })),\n         };\n         ExpandResult { value: res, err }"}, {"sha": "08359133f1aa7e1f83805fc4be0621cb4b894dc4", "filename": "src/tools/rust-analyzer/crates/parser/Cargo.toml", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -2,18 +2,22 @@\n name = \"parser\"\n version = \"0.0.0\"\n description = \"TBD\"\n-license = \"MIT OR Apache-2.0\"\n-edition = \"2021\"\n-rust-version = \"1.65\"\n+\n+authors.workspace = true\n+edition.workspace = true\n+license.workspace = true\n+rust-version.workspace = true\n \n [lib]\n doctest = false\n \n [dependencies]\n drop_bomb = \"0.1.5\"\n-rustc_lexer = { version = \"725.0.0\", package = \"rustc-ap-rustc_lexer\" }\n-limit = { path = \"../limit\", version = \"0.0.0\" }\n+rustc_lexer = { version = \"727.0.0\", package = \"rustc-ap-rustc_lexer\" }\n+\n+limit.workspace = true\n \n [dev-dependencies]\n expect-test = \"1.4.0\"\n-sourcegen = { path = \"../sourcegen\" }\n+\n+sourcegen.workspace = true"}, {"sha": "577eb0967b4263d4e3814bd0af9a6ccfaa329cad", "filename": "src/tools/rust-analyzer/crates/parser/src/event.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fevent.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a", "patch": "@@ -74,7 +74,13 @@ pub(crate) enum Event {\n         kind: SyntaxKind,\n         n_raw_tokens: u8,\n     },\n-\n+    /// When we parse `foo.0.0` or `foo. 0. 0` the lexer will hand us a float literal\n+    /// instead of an integer literal followed by a dot as the lexer has no contextual knowledge.\n+    /// This event instructs whatever consumes the events to split the float literal into\n+    /// the corresponding parts.\n+    FloatSplitHack {\n+        ends_in_dot: bool,\n+    },\n     Error {\n         msg: String,\n     },\n@@ -125,6 +131,11 @@ pub(super) fn process(mut events: Vec<Event>) -> Output {\n             Event::Token { kind, n_raw_tokens } => {\n                 res.token(kind, n_raw_tokens);\n             }\n+            Event::FloatSplitHack { ends_in_dot } => {\n+                res.float_split_hack(ends_in_dot);\n+                let ev = mem::replace(&mut events[i + 1], Event::tombstone());\n+                assert!(matches!(ev, Event::Finish), \"{ev:?}\");\n+            }\n             Event::Error { msg } => res.error(msg),\n         }\n     }"}, {"sha": "7516ac3c4bd37f3e9b04617159c5163dd3c24b8f", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "a23f900b73864b26a96f5f0b72ae106304116ff0", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "100deff462d25975adaf1ef136bec6b0fa232b7d", "filename": "src/tools/rust-analyzer/crates/parser/src/lexed_str.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flexed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flexed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flexed_str.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "8c5aed0232ba3282f841e831ed3b318c1cd66fb3", "filename": "src/tools/rust-analyzer/crates/parser/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "41d4c68b2d7486c69a969112c4d39ac8ca03ea36", "filename": "src/tools/rust-analyzer/crates/parser/src/output.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Foutput.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "280416ae7c99462af6c452984297ab4e31d32578", "filename": "src/tools/rust-analyzer/crates/parser/src/parser.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fparser.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "47e4adcbbe6955acf6f345c81d37fff55f911ecb", "filename": "src/tools/rust-analyzer/crates/parser/src/shortcuts.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fshortcuts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fshortcuts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fshortcuts.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "40f92e58804f925018c59518a66f811594794169", "filename": "src/tools/rust-analyzer/crates/parser/src/tests/prefix_entries.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Fprefix_entries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Fprefix_entries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Fprefix_entries.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "dd27dc48964242015e5420418f085d7037ed0597", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0011_field_expr.rast", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rast?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "98dbe45a7ec92531842c86179be30b2d38e3d133", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0011_field_expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0011_field_expr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "b28b8eb673a7033c5990b54f75e758f8369e0d3e", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0107_method_call_expr.rast", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rast?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "48bb6381e80bf8e84bd173457137457595e3ef45", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0107_method_call_expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0107_method_call_expr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "af713a22072fe5d4e67a81d978742708263651a6", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0137_await_expr.rast", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rast", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rast?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "fe9a3211bb18d2061eb86e8702bfe991d747068c", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0137_await_expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0137_await_expr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "06442a1d0f1f7f555047518551cf44bd14e8480f", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0205_const_closure.rast", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0205_const_closure.rast", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0205_const_closure.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0205_const_closure.rast?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "0c05cc70bd37699b7e0ea21e56e477c1618696e5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0205_const_closure.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0205_const_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0205_const_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0205_const_closure.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "e24e6eceffbd9f28896481661c2d7dbe77164d00", "filename": "src/tools/rust-analyzer/crates/paths/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "28469b832468b4fd0d799d7fe03dd45ba21a205e", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/Cargo.toml", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "90d06967e8fc0502cee77c38780e4add6b3b7e3d", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "4040efe93f093fad5bd84dbc4f53c4ce076c5ff4", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/msg.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "fd3202e0b284c3794897a84894bfee5f481f9609", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/msg/flat.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "1ccbd780fdda33067a2ffe140906de8955a5a156", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/process.rs", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fprocess.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "c402bc02253c2c38c71e65e7ae616a55ba8a3f98", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv-cli/Cargo.toml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv-cli%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "f7f07cfcb2e27c9c7256f7b34434372f9761a304", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "1c91ac0fa1b8fb66d821b166bc52de075a2ed4fb", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/mod.rs", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fmod.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "d82669d3e2336622942d127aaf5ca0c2ad501e9e", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/buffer.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "e78842f5c37ec831b89f988051056f60b58106ad", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/client.rs", "status": "removed", "additions": 0, "deletions": 485, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclient.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "5be71cc3d70136c46f71483e57ca59428dbf358d", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/closure.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "bcbb86812470a3e9702c0291cea97dec0efc9c26", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/handle.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "b7968c529c30fe6fdde2881c142af6d9b177c5e1", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/mod.rs", "status": "removed", "additions": 0, "deletions": 429, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fmod.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "d50564d01a5d2d9371f16355055d5c18604b68b1", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/rpc.rs", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Frpc.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "b0c2e5b9c26b1c69189d6281684e9646cdcb39cf", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/scoped_cell.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "06a19791351a485674dd4ed2843c43bfdb5e9356", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/bridge/server.rs", "status": "removed", "additions": 0, "deletions": 352, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fbridge%2Fserver.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "cda239f87850012cf1831a7df84558fca3bff1ab", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/diagnostic.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fdiagnostic.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "c5145d00e329e6c22fb75baa2336b5ea0b2091e5", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/mod.rs", "status": "removed", "additions": 0, "deletions": 1056, "changes": 1056, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "b539ab9c0c6d6b236de6995f626013743bd21864", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/quote.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fquote.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "22d4ad94f770e8e59329d98562bf53a579f34d16", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/ra_server.rs", "status": "removed", "additions": 0, "deletions": 822, "changes": 822, "blob_url": "https://github.com/rust-lang/rust/blob/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c9eede5d50be0231f229bf28a271cd509861a3/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs?ref=a3c9eede5d50be0231f229bf28a271cd509861a3"}, {"sha": "93805c89354a5d7fff1b4463e1776c0d8083bfa5", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_63/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "89bd10da5e4863392935b1d96517ebd39db5608b", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "30baf3a13f57f5399857619510ac6ed8cd37e5be", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_63/ra_server.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "0a3b8866a7fd5c2e1f872b7259ee3a85d455beec", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_sysroot/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "d258a02472909c878dc044e1e2007c5f6b048d98", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_sysroot/ra_server.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "d091d431900a030a737b0946ce33424be9618ac4", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_sysroot/ra_server/token_stream.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "04be39cffa4adbba3b179dc9a9cf872553c719a8", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "05168feb629f2fc9ec05bbe58f2f8c40abcc7670", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/cli.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fcli.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "89ffd1f493e29fb97c24e872f56df897e3e8f261", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/dylib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "ee70fe7d4f54140f95e033f09ab572e276a59550", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "04a0ae7bc72017a3f34709e1ece9f01364ef97b4", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "77b4afd7d7e1334754ead99c7312bf1cc4a59482", "filename": "src/tools/rust-analyzer/crates/proc-macro-test/Cargo.toml", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "2a36737cef05856eb6ef345e4f375b954294bbcc", "filename": "src/tools/rust-analyzer/crates/proc-macro-test/imp/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-test%2Fimp%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "6273ea51db839a0389bc62437471b1c61da1c92e", "filename": "src/tools/rust-analyzer/crates/profile/Cargo.toml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "e7fc3d970bfff31c15c506e09608d4ae8e0c440f", "filename": "src/tools/rust-analyzer/crates/profile/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "22d6a6e78957c2c5663d8a929201e465750c8bd6", "filename": "src/tools/rust-analyzer/crates/project-model/Cargo.toml", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "fdc7859eb90fb82b88ea2e8c5989b02e65f4960e", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "9b6a71db811454d2084b9a1b14fd88a10cbc16e4", "filename": "src/tools/rust-analyzer/crates/project-model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "4b2448e47f1ff09d2d61a52febf6e736b8cf7a31", "filename": "src/tools/rust-analyzer/crates/project-model/src/project_json.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fproject_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fproject_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fproject_json.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "328d2fbcf31f4aa77d934f8d1b80bda25d407d1b", "filename": "src/tools/rust-analyzer/crates/project-model/src/sysroot.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "42c06ad0ed3717ba1388d721f8b806080e5f1ab7", "filename": "src/tools/rust-analyzer/crates/project-model/src/target_data_layout.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftarget_data_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftarget_data_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftarget_data_layout.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "9e9691d11e854f33e12c937a0b31cad9c6c58b0a", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 90, "deletions": 38, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "2a11f1e8eb820508246c3c13db03d082a741aabc", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 163, "deletions": 67, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "e3aa880d00583277af1352a8de1b4b5da80ec014", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "4de022b6ed6076a522b866fd383ee71fa3c8ee28", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "841861635c6ee5b8e40ca8e87175430a5a8f309a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "93297faa664d108066f3bdb695fe99a65266a732", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "ff821be53d83d16b9ee0fb77007fbf7bb835ab2d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "5a958d963e4b5c74a3c9f5eb91e50c98ae04b855", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "60a7f99ccdb857a1fb35b122e36780d79c244458", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "9a04fbea7747b2b18b79484b96c6f637e18e904b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "3552f840a1b76804c233122615320254ff4eaf8c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "be09938c2c4a4b700574aa663744de3c5a99f1c4", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "73d2ed329845a72b5d18fada085eb35e9e9ff9e8", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config/patch_old_style.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig%2Fpatch_old_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig%2Fpatch_old_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig%2Fpatch_old_style.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "55b89019b47a8f09d09246725ef661d03b0b8c6c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "aca6c92357070752258d6b05dd6e7de61b671c31", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "4e08bd0a724a205af703ed44cac44f2004450db3", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 13, "deletions": 53, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "e8912b90796ac6c02f90bb804dbc0a2e90eac84b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/integrated_benchmarks.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "08b2c837de370bf9adc86a0ba48efae98fbd3050", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "baa77a005e226545ec8ae5ce8bcb38c64d05182c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "346a74e270f99deeac63e031ea2d1b59ff0535e5", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "5ac5af94f5aefd1a37b81f8acbdd1d4f0e714163", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "5bdc1bf8d9bb7ea0a83814b012170dab19ad1979", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 110, "deletions": 101, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "b7275df0f4019e67bafe70a4b4cd70d262206860", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "8e3097fce4230a556d42d6bf1195913296372b95", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "fb2b9ebef506df24dcdcb8af2f1593883a7a8832", "filename": "src/tools/rust-analyzer/crates/sourcegen/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "c881f2fd3f45e075f97c5382ee91dbf24fb08ff9", "filename": "src/tools/rust-analyzer/crates/stdx/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "bd24d7d28bac936545cddd7eb79db6a273972914", "filename": "src/tools/rust-analyzer/crates/stdx/src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "1a9982fa8b2a7f9d6e14f01ca5d5e35c4d8c7476", "filename": "src/tools/rust-analyzer/crates/stdx/src/macros.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fmacros.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "8fc493a23f5e74dde1c70981b2f56cfafe027547", "filename": "src/tools/rust-analyzer/crates/syntax/Cargo.toml", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "6070222f1f192431345893e67e7e2fd6031751a7", "filename": "src/tools/rust-analyzer/crates/syntax/fuzz/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Ffuzz%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "36ad5fddfd0c50cfa17680855aa9b532ef0dd8a3", "filename": "src/tools/rust-analyzer/crates/syntax/rust.ungram", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "385a4e0a3cee1e5c515c4bbd8996c08387470291", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "642a3bfc35d13c5a4eb71faabd30c7b5b5641cf9", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "5aebe4cd9f53aa98ef194d41ed8853fa38d52b00", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/make.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "2e9e0bc226b9d4889a3adee7c3d617fa4f69a366", "filename": "src/tools/rust-analyzer/crates/syntax/src/syntax_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fsyntax_node.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "25f34ea9d397d747f91cf06e6aaf31613c9d2f80", "filename": "src/tools/rust-analyzer/crates/syntax/src/utils.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Futils.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "92b1ef23e69cefdc4fa22f65b33718974882f102", "filename": "src/tools/rust-analyzer/crates/test-utils/Cargo.toml", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "3b033e1aae531b5d0191ed11f09a07117fbbd082", "filename": "src/tools/rust-analyzer/crates/test-utils/src/minicore.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "337cd234739c8d4819b13ef4b24254575103ce07", "filename": "src/tools/rust-analyzer/crates/text-edit/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "a283f9a8842145140c15e73401aaf05544d7dd2e", "filename": "src/tools/rust-analyzer/crates/toolchain/Cargo.toml", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "b8469383183b6984ff9c5e8ea447128945f6f056", "filename": "src/tools/rust-analyzer/crates/tt/Cargo.toml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "0615a3763dfa1c172c8be30ea9de0d00693c1b76", "filename": "src/tools/rust-analyzer/crates/tt/src/buffer.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2Fsrc%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2Fsrc%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2Fsrc%2Fbuffer.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "b7dbc82e1d66e2ec14859448168c189d867fdb56", "filename": "src/tools/rust-analyzer/crates/tt/src/lib.rs", "status": "modified", "additions": 138, "deletions": 90, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftt%2Fsrc%2Flib.rs?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "e06b98d8118b622c5919719412c0140b105634a6", "filename": "src/tools/rust-analyzer/crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}, {"sha": "802a300060fa18da0be7c399bcf98b89ad96e967", "filename": "src/tools/rust-analyzer/crates/vfs/Cargo.toml", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/065852def0903296da33a9eaf557f230bcf3a61a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml?ref=065852def0903296da33a9eaf557f230bcf3a61a"}]}