{"sha": "9d3483a74dba6b0a338230fd003d91a0447c5398", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMzQ4M2E3NGRiYTZiMGEzMzgyMzBmZDAwM2Q5MWEwNDQ3YzUzOTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-24T12:23:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-24T12:23:28Z"}, "message": "Merge #5846\n\n5846: Add references to fn args during completion r=matklad a=adamrk\n\nWhen completing a function call, if there is an argument taken as a ref or mut ref which matches the name and type of a variable in scope, we will insert a `&` or `&mut` when filling in the function arguments. This addresses https://github.com/rust-analyzer/rust-analyzer/issues/5449.\r\n\r\nE.g. \r\n```rust\r\nfn foo(x: &i32) {}\r\nfn main() {\r\n  let x = 5;\r\n  foo # completing foo here generates `foo(&x)` now instead of `foo(x)`\r\n}\r\n```\n\nCo-authored-by: adamrk <ark.email@gmail.com>", "tree": {"sha": "4439388ec3467138500985160ace14db433f784b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4439388ec3467138500985160ace14db433f784b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3483a74dba6b0a338230fd003d91a0447c5398", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfbI/ACRBK7hj4Ov3rIwAAdHIIAHyNfrIyA2ydIBrWtmSdZ0Z2\nLup19B/8ZDK5x4Jf4CcuNqtJU774ZCFCpipJds3TepJLyZEYG3Lcy7jGJtY/PAqB\nusdVujXX8bsUo96Ys929uIQh7gHDVTrzGyTx4yMMkqcAyMyuY7f+wUfcLZ/90HcR\nf6AdFdv9NeKRyhOQcT4idYiGfLwEW7cpYvayQNjfjyCVs/F6k/7QTZYKp875/fJA\n2jNuO9PHrUxIvBwEM8KTW33iXulctdDeVhdokydfuJqahRZNRCH4H8K4SwLNnSuc\nOyPc7VVS6LXOxRzMdk3AGqb38zb7fEHJiSz1VDw8eZre+FIV36cUaIP6Cj9ZrEM=\n=0YcG\n-----END PGP SIGNATURE-----\n", "payload": "tree 4439388ec3467138500985160ace14db433f784b\nparent 4ddb8124b01a04adcc7d42444f7ca8d377bb60ae\nparent 5cd2c67c25e8f85625620f24d894973fcab41c8c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1600950208 +0000\ncommitter GitHub <noreply@github.com> 1600950208 +0000\n\nMerge #5846\n\n5846: Add references to fn args during completion r=matklad a=adamrk\n\nWhen completing a function call, if there is an argument taken as a ref or mut ref which matches the name and type of a variable in scope, we will insert a `&` or `&mut` when filling in the function arguments. This addresses https://github.com/rust-analyzer/rust-analyzer/issues/5449.\r\n\r\nE.g. \r\n```rust\r\nfn foo(x: &i32) {}\r\nfn main() {\r\n  let x = 5;\r\n  foo # completing foo here generates `foo(&x)` now instead of `foo(x)`\r\n}\r\n```\n\nCo-authored-by: adamrk <ark.email@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3483a74dba6b0a338230fd003d91a0447c5398", "html_url": "https://github.com/rust-lang/rust/commit/9d3483a74dba6b0a338230fd003d91a0447c5398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3483a74dba6b0a338230fd003d91a0447c5398/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ddb8124b01a04adcc7d42444f7ca8d377bb60ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ddb8124b01a04adcc7d42444f7ca8d377bb60ae", "html_url": "https://github.com/rust-lang/rust/commit/4ddb8124b01a04adcc7d42444f7ca8d377bb60ae"}, {"sha": "5cd2c67c25e8f85625620f24d894973fcab41c8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd2c67c25e8f85625620f24d894973fcab41c8c", "html_url": "https://github.com/rust-lang/rust/commit/5cd2c67c25e8f85625620f24d894973fcab41c8c"}], "stats": {"total": 169, "additions": 161, "deletions": 8}, "files": [{"sha": "a2a166e0aed50e3f2913fe9b99d38964bbc2c791", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d3483a74dba6b0a338230fd003d91a0447c5398/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3483a74dba6b0a338230fd003d91a0447c5398/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=9d3483a74dba6b0a338230fd003d91a0447c5398", "patch": "@@ -709,11 +709,23 @@ impl Function {\n     }\n \n     pub fn params(self, db: &dyn HirDatabase) -> Vec<Param> {\n+        let resolver = self.id.resolver(db.upcast());\n+        let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n+        let environment = TraitEnvironment::lower(db, &resolver);\n         db.function_data(self.id)\n             .params\n             .iter()\n             .skip(if self.self_param(db).is_some() { 1 } else { 0 })\n-            .map(|_| Param { _ty: () })\n+            .map(|type_ref| {\n+                let ty = Type {\n+                    krate: self.id.lookup(db.upcast()).container.module(db.upcast()).krate,\n+                    ty: InEnvironment {\n+                        value: Ty::from_hir_ext(&ctx, type_ref).0,\n+                        environment: environment.clone(),\n+                    },\n+                };\n+                Param { ty }\n+            })\n             .collect()\n     }\n \n@@ -742,15 +754,21 @@ impl From<Mutability> for Access {\n     }\n }\n \n+pub struct Param {\n+    ty: Type,\n+}\n+\n+impl Param {\n+    pub fn ty(&self) -> &Type {\n+        &self.ty\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n     func: FunctionId,\n }\n \n-pub struct Param {\n-    _ty: (),\n-}\n-\n impl SelfParam {\n     pub fn access(self, db: &dyn HirDatabase) -> Access {\n         let func_data = db.function_data(self.func);\n@@ -1276,6 +1294,14 @@ impl Type {\n         )\n     }\n \n+    pub fn remove_ref(&self) -> Option<Type> {\n+        if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(_), .. }) = self.ty.value {\n+            self.ty.value.substs().map(|substs| self.derived(substs[0].clone()))\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn is_unknown(&self) -> bool {\n         matches!(self.ty.value, Ty::Unknown)\n     }"}, {"sha": "671b13328c63160a9c555469731c46a80705a116", "filename": "crates/ide/src/completion/completion_context.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d3483a74dba6b0a338230fd003d91a0447c5398/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3483a74dba6b0a338230fd003d91a0447c5398/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=9d3483a74dba6b0a338230fd003d91a0447c5398", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use base_db::SourceDatabase;\n-use hir::{Semantics, SemanticsScope, Type};\n+use hir::{Local, ScopeDef, Semantics, SemanticsScope, Type};\n use ide_db::RootDatabase;\n use syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n@@ -91,6 +91,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) impl_as_prev_sibling: bool,\n     pub(super) is_match_arm: bool,\n     pub(super) has_item_list_or_source_file_parent: bool,\n+    pub(super) locals: Vec<(String, Local)>,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -119,6 +120,12 @@ impl<'a> CompletionContext<'a> {\n             original_file.syntax().token_at_offset(position.offset).left_biased()?;\n         let token = sema.descend_into_macros(original_token.clone());\n         let scope = sema.scope_at_offset(&token.parent(), position.offset);\n+        let mut locals = vec![];\n+        scope.process_all_names(&mut |name, scope| {\n+            if let ScopeDef::Local(local) = scope {\n+                locals.push((name.to_string(), local));\n+            }\n+        });\n         let mut ctx = CompletionContext {\n             sema,\n             scope,\n@@ -167,6 +174,7 @@ impl<'a> CompletionContext<'a> {\n             if_is_prev: false,\n             is_match_arm: false,\n             has_item_list_or_source_file_parent: false,\n+            locals,\n         };\n \n         let mut original_file = original_file.syntax().clone();"}, {"sha": "987cbfa7a86d2d94b4884dc17243a2e5c032d93a", "filename": "crates/ide/src/completion/presentation.rs", "status": "modified", "additions": 121, "deletions": 2, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/9d3483a74dba6b0a338230fd003d91a0447c5398/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3483a74dba6b0a338230fd003d91a0447c5398/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=9d3483a74dba6b0a338230fd003d91a0447c5398", "patch": "@@ -191,6 +191,17 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<String>,\n     ) {\n+        fn add_arg(arg: &str, ty: &Type, ctx: &CompletionContext) -> String {\n+            if let Some(derefed_ty) = ty.remove_ref() {\n+                for (name, local) in ctx.locals.iter() {\n+                    if name == arg && local.ty(ctx.db) == derefed_ty {\n+                        return (if ty.is_mutable_reference() { \"&mut \" } else { \"&\" }).to_string()\n+                            + &arg.to_string();\n+                    }\n+                }\n+            }\n+            arg.to_string()\n+        };\n         let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;\n \n@@ -205,12 +216,20 @@ impl Completions {\n                 .set_deprecated(is_deprecated(func, ctx.db))\n                 .detail(function_declaration(&ast_node));\n \n+        let params_ty = func.params(ctx.db);\n         let params = ast_node\n             .param_list()\n             .into_iter()\n             .flat_map(|it| it.params())\n-            .flat_map(|it| it.pat())\n-            .map(|pat| pat.to_string().trim_start_matches('_').into())\n+            .zip(params_ty)\n+            .flat_map(|(it, param_ty)| {\n+                if let Some(pat) = it.pat() {\n+                    let name = pat.to_string();\n+                    let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n+                    return Some(add_arg(arg, param_ty.ty(), ctx));\n+                }\n+                None\n+            })\n             .collect();\n \n         builder = builder.add_call_parens(ctx, name, Params::Named(params));\n@@ -863,6 +882,106 @@ fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n         );\n     }\n \n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_mut_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&mut x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope_for_method() {\n+        check_edit(\n+            \"apply_foo\",\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.apply_foo(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trim_mut_keyword_in_func_completion() {\n+        check_edit(\n+            \"take_mutably\",\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_m<|>\n+}\n+\"#,\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_mutably(${1:x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn inserts_parens_for_tuple_enums() {\n         mark::check!(inserts_parens_for_tuple_enums);"}]}