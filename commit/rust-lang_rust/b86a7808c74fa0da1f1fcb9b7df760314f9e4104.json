{"sha": "b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NmE3ODA4Yzc0ZmEwZGExZjFmY2I5YjdkZjc2MDMxNGY5ZTQxMDQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-11-15T03:44:55Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-11-25T06:10:32Z"}, "message": "Add methods to go from a slice iterators to a slice.\n\nA slice iterator is isomorphic to a slice, just with a slightly\ndifferent form: storing start and end pointers rather than start pointer\nand length. This patch reflects this by making converting between them\nas easy as `iter.as_slice()` (or even `iter[]` if the shorter lifetime\nis ok). That is, `slice.iter().as_slice() == slice`.", "tree": {"sha": "40bc88044c4b03681b4c67d2b4373e0649e8c95f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40bc88044c4b03681b4c67d2b4373e0649e8c95f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "html_url": "https://github.com/rust-lang/rust/commit/b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b86a7808c74fa0da1f1fcb9b7df760314f9e4104/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb2168c5252adeda1dd35ccf7050df89655233d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb2168c5252adeda1dd35ccf7050df89655233d7", "html_url": "https://github.com/rust-lang/rust/commit/bb2168c5252adeda1dd35ccf7050df89655233d7"}], "stats": {"total": 145, "additions": 145, "deletions": 0}, "files": [{"sha": "65f617911278b7d8898598593eef996edfb9fdda", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b86a7808c74fa0da1f1fcb9b7df760314f9e4104/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86a7808c74fa0da1f1fcb9b7df760314f9e4104/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "patch": "@@ -1092,6 +1092,21 @@ macro_rules! iterator {\n     }\n }\n \n+macro_rules! make_slice {\n+    ($t: ty -> $result: ty: $start: expr, $end: expr) => {{\n+        let diff = $end as uint - $start as uint;\n+        let len = if mem::size_of::<T>() == 0 {\n+            diff\n+        } else {\n+            diff / mem::size_of::<$t>()\n+        };\n+        unsafe {\n+            transmute::<_, $result>(RawSlice { data: $start as *const T, len: len })\n+        }\n+    }}\n+}\n+\n+\n /// Immutable slice iterator\n #[experimental = \"needs review\"]\n pub struct Items<'a, T: 'a> {\n@@ -1100,6 +1115,36 @@ pub struct Items<'a, T: 'a> {\n     marker: marker::ContravariantLifetime<'a>\n }\n \n+#[experimental]\n+impl<'a, T> ops::Slice<uint, [T]> for Items<'a, T> {\n+    fn as_slice_(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice().slice_from_or_fail(from)\n+    }\n+    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice().slice_to_or_fail(to)\n+    }\n+    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice().slice_or_fail(from, to)\n+    }\n+}\n+\n+impl<'a, T> Items<'a, T> {\n+    /// View the underlying data as a subslice of the original data.\n+    ///\n+    /// This has the same lifetime as the original slice, and so the\n+    /// iterator can continue to be used while this exists.\n+    #[experimental]\n+    pub fn as_slice(&self) -> &'a [T] {\n+        make_slice!(T -> &'a [T]: self.ptr, self.end)\n+    }\n+}\n+\n iterator!{struct Items -> *const T, &'a T}\n \n #[experimental = \"needs review\"]\n@@ -1144,6 +1189,57 @@ pub struct MutItems<'a, T: 'a> {\n     marker2: marker::NoCopy\n }\n \n+#[experimental]\n+impl<'a, T> ops::Slice<uint, [T]> for MutItems<'a, T> {\n+    fn as_slice_<'b>(&'b self) -> &'b [T] {\n+        make_slice!(T -> &'b [T]: self.ptr, self.end)\n+    }\n+    fn slice_from_or_fail<'b>(&'b self, from: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice_().slice_from_or_fail(from)\n+    }\n+    fn slice_to_or_fail<'b>(&'b self, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice_().slice_to_or_fail(to)\n+    }\n+    fn slice_or_fail<'b>(&'b self, from: &uint, to: &uint) -> &'b [T] {\n+        use ops::Slice;\n+        self.as_slice_().slice_or_fail(from, to)\n+    }\n+}\n+\n+#[experimental]\n+impl<'a, T> ops::SliceMut<uint, [T]> for MutItems<'a, T> {\n+    fn as_mut_slice_<'b>(&'b mut self) -> &'b mut [T] {\n+        make_slice!(T -> &'b mut [T]: self.ptr, self.end)\n+    }\n+    fn slice_from_or_fail_mut<'b>(&'b mut self, from: &uint) -> &'b mut [T] {\n+        use ops::SliceMut;\n+        self.as_mut_slice_().slice_from_or_fail_mut(from)\n+    }\n+    fn slice_to_or_fail_mut<'b>(&'b mut self, to: &uint) -> &'b mut [T] {\n+        use ops::SliceMut;\n+        self.as_mut_slice_().slice_to_or_fail_mut(to)\n+    }\n+    fn slice_or_fail_mut<'b>(&'b mut self, from: &uint, to: &uint) -> &'b mut [T] {\n+        use ops::SliceMut;\n+        self.as_mut_slice_().slice_or_fail_mut(from, to)\n+    }\n+}\n+\n+impl<'a, T> MutItems<'a, T> {\n+    /// View the underlying data as a subslice of the original data.\n+    ///\n+    /// To avoid creating `&mut` references that alias, this is forced\n+    /// to consume the iterator. Consider using the `Slice` and\n+    /// `SliceMut` implementations for obtaining slices with more\n+    /// restricted lifetimes that do not consume the iterator.\n+    #[experimental]\n+    pub fn into_slice(self) -> &'a mut [T] {\n+        make_slice!(T -> &'a mut [T]: self.ptr, self.end)\n+    }\n+}\n+\n iterator!{struct MutItems -> *mut T, &'a mut T}\n \n #[experimental = \"needs review\"]"}, {"sha": "29253c50ed0650243fb8e7c30249d09fcb7cb7af", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b86a7808c74fa0da1f1fcb9b7df760314f9e4104/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86a7808c74fa0da1f1fcb9b7df760314f9e4104/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=b86a7808c74fa0da1f1fcb9b7df760314f9e4104", "patch": "@@ -33,3 +33,52 @@ fn binary_search_not_found() {\n     let b = [1i, 2, 4, 5, 6, 8];\n     assert!(b.binary_search(|v| v.cmp(&9)) == NotFound(6));\n }\n+\n+#[test]\n+fn iterator_to_slice() {\n+    macro_rules! test {\n+        ($data: expr) => {{\n+            let data: &mut [_] = &mut $data;\n+            let other_data: &mut [_] = &mut $data;\n+\n+            {\n+                let mut iter = data.iter();\n+                assert_eq!(iter[], other_data[]);\n+\n+                iter.next();\n+                assert_eq!(iter[], other_data[1..]);\n+\n+                iter.next_back();\n+                assert_eq!(iter[], other_data[1..2]);\n+\n+                let s = iter.as_slice();\n+                iter.next();\n+                assert_eq!(s, other_data[1..2]);\n+            }\n+            {\n+                let mut iter = data.iter_mut();\n+                assert_eq!(iter[], other_data[]);\n+                // mutability:\n+                assert!(iter[mut] == other_data);\n+\n+                iter.next();\n+                assert_eq!(iter[], other_data[1..]);\n+                assert!(iter[mut] == other_data[mut 1..]);\n+\n+                iter.next_back();\n+\n+                assert_eq!(iter[], other_data[1..2]);\n+                assert!(iter[mut] == other_data[mut 1..2]);\n+\n+                let s = iter.into_slice();\n+                assert!(s == other_data[mut 1..2]);\n+            }\n+        }}\n+    }\n+\n+    // try types of a variety of sizes\n+    test!([(1u64, 1u64, 1u8), (2, 2, 2), (3, 3, 3)]);\n+    test!([1u64,2,3]);\n+    test!([1u8,2,3]);\n+    test!([(),(),()]);\n+}"}]}