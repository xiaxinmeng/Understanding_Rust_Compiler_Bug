{"sha": "5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMTJjZDcyZjQ3NzRhZjhjYTFjM2M5YzAxMTViNGIxYTcyNDA0YmI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-11T23:18:00Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-11T23:20:01Z"}, "message": "Allow classes to implement ifaces\n\nIntroduce syntax like:\n\niface animal { ... }\nclass cat implements animal { ... }\n\nto allow classes to implement ifaces. Casting classes to ifaces\nis *not* yet supported. ifaces that a class implements are not\nyet included in metadata.\n\nThe syntax is subject to change, and may go away completely if we\ndecide to use duck typing to relate classes with ifaces (see\nhttp://smallcultfollowing.com/babysteps/blog/2012/04/10/declared-vs-duckish-typing/ )", "tree": {"sha": "6e6982510b2cb091ed01f3072841fadd18691460", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e6982510b2cb091ed01f3072841fadd18691460"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "html_url": "https://github.com/rust-lang/rust/commit/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fda1578a219a8762fadddfd37c45abdd6a271a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fda1578a219a8762fadddfd37c45abdd6a271a1", "html_url": "https://github.com/rust-lang/rust/commit/9fda1578a219a8762fadddfd37c45abdd6a271a1"}], "stats": {"total": 325, "additions": 242, "deletions": 83}, "files": [{"sha": "fa190a120e9b4c2716faee0588e52e97b77001ed", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -641,6 +641,9 @@ enum attr_style { attr_outer, attr_inner, }\n #[auto_serialize]\n type attribute_ = {style: attr_style, value: meta_item};\n \n+#[auto_serialize]\n+type iface_ref = {path: @path, id: node_id};\n+\n #[auto_serialize]\n type item = {ident: ident, attrs: [attribute],\n              id: node_id, node: item_, span: span};\n@@ -656,6 +659,7 @@ enum item_ {\n     item_res(fn_decl /* dtor */, [ty_param], blk /* dtor body */,\n              node_id /* dtor id */, node_id /* ctor id */),\n     item_class([ty_param], /* ty params for class */\n+               [iface_ref],   /* ifaces this class implements */\n                [@class_member], /* methods, etc. */\n                                /* (not including ctor) */\n                class_ctor"}, {"sha": "f40c351b4ef017b18afd148e664f55310aade700", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -269,11 +269,13 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             item_enum(vec::map(variants, fld.fold_variant),\n                       fold_ty_params(typms, fld))\n           }\n-          item_class(typms, items, ctor) {\n+          item_class(typms, ifaces, items, ctor) {\n               let ctor_body = fld.fold_block(ctor.node.body);\n               let ctor_decl = fold_fn_decl(ctor.node.dec, fld);\n               let ctor_id   = fld.new_id(ctor.node.id);\n-              item_class(typms,\n+              item_class(typms, vec::map(ifaces, {|p|\n+                              {path: fld.fold_path(p.path),\n+                               id: fld.new_id(p.id)}}),\n                          vec::map(items, fld.fold_class_item),\n                          {node: {body: ctor_body,\n                                  dec: ctor_decl,"}, {"sha": "17a2c4e217fbac4a1d04802bfebfded42921a3c5", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -2143,11 +2143,19 @@ fn ident_to_path_tys(p: parser, i: ast::ident,\n     @spanned(s.lo, s.hi, p_)\n }\n \n+fn parse_iface_ref_list(p:parser) -> [ast::iface_ref] {\n+    parse_seq_to_before_end(token::LBRACE, seq_sep(token::COMMA),\n+                   {|p| {path: parse_path(p), id: p.get_id()}}, p)\n+}\n+\n fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let class_name = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n     let class_path = ident_to_path_tys(p, class_name, ty_params);\n+    let ifaces : [ast::iface_ref] = if eat_word(p, \"implements\")\n+                                       { parse_iface_ref_list(p) }\n+                                    else { [] };\n     expect(p, token::LBRACE);\n     let mut ms: [@ast::class_member] = [];\n     let ctor_id = p.get_id();\n@@ -2163,9 +2171,8 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     p.bump();\n     alt the_ctor {\n       some((ct_d, ct_b, ct_s)) {\n-          ret mk_item(p, lo, p.last_span.hi,\n-                                             class_name,\n-         ast::item_class(ty_params, ms,\n+          ret mk_item(p, lo, p.last_span.hi, class_name,\n+                      ast::item_class(ty_params, ifaces, ms,\n                          {node: {id: ctor_id,\n                                  self_id: p.get_id(),\n                                  dec: ct_d,"}, {"sha": "d45ae9e0056ca5767af2978ce21b21bd9c71ced6", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -493,10 +493,13 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_class(tps,items,ctor) {\n+      ast::item_class(tps,ifaces,items,ctor) {\n           head(s, \"class\");\n           word_nbsp(s, item.ident);\n           print_type_params(s, tps);\n+          word_space(s, \"implements\");\n+          commasep(s, inconsistent, ifaces, {|s, p|\n+                      print_path(s, p.path, false)});\n           bopen(s);\n           hardbreak_if_not_bol(s);\n           maybe_print_comment(s, ctor.span.lo);"}, {"sha": "20d85e08989a5c58d1332d01fad21ec6817ca89d", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -137,11 +137,12 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             visit_method_helper(m, e, v)\n         }\n       }\n-      item_class(tps, members, ctor) {\n+      item_class(tps, ifaces, members, ctor) {\n           v.visit_ty_params(tps, e, v);\n           for members.each {|m|\n              v.visit_class_item(m, e, v);\n           }\n+          for ifaces.each {|p| visit_path(p.path, e, v); }\n           visit_class_ctor_helper(ctor, i.ident, tps,\n                                   ast_util::local_def(i.id), e, v);\n       }"}, {"sha": "b46bc091aaa32db61cbbb23396cb74d86b01f4ff", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -151,7 +151,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml_w.end_tag();\n           }\n-          item_class(tps,items,ctor) {\n+          item_class(_, _, items, ctor) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n@@ -556,7 +556,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps,items,ctor) {\n+      item_class(tps, _ifaces, items,ctor) {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -573,7 +573,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-\n+        /* FIXME: encode ifaces */\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_iface_method\n         needs to know*/\n@@ -729,7 +729,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n                 alt i.node {\n-                  item_class(tps,_,ctor) {\n+                  item_class(tps,_,_,ctor) {\n                    /* this is assuming that ctors aren't inlined...\n                       probably shouldn't assume that */\n                    #debug(\"encoding info for ctor %s %d\", i.ident,"}, {"sha": "5c217fb6e96fff83c3bb723a404b81500910d100", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -203,7 +203,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n         }\n       }\n-      item_class(_, items, ctor) {\n+      item_class(_, _, items, ctor) {\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);\n           for items.each {|ci|"}, {"sha": "45d0beeab81fbf685bafa0bd8d4f5dc0a7c9aaa9", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -216,7 +216,7 @@ fn visit_expr(ex: @expr, &&cx: @ctx, v: visit::vt<@ctx>) {\n \n fn visit_item(item: @item, &&cx: @ctx, v: visit::vt<@ctx>) {\n     alt item.node {\n-      item_class(tps, items, ctor) {\n+      item_class(tps, _, items, ctor) {\n          v.visit_ty_params(tps, cx, v);\n          vec::map::<@class_member, ()>(items,\n              {|i| v.visit_class_item(i, cx, v); });"}, {"sha": "cea516c3cf40b4ddc8c4e6f7bcf1962b22fe7adc", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -530,7 +530,7 @@ fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n             {parent: pa_fn_item(item.id),\n              scope: cx.scope.binding_subscope(item.id)}\n           }\n-          ast::item_impl(_, _, _, _) | ast::item_class(_, _, _) {\n+          ast::item_impl(_, _, _, _) | ast::item_class(_, _, _, _) {\n             {parent: pa_item(item.id),\n              scope: cx.scope.self_subscope(item.id)}\n           }"}, {"sha": "897a562a4d3686a9049a1420dca0f96d018029d4", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -391,7 +391,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     e.used_imports.track = true;\n     let v =\n         @{visit_native_item: visit_native_item_with_scope,\n-          visit_item: bind visit_item_with_scope(e, _, _, _),\n+          visit_item: bind walk_item(e, _, _, _),\n           visit_block: visit_block_with_scope,\n           visit_decl: visit_decl_with_scope,\n           visit_arm: visit_arm_with_scope,\n@@ -407,6 +407,24 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     e.used_imports.track = false;\n     e.sess.abort_if_errors();\n \n+    fn walk_item(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n+        visit_item_with_scope(e, i, sc, v);\n+        /*\n+          Resolve the ifaces that a class implements; do nothing for\n+          non-class items\n+         */\n+        alt i.node {\n+           ast::item_class(_, ifaces, _, _) {\n+             /* visit the iface paths... */\n+             for ifaces.each {|p|\n+               maybe_insert(e, p.id,\n+                 lookup_path_strict(*e, sc, p.path.span, p.path.node,\n+                                    ns_type))};\n+           }\n+           _ {}\n+        }\n+    }\n+\n     fn walk_expr(e: @env, exp: @ast::expr, sc: scopes, v: vt<scopes>) {\n         visit::visit_expr(exp, sc, v);\n         alt exp.node {\n@@ -517,7 +535,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n             v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n-      ast::item_class(tps, members, ctor) {\n+      ast::item_class(tps, ifaces, members, ctor) {\n         visit::visit_ty_params(tps, sc, v);\n         // Can maybe skip this now that we require self on class fields\n         let class_scope = cons(scope_item(i), @sc);\n@@ -993,7 +1011,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n               ast::item_native_mod(m) {\n                 ret lookup_in_local_native_mod(e, it.id, sp, name, ns);\n               }\n-              ast::item_class(tps, members, ctor) {\n+              ast::item_class(tps, _, members, ctor) {\n                   if ns == ns_type {\n                     ret lookup_in_ty_params(e, name, tps);\n                   }\n@@ -1278,7 +1296,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n           _ { }\n         }\n       }\n-      ast::item_class(_, _, _) {\n+      ast::item_class(_, _, _, _) {\n           if ns == ns_type {\n             ret some(ast::def_class(local_def(i.id)));\n           }\n@@ -1407,7 +1425,11 @@ fn list_search<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option<U>)\n \n fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n                        ns: namespace, dr: dir) -> option<def> {\n-    let info = e.mod_map.get(node_id);\n+    let info = alt e.mod_map.find(node_id) {\n+            some(x) { x }\n+            none { e.sess.span_bug(sp, #fmt(\"lookup_in_local_mod: \\\n+                     module %d not in mod_map\", node_id)); }\n+    };\n     if dr == outside && !is_exported(e, id, info) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n         ret none; // name is not visible\n@@ -1582,7 +1604,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n                 variant_idx += 1u;\n             }\n           }\n-          ast::item_class(tps, items, ctor) {\n+          ast::item_class(tps, _, items, ctor) {\n               // add the class name itself\n               add_to_index(index, it.ident, mie_item(it));\n               // add the constructor decl"}, {"sha": "92fad70a642f6605e0b63ead2164caf17b0f1254", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -4432,9 +4432,11 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         };\n         native::trans_native_mod(ccx, native_mod, abi);\n       }\n-      ast::item_class(tps, items, ctor) {\n+      ast::item_class(tps, _ifaces, items, ctor) {\n         if tps.len() == 0u {\n           let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n+                         // FIXME: vtables have to get filled in depending\n+                         // on ifaces\n                          vtables: none,\n                          bounds: @[]};\n           trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,"}, {"sha": "863549f458e39d7096f8cc03cdf4c1f2e9707dca", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -102,7 +102,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_class(tps, items, ctor) {\n+      item_class(tps, _ifaces, items, ctor) {\n         cx.rmap.insert(ctor.node.id, ());\n         for vec::each(items) {|item|\n             alt item.node {"}, {"sha": "16578d8b1f307f44a40c2035f7ad3a88e70bb537", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -57,8 +57,8 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n              ccx: ccx};\n         find_pre_post_fn(fcx, body);\n       }\n-      item_class(_,_,_) {\n-          fail \"find_pre_post_item: implement item_class\";\n+      item_class(_,_,_,_) {\n+          fail \"find_pre_post_item: shouldn't be called on item_class\";\n       }\n       item_impl(_, _, _, ms) {\n         for ms.each {|m| find_pre_post_method(ccx, m); }"}, {"sha": "068f23826914b16abef75925cf4a322bc9fbb062", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -2261,7 +2261,7 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) {\n          alt i.node {\n-           ast::item_class(_, items, _) {\n+           ast::item_class(_, _, items, _) {\n                class_field_tys(items)\n            }\n            _ { cx.sess.bug(\"class ID bound to non-class\"); }\n@@ -2303,7 +2303,7 @@ pure fn is_public(f: field_ty) -> bool {\n fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n     : is_local(did) -> [{name: ident, id: node_id, privacy: privacy}] {\n     alt cx.items.find(did.node) {\n-       some(ast_map::node_item(@{node: item_class(_,items,_), _}, _)) {\n+       some(ast_map::node_item(@{node: item_class(_,_,items,_), _}, _)) {\n          let (_,ms) = split_class_items(items);\n          vec::map(ms, {|m| {name: m.ident, id: m.id,\n                          privacy: m.privacy}})"}, {"sha": "b3a07cb211410c056daef64ef417abc56236bc90", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 100, "deletions": 57, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -128,16 +128,23 @@ fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ty_vid {\n     }\n }\n \n-fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n-    alt fcx.ccx.tcx.def_map.find(id) {\n+fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n+    alt tcx.def_map.find(id) {\n       some(x) { x }\n       _ {\n-        fcx.ccx.tcx.sess.span_fatal(sp,\n-                                    \"internal error looking up a definition\")\n+        tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n       }\n     }\n }\n \n+fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id) -> ast::def {\n+    lookup_def_tcx(ccx.tcx, sp, id)\n+}\n+\n+fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n+    lookup_def_ccx(fcx.ccx, sp, id)\n+}\n+\n // Returns the type parameter count and the type for the given definition.\n fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n    ty_param_bounds_and_ty {\n@@ -567,7 +574,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_class(tps,_,_) {\n+      ast::item_class(tps,_,_,_) {\n           let {bounds,params} = mk_ty_params(tcx, tps);\n           let t = ty::mk_class(tcx, local_def(it.id), params);\n           let tpt = {bounds: bounds, ty: t};\n@@ -1020,6 +1027,7 @@ fn instantiate_bound_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n     }\n }\n \n+\n // Item collection - a pair of bootstrap passes:\n //\n // (1) Collect the IDs of all type items (typedefs) and store them in a table.\n@@ -1078,7 +1086,7 @@ mod collect {\n               store_methods::<ast::ty_method>(tcx, id, ms, {|m|\n                           ty_of_ty_method(tcx, m_collect, m)});\n           }\n-          ast_map::node_item(@{node: ast::item_class(_,its,_), _}, _) {\n+          ast_map::node_item(@{node: ast::item_class(_,_,its,_), _}, _) {\n               let (_,ms) = split_class_items(its);\n               // All methods need to be stored, since lookup_method\n               // relies on the same method cache for self-calls\n@@ -1087,6 +1095,57 @@ mod collect {\n           }\n         }\n     }\n+    fn check_methods_against_iface(tcx: ty::ctxt, tps: [ast::ty_param],\n+                          selfty: ty::t, t: @ast::ty, ms: [@ast::method]) {\n+      let i_bounds = ty_param_bounds(tcx, m_collect, tps);\n+      let my_methods = convert_methods(tcx, ms, i_bounds, some(selfty));\n+      let iface_ty = ast_ty_to_ty(tcx, m_collect, t);\n+      alt ty::get(iface_ty).struct {\n+        ty::ty_iface(did, tys) {\n+         // Store the iface type in the type node\n+         alt check t.node {\n+           ast::ty_path(_, t_id) {\n+             write_ty_to_tcx(tcx, t_id, iface_ty);\n+           }\n+         }\n+         if did.crate == ast::local_crate {\n+             ensure_iface_methods(tcx, did.node);\n+         }\n+         for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n+            alt vec::find(my_methods,\n+                          {|m| if_m.ident == m.mty.ident}) {\n+              some({mty: m, id, span}) {\n+               if m.purity != if_m.purity {\n+                  tcx.sess.span_err(\n+                     span, \"method `\" + m.ident + \"`'s purity \\\n+                       not match the iface method's \\\n+                       purity\");\n+               }\n+               let mt = compare_impl_method(\n+                         tcx, span, m, vec::len(tps), if_m, tys,\n+                         selfty);\n+               let old = tcx.tcache.get(local_def(id));\n+               if old.ty != mt {\n+                  tcx.tcache.insert(local_def(id),\n+                                    {bounds: old.bounds,\n+                                     ty: mt});\n+                  write_ty_to_tcx(tcx, id, mt);\n+               }\n+              }\n+              none {\n+                   tcx.sess.span_err(t.span, \"missing method `\" +\n+                      if_m.ident + \"`\");\n+              }\n+            } // alt\n+          } // |if_m|\n+        } // for\n+        _ {\n+            tcx.sess.span_fatal(t.span, \"can only implement \\\n+                                         interface types\");\n+        }\n+     }\n+    }\n+\n     fn convert_class_item(tcx: ty::ctxt, v: ast_util::ivar) {\n         /* we want to do something here, b/c within the\n          scope of the class, it's ok to refer to fields &\n@@ -1141,56 +1200,15 @@ mod collect {\n             write_ty_to_tcx(tcx, it.id, selfty);\n             tcx.tcache.insert(local_def(it.id), {bounds: i_bounds,\n                                                  ty: selfty});\n-            let my_methods = convert_methods(tcx, ms, i_bounds, some(selfty));\n             alt ifce {\n               some(t) {\n-                let iface_ty = ast_ty_to_ty(tcx, m_collect, t);\n-                alt ty::get(iface_ty).struct {\n-                  ty::ty_iface(did, tys) {\n-                    // Store the iface type in the type node\n-                    alt check t.node {\n-                      ast::ty_path(_, t_id) {\n-                        write_ty_to_tcx(tcx, t_id, iface_ty);\n-                      }\n-                    }\n-                    if did.crate == ast::local_crate {\n-                        ensure_iface_methods(tcx, did.node);\n-                    }\n-                    for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n-                        alt vec::find(my_methods,\n-                                      {|m| if_m.ident == m.mty.ident}) {\n-                          some({mty: m, id, span}) {\n-                            if m.purity != if_m.purity {\n-                                tcx.sess.span_err(\n-                                    span, \"method `\" + m.ident + \"`'s purity \\\n-                                           not match the iface method's \\\n-                                           purity\");\n-                            }\n-                            let mt = compare_impl_method(\n-                                tcx, span, m, vec::len(tps), if_m, tys,\n-                                selfty);\n-                            let old = tcx.tcache.get(local_def(id));\n-                            if old.ty != mt {\n-                                tcx.tcache.insert(local_def(id),\n-                                                     {bounds: old.bounds,\n-                                                     ty: mt});\n-                                write_ty_to_tcx(tcx, id, mt);\n-                            }\n-                          }\n-                          none {\n-                            tcx.sess.span_err(t.span, \"missing method `\" +\n-                                                 if_m.ident + \"`\");\n-                          }\n-                        }\n-                    }\n-                  }\n-                  _ {\n-                    tcx.sess.span_fatal(t.span, \"can only implement \\\n-                                                    interface types\");\n-                  }\n-                }\n+                  check_methods_against_iface(tcx, tps, selfty,\n+                                                    t, ms); }\n+              _ {\n+                  // Still have to do this to write method types\n+                  // into the table\n+                convert_methods(tcx, ms, i_bounds, some(selfty));\n               }\n-              _ {}\n             }\n           }\n           ast::item_res(decl, tps, _, dtor_id, ctor_id) {\n@@ -1221,7 +1239,7 @@ mod collect {\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n             ensure_iface_methods(tcx, it.id);\n           }\n-          ast::item_class(tps, members, ctor) {\n+          ast::item_class(tps, ifaces, members, ctor) {\n               // Write the class type\n               let tpt = ty_of_item(tcx, m_collect, it);\n               write_ty_to_tcx(tcx, it.id, tpt.ty);\n@@ -1245,6 +1263,31 @@ mod collect {\n               // Need to convert all methods so we can check internal\n               // references to private methods\n               convert_methods(tcx, methods, @[], some(selfty));\n+              /*\n+                Finally, check that the class really implements the ifaces\n+                that it claims to implement.\n+               */\n+              for ifaces.each {|ifce|\n+                alt lookup_def_tcx(tcx, it.span, ifce.id) {\n+                   ast::def_ty(t_id) {\n+                     let t = ty::lookup_item_type(tcx, t_id).ty;\n+                     alt ty::get(t).struct {\n+                        ty::ty_iface(_,_) {\n+                            write_ty_to_tcx(tcx, ifce.id, t);\n+                            check_methods_against_iface(tcx, tps, selfty,\n+                               @{id: ifce.id,\n+                                 node: ast::ty_path(ifce.path, ifce.id),\n+                                 span: ifce.path.span},\n+                               methods);\n+                        }\n+                        _ { tcx.sess.span_fatal(ifce.path.span,\n+                           \"can only implement interface types\"); }\n+                     }\n+                   }\n+                   _ { tcx.sess.span_err(ifce.path.span, \"not an interface \\\n+                           type\"); }\n+                };\n+              }\n           }\n           _ {\n             // This call populates the type cache with the converted type\n@@ -3978,9 +4021,9 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let self_ty = replace_self_region(ccx.tcx, self_region, self_ty);\n         for ms.each {|m| check_method(ccx, m, self_ty);}\n       }\n-      ast::item_class(tps, members, ctor) {\n-          let cid = some(it.id);\n-          let class_t = ty::node_id_to_type(ccx.tcx, it.id);\n+      ast::item_class(tps, ifaces, members, ctor) {\n+          let cid = some(it.id), tcx = ccx.tcx;\n+          let class_t = ty::node_id_to_type(tcx, it.id);\n           let members_info = class_types(ccx, members);\n           // can also ditch the enclosing_class stuff once we move to self\n           // FIXME"}, {"sha": "ff7d9fbe32788d5843f5a447281606e0f39a0901", "filename": "src/test/compile-fail/class-implements-bad-iface.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -0,0 +1,9 @@\n+// error-pattern:unresolved typename: nonexistent\n+class cat implements nonexistent {\n+  let meows: uint;\n+  new(in_x : uint) { self.meows = in_x; }\n+}\n+\n+fn main() {\n+  let nyan = cat(0u);\n+}\n\\ No newline at end of file"}, {"sha": "b4111ef93b305c8378ed862b9d5b6069b73fcf70", "filename": "src/test/compile-fail/class-implements-int.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -0,0 +1,9 @@\n+// error-pattern:not an interface type\n+class cat implements int {\n+  let meows: uint;\n+  new(in_x : uint) { self.meows = in_x; }\n+}\n+\n+fn main() {\n+  let nyan = cat(0u);\n+}\n\\ No newline at end of file"}, {"sha": "6e6092fceab2bd7e0654a1e8587453f075db905e", "filename": "src/test/compile-fail/class-method-missing.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern:missing method `eat`\n+iface animal {\n+  fn eat();\n+}\n+\n+class cat implements animal {\n+  let meows: uint;\n+  new(in_x : uint) { self.meows = in_x; }\n+}\n+\n+fn main() {\n+  let nyan = cat(0u);\n+}\n\\ No newline at end of file"}, {"sha": "6e09d045820bda41cb5120f2ddb56bbb0b0c8c53", "filename": "src/test/run-pass/class-implement-ifaces.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs?ref=5c12cd72f4774af8ca1c3c9c0115b4b1a72404bb", "patch": "@@ -0,0 +1,44 @@\n+iface noisy {\n+  fn speak();\n+}\n+\n+class cat implements noisy {\n+  priv {\n+    let mut meows : uint;\n+    fn meow() {\n+      #error(\"Meow\");\n+      self.meows += 1u;\n+      if self.meows % 5u == 0u {\n+          self.how_hungry += 1;\n+      }\n+    }\n+  }\n+\n+  let mutable how_hungry : int;\n+  let name : str;\n+\n+  new(in_x : uint, in_y : int, in_name: str)\n+    { self.meows = in_x; self.how_hungry = in_y; self.name = in_name; }\n+\n+  fn speak() { self.meow(); }\n+\n+  fn eat() -> bool {\n+    if self.how_hungry > 0 {\n+        #error(\"OM NOM NOM\");\n+        self.how_hungry -= 2;\n+        ret true;\n+    }\n+    else {\n+        #error(\"Not hungry!\");\n+        ret false;\n+    }\n+  }\n+}\n+\n+fn main() {\n+  let nyan = cat(0u, 2, \"nyan\");\n+  nyan.eat();\n+  assert(!nyan.eat());\n+  uint::range(1u, 10u, {|_i| nyan.speak(); });\n+  assert(nyan.eat());\n+}\n\\ No newline at end of file"}]}