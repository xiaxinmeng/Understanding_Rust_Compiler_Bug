{"sha": "3ddfb725127a49e03593c0c56542f12826713bd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZGZiNzI1MTI3YTQ5ZTAzNTkzYzBjNTY1NDJmMTI4MjY3MTNiZDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T01:51:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T01:51:42Z"}, "message": "auto merge of #8562 : bblum/rust/superkinds, r=nikomatsakis\n\nFor #7083.\r\n\r\nThe metadata issue with the old version is now fixed. Ready for review.\r\n\r\nThis is also not the full solution to #7083, because this is not supported yet:\r\n```\r\ntrait Foo : Send { }\r\n\r\nimpl <T: Send> Foo for T { }\r\n\r\nfn foo<T: Foo>(val: T, chan: std::comm::Chan<T>) {\r\n    chan.send(val);\r\n}\r\n```\r\n\r\ncc @nikomatsakis", "tree": {"sha": "0f9d94dcd21fcf4036379b418b224ac5255648a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f9d94dcd21fcf4036379b418b224ac5255648a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ddfb725127a49e03593c0c56542f12826713bd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ddfb725127a49e03593c0c56542f12826713bd6", "html_url": "https://github.com/rust-lang/rust/commit/3ddfb725127a49e03593c0c56542f12826713bd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ddfb725127a49e03593c0c56542f12826713bd6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fca75199c7b2186e64fcab51a9e498695ce4a7b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/fca75199c7b2186e64fcab51a9e498695ce4a7b8", "html_url": "https://github.com/rust-lang/rust/commit/fca75199c7b2186e64fcab51a9e498695ce4a7b8"}, {"sha": "b795fab046ca1b218785bee5ec5af7326ef9fc85", "url": "https://api.github.com/repos/rust-lang/rust/commits/b795fab046ca1b218785bee5ec5af7326ef9fc85", "html_url": "https://github.com/rust-lang/rust/commit/b795fab046ca1b218785bee5ec5af7326ef9fc85"}], "stats": {"total": 615, "additions": 519, "deletions": 96}, "files": [{"sha": "9eb09806bc07dc0ea6e12bae27951225772564a3", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -375,9 +375,21 @@ pub fn get_trait_def(cdata: cmd,\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n                                      tag_items_data_item_ty_param_bounds);\n     let rp = item_ty_region_param(item_doc);\n+    let mut bounds = ty::EmptyBuiltinBounds();\n+    // Collect the builtin bounds from the encoded supertraits.\n+    // FIXME(#8559): They should be encoded directly.\n+    do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+        // NB. Bypasses real supertraits. See get_supertraits() if you wanted them.\n+        let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n+        do tcx.lang_items.to_builtin_kind(trait_ref.def_id).map_move |bound| {\n+            bounds.add(bound);\n+        };\n+        true\n+    };\n     ty::TraitDef {\n         generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param: rp},\n+        bounds: bounds,\n         trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n     }\n }\n@@ -929,7 +941,13 @@ pub fn get_supertraits(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n     do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n-        results.push(@doc_trait_ref(trait_doc, tcx, cdata));\n+        // NB. Only reads the ones that *aren't* builtin-bounds. See also\n+        // get_trait_def() for collecting the builtin bounds.\n+        // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n+        let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n+        if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_none() {\n+            results.push(@trait_ref);\n+        }\n         true\n     };\n     return results;"}, {"sha": "dbed508348d03297de14364ec2e9316a6f854fda", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -1066,6 +1066,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        // FIXME(#8559): This should use the tcx's supertrait cache instead of\n+        // reading the AST's list, because the former has already filtered out\n+        // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n         for ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);"}, {"sha": "edea267d22686c70ed6d8e2388c7869c8463b9f9", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -50,8 +50,6 @@ use syntax::visit::Visitor;\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-pub static try_adding: &'static str = \"Try adding a move\";\n-\n #[deriving(Clone)]\n pub struct Context {\n     tcx: ty::ctxt,\n@@ -77,9 +75,6 @@ impl Visitor<Context> for KindAnalysisVisitor {\n     fn visit_item(&mut self, i:@item, e:Context) {\n         check_item(self, i, e);\n     }\n-    fn visit_block(&mut self, b:&Block, e:Context) {\n-        check_block(self, b, e);\n-    }\n }\n \n pub fn check_crate(tcx: ty::ctxt,\n@@ -125,46 +120,47 @@ fn check_struct_safe_for_destructor(cx: Context,\n     }\n }\n \n-fn check_block(visitor: &mut KindAnalysisVisitor,\n-               block: &Block,\n-               cx: Context) {\n-    visit::walk_block(visitor, block, cx);\n+fn check_impl_of_trait(cx: Context, it: @item, trait_ref: &trait_ref, self_type: &Ty) {\n+    let ast_trait_def = cx.tcx.def_map.find(&trait_ref.ref_id)\n+                            .expect(\"trait ref not in def map!\");\n+    let trait_def_id = ast_util::def_id_of_def(*ast_trait_def);\n+    let trait_def = cx.tcx.trait_defs.find(&trait_def_id)\n+                        .expect(\"trait def not in trait-defs map!\");\n+\n+    // If this trait has builtin-kind supertraits, meet them.\n+    let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n+    error!(\"checking impl with self type %?\", ty::get(self_ty).sty);\n+    do check_builtin_bounds(cx, self_ty, trait_def.bounds) |missing| {\n+        cx.tcx.sess.span_err(self_type.span,\n+            fmt!(\"the type `%s', which does not fulfill `%s`, cannot implement this \\\n+                  trait\", ty_to_str(cx.tcx, self_ty), missing.user_string(cx.tcx)));\n+        cx.tcx.sess.span_note(self_type.span,\n+            fmt!(\"types implementing this trait must fulfill `%s`\",\n+                 trait_def.bounds.user_string(cx.tcx)));\n+    }\n+\n+    // If this is a destructor, check kinds.\n+    if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n+        match self_type.node {\n+            ty_path(_, ref bounds, path_node_id) => {\n+                assert!(bounds.is_none());\n+                let struct_def = cx.tcx.def_map.get_copy(&path_node_id);\n+                let struct_did = ast_util::def_id_of_def(struct_def);\n+                check_struct_safe_for_destructor(cx, self_type.span, struct_did);\n+            }\n+            _ => {\n+                cx.tcx.sess.span_bug(self_type.span,\n+                    \"the self type for the Drop trait impl is not a path\");\n+            }\n+        }\n+    }\n }\n \n fn check_item(visitor: &mut KindAnalysisVisitor, item: @item, cx: Context) {\n-    // If this is a destructor, check kinds.\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n-                match cx.tcx.def_map.find(&trait_ref.ref_id) {\n-                    None => cx.tcx.sess.bug(\"trait ref not in def map!\"),\n-                    Some(&trait_def) => {\n-                        let trait_def_id = ast_util::def_id_of_def(trait_def);\n-                        if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n-                            // Yes, it's a destructor.\n-                            match self_type.node {\n-                                ty_path(_, ref bounds, path_node_id) => {\n-                                    assert!(bounds.is_none());\n-                                    let struct_def = cx.tcx.def_map.get_copy(\n-                                        &path_node_id);\n-                                    let struct_did =\n-                                        ast_util::def_id_of_def(struct_def);\n-                                    check_struct_safe_for_destructor(\n-                                        cx,\n-                                        self_type.span,\n-                                        struct_did);\n-                                }\n-                                _ => {\n-                                    cx.tcx.sess.span_bug(self_type.span,\n-                                                         \"the self type for \\\n-                                                          the Drop trait \\\n-                                                          impl is not a \\\n-                                                          path\");\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+                check_impl_of_trait(cx, item, trait_ref, self_type);\n             }\n             _ => {}\n         }"}, {"sha": "47e2937ca8a8a048210cf459e65c5a703ba99d4c", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -23,6 +23,7 @@\n use driver::session::Session;\n use metadata::csearch::each_lang_item;\n use metadata::cstore::iter_crate_data;\n+use middle::ty::{BuiltinBound, BoundFreeze, BoundSend, BoundSized};\n use syntax::ast::{Crate, def_id, MetaItem};\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n@@ -158,6 +159,18 @@ impl LanguageItems {\n         }\n     }\n \n+    pub fn to_builtin_kind(&self, id: def_id) -> Option<BuiltinBound> {\n+        if Some(id) == self.freeze_trait() {\n+            Some(BoundFreeze)\n+        } else if Some(id) == self.send_trait() {\n+            Some(BoundSend)\n+        } else if Some(id) == self.sized_trait() {\n+            Some(BoundSized)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn freeze_trait(&self) -> Option<def_id> {\n         self.items[FreezeTraitLangItem as uint]\n     }"}, {"sha": "39ffffa25c7b581fc07a6174fefd5ada018c4e4b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -863,6 +863,7 @@ pub struct ty_param_bounds_and_ty {\n /// As `ty_param_bounds_and_ty` but for a trait ref.\n pub struct TraitDef {\n     generics: Generics,\n+    bounds: BuiltinBounds,\n     trait_ref: @ty::TraitRef,\n }\n \n@@ -2160,17 +2161,19 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // def-id.\n                 assert_eq!(p.def_id.crate, ast::LOCAL_CRATE);\n \n-                type_param_def_to_contents(\n-                    cx, cx.ty_param_defs.get(&p.def_id.node))\n+                let tp_def = cx.ty_param_defs.get(&p.def_id.node);\n+                kind_bounds_to_contents(cx, &tp_def.bounds.builtin_bounds,\n+                                        tp_def.bounds.trait_bounds)\n             }\n \n-            ty_self(_) => {\n-                // Currently, self is not bounded, so we must assume the\n-                // worst.  But in the future we should examine the super\n-                // traits.\n-                //\n+            ty_self(def_id) => {\n                 // FIXME(#4678)---self should just be a ty param\n-                TC_ALL\n+\n+                // Self may be bounded if the associated trait has builtin kinds\n+                // for supertraits. If so we can use those bounds.\n+                let trait_def = lookup_trait_def(cx, def_id);\n+                let traits = [trait_def.trait_ref];\n+                kind_bounds_to_contents(cx, &trait_def.bounds, traits)\n             }\n \n             ty_infer(_) => {\n@@ -2314,14 +2317,12 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         st + mt + bt\n     }\n \n-    fn type_param_def_to_contents(cx: ctxt,\n-                                  type_param_def: &TypeParameterDef) -> TypeContents\n-    {\n-        debug!(\"type_param_def_to_contents(%s)\", type_param_def.repr(cx));\n+    fn kind_bounds_to_contents(cx: ctxt, bounds: &BuiltinBounds, traits: &[@TraitRef])\n+            -> TypeContents {\n         let _i = indenter();\n \n         let mut tc = TC_ALL;\n-        for bound in type_param_def.bounds.builtin_bounds.iter() {\n+        do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n             debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n             tc = tc - match bound {\n                 BoundStatic => TypeContents::nonstatic(cx),\n@@ -2334,6 +2335,23 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         debug!(\"result = %s\", tc.to_str());\n         return tc;\n+\n+        // Iterates over all builtin bounds on the type parameter def, including\n+        // those inherited from traits with builtin-kind-supertraits.\n+        fn each_inherited_builtin_bound(cx: ctxt, bounds: &BuiltinBounds,\n+                                        traits: &[@TraitRef], f: &fn(BuiltinBound)) {\n+            for bound in bounds.iter() {\n+                f(bound);\n+            }\n+\n+            do each_bound_trait_and_supertraits(cx, traits) |trait_ref| {\n+                let trait_def = lookup_trait_def(cx, trait_ref.def_id);\n+                for bound in trait_def.bounds.iter() {\n+                    f(bound);\n+                }\n+                true\n+            };\n+        }\n     }\n }\n \n@@ -3727,6 +3745,25 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n     return ret;\n }\n \n+pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::trait_ref) -> ast::def_id {\n+    let def = tcx.def_map.find(&tr.ref_id).expect(\"no def-map entry for trait\");\n+    ast_util::def_id_of_def(*def)\n+}\n+\n+pub fn try_add_builtin_trait(tcx: ctxt,\n+                             trait_def_id: ast::def_id,\n+                             builtin_bounds: &mut BuiltinBounds) -> bool {\n+    //! Checks whether `trait_ref` refers to one of the builtin\n+    //! traits, like `Send`, and adds the corresponding\n+    //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n+    //! is a builtin trait.\n+\n+    match tcx.lang_items.to_builtin_kind(trait_def_id) {\n+        Some(bound) => { builtin_bounds.add(bound); true }\n+        None => false\n+    }\n+}\n+\n pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n     match get(ty).sty {\n       ty_trait(id, _, _, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),"}, {"sha": "db76d75a5a58303d61e96744f360256929f55834", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -773,9 +773,8 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n                     ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                             ast::def_trait(trait_did) => {\n-                                if try_add_builtin_trait(tcx,\n-                                                         trait_did,\n-                                                         &mut builtin_bounds) {\n+                                if ty::try_add_builtin_trait(tcx, trait_did,\n+                                                             &mut builtin_bounds) {\n                                     loop; // success\n                                 }\n                             }\n@@ -807,26 +806,3 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n         (&None, ty::RegionTraitStore(*)) => ty::EmptyBuiltinBounds(),\n     }\n }\n-\n-pub fn try_add_builtin_trait(tcx: ty::ctxt,\n-                             trait_def_id: ast::def_id,\n-                             builtin_bounds: &mut ty::BuiltinBounds) -> bool {\n-    //! Checks whether `trait_ref` refers to one of the builtin\n-    //! traits, like `Send`, and adds the corresponding\n-    //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n-    //! is a builtin trait.\n-\n-    let li = &tcx.lang_items;\n-    if Some(trait_def_id) == li.send_trait() {\n-        builtin_bounds.add(ty::BoundSend);\n-        true\n-    } else if Some(trait_def_id) == li.freeze_trait() {\n-        builtin_bounds.add(ty::BoundFreeze);\n-        true\n-    } else if Some(trait_def_id) == li.sized_trait() {\n-        builtin_bounds.add(ty::BoundSized);\n-        true\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "a22879654e810b9d6b7b83d87ea83d41b36539b2", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -398,28 +398,39 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n                           ast_trait_refs: &[ast::trait_ref],\n-                          generics: &ast::Generics)\n+                          generics: &ast::Generics) -> ty::BuiltinBounds\n {\n     let tcx = ccx.tcx;\n-    if tcx.supertraits.contains_key(&local_def(id)) { return; }\n+\n+    // Called only the first time trait_def_of_item is called.\n+    // Supertraits are ensured at the same time.\n+    assert!(!tcx.supertraits.contains_key(&local_def(id)));\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n+    let mut bounds = ty::EmptyBuiltinBounds();\n     for ast_trait_ref in ast_trait_refs.iter() {\n+        let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n+        // FIXME(#8559): Need to instantiate the trait_ref whether or not it's a\n+        // builtin trait, so that the trait's node id appears in the tcx trait_ref\n+        // map. This is only needed for metadata; see the similar fixme in encoder.rs.\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n-\n-        // FIXME(#5527) Could have same trait multiple times\n-        if ty_trait_refs.iter().any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n-            // This means a trait inherited from the same supertrait more\n-            // than once.\n-            tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n-            break;\n-        } else {\n-            ty_trait_refs.push(trait_ref);\n+        if !ty::try_add_builtin_trait(ccx.tcx, trait_def_id, &mut bounds) {\n+\n+            // FIXME(#5527) Could have same trait multiple times\n+            if ty_trait_refs.iter().any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n+                // This means a trait inherited from the same supertrait more\n+                // than once.\n+                tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n+                break;\n+            } else {\n+                ty_trait_refs.push(trait_ref);\n+            }\n         }\n     }\n     tcx.supertraits.insert(local_def(id), @ty_trait_refs);\n+    bounds\n }\n \n /**\n@@ -869,14 +880,20 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n         for t in opt_trait_ref.iter() {\n+            // Prevent the builtin kind traits from being manually implemented.\n+            let trait_def_id = ty::trait_ref_to_def_id(tcx, t);\n+            if tcx.lang_items.to_builtin_kind(trait_def_id).is_some() {\n+                tcx.sess.span_err(it.span,\n+                    \"cannot provide an explicit implementation \\\n+                     for a builtin kind\");\n+            }\n+\n             check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n-      ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n-          let trait_def = trait_def_of_item(ccx, it);\n-          tcx.trait_defs.insert(local_def(it.id), trait_def);\n+      ast::item_trait(ref generics, _, ref trait_methods) => {\n+          let _trait_def = trait_def_of_item(ccx, it);\n           ensure_trait_methods(ccx, it.id);\n-          ensure_supertraits(ccx, it.id, it.span, rp, *supertraits, generics);\n \n           let (_, provided_methods) =\n               split_trait_methods(*trait_methods);\n@@ -1032,13 +1049,16 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n     }\n     let rp = tcx.region_paramd_items.find(&it.id).map_move(|x| *x);\n     match it.node {\n-        ast::item_trait(ref generics, _, _) => {\n+        ast::item_trait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n             let (ty_generics, substs) = mk_item_substs(ccx, generics, rp,\n                                                        Some(self_ty));\n+            let bounds = ensure_supertraits(ccx, it.id, it.span, rp,\n+                                            *supertraits, generics);\n             let trait_ref = @ty::TraitRef {def_id: def_id,\n                                            substs: substs};\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n+                                           bounds: bounds,\n                                            trait_ref: trait_ref};\n             tcx.trait_defs.insert(def_id, trait_def);\n             return trait_def;\n@@ -1218,7 +1238,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                 TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n-                    if !astconv::try_add_builtin_trait(\n+                    if !ty::try_add_builtin_trait(\n                         ccx.tcx, trait_ref.def_id,\n                         &mut param_bounds.builtin_bounds)\n                     {"}, {"sha": "dfb0c0310ecf1bf64beb0101013ec84e7d865999", "filename": "src/test/auxiliary/trait_superkinds_in_metadata.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fauxiliary%2Ftrait_superkinds_in_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fauxiliary%2Ftrait_superkinds_in_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_superkinds_in_metadata.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test library crate for cross-crate usages of traits inheriting\n+// from the builtin kinds. Mostly tests metadata correctness.\n+\n+#[crate_type=\"lib\"];\n+\n+pub trait RequiresFreeze : Freeze { }\n+pub trait RequiresRequiresFreezeAndSend : RequiresFreeze + Send { }"}, {"sha": "15fa0b6643381f60a63124111666509f461cd8f8", "filename": "src/test/compile-fail/builtin-superkinds-double-superkind.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for traits that inherit from multiple builtin kinds at once,\n+// testing that all such kinds must be present on implementing types.\n+\n+trait Foo : Send+Freeze { }\n+\n+impl <T: Freeze> Foo for (T,) { } //~ ERROR cannot implement this trait\n+\n+impl <T: Send> Foo for (T,T) { } //~ ERROR cannot implement this trait\n+\n+impl <T: Send+Freeze> Foo for (T,T,T) { } // (ok)\n+\n+fn main() { }"}, {"sha": "fe35bf471961d82fdcdcedf635560c45e81ef4b0", "filename": "src/test/compile-fail/builtin-superkinds-in-metadata.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-in-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-in-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-in-metadata.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+// aux-build:trait_superkinds_in_metadata.rs\n+\n+// Test for traits inheriting from the builtin kinds cross-crate.\n+// Mostly tests correctness of metadata.\n+\n+extern mod trait_superkinds_in_metadata;\n+use trait_superkinds_in_metadata::{RequiresRequiresFreezeAndSend, RequiresFreeze};\n+\n+struct X<T>(T);\n+\n+impl <T:Freeze> RequiresFreeze for X<T> { }\n+\n+impl <T:Freeze> RequiresRequiresFreezeAndSend for X<T> { } //~ ERROR cannot implement this trait\n+\n+fn main() { }"}, {"sha": "d7ee3aae4d52cdfd0979dee01a259355228f5d5a", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests (negatively) the ability for the Self type in default methods\n+// to use capabilities granted by builtin kinds as supertraits.\n+\n+use std::comm;\n+\n+trait Foo : Freeze {\n+    fn foo(self, chan: comm::Chan<Self>) {\n+        chan.send(self); //~ ERROR does not fulfill `Send`\n+    }\n+}\n+\n+impl <T: Freeze> Foo for T { }\n+\n+fn main() {\n+    let (p,c) = comm::stream();\n+    1193182.foo(c);\n+    assert!(p.recv() == 1193182);\n+}"}, {"sha": "c1011f1368a656769e8ec43ddb0c85c3ec5f34b1", "filename": "src/test/compile-fail/builtin-superkinds-simple.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for traits inheriting from the builtin kinds, checking\n+// the type contents of the implementing type (that's not a typaram).\n+\n+trait Foo : Send { }\n+\n+impl <'self> Foo for &'self mut () { } //~ ERROR cannot implement this trait\n+\n+trait Bar : Freeze { }\n+\n+impl <'self> Bar for &'self mut () { } //~ ERROR cannot implement this trait\n+\n+fn main() { }"}, {"sha": "2a3d3c7df6132ff8d95678216ba16c62ba2f6911", "filename": "src/test/compile-fail/builtin-superkinds-typaram-not-send.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for traits inheriting from the builtin kinds.\n+\n+trait Foo : Send { }\n+\n+impl <T: Freeze> Foo for T { } //~ ERROR cannot implement this trait\n+\n+fn main() { }"}, {"sha": "c35ca098372d351f6e013043fb38070acaff3315", "filename": "src/test/compile-fail/cant-implement-builtin-kinds.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fcant-implement-builtin-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Fcompile-fail%2Fcant-implement-builtin-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcant-implement-builtin-kinds.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See issue #8517 for why this should be illegal.\n+\n+struct X<T>(T);\n+\n+impl <T> Send for X<T> { } //~ ERROR cannot provide an explicit implementation for a builtin kind\n+impl <T> Sized for X<T> { } //~ ERROR cannot provide an explicit implementation for a builtin kind\n+impl <T> Freeze for X<T> { } //~ ERROR cannot provide an explicit implementation for a builtin kind\n+\n+fn main() { }"}, {"sha": "74a218ac469a30bda8e6be9e905f1b443f14f425", "filename": "src/test/run-pass/builtin-superkinds-capabilities-transitive.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests \"transitivity\" of super-builtin-kinds on traits. Here, if\n+// we have a Foo, we know we have a Bar, and if we have a Bar, we\n+// know we have a Send. So if we have a Foo we should know we have\n+// a Send. Basically this just makes sure rustc is using\n+// each_bound_trait_and_supertraits in type_contents correctly.\n+\n+use std::comm;\n+\n+trait Bar : Send { }\n+trait Foo : Bar { }\n+\n+impl <T: Send> Foo for T { }\n+impl <T: Send> Bar for T { }\n+\n+fn foo<T: Foo>(val: T, chan: comm::Chan<T>) {\n+    chan.send(val);\n+}\n+\n+fn main() {\n+    let (p,c) = comm::stream();\n+    foo(31337, c);\n+    assert!(p.recv() == 31337);\n+}"}, {"sha": "ea61b91e3b92e48047881f1ceca4c72d5a0fefe9", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+// aux-build:trait_superkinds_in_metadata.rs\n+\n+// Tests \"capabilities\" granted by traits with super-builtin-kinds,\n+// even when using them cross-crate.\n+\n+extern mod trait_superkinds_in_metadata;\n+use trait_superkinds_in_metadata::{RequiresRequiresFreezeAndSend, RequiresFreeze};\n+use std::comm;\n+\n+#[deriving(Eq)]\n+struct X<T>(T);\n+\n+impl <T: Freeze> RequiresFreeze for X<T> { }\n+impl <T: Freeze+Send> RequiresRequiresFreezeAndSend for X<T> { }\n+\n+fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: comm::Chan<T>) {\n+    chan.send(val);\n+}\n+\n+fn main() {\n+    let (p,c) = comm::stream();\n+    foo(X(31337), c);\n+    assert!(p.recv() == X(31337));\n+}"}, {"sha": "c2d2129b1c182a3056092727aa561bfed9545648", "filename": "src/test/run-pass/builtin-superkinds-capabilities.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests \"capabilities\" granted by traits that inherit from super-\n+// builtin-kinds, e.g., if a trait requires Send to implement, then\n+// at usage site of that trait, we know we have the Send capability.\n+\n+use std::comm;\n+\n+trait Foo : Send { }\n+\n+impl <T: Send> Foo for T { }\n+\n+fn foo<T: Foo>(val: T, chan: comm::Chan<T>) {\n+    chan.send(val);\n+}\n+\n+fn main() {\n+    let (p,c) = comm::stream();\n+    foo(31337, c);\n+    assert!(p.recv() == 31337);\n+}"}, {"sha": "e2fc6cc335f43ba2bbcb790bcab7e7d5bc9db7af", "filename": "src/test/run-pass/builtin-superkinds-in-metadata.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-in-metadata.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+// aux-build:trait_superkinds_in_metadata.rs\n+\n+// Tests (correct) usage of trait super-builtin-kinds cross-crate.\n+\n+extern mod trait_superkinds_in_metadata;\n+use trait_superkinds_in_metadata::{RequiresRequiresFreezeAndSend, RequiresFreeze};\n+\n+struct X<T>(T);\n+\n+impl <T:Freeze> RequiresFreeze for X<T> { }\n+\n+impl <T:Freeze+Send> RequiresRequiresFreezeAndSend for X<T> { }\n+\n+fn main() { }"}, {"sha": "b6e58bfbf3d8ff10260f89fe01ef17bfa070db5f", "filename": "src/test/run-pass/builtin-superkinds-phantom-typaram.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-phantom-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-phantom-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-phantom-typaram.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that even when a type paramenter doesn't implement a required\n+// super-builtin-kind of a trait, if the type parameter is never used,\n+// the type can implement the trait anyway.\n+\n+trait Foo : Send { }\n+\n+struct X<T>(());\n+\n+impl <T> Foo for X<T> { }\n+\n+fn main() { }"}, {"sha": "2285c471c91912abc3a6d299929448624ab273e0", "filename": "src/test/run-pass/builtin-superkinds-self-type.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests the ability for the Self type in default methods to use\n+// capabilities granted by builtin kinds as supertraits.\n+\n+use std::comm;\n+\n+trait Foo : Send {\n+    fn foo(self, chan: comm::Chan<Self>) {\n+        chan.send(self);\n+    }\n+}\n+\n+impl <T: Send> Foo for T { }\n+\n+fn main() {\n+    let (p,c) = comm::stream();\n+    1193182.foo(c);\n+    assert!(p.recv() == 1193182);\n+}"}, {"sha": "61a22d97498cbbb51be191a541d6bb09f8507f02", "filename": "src/test/run-pass/builtin-superkinds-simple.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-simple.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Simple test case of implementing a trait with super-builtin-kinds.\n+\n+trait Foo : Send { }\n+\n+impl Foo for int { }\n+\n+fn main() { }"}, {"sha": "7dfd1e0629f8b860d4a19b5a7d7b2554247a8a83", "filename": "src/test/run-pass/builtin-superkinds-typaram.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ddfb725127a49e03593c0c56542f12826713bd6/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-typaram.rs?ref=3ddfb725127a49e03593c0c56542f12826713bd6", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests correct implementation of traits with super-builtin-kinds\n+// using a bounded type parameter.\n+\n+trait Foo : Send { }\n+\n+impl <T: Send> Foo for T { }\n+\n+fn main() { }"}]}