{"sha": "07faca9741e0ba9a9e77a8b876883ddd87cca1ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZmFjYTk3NDFlMGJhOWE5ZTc3YThiODc2ODgzZGRkODdjY2ExY2U=", "commit": {"author": {"name": "Meade Kincke", "email": "thedarkula2049@gmail.com", "date": "2018-07-07T14:39:21Z"}, "committer": {"name": "Meade Kincke", "email": "thedarkula2049@gmail.com", "date": "2018-07-14T20:46:19Z"}, "message": "Removed the promotable field from CheckCrateVisitor and replaced it with the structs Promotable and NotPromotable.", "tree": {"sha": "225280fd1f70e4c27ad999b5ac386c05d4f4c0f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/225280fd1f70e4c27ad999b5ac386c05d4f4c0f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07faca9741e0ba9a9e77a8b876883ddd87cca1ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07faca9741e0ba9a9e77a8b876883ddd87cca1ce", "html_url": "https://github.com/rust-lang/rust/commit/07faca9741e0ba9a9e77a8b876883ddd87cca1ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07faca9741e0ba9a9e77a8b876883ddd87cca1ce/comments", "author": null, "committer": null, "parents": [{"sha": "f629eb35950ef32a909a98548840f4645bb0f862", "url": "https://api.github.com/repos/rust-lang/rust/commits/f629eb35950ef32a909a98548840f4645bb0f862", "html_url": "https://github.com/rust-lang/rust/commit/f629eb35950ef32a909a98548840f4645bb0f862"}], "stats": {"total": 342, "additions": 213, "deletions": 129}, "files": [{"sha": "6fbe4e0f240bbcef8bb4ac9eb9ac65fb31a74dd2", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 196, "deletions": 129, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/07faca9741e0ba9a9e77a8b876883ddd87cca1ce/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07faca9741e0ba9a9e77a8b876883ddd87cca1ce/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=07faca9741e0ba9a9e77a8b876883ddd87cca1ce", "patch": "@@ -40,6 +40,9 @@ use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::{Span, DUMMY_SP};\n+use self::Promotability::*;\n+use std::ops::{BitAnd, BitOr};\n+\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -84,7 +87,6 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tables: &ty::TypeckTables::empty(None),\n         in_fn: false,\n         in_static: false,\n-        promotable: false,\n         mut_rvalue_borrows: NodeSet(),\n         param_env: ty::ParamEnv::empty(),\n         identity_substs: Substs::empty(),\n@@ -95,7 +97,7 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node_id = tcx.hir.as_local_node_id(def_id)\n         .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n     let body_id = tcx.hir.body_owned_by(node_id);\n-    visitor.visit_nested_body(body_id);\n+    let _ = visitor.check_nested_body(body_id);\n \n     Lrc::new(visitor.result)\n }\n@@ -104,38 +106,83 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     in_fn: bool,\n     in_static: bool,\n-    promotable: bool,\n     mut_rvalue_borrows: NodeSet,\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: &'tcx Substs<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     result: ItemLocalSet,\n }\n \n+#[must_use]\n+#[derive(Debug, PartialEq)]\n+enum Promotability {\n+    Promotable,\n+    NotPromotable\n+}\n+\n+impl BitAnd for Promotability {\n+    type Output = Self;\n+\n+    fn bitand(self, rhs: Self) -> Self {\n+        match (self, rhs) {\n+            (Promotable, NotPromotable) => NotPromotable,\n+            (NotPromotable, Promotable) => NotPromotable,\n+            (NotPromotable, NotPromotable) => NotPromotable,\n+            (Promotable, Promotable) => Promotable,\n+        }\n+    }\n+}\n+\n+impl BitOr for Promotability {\n+    type Output = Self;\n+\n+    fn bitor(self, rhs: Self) -> Self {\n+        match (self, rhs) {\n+            (Promotable, NotPromotable) => Promotable,\n+            (NotPromotable, Promotable) => Promotable,\n+            (NotPromotable, NotPromotable) => NotPromotable,\n+            (Promotable, Promotable) => Promotable,\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     // Returns true iff all the values of the type are promotable.\n-    fn type_has_only_promotable_values(&mut self, ty: Ty<'gcx>) -> bool {\n-        ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n-            !ty.needs_drop(self.tcx, self.param_env)\n+    fn type_promotability(&mut self, ty: Ty<'gcx>) -> Promotability {\n+        debug!(\"type_promotability({})\", ty);\n+\n+        if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n+            !ty.needs_drop(self.tcx, self.param_env) {\n+            Promotable\n+        } else {\n+            NotPromotable\n+        }\n     }\n \n-    fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>, span: Span) {\n-        self.promotable &= self.type_has_only_promotable_values(ret_ty);\n+    fn handle_const_fn_call(&mut self, def_id: DefId,\n+                            ret_ty: Ty<'gcx>, span: Span) -> Promotability {\n+        if let NotPromotable = self.type_promotability(ret_ty) {\n+            return NotPromotable;\n+        }\n \n-        self.promotable &= if let Some(fn_id) = self.tcx.hir.as_local_node_id(def_id) {\n+        let node_check = if let Some(fn_id) = self.tcx.hir.as_local_node_id(def_id) {\n             FnLikeNode::from_node(self.tcx.hir.get(fn_id)).map_or(false, |fn_like| {\n                 fn_like.constness() == hir::Constness::Const\n             })\n         } else {\n             self.tcx.is_const_fn(def_id)\n         };\n \n+        if !node_check {\n+            return NotPromotable\n+        }\n+\n         if let Some(&attr::Stability {\n             rustc_const_unstable: Some(attr::RustcConstUnstable {\n                                            feature: ref feature_name\n                                        }),\n             .. }) = self.tcx.lookup_stability(def_id) {\n-            self.promotable &=\n+            let stable_check =\n                 // feature-gate is enabled,\n                 self.tcx.features()\n                     .declared_lib_features\n@@ -147,7 +194,11 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n                     // this comes from a macro that has #[allow_internal_unstable]\n                     span.allows_unstable();\n-        }\n+            if !stable_check {\n+                return NotPromotable\n+            }\n+        };\n+        Promotable\n     }\n \n     /// While the `ExprUseVisitor` walks, we will identify which\n@@ -169,7 +220,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n }\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+    fn check_nested_body(&mut self, body_id: hir::BodyId) -> Promotability {\n         let item_id = self.tcx.hir.body_owner(body_id);\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n@@ -200,68 +251,67 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables, None)\n             .consume_body(body);\n \n-        self.visit_expr(&body.value);\n+        let body_promotable = self.check_expr(&body.value);\n         self.in_fn = outer_in_fn;\n         self.tables = outer_tables;\n         self.param_env = outer_param_env;\n         self.identity_substs = outer_identity_substs;\n+        body_promotable\n     }\n \n-    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n+    fn check_stmt(&mut self, stmt: &'tcx hir::Stmt) -> Promotability {\n         match stmt.node {\n             hir::StmtDecl(ref decl, _node_id) => {\n                 match &decl.node {\n                     hir::DeclLocal(local) => {\n-                        self.promotable = false;\n                         if self.remove_mut_rvalue_borrow(&local.pat) {\n                             if let Some(init) = &local.init {\n                                 self.mut_rvalue_borrows.insert(init.id);\n                             }\n                         }\n \n                         match local.init {\n-                            Some(ref expr) => self.visit_expr(&expr),\n+                            Some(ref expr) => { let _ = self.check_expr(&expr); },\n                             None => {},\n                         }\n+                        NotPromotable\n                     }\n                     // Item statements are allowed\n-                    hir::DeclItem(_) => {}\n+                    hir::DeclItem(_) => Promotable\n                 }\n             }\n             hir::StmtExpr(ref box_expr, _node_id) |\n             hir::StmtSemi(ref box_expr, _node_id) => {\n-                self.visit_expr(box_expr);\n-                self.promotable = false;\n+                let _ = self.check_expr(box_expr);\n+                NotPromotable\n             }\n         }\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n-        let outer = self.promotable;\n-        self.promotable = true;\n-\n+    fn check_expr(&mut self, ex: &'tcx hir::Expr) -> Promotability {\n         let node_ty = self.tables.node_id_to_type(ex.hir_id);\n-        check_expr(self, ex, node_ty);\n-        check_adjustments(self, ex);\n+        let mut outer = check_expr_kind(self, ex, node_ty);\n+        outer = outer & check_adjustments(self, ex);\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n         if self.mut_rvalue_borrows.remove(&ex.id) {\n-            self.promotable = false;\n+            outer = NotPromotable\n         }\n \n-        if self.promotable {\n+        if outer == Promotable {\n             self.result.insert(ex.hir_id.local_id);\n         }\n-        self.promotable &= outer;\n+        outer\n     }\n \n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+    fn check_block(&mut self, block: &'tcx hir::Block) -> Promotability {\n+        let mut iter_result = Promotable;\n         for index in block.stmts.iter() {\n-            self.visit_stmt(index)\n+            iter_result = iter_result & self.check_stmt(index);\n         }\n         match block.expr {\n-            Some(ref box_expr) => { self.visit_expr(&*box_expr) },\n-            None => {},\n+            Some(ref box_expr) => iter_result & self.check_expr(&*box_expr),\n+            None => iter_result,\n         }\n     }\n }\n@@ -272,63 +322,68 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n /// every nested expression. If the expression is not part\n /// of a const/static item, it is qualified for promotion\n /// instead of producing errors.\n-fn check_expr<'a, 'tcx>(\n+fn check_expr_kind<'a, 'tcx>(\n     v: &mut CheckCrateVisitor<'a, 'tcx>,\n-    e: &'tcx hir::Expr, node_ty: Ty<'tcx>) {\n-    match node_ty.sty {\n+    e: &'tcx hir::Expr, node_ty: Ty<'tcx>) -> Promotability {\n+\n+    let ty_result = match node_ty.sty {\n         ty::TyAdt(def, _) if def.has_dtor(v.tcx) => {\n-            v.promotable = false;\n+            NotPromotable\n         }\n-        _ => {}\n-    }\n+        _ => Promotable\n+    };\n \n-    match e.node {\n+    let node_result = match e.node {\n         hir::ExprBox(ref expr) => {\n-            v.visit_expr(&expr);\n-            v.promotable = false;\n+            let _ = v.check_expr(&expr);\n+            NotPromotable\n         }\n         hir::ExprUnary(op, ref expr) => {\n+            let expr_promotability = v.check_expr(expr);\n             if v.tables.is_method_call(e) {\n-                v.promotable = false;\n+                return NotPromotable;\n             }\n             if op == hir::UnDeref {\n-                v.promotable = false;\n+                return NotPromotable;\n             }\n-            v.visit_expr(expr);\n+            expr_promotability\n         }\n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            let lefty = v.check_expr(lhs);\n+            let righty = v.check_expr(rhs);\n             if v.tables.is_method_call(e) {\n-                v.promotable = false;\n+                return NotPromotable;\n             }\n-            v.visit_expr(lhs);\n-            v.visit_expr(rhs);\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                         op.node == hir::BiLe || op.node == hir::BiLt ||\n                         op.node == hir::BiGe || op.node == hir::BiGt);\n \n-                    v.promotable = false;\n+                    NotPromotable\n                 }\n-                _ => {}\n+                _ => lefty & righty\n             }\n         }\n         hir::ExprCast(ref from, _) => {\n-            v.visit_expr(from);\n+            let expr_promotability = v.check_expr(from);\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tables.cast_kinds().get(from.hir_id) {\n-                None => v.tcx.sess.delay_span_bug(e.span, \"no kind for cast\"),\n+                None => {\n+                    v.tcx.sess.delay_span_bug(e.span, \"no kind for cast\");\n+                    NotPromotable\n+                },\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n-                    v.promotable = false;\n+                    NotPromotable\n                 }\n-                _ => {}\n+                _ => expr_promotability\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n-                Def::Fn(..) | Def::Method(..) =>  {}\n+                Def::Fn(..) | Def::Method(..) => Promotable,\n \n                 // References to a static that are themselves within a static\n                 // are inherently promotable with the exception\n@@ -337,25 +392,18 @@ fn check_expr<'a, 'tcx>(\n                 Def::Static(did, _) => {\n \n                     if v.in_static {\n-                        let mut thread_local = false;\n-\n                         for attr in &v.tcx.get_attrs(did)[..] {\n                             if attr.check_name(\"thread_local\") {\n                                 debug!(\"Reference to Static(id={:?}) is unpromotable \\\n                                        due to a #[thread_local] attribute\", did);\n-                                v.promotable = false;\n-                                thread_local = true;\n-                                break;\n+                                return NotPromotable;\n                             }\n                         }\n-\n-                        if !thread_local {\n-                            debug!(\"Allowing promotion of reference to Static(id={:?})\", did);\n-                        }\n+                        Promotable\n                     } else {\n                         debug!(\"Reference to Static(id={:?}) is unpromotable as it is not \\\n                                referenced from a static\", did);\n-                        v.promotable = false;\n+                        NotPromotable\n \n                     }\n                 }\n@@ -364,26 +412,24 @@ fn check_expr<'a, 'tcx>(\n                 Def::AssociatedConst(did) => {\n                     let promotable = if v.tcx.trait_of_item(did).is_some() {\n                         // Don't peek inside trait associated constants.\n-                        false\n+                        NotPromotable\n+                    } else if v.tcx.at(e.span).const_is_rvalue_promotable_to_static(did) {\n+                        Promotable\n                     } else {\n-                        v.tcx.at(e.span).const_is_rvalue_promotable_to_static(did)\n+                        NotPromotable\n                     };\n-\n                     // Just in case the type is more specific than the definition,\n                     // e.g. impl associated const with type parameters, check it.\n                     // Also, trait associated consts are relaxed by this.\n-                    v.promotable &= promotable || v.type_has_only_promotable_values(node_ty);\n-                }\n-\n-                _ => {\n-                    v.promotable = false;\n+                    promotable | v.type_promotability(node_ty)\n                 }\n+                _ => NotPromotable\n             }\n         }\n         hir::ExprCall(ref callee, ref hirvec) => {\n-            v.visit_expr(callee);\n+            let mut call_result = v.check_expr(callee);\n             for index in hirvec.iter() {\n-                v.visit_expr(index)\n+                call_result = call_result & v.check_expr(index);\n             }\n             let mut callee = &**callee;\n             loop {\n@@ -401,9 +447,9 @@ fn check_expr<'a, 'tcx>(\n             } else {\n                 Def::Err\n             };\n-            match def {\n+            let def_result = match def {\n                 Def::StructCtor(_, CtorKind::Fn) |\n-                Def::VariantCtor(_, CtorKind::Fn) => {}\n+                Def::VariantCtor(_, CtorKind::Fn) => Promotable,\n                 Def::Fn(did) => {\n                     v.handle_const_fn_call(did, node_ty, e.span)\n                 }\n@@ -412,94 +458,110 @@ fn check_expr<'a, 'tcx>(\n                         ty::ImplContainer(_) => {\n                             v.handle_const_fn_call(did, node_ty, e.span)\n                         }\n-                        ty::TraitContainer(_) => v.promotable = false\n+                        ty::TraitContainer(_) => NotPromotable,\n                     }\n                 }\n-                _ => v.promotable = false\n-            }\n+                _ => NotPromotable,\n+            };\n+            def_result & call_result\n         }\n         hir::ExprMethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n+            let mut method_call_result = Promotable;\n             for index in hirvec.iter() {\n-                v.visit_expr(index)\n+                method_call_result = method_call_result & v.check_expr(index);\n             }\n             if let Some(def) = v.tables.type_dependent_defs().get(e.hir_id) {\n                 let def_id = def.def_id();\n                 match v.tcx.associated_item(def_id).container {\n-                    ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty, e.span),\n-                    ty::TraitContainer(_) => v.promotable = false\n-                }\n+                    ty::ImplContainer(_) => {\n+                        method_call_result = method_call_result\n+                            & v.handle_const_fn_call(def_id, node_ty, e.span);\n+                    }\n+                    ty::TraitContainer(_) => return NotPromotable,\n+                };\n             } else {\n                 v.tcx.sess.delay_span_bug(e.span, \"no type-dependent def for method call\");\n             }\n+            method_call_result\n         }\n         hir::ExprStruct(ref _qpath, ref hirvec, ref option_expr) => {\n+            let mut struct_result = Promotable;\n             for index in hirvec.iter() {\n-                v.visit_expr(&index.expr);\n+                struct_result = struct_result & v.check_expr(&index.expr);\n             }\n             match *option_expr {\n-                Some(ref expr) => { v.visit_expr(&expr) },\n+                Some(ref expr) => { struct_result = struct_result & v.check_expr(&expr); },\n                 None => {},\n             }\n             if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n-                    v.promotable = false;\n+                    return NotPromotable;\n                 }\n             }\n+            struct_result\n         }\n \n-        hir::ExprLit(_) => {}\n+        hir::ExprLit(_) => Promotable,\n \n         hir::ExprAddrOf(_, ref expr) |\n         hir::ExprRepeat(ref expr, _) => {\n-            v.visit_expr(expr);\n+            v.check_expr(&expr)\n         }\n \n         hir::ExprClosure(_capture_clause, ref _box_fn_decl,\n                          body_id, _span, _option_generator_movability) => {\n-            v.visit_nested_body(body_id);\n+            let nested_body_promotable = v.check_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n-                v.promotable = false;\n+                NotPromotable\n+            } else {\n+                nested_body_promotable\n             }\n         }\n \n         hir::ExprField(ref expr, _ident) => {\n-            v.visit_expr(expr);\n+            let expr_promotability = v.check_expr(&expr);\n             if let Some(def) = v.tables.expr_ty(expr).ty_adt_def() {\n                 if def.is_union() {\n-                    v.promotable = false\n+                    return NotPromotable;\n                 }\n             }\n+            expr_promotability\n         }\n \n         hir::ExprBlock(ref box_block, ref _option_label) => {\n-            v.visit_block(box_block);\n+            v.check_block(box_block)\n         }\n \n         hir::ExprIndex(ref lhs, ref rhs) => {\n+            let lefty = v.check_expr(lhs);\n+            let righty = v.check_expr(rhs);\n             if v.tables.is_method_call(e) {\n-                v.promotable = false;\n+                return NotPromotable;\n             }\n-            v.visit_expr(lhs);\n-            v.visit_expr(rhs);\n+            lefty & righty\n         }\n \n         hir::ExprArray(ref hirvec) => {\n+            let mut array_result = Promotable;\n             for index in hirvec.iter() {\n-                v.visit_expr(index)\n+                array_result = array_result & v.check_expr(index);\n             }\n+            array_result\n         }\n \n         hir::ExprType(ref expr, ref _ty) => {\n-            v.visit_expr(expr);\n+            v.check_expr(&expr)\n         }\n \n         hir::ExprTup(ref hirvec) => {\n+            let mut tup_result = Promotable;\n             for index in hirvec.iter() {\n-                v.visit_expr(index)\n+                tup_result = tup_result & v.check_expr(index);\n             }\n+            tup_result\n         }\n \n \n@@ -515,79 +577,84 @@ fn check_expr<'a, 'tcx>(\n                 v.mut_rvalue_borrows.insert(expr.id);\n             }\n \n-            v.visit_expr(expr);\n+            let _ = v.check_expr(expr);\n             for index in hirvec_arm.iter() {\n-                v.visit_expr(&*index.body);\n+                let _ = v.check_expr(&*index.body);\n                 match index.guard {\n-                    Some(ref expr) => v.visit_expr(&expr),\n+                    Some(ref expr) => {\n+                        let _ = v.check_expr(&expr);\n+                    },\n                     None => {},\n-                }\n+                };\n             }\n-            v.promotable = false;\n+            NotPromotable\n         }\n \n         hir::ExprIf(ref lhs, ref rhs, ref option_expr) => {\n-            v.visit_expr(lhs);\n-            v.visit_expr(rhs);\n+            let _ = v.check_expr(lhs);\n+            let _ = v.check_expr(rhs);\n             match option_expr {\n-                Some(ref expr) => v.visit_expr(&expr),\n+                Some(ref expr) => { let _ = v.check_expr(&expr); },\n                 None => {},\n-            }\n-            v.promotable = false;\n+            };\n+            NotPromotable\n         }\n \n         // Loops (not very meaningful in constants).\n         hir::ExprWhile(ref expr, ref box_block, ref _option_label) => {\n-            v.visit_expr(expr);\n-            v.visit_block(box_block);\n-            v.promotable = false;\n+            let _ = v.check_expr(expr);\n+            let _ = v.check_block(box_block);\n+            NotPromotable\n         }\n \n         hir::ExprLoop(ref box_block, ref _option_label, ref _loop_source) => {\n-            v.visit_block(box_block);\n-            v.promotable = false;\n+            let _ = v.check_block(box_block);\n+            NotPromotable\n         }\n \n         // More control flow (also not very meaningful).\n         hir::ExprBreak(_, ref option_expr) | hir::ExprRet(ref option_expr) => {\n             match *option_expr {\n-                Some(ref expr) => { v.visit_expr(&expr) },\n+                Some(ref expr) => { let _ = v.check_expr(&expr); },\n                 None => {},\n             }\n-            v.promotable = false;\n+            NotPromotable\n         }\n \n         hir::ExprContinue(_) => {\n-            v.promotable = false;\n+            NotPromotable\n         }\n \n         // Generator expressions\n         hir::ExprYield(ref expr) => {\n-            v.visit_expr(&expr);\n-            v.promotable = false;\n+            let _ = v.check_expr(&expr);\n+            NotPromotable\n         }\n \n         // Expressions with side-effects.\n         hir::ExprAssignOp(_, ref lhs, ref rhs) | hir::ExprAssign(ref lhs, ref rhs) => {\n-            v.visit_expr(lhs);\n-            v.visit_expr(rhs);\n-            v.promotable = false;\n+            let _ = v.check_expr(lhs);\n+            let _ = v.check_expr(rhs);\n+            NotPromotable\n         }\n \n         hir::ExprInlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n             for index in hirvec_lhs.iter() {\n-                v.visit_expr(index)\n+                let _ = v.check_expr(index);\n             }\n             for index in hirvec_rhs.iter() {\n-                v.visit_expr(index)\n+                let _ = v.check_expr(index);\n             }\n-            v.promotable = false;\n+            NotPromotable\n         }\n-    }\n+    };\n+    ty_result & node_result\n }\n \n /// Check the adjustments of an expression\n-fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n+fn check_adjustments<'a, 'tcx>(\n+    v: &mut CheckCrateVisitor<'a, 'tcx>,\n+    e: &hir::Expr) -> Promotability {\n     use rustc::ty::adjustment::*;\n \n     let mut adjustments = v.tables.expr_adjustments(e).iter().peekable();\n@@ -607,11 +674,11 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n                         continue;\n                     }\n                 }\n-                v.promotable = false;\n-                break;\n+                return NotPromotable;\n             }\n         }\n     }\n+    Promotable\n }\n \n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {"}, {"sha": "ddc995a1a41000c681637436605a88e1afe6fef8", "filename": "src/test/compile-fail/closure_promotion.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/07faca9741e0ba9a9e77a8b876883ddd87cca1ce/src%2Ftest%2Fcompile-fail%2Fclosure_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07faca9741e0ba9a9e77a8b876883ddd87cca1ce/src%2Ftest%2Fcompile-fail%2Fclosure_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure_promotion.rs?ref=07faca9741e0ba9a9e77a8b876883ddd87cca1ce", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(const_err)]\n+\n+// nll successfully compiles this. It is a bug.\n+// See https://github.com/rust-lang/rust/issues/52384\n+fn main() {\n+    let x: &'static _ = &|| { let z = 3; z }; //~ ERROR does not live long enough\n+}"}]}