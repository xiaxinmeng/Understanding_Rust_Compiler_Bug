{"sha": "4dbd10a7024a30ca21571254166ebbe4a10b1beb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYmQxMGE3MDI0YTMwY2EyMTU3MTI1NDE2NmViYmU0YTEwYjFiZWI=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-20T18:53:13Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:37Z"}, "message": "First example of a program using pipes.", "tree": {"sha": "9642d9fe5683ab1b2bfb538d7c15fccf0800a606", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9642d9fe5683ab1b2bfb538d7c15fccf0800a606"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dbd10a7024a30ca21571254166ebbe4a10b1beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dbd10a7024a30ca21571254166ebbe4a10b1beb", "html_url": "https://github.com/rust-lang/rust/commit/4dbd10a7024a30ca21571254166ebbe4a10b1beb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dbd10a7024a30ca21571254166ebbe4a10b1beb/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "117b9a0b75564e0f437add6abbac81b9e7f432a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/117b9a0b75564e0f437add6abbac81b9e7f432a1", "html_url": "https://github.com/rust-lang/rust/commit/117b9a0b75564e0f437add6abbac81b9e7f432a1"}], "stats": {"total": 114, "additions": 112, "deletions": 2}, "files": [{"sha": "b3b9d089fea7a92ce185c433cb7117017a8ba30c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dbd10a7024a30ca21571254166ebbe4a10b1beb/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dbd10a7024a30ca21571254166ebbe4a10b1beb/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=4dbd10a7024a30ca21571254166ebbe4a10b1beb", "patch": "@@ -1162,14 +1162,14 @@ pure fn unpack_mut_slice<T,U>(s: &[mut T],\n \n impl extensions<T: copy> for ~[T] {\n     #[inline(always)]\n-    pure fn +(rhs: &[T]) -> ~[T] {\n+    pure fn +(rhs: &[const T]) -> ~[T] {\n         append(self, rhs)\n     }\n }\n \n impl extensions<T: copy> for ~[mut T] {\n     #[inline(always)]\n-    pure fn +(rhs: &[mut T]) -> ~[mut T] {\n+    pure fn +(rhs: &[const T]) -> ~[mut T] {\n         append_mut(self, rhs)\n     }\n }"}, {"sha": "995e58ced31e64a4019c35264491546b39370fee", "filename": "src/test/run-pass/pipe-manual-1.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4dbd10a7024a30ca21571254166ebbe4a10b1beb/src%2Ftest%2Frun-pass%2Fpipe-manual-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dbd10a7024a30ca21571254166ebbe4a10b1beb/src%2Ftest%2Frun-pass%2Fpipe-manual-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-1.rs?ref=4dbd10a7024a30ca21571254166ebbe4a10b1beb", "patch": "@@ -0,0 +1,110 @@\n+/*\n+\n+The first test case using pipes. The idea is to break this into\n+several stages for prototyping. Here's the plan:\n+\n+1. Write an already-compiled protocol using existing ports and chans.\n+\n+2. Take the already-compiled version and add the low-level\n+synchronization code instead.\n+\n+3. Write a syntax extension to compile the protocols.\n+\n+At some point, we'll need to add support for select.\n+\n+*/\n+\n+mod pingpong {\n+    import newcomm::*;\n+\n+    type pingpong = ~mut option<(chan<()>, port<()>)>;\n+\n+    fn init() -> (client::ping, server::ping) {\n+        let cp = port();\n+        let sp = port();\n+        let cc = chan(sp);\n+        let sc = chan(cp);\n+\n+        let client = client::ping(~mut some((cc, cp)));\n+        let server = server::ping(~mut some((sc, sp)));\n+\n+        (client, server)\n+    }\n+\n+    mod client {\n+        enum ping = pingpong;\n+        enum pong = pingpong;\n+\n+        fn do_ping(-c: ping) -> pong {\n+            let mut op = none;\n+            op <-> **c;\n+            let (c, s) <- option::unwrap(op);\n+            c.send(());\n+            let p <- (c, s);\n+            pong(~mut some(p))\n+        }\n+\n+        fn do_pong(-c: pong) -> (ping, ()) {\n+            let mut op = none;\n+            op <-> **c;\n+            let (c, s) <- option::unwrap(op);\n+            let d = s.recv();\n+            let p <- (c, s);\n+            (ping(~mut some(p)), d)\n+        }\n+    }\n+\n+    mod server {\n+        enum ping = pingpong;\n+        enum pong = pingpong;\n+\n+        fn do_ping(-c: ping) -> (pong, ()) {\n+            let mut op = none;\n+            op <-> **c;\n+            let (c, s) <- option::unwrap(op);\n+            let d = s.recv();\n+            let p <- (c, s);\n+            (pong(~mut some(p)), d)\n+        }\n+\n+        fn do_pong(-c: pong) -> ping {\n+            let mut op = none;\n+            op <-> **c;\n+            let (c, s) <- option::unwrap(op);\n+            c.send(());\n+            let p <- (c, s);\n+            ping(~mut some(p))\n+        }\n+    }\n+}\n+\n+fn client(-chan: pingpong::client::ping) {\n+    let chan = pingpong::client::do_ping(chan);\n+    log(error, \"Sent ping\");\n+    let (_chan, _data) = pingpong::client::do_pong(chan);\n+    log(error, \"Received pong\");\n+}\n+\n+fn server(-chan: pingpong::server::ping) {\n+    let (chan, _data) = pingpong::server::do_ping(chan);\n+    log(error, \"Received ping\");\n+    let _chan = pingpong::server::do_pong(chan);\n+    log(error, \"Sent pong\");\n+}\n+\n+fn main() {\n+    let (client_, server_) = pingpong::init();\n+    let client_ = ~mut some(client_);\n+    let server_ = ~mut some(server_);\n+\n+    task::spawn {|move client_|\n+        let mut client__ = none;\n+        *client_ <-> client__;\n+        client(option::unwrap(client__));\n+    };\n+    task::spawn {|move server_|\n+        let mut server_\u02ca = none;\n+        *server_ <-> server_\u02ca;\n+        server(option::unwrap(server_\u02ca));\n+    };\n+}"}]}