{"sha": "a88d4f8c7216105e8bffed55fe85d9de796dc172", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4OGQ0ZjhjNzIxNjEwNWU4YmZmZWQ1NWZlODVkOWRlNzk2ZGMxNzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-02T17:42:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-02T17:42:45Z"}, "message": "Merge #7133\n\n7133: Proper handling $crate and local_inner_macros r=jonas-schievink a=edwin0cheng\n\nThis PR introduces `HygineFrames` to store the macro definition/call site hierarchy in hyginee and when resolving `local_inner_macros` and `$crate`, we use the token to look up the corresponding frame and return the correct value.\r\n\r\nSee also: https://rustc-dev-guide.rust-lang.org/macro-expansion.html#hygiene-and-hierarchies\r\n\r\nfixe #6890 and  #6788\r\n\r\nr? @jonas-schievink \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "da8fe6fd5f771181ee1753907af22d9c0ce60586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da8fe6fd5f771181ee1753907af22d9c0ce60586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a88d4f8c7216105e8bffed55fe85d9de796dc172", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf8LCVCRBK7hj4Ov3rIwAAdHIIAEgkPkXzvP4zegrz208/eO07\ntGJxXRUyqWu0cUeI6X337dl8yLvW70i0zdZJirzaM/TJtKVpQCcb8NDJBNqloKnL\nmwxjA0E6VKU/lY3FuxU+H9IXbPN5kqyJMA80BrM4O+2GkbDfXUMap+M065rQZV3o\n+U/c0IQMjs4sbtk/q134dGpgtMogM7ieAe2ZNZXyDQAhh2F6wQ3VMDswZOWDowdT\ncsrDZdLfW2A6M4E2B3NXZ7EJm3FqYx33Lm4J3Mmj3L8SisGv2WfscYLuOH7iTSPN\n5qXGqzUvEE9K6cu+UqloDDNC+NJjeExYkzBuqPOOtHvA2QJ1GaachGlIN/mlg9M=\n=Jdy5\n-----END PGP SIGNATURE-----\n", "payload": "tree da8fe6fd5f771181ee1753907af22d9c0ce60586\nparent 510abef5da1427c542e7b37dcea805c7b022984c\nparent 3545289603dae852fb2b99181e9be5e3117b0a2e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1609609365 +0000\ncommitter GitHub <noreply@github.com> 1609609365 +0000\n\nMerge #7133\n\n7133: Proper handling $crate and local_inner_macros r=jonas-schievink a=edwin0cheng\n\nThis PR introduces `HygineFrames` to store the macro definition/call site hierarchy in hyginee and when resolving `local_inner_macros` and `$crate`, we use the token to look up the corresponding frame and return the correct value.\r\n\r\nSee also: https://rustc-dev-guide.rust-lang.org/macro-expansion.html#hygiene-and-hierarchies\r\n\r\nfixe #6890 and  #6788\r\n\r\nr? @jonas-schievink \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a88d4f8c7216105e8bffed55fe85d9de796dc172", "html_url": "https://github.com/rust-lang/rust/commit/a88d4f8c7216105e8bffed55fe85d9de796dc172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a88d4f8c7216105e8bffed55fe85d9de796dc172/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "510abef5da1427c542e7b37dcea805c7b022984c", "url": "https://api.github.com/repos/rust-lang/rust/commits/510abef5da1427c542e7b37dcea805c7b022984c", "html_url": "https://github.com/rust-lang/rust/commit/510abef5da1427c542e7b37dcea805c7b022984c"}, {"sha": "3545289603dae852fb2b99181e9be5e3117b0a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3545289603dae852fb2b99181e9be5e3117b0a2e", "html_url": "https://github.com/rust-lang/rust/commit/3545289603dae852fb2b99181e9be5e3117b0a2e"}], "stats": {"total": 228, "additions": 176, "deletions": 52}, "files": [{"sha": "9518ac109be5f6f4858fecc0839bc6617be9225e", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=a88d4f8c7216105e8bffed55fe85d9de796dc172", "patch": "@@ -123,7 +123,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     // We follow what it did anyway :)\n     if segments.len() == 1 && kind == PathKind::Plain {\n         if let Some(_macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n-            if let Some(crate_id) = hygiene.local_inner_macros() {\n+            if let Some(crate_id) = hygiene.local_inner_macros(path) {\n                 kind = PathKind::DollarCrate(crate_id);\n             }\n         }"}, {"sha": "6042e15b2280b0d9d2a9a97bbd0c04ccebcccd20", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 126, "deletions": 25, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=a88d4f8c7216105e8bffed55fe85d9de796dc172", "patch": "@@ -2,30 +2,94 @@\n //!\n //! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n //! this moment, this is horribly incomplete and handles only `$crate`.\n+use std::sync::Arc;\n+\n+use arena::{Arena, Idx};\n use base_db::CrateId;\n use either::Either;\n-use syntax::ast;\n+use mbe::Origin;\n+use syntax::{ast, AstNode};\n \n use crate::{\n     db::AstDatabase,\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n+    ExpansionInfo, HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n };\n \n #[derive(Clone, Debug)]\n pub struct Hygiene {\n-    // This is what `$crate` expands to\n-    def_crate: Option<CrateId>,\n+    frames: Option<Arc<HygieneFrames>>,\n+}\n+\n+impl Hygiene {\n+    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n+        Hygiene { frames: Some(Arc::new(HygieneFrames::new(db, file_id.clone()))) }\n+    }\n+\n+    pub fn new_unhygienic() -> Hygiene {\n+        Hygiene { frames: None }\n+    }\n+\n+    // FIXME: this should just return name\n+    pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n+        if let Some(frames) = &self.frames {\n+            if name_ref.text() == \"$crate\" {\n+                if let Some(krate) = frames.root_crate(&name_ref) {\n+                    return Either::Right(krate);\n+                }\n+            }\n+        }\n+\n+        Either::Left(name_ref.as_name())\n+    }\n+\n+    pub fn local_inner_macros(&self, path: ast::Path) -> Option<CrateId> {\n+        let frames = self.frames.as_ref()?;\n+\n+        let mut token = path.syntax().first_token()?;\n+        let mut current = frames.first();\n+\n+        while let Some((frame, data)) =\n+            current.and_then(|it| Some((it, it.expansion.as_ref()?.map_token_up(&token)?)))\n+        {\n+            let (mapped, origin) = data;\n+            if origin == Origin::Def {\n+                return if frame.local_inner { frame.krate } else { None };\n+            }\n+            current = Some(&frames.0[frame.call_site?]);\n+            token = mapped.value;\n+        }\n+        None\n+    }\n+}\n+\n+#[derive(Default, Debug)]\n+struct HygieneFrames(Arena<HygieneFrame>);\n+\n+#[derive(Clone, Debug)]\n+struct HygieneFrame {\n+    expansion: Option<ExpansionInfo>,\n \n     // Indicate this is a local inner macro\n     local_inner: bool,\n+    krate: Option<CrateId>,\n+\n+    call_site: Option<Idx<HygieneFrame>>,\n+    def_site: Option<Idx<HygieneFrame>>,\n }\n \n-impl Hygiene {\n-    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n-        let (def_crate, local_inner) = match file_id.0 {\n+impl HygieneFrames {\n+    fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Self {\n+        let mut frames = HygieneFrames::default();\n+        frames.add(db, file_id);\n+        frames\n+    }\n+\n+    fn add(&mut self, db: &dyn AstDatabase, file_id: HirFileId) -> Option<Idx<HygieneFrame>> {\n+        let (krate, local_inner) = match file_id.0 {\n             HirFileIdRepr::FileId(_) => (None, false),\n             HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n+                MacroCallId::EagerMacro(_id) => (None, false),\n                 MacroCallId::LazyMacro(id) => {\n                     let loc = db.lookup_intern_macro(id);\n                     match loc.def.kind {\n@@ -36,31 +100,68 @@ impl Hygiene {\n                         MacroDefKind::ProcMacro(_) => (None, false),\n                     }\n                 }\n-                MacroCallId::EagerMacro(_id) => (None, false),\n             },\n         };\n-        Hygiene { def_crate, local_inner }\n-    }\n \n-    pub fn new_unhygienic() -> Hygiene {\n-        Hygiene { def_crate: None, local_inner: false }\n+        let expansion = file_id.expansion_info(db);\n+        let expansion = match expansion {\n+            None => {\n+                return Some(self.0.alloc(HygieneFrame {\n+                    expansion: None,\n+                    local_inner,\n+                    krate,\n+                    call_site: None,\n+                    def_site: None,\n+                }));\n+            }\n+            Some(it) => it,\n+        };\n+\n+        let def_site = expansion.def.clone();\n+        let call_site = expansion.arg.file_id;\n+        let idx = self.0.alloc(HygieneFrame {\n+            expansion: Some(expansion),\n+            local_inner,\n+            krate,\n+            call_site: None,\n+            def_site: None,\n+        });\n+\n+        self.0[idx].call_site = self.add(db, call_site);\n+        self.0[idx].def_site = def_site.and_then(|it| self.add(db, it.file_id));\n+\n+        Some(idx)\n     }\n \n-    // FIXME: this should just return name\n-    pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n-        if let Some(def_crate) = self.def_crate {\n-            if name_ref.text() == \"$crate\" {\n-                return Either::Right(def_crate);\n-            }\n-        }\n-        Either::Left(name_ref.as_name())\n+    fn first(&self) -> Option<&HygieneFrame> {\n+        self.0.iter().next().map(|it| it.1)\n     }\n \n-    pub fn local_inner_macros(&self) -> Option<CrateId> {\n-        if self.local_inner {\n-            self.def_crate\n-        } else {\n-            None\n+    fn root_crate(&self, name_ref: &ast::NameRef) -> Option<CrateId> {\n+        let mut token = name_ref.syntax().first_token()?;\n+        let first = self.first()?;\n+        let mut result = first.krate;\n+        let mut current = Some(first);\n+\n+        while let Some((frame, (mapped, origin))) =\n+            current.and_then(|it| Some((it, it.expansion.as_ref()?.map_token_up(&token)?)))\n+        {\n+            result = frame.krate;\n+\n+            let site = match origin {\n+                Origin::Def => frame.def_site,\n+                Origin::Call => frame.call_site,\n+            };\n+\n+            let site = match site {\n+                None => break,\n+                Some(it) => it,\n+            };\n+\n+            current = Some(&self.0[site]);\n+            token = mapped.value;\n         }\n+\n+        result\n     }\n }"}, {"sha": "5b6734a5f4e7d573f49209ba02913b6d3fd414a6", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=a88d4f8c7216105e8bffed55fe85d9de796dc172", "patch": "@@ -340,11 +340,8 @@ impl ExpansionInfo {\n         Some(self.expanded.with_value(token))\n     }\n \n-    pub fn map_token_up(\n-        &self,\n-        token: InFile<&SyntaxToken>,\n-    ) -> Option<(InFile<SyntaxToken>, Origin)> {\n-        let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n+    pub fn map_token_up(&self, token: &SyntaxToken) -> Option<(InFile<SyntaxToken>, Origin)> {\n+        let token_id = self.exp_map.token_by_range(token.text_range())?;\n \n         let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n         let (token_map, tt) = match origin {\n@@ -359,7 +356,7 @@ impl ExpansionInfo {\n             ),\n         };\n \n-        let range = token_map.range_by_token(token_id)?.by_kind(token.value.kind())?;\n+        let range = token_map.range_by_token(token_id)?.by_kind(token.kind())?;\n         let token = algo::find_covering_element(&tt.value, range + tt.value.text_range().start())\n             .into_token()?;\n         Some((tt.with_value(token), origin))\n@@ -495,7 +492,7 @@ fn ascend_call_token(\n     expansion: &ExpansionInfo,\n     token: InFile<SyntaxToken>,\n ) -> Option<InFile<SyntaxToken>> {\n-    let (mapped, origin) = expansion.map_token_up(token.as_ref())?;\n+    let (mapped, origin) = expansion.map_token_up(&token.value)?;\n     if origin != Origin::Call {\n         return None;\n     }"}, {"sha": "23b79abc45f2437250f4df50b41f2ecddd755263", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=a88d4f8c7216105e8bffed55fe85d9de796dc172", "patch": "@@ -370,6 +370,37 @@ expand!();\n     );\n }\n \n+#[test]\n+fn infer_macro_with_dollar_crate_in_def_site() {\n+    check_types(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+use foo::expand;\n+\n+macro_rules! list {\n+    ($($tt:tt)*) => { $($tt)* }\n+}\n+\n+fn test() {\n+    let r = expand!();\n+    r;\n+  //^ u128\n+}\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! expand {\n+    () => { list!($crate::m!()) };\n+}\n+\n+#[macro_export]\n+macro_rules! m {\n+    () => { 0u128 };\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_type_value_non_legacy_macro_use_as() {\n     check_infer("}, {"sha": "385b4660187f8f29a369cac5c1d2dc146e8ed41f", "filename": "crates/mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=a88d4f8c7216105e8bffed55fe85d9de796dc172", "patch": "@@ -150,7 +150,7 @@ fn match_subtree(\n                     res.add_err(err!(\"leftover tokens\"));\n                 }\n             }\n-            Op::Var { name, kind } => {\n+            Op::Var { name, kind, .. } => {\n                 let kind = match kind {\n                     Some(k) => k,\n                     None => {"}, {"sha": "57f3f104dcaa77707c5be1f53bc63299086cf1aa", "filename": "crates/mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=a88d4f8c7216105e8bffed55fe85d9de796dc172", "patch": "@@ -100,8 +100,8 @@ fn expand_subtree(\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n-            Op::Var { name, .. } => {\n-                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name);\n+            Op::Var { name, id, .. } => {\n+                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name, *id);\n                 err = err.or(e);\n                 push_fragment(arena, fragment);\n             }\n@@ -118,12 +118,10 @@ fn expand_subtree(\n     ExpandResult { value: tt::Subtree { delimiter: template.delimiter, token_trees: tts }, err }\n }\n \n-fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n+fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n     if v == \"crate\" {\n         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-        let tt =\n-            tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n-                .into();\n+        let tt = tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id }).into();\n         ExpandResult::ok(Fragment::Tokens(tt))\n     } else if !ctx.bindings.contains(v) {\n         // Note that it is possible to have a `$var` inside a macro which is not bound.\n@@ -142,14 +140,8 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n         let tt = tt::Subtree {\n             delimiter: None,\n             token_trees: vec![\n-                tt::Leaf::from(tt::Punct {\n-                    char: '$',\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n-                })\n-                .into(),\n-                tt::Leaf::from(tt::Ident { text: v.clone(), id: tt::TokenId::unspecified() })\n-                    .into(),\n+                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone, id }).into(),\n+                tt::Leaf::from(tt::Ident { text: v.clone(), id }).into(),\n             ],\n         }\n         .into();"}, {"sha": "77cc739b65707d6a3e09df2d955bb361df466451", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a88d4f8c7216105e8bffed55fe85d9de796dc172/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=a88d4f8c7216105e8bffed55fe85d9de796dc172", "patch": "@@ -8,7 +8,7 @@ use crate::{tt_iter::TtIter, ExpandError, MetaTemplate};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n-    Var { name: SmolStr, kind: Option<SmolStr> },\n+    Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n     Repeat { subtree: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n     Leaf(tt::Leaf),\n     Subtree(MetaTemplate),\n@@ -106,18 +106,21 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                         }\n                         let name = UNDERSCORE.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n-                        Op::Var { name, kind }\n+                        let id = punct.id;\n+                        Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let name = ident.text.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n-                        Op::Var { name, kind }\n+                        let id = ident.id;\n+                        Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Literal(lit) => {\n                         if is_boolean_literal(&lit) {\n                             let name = lit.text.clone();\n                             let kind = eat_fragment_kind(src, mode)?;\n-                            Op::Var { name, kind }\n+                            let id = lit.id;\n+                            Op::Var { name, kind, id }\n                         } else {\n                             bail!(\"bad var 2\");\n                         }"}]}