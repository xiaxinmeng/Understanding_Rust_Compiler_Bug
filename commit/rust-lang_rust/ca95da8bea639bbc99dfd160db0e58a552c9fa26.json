{"sha": "ca95da8bea639bbc99dfd160db0e58a552c9fa26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOTVkYThiZWE2MzliYmM5OWRmZDE2MGRiMGU1OGE1NTJjOWZhMjY=", "commit": {"author": {"name": "Jeffrey Yasskin", "email": "jyasskin@gmail.com", "date": "2010-07-18T22:33:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2010-07-19T17:23:45Z"}, "message": "Teach the LLVM backend to emit line number information.\nThis isn't complete: it misses line numbers in certain kinds of block.  It's\nalso still tricky to use it on Darwin, where we need to call dsymutil while the\n.o file is still around in order for gdb to find the debugging symbols.", "tree": {"sha": "07fb942e2a671a55cb11d4692209ee3215467e81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07fb942e2a671a55cb11d4692209ee3215467e81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca95da8bea639bbc99dfd160db0e58a552c9fa26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca95da8bea639bbc99dfd160db0e58a552c9fa26", "html_url": "https://github.com/rust-lang/rust/commit/ca95da8bea639bbc99dfd160db0e58a552c9fa26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca95da8bea639bbc99dfd160db0e58a552c9fa26/comments", "author": {"login": "jyasskin", "id": 83420, "node_id": "MDQ6VXNlcjgzNDIw", "avatar_url": "https://avatars.githubusercontent.com/u/83420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyasskin", "html_url": "https://github.com/jyasskin", "followers_url": "https://api.github.com/users/jyasskin/followers", "following_url": "https://api.github.com/users/jyasskin/following{/other_user}", "gists_url": "https://api.github.com/users/jyasskin/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyasskin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyasskin/subscriptions", "organizations_url": "https://api.github.com/users/jyasskin/orgs", "repos_url": "https://api.github.com/users/jyasskin/repos", "events_url": "https://api.github.com/users/jyasskin/events{/privacy}", "received_events_url": "https://api.github.com/users/jyasskin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d974aade934d7bca50fe66eb1de849d4b666828b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d974aade934d7bca50fe66eb1de849d4b666828b", "html_url": "https://github.com/rust-lang/rust/commit/d974aade934d7bca50fe66eb1de849d4b666828b"}], "stats": {"total": 114, "additions": 87, "deletions": 27}, "files": [{"sha": "e104391dafb4190a36ee0476715a70c9f0ca7d83", "filename": "src/boot/llvm/lltrans.ml", "status": "modified", "additions": 87, "deletions": 27, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ca95da8bea639bbc99dfd160db0e58a552c9fa26/src%2Fboot%2Fllvm%2Flltrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/ca95da8bea639bbc99dfd160db0e58a552c9fa26/src%2Fboot%2Fllvm%2Flltrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Flltrans.ml?ref=ca95da8bea639bbc99dfd160db0e58a552c9fa26", "patch": "@@ -24,10 +24,6 @@ let trans_crate\n   in\n \n   (* Helpers for adding metadata. *)\n-  let (dbg_mdkind:int) = Llvm.mdkind_id llctx \"dbg\" in\n-  let set_dbg_metadata (inst:Llvm.llvalue) (md:Llvm.llvalue) : unit =\n-    Llvm.set_metadata inst dbg_mdkind md\n-  in\n   let md_str (s:string) : Llvm.llvalue = Llvm.mdstring llctx s in\n   let md_node (vals:Llvm.llvalue array) : Llvm.llvalue =\n     Llvm.mdnode llctx vals\n@@ -43,6 +39,73 @@ let trans_crate\n     const_i32 (llvm_debug_version lor (Dwarf.dw_tag_to_int tag))\n   in\n \n+  (* See http://llvm.org/docs/SourceLevelDebugging.html. *)\n+  let crate_compile_unit : Llvm.llvalue =\n+    let name = Hashtbl.find sem_cx.Semant.ctxt_item_files crate.id in\n+    md_node [| const_dw_tag Dwarf.DW_TAG_compile_unit;\n+               const_i32 0;  (* Unused. *)\n+               const_i32 2;  (* DW_LANG_C. FIXME: Pick a Rust DW_LANG code. *)\n+               md_str (Filename.basename name);\n+               md_str (Filename.concat\n+                            (Sys.getcwd()) (Filename.dirname name));\n+               md_str (\"Rustboot \" ^ Version.version);\n+               (* This is the main compile unit. There must be exactly one of\n+                  these in an LLVM module for it to emit debug info. *)\n+               const_i1 1;\n+               (* There are a couple more supported fields, which we ignore\n+                  here. *)\n+            |]\n+  in\n+  let di_file (filepath:string) =\n+    md_node [| const_dw_tag Dwarf.DW_TAG_file_type;\n+               md_str (Filename.basename filepath);\n+               md_str (Filename.concat\n+                            (Sys.getcwd()) (Filename.dirname filepath));\n+               crate_compile_unit\n+            |]\n+  in\n+  let di_subprogram (scope:Llvm.llvalue) (name:string) (fullname:string)\n+      (di_file:Llvm.llvalue) (line:int) (llfunction:Llvm.llvalue)\n+      : Llvm.llvalue =\n+    (* 'scope' is generally a compile unit or other subprogram.  *)\n+    md_node [| const_dw_tag Dwarf.DW_TAG_subprogram;\n+               const_i32 0;  (* Unused. *)\n+               scope;\n+               md_str name;\n+               md_str fullname;  (* Display name *)\n+               md_str fullname;  (* Linkage name *)\n+               di_file;\n+               const_i32 line;\n+               (* FIXME: Fill in the following fields. *)\n+               md_node [||];\n+               const_i1 1;\n+               const_i1 1;\n+               const_i32 0;\n+               const_i32 0;\n+               md_node [||];\n+               const_i1 0;\n+               const_i1 0;\n+               llfunction  (* The llvm::Function this reflects. *)\n+            |]\n+  in\n+  let di_location (line:int) (col:int) (scope:Llvm.llvalue) : Llvm.llvalue =\n+    (* 'scope' is generally a subprogram or block. *)\n+    md_node [| const_i32 line; const_i32 col; scope; const_i32 0 |]\n+  in\n+\n+  (* Sets the 'llbuilder's current location (which it attaches to all\n+     instructions) to the location of the start of the 'id' node within\n+     'scope', usually a subprogram or lexical block. *)\n+  let set_debug_location\n+      (llbuilder:Llvm.llbuilder) (scope:Llvm.llvalue) (id:node_id)\n+      : unit =\n+    match Session.get_span sess id with\n+        None -> ()\n+      | Some {lo=(_, line, col)} ->\n+          Llvm.set_current_debug_location llbuilder\n+            (di_location line col scope)\n+  in\n+\n   (* Translation of our node_ids into LLVM identifiers, which are strings. *)\n   let next_anon_llid = ref 0 in\n   let num_llid num klass = Printf.sprintf \"%s%d\" klass num in\n@@ -475,44 +538,31 @@ let trans_crate\n   in\n \n   let (llitems:(node_id, Llvm.llvalue) Hashtbl.t) = Hashtbl.create 0 in\n+    (* Maps a fn's or block's id to an LLVM metadata node (subprogram or\n+       lexical block) representing it. *)\n+  let (dbg_llscopes:(node_id, Llvm.llvalue) Hashtbl.t) = Hashtbl.create 0 in\n   let declare_mod_item\n       (name:Ast.ident)\n       { node = { Ast.decl_item = (item:Ast.mod_item') }; id = id }\n       : unit =\n     let full_name = Semant.item_str sem_cx id in\n-    let line_num =\n+    let (filename, line_num) =\n       match Session.get_span sess id with\n-          None -> 0\n+          None -> (\"\", 0)\n         | Some span ->\n-            let (_, line, _) = span.lo in\n-              line\n+            let (file, line, _) = span.lo in\n+              (file, line)\n     in\n       match item with\n           Ast.MOD_ITEM_fn _ ->\n             let llty = trans_ty (ty_of_item id) in\n             let llfn = Llvm.declare_function (\"_rust_\" ^ name) llty llmod in\n-            let meta =\n-              md_node\n-                [|\n-                  const_dw_tag Dwarf.DW_TAG_subprogram;\n-                  const_i32 0; (* unused *)\n-                  const_i32 0; (* context metadata llvalue *)\n-                  md_str name;\n-                  md_str full_name;\n-                  md_str full_name;\n-                  const_i32 0; (* file metadata llvalue *)\n-                  const_i32 line_num;\n-                  const_i32 0; (* type descriptor metadata llvalue *)\n-                  const_i1 1;  (* flag: local to compile unit? *)\n-                  const_i1 1;  (* flag: defined in compile unit? *)\n-                |]\n+            let meta = (di_subprogram crate_compile_unit name full_name\n+                          (di_file filename) line_num llfn)\n             in\n               Llvm.set_function_call_conv Llvm.CallConv.c llfn;\n               Hashtbl.add llitems id llfn;\n-\n-              (* FIXME: Adding metadata does not work yet. . *)\n-              let _ = fun _ -> set_dbg_metadata llfn meta in\n-                ()\n+              Hashtbl.add dbg_llscopes id meta\n \n         | _ -> () (* TODO *)\n   in\n@@ -527,6 +577,7 @@ let trans_crate\n     let llfn = Hashtbl.find llitems fn_id in\n     let lloutptr = Llvm.param llfn 0 in\n     let lltask = Llvm.param llfn 1 in\n+    let llsubprogram = Hashtbl.find dbg_llscopes fn_id in\n \n     (* LLVM requires that functions be grouped into basic blocks terminated by\n      * terminator instructions, while our AST is less strict. So we have to do\n@@ -621,6 +672,12 @@ let trans_crate\n         (stmts:Ast.stmt list)\n         (terminate:(Llvm.llbuilder -> node_id -> unit))\n         : unit =\n+      let set_debug_loc (id:node_id) =\n+        (* Sets the llbuilder's current location (which it attaches to all\n+           instructions) to the location of the start of the 'id' node. *)\n+        set_debug_location llbuilder llsubprogram id\n+      in\n+\n       let trans_literal\n           (lit:Ast.lit)\n           : Llvm.llvalue =\n@@ -645,6 +702,7 @@ let trans_crate\n         iflog (fun _ -> log sem_cx \"trans_lval: %a\" Ast.sprintf_lval lval);\n         match lval with\n             Ast.LVAL_base { id = base_id } ->\n+              set_debug_loc base_id;\n               let id =\n                 Hashtbl.find sem_cx.Semant.ctxt_lval_to_referent base_id\n               in\n@@ -760,6 +818,8 @@ let trans_crate\n             in\n             let trans_tail () = trans_tail_with_builder llbuilder in\n \n+            set_debug_loc head.id;\n+\n             match head.node with\n                 Ast.STMT_init_tup (dest, elems) ->\n                   let zero = const_i32 0 in"}]}