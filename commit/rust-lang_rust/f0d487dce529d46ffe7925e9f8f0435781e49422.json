{"sha": "f0d487dce529d46ffe7925e9f8f0435781e49422", "node_id": "C_kwDOAAsO6NoAKGYwZDQ4N2RjZTUyOWQ0NmZmZTc5MjVlOWY4ZjA0MzU3ODFlNDk0MjI", "commit": {"author": {"name": "Petros Angelatos", "email": "petrosagg@gmail.com", "date": "2023-04-08T17:41:50Z"}, "committer": {"name": "Petros Angelatos", "email": "petrosagg@gmail.com", "date": "2023-04-08T17:57:22Z"}, "message": "sync::mpsc: synchronize receiver disconnect with initialization\n\nReceiver disconnection relies on the incorrect assumption that\n`head.index != tail.index` implies that the channel is initialized (i.e\n`head.block` and `tail.block` point to allocated blocks). However, it\ncan happen that `head.index != tail.index` and `head.block == null` at\nthe same time which leads to a segfault when a channel is dropped in\nthat state.\n\nThis can happen because initialization is performed in two steps. First,\nthe tail block is allocated and the `tail.block` is set. If that is\nsuccessful `head.block` is set to the same pointer. Importantly,\ninitialization is skipped if `tail.block` is not null.\n\nTherefore we can have the following situation:\n\n1. Thread A starts to send the first value of the channel, observes that\n   `tail.block` is null and begins initialization. It sets `tail.block`\n   to point to a newly allocated block and then gets preempted.\n   `head.block` is still null at this point.\n2. Thread B starts to send the second value of the channel, observes\n   that `tail.block` *is not* null and proceeds with writing its value\n   in the allocated tail block and sets `tail.index` to 1.\n3. Thread B drops the receiver of the channel which observes that\n   `head.index != tail.index` (0 and 1 respectively), therefore there\n   must be messages to drop. It starts traversing the linked list from\n   `head.block` which is still a null pointer, leading to a segfault.\n\nThis PR fixes this problem by waiting for initialization to complete\nwhen `head.index != tail.index` and the `head.block` is still null. A\nsimilar check exists in `start_recv` for similar reasons.\n\nFixes #110001\n\nSigned-off-by: Petros Angelatos <petrosagg@gmail.com>", "tree": {"sha": "e9d4d2f5ff31cab72ae41a861e512d088dcdbc89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9d4d2f5ff31cab72ae41a861e512d088dcdbc89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0d487dce529d46ffe7925e9f8f0435781e49422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0d487dce529d46ffe7925e9f8f0435781e49422", "html_url": "https://github.com/rust-lang/rust/commit/f0d487dce529d46ffe7925e9f8f0435781e49422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0d487dce529d46ffe7925e9f8f0435781e49422/comments", "author": {"login": "petrosagg", "id": 939420, "node_id": "MDQ6VXNlcjkzOTQyMA==", "avatar_url": "https://avatars.githubusercontent.com/u/939420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrosagg", "html_url": "https://github.com/petrosagg", "followers_url": "https://api.github.com/users/petrosagg/followers", "following_url": "https://api.github.com/users/petrosagg/following{/other_user}", "gists_url": "https://api.github.com/users/petrosagg/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrosagg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrosagg/subscriptions", "organizations_url": "https://api.github.com/users/petrosagg/orgs", "repos_url": "https://api.github.com/users/petrosagg/repos", "events_url": "https://api.github.com/users/petrosagg/events{/privacy}", "received_events_url": "https://api.github.com/users/petrosagg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrosagg", "id": 939420, "node_id": "MDQ6VXNlcjkzOTQyMA==", "avatar_url": "https://avatars.githubusercontent.com/u/939420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrosagg", "html_url": "https://github.com/petrosagg", "followers_url": "https://api.github.com/users/petrosagg/followers", "following_url": "https://api.github.com/users/petrosagg/following{/other_user}", "gists_url": "https://api.github.com/users/petrosagg/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrosagg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrosagg/subscriptions", "organizations_url": "https://api.github.com/users/petrosagg/orgs", "repos_url": "https://api.github.com/users/petrosagg/repos", "events_url": "https://api.github.com/users/petrosagg/events{/privacy}", "received_events_url": "https://api.github.com/users/petrosagg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f87a63edcef5c8c06229ff13e0f64f427537378", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f87a63edcef5c8c06229ff13e0f64f427537378", "html_url": "https://github.com/rust-lang/rust/commit/4f87a63edcef5c8c06229ff13e0f64f427537378"}], "stats": {"total": 12, "additions": 12, "deletions": 0}, "files": [{"sha": "406a331a309614c35cde21ec6384bb0c0d1fda38", "filename": "library/std/src/sync/mpmc/list.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0d487dce529d46ffe7925e9f8f0435781e49422/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d487dce529d46ffe7925e9f8f0435781e49422/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpmc%2Flist.rs?ref=f0d487dce529d46ffe7925e9f8f0435781e49422", "patch": "@@ -549,6 +549,18 @@ impl<T> Channel<T> {\n         let mut head = self.head.index.load(Ordering::Acquire);\n         let mut block = self.head.block.load(Ordering::Acquire);\n \n+        // If we're going to be dropping messages we need to synchronize with initialization\n+        if head >> SHIFT != tail >> SHIFT {\n+            // The block can be null here only if a sender is in the process of initializing the\n+            // channel while another sender managed to send a message by inserting it into the\n+            // semi-initialized channel and advanced the tail.\n+            // In that case, just wait until it gets initialized.\n+            while block.is_null() {\n+                backoff.spin_heavy();\n+                block = self.head.block.load(Ordering::Acquire);\n+            }\n+        }\n+\n         unsafe {\n             // Drop all messages between head and tail and deallocate the heap-allocated blocks.\n             while head >> SHIFT != tail >> SHIFT {"}]}