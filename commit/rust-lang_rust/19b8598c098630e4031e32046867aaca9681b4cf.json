{"sha": "19b8598c098630e4031e32046867aaca9681b4cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5Yjg1OThjMDk4NjMwZTQwMzFlMzIwNDY4NjdhYWNhOTY4MWI0Y2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-18T00:55:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-18T00:56:47Z"}, "message": "rustc: Implement \"priv\" for simple items.\n\nInherited privacy doesn't work yet. This probably requires a snapshot since\nit won't be backwards compatible. Additionally, two errors are printed instead\nof one. For this reason the test is XFAIL'd.", "tree": {"sha": "41d2d679b1f83bef3d5f19aa0d21b76adef45e1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41d2d679b1f83bef3d5f19aa0d21b76adef45e1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19b8598c098630e4031e32046867aaca9681b4cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19b8598c098630e4031e32046867aaca9681b4cf", "html_url": "https://github.com/rust-lang/rust/commit/19b8598c098630e4031e32046867aaca9681b4cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19b8598c098630e4031e32046867aaca9681b4cf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcb055ef7e030c3cb057a375e3fd7dfc65777137", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcb055ef7e030c3cb057a375e3fd7dfc65777137", "html_url": "https://github.com/rust-lang/rust/commit/fcb055ef7e030c3cb057a375e3fd7dfc65777137"}], "stats": {"total": 197, "additions": 137, "deletions": 60}, "files": [{"sha": "bfd9f720380b7573dc576a3ff0795ee0060817b3", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 124, "deletions": 60, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/19b8598c098630e4031e32046867aaca9681b4cf/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b8598c098630e4031e32046867aaca9681b4cf/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=19b8598c098630e4031e32046867aaca9681b4cf", "patch": "@@ -26,21 +26,22 @@ import syntax::ast::{expr_binary, expr_break, expr_cast, expr_field, expr_fn};\n import syntax::ast::{expr_fn_block, expr_index, expr_loop};\n import syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n import syntax::ast::{foreign_item, foreign_item_fn, ge, gt, ident, trait_ref};\n-import syntax::ast::{impure_fn, item, item_class, item_const};\n+import syntax::ast::{impure_fn, inherited, item, item_class, item_const};\n import syntax::ast::{item_enum, item_fn, item_mac, item_foreign_mod};\n import syntax::ast::{item_impl, item_mod, item_trait, item_ty, le, local};\n import syntax::ast::{local_crate, lt, method, mul, ne, neg, node_id, pat};\n import syntax::ast::{pat_enum, pat_ident, path, prim_ty, pat_box, pat_uniq};\n import syntax::ast::{pat_lit, pat_range, pat_rec, pat_struct, pat_tup};\n-import syntax::ast::{pat_wild, provided, required, rem, self_ty_, shl};\n-import syntax::ast::{stmt_decl, struct_field, struct_variant_kind};\n+import syntax::ast::{pat_wild, private, provided, public, required, rem};\n+import syntax::ast::{self_ty_};\n+import syntax::ast::{shl, stmt_decl, struct_field, struct_variant_kind};\n import syntax::ast::{sty_static, subtract, tuple_variant_kind, ty};\n import syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n import syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param};\n import syntax::ast::{ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8};\n import syntax::ast::{ty_uint, variant, view_item, view_item_export};\n import syntax::ast::{view_item_import, view_item_use, view_path_glob};\n-import syntax::ast::{view_path_list, view_path_simple};\n+import syntax::ast::{view_path_list, view_path_simple, visibility};\n import syntax::ast_util::{def_id_of_def, dummy_sp, local_def, new_def_hash};\n import syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n import syntax::attr::{attr_metas, contains_name};\n@@ -475,14 +476,26 @@ fn unused_import_lint_level(session: session) -> level {\n     return allow;\n }\n \n+enum Privacy {\n+    Private,\n+    Public\n+}\n+\n+// Records a possibly-private definition.\n+struct Definition {\n+    privacy: Privacy;\n+    def: def;\n+}\n+\n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n struct NameBindings {\n-    let mut module_def: ModuleDef;      //< Meaning in the module namespace.\n-    let mut type_def: option<def>;      //< Meaning in the type namespace.\n-    let mut value_def: option<def>;     //< Meaning in the value namespace.\n+    let mut module_def: ModuleDef;         //< Meaning in module namespace.\n+    let mut type_def: option<Definition>;  //< Meaning in type namespace.\n+    let mut value_def: option<Definition>; //< Meaning in value namespace.\n \n     // For error reporting\n+    // XXX: Merge me into Definition.\n     let mut module_span: option<span>;\n     let mut type_span: option<span>;\n     let mut value_span: option<span>;\n@@ -507,14 +520,14 @@ struct NameBindings {\n     }\n \n     /// Records a type definition.\n-    fn define_type(def: def, sp: span) {\n-        self.type_def = some(def);\n+    fn define_type(privacy: Privacy, def: def, sp: span) {\n+        self.type_def = some(Definition { privacy: privacy, def: def });\n         self.type_span = some(sp);\n     }\n \n     /// Records a value definition.\n-    fn define_value(def: def, sp: span) {\n-        self.value_def = some(def);\n+    fn define_value(privacy: Privacy, def: def, sp: span) {\n+        self.value_def = some(Definition { privacy: privacy, def: def });\n         self.value_span = some(sp);\n     }\n \n@@ -550,16 +563,22 @@ struct NameBindings {\n         }\n     }\n \n-    fn def_for_namespace(namespace: Namespace) -> option<def> {\n+    fn def_for_namespace(namespace: Namespace) -> option<Definition> {\n         match namespace {\n           TypeNS => return self.type_def,\n           ValueNS => return self.value_def,\n           ModuleNS => match self.module_def {\n             NoModuleDef => return none,\n-            ModuleDef(module_) => match module_.def_id {\n-              none => return none,\n-              some(def_id) => return some(def_mod(def_id))\n-            }\n+            ModuleDef(module_) =>\n+                match module_.def_id {\n+                    none => return none,\n+                    some(def_id) => {\n+                        return some(Definition {\n+                            privacy: Public,\n+                            def: def_mod(def_id)\n+                        });\n+                    }\n+                }\n           }\n         }\n     }\n@@ -762,6 +781,13 @@ struct Resolver {\n         }));\n     }\n \n+    fn visibility_to_privacy(visibility: visibility) -> Privacy {\n+        match visibility {\n+            inherited | public => Public,\n+            privacy => Private\n+        }\n+    }\n+\n     /// Returns the current module tracked by the reduced graph parent.\n     fn get_module_from_parent(reduced_graph_parent: ReducedGraphParent)\n                            -> @Module {\n@@ -915,15 +941,18 @@ struct Resolver {\n               let (name_bindings, _) = self.add_child(atom, parent,\n                                                       ~[ValueNS], sp);\n \n-                (*name_bindings).define_value(def_const(local_def(item.id)),\n-                                              sp);\n+                (*name_bindings).define_value\n+                    (self.visibility_to_privacy(item.vis),\n+                     def_const(local_def(item.id)),\n+                     sp);\n             }\n             item_fn(decl, _, _) => {\n               let (name_bindings, new_parent) = self.add_child(atom, parent,\n                                                         ~[ValueNS], sp);\n \n                 let def = def_fn(local_def(item.id), decl.purity);\n-                (*name_bindings).define_value(def, sp);\n+                (*name_bindings).define_value\n+                    (self.visibility_to_privacy(item.vis), def, sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n@@ -932,15 +961,21 @@ struct Resolver {\n               let (name_bindings, _) = self.add_child(atom, parent,\n                                                       ~[TypeNS], sp);\n \n-                (*name_bindings).define_type(def_ty(local_def(item.id)), sp);\n+                (*name_bindings).define_type\n+                    (self.visibility_to_privacy(item.vis),\n+                     def_ty(local_def(item.id)),\n+                     sp);\n             }\n \n             item_enum(enum_definition, _) => {\n \n               let (name_bindings, new_parent) = self.add_child(atom, parent,\n                                                                ~[TypeNS], sp);\n \n-                (*name_bindings).define_type(def_ty(local_def(item.id)), sp);\n+                (*name_bindings).define_type\n+                    (self.visibility_to_privacy(item.vis),\n+                     def_ty(local_def(item.id)),\n+                     sp);\n \n                 for enum_definition.variants.each |variant| {\n                     self.build_reduced_graph_for_variant(variant,\n@@ -958,22 +993,26 @@ struct Resolver {\n                         let (name_bindings, new_parent) =\n                             self.add_child(atom, parent, ~[TypeNS], sp);\n \n-                        (*name_bindings).define_type(def_ty(\n-                            local_def(item.id)), sp);\n+                        (*name_bindings).define_type\n+                            (self.visibility_to_privacy(item.vis),\n+                             def_ty(local_def(item.id)),\n+                             sp);\n                         new_parent\n                     }\n                     some(ctor) => {\n                         let (name_bindings, new_parent) =\n                             self.add_child(atom, parent, ~[ValueNS, TypeNS],\n                                            sp);\n \n-                        (*name_bindings).define_type(def_ty(\n-                            local_def(item.id)), sp);\n+                        let privacy = self.visibility_to_privacy(item.vis);\n+\n+                        (*name_bindings).define_type\n+                            (privacy, def_ty(local_def(item.id)), sp);\n \n                         let purity = ctor.node.dec.purity;\n                         let ctor_def = def_fn(local_def(ctor.node.id),\n                                               purity);\n-                        (*name_bindings).define_value(ctor_def, sp);\n+                        (*name_bindings).define_value(privacy, ctor_def, sp);\n                         new_parent\n                     }\n                 };\n@@ -1009,7 +1048,8 @@ struct Resolver {\n                                            ty_m.span);\n                         let def = def_static_method(local_def(ty_m.id),\n                                                     ty_m.decl.purity);\n-                        (*method_name_bindings).define_value(def, ty_m.span);\n+                        (*method_name_bindings).define_value\n+                            (Public, def, ty_m.span);\n                       }\n                       _ => {\n                         (*method_names).insert(atom, ());\n@@ -1020,7 +1060,10 @@ struct Resolver {\n                 let def_id = local_def(item.id);\n                 self.trait_info.insert(def_id, method_names);\n \n-                (*name_bindings).define_type(def_ty(def_id), sp);\n+                (*name_bindings).define_type\n+                    (self.visibility_to_privacy(item.vis),\n+                     def_ty(def_id),\n+                     sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n@@ -1043,18 +1086,21 @@ struct Resolver {\n \n         match variant.node.kind {\n             tuple_variant_kind(_) => {\n-                (*child).define_value(def_variant(item_id,\n+                (*child).define_value(Public,\n+                                      def_variant(item_id,\n                                                   local_def(variant.node.id)),\n                                       variant.span);\n             }\n             struct_variant_kind(_) => {\n-                (*child).define_type(def_variant(item_id,\n+                (*child).define_type(Public,\n+                                     def_variant(item_id,\n                                                  local_def(variant.node.id)),\n                                      variant.span);\n                 self.structs.insert(local_def(variant.node.id), false);\n             }\n             enum_variant_kind(enum_definition) => {\n-                (*child).define_type(def_ty(local_def(variant.node.id)),\n+                (*child).define_type(Public,\n+                                     def_ty(local_def(variant.node.id)),\n                                      variant.span);\n                 for enum_definition.variants.each |variant| {\n                     self.build_reduced_graph_for_variant(variant, item_id,\n@@ -1240,7 +1286,7 @@ struct Resolver {\n                                               ~[ValueNS], foreign_item.span);\n \n                 let def = def_fn(local_def(foreign_item.id), fn_decl.purity);\n-                (*name_bindings).define_value(def, foreign_item.span);\n+                (*name_bindings).define_value(Public, def, foreign_item.span);\n \n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters,\n@@ -1342,7 +1388,7 @@ struct Resolver {\n           def_const(def_id) | def_variant(_, def_id) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value %s\", final_ident);\n-            (*child_name_bindings).define_value(def, dummy_sp());\n+            (*child_name_bindings).define_value(Public, def, dummy_sp());\n           }\n           def_ty(def_id) => {\n             debug!(\"(building reduced graph for external \\\n@@ -1375,17 +1421,17 @@ struct Resolver {\n               }\n             }\n \n-            child_name_bindings.define_type(def, dummy_sp());\n+            child_name_bindings.define_type(Public, def, dummy_sp());\n           }\n           def_class(def_id, has_constructor) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building type %s (value? %d)\",\n                    final_ident,\n                    if has_constructor { 1 } else { 0 });\n-            child_name_bindings.define_type(def, dummy_sp());\n+            child_name_bindings.define_type(Public, def, dummy_sp());\n \n             if has_constructor {\n-                child_name_bindings.define_value(def, dummy_sp());\n+                child_name_bindings.define_value(Public, def, dummy_sp());\n             }\n \n             self.structs.insert(def_id, has_constructor);\n@@ -3751,14 +3797,18 @@ struct Resolver {\n                         fail ~\"resolved name in the value namespace to a set \\\n                               of name bindings with no def?!\";\n                     }\n-                    some(def @ def_variant(*)) => {\n-                        return FoundEnumVariant(def);\n-                    }\n-                    some(def_const(*)) => {\n-                        return FoundConst;\n-                    }\n-                    some(_) => {\n-                        return EnumVariantOrConstNotFound;\n+                    some(def) => {\n+                        match def.def {\n+                            def @ def_variant(*) => {\n+                                return FoundEnumVariant(def);\n+                            }\n+                            def_const(*) => {\n+                                return FoundConst;\n+                            }\n+                            _ => {\n+                                return EnumVariantOrConstNotFound;\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -3845,11 +3895,11 @@ struct Resolver {\n         match containing_module.children.find(name) {\n             some(child_name_bindings) => {\n                 match (*child_name_bindings).def_for_namespace(namespace) {\n-                    some(def) => {\n+                    some(def) if def.privacy == Public => {\n                         // Found it. Stop the search here.\n-                        return ChildNameDefinition(def);\n+                        return ChildNameDefinition(def.def);\n                     }\n-                    none => {\n+                    some(_) | none => {\n                         // Continue.\n                     }\n                 }\n@@ -3866,12 +3916,12 @@ struct Resolver {\n                     some(target) => {\n                         match (*target.bindings)\n                             .def_for_namespace(namespace) {\n-                            some(def) => {\n+                            some(def) if def.privacy == Public => {\n                                 // Found it.\n                                 import_resolution.used = true;\n-                                return ImportNameDefinition(def);\n+                                return ImportNameDefinition(def.def);\n                             }\n-                            none => {\n+                            some(_) | none => {\n                                 // This can happen with external impls, due to\n                                 // the imperfect way we read the metadata.\n \n@@ -4066,7 +4116,7 @@ struct Resolver {\n                         debug!{\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n                                *(*self.atom_table).atom_to_str(name)};\n-                        return some(def);\n+                        return some(def.def);\n                     }\n                 }\n             }\n@@ -4277,12 +4327,18 @@ struct Resolver {\n             // Look for trait children.\n             for search_module.children.each |_name, child_name_bindings| {\n                 match child_name_bindings.def_for_namespace(TypeNS) {\n-                    some(def_ty(trait_def_id)) => {\n-                        self.add_trait_info_if_containing_method(found_traits,\n-                                                                 trait_def_id,\n-                                                                 name);\n+                    some(def) => {\n+                        match def.def {\n+                            def_ty(trait_def_id) => {\n+                                self.add_trait_info_if_containing_method\n+                                    (found_traits, trait_def_id, name);\n+                            }\n+                            _ => {\n+                                // Continue.\n+                            }\n+                        }\n                     }\n-                    some(_) | none => {\n+                    none => {\n                         // Continue.\n                     }\n                 }\n@@ -4298,11 +4354,19 @@ struct Resolver {\n                     }\n                     some(target) => {\n                         match target.bindings.def_for_namespace(TypeNS) {\n-                            some(def_ty(trait_def_id)) => {\n-                                self.add_trait_info_if_containing_method\n-                                    (found_traits, trait_def_id, name);\n+                            some(def) => {\n+                                match def.def {\n+                                    def_ty(trait_def_id) => {\n+                                        self.\n+                                        add_trait_info_if_containing_method\n+                                        (found_traits, trait_def_id, name);\n+                                    }\n+                                    _ => {\n+                                        // Continue.\n+                                    }\n+                                }\n                             }\n-                            some(_) | none => {\n+                            none => {\n                                 // Continue.\n                             }\n                         }"}, {"sha": "843c7f4aaa2a30922ca297a27854b3bdc7b0681c", "filename": "src/test/compile-fail/private-item-simple.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19b8598c098630e4031e32046867aaca9681b4cf/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b8598c098630e4031e32046867aaca9681b4cf/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-item-simple.rs?ref=19b8598c098630e4031e32046867aaca9681b4cf", "patch": "@@ -0,0 +1,13 @@\n+// xfail-test\n+// xfail-fast\n+\n+// This is xfail'd because two errors are reported instead of one.\n+\n+mod a {\n+    priv fn f() {}\n+}\n+\n+fn main() {\n+    a::f(); //~ ERROR unresolved name\n+}\n+"}]}