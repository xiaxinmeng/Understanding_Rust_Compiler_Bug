{"sha": "f1ca9969bfb1a69e98dab6ff0413e099532f57f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxY2E5OTY5YmZiMWE2OWU5OGRhYjZmZjA0MTNlMDk5NTMyZjU3ZjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-08T20:50:01Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-18T14:08:25Z"}, "message": "parse: module parsing -> item.rs", "tree": {"sha": "d491a4a1e13431b20b7210f881ed2c14e3072e1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d491a4a1e13431b20b7210f881ed2c14e3072e1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1ca9969bfb1a69e98dab6ff0413e099532f57f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ca9969bfb1a69e98dab6ff0413e099532f57f2", "html_url": "https://github.com/rust-lang/rust/commit/f1ca9969bfb1a69e98dab6ff0413e099532f57f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1ca9969bfb1a69e98dab6ff0413e099532f57f2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83a757a9ca0d0f61bd2325e9a95d591d53e01129", "url": "https://api.github.com/repos/rust-lang/rust/commits/83a757a9ca0d0f61bd2325e9a95d591d53e01129", "html_url": "https://github.com/rust-lang/rust/commit/83a757a9ca0d0f61bd2325e9a95d591d53e01129"}], "stats": {"total": 131, "additions": 66, "deletions": 65}, "files": [{"sha": "d0da8e6c7c11e4ac33b8246b4fe6b6a33c3d46c2", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f1ca9969bfb1a69e98dab6ff0413e099532f57f2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ca9969bfb1a69e98dab6ff0413e099532f57f2/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=f1ca9969bfb1a69e98dab6ff0413e099532f57f2", "patch": "@@ -4,14 +4,18 @@ use super::{FollowedByType, Parser, PathStyle};\n \n use crate::maybe_whole;\n \n-use rustc_ast::ast::{self, Async, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n-use rustc_ast::ast::{AssocItem, AssocItemKind, ForeignItemKind, Item, ItemKind};\n-use rustc_ast::ast::{BindingMode, Block, FnDecl, FnSig, MacArgs, MacCall, MacDelimiter, Param};\n-use rustc_ast::ast::{Const, Defaultness, IsAuto, PathSegment, Unsafe, UseTree, UseTreeKind};\n+use rustc_ast::ast::{self, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n+use rustc_ast::ast::{AssocItem, AssocItemKind, ForeignItemKind, Item, ItemKind, Mod};\n+use rustc_ast::ast::{\n+    Async, Const, Defaultness, IsAuto, PathSegment, Unsafe, UseTree, UseTreeKind,\n+};\n+use rustc_ast::ast::{\n+    BindingMode, Block, FnDecl, FnSig, MacArgs, MacCall, MacDelimiter, Param, SelfKind,\n+};\n use rustc_ast::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n use rustc_ast::ast::{FnHeader, ForeignItem, Mutability, SelfKind, Visibility, VisibilityKind};\n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n+use rustc_ast::token::{self, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, PResult, StashKey};\n@@ -23,6 +27,61 @@ use log::debug;\n use std::convert::TryFrom;\n use std::mem;\n \n+impl<'a> Parser<'a> {\n+    /// Parses a source module as a crate. This is the main entry point for the parser.\n+    pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {\n+        let lo = self.token.span;\n+        let (module, attrs) = self.parse_mod(&token::Eof)?;\n+        let span = lo.to(self.token.span);\n+        let proc_macros = Vec::new(); // Filled in by `proc_macro_harness::inject()`.\n+        Ok(ast::Crate { attrs, module, span, proc_macros })\n+    }\n+\n+    /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n+    pub(super) fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+        let id = self.parse_ident()?;\n+        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n+            Default::default()\n+        } else {\n+            self.expect(&token::OpenDelim(token::Brace))?;\n+            self.parse_mod(&token::CloseDelim(token::Brace))?\n+        };\n+        attrs.append(&mut inner_attrs);\n+        Ok((id, ItemKind::Mod(module)))\n+    }\n+\n+    /// Parses the contents of a module (inner attributes followed by module items).\n+    pub fn parse_mod(&mut self, term: &TokenKind) -> PResult<'a, (Mod, Vec<Attribute>)> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_inner_attributes()?;\n+        let module = self.parse_mod_items(term, lo)?;\n+        Ok((module, attrs))\n+    }\n+\n+    /// Given a termination token, parses all of the items in a module.\n+    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n+        let mut items = vec![];\n+        while let Some(item) = self.parse_item()? {\n+            items.push(item);\n+            self.maybe_consume_incorrect_semicolon(&items);\n+        }\n+\n+        if !self.eat(term) {\n+            let token_str = super::token_descr(&self.token);\n+            if !self.maybe_consume_incorrect_semicolon(&items) {\n+                let msg = &format!(\"expected item, found {}\", token_str);\n+                let mut err = self.struct_span_err(self.token.span, msg);\n+                err.span_label(self.token.span, \"expected item\");\n+                return Err(err);\n+            }\n+        }\n+\n+        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n+\n+        Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n+    }\n+}\n+\n pub(super) type ItemInfo = (Ident, ItemKind);\n \n impl<'a> Parser<'a> {"}, {"sha": "2c752bd9f0af707bc2856d3181c67b0dec30308e", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f1ca9969bfb1a69e98dab6ff0413e099532f57f2/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ca9969bfb1a69e98dab6ff0413e099532f57f2/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=f1ca9969bfb1a69e98dab6ff0413e099532f57f2", "patch": "@@ -1,11 +1,8 @@\n-use super::item::ItemInfo;\n-use super::Parser;\n-\n use crate::{new_sub_parser_from_file, Directory, DirectoryOwnership};\n \n-use rustc_ast::ast::{self, Attribute, Crate, Ident, ItemKind, Mod};\n+use rustc_ast::ast::{self, Attribute, Ident, Mod};\n use rustc_ast::attr;\n-use rustc_ast::token::{self, TokenKind};\n+use rustc_ast::token;\n use rustc_errors::{struct_span_err, PResult};\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FileName, Span};\n@@ -27,61 +24,6 @@ pub struct ModulePathSuccess {\n     pub ownership: DirectoryOwnership,\n }\n \n-impl<'a> Parser<'a> {\n-    /// Parses a source module as a crate. This is the main entry point for the parser.\n-    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n-        let lo = self.token.span;\n-        let (module, attrs) = self.parse_mod(&token::Eof)?;\n-        let span = lo.to(self.token.span);\n-        let proc_macros = Vec::new(); // Filled in by `proc_macro_harness::inject()`.\n-        Ok(ast::Crate { attrs, module, span, proc_macros })\n-    }\n-\n-    /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n-    pub(super) fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n-        let id = self.parse_ident()?;\n-        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n-            Default::default()\n-        } else {\n-            self.expect(&token::OpenDelim(token::Brace))?;\n-            self.parse_mod(&token::CloseDelim(token::Brace))?\n-        };\n-        attrs.append(&mut inner_attrs);\n-        Ok((id, ItemKind::Mod(module)))\n-    }\n-\n-    /// Parses the contents of a module (inner attributes followed by module items).\n-    fn parse_mod(&mut self, term: &TokenKind) -> PResult<'a, (Mod, Vec<Attribute>)> {\n-        let lo = self.token.span;\n-        let attrs = self.parse_inner_attributes()?;\n-        let module = self.parse_mod_items(term, lo)?;\n-        Ok((module, attrs))\n-    }\n-\n-    /// Given a termination token, parses all of the items in a module.\n-    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n-        let mut items = vec![];\n-        while let Some(item) = self.parse_item()? {\n-            items.push(item);\n-            self.maybe_consume_incorrect_semicolon(&items);\n-        }\n-\n-        if !self.eat(term) {\n-            let token_str = super::token_descr(&self.token);\n-            if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let msg = &format!(\"expected item, found {}\", token_str);\n-                let mut err = self.struct_span_err(self.token.span, msg);\n-                err.span_label(self.token.span, \"expected item\");\n-                return Err(err);\n-            }\n-        }\n-\n-        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n-\n-        Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n-    }\n-}\n-\n pub fn parse_external_mod(\n     sess: &ParseSess,\n     id: ast::Ident,"}]}