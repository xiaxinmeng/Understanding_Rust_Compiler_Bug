{"sha": "96b178b131c63b38aa760381a4a0359fd8a17ed1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YjE3OGIxMzFjNjNiMzhhYTc2MDM4MWE0YTAzNTlmZDhhMTdlZDE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-05-12T22:20:59Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-05-12T22:20:59Z"}, "message": "Some simple improvements to MIR pretty printing\n\nIn short, this PR changes the MIR printer so that it:\n\n* places an empty line between the MIR for each item\n* does *not* write an empty line before the first BB when there are no\n  var decls\n* aligns the \"// Scope\" comments 50 chars in (makes the output more\n  readable)\n* prints the scope comments as \"// scope N at ...\" instead of \"//\n  Scope(N) at ...\"\n* prints a prettier scope tree:\n * no more unbalanced delimiters!\n * no more \"Parent\" entry (these convey no useful information)\n * drop the \"Scope()\" and just print scope IDs\n * no braces when the scope is empty", "tree": {"sha": "b9685e58ef6bbfba5547e828d13b3df344aad20c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9685e58ef6bbfba5547e828d13b3df344aad20c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96b178b131c63b38aa760381a4a0359fd8a17ed1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96b178b131c63b38aa760381a4a0359fd8a17ed1", "html_url": "https://github.com/rust-lang/rust/commit/96b178b131c63b38aa760381a4a0359fd8a17ed1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96b178b131c63b38aa760381a4a0359fd8a17ed1/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e88defe71806ad190588e168e513bc1098f7c9fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88defe71806ad190588e168e513bc1098f7c9fb", "html_url": "https://github.com/rust-lang/rust/commit/e88defe71806ad190588e168e513bc1098f7c9fb"}], "stats": {"total": 77, "additions": 55, "deletions": 22}, "files": [{"sha": "46f433ff4c6682c166ea07358d3b0f175c7359f4", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/96b178b131c63b38aa760381a4a0359fd8a17ed1/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96b178b131c63b38aa760381a4a0359fd8a17ed1/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=96b178b131c63b38aa760381a4a0359fd8a17ed1", "patch": "@@ -21,6 +21,8 @@ use syntax::ast::NodeId;\n use syntax::codemap::Span;\n \n const INDENT: &'static str = \"    \";\n+/// Alignment for lining up comments following MIR statements\n+const ALIGN: usize = 50;\n \n /// If the session is properly configured, dumps a human-readable\n /// representation of the mir into:\n@@ -79,11 +81,20 @@ pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                          -> io::Result<()>\n     where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n {\n+    let mut first = true;\n     for (&id, mir) in iter {\n+        if first {\n+            first = false;\n+        } else {\n+            // Put empty lines between all items\n+            writeln!(w, \"\")?;\n+        }\n+\n         let src = MirSource::from_node(tcx, id);\n         write_mir_fn(tcx, src, mir, w, None)?;\n \n         for (i, mir) in mir.promoted.iter().enumerate() {\n+            writeln!(w, \"\")?;\n             write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w, None)?;\n         }\n     }\n@@ -131,6 +142,8 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   .or_insert(vec![])\n                   .push(ScopeId::new(index));\n     }\n+\n+    writeln!(w, \"{}scope tree:\", INDENT)?;\n     write_scope_tree(tcx, mir, auxiliary, &scope_tree, w, None, 1)?;\n \n     writeln!(w, \"}}\")?;\n@@ -147,7 +160,7 @@ fn write_basic_block(tcx: TyCtxt,\n     let data = mir.basic_block_data(block);\n \n     // Basic block label at the top.\n-    writeln!(w, \"\\n{}{:?}: {{\", INDENT, block)?;\n+    writeln!(w, \"{}{:?}: {{\", INDENT, block)?;\n \n     // List of statements in the middle.\n     let mut current_location = Location { block: block, statement_index: 0 };\n@@ -165,25 +178,27 @@ fn write_basic_block(tcx: TyCtxt,\n             }\n         }\n \n-        writeln!(w, \"{0}{0}{1:?}; // {2}\",\n-                 INDENT,\n-                 statement,\n+        let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n+        writeln!(w, \"{0:1$} // {2}\",\n+                 indented_mir,\n+                 ALIGN,\n                  comment(tcx, statement.scope, statement.span))?;\n \n         current_location.statement_index += 1;\n     }\n \n     // Terminator at the bottom.\n-    writeln!(w, \"{0}{0}{1:?}; // {2}\",\n-             INDENT,\n-             data.terminator().kind,\n+    let indented_terminator = format!(\"{0}{0}{1:?};\", INDENT, data.terminator().kind);\n+    writeln!(w, \"{0:1$} // {2}\",\n+             indented_terminator,\n+             ALIGN,\n              comment(tcx, data.terminator().scope, data.terminator().span))?;\n \n-    writeln!(w, \"{}}}\", INDENT)\n+    writeln!(w, \"{}}}\\n\", INDENT)\n }\n \n fn comment(tcx: TyCtxt, scope: ScopeId, span: Span) -> String {\n-    format!(\"Scope({}) at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n+    format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n fn write_scope_tree(tcx: TyCtxt,\n@@ -198,22 +213,28 @@ fn write_scope_tree(tcx: TyCtxt,\n         let indent = depth * INDENT.len();\n         let data = &mir.scopes[child];\n         assert_eq!(data.parent_scope, parent);\n-        writeln!(w, \"{0:1$}Scope({2}) {{\", \"\", indent, child.index())?;\n+        write!(w, \"{0:1$}{2}\", \"\", indent, child.index())?;\n \n         let indent = indent + INDENT.len();\n-        if let Some(parent) = parent {\n-            writeln!(w, \"{0:1$}Parent: Scope({2})\", \"\", indent, parent.index())?;\n-        }\n \n         if let Some(auxiliary) = auxiliary {\n             let extent = auxiliary[child].extent;\n             let data = tcx.region_maps.code_extent_data(extent);\n             writeln!(w, \"{0:1$}Extent: {2:?}\", \"\", indent, data)?;\n         }\n \n-        write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n-                         Some(child), depth + 1)?;\n+        if scope_tree.get(&Some(child)).map(Vec::is_empty).unwrap_or(true) {\n+            // No child scopes, skip the braces\n+            writeln!(w, \"\")?;\n+        } else {\n+            writeln!(w, \" {{\")?;\n+            write_scope_tree(tcx, mir, auxiliary, scope_tree, w,\n+                             Some(child), depth + 1)?;\n+\n+            writeln!(w, \"{0:1$}}}\", \"\", indent - INDENT.len())?;\n+        }\n     }\n+\n     Ok(())\n }\n \n@@ -261,13 +282,20 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // User variable types (including the user's name in a comment).\n     for (i, var) in mir.var_decls.iter().enumerate() {\n-        write!(w, \"{}let \", INDENT)?;\n-        if var.mutability == Mutability::Mut {\n-            write!(w, \"mut \")?;\n-        }\n-        writeln!(w, \"{:?}: {}; // {} in {}\",\n-                 Lvalue::Var(i as u32),\n-                 var.ty,\n+        let mut_str = if var.mutability == Mutability::Mut {\n+            \"mut \"\n+        } else {\n+            \"\"\n+        };\n+\n+        let indented_var = format!(\"{}let {}{:?}: {};\",\n+                                   INDENT,\n+                                   mut_str,\n+                                   Lvalue::Var(i as u32),\n+                                   var.ty);\n+        writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n+                 indented_var,\n+                 ALIGN,\n                  var.name,\n                  comment(tcx, var.scope, var.span))?;\n     }\n@@ -277,5 +305,10 @@ fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty)?;\n     }\n \n+    // Wrote any declaration? Add an empty line before the first block is printed.\n+    if !mir.var_decls.is_empty() || !mir.temp_decls.is_empty() {\n+        writeln!(w, \"\")?;\n+    }\n+\n     Ok(())\n }"}]}