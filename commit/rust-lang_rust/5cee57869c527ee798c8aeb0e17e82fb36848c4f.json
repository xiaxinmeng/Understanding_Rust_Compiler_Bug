{"sha": "5cee57869c527ee798c8aeb0e17e82fb36848c4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZWU1Nzg2OWM1MjdlZTc5OGM4YWViMGUxN2U4MmZiMzY4NDhjNGY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-07T07:13:49Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-07-11T15:32:23Z"}, "message": "Removed dead structures after changes to PartialOrd/Ord derivings.\n\nRemove the `NonMatchesExplode` variant now that no deriving impl uses it.\nRemoved `EnumNonMatching` entirely.\nRemove now irrelevant `on_matching` field and `HandleNonMatchingEnums` type.\nRemoved unused `EnumNonMatchFunc` type def.\n\nDrive-by: revise `EnumNonMatchCollapsedFunc` doc.\n\nMade all calls to `expand_enum_method_body` go directly to\n`build_enum_match_tuple`.\n\nAlpha-rename `enum_nonmatch_g` back to `enum_nonmatch_f` to reduce overall diff noise.\nInline sole call of `some_ordering_const`.\nInline sole call of `ordering_const`.\n\nRemoved a bunch of code that became dead after the above changes.", "tree": {"sha": "c4dc23e67ff6cd75b9d852ed645b50fb51b4d34b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4dc23e67ff6cd75b9d852ed645b50fb51b4d34b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cee57869c527ee798c8aeb0e17e82fb36848c4f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cee57869c527ee798c8aeb0e17e82fb36848c4f", "html_url": "https://github.com/rust-lang/rust/commit/5cee57869c527ee798c8aeb0e17e82fb36848c4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cee57869c527ee798c8aeb0e17e82fb36848c4f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8ae44682d76bb40eb1471eeb42603eaecd0b392", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ae44682d76bb40eb1471eeb42603eaecd0b392", "html_url": "https://github.com/rust-lang/rust/commit/c8ae44682d76bb40eb1471eeb42603eaecd0b392"}], "stats": {"total": 381, "additions": 29, "deletions": 352}, "files": [{"sha": "bbe96018f4b3ddbd080bee76e71ffc5eaddd0b74", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -39,7 +39,6 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Self,\n                 attributes: attrs,\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|c, s, sub| {\n                     cs_clone(\"Clone\", c, s, sub)\n                 }),\n@@ -69,7 +68,7 @@ fn cs_clone(\n             ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n-        EnumNonMatching(..) | EnumNonMatchingCollapsed (..) => {\n+        EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n                         format!(\"non-matching enum variants in \\\n                                  `deriving({})`\","}, {"sha": "19a979a5655ba060912d52838fa8b6faabc1701e", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -27,12 +27,10 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n-               |cx, span, _, _| cx.expr_bool(span, false),\n-               cx, span, substr)\n+                                 cx, span, substr)\n     }\n     fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> Gc<Expr> {\n         cs_or(|cx, span, _, _| cx.expr_bool(span, true),\n-              |cx, span, _, _| cx.expr_bool(span, true),\n               cx, span, substr)\n     }\n \n@@ -47,7 +45,6 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchesCollapse,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     $f(a, b, c)\n                 })"}, {"sha": "dcf59ba820e4cc39c0a81dd85844e00890fed6de", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -35,7 +35,6 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchesCollapseWithTags,\n                 combine_substructure: combine_substructure(|cx, span, substr| {\n                     cs_op($op, $equal, cx, span, substr)\n                 })\n@@ -59,7 +58,6 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n         args: vec![borrowed_self()],\n         ret_ty: ret_ty,\n         attributes: attrs,\n-        on_nonmatching: NonMatchesCollapseWithTags,\n         combine_substructure: combine_substructure(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n         })\n@@ -82,20 +80,6 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn some_ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> Gc<ast::Expr> {\n-    let cnst = match cnst {\n-        Less => \"Less\",\n-        Equal => \"Equal\",\n-        Greater => \"Greater\"\n-    };\n-    let ordering = cx.path_global(span,\n-                                  vec!(cx.ident_of(\"std\"),\n-                                       cx.ident_of(\"cmp\"),\n-                                       cx.ident_of(cnst)));\n-    let ordering = cx.expr_path(ordering);\n-    cx.expr_some(span, ordering)\n-}\n-\n pub enum OrderingOp {\n     PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n }\n@@ -117,7 +101,12 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n-    let equals_expr = some_ordering_const(cx, span, Equal);\n+    let ordering = cx.path_global(span,\n+                                  vec!(cx.ident_of(\"std\"),\n+                                       cx.ident_of(\"cmp\"),\n+                                       cx.ident_of(\"Equal\")));\n+    let ordering = cx.expr_path(ordering);\n+    let equals_expr = cx.expr_some(span, ordering);\n \n     /*\n     Builds:\n@@ -159,15 +148,6 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n             cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n         equals_expr.clone(),\n-        |cx, span, list, _| {\n-            match list {\n-                // an earlier nonmatching variant is Less than a\n-                // later one.\n-                [(self_var, _, _), (other_var, _, _)] =>\n-                     some_ordering_const(cx, span, self_var.cmp(&other_var)),\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\"),\n-            }\n-        },\n         |cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n@@ -216,21 +196,6 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n             cx.expr_binary(span, ast::BiOr, cmp, and)\n         },\n         cx.expr_bool(span, equal),\n-        |cx, span, args, _| {\n-            // nonmatching enums, order by the order the variants are\n-            // written\n-            match args {\n-                [(self_var, _, _),\n-                 (other_var, _, _)] =>\n-                    cx.expr_bool(span,\n-                                 if less {\n-                                     self_var < other_var\n-                                 } else {\n-                                     self_var > other_var\n-                                 }),\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n-            }\n-        },\n         |cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")"}, {"sha": "42365936c9d4f5e56507ef736b2ea6bb8d8ff5bc", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -32,7 +32,6 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n             let block = cx.block(span, stmts, None);\n             cx.expr_block(block)\n         },\n-                       |cx, sp, _, _| cx.span_bug(sp, \"non matching enums in deriving(Eq)?\"),\n                        |cx, sp, _, _| cx.span_bug(sp, \"non matching enums in deriving(Eq)?\"),\n                        cx,\n                        span,\n@@ -58,7 +57,6 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                 args: vec!(),\n                 ret_ty: nil_ty(),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchesCollapse,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     cs_total_eq_assert(a, b, c)\n                 })"}, {"sha": "e010b635fe41a666244d7c82fd45458fceefdcea", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -17,7 +17,6 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n-use std::cmp::{Ordering, Equal, Less, Greater};\n use std::gc::Gc;\n \n pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n@@ -41,7 +40,6 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"cmp\", \"Ordering\"))),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchesCollapseWithTags,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     cs_cmp(a, b, c)\n                 }),\n@@ -53,18 +51,6 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n }\n \n \n-pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n-    let cnst = match cnst {\n-        Less => \"Less\",\n-        Equal => \"Equal\",\n-        Greater => \"Greater\"\n-    };\n-    cx.path_global(span,\n-                   vec!(cx.ident_of(\"std\"),\n-                     cx.ident_of(\"cmp\"),\n-                     cx.ident_of(cnst)))\n-}\n-\n pub fn ordering_collapsed(cx: &mut ExtCtxt,\n                           span: Span,\n                           self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n@@ -76,7 +62,10 @@ pub fn ordering_collapsed(cx: &mut ExtCtxt,\n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n-    let equals_path = ordering_const(cx, span, Equal);\n+    let equals_path = cx.path_global(span,\n+                                     vec!(cx.ident_of(\"std\"),\n+                                          cx.ident_of(\"cmp\"),\n+                                          cx.ident_of(\"Equal\")));\n \n     /*\n     Builds:\n@@ -118,18 +107,6 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n             cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n         cx.expr_path(equals_path.clone()),\n-        |cx, span, list, _| {\n-            match list {\n-                // an earlier nonmatching variant is Less than a\n-                // later one.\n-                [(self_var, _, _),\n-                 (other_var, _, _)] => {\n-                    let order = ordering_const(cx, span, self_var.cmp(&other_var));\n-                    cx.expr_path(order)\n-                }\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n-            }\n-        },\n         |cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `deriving(TotalOrd)`\")"}, {"sha": "d909ffd2b49fb56aa24361e419641ab1113b5642", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -54,7 +54,6 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                           vec!(box Self,\n                                                box Literal(Path::new_local(\"__E\"))), true)),\n                 attributes: Vec::new(),\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     decodable_substructure(a, b, c)\n                 }),"}, {"sha": "f7d0308e1bd21d52cd1b1a401d878c8d9b22e142", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -39,7 +39,6 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Self,\n                 attributes: attrs,\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     default_substructure(a, b, c)\n                 })"}, {"sha": "7e289e7676aa92c908353371364c142bf173de71", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -121,7 +121,6 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                                 box Literal(Path::new_local(\"__E\"))),\n                                            true)),\n                 attributes: Vec::new(),\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     encodable_substructure(a, b, c)\n                 }),"}, {"sha": "7d454016d602d3f118adec1126dfba0e1e7e85cc", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 16, "deletions": 259, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -37,18 +37,19 @@\n //!   `struct T(int, char)`).\n //! - `EnumMatching`, when `Self` is an enum and all the arguments are the\n //!   same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`)\n-//! - `EnumNonMatching` when `Self` is an enum and the arguments are not\n-//!   the same variant (e.g. `None`, `Some(1)` and `None`). If\n-//!   `on_nonmatching == NonMatchesCollapse`, this will contain an empty list.\n+//! - `EnumNonMatchingCollapsed` when `Self` is an enum and the arguments\n+//!   are not the same variant (e.g. `None`, `Some(1)` and `None`).\n //! - `StaticEnum` and `StaticStruct` for static methods, where the type\n //!   being derived upon is either an enum or struct respectively. (Any\n //!   argument with type Self is just grouped among the non-self\n //!   arguments.)\n //!\n //! In the first two cases, the values from the corresponding fields in\n-//! all the arguments are grouped together. In the `EnumNonMatching` case\n+//! all the arguments are grouped together. For `EnumNonMatchingCollapsed`\n //! this isn't possible (different variants have different fields), so the\n-//! fields are grouped by which argument they come from. There are no\n+//! fields are inaccessible. (Previous versions of the deriving infrastructure\n+//! had a way to expand into code that could access them, at the cost of\n+//! generating exponential amounts of code; see issue #15375). There are no\n //! fields with values in the static cases, so these are treated entirely\n //! differently.\n //!\n@@ -218,21 +219,6 @@ pub struct TraitDef<'a> {\n     pub methods: Vec<MethodDef<'a>>,\n }\n \n-#[deriving(PartialEq, Eq)]\n-pub enum HandleNonMatchingEnums {\n-    /// handle all non-matches via one `_ => ..` clause\n-    NonMatchesCollapse,\n-\n-    /// handle all non-matches via one `_ => ..` clause that has\n-    /// access to a tuple of tags indicating each variant index.\n-    NonMatchesCollapseWithTags,\n-\n-    /// handle via n^k cases for n variants and k self-args\n-    NonMatchesExplode,\n-\n-    /// cannot encounter two enums of Self type\n-    NonMatchHandlingIrrelevant,\n-}\n \n pub struct MethodDef<'a> {\n     /// name of the method\n@@ -253,18 +239,6 @@ pub struct MethodDef<'a> {\n \n     pub attributes: Vec<ast::Attribute>,\n \n-    /// How to handle nonmatching enums; `NonMatchesCollapse`\n-    /// indicates value is independent of the actual enum variants,\n-    /// i.e. can use _ => .. match.\n-    ///\n-    /// Note that if this is `NonMatchesExplode`, then deriving will\n-    /// generate `Omega(n^k)` code, where `n` is the number of\n-    /// variants and `k` is the number of arguments of `Self` type for\n-    /// the method (including the `self` argument, if any).  Strive to\n-    /// avoid use of `NonMatchesExplode`, to avoid generating\n-    /// quadratic amounts of code (#15375) or worse.\n-    pub on_nonmatching: HandleNonMatchingEnums,\n-\n     pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n }\n \n@@ -314,14 +288,6 @@ pub enum SubstructureFields<'a> {\n     */\n     EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n \n-    /**\n-    non-matching variants of the enum, [(variant index, ast::Variant,\n-    [field span, field ident, fields])] \\(i.e. all fields for self are in the\n-    first tuple, for other1 are in the second tuple, etc.)\n-    */\n-    EnumNonMatching(&'a [(uint, P<ast::Variant>,\n-                          Vec<(Span, Option<Ident>, Gc<Expr>)>)]),\n-\n     /**\n     non-matching variants of the enum, but with all state hidden from\n     the consequent code.  The first component holds Idents for all of\n@@ -839,204 +805,11 @@ impl<'a> MethodDef<'a> {\n                                self_args: &[Gc<Expr>],\n                                nonself_args: &[Gc<Expr>])\n                                -> Gc<Expr> {\n-        let mut matches = Vec::new();\n-        match self.on_nonmatching {\n-            NonMatchesCollapseWithTags =>\n-                self.build_enum_match_tuple(\n-                    cx, trait_, enum_def, type_ident, self_args, nonself_args),\n-            NonMatchesCollapse | NonMatchesExplode | NonMatchHandlingIrrelevant =>\n-                self.build_enum_match(\n-                    cx, trait_, enum_def, type_ident, self_args, nonself_args,\n-                    None, &mut matches, 0),\n-        }\n+        self.build_enum_match_tuple(\n+            cx, trait_, enum_def, type_ident, self_args, nonself_args)\n     }\n \n \n-    /**\n-    Creates the nested matches for an enum definition recursively, i.e.\n-\n-   ~~~text\n-    match self {\n-       Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n-       Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n-       ...\n-    }\n-   ~~~\n-\n-    It acts in the most naive way, so every branch (and subbranch,\n-    subsubbranch, etc) exists, not just the ones where all the variants in\n-    the tree are the same. Hopefully the optimisers get rid of any\n-    repetition, otherwise derived methods with many Self arguments will be\n-    exponentially large.\n-\n-    `matching` is Some(n) if all branches in the tree above the\n-    current position are variant `n`, `None` otherwise (including on\n-    the first call).\n-    */\n-    fn build_enum_match(&self,\n-                        cx: &mut ExtCtxt,\n-                        trait_: &TraitDef,\n-                        enum_def: &EnumDef,\n-                        type_ident: Ident,\n-                        self_args: &[Gc<Expr>],\n-                        nonself_args: &[Gc<Expr>],\n-                        matching: Option<uint>,\n-                        matches_so_far: &mut Vec<(uint, P<ast::Variant>,\n-                                              Vec<(Span, Option<Ident>, Gc<Expr>)>)> ,\n-                        match_count: uint) -> Gc<Expr> {\n-        if match_count == self_args.len() {\n-            // we've matched against all arguments, so make the final\n-            // expression at the bottom of the match tree\n-            if matches_so_far.len() == 0 {\n-                cx.span_bug(trait_.span,\n-                                \"no self match on an enum in \\\n-                                generic `deriving`\");\n-            }\n-\n-            // `ref` inside let matches is buggy. Causes havoc with rusc.\n-            // let (variant_index, ref self_vec) = matches_so_far[0];\n-            let (variant, self_vec) = match matches_so_far.get(0) {\n-                &(_, v, ref s) => (v, s)\n-            };\n-\n-            // we currently have a vec of vecs, where each\n-            // subvec is the fields of one of the arguments,\n-            // but if the variants all match, we want this as\n-            // vec of tuples, where each tuple represents a\n-            // field.\n-\n-            // most arms don't have matching variants, so do a\n-            // quick check to see if they match (even though\n-            // this means iterating twice) instead of being\n-            // optimistic and doing a pile of allocations etc.\n-            let substructure = match matching {\n-                Some(variant_index) => {\n-                    let mut enum_matching_fields = Vec::from_elem(self_vec.len(), Vec::new());\n-\n-                    for triple in matches_so_far.tail().iter() {\n-                        match triple {\n-                            &(_, _, ref other_fields) => {\n-                                for (i, &(_, _, e)) in other_fields.iter().enumerate() {\n-                                    enum_matching_fields.get_mut(i).push(e);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    let field_tuples =\n-                        self_vec.iter()\n-                                .zip(enum_matching_fields.iter())\n-                                .map(|(&(span, id, self_f), other)| {\n-                        FieldInfo {\n-                            span: span,\n-                            name: id,\n-                            self_: self_f,\n-                            other: (*other).clone()\n-                        }\n-                    }).collect();\n-                    EnumMatching(variant_index, &*variant, field_tuples)\n-                }\n-                None => {\n-                    EnumNonMatching(matches_so_far.as_slice())\n-                }\n-            };\n-            self.call_substructure_method(cx, trait_, type_ident,\n-                                          self_args, nonself_args,\n-                                          &substructure)\n-\n-        } else {  // there are still matches to create\n-            let current_match_str = if match_count == 0 {\n-                \"__self\".to_string()\n-            } else {\n-                format!(\"__arg_{}\", match_count)\n-            };\n-\n-            let mut arms = Vec::new();\n-\n-            assert!(self.on_nonmatching == NonMatchesCollapse ||\n-                    self.on_nonmatching == NonMatchesExplode ||\n-                    self.on_nonmatching == NonMatchHandlingIrrelevant);\n-\n-            // the code for nonmatching variants only matters when\n-            // we've seen at least one other variant already\n-            assert!(match_count == 0 ||\n-                    self.on_nonmatching != NonMatchHandlingIrrelevant);\n-            if self.on_nonmatching == NonMatchesCollapse && match_count > 0 {\n-                // make a matching-variant match, and a _ match.\n-                let index = match matching {\n-                    Some(i) => i,\n-                    None => cx.span_bug(trait_.span,\n-                                        \"non-matching variants when required to \\\n-                                        be matching in generic `deriving`\")\n-                };\n-\n-                // matching-variant match\n-                let variant = *enum_def.variants.get(index);\n-                let (pattern, idents) = trait_.create_enum_variant_pattern(\n-                    cx,\n-                    &*variant,\n-                    current_match_str.as_slice(),\n-                    ast::MutImmutable);\n-\n-                matches_so_far.push((index, variant, idents));\n-                let arm_expr = self.build_enum_match(cx,\n-                                                     trait_,\n-                                                     enum_def,\n-                                                     type_ident,\n-                                                     self_args, nonself_args,\n-                                                     matching,\n-                                                     matches_so_far,\n-                                                     match_count + 1);\n-                matches_so_far.pop().unwrap();\n-                arms.push(cx.arm(trait_.span, vec!( pattern ), arm_expr));\n-\n-                if enum_def.variants.len() > 1 {\n-                    let e = &EnumNonMatching(&[]);\n-                    let wild_expr = self.call_substructure_method(cx, trait_, type_ident,\n-                                                                  self_args, nonself_args,\n-                                                                  e);\n-                    let wild_arm = cx.arm(\n-                        trait_.span,\n-                        vec!( cx.pat_wild(trait_.span) ),\n-                        wild_expr);\n-                    arms.push(wild_arm);\n-                }\n-            } else {\n-                // create an arm matching on each variant\n-                for (index, &variant) in enum_def.variants.iter().enumerate() {\n-                    let (pattern, idents) =\n-                        trait_.create_enum_variant_pattern(\n-                            cx,\n-                            &*variant,\n-                            current_match_str.as_slice(),\n-                            ast::MutImmutable);\n-\n-                    matches_so_far.push((index, variant, idents));\n-                    let new_matching =\n-                        match matching {\n-                            _ if match_count == 0 => Some(index),\n-                            Some(i) if index == i => Some(i),\n-                            _ => None\n-                        };\n-                    let arm_expr = self.build_enum_match(cx,\n-                                                         trait_,\n-                                                         enum_def,\n-                                                         type_ident,\n-                                                         self_args, nonself_args,\n-                                                         new_matching,\n-                                                         matches_so_far,\n-                                                         match_count + 1);\n-                    matches_so_far.pop().unwrap();\n-\n-                    let arm = cx.arm(trait_.span, vec!( pattern ), arm_expr);\n-                    arms.push(arm);\n-                }\n-            }\n-\n-            // match foo { arm, arm, arm, ... }\n-            cx.expr_match(trait_.span, self_args[match_count], arms)\n-        }\n-    }\n-\n     /**\n     Creates a match for a tuple of all `self_args`, where either all\n     variants match, or it falls into a catch-all for when one variant\n@@ -1522,8 +1295,7 @@ left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold(use_foldl: bool,\n                f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>, &[Gc<Expr>]| -> Gc<Expr>,\n                base: Gc<Expr>,\n-               enum_nonmatch_f: EnumNonMatchFunc,\n-               enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n+               enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n@@ -1548,11 +1320,8 @@ pub fn cs_fold(use_foldl: bool,\n                 })\n             }\n         },\n-        EnumNonMatching(ref all_enums) =>\n-            enum_nonmatch_f(cx, trait_span, *all_enums,\n-                            substructure.nonself_args),\n         EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n-            enum_nonmatch_g(cx, trait_span, (all_args.as_slice(), tuple),\n+            enum_nonmatch_f(cx, trait_span, (all_args.as_slice(), tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")\n@@ -1572,8 +1341,7 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n */\n #[inline]\n pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n-                      enum_nonmatch_f: EnumNonMatchFunc,\n-                      enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n+                      enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n@@ -1592,11 +1360,8 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n \n             f(cx, trait_span, called)\n         },\n-        EnumNonMatching(ref all_enums) =>\n-            enum_nonmatch_f(cx, trait_span, *all_enums,\n-                            substructure.nonself_args),\n         EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n-            enum_nonmatch_g(cx, trait_span, (all_self_args.as_slice(), tuple),\n+            enum_nonmatch_f(cx, trait_span, (all_self_args.as_slice(), tuple),\n                             substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")\n@@ -1613,8 +1378,7 @@ fields. `use_foldl` controls whether this is done left-to-right\n pub fn cs_same_method_fold(use_foldl: bool,\n                            f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>| -> Gc<Expr>,\n                            base: Gc<Expr>,\n-                           enum_nonmatch_f: EnumNonMatchFunc,\n-                           enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n+                           enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                            cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n@@ -1632,7 +1396,6 @@ pub fn cs_same_method_fold(use_foldl: bool,\n             }\n         },\n         enum_nonmatch_f,\n-        enum_nonmatch_g,\n         cx, trait_span, substructure)\n }\n \n@@ -1642,8 +1405,7 @@ on all the fields.\n */\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n-                enum_nonmatch_f: EnumNonMatchFunc,\n-                enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n+                enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> Gc<Expr> {\n     cs_same_method_fold(\n@@ -1656,30 +1418,25 @@ pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n         },\n         base,\n         enum_nonmatch_f,\n-        enum_nonmatch_g,\n         cx, trait_span, substructure)\n }\n \n /// cs_binop with binop == or\n #[inline]\n-pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n-             enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n+pub fn cs_or(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n              cx: &mut ExtCtxt, span: Span,\n              substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n              enum_nonmatch_f,\n-             enum_nonmatch_g,\n              cx, span, substructure)\n }\n \n /// cs_binop with binop == and\n #[inline]\n-pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n-              enum_nonmatch_g: EnumNonMatchCollapsedFunc,\n+pub fn cs_and(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n               cx: &mut ExtCtxt, span: Span,\n               substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),\n              enum_nonmatch_f,\n-             enum_nonmatch_g,\n              cx, span, substructure)\n }"}, {"sha": "f469139177a0b24e8ebb2551a036faf4897e797a", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -54,7 +54,6 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                 args: vec!(Ptr(box Literal(args), Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     hash_substructure(a, b, c)\n                 })"}, {"sha": "30dd8e9683ad51b320d3e36d8c462d4d145205c0", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -45,7 +45,6 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs.clone(),\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|c, s, sub| {\n                     cs_from(\"i64\", c, s, sub)\n                 }),\n@@ -62,7 +61,6 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs,\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|c, s, sub| {\n                     cs_from(\"u64\", c, s, sub)\n                 }),"}, {"sha": "c652b5a5bed9a60c223ee7b6839927c98759d727", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -45,7 +45,6 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                 ),\n                 ret_ty: Self,\n                 attributes: Vec::new(),\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     rand_substructure(a, b, c)\n                 })"}, {"sha": "e0dfbb232f554fcf0c7343f29ef89f608f4a4ed0", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -45,7 +45,6 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                 args: vec!(fmtr),\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"fmt\", \"Result\"))),\n                 attributes: Vec::new(),\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     show_substructure(a, b, c)\n                 })\n@@ -66,9 +65,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let name = match *substr.fields {\n         Struct(_) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n-\n-        EnumNonMatching(..) | EnumNonMatchingCollapsed(..) |\n-        StaticStruct(..) | StaticEnum(..) => {\n+        EnumNonMatchingCollapsed(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[deriving(Show)]`\")\n         }\n     };"}, {"sha": "973f9d518cd70563c373cce5e0d9e2c50f26c450", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cee57869c527ee798c8aeb0e17e82fb36848c4f/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=5cee57869c527ee798c8aeb0e17e82fb36848c4f", "patch": "@@ -39,7 +39,6 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Self,\n                 attributes: attrs.clone(),\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     zero_substructure(a, b, c)\n                 })\n@@ -51,16 +50,11 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 attributes: attrs,\n-                on_nonmatching: NonMatchHandlingIrrelevant,\n                 combine_substructure: combine_substructure(|cx, span, substr| {\n                     cs_and(|cx, span, _, _| cx.span_bug(span,\n                                                         \"Non-matching enum \\\n                                                          variant in \\\n                                                          deriving(Zero)\"),\n-                           |cx, span, _, _| cx.span_bug(span,\n-                                                        \"Non-matching enum \\\n-                                                         variant in \\\n-                                                         deriving(Zero)\"),\n                            cx, span, substr)\n                 })\n             }"}]}