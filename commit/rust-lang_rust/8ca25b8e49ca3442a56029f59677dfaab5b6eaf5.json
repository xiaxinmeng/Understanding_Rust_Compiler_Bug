{"sha": "8ca25b8e49ca3442a56029f59677dfaab5b6eaf5", "node_id": "C_kwDOAAsO6NoAKDhjYTI1YjhlNDljYTM0NDJhNTYwMjlmNTk2NzdkZmFhYjViNmVhZjU", "commit": {"author": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2022-12-29T22:43:34Z"}, "committer": {"name": "Markus Everling", "email": "markuseverling@gmail.com", "date": "2023-01-31T14:04:39Z"}, "message": "Fix `vec_deque::Drain` FIXME", "tree": {"sha": "52b51621c0969d86ad22c1a34ab7427a18cb9136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52b51621c0969d86ad22c1a34ab7427a18cb9136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5", "html_url": "https://github.com/rust-lang/rust/commit/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5/comments", "author": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Sp00ph", "id": 61327188, "node_id": "MDQ6VXNlcjYxMzI3MTg4", "avatar_url": "https://avatars.githubusercontent.com/u/61327188?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sp00ph", "html_url": "https://github.com/Sp00ph", "followers_url": "https://api.github.com/users/Sp00ph/followers", "following_url": "https://api.github.com/users/Sp00ph/following{/other_user}", "gists_url": "https://api.github.com/users/Sp00ph/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sp00ph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sp00ph/subscriptions", "organizations_url": "https://api.github.com/users/Sp00ph/orgs", "repos_url": "https://api.github.com/users/Sp00ph/repos", "events_url": "https://api.github.com/users/Sp00ph/events{/privacy}", "received_events_url": "https://api.github.com/users/Sp00ph/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e37ff7e71a087fcd799d3e59bcd63e3732d351d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e37ff7e71a087fcd799d3e59bcd63e3732d351d3", "html_url": "https://github.com/rust-lang/rust/commit/e37ff7e71a087fcd799d3e59bcd63e3732d351d3"}], "stats": {"total": 50, "additions": 19, "deletions": 31}, "files": [{"sha": "a102aaad452e844ee0d11978a6f0ea5260e32479", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=8ca25b8e49ca3442a56029f59677dfaab5b6eaf5", "patch": "@@ -57,31 +57,17 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n     unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n         unsafe {\n             let deque = self.deque.as_ref();\n-            // FIXME: This is doing almost exactly the same thing as the else branch in `VecDeque::slice_ranges`.\n-            // Unfortunately, we can't just call `slice_ranges` here, as the deque's `len` is currently\n-            // just `drain_start`, so the range check would (almost) always panic. Between temporarily\n-            // adjusting the deques `len` to call `slice_ranges`, and just copy pasting the `slice_ranges`\n-            // implementation, this seemed like the less hacky solution, though it might be good to\n-            // find a better one in the future.\n-\n-            // because `self.remaining != 0`, we know that `self.idx < deque.original_len`, so it's a valid\n-            // logical index.\n-            let wrapped_start = deque.to_physical_idx(self.idx);\n-\n-            let head_len = deque.capacity() - wrapped_start;\n-\n-            let (a_range, b_range) = if head_len >= self.remaining {\n-                (wrapped_start..wrapped_start + self.remaining, 0..0)\n-            } else {\n-                let tail_len = self.remaining - head_len;\n-                (wrapped_start..deque.capacity(), 0..tail_len)\n-            };\n-\n-            // SAFETY: the range `self.idx..self.idx+self.remaining` lies strictly inside\n-            // the range `0..deque.original_len`. because of this, and because of the fact\n-            // that we acquire `a_range` and `b_range` exactly like `slice_ranges` would,\n+\n+            let start = self.idx;\n+            // We know that `self.idx + self.remaining <= deque.len <= usize::MAX`, so this won't overflow.\n+            let end = start + self.remaining;\n+\n+            // SAFETY: the range `start..end` lies strictly inside\n+            // the range `0..deque.original_len`. Because of this, and because\n+            // we haven't touched the elements inside this range yet,\n             // it's guaranteed that `a_range` and `b_range` represent valid ranges into\n             // the deques buffer.\n+            let (a_range, b_range) = deque.slice_ranges(start..end, end);\n             (deque.buffer_range(a_range), deque.buffer_range(b_range))\n         }\n     }"}, {"sha": "6d3e784c8b7f096eb25b1267b96041161ae83d15", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca25b8e49ca3442a56029f59677dfaab5b6eaf5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=8ca25b8e49ca3442a56029f59677dfaab5b6eaf5", "patch": "@@ -1147,7 +1147,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n@@ -1181,7 +1181,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n@@ -1223,19 +1223,21 @@ impl<T, A: Allocator> VecDeque<T, A> {\n \n     /// Given a range into the logical buffer of the deque, this function\n     /// return two ranges into the physical buffer that correspond to\n-    /// the given range.\n-    fn slice_ranges<R>(&self, range: R) -> (Range<usize>, Range<usize>)\n+    /// the given range. The `len` parameter should usually just be `self.len`;\n+    /// the reason it's passed explicitly is that if the deque is wrapped in\n+    /// a `Drain`, then `self.len` is not actually the length of the deque.\n+    fn slice_ranges<R>(&self, range: R, len: usize) -> (Range<usize>, Range<usize>)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = slice::range(range, ..self.len);\n+        let Range { start, end } = slice::range(range, ..len);\n         let len = end - start;\n \n         if len == 0 {\n             (0..0, 0..0)\n         } else {\n             // `slice::range` guarantees that `start <= end <= self.len`.\n-            // because `len != 0`, we know that `start < end`, so `start < self.len`\n+            // because `len != 0`, we know that `start < end`, so `start < len`\n             // and the indexing is valid.\n             let wrapped_start = self.to_physical_idx(start);\n \n@@ -1281,7 +1283,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and\n@@ -1321,7 +1323,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and"}]}