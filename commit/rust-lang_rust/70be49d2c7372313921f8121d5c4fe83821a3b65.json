{"sha": "70be49d2c7372313921f8121d5c4fe83821a3b65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYmU0OWQyYzczNzIzMTM5MjFmODEyMWQ1YzRmZTgzODIxYTNiNjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-05T07:57:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-13T01:24:34Z"}, "message": "Move the list of region obligations into the fulfillment context.", "tree": {"sha": "2c288a6a361b3e839509b59104fed9107b934c04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c288a6a361b3e839509b59104fed9107b934c04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70be49d2c7372313921f8121d5c4fe83821a3b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70be49d2c7372313921f8121d5c4fe83821a3b65", "html_url": "https://github.com/rust-lang/rust/commit/70be49d2c7372313921f8121d5c4fe83821a3b65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70be49d2c7372313921f8121d5c4fe83821a3b65/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bdd7f00401c0002011ab20b70b405a15fa9128c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bdd7f00401c0002011ab20b70b405a15fa9128c", "html_url": "https://github.com/rust-lang/rust/commit/9bdd7f00401c0002011ab20b70b405a15fa9128c"}], "stats": {"total": 150, "additions": 83, "deletions": 67}, "files": [{"sha": "d0e401d35518f3a75e9818703288d35a7eb884f9", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=70be49d2c7372313921f8121d5c4fe83821a3b65", "patch": "@@ -9,11 +9,15 @@\n // except according to those terms.\n \n use middle::mem_categorization::Typer;\n-use middle::ty;\n-use middle::infer::InferCtxt;\n+use middle::ty::{mod, Ty};\n+use middle::infer::{mod, InferCtxt};\n use std::collections::HashSet;\n+use std::collections::hash_map::{Occupied, Vacant};\n+use std::default::Default;\n use std::rc::Rc;\n+use syntax::ast;\n use util::ppaux::Repr;\n+use util::nodemap::NodeMap;\n \n use super::CodeAmbiguity;\n use super::TraitObligation;\n@@ -47,6 +51,38 @@ pub struct FulfillmentContext<'tcx> {\n     // attempted to select. This is used to avoid repeating work\n     // when `select_new_obligations` is called.\n     attempted_mark: uint,\n+\n+    // A set of constraints that regionck must validate. Each\n+    // constraint has the form `T:'a`, meaning \"some type `T` must\n+    // outlive the lifetime 'a\". These constraints derive from\n+    // instantiated type parameters. So if you had a struct defined\n+    // like\n+    //\n+    //     struct Foo<T:'static> { ... }\n+    //\n+    // then in some expression `let x = Foo { ... }` it will\n+    // instantiate the type parameter `T` with a fresh type `$0`. At\n+    // the same time, it will record a region obligation of\n+    // `$0:'static`. This will get checked later by regionck. (We\n+    // can't generally check these things right away because we have\n+    // to wait until types are resolved.)\n+    //\n+    // These are stored in a map keyed to the id of the innermost\n+    // enclosing fn body / static initializer expression. This is\n+    // because the location where the obligation was incurred can be\n+    // relevant with respect to which sublifetime assumptions are in\n+    // place. The reason that we store under the fn-id, and not\n+    // something more fine-grained, is so that it is easier for\n+    // regionck to be sure that it has found *all* the region\n+    // obligations (otherwise, it's easy to fail to walk to a\n+    // particular node-id).\n+    region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n+}\n+\n+pub struct RegionObligation<'tcx> {\n+    pub sub_region: ty::Region,\n+    pub sup_type: Ty<'tcx>,\n+    pub origin: infer::SubregionOrigin<'tcx>,\n }\n \n impl<'tcx> FulfillmentContext<'tcx> {\n@@ -55,6 +91,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             duplicate_set: HashSet::new(),\n             trait_obligations: Vec::new(),\n             attempted_mark: 0,\n+            region_obligations: NodeMap::new(),\n         }\n     }\n \n@@ -71,6 +108,26 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n+    pub fn register_region_obligation(&mut self,\n+                                      body_id: ast::NodeId,\n+                                      region_obligation: RegionObligation<'tcx>)\n+    {\n+        match self.region_obligations.entry(body_id) {\n+            Vacant(entry) => { entry.set(vec![region_obligation]); },\n+            Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n+        }\n+    }\n+\n+    pub fn region_obligations(&self,\n+                              body_id: ast::NodeId)\n+                              -> &[RegionObligation<'tcx>]\n+    {\n+        match self.region_obligations.get(&body_id) {\n+            None => Default::default(),\n+            Some(vec) => vec.as_slice(),\n+        }\n+    }\n+\n     pub fn select_all_or_error<'a>(&mut self,\n                                    infcx: &InferCtxt<'a,'tcx>,\n                                    param_env: &ty::ParameterEnvironment<'tcx>,\n@@ -208,3 +265,12 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"RegionObligation(sub_region={}, sup_type={}, origin={})\",\n+                self.sub_region.repr(tcx),\n+                self.sup_type.repr(tcx),\n+                self.origin.repr(tcx))\n+    }\n+}"}, {"sha": "aab1fbcdbfd6acffb20fb1a97795db6973086ea3", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=70be49d2c7372313921f8121d5c4fe83821a3b65", "patch": "@@ -25,7 +25,7 @@ use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use util::common::ErrorReported;\n \n-pub use self::fulfill::FulfillmentContext;\n+pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};"}, {"sha": "c7be362f18755f03d289b21d9be6a07c41279d58", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 52, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=70be49d2c7372313921f8121d5c4fe83821a3b65", "patch": "@@ -84,13 +84,14 @@ use self::TupleArgumentsFlag::*;\n \n use astconv::{mod, ast_region_to_region, ast_ty_to_ty, AstConv};\n use check::_match::pat_ctxt;\n-use middle::{const_eval, def, traits};\n+use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n use middle::mem_categorization::{mod, McResult};\n use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n+use middle::traits;\n use middle::ty::{FnSig, VariantInfo, Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{mod, Ty};\n@@ -108,7 +109,6 @@ use util::ppaux::{mod, UserString, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use syntax::{mod, abi, attr};\n@@ -161,42 +161,10 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // one is never copied into the tcx: it is only used by regionck.\n     fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n \n-    // A set of constraints that regionck must validate. Each\n-    // constraint has the form `T:'a`, meaning \"some type `T` must\n-    // outlive the lifetime 'a\". These constraints derive from\n-    // instantiated type parameters. So if you had a struct defined\n-    // like\n-    //\n-    //     struct Foo<T:'static> { ... }\n-    //\n-    // then in some expression `let x = Foo { ... }` it will\n-    // instantiate the type parameter `T` with a fresh type `$0`. At\n-    // the same time, it will record a region obligation of\n-    // `$0:'static`. This will get checked later by regionck. (We\n-    // can't generally check these things right away because we have\n-    // to wait until types are resolved.)\n-    //\n-    // These are stored in a map keyed to the id of the innermost\n-    // enclosing fn body / static initializer expression. This is\n-    // because the location where the obligation was incurred can be\n-    // relevant with respect to which sublifetime assumptions are in\n-    // place. The reason that we store under the fn-id, and not\n-    // something more fine-grained, is so that it is easier for\n-    // regionck to be sure that it has found *all* the region\n-    // obligations (otherwise, it's easy to fail to walk to a\n-    // particular node-id).\n-    region_obligations: RefCell<NodeMap<Vec<RegionObligation<'tcx>>>>,\n-\n     // Tracks trait obligations incurred during this function body.\n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n }\n \n-struct RegionObligation<'tcx> {\n-    sub_region: ty::Region,\n-    sup_type: Ty<'tcx>,\n-    origin: infer::SubregionOrigin<'tcx>,\n-}\n-\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n enum Expectation<'tcx> {\n@@ -328,7 +296,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             upvar_borrow_map: RefCell::new(FnvHashMap::new()),\n             unboxed_closures: RefCell::new(DefIdMap::new()),\n             fn_sig_map: RefCell::new(NodeMap::new()),\n-            region_obligations: RefCell::new(NodeMap::new()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n@@ -1988,15 +1955,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       ty: Ty<'tcx>,\n                                       r: ty::Region)\n     {\n-        let mut region_obligations = self.inh.region_obligations.borrow_mut();\n-        let region_obligation = RegionObligation { sub_region: r,\n-                                                   sup_type: ty,\n-                                                   origin: origin };\n-\n-        match region_obligations.entry(self.body_id) {\n-            Vacant(entry) => { entry.set(vec![region_obligation]); },\n-            Occupied(mut entry) => { entry.get_mut().push(region_obligation); },\n-        }\n+        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        let region_obligation = traits::RegionObligation { sub_region: r,\n+                                                           sup_type: ty,\n+                                                           origin: origin };\n+        fulfillment_cx.register_region_obligation(self.body_id, region_obligation);\n     }\n \n     pub fn add_default_region_param_bounds(&self,\n@@ -5833,11 +5796,3 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"RegionObligation(sub_region={}, sup_type={}, origin={})\",\n-                self.sub_region.repr(tcx),\n-                self.sup_type.repr(tcx),\n-                self.origin.repr(tcx))\n-    }\n-}"}, {"sha": "1564287f15f940535c7132bab58c5b64462a1a26", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70be49d2c7372313921f8121d5c4fe83821a3b65/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=70be49d2c7372313921f8121d5c4fe83821a3b65", "patch": "@@ -353,18 +353,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n-        let region_obligations = self.fcx.inh.region_obligations.borrow();\n-        match region_obligations.get(&node_id) {\n-            None => { }\n-            Some(vec) => {\n-                for r_o in vec.iter() {\n-                    debug!(\"visit_region_obligations: r_o={}\",\n-                           r_o.repr(self.tcx()));\n-                    let sup_type = self.resolve_type(r_o.sup_type);\n-                    type_must_outlive(self, r_o.origin.clone(),\n-                                      sup_type, r_o.sub_region);\n-                }\n-            }\n+        let fulfillment_cx = self.fcx.inh.fulfillment_cx.borrow();\n+        for r_o in fulfillment_cx.region_obligations(node_id).iter() {\n+            debug!(\"visit_region_obligations: r_o={}\",\n+                   r_o.repr(self.tcx()));\n+            let sup_type = self.resolve_type(r_o.sup_type);\n+            type_must_outlive(self, r_o.origin.clone(),\n+                              sup_type, r_o.sub_region);\n         }\n     }\n "}]}