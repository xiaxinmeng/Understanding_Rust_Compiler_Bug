{"sha": "67ce547f474fbe34e8aafe4bfc284c3856673744", "node_id": "C_kwDOAAsO6NoAKDY3Y2U1NDdmNDc0ZmJlMzRlOGFhZmU0YmZjMjg0YzM4NTY2NzM3NDQ", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-04-29T18:56:57Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-04-29T18:56:57Z"}, "message": "Refactor and document the repeat length check", "tree": {"sha": "38459ecf7bafe509a1a337abd330ec03b10ce1f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38459ecf7bafe509a1a337abd330ec03b10ce1f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67ce547f474fbe34e8aafe4bfc284c3856673744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67ce547f474fbe34e8aafe4bfc284c3856673744", "html_url": "https://github.com/rust-lang/rust/commit/67ce547f474fbe34e8aafe4bfc284c3856673744", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67ce547f474fbe34e8aafe4bfc284c3856673744/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be54947315b6d2892ed09281a7770e1f09c673e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/be54947315b6d2892ed09281a7770e1f09c673e7", "html_url": "https://github.com/rust-lang/rust/commit/be54947315b6d2892ed09281a7770e1f09c673e7"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "a1e8d2040dd80d82429fa9b4984a656fb3145ef6", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/67ce547f474fbe34e8aafe4bfc284c3856673744/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67ce547f474fbe34e8aafe4bfc284c3856673744/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=67ce547f474fbe34e8aafe4bfc284c3856673744", "patch": "@@ -1304,31 +1304,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         element_ty: Ty<'tcx>,\n     ) {\n         let tcx = self.tcx;\n-        let is_const = match &element.kind {\n-            hir::ExprKind::ConstBlock(..) => true,\n+        // Actual constants as the repeat element get inserted repeatedly instead of getting copied via Copy.\n+        match &element.kind {\n+            hir::ExprKind::ConstBlock(..) => return,\n             hir::ExprKind::Path(qpath) => {\n                 let res = self.typeck_results.borrow().qpath_res(qpath, element.hir_id);\n-                matches!(\n-                    res,\n-                    Res::Def(DefKind::Const | DefKind::AssocConst | DefKind::AnonConst, _)\n-                )\n+                if let Res::Def(DefKind::Const | DefKind::AssocConst | DefKind::AnonConst, _) = res\n+                {\n+                    return;\n+                }\n             }\n+            _ => {}\n+        }\n+        // If someone calls a const fn, they can extract that call out into a separate constant (or a const\n+        // block in the future), so we check that to tell them that in the diagnostic. Does not affect typeck.\n+        let is_const_fn = match element.kind {\n+            hir::ExprKind::Call(func, _args) => match *self.node_ty(func.hir_id).kind() {\n+                ty::FnDef(def_id, _) => tcx.is_const_fn(def_id),\n+                _ => false,\n+            },\n             _ => false,\n         };\n-        if !is_const {\n-            let is_const_fn = match element.kind {\n-                hir::ExprKind::Call(func, _args) => match *self.node_ty(func.hir_id).kind() {\n-                    ty::FnDef(def_id, _) => tcx.is_const_fn(def_id),\n-                    _ => false,\n-                },\n-                _ => false,\n-            };\n \n-            if count.try_eval_usize(tcx, self.param_env).map_or(true, |len| len > 1) {\n-                let lang_item = self.tcx.require_lang_item(LangItem::Copy, None);\n-                let code = traits::ObligationCauseCode::RepeatElementCopy { is_const_fn };\n-                self.require_type_meets(element_ty, element.span, code, lang_item);\n-            }\n+        // If the length is 0, we don't create any elements, so we don't copy any. If the length is 1, we\n+        // don't copy that one element, we move it. Only check for Copy if the length is larger.\n+        if count.try_eval_usize(tcx, self.param_env).map_or(true, |len| len > 1) {\n+            let lang_item = self.tcx.require_lang_item(LangItem::Copy, None);\n+            let code = traits::ObligationCauseCode::RepeatElementCopy { is_const_fn };\n+            self.require_type_meets(element_ty, element.span, code, lang_item);\n         }\n     }\n "}]}