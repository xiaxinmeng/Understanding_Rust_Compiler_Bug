{"sha": "48e89b00caa94829a5f07e0f1ecb33bf37431244", "node_id": "C_kwDOAAsO6NoAKDQ4ZTg5YjAwY2FhOTQ4MjlhNWYwN2UwZjFlY2IzM2JmMzc0MzEyNDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-16T14:25:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-16T14:25:25Z"}, "message": "Auto merge of #92245 - petrochenkov:cmrval, r=nagisa\n\nrustc_metadata: Switch all decoder methods from vectors to iterators\n\nTo avoid allocations in some cases.\n\nAlso remove unnecessary `is_proc_macro_crate` checks from decoder, currently the general strategy is to shift all the work to the encoder and assume that all the encoded data is correct and can be decoded unconditionally in the decoder.", "tree": {"sha": "a928f002bc17f2c6a6bd1d512e01086aa257fc65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a928f002bc17f2c6a6bd1d512e01086aa257fc65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48e89b00caa94829a5f07e0f1ecb33bf37431244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48e89b00caa94829a5f07e0f1ecb33bf37431244", "html_url": "https://github.com/rust-lang/rust/commit/48e89b00caa94829a5f07e0f1ecb33bf37431244", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48e89b00caa94829a5f07e0f1ecb33bf37431244/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7be8693984d32d2f65ce9ded4f65b6b7340bddce", "url": "https://api.github.com/repos/rust-lang/rust/commits/7be8693984d32d2f65ce9ded4f65b6b7340bddce", "html_url": "https://github.com/rust-lang/rust/commit/7be8693984d32d2f65ce9ded4f65b6b7340bddce"}, {"sha": "4549b135719aa81bbb0427087963c7af3e8f6bdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4549b135719aa81bbb0427087963c7af3e8f6bdc", "html_url": "https://github.com/rust-lang/rust/commit/4549b135719aa81bbb0427087963c7af3e8f6bdc"}], "stats": {"total": 153, "additions": 66, "deletions": 87}, "files": [{"sha": "39aa1844d691165f2af75debda0d0b46e0205638", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 33, "deletions": 67, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=48e89b00caa94829a5f07e0f1ecb33bf37431244", "patch": "@@ -1033,45 +1033,33 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     /// Iterates over all the stability attributes in the given crate.\n     fn get_lib_features(self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n-        // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n-        // features or an empty Vec. Both don't cause ICEs.\n         tcx.arena.alloc_from_iter(self.root.lib_features.decode(self))\n     }\n \n     /// Iterates over the language items in the given crate.\n     fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n-        if self.root.is_proc_macro_crate() {\n-            // Proc macro crates do not export any lang-items to the target.\n-            &[]\n-        } else {\n-            tcx.arena.alloc_from_iter(\n-                self.root\n-                    .lang_items\n-                    .decode(self)\n-                    .map(|(def_index, index)| (self.local_def_id(def_index), index)),\n-            )\n-        }\n+        tcx.arena.alloc_from_iter(\n+            self.root\n+                .lang_items\n+                .decode(self)\n+                .map(|(def_index, index)| (self.local_def_id(def_index), index)),\n+        )\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n     fn get_diagnostic_items(self) -> DiagnosticItems {\n-        if self.root.is_proc_macro_crate() {\n-            // Proc macro crates do not export any diagnostic-items to the target.\n-            Default::default()\n-        } else {\n-            let mut id_to_name = FxHashMap::default();\n-            let name_to_id = self\n-                .root\n-                .diagnostic_items\n-                .decode(self)\n-                .map(|(name, def_index)| {\n-                    let id = self.local_def_id(def_index);\n-                    id_to_name.insert(id, name);\n-                    (name, id)\n-                })\n-                .collect();\n-            DiagnosticItems { id_to_name, name_to_id }\n-        }\n+        let mut id_to_name = FxHashMap::default();\n+        let name_to_id = self\n+            .root\n+            .diagnostic_items\n+            .decode(self)\n+            .map(|(name, def_index)| {\n+                let id = self.local_def_id(def_index);\n+                id_to_name.insert(id, name);\n+                (name, id)\n+            })\n+            .collect();\n+        DiagnosticItems { id_to_name, name_to_id }\n     }\n \n     /// Iterates over all named children of the given module,\n@@ -1346,26 +1334,28 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_struct_field_names(self, id: DefIndex, sess: &Session) -> Vec<Spanned<Symbol>> {\n+    fn get_struct_field_names(\n+        self,\n+        id: DefIndex,\n+        sess: &'a Session,\n+    ) -> impl Iterator<Item = Spanned<Symbol>> + 'a {\n         self.root\n             .tables\n             .children\n             .get(self, id)\n             .unwrap_or_else(Lazy::empty)\n             .decode(self)\n-            .map(|index| respan(self.get_span(index, sess), self.item_ident(index, sess).name))\n-            .collect()\n+            .map(move |index| respan(self.get_span(index, sess), self.item_ident(index, sess).name))\n     }\n \n-    fn get_struct_field_visibilities(self, id: DefIndex) -> Vec<Visibility> {\n+    fn get_struct_field_visibilities(self, id: DefIndex) -> impl Iterator<Item = Visibility> + 'a {\n         self.root\n             .tables\n             .children\n             .get(self, id)\n             .unwrap_or_else(Lazy::empty)\n             .decode(self)\n-            .map(|field_index| self.get_visibility(field_index))\n-            .collect()\n+            .map(move |field_index| self.get_visibility(field_index))\n     }\n \n     fn get_inherent_implementations_for_type(\n@@ -1401,8 +1391,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n     ) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n-        if self.root.is_proc_macro_crate() {\n-            // proc-macro crates export no trait impls.\n+        if self.trait_impls.is_empty() {\n             return &[];\n         }\n \n@@ -1437,13 +1426,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         })\n     }\n \n-    fn get_native_libraries(self, sess: &Session) -> Vec<NativeLib> {\n-        if self.root.is_proc_macro_crate() {\n-            // Proc macro crates do not have any *target* native libraries.\n-            vec![]\n-        } else {\n-            self.root.native_libraries.decode((self, sess)).collect()\n-        }\n+    fn get_native_libraries(self, sess: &'a Session) -> impl Iterator<Item = NativeLib> + 'a {\n+        self.root.native_libraries.decode((self, sess))\n     }\n \n     fn get_proc_macro_quoted_span(self, index: usize, sess: &Session) -> Span {\n@@ -1455,15 +1439,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_foreign_modules(self, tcx: TyCtxt<'tcx>) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n-        if self.root.is_proc_macro_crate() {\n-            // Proc macro crates do not have any *target* foreign modules.\n-            Lrc::new(FxHashMap::default())\n-        } else {\n-            let modules: FxHashMap<DefId, ForeignModule> =\n-                self.root.foreign_modules.decode((self, tcx.sess)).map(|m| (m.def_id, m)).collect();\n-            Lrc::new(modules)\n-        }\n+    fn get_foreign_modules(self, sess: &'a Session) -> impl Iterator<Item = ForeignModule> + '_ {\n+        self.root.foreign_modules.decode((self, sess))\n     }\n \n     fn get_dylib_dependency_formats(\n@@ -1479,12 +1456,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_missing_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n-        if self.root.is_proc_macro_crate() {\n-            // Proc macro crates do not depend on any target weak lang-items.\n-            &[]\n-        } else {\n-            tcx.arena.alloc_from_iter(self.root.lang_items_missing.decode(self))\n-        }\n+        tcx.arena.alloc_from_iter(self.root.lang_items_missing.decode(self))\n     }\n \n     fn get_fn_param_names(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n@@ -1500,13 +1472,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportLevel)] {\n-        if self.root.is_proc_macro_crate() {\n-            // If this crate is a custom derive crate, then we're not even going to\n-            // link those in so we skip those crates.\n-            &[]\n-        } else {\n-            tcx.arena.alloc_from_iter(self.root.exported_symbols.decode((self, tcx)))\n-        }\n+        tcx.arena.alloc_from_iter(self.root.exported_symbols.decode((self, tcx)))\n     }\n \n     fn get_rendered_const(self, id: DefIndex) -> String {"}, {"sha": "9b59c14c2fec82a342c4dd7c2183e953ac4004bb", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=48e89b00caa94829a5f07e0f1ecb33bf37431244", "patch": "@@ -179,8 +179,10 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n         reachable_non_generics\n     }\n-    native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess)) }\n-    foreign_modules => { cdata.get_foreign_modules(tcx) }\n+    native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess).collect()) }\n+    foreign_modules => {\n+        Lrc::new(cdata.get_foreign_modules(tcx.sess).map(|m| (m.def_id, m)).collect())\n+    }\n     crate_hash => { cdata.root.hash }\n     crate_host_hash => { cdata.host_hash }\n     crate_name => { cdata.root.name }\n@@ -371,11 +373,18 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n }\n \n impl CStore {\n-    pub fn struct_field_names_untracked(&self, def: DefId, sess: &Session) -> Vec<Spanned<Symbol>> {\n+    pub fn struct_field_names_untracked<'a>(\n+        &'a self,\n+        def: DefId,\n+        sess: &'a Session,\n+    ) -> impl Iterator<Item = Spanned<Symbol>> + 'a {\n         self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n     }\n \n-    pub fn struct_field_visibilities_untracked(&self, def: DefId) -> Vec<Visibility> {\n+    pub fn struct_field_visibilities_untracked(\n+        &self,\n+        def: DefId,\n+    ) -> impl Iterator<Item = Visibility> + '_ {\n         self.get_crate_data(def.krate).get_struct_field_visibilities(def.index)\n     }\n \n@@ -460,8 +469,12 @@ impl CStore {\n         self.get_crate_data(cnum).num_def_ids()\n     }\n \n-    pub fn item_attrs_untracked(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n-        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess).collect()\n+    pub fn item_attrs_untracked<'a>(\n+        &'a self,\n+        def_id: DefId,\n+        sess: &'a Session,\n+    ) -> impl Iterator<Item = ast::Attribute> + 'a {\n+        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess)\n     }\n \n     pub fn get_proc_macro_quoted_span_untracked(\n@@ -473,15 +486,15 @@ impl CStore {\n         self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n     }\n \n-    pub fn traits_in_crate_untracked(&self, cnum: CrateNum) -> Vec<DefId> {\n-        self.get_crate_data(cnum).get_traits().collect()\n+    pub fn traits_in_crate_untracked(&self, cnum: CrateNum) -> impl Iterator<Item = DefId> + '_ {\n+        self.get_crate_data(cnum).get_traits()\n     }\n \n     pub fn trait_impls_in_crate_untracked(\n         &self,\n         cnum: CrateNum,\n-    ) -> Vec<(DefId, Option<SimplifiedType>)> {\n-        self.get_crate_data(cnum).get_trait_impls().collect()\n+    ) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + '_ {\n+        self.get_crate_data(cnum).get_trait_impls()\n     }\n }\n "}, {"sha": "631b8fef668db35181a33b8468819615d62e18ca", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=48e89b00caa94829a5f07e0f1ecb33bf37431244", "patch": "@@ -999,20 +999,23 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let cstore = self.r.cstore();\n         match res {\n             Res::Def(DefKind::Struct, def_id) => {\n-                let field_names = cstore.struct_field_names_untracked(def_id, self.r.session);\n+                let field_names =\n+                    cstore.struct_field_names_untracked(def_id, self.r.session).collect();\n                 let ctor = cstore.ctor_def_id_and_kind_untracked(def_id);\n                 if let Some((ctor_def_id, ctor_kind)) = ctor {\n                     let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n                     let ctor_vis = cstore.visibility_untracked(ctor_def_id);\n-                    let field_visibilities = cstore.struct_field_visibilities_untracked(def_id);\n+                    let field_visibilities =\n+                        cstore.struct_field_visibilities_untracked(def_id).collect();\n                     self.r\n                         .struct_constructors\n                         .insert(def_id, (ctor_res, ctor_vis, field_visibilities));\n                 }\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::Union, def_id) => {\n-                let field_names = cstore.struct_field_names_untracked(def_id, self.r.session);\n+                let field_names =\n+                    cstore.struct_field_names_untracked(def_id, self.r.session).collect();\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::AssocFn, def_id) => {"}, {"sha": "c7edcb077b917ec7a0582ae891aae2138fd66efe", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=48e89b00caa94829a5f07e0f1ecb33bf37431244", "patch": "@@ -914,19 +914,17 @@ impl<'a> Resolver<'a> {\n                             // a note about editions\n                             let note = if let Some(did) = did {\n                                 let requires_note = !did.is_local()\n-                                    && this\n-                                        .cstore()\n-                                        .item_attrs_untracked(did, this.session)\n-                                        .iter()\n-                                        .any(|attr| {\n+                                    && this.cstore().item_attrs_untracked(did, this.session).any(\n+                                        |attr| {\n                                             if attr.has_name(sym::rustc_diagnostic_item) {\n                                                 [sym::TryInto, sym::TryFrom, sym::FromIterator]\n                                                     .map(|x| Some(x))\n                                                     .contains(&attr.value_str())\n                                             } else {\n                                                 false\n                                             }\n-                                        });\n+                                        },\n+                                    );\n \n                                 requires_note.then(|| {\n                                     format!("}, {"sha": "f5b2ba8fd72eb213ae793230a67d60982b368fef", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48e89b00caa94829a5f07e0f1ecb33bf37431244/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=48e89b00caa94829a5f07e0f1ecb33bf37431244", "patch": "@@ -3442,7 +3442,6 @@ impl<'a> Resolver<'a> {\n                 let attr = self\n                     .cstore()\n                     .item_attrs_untracked(def_id, self.session)\n-                    .into_iter()\n                     .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {"}]}