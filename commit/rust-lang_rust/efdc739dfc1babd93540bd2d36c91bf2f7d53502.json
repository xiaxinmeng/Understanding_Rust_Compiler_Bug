{"sha": "efdc739dfc1babd93540bd2d36c91bf2f7d53502", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZGM3MzlkZmMxYmFiZDkzNTQwYmQyZDM2YzkxYmYyZjdkNTM1MDI=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-09-29T12:12:40Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-09-29T12:12:40Z"}, "message": "Move unnecessary_filter_map to a submodule", "tree": {"sha": "8deaf30d5cf63168de7438b3bdd36fa48f0b4412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8deaf30d5cf63168de7438b3bdd36fa48f0b4412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efdc739dfc1babd93540bd2d36c91bf2f7d53502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efdc739dfc1babd93540bd2d36c91bf2f7d53502", "html_url": "https://github.com/rust-lang/rust/commit/efdc739dfc1babd93540bd2d36c91bf2f7d53502", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efdc739dfc1babd93540bd2d36c91bf2f7d53502/comments", "author": null, "committer": null, "parents": [{"sha": "db5c63b77ae022eae16d94fd63ff2d264e57c830", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5c63b77ae022eae16d94fd63ff2d264e57c830", "html_url": "https://github.com/rust-lang/rust/commit/db5c63b77ae022eae16d94fd63ff2d264e57c830"}], "stats": {"total": 288, "additions": 148, "deletions": 140}, "files": [{"sha": "828ef5b12bd0fd8295c91f538a6ce4fa312c3e76", "filename": "clippy_lints/src/methods/mod.rs", "status": "renamed", "additions": 2, "deletions": 140, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/efdc739dfc1babd93540bd2d36c91bf2f7d53502/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efdc739dfc1babd93540bd2d36c91bf2f7d53502/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=efdc739dfc1babd93540bd2d36c91bf2f7d53502", "patch": "@@ -1,6 +1,5 @@\n use crate::rustc::hir;\n use crate::rustc::hir::def::Def;\n-use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, Lint, LintArray, LintContext, LintPass};\n use crate::rustc::ty::{self, Ty};\n use crate::rustc::{declare_tool_lint, lint_array};\n@@ -9,7 +8,6 @@ use crate::syntax::ast;\n use crate::syntax::source_map::{BytePos, Span};\n use crate::utils::paths;\n use crate::utils::sugg;\n-use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self, is_self_ty,\n     iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method, match_type,\n@@ -22,6 +20,8 @@ use std::borrow::Cow;\n use std::fmt;\n use std::iter;\n \n+mod unnecessary_filter_map;\n+\n #[derive(Clone)]\n pub struct Pass;\n \n@@ -1424,144 +1424,6 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     };\n }\n \n-mod unnecessary_filter_map {\n-    use super::*;\n-\n-    pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n-\n-        if !match_trait_method(cx, expr, &paths::ITERATOR) {\n-            return;\n-        }\n-\n-        if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n-\n-            let body = cx.tcx.hir.body(body_id);\n-            let arg_id = body.arguments[0].pat.id;\n-            let mutates_arg = match mutated_variables(&body.value, cx) {\n-                    Some(used_mutably) => used_mutably.contains(&arg_id),\n-                    None => true,\n-            };\n-\n-            let (mut found_mapping, mut found_filtering) = check_expression(&cx, arg_id, &body.value);\n-\n-            let mut return_visitor = ReturnVisitor::new(&cx, arg_id);\n-            return_visitor.visit_expr(&body.value);\n-            found_mapping |= return_visitor.found_mapping;\n-            found_filtering |= return_visitor.found_filtering;\n-\n-            if !found_filtering {\n-                span_lint(\n-                    cx,\n-                    UNNECESSARY_FILTER_MAP,\n-                    expr.span,\n-                    \"this `.filter_map` can be written more simply using `.map`\",\n-                );\n-                return;\n-            }\n-\n-            if !found_mapping && !mutates_arg {\n-                span_lint(\n-                    cx,\n-                    UNNECESSARY_FILTER_MAP,\n-                    expr.span,\n-                    \"this `.filter_map` can be written more simply using `.filter`\",\n-                );\n-                return;\n-            }\n-        }\n-    }\n-\n-    // returns (found_mapping, found_filtering)\n-    fn check_expression<'a, 'tcx: 'a>(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId, expr: &'tcx hir::Expr) -> (bool, bool) {\n-        match &expr.node {\n-            hir::ExprKind::Call(ref func, ref args) => {\n-                if_chain! {\n-                    if let hir::ExprKind::Path(ref path) = func.node;\n-                    then {\n-                        if match_qpath(path, &paths::OPTION_SOME) {\n-                            if_chain! {\n-                                if let hir::ExprKind::Path(path) = &args[0].node;\n-                                if let Def::Local(ref local) = cx.tables.qpath_def(path, args[0].hir_id);\n-                                then {\n-                                    if arg_id == *local {\n-                                        return (false, false)\n-                                    }\n-                                }\n-                            }\n-                            return (true, false);\n-                        } else {\n-                            // We don't know. It might do anything.\n-                            return (true, true);\n-                        }\n-                    }\n-                }\n-                (true, true)\n-            },\n-            hir::ExprKind::Block(ref block, _) => {\n-                if let Some(expr) = &block.expr {\n-                    check_expression(cx, arg_id, &expr)\n-                } else {\n-                    (false, false)\n-                }\n-            },\n-            // There must be an else_arm or there will be a type error\n-            hir::ExprKind::If(_, ref if_arm, Some(ref else_arm)) => {\n-                let if_check = check_expression(cx, arg_id, if_arm);\n-                let else_check = check_expression(cx, arg_id, else_arm);\n-                (if_check.0 | else_check.0, if_check.1 | else_check.1)\n-            },\n-            hir::ExprKind::Match(_, ref arms, _) => {\n-                let mut found_mapping = false;\n-                let mut found_filtering = false;\n-                for arm in arms {\n-                    let (m, f) = check_expression(cx, arg_id, &arm.body);\n-                    found_mapping |= m;\n-                    found_filtering |= f;\n-                }\n-                (found_mapping, found_filtering)\n-            },\n-            hir::ExprKind::Path(path) if match_qpath(path, &paths::OPTION_NONE) => (false, true),\n-            _ => (true, true)\n-        }\n-    }\n-\n-    struct ReturnVisitor<'a, 'tcx: 'a> {\n-        cx: &'a LateContext<'a, 'tcx>,\n-        arg_id: ast::NodeId,\n-        // Found a non-None return that isn't Some(input)\n-        found_mapping: bool,\n-        // Found a return that isn't Some\n-        found_filtering: bool,\n-    }\n-\n-    impl<'a, 'tcx: 'a> ReturnVisitor<'a, 'tcx> {\n-        fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId) -> ReturnVisitor<'a, 'tcx> {\n-            ReturnVisitor {\n-                cx,\n-                arg_id,\n-                found_mapping: false,\n-                found_filtering: false,\n-            }\n-        }\n-    }\n-\n-    impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-            if let hir::ExprKind::Ret(Some(expr)) = &expr.node {\n-                let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n-                self.found_mapping |= found_mapping;\n-                self.found_filtering |= found_filtering;\n-            } else {\n-                walk_expr(self, expr);\n-            }\n-        }\n-\n-        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-            NestedVisitorMap::None\n-        }\n-    }\n-}\n-\n fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {", "previous_filename": "clippy_lints/src/methods.rs"}, {"sha": "691c08ef0ccaf950ec448526fe9c22d7f41f5a9f", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/efdc739dfc1babd93540bd2d36c91bf2f7d53502/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efdc739dfc1babd93540bd2d36c91bf2f7d53502/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=efdc739dfc1babd93540bd2d36c91bf2f7d53502", "patch": "@@ -0,0 +1,146 @@\n+use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use crate::rustc::lint::LateContext;\n+use crate::rustc::hir;\n+use crate::rustc::hir::def::Def;\n+use crate::syntax::ast;\n+use crate::utils::{match_qpath, match_trait_method, span_lint};\n+use crate::utils::paths;\n+use crate::utils::usage::mutated_variables;\n+\n+use if_chain::if_chain;\n+\n+use super::UNNECESSARY_FILTER_MAP;\n+\n+pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n+\n+    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n+        return;\n+    }\n+\n+    if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n+\n+        let body = cx.tcx.hir.body(body_id);\n+        let arg_id = body.arguments[0].pat.id;\n+        let mutates_arg = match mutated_variables(&body.value, cx) {\n+                Some(used_mutably) => used_mutably.contains(&arg_id),\n+                None => true,\n+        };\n+\n+        let (mut found_mapping, mut found_filtering) = check_expression(&cx, arg_id, &body.value);\n+\n+        let mut return_visitor = ReturnVisitor::new(&cx, arg_id);\n+        return_visitor.visit_expr(&body.value);\n+        found_mapping |= return_visitor.found_mapping;\n+        found_filtering |= return_visitor.found_filtering;\n+\n+        if !found_filtering {\n+            span_lint(\n+                cx,\n+                UNNECESSARY_FILTER_MAP,\n+                expr.span,\n+                \"this `.filter_map` can be written more simply using `.map`\",\n+            );\n+            return;\n+        }\n+\n+        if !found_mapping && !mutates_arg {\n+            span_lint(\n+                cx,\n+                UNNECESSARY_FILTER_MAP,\n+                expr.span,\n+                \"this `.filter_map` can be written more simply using `.filter`\",\n+            );\n+            return;\n+        }\n+    }\n+}\n+\n+// returns (found_mapping, found_filtering)\n+fn check_expression<'a, 'tcx: 'a>(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId, expr: &'tcx hir::Expr) -> (bool, bool) {\n+    match &expr.node {\n+        hir::ExprKind::Call(ref func, ref args) => {\n+            if_chain! {\n+                if let hir::ExprKind::Path(ref path) = func.node;\n+                then {\n+                    if match_qpath(path, &paths::OPTION_SOME) {\n+                        if_chain! {\n+                            if let hir::ExprKind::Path(path) = &args[0].node;\n+                            if let Def::Local(ref local) = cx.tables.qpath_def(path, args[0].hir_id);\n+                            then {\n+                                if arg_id == *local {\n+                                    return (false, false)\n+                                }\n+                            }\n+                        }\n+                        return (true, false);\n+                    } else {\n+                        // We don't know. It might do anything.\n+                        return (true, true);\n+                    }\n+                }\n+            }\n+            (true, true)\n+        },\n+        hir::ExprKind::Block(ref block, _) => {\n+            if let Some(expr) = &block.expr {\n+                check_expression(cx, arg_id, &expr)\n+            } else {\n+                (false, false)\n+            }\n+        },\n+        // There must be an else_arm or there will be a type error\n+        hir::ExprKind::If(_, ref if_arm, Some(ref else_arm)) => {\n+            let if_check = check_expression(cx, arg_id, if_arm);\n+            let else_check = check_expression(cx, arg_id, else_arm);\n+            (if_check.0 | else_check.0, if_check.1 | else_check.1)\n+        },\n+        hir::ExprKind::Match(_, ref arms, _) => {\n+            let mut found_mapping = false;\n+            let mut found_filtering = false;\n+            for arm in arms {\n+                let (m, f) = check_expression(cx, arg_id, &arm.body);\n+                found_mapping |= m;\n+                found_filtering |= f;\n+            }\n+            (found_mapping, found_filtering)\n+        },\n+        hir::ExprKind::Path(path) if match_qpath(path, &paths::OPTION_NONE) => (false, true),\n+        _ => (true, true)\n+    }\n+}\n+\n+struct ReturnVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    arg_id: ast::NodeId,\n+    // Found a non-None return that isn't Some(input)\n+    found_mapping: bool,\n+    // Found a return that isn't Some\n+    found_filtering: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> ReturnVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId) -> ReturnVisitor<'a, 'tcx> {\n+        ReturnVisitor {\n+            cx,\n+            arg_id,\n+            found_mapping: false,\n+            found_filtering: false,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if let hir::ExprKind::Ret(Some(expr)) = &expr.node {\n+            let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n+            self.found_mapping |= found_mapping;\n+            self.found_filtering |= found_filtering;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}"}]}