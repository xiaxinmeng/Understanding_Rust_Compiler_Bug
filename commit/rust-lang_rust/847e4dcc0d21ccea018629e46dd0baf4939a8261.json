{"sha": "847e4dcc0d21ccea018629e46dd0baf4939a8261", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0N2U0ZGNjMGQyMWNjZWEwMTg2MjllNDZkZDBiYWY0OTM5YTgyNjE=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-07-17T04:32:39Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-07-17T04:32:39Z"}, "message": "Merge branch 'master' into issue2894", "tree": {"sha": "98da34959858d67d5bf57fe4c74179e6de827e2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98da34959858d67d5bf57fe4c74179e6de827e2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/847e4dcc0d21ccea018629e46dd0baf4939a8261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/847e4dcc0d21ccea018629e46dd0baf4939a8261", "html_url": "https://github.com/rust-lang/rust/commit/847e4dcc0d21ccea018629e46dd0baf4939a8261", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/847e4dcc0d21ccea018629e46dd0baf4939a8261/comments", "author": null, "committer": null, "parents": [{"sha": "b90fc5edfa4b8f1954f29a47f1e124d1ed29c767", "url": "https://api.github.com/repos/rust-lang/rust/commits/b90fc5edfa4b8f1954f29a47f1e124d1ed29c767", "html_url": "https://github.com/rust-lang/rust/commit/b90fc5edfa4b8f1954f29a47f1e124d1ed29c767"}, {"sha": "f27aaacb9bf1d0d3492f20f92346bb1aaf45e3d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f27aaacb9bf1d0d3492f20f92346bb1aaf45e3d8", "html_url": "https://github.com/rust-lang/rust/commit/f27aaacb9bf1d0d3492f20f92346bb1aaf45e3d8"}], "stats": {"total": 2758, "additions": 1417, "deletions": 1341}, "files": [{"sha": "293418416a27402aba55f759a07f2608d2f051b5", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -93,9 +93,9 @@ a `.stdout` file with the generated code:\n // ./tests/ui/my_lint.stdout\n \n if_chain! {\n-    if let Expr_::ExprArray(ref elements) = stmt.node;\n+    if let ExprKind::Array(ref elements) = stmt.node;\n     if elements.len() == 1;\n-    if let Expr_::ExprLit(ref lit) = elements[0].node;\n+    if let ExprKind::Lit(ref lit) = elements[0].node;\n     if let LitKind::Int(7, _) = lit.node;\n     then {\n         // report your lint here\n@@ -179,7 +179,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n ```\n \n The [`rustc_plugin::PluginRegistry`][plugin_registry] provides two methods to register lints: [register_early_lint_pass][reg_early_lint_pass] and [register_late_lint_pass][reg_late_lint_pass].\n-Both take an object that implements an [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass] respectively. This is done in every single lint. \n+Both take an object that implements an [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass] respectively. This is done in every single lint.\n It's worth noting that the majority of `clippy_lints/src/lib.rs` is autogenerated by `util/update_lints.py` and you don't have to add anything by hand. When you are writing your own lint, you can use that script to save you some time.\n \n ```rust"}, {"sha": "41eacdba1a4a81f0a49e0c48688ac0c6a6553716", "filename": "README.md", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -35,44 +35,46 @@ Table of contents:\n Since this is a tool for helping the developer of a library or application\n write better code, it is recommended not to include Clippy as a hard dependency.\n Options include using it as an optional dependency, as a cargo subcommand, or\n-as an included feature during build. All of these options are detailed below.\n+as an included feature during build. These options are detailed below.\n \n-As a general rule Clippy will only work with the *latest* Rust nightly for now.\n+### As a cargo subcommand (`cargo clippy`)\n \n-To install Rust nightly, the recommended way is to use [rustup](https://rustup.rs/):\n+One way to use Clippy is by installing Clippy through rustup as a cargo\n+subcommand.\n \n-```terminal\n-rustup install nightly\n-```\n+#### Step 1: Install rustup\n \n-### As a cargo subcommand (`cargo clippy`)\n+You can install [rustup](http://rustup.rs/) on supported platforms. This will help\n+us install clippy and its dependencies.\n \n-One way to use Clippy is by installing Clippy through cargo as a cargo\n-subcommand.\n+If you already have rustup installed, update to ensure you have the latest\n+rustup and compiler:\n \n ```terminal\n-cargo +nightly install clippy\n+rustup update\n ```\n \n-(The `+nightly` is not necessary if your default `rustup` install is nightly)\n+#### Step 2: Install nightly toolchain\n \n-Now you can run Clippy by invoking `cargo +nightly clippy`.\n+Rustup integration is still new, you will need a relatively new nightly (2018-07-15 or later).\n \n-To update the subcommand together with the latest nightly use the [rust-update](rust-update) script or run:\n+To install Rust nightly with [rustup](https://rustup.rs/):\n \n ```terminal\n-rustup update nightly\n-cargo +nightly install --force clippy\n+rustup install nightly\n ```\n \n-In case you are not using rustup, you need to set the environment flag\n-`SYSROOT` during installation so Clippy knows where to find `librustc` and\n-similar crates.\n+#### Step 3: Install clippy\n+\n+Once you have rustup and the nightly toolchain installed, run the following command:\n \n ```terminal\n-SYSROOT=/path/to/rustc/sysroot cargo install clippy\n+rustup component add clippy-preview --toolchain=nightly\n ```\n \n+Now you can run Clippy by invoking `cargo +nightly clippy`. If nightly is your\n+default toolchain in rustup, `cargo clippy` will work fine.\n+\n ### Running Clippy from the command line without installing it\n \n To have cargo compile your crate with Clippy without Clippy installation"}, {"sha": "4b304f6f2a6d4c966eeff64f0444072e13fd8677", "filename": "ci/base-tests.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/ci%2Fbase-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/ci%2Fbase-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbase-tests.sh?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -6,6 +6,7 @@ cargo test --features debugging\n mkdir -p ~/rust/cargo/bin\n cp target/debug/cargo-clippy ~/rust/cargo/bin/cargo-clippy\n cp target/debug/clippy-driver ~/rust/cargo/bin/clippy-driver\n+rm ~/.cargo/bin/cargo-clippy\n PATH=$PATH:~/rust/cargo/bin cargo clippy --all -- -D clippy\n cd clippy_workspace_tests && PATH=$PATH:~/rust/cargo/bin cargo clippy -- -D clippy && cd ..\n cd clippy_workspace_tests/src && PATH=$PATH:~/rust/cargo/bin cargo clippy -- -D clippy && cd ../.."}, {"sha": "a989b261ac7a6e4c9431f19efe48206a3fefb5a0", "filename": "ci/integration-tests.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/ci%2Fintegration-tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/ci%2Fintegration-tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fintegration-tests.sh?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,4 +1,5 @@\n set -x\n+rm ~/.cargo/bin/cargo-clippy\n cargo install --force --path .\n \n echo \"Running integration test for crate ${INTEGRATION}\""}, {"sha": "13e1dbe3c0a71fe51680c2221285f2d9b7227d0d", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -63,7 +63,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprLit(ref lit) = e.node {\n+        if let ExprKind::Lit(ref lit) = e.node {\n             check_lit(cx, lit, e);\n         }\n     }"}, {"sha": "0ab7a3388637c70c1a2c7e544594cd997d259969", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -55,21 +55,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n             return;\n         }\n         match expr.node {\n-            hir::ExprBinary(ref op, ref l, ref r) => {\n+            hir::ExprKind::Binary(ref op, ref l, ref r) => {\n                 match op.node {\n-                    hir::BiAnd\n-                    | hir::BiOr\n-                    | hir::BiBitAnd\n-                    | hir::BiBitOr\n-                    | hir::BiBitXor\n-                    | hir::BiShl\n-                    | hir::BiShr\n-                    | hir::BiEq\n-                    | hir::BiLt\n-                    | hir::BiLe\n-                    | hir::BiNe\n-                    | hir::BiGe\n-                    | hir::BiGt => return,\n+                    hir::BinOpKind::And\n+                    | hir::BinOpKind::Or\n+                    | hir::BinOpKind::BitAnd\n+                    | hir::BinOpKind::BitOr\n+                    | hir::BinOpKind::BitXor\n+                    | hir::BinOpKind::Shl\n+                    | hir::BinOpKind::Shr\n+                    | hir::BinOpKind::Eq\n+                    | hir::BinOpKind::Lt\n+                    | hir::BinOpKind::Le\n+                    | hir::BinOpKind::Ne\n+                    | hir::BinOpKind::Ge\n+                    | hir::BinOpKind::Gt => return,\n                     _ => (),\n                 }\n                 let (l_ty, r_ty) = (cx.tables.expr_ty(l), cx.tables.expr_ty(r));\n@@ -81,7 +81,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n                     self.span = Some(expr.span);\n                 }\n             },\n-            hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref arg) => {\n                 let ty = cx.tables.expr_ty(arg);\n                 if ty.is_integral() {\n                     span_lint(cx, INTEGER_ARITHMETIC, expr.span, \"integer arithmetic detected\");"}, {"sha": "272b6c5a84dcfd04adcab71b17c1e56dbb3c5c2b", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -76,7 +76,7 @@ impl LintPass for AssignOps {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {\n                     let lhs = &sugg::Sugg::hir(cx, lhs, \"..\");\n                     let rhs = &sugg::Sugg::hir(cx, rhs, \"..\");\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         format!(\"{} = {}\", lhs, sugg::make_binop(higher::binop(op.node), lhs, rhs)),\n                     );\n                 });\n-                if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n+                if let hir::ExprKind::Binary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs_other: &hir::Expr| {\n                             span_lint_and_then(\n@@ -131,8 +131,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     }\n                 }\n             },\n-            hir::ExprAssign(ref assignee, ref e) => {\n-                if let hir::ExprBinary(op, ref l, ref r) = e.node {\n+            hir::ExprKind::Assign(ref assignee, ref e) => {\n+                if let hir::ExprKind::Binary(op, ref l, ref r) = e.node {\n                     #[allow(cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);\n@@ -142,9 +142,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                              $cx:expr,\n                              $ty:expr,\n                              $rty:expr,\n-                             $($trait_name:ident:$full_trait_name:ident),+) => {\n+                             $($trait_name:ident),+) => {\n                                 match $op {\n-                                    $(hir::$full_trait_name => {\n+                                    $(hir::BinOpKind::$trait_name => {\n                                         let [krate, module] = crate::utils::paths::OPS_MODULE;\n                                         let path = [krate, module, concat!(stringify!($trait_name), \"Assign\")];\n                                         let trait_id = if let Some(trait_id) = get_trait_def_id($cx, &path) {\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         if_chain! {\n                                             if parent_impl != ast::CRATE_NODE_ID;\n                                             if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n-                                            if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) =\n+                                            if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) =\n                                                 item.node;\n                                             if trait_ref.path.def.def_id() == trait_id;\n                                             then { return; }\n@@ -175,18 +175,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                             cx,\n                             ty,\n                             rty.into(),\n-                            Add: BiAdd,\n-                            Sub: BiSub,\n-                            Mul: BiMul,\n-                            Div: BiDiv,\n-                            Rem: BiRem,\n-                            And: BiAnd,\n-                            Or: BiOr,\n-                            BitAnd: BiBitAnd,\n-                            BitOr: BiBitOr,\n-                            BitXor: BiBitXor,\n-                            Shr: BiShr,\n-                            Shl: BiShl\n+                            Add,\n+                            Sub,\n+                            Mul,\n+                            Div,\n+                            Rem,\n+                            And,\n+                            Or,\n+                            BitAnd,\n+                            BitOr,\n+                            BitXor,\n+                            Shr,\n+                            Shl\n                         ) {\n                             span_lint_and_then(\n                                 cx,\n@@ -224,13 +224,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                         // a = b commutative_op a\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r) {\n                             match op.node {\n-                                hir::BiAdd\n-                                | hir::BiMul\n-                                | hir::BiAnd\n-                                | hir::BiOr\n-                                | hir::BiBitXor\n-                                | hir::BiBitAnd\n-                                | hir::BiBitOr => {\n+                                hir::BinOpKind::Add\n+                                | hir::BinOpKind::Mul\n+                                | hir::BinOpKind::And\n+                                | hir::BinOpKind::Or\n+                                | hir::BinOpKind::BitXor\n+                                | hir::BinOpKind::BitAnd\n+                                | hir::BinOpKind::BitOr => {\n                                     lint(assignee, l);\n                                 },\n                                 _ => {},\n@@ -244,11 +244,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     }\n }\n \n-fn is_commutative(op: hir::BinOp_) -> bool {\n-    use rustc::hir::BinOp_::*;\n+fn is_commutative(op: hir::BinOpKind) -> bool {\n+    use rustc::hir::BinOpKind::*;\n     match op {\n-        BiAdd | BiMul | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr | BiEq | BiNe => true,\n-        BiSub | BiDiv | BiRem | BiShl | BiShr | BiLt | BiLe | BiGe | BiGt => false,\n+        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n+        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n     }\n }\n "}, {"sha": "5d5e2f964b09556e00bbe7e02fa70d9a250abce7", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -154,15 +154,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n             check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n         match item.node {\n-            ItemExternCrate(_) | ItemUse(_, _) => {\n+            ItemKind::ExternCrate(_) | ItemKind::Use(_, _) => {\n                 for attr in &item.attrs {\n                     if let Some(ref lint_list) = attr.meta_item_list() {\n                         match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                                 // whitelist `unused_imports` and `deprecated`\n                                 for lint in lint_list {\n                                     if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n-                                        if let ItemUse(_, _) = item.node {\n+                                        if let ItemKind::Use(_, _) = item.node {\n                                             return;\n                                         }\n                                     }\n@@ -207,7 +207,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n }\n \n fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, eid) = item.node {\n+    if let ItemKind::Fn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         true\n@@ -234,8 +234,8 @@ fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match stmt.node {\n-            StmtDecl(_, _) => true,\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n+            StmtKind::Decl(_, _) => true,\n+            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => is_relevant_expr(tcx, tables, expr),\n         }\n     } else {\n         block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n@@ -244,10 +244,10 @@ fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> b\n \n fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBlock(ref block, _) => is_relevant_block(tcx, tables, block),\n-        ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n-        ExprRet(None) | ExprBreak(_, None) => false,\n-        ExprCall(ref path_expr, _) => if let ExprPath(ref qpath) = path_expr.node {\n+        ExprKind::Block(ref block, _) => is_relevant_block(tcx, tables, block),\n+        ExprKind::Ret(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n+        ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n+        ExprKind::Call(ref path_expr, _) => if let ExprKind::Path(ref qpath) = path_expr.node {\n             if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n                 !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n             } else {"}, {"sha": "25d5e4d4db1d573b986d902bad7008fa23cad5a2", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -109,7 +109,7 @@ impl LintPass for BitMask {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n                     check_compare(cx, left, cmp.node, cmp_opt, e.span)\n@@ -119,13 +119,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n             }\n         }\n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref left, ref right) = e.node;\n-            if BinOp_::BiEq == op.node;\n-            if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n-            if BinOp_::BiBitAnd == op1.node;\n-            if let Expr_::ExprLit(ref lit) = right1.node;\n+            if let ExprKind::Binary(ref op, ref left, ref right) = e.node;\n+            if BinOpKind::Eq == op.node;\n+            if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n+            if BinOpKind::BitAnd == op1.node;\n+            if let ExprKind::Lit(ref lit) = right1.node;\n             if let LitKind::Int(n, _) = lit.node;\n-            if let Expr_::ExprLit(ref lit1) = right.node;\n+            if let ExprKind::Lit(ref lit1) = right.node;\n             if let LitKind::Int(0, _) = lit1.node;\n             if n.leading_zeros() == n.count_zeros();\n             if n > u128::from(self.verbose_bit_mask_threshold);\n@@ -143,22 +143,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n     }\n }\n \n-fn invert_cmp(cmp: BinOp_) -> BinOp_ {\n+fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n     match cmp {\n-        BiEq => BiEq,\n-        BiNe => BiNe,\n-        BiLt => BiGt,\n-        BiGt => BiLt,\n-        BiLe => BiGe,\n-        BiGe => BiLe,\n-        _ => BiOr, // Dummy\n+        BinOpKind::Eq => BinOpKind::Eq,\n+        BinOpKind::Ne => BinOpKind::Ne,\n+        BinOpKind::Lt => BinOpKind::Gt,\n+        BinOpKind::Gt => BinOpKind::Lt,\n+        BinOpKind::Le => BinOpKind::Ge,\n+        BinOpKind::Ge => BinOpKind::Le,\n+        _ => BinOpKind::Or, // Dummy\n     }\n }\n \n \n-fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: Span) {\n-    if let ExprBinary(ref op, ref left, ref right) = bit_op.node {\n-        if op.node != BiBitAnd && op.node != BiBitOr {\n+fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n+    if let ExprKind::Binary(ref op, ref left, ref right) = bit_op.node {\n+        if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n         }\n         fetch_int_literal(cx, right)\n@@ -167,10 +167,10 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u12\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: Span) {\n+fn check_bit_mask(cx: &LateContext, bit_op: BinOpKind, cmp_op: BinOpKind, mask_value: u128, cmp_value: u128, span: Span) {\n     match cmp_op {\n-        BiEq | BiNe => match bit_op {\n-            BiBitAnd => if mask_value & cmp_value != cmp_value {\n+        BinOpKind::Eq | BinOpKind::Ne => match bit_op {\n+            BinOpKind::BitAnd => if mask_value & cmp_value != cmp_value {\n                 if cmp_value != 0 {\n                     span_lint(\n                         cx,\n@@ -186,7 +186,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else if mask_value == 0 {\n                 span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n-            BiBitOr => if mask_value | cmp_value != cmp_value {\n+            BinOpKind::BitOr => if mask_value | cmp_value != cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -200,8 +200,8 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             },\n             _ => (),\n         },\n-        BiLt | BiGe => match bit_op {\n-            BiBitAnd => if mask_value < cmp_value {\n+        BinOpKind::Lt | BinOpKind::Ge => match bit_op {\n+            BinOpKind::BitAnd => if mask_value < cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -215,7 +215,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else if mask_value == 0 {\n                 span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n-            BiBitOr => if mask_value >= cmp_value {\n+            BinOpKind::BitOr => if mask_value >= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -229,11 +229,11 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else {\n                 check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n+            BinOpKind::BitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n-        BiLe | BiGt => match bit_op {\n-            BiBitAnd => if mask_value <= cmp_value {\n+        BinOpKind::Le | BinOpKind::Gt => match bit_op {\n+            BinOpKind::BitAnd => if mask_value <= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -247,7 +247,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else if mask_value == 0 {\n                 span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n-            BiBitOr => if mask_value > cmp_value {\n+            BinOpKind::BitOr => if mask_value > cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n@@ -261,7 +261,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n             } else {\n                 check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n+            BinOpKind::BitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n         _ => (),"}, {"sha": "94e17290b6a60991d4ea0f97abacc158f1de5526", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -56,10 +56,10 @@ struct ExVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let ExprClosure(_, _, eid, _, _) = expr.node {\n+        if let ExprKind::Closure(_, _, eid, _, _) = expr.node {\n             let body = self.cx.tcx.hir.body(eid);\n             let ex = &body.value;\n-            if matches!(ex.node, ExprBlock(_, _)) {\n+            if matches!(ex.node, ExprKind::Block(_, _)) {\n                 self.found_block = Some(ex);\n                 return;\n             }\n@@ -77,8 +77,8 @@ const COMPLEX_BLOCK_MESSAGE: &str = \"in an 'if' condition, avoid complex blocks\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIf(ref check, ref then, _) = expr.node {\n-            if let ExprBlock(ref block, _) = check.node {\n+        if let ExprKind::If(ref check, ref then, _) = expr.node {\n+            if let ExprKind::Block(ref block, _) = check.node {\n                 if block.rules == DefaultBlock {\n                     if block.stmts.is_empty() {\n                         if let Some(ref ex) = block.expr {"}, {"sha": "e23978ebc1d476e8c6ab04c45561eb3542fb4055", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -84,9 +84,9 @@ struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n }\n \n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n-    fn extract(&mut self, op: BinOp_, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n+    fn extract(&mut self, op: BinOpKind, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n         for a in a {\n-            if let ExprBinary(binop, ref lhs, ref rhs) = a.node {\n+            if let ExprKind::Binary(binop, ref lhs, ref rhs) = a.node {\n                 if binop.node == op {\n                     v = self.extract(op, &[lhs, rhs], v)?;\n                     continue;\n@@ -101,13 +101,13 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         // prevent folding of `cfg!` macros and the like\n         if !in_macro(e.span) {\n             match e.node {\n-                ExprUnary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n-                ExprBinary(binop, ref lhs, ref rhs) => match binop.node {\n-                    BiOr => return Ok(Bool::Or(self.extract(BiOr, &[lhs, rhs], Vec::new())?)),\n-                    BiAnd => return Ok(Bool::And(self.extract(BiAnd, &[lhs, rhs], Vec::new())?)),\n+                ExprKind::Unary(UnNot, ref inner) => return Ok(Bool::Not(box self.run(inner)?)),\n+                ExprKind::Binary(binop, ref lhs, ref rhs) => match binop.node {\n+                    BinOpKind::Or => return Ok(Bool::Or(self.extract(BinOpKind::Or, &[lhs, rhs], Vec::new())?)),\n+                    BinOpKind::And => return Ok(Bool::And(self.extract(BinOpKind::And, &[lhs, rhs], Vec::new())?)),\n                     _ => (),\n                 },\n-                ExprLit(ref lit) => match lit.node {\n+                ExprKind::Lit(ref lit) => match lit.node {\n                     LitKind::Bool(true) => return Ok(Bool::True),\n                     LitKind::Bool(false) => return Ok(Bool::False),\n                     _ => (),\n@@ -121,8 +121,8 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                 return Ok(Bool::Term(n as u8));\n             }\n             let negated = match e.node {\n-                ExprBinary(binop, ref lhs, ref rhs) => {\n- \n+                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+\n                     if !implements_ord(self.cx, lhs) {\n                         continue;\n                     }\n@@ -133,16 +133,16 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n                             hir_id: DUMMY_HIR_ID,\n                             span: DUMMY_SP,\n                             attrs: ThinVec::new(),\n-                            node: ExprBinary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n+                            node: ExprKind::Binary(dummy_spanned(op), lhs.clone(), rhs.clone()),\n                         }\n                     };\n                     match binop.node {\n-                        BiEq => mk_expr(BiNe),\n-                        BiNe => mk_expr(BiEq),\n-                        BiGt => mk_expr(BiLe),\n-                        BiGe => mk_expr(BiLt),\n-                        BiLt => mk_expr(BiGe),\n-                        BiLe => mk_expr(BiGt),\n+                        BinOpKind::Eq => mk_expr(BinOpKind::Ne),\n+                        BinOpKind::Ne => mk_expr(BinOpKind::Eq),\n+                        BinOpKind::Gt => mk_expr(BinOpKind::Le),\n+                        BinOpKind::Ge => mk_expr(BinOpKind::Lt),\n+                        BinOpKind::Lt => mk_expr(BinOpKind::Ge),\n+                        BinOpKind::Le => mk_expr(BinOpKind::Gt),\n                         _ => continue,\n                     }\n                 },\n@@ -178,23 +178,23 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n \n     fn simplify_not(&self, expr: &Expr) -> Option<String> {\n         match expr.node {\n-            ExprBinary(binop, ref lhs, ref rhs) => {\n+            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n \n                 if !implements_ord(self.cx, lhs) {\n                     return None;\n                 }\n \n                 match binop.node {\n-                    BiEq => Some(\" != \"),\n-                    BiNe => Some(\" == \"),\n-                    BiLt => Some(\" >= \"),\n-                    BiGt => Some(\" <= \"),\n-                    BiLe => Some(\" > \"),\n-                    BiGe => Some(\" < \"),\n+                    BinOpKind::Eq => Some(\" != \"),\n+                    BinOpKind::Ne => Some(\" == \"),\n+                    BinOpKind::Lt => Some(\" >= \"),\n+                    BinOpKind::Gt => Some(\" <= \"),\n+                    BinOpKind::Le => Some(\" > \"),\n+                    BinOpKind::Ge => Some(\" < \"),\n                     _ => None,\n                 }.and_then(|op| Some(format!(\"{}{}{}\", self.snip(lhs)?, op, self.snip(rhs)?)))\n             },\n-            ExprMethodCall(ref path, _, ref args) if args.len() == 1 => {\n+            ExprKind::MethodCall(ref path, _, ref args) if args.len() == 1 => {\n                 let type_of_receiver = self.cx.tables.expr_ty(&args[0]);\n                 if !match_type(self.cx, type_of_receiver, &paths::OPTION) &&\n                     !match_type(self.cx, type_of_receiver, &paths::RESULT) {\n@@ -441,8 +441,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n             return;\n         }\n         match e.node {\n-            ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n-            ExprUnary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n+            ExprKind::Binary(binop, _, _) if binop.node == BinOpKind::Or || binop.node == BinOpKind::And => self.bool_expr(e),\n+            ExprKind::Unary(UnNot, ref inner) => if self.cx.tables.node_types()[inner.hir_id].is_bool() {\n                 self.bool_expr(e);\n             } else {\n                 walk_expr(self, e);"}, {"sha": "aaa924e95b1ec923b0f306c8879eebcada2d7521", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -38,20 +38,20 @@ impl LintPass for ByteCount {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_chain! {\n-            if let ExprMethodCall(ref count, _, ref count_args) = expr.node;\n+            if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.node;\n             if count.ident.name == \"count\";\n             if count_args.len() == 1;\n-            if let ExprMethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n+            if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n             if filter.ident.name == \"filter\";\n             if filter_args.len() == 2;\n-            if let ExprClosure(_, _, body_id, _, _) = filter_args[1].node;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].node;\n             then {\n                 let body = cx.tcx.hir.body(body_id);\n                 if_chain! {\n                     if body.arguments.len() == 1;\n                     if let Some(argname) = get_pat_name(&body.arguments[0].pat);\n-                    if let ExprBinary(ref op, ref l, ref r) = body.value.node;\n-                    if op.node == BiEq;\n+                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.node;\n+                    if op.node == BinOpKind::Eq;\n                     if match_type(cx,\n                                walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n                                &paths::SLICE_ITER);\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n                             return;\n                         }\n-                        let haystack = if let ExprMethodCall(ref path, _, ref args) =\n+                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args) =\n                                 filter_args[0].node {\n                             let p = path.ident.name;\n                             if (p == \"iter\" || p == \"iter_mut\") && args.len() == 1 {\n@@ -98,13 +98,13 @@ fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n \n fn get_path_name(expr: &Expr) -> Option<Name> {\n     match expr.node {\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) | ExprUnary(UnOp::UnDeref, ref e) => get_path_name(e),\n-        ExprBlock(ref b, _) => if b.stmts.is_empty() {\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => get_path_name(e),\n+        ExprKind::Block(ref b, _) => if b.stmts.is_empty() {\n             b.expr.as_ref().and_then(|p| get_path_name(p))\n         } else {\n             None\n         },\n-        ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n+        ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n         _ => None,\n     }\n }"}, {"sha": "d7323337f2472023314bf207c19a5b103da1bc87", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -211,25 +211,25 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// simple constant folding: Insert an expression, get a constant or none.\n     pub fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n-            ExprPath(ref qpath) => self.fetch_path(qpath, e.hir_id),\n-            ExprBlock(ref block, _) => self.block(block),\n-            ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n-            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n-            ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n-            ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprRepeat(ref value, _) => {\n+            ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id),\n+            ExprKind::Block(ref block, _) => self.block(block),\n+            ExprKind::If(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n+            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n+            ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n+            ExprKind::Repeat(ref value, _) => {\n                 let n = match self.tables.expr_ty(e).sty {\n                     ty::TyArray(_, n) => n.assert_usize(self.tcx).expect(\"array length\"),\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n                 self.expr(value).map(|v| Constant::Repeat(Box::new(v), n as u64))\n             },\n-            ExprUnary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n+            ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n                 UnNot => self.constant_not(&o, self.tables.expr_ty(e)),\n                 UnNeg => self.constant_negate(&o, self.tables.expr_ty(e)),\n                 UnDeref => Some(o),\n             }),\n-            ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n+            ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n             // TODO: add other expressions\n             _ => None,\n         }\n@@ -279,7 +279,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             .collect::<Option<_>>()\n     }\n \n-    /// lookup a possibly constant expression from a ExprPath\n+    /// lookup a possibly constant expression from a ExprKind::Path\n     fn fetch_path(&mut self, qpath: &QPath, id: HirId) -> Option<Constant> {\n         let def = self.tables.qpath_def(qpath, id);\n         match def {\n@@ -340,84 +340,84 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                         let r = sext(self.tcx, r, ity);\n                         let zext = |n: i128| Constant::Int(unsext(self.tcx, n, ity));\n                         match op.node {\n-                            BiAdd => l.checked_add(r).map(zext),\n-                            BiSub => l.checked_sub(r).map(zext),\n-                            BiMul => l.checked_mul(r).map(zext),\n-                            BiDiv if r != 0 => l.checked_div(r).map(zext),\n-                            BiRem if r != 0 => l.checked_rem(r).map(zext),\n-                            BiShr => l.checked_shr(r as u128 as u32).map(zext),\n-                            BiShl => l.checked_shl(r as u128 as u32).map(zext),\n-                            BiBitXor => Some(zext(l ^ r)),\n-                            BiBitOr => Some(zext(l | r)),\n-                            BiBitAnd => Some(zext(l & r)),\n-                            BiEq => Some(Constant::Bool(l == r)),\n-                            BiNe => Some(Constant::Bool(l != r)),\n-                            BiLt => Some(Constant::Bool(l < r)),\n-                            BiLe => Some(Constant::Bool(l <= r)),\n-                            BiGe => Some(Constant::Bool(l >= r)),\n-                            BiGt => Some(Constant::Bool(l > r)),\n+                            BinOpKind::Add => l.checked_add(r).map(zext),\n+                            BinOpKind::Sub => l.checked_sub(r).map(zext),\n+                            BinOpKind::Mul => l.checked_mul(r).map(zext),\n+                            BinOpKind::Div if r != 0 => l.checked_div(r).map(zext),\n+                            BinOpKind::Rem if r != 0 => l.checked_rem(r).map(zext),\n+                            BinOpKind::Shr => l.checked_shr(r as u128 as u32).map(zext),\n+                            BinOpKind::Shl => l.checked_shl(r as u128 as u32).map(zext),\n+                            BinOpKind::BitXor => Some(zext(l ^ r)),\n+                            BinOpKind::BitOr => Some(zext(l | r)),\n+                            BinOpKind::BitAnd => Some(zext(l & r)),\n+                            BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                            BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                            BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                            BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                            BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                            BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                             _ => None,\n                         }\n                     }\n                     ty::TyUint(_) => {\n                         match op.node {\n-                            BiAdd => l.checked_add(r).map(Constant::Int),\n-                            BiSub => l.checked_sub(r).map(Constant::Int),\n-                            BiMul => l.checked_mul(r).map(Constant::Int),\n-                            BiDiv => l.checked_div(r).map(Constant::Int),\n-                            BiRem => l.checked_rem(r).map(Constant::Int),\n-                            BiShr => l.checked_shr(r as u32).map(Constant::Int),\n-                            BiShl => l.checked_shl(r as u32).map(Constant::Int),\n-                            BiBitXor => Some(Constant::Int(l ^ r)),\n-                            BiBitOr => Some(Constant::Int(l | r)),\n-                            BiBitAnd => Some(Constant::Int(l & r)),\n-                            BiEq => Some(Constant::Bool(l == r)),\n-                            BiNe => Some(Constant::Bool(l != r)),\n-                            BiLt => Some(Constant::Bool(l < r)),\n-                            BiLe => Some(Constant::Bool(l <= r)),\n-                            BiGe => Some(Constant::Bool(l >= r)),\n-                            BiGt => Some(Constant::Bool(l > r)),\n+                            BinOpKind::Add => l.checked_add(r).map(Constant::Int),\n+                            BinOpKind::Sub => l.checked_sub(r).map(Constant::Int),\n+                            BinOpKind::Mul => l.checked_mul(r).map(Constant::Int),\n+                            BinOpKind::Div => l.checked_div(r).map(Constant::Int),\n+                            BinOpKind::Rem => l.checked_rem(r).map(Constant::Int),\n+                            BinOpKind::Shr => l.checked_shr(r as u32).map(Constant::Int),\n+                            BinOpKind::Shl => l.checked_shl(r as u32).map(Constant::Int),\n+                            BinOpKind::BitXor => Some(Constant::Int(l ^ r)),\n+                            BinOpKind::BitOr => Some(Constant::Int(l | r)),\n+                            BinOpKind::BitAnd => Some(Constant::Int(l & r)),\n+                            BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                            BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                            BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                            BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                            BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                            BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                             _ => None,\n                         }\n                     },\n                     _ => None,\n                 }\n             },\n             (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n-                BiAdd => Some(Constant::F32(l + r)),\n-                BiSub => Some(Constant::F32(l - r)),\n-                BiMul => Some(Constant::F32(l * r)),\n-                BiDiv => Some(Constant::F32(l / r)),\n-                BiRem => Some(Constant::F32(l % r)),\n-                BiEq => Some(Constant::Bool(l == r)),\n-                BiNe => Some(Constant::Bool(l != r)),\n-                BiLt => Some(Constant::Bool(l < r)),\n-                BiLe => Some(Constant::Bool(l <= r)),\n-                BiGe => Some(Constant::Bool(l >= r)),\n-                BiGt => Some(Constant::Bool(l > r)),\n+                BinOpKind::Add => Some(Constant::F32(l + r)),\n+                BinOpKind::Sub => Some(Constant::F32(l - r)),\n+                BinOpKind::Mul => Some(Constant::F32(l * r)),\n+                BinOpKind::Div => Some(Constant::F32(l / r)),\n+                BinOpKind::Rem => Some(Constant::F32(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                 _ => None,\n             },\n             (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n-                BiAdd => Some(Constant::F64(l + r)),\n-                BiSub => Some(Constant::F64(l - r)),\n-                BiMul => Some(Constant::F64(l * r)),\n-                BiDiv => Some(Constant::F64(l / r)),\n-                BiRem => Some(Constant::F64(l % r)),\n-                BiEq => Some(Constant::Bool(l == r)),\n-                BiNe => Some(Constant::Bool(l != r)),\n-                BiLt => Some(Constant::Bool(l < r)),\n-                BiLe => Some(Constant::Bool(l <= r)),\n-                BiGe => Some(Constant::Bool(l >= r)),\n-                BiGt => Some(Constant::Bool(l > r)),\n+                BinOpKind::Add => Some(Constant::F64(l + r)),\n+                BinOpKind::Sub => Some(Constant::F64(l - r)),\n+                BinOpKind::Mul => Some(Constant::F64(l * r)),\n+                BinOpKind::Div => Some(Constant::F64(l / r)),\n+                BinOpKind::Rem => Some(Constant::F64(l % r)),\n+                BinOpKind::Eq => Some(Constant::Bool(l == r)),\n+                BinOpKind::Ne => Some(Constant::Bool(l != r)),\n+                BinOpKind::Lt => Some(Constant::Bool(l < r)),\n+                BinOpKind::Le => Some(Constant::Bool(l <= r)),\n+                BinOpKind::Ge => Some(Constant::Bool(l >= r)),\n+                BinOpKind::Gt => Some(Constant::Bool(l > r)),\n                 _ => None,\n             },\n             (l, r) => match (op.node, l, r) {\n-                (BiAnd, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n-                (BiOr, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-                (BiAnd, Constant::Bool(true), Some(r)) | (BiOr, Constant::Bool(false), Some(r)) => Some(r),\n-                (BiBitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n-                (BiBitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n-                (BiBitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+                (BinOpKind::And, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+                (BinOpKind::Or, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+                (BinOpKind::And, Constant::Bool(true), Some(r)) | (BinOpKind::Or, Constant::Bool(false), Some(r)) => Some(r),\n+                (BinOpKind::BitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+                (BinOpKind::BitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+                (BinOpKind::BitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n                 _ => None,\n             },\n         }"}, {"sha": "9e9a641ce27e3bc893291ea9f6e96af1850e4275", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n         if !in_macro(expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(&Expr {\n-                node: ExprIf(_, _, Some(ref else_expr)),\n+                node: ExprKind::If(_, _, Some(ref else_expr)),\n                 ..\n             }) = get_parent_expr(cx, expr)\n             {\n@@ -172,7 +172,7 @@ fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n-    if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n+    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.node {\n         let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n             let mut h = SpanlessHash::new(cx, cx.tables);\n             h.hash_expr(&arm.body);\n@@ -236,12 +236,12 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n     let mut conds = SmallVector::new();\n     let mut blocks: SmallVector<&Block> = SmallVector::new();\n \n-    while let ExprIf(ref cond, ref then_expr, ref else_expr) = expr.node {\n+    while let ExprKind::If(ref cond, ref then_expr, ref else_expr) = expr.node {\n         conds.push(&**cond);\n-        if let ExprBlock(ref block, _) = then_expr.node {\n+        if let ExprKind::Block(ref block, _) = then_expr.node {\n             blocks.push(block);\n         } else {\n-            panic!(\"ExprIf node is not an ExprBlock\");\n+            panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n         if let Some(ref else_expr) = *else_expr {\n@@ -253,7 +253,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n \n     // final `else {..}`\n     if !blocks.is_empty() {\n-        if let ExprBlock(ref block, _) = expr.node {\n+        if let ExprKind::Block(ref block, _) = expr.node {\n             blocks.push(&**block);\n         }\n     }"}, {"sha": "b1b667d046ca7e738f6d90395ac6bbd4e3595ed3", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -147,14 +147,14 @@ struct CCHelper<'a, 'tcx: 'a> {\n impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprMatch(_, ref arms, _) => {\n+            ExprKind::Match(_, ref arms, _) => {\n                 walk_expr(self, e);\n                 let arms_n: u64 = arms.iter().map(|arm| arm.pats.len() as u64).sum();\n                 if arms_n > 1 {\n                     self.match_arms += arms_n - 2;\n                 }\n             },\n-            ExprCall(ref callee, _) => {\n+            ExprKind::Call(ref callee, _) => {\n                 walk_expr(self, e);\n                 let ty = self.cx.tables.node_id_to_type(callee.hir_id);\n                 match ty.sty {\n@@ -167,15 +167,15 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n                     _ => (),\n                 }\n             },\n-            ExprClosure(.., _) => (),\n-            ExprBinary(op, _, _) => {\n+            ExprKind::Closure(.., _) => (),\n+            ExprKind::Binary(op, _, _) => {\n                 walk_expr(self, e);\n                 match op.node {\n-                    BiAnd | BiOr => self.short_circuits += 1,\n+                    BinOpKind::And | BinOpKind::Or => self.short_circuits += 1,\n                     _ => (),\n                 }\n             },\n-            ExprRet(_) => self.returns += 1,\n+            ExprKind::Ret(_) => self.returns += 1,\n             _ => walk_expr(self, e),\n         }\n     }"}, {"sha": "900dabc96505b44232ca56faddad0285e00e411c", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -38,9 +38,9 @@ impl LintPass for DefaultTraitAccess {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ..) = expr.node;\n+            if let ExprKind::Call(ref path, ..) = expr.node;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.id);\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             if match_def_path(cx.tcx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             then {"}, {"sha": "0d0eb27fb7dba6633bdd988af6e126348b207360", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -70,7 +70,7 @@ impl LintPass for Derive {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n             let ty = cx.tcx.type_of(cx.tcx.hir.local_def_id(item.id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n "}, {"sha": "e2ea5723a98e0a7303237127cfc1c58744249ee3", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -41,13 +41,13 @@ impl<'a, 'tcx> DoubleComparisonPass {\n     fn check_binop(\n         &self,\n         cx: &LateContext<'a, 'tcx>,\n-        op: BinOp_,\n+        op: BinOpKind,\n         lhs: &'tcx Expr,\n         rhs: &'tcx Expr,\n         span: Span,\n     ) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (lhs.node.clone(), rhs.node.clone()) {\n-            (ExprBinary(lb, llhs, lrhs), ExprBinary(rb, rlhs, rrhs)) => {\n+            (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n             }\n             _ => return,\n@@ -67,18 +67,18 @@ impl<'a, 'tcx> DoubleComparisonPass {\n             }}\n         }\n         match (op, lkind, rkind) {\n-            (BiOr, BiEq, BiLt) | (BiOr, BiLt, BiEq) => lint_double_comparison!(<=),\n-            (BiOr, BiEq, BiGt) | (BiOr, BiGt, BiEq) => lint_double_comparison!(>=),\n-            (BiOr, BiLt, BiGt) | (BiOr, BiGt, BiLt) => lint_double_comparison!(!=),\n-            (BiAnd, BiLe, BiGe) | (BiAnd, BiGe, BiLe) => lint_double_comparison!(==),\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Lt) | (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Eq) => lint_double_comparison!(<=),\n+            (BinOpKind::Or, BinOpKind::Eq, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Eq) => lint_double_comparison!(>=),\n+            (BinOpKind::Or, BinOpKind::Lt, BinOpKind::Gt) | (BinOpKind::Or, BinOpKind::Gt, BinOpKind::Lt) => lint_double_comparison!(!=),\n+            (BinOpKind::And, BinOpKind::Le, BinOpKind::Ge) | (BinOpKind::And, BinOpKind::Ge, BinOpKind::Le) => lint_double_comparison!(==),\n             _ => (),\n         };\n     }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisonPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref kind, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.node {\n             self.check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }\n     }"}, {"sha": "b0625e10d761d249dd02b8fc0668d5bbeee6dbe1", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -116,8 +116,8 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Call(ref path, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 1;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             then {"}, {"sha": "d374973e35b4d84f7531a26423d567f0da81c0c2", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -38,8 +38,8 @@ impl LintPass for DurationSubsec {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprBinary(Spanned { node: BiDiv, .. }, ref left, ref right) = expr.node;\n-            if let ExprMethodCall(ref method_path, _ , ref args) = left.node;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.node;\n+            if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.node;\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n             then {"}, {"sha": "1ca32cf2263ed65eb8acfbeb8b5dc074d589c5b9", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -34,7 +34,7 @@ impl LintPass for EmptyEnum {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n-        if let ItemEnum(..) = item.node {\n+        if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def()\n                 .expect(\"already checked whether this is an enum\");"}, {"sha": "f29c2d1bb6d0e26bb895a25558b6349b4157a9c6", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -41,13 +41,13 @@ impl LintPass for HashMapLint {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIf(ref check, ref then_block, ref else_block) = expr.node {\n-            if let ExprUnary(UnOp::UnNot, ref check) = check.node {\n+        if let ExprKind::If(ref check, ref then_block, ref else_block) = expr.node {\n+            if let ExprKind::Unary(UnOp::UnNot, ref check) = check.node {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n-                        else_block.is_none() && if let ExprBlock(ref then_block, _) = then_block.node {\n+                        else_block.is_none() && if let ExprKind::Block(ref then_block, _) = then_block.node {\n                             (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n                         } else {\n                             true\n@@ -88,10 +88,10 @@ fn check_cond<'a, 'tcx, 'b>(\n     check: &'b Expr,\n ) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n     if_chain! {\n-        if let ExprMethodCall(ref path, _, ref params) = check.node;\n+        if let ExprKind::MethodCall(ref path, _, ref params) = check.node;\n         if params.len() >= 2;\n         if path.ident.name == \"contains_key\";\n-        if let ExprAddrOf(_, ref key) = params[1].node;\n+        if let ExprKind::AddrOf(_, ref key) = params[1].node;\n         then {\n             let map = &params[0];\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n@@ -123,7 +123,7 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprMethodCall(ref path, _, ref params) = expr.node;\n+            if let ExprKind::MethodCall(ref path, _, ref params) = expr.node;\n             if params.len() == 3;\n             if path.ident.name == \"insert\";\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);"}, {"sha": "6584bc6ffa95adeb6a13fa3fa829f0d9dc99057f", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n         if cx.tcx.data_layout.pointer_size.bits() != 64 {\n             return;\n         }\n-        if let ItemEnum(ref def, _) = item.node {\n+        if let ItemKind::Enum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;\n                 if let Some(ref anon_const) = variant.disr_expr {"}, {"sha": "042a96a21c851f585d27a2fefed233f322ffddf7", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -44,10 +44,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n \n impl EnumGlobUse {\n     fn lint_item(&self, cx: &LateContext, item: &Item) {\n-        if item.vis.node == VisibilityKind::Public {\n+        if item.vis.node.is_pub() {\n             return; // re-exports are fine\n         }\n-        if let ItemUse(ref path, UseKind::Glob) = item.node {\n+        if let ItemKind::Use(ref path, UseKind::Glob) = item.node {\n             if let Def::Enum(_) = path.def {\n                 span_lint(\n                     cx,"}, {"sha": "d272cab0a0df941174593b27472ce6e3b939c8a5", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -262,7 +262,7 @@ impl EarlyLintPass for EnumVariantNames {\n                             );\n                         }\n                     }\n-                    if item.vis.node == VisibilityKind::Public {\n+                    if item.vis.node.is_pub() {\n                         let matching = partial_match(mod_camel, &item_camel);\n                         let rmatching = partial_rmatch(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();"}, {"sha": "f58b499d8065688f0e9d192dd50053afd3775403", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -52,7 +52,7 @@ impl LintPass for EqOp {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(op, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(op, ref left, ref right) = e.node {\n             if in_macro(e.span) {\n                 return;\n             }\n@@ -66,28 +66,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 return;\n             }\n             let (trait_id, requires_ref) = match op.node {\n-                BiAdd => (cx.tcx.lang_items().add_trait(), false),\n-                BiSub => (cx.tcx.lang_items().sub_trait(), false),\n-                BiMul => (cx.tcx.lang_items().mul_trait(), false),\n-                BiDiv => (cx.tcx.lang_items().div_trait(), false),\n-                BiRem => (cx.tcx.lang_items().rem_trait(), false),\n+                BinOpKind::Add => (cx.tcx.lang_items().add_trait(), false),\n+                BinOpKind::Sub => (cx.tcx.lang_items().sub_trait(), false),\n+                BinOpKind::Mul => (cx.tcx.lang_items().mul_trait(), false),\n+                BinOpKind::Div => (cx.tcx.lang_items().div_trait(), false),\n+                BinOpKind::Rem => (cx.tcx.lang_items().rem_trait(), false),\n                 // don't lint short circuiting ops\n-                BiAnd | BiOr => return,\n-                BiBitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n-                BiBitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n-                BiBitOr => (cx.tcx.lang_items().bitor_trait(), false),\n-                BiShl => (cx.tcx.lang_items().shl_trait(), false),\n-                BiShr => (cx.tcx.lang_items().shr_trait(), false),\n-                BiNe | BiEq => (cx.tcx.lang_items().eq_trait(), true),\n-                BiLt | BiLe | BiGe | BiGt => (cx.tcx.lang_items().ord_trait(), true),\n+                BinOpKind::And | BinOpKind::Or => return,\n+                BinOpKind::BitXor => (cx.tcx.lang_items().bitxor_trait(), false),\n+                BinOpKind::BitAnd => (cx.tcx.lang_items().bitand_trait(), false),\n+                BinOpKind::BitOr => (cx.tcx.lang_items().bitor_trait(), false),\n+                BinOpKind::Shl => (cx.tcx.lang_items().shl_trait(), false),\n+                BinOpKind::Shr => (cx.tcx.lang_items().shr_trait(), false),\n+                BinOpKind::Ne | BinOpKind::Eq => (cx.tcx.lang_items().eq_trait(), true),\n+                BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ge | BinOpKind::Gt => (cx.tcx.lang_items().ord_trait(), true),\n             };\n             if let Some(trait_id) = trait_id {\n                 #[allow(match_same_arms)]\n                 match (&left.node, &right.node) {\n                     // do not suggest to dereference literals\n-                    (&ExprLit(..), _) | (_, &ExprLit(..)) => {},\n+                    (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n-                    (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n+                    (&ExprKind::AddrOf(_, ref l), &ExprKind::AddrOf(_, ref r)) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let rty = cx.tables.expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         }\n                     },\n                     // &foo == bar\n-                    (&ExprAddrOf(_, ref l), _) => {\n+                    (&ExprKind::AddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right).into()]) {\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         }\n                     },\n                     // foo == &bar\n-                    (_, &ExprAddrOf(_, ref r)) => {\n+                    (_, &ExprKind::AddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty.into()]) {\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n \n fn is_valid_operator(op: BinOp) -> bool {\n     match op.node {\n-        BiSub | BiDiv | BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n+        BinOpKind::Sub | BinOpKind::Div | BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Gt | BinOpKind::Ge | BinOpKind::Ne | BinOpKind::And | BinOpKind::Or | BinOpKind::BitXor | BinOpKind::BitAnd | BinOpKind::BitOr => true,\n         _ => false,\n     }\n }"}, {"sha": "acede5d1a132fdd2698e9f73276de8092a793706", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -36,13 +36,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n-                BiMul | BiBitAnd => {\n+                BinOpKind::Mul | BinOpKind::BitAnd => {\n                     check(cx, left, e.span);\n                     check(cx, right, e.span);\n                 },\n-                BiDiv => check(cx, left, e.span),\n+                BinOpKind::Div => check(cx, left, e.span),\n                 _ => (),\n             }\n         }"}, {"sha": "a03dc7b62690c15941ce4dcebeb0a255245b6a3a", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -110,10 +110,10 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         if let Categorization::Rvalue(..) = cmt.cat {\n             let id = map.hir_to_node_id(cmt.hir_id);\n             if let Some(NodeStmt(st)) = map.find(map.get_parent_node(id)) {\n-                if let StmtDecl(ref decl, _) = st.node {\n-                    if let DeclLocal(ref loc) = decl.node {\n+                if let StmtKind::Decl(ref decl, _) = st.node {\n+                    if let DeclKind::Local(ref loc) = decl.node {\n                         if let Some(ref ex) = loc.init {\n-                            if let ExprBox(..) = ex.node {\n+                            if let ExprKind::Box(..) = ex.node {\n                                 if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                                     // let x = box (...)\n                                     self.set.insert(consume_pat.id);"}, {"sha": "87f0e64caafa60f282aa4c18d01ca9fd710cebde", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -37,7 +37,7 @@ impl LintPass for EtaPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => for arg in args {\n+            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => for arg in args {\n                 check_closure(cx, arg)\n             },\n             _ => (),\n@@ -46,10 +46,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n }\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, eid, _, _) = expr.node {\n+    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n         let body = cx.tcx.hir.body(eid);\n         let ex = &body.value;\n-        if let ExprCall(ref caller, ref args) = ex.node {\n+        if let ExprKind::Call(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n                 // is no way the closure is the same as the function\n@@ -73,7 +73,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n             for (a1, a2) in iter_input_pats(decl, body).zip(args) {\n                 if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n+                    if let ExprKind::Path(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {\n                             // If it's a proper path, it can't be a local variable\n                             return;"}, {"sha": "58436bd897bb95e31ab0367b551a700a0f8dcdef", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n-            ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => if let ExprPath(ref qpath) = lhs.node {\n+            ExprKind::Assign(ref lhs, _) | ExprKind::AssignOp(_, ref lhs, _) => if let ExprKind::Path(ref qpath) = lhs.node {\n                 if let QPath::Resolved(_, ref path) = *qpath {\n                     if path.segments.len() == 1 {\n                         if let def::Def::Local(var) = cx.tables.qpath_def(qpath, lhs.hir_id) {\n@@ -82,8 +82,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n-            StmtDecl(ref d, _) => if let DeclLocal(ref local) = d.node {\n+            StmtKind::Expr(ref e, _) | StmtKind::Semi(ref e, _) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n+            StmtKind::Decl(ref d, _) => if let DeclKind::Local(ref local) = d.node {\n                 if let Local {\n                     init: Some(ref e), ..\n                 } = **local\n@@ -102,8 +102,8 @@ struct DivergenceVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprClosure(.., _) => {},\n-            ExprMatch(ref e, ref arms, _) => {\n+            ExprKind::Closure(.., _) => {},\n+            ExprKind::Match(ref e, ref arms, _) => {\n                 self.visit_expr(e);\n                 for arm in arms {\n                     if let Some(ref guard) = arm.guard {\n@@ -124,8 +124,8 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n-            ExprContinue(_) | ExprBreak(_, _) | ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => {\n+            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n+            ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.tables.expr_ty(func);\n                 match typ.sty {\n                     ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                     _ => {},\n                 }\n             },\n-            ExprMethodCall(..) => {\n+            ExprKind::MethodCall(..) => {\n                 let borrowed_table = self.cx.tables;\n                 if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n@@ -218,25 +218,25 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n     }\n \n     match expr.node {\n-        ExprArray(_) |\n-        ExprTup(_) |\n-        ExprMethodCall(..) |\n-        ExprCall(_, _) |\n-        ExprAssign(_, _) |\n-        ExprIndex(_, _) |\n-        ExprRepeat(_, _) |\n-        ExprStruct(_, _, _) => {\n+        ExprKind::Array(_) |\n+        ExprKind::Tup(_) |\n+        ExprKind::MethodCall(..) |\n+        ExprKind::Call(_, _) |\n+        ExprKind::Assign(_, _) |\n+        ExprKind::Index(_, _) |\n+        ExprKind::Repeat(_, _) |\n+        ExprKind::Struct(_, _, _) => {\n             walk_expr(vis, expr);\n         },\n-        ExprBinary(op, _, _) | ExprAssignOp(op, _, _) => {\n-            if op.node == BiAnd || op.node == BiOr {\n+        ExprKind::Binary(op, _, _) | ExprKind::AssignOp(op, _, _) => {\n+            if op.node == BinOpKind::And || op.node == BinOpKind::Or {\n                 // x && y and x || y always evaluate x first, so these are\n                 // strictly sequenced.\n             } else {\n                 walk_expr(vis, expr);\n             }\n         },\n-        ExprClosure(_, _, _, _, _) => {\n+        ExprKind::Closure(_, _, _, _, _) => {\n             // Either\n             //\n             // * `var` is defined in the closure body, in which case we've\n@@ -262,12 +262,12 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n \n fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n     match stmt.node {\n-        StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => check_expr(vis, expr),\n-        StmtDecl(ref decl, _) => {\n+        StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => check_expr(vis, expr),\n+        StmtKind::Decl(ref decl, _) => {\n             // If the declaration is of a local variable, check its initializer\n             // expression if it has one. Otherwise, keep going.\n             let local = match decl.node {\n-                DeclLocal(ref local) => Some(local),\n+                DeclKind::Local(ref local) => Some(local),\n                 _ => None,\n             };\n             local\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n         }\n \n         match expr.node {\n-            ExprPath(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 if_chain! {\n                     if let QPath::Resolved(None, ref path) = *qpath;\n                     if path.segments.len() == 1;\n@@ -320,7 +320,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             // We're about to descend a closure. Since we don't know when (or\n             // if) the closure will be evaluated, any reads in it might not\n             // occur here (or ever). Like above, bail to avoid false positives.\n-            ExprClosure(_, _, _, _, _) |\n+            ExprKind::Closure(_, _, _, _, _) |\n \n             // We want to avoid a false positive when a variable name occurs\n             // only to have its address taken, so we stop here. Technically,\n@@ -332,7 +332,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n             // ```\n             //\n             // TODO: fix this\n-            ExprAddrOf(_, _) => {\n+            ExprKind::AddrOf(_, _) => {\n                 return;\n             }\n             _ => {}\n@@ -348,7 +348,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n fn is_in_assignment_position(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n-        if let ExprAssign(ref lhs, _) = parent.node {\n+        if let ExprKind::Assign(ref lhs, _) = parent.node {\n             return lhs.id == expr.id;\n         }\n     }"}, {"sha": "24bbf6692059cd7edac8e4fd728ac41c9f49c07f", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n             if let TypeVariants::TyFloat(fty) = ty.sty;\n-            if let hir::ExprLit(ref lit) = expr.node;\n+            if let hir::ExprKind::Lit(ref lit) = expr.node;\n             if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);\n             then {"}, {"sha": "019d21f81e0e0131da6f5aed67c6b3cbd611d135", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -35,17 +35,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprMethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n+            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n             if unwrap_fun.ident.name == \"unwrap\";\n             // match call to write_fmt\n             if unwrap_args.len() > 0;\n-            if let ExprMethodCall(ref write_fun, _, ref write_args) =\n+            if let ExprKind::MethodCall(ref write_fun, _, ref write_args) =\n                 unwrap_args[0].node;\n             if write_fun.ident.name == \"write_fmt\";\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if write_args.len() > 0;\n-            if let ExprCall(ref dest_fun, _) = write_args[0].node;\n-            if let ExprPath(ref qpath) = dest_fun.node;\n+            if let ExprKind::Call(ref dest_fun, _) = write_args[0].node;\n+            if let ExprKind::Path(ref qpath) = dest_fun.node;\n             if let Some(dest_fun_id) =\n                 opt_def_id(resolve_node(cx, qpath, dest_fun.hir_id));\n             if let Some(dest_name) = if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {"}, {"sha": "1ea000d3611b7e7d23217bbd2215b53d2419b701", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n         // check for `impl From<???> for ..`\n         let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n         if_chain! {\n-            if let hir::ItemImpl(.., ref impl_items) = item.node;\n+            if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n             if match_def_path(cx.tcx, impl_trait_ref.def_id, &FROM_TRAIT);\n             then {\n@@ -63,8 +63,8 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         fn visit_expr(&mut self, expr: &'tcx Expr) {\n             // check for `begin_panic`\n             if_chain! {\n-                if let ExprCall(ref func_expr, _) = expr.node;\n-                if let ExprPath(QPath::Resolved(_, ref path)) = func_expr.node;\n+                if let ExprKind::Call(ref func_expr, _) = expr.node;\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.node;\n                 if let Some(path_def_id) = opt_def_id(path.def);\n                 if match_def_path(self.tcx, path_def_id, &BEGIN_PANIC) ||\n                     match_def_path(self.tcx, path_def_id, &BEGIN_PANIC_FMT);"}, {"sha": "e88f03868939bfccc2b477cf6fde6b7c024c5bed", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             match expr.node {\n \n                 // `format!(\"{}\", foo)` expansion\n-                ExprCall(ref fun, ref args) => {\n+                ExprKind::Call(ref fun, ref args) => {\n                     if_chain! {\n-                        if let ExprPath(ref qpath) = fun.node;\n+                        if let ExprKind::Path(ref qpath) = fun.node;\n                         if args.len() == 3;\n                         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n                         if match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n@@ -64,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     }\n                 },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprMatch(ref matchee, _, _) => if let ExprTup(ref tup) = matchee.node {\n+                ExprKind::Match(ref matchee, _, _) => if let ExprKind::Tup(ref tup) = matchee.node {\n                     if tup.is_empty() {\n                         let sugg = format!(\"{}.to_string()\", snippet(cx, expr.span, \"<expr>\").into_owned());\n                         span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n@@ -81,10 +81,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n /// Checks if the expressions matches `&[\"\"]`\n fn check_single_piece(expr: &Expr) -> bool {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\"]\n-        if let ExprArray(ref exprs) = expr.node; // [\"\"]\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\"]\n+        if let ExprKind::Array(ref exprs) = expr.node; // [\"\"]\n         if exprs.len() == 1;\n-        if let ExprLit(ref lit) = exprs[0].node;\n+        if let ExprKind::Lit(ref lit) = exprs[0].node;\n         if let LitKind::Str(ref lit, _) = lit.node;\n         then {\n             return lit.as_str().is_empty();\n@@ -105,23 +105,23 @@ fn check_single_piece(expr: &Expr) -> bool {\n /// then returns the span of first element of the matched tuple\n fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprMatch(ref match_expr, ref arms, _) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;\n         if arms.len() == 1;\n         if arms[0].pats.len() == 1;\n         if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n         if pat.len() == 1;\n-        if let ExprArray(ref exprs) = arms[0].body.node;\n+        if let ExprKind::Array(ref exprs) = arms[0].body.node;\n         if exprs.len() == 1;\n-        if let ExprCall(_, ref args) = exprs[0].node;\n+        if let ExprKind::Call(_, ref args) = exprs[0].node;\n         if args.len() == 2;\n-        if let ExprPath(ref qpath) = args[1].node;\n+        if let ExprKind::Path(ref qpath) = args[1].node;\n         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, args[1].hir_id));\n         if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n             if ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING) {\n-                if let ExprTup(ref values) = match_expr.node {\n+                if let ExprKind::Tup(ref values) = match_expr.node {\n                     return Some(values[0].span);\n                 }\n             }\n@@ -143,14 +143,14 @@ fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n /// ```\n fn check_unformatted(expr: &Expr) -> bool {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         if exprs.len() == 1;\n-        if let ExprStruct(_, ref fields, _) = exprs[0].node;\n+        if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n-        if let ExprStruct(_, ref fields, _) = format_field.expr.node;\n+        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n         if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprPath(ref qpath) = align_field.expr.node;\n+        if let ExprKind::Path(ref qpath) = align_field.expr.node;\n         if last_path_segment(qpath).ident.name == \"Implied\";\n         then {\n             return true;"}, {"sha": "164380923159f007745ea3d0713a5112eb789280", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         use rustc::hir::map::Node::*;\n \n         let is_impl = if let Some(NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(nodeid)) {\n-            matches!(item.node, hir::ItemImpl(_, _, _, _, Some(_), _, _))\n+            matches!(item.node, hir::ItemKind::Impl(_, _, _, _, Some(_), _, _))\n         } else {\n             false\n         };\n@@ -168,7 +168,7 @@ impl<'a, 'tcx> Functions {\n }\n \n fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<ast::NodeId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &ty.node) {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.node, &ty.node) {\n         Some(id)\n     } else {\n         None\n@@ -184,7 +184,7 @@ struct DerefVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprCall(ref f, ref args) => {\n+            hir::ExprKind::Call(ref f, ref args) => {\n                 let ty = self.tables.expr_ty(f);\n \n                 if type_is_unsafe_function(self.cx, ty) {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprMethodCall(_, _, ref args) => {\n+            hir::ExprKind::MethodCall(_, _, ref args) => {\n                 let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n@@ -203,7 +203,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprUnary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n+            hir::ExprKind::Unary(hir::UnDeref, ref ptr) => self.check_arg(ptr),\n             _ => (),\n         }\n \n@@ -216,7 +216,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n-        if let hir::ExprPath(ref qpath) = ptr.node {\n+        if let hir::ExprKind::Path(ref qpath) = ptr.node {\n             if let Def::Local(id) = self.cx.tables.qpath_def(qpath, ptr.hir_id) {\n                 if self.ptrs.contains(&id) {\n                     span_lint("}, {"sha": "32ae8bcb29f8b808774cd9bee5ed2a22e679c5ce", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -43,19 +43,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n         }\n \n         match e.node {\n-            ExprMatch(_, ref arms, MatchSource::TryDesugar) => {\n+            ExprKind::Match(_, ref arms, MatchSource::TryDesugar) => {\n                 let e = match arms[0].body.node {\n-                    ExprRet(Some(ref e)) | ExprBreak(_, Some(ref e)) => e,\n+                    ExprKind::Ret(Some(ref e)) | ExprKind::Break(_, Some(ref e)) => e,\n                     _ => return,\n                 };\n-                if let ExprCall(_, ref args) = e.node {\n+                if let ExprKind::Call(_, ref args) = e.node {\n                     self.try_desugar_arm.push(args[0].id);\n                 } else {\n                     return;\n                 }\n             },\n \n-            ExprMethodCall(ref name, .., ref args) => {\n+            ExprKind::MethodCall(ref name, .., ref args) => {\n                 if match_trait_method(cx, e, &paths::INTO[..]) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n                 }\n             },\n \n-            ExprCall(ref path, ref args) => if let ExprPath(ref qpath) = path.node {\n+            ExprKind::Call(ref path, ref args) => if let ExprKind::Path(ref qpath) = path.node {\n                 if let Some(def_id) = opt_def_id(resolve_node(cx, qpath, path.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::FROM_FROM[..]) {\n                         let a = cx.tables.expr_ty(e);"}, {"sha": "92e07401818eb5dd2d7d4900c293dceba2da79f5", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -36,19 +36,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.node {\n             match cmp.node {\n-                BiAdd | BiBitOr | BiBitXor => {\n+                BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n                     check(cx, left, 0, e.span, right.span);\n                     check(cx, right, 0, e.span, left.span);\n                 },\n-                BiShl | BiShr | BiSub => check(cx, right, 0, e.span, left.span),\n-                BiMul => {\n+                BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => check(cx, right, 0, e.span, left.span),\n+                BinOpKind::Mul => {\n                     check(cx, left, 1, e.span, right.span);\n                     check(cx, right, 1, e.span, left.span);\n                 },\n-                BiDiv => check(cx, right, 1, e.span, left.span),\n-                BiBitAnd => {\n+                BinOpKind::Div => check(cx, right, 1, e.span, left.span),\n+                BinOpKind::BitAnd => {\n                     check(cx, left, -1, e.span, right.span);\n                     check(cx, right, -1, e.span, left.span);\n                 },"}, {"sha": "17dcf571fbf0c35c82363b6a3b02d32fdd00f500", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -45,16 +45,20 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n+        if let ExprKind::Match(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n             if arms[0].pats.len() == 1 {\n                 let good_method = match arms[0].pats[0].node {\n-                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild => {\n-                        if match_qpath(path, &paths::RESULT_OK) {\n-                            \"is_ok()\"\n-                        } else if match_qpath(path, &paths::RESULT_ERR) {\n-                            \"is_err()\"\n-                        } else if match_qpath(path, &paths::OPTION_SOME) {\n-                            \"is_some()\"\n+                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {\n+                        if let PatKind::Wild = pats[0].node {\n+                            if match_qpath(path, &paths::RESULT_OK) {\n+                                \"is_ok()\"\n+                            } else if match_qpath(path, &paths::RESULT_ERR) {\n+                                \"is_err()\"\n+                            } else if match_qpath(path, &paths::OPTION_SOME) {\n+                                \"is_some()\"\n+                            } else {\n+                                return;\n+                            }\n                         } else {\n                             return;\n                         }"}, {"sha": "8176408e720854e48828ee939bb5a6f04ef10e9e", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -94,7 +94,7 @@ impl LintPass for IndexingSlicing {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprIndex(ref array, ref index) = &expr.node {\n+        if let ExprKind::Index(ref array, ref index) = &expr.node {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {\n                 // Ranged indexes, i.e. &x[n..m], &x[n..], &x[..n] and &x[..]"}, {"sha": "9abd9754d6795950823eb39e8bc0c2672986464e", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n         if_chain! {\n             if let Some(ref expr) = local.init;\n-            if let Expr_::ExprMatch(ref target, ref arms, MatchSource::Normal) = expr.node;\n+            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.node;\n             if arms.len() == 1 && arms[0].pats.len() == 1 && arms[0].guard.is_none();\n             if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pats[0].node;\n             if args.len() == 1;"}, {"sha": "a979486945a77497bec06ccb07f430070c5c0c58", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -141,7 +141,7 @@ static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n \n fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n-        ExprMethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n                 if method.ident.name == name && args.len() == len {\n                     return (match heuristic {\n@@ -153,21 +153,21 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n             if method.ident.name == \"flat_map\" && args.len() == 2 {\n-                if let ExprClosure(_, _, body_id, _, _) = args[1].node {\n+                if let ExprKind::Closure(_, _, body_id, _, _) = args[1].node {\n                     let body = cx.tcx.hir.body(body_id);\n                     return is_infinite(cx, &body.value);\n                 }\n             }\n             Finite\n         },\n-        ExprBlock(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n-        ExprBox(ref e) | ExprAddrOf(_, ref e) => is_infinite(cx, e),\n-        ExprCall(ref path, _) => if let ExprPath(ref qpath) = path.node {\n+        ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n+        ExprKind::Box(ref e) | ExprKind::AddrOf(_, ref e) => is_infinite(cx, e),\n+        ExprKind::Call(ref path, _) => if let ExprKind::Path(ref qpath) = path.node {\n             match_qpath(qpath, &paths::REPEAT).into()\n         } else {\n             Finite\n         },\n-        ExprStruct(..) => higher::range(cx, expr)\n+        ExprKind::Struct(..) => higher::range(cx, expr)\n             .map_or(false, |r| r.end.is_none())\n             .into(),\n         _ => Finite,\n@@ -205,7 +205,7 @@ static COMPLETING_METHODS: &[(&str, usize)] = &[\n \n fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n-        ExprMethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {\n                 if method.ident.name == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);\n@@ -224,11 +224,11 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n                 }\n             }\n         },\n-        ExprBinary(op, ref l, ref r) => if op.node.is_comparison() {\n+        ExprKind::Binary(op, ref l, ref r) => if op.node.is_comparison() {\n             return is_infinite(cx, l)\n                 .and(is_infinite(cx, r))\n                 .and(MaybeInfinite);\n-        }, // TODO: ExprLoop + Match\n+        }, // TODO: ExprKind::Loop + Match\n         _ => (),\n     }\n     Finite"}, {"sha": "9fb9a162cde617aea51c187d6b121234746151a2", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -56,7 +56,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let Item_::ItemImpl(_, _, _, ref generics, None, _, _) = item.node {\n+        if let ItemKind::Impl(_, _, _, ref generics, None, _, _) = item.node {\n             // Remember for each inherent implementation encoutered its span and generics\n             self.impls\n                 .insert(item.hir_id.owner_def_id(), (item.span, generics.clone()));"}, {"sha": "255efa7416591ab3b5cc9097478f6c538be7f925", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -35,8 +35,8 @@ impl LintPass for InvalidRef {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref path, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = path.node;\n+            if let ExprKind::Call(ref path, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = path.node;\n             if args.len() == 0;\n             if let ty::TyRef(..) = cx.tables.expr_ty(expr).sty;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));"}, {"sha": "926e3a3033f835dd3294d5953ebfef711e3f5952", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -49,7 +49,7 @@ impl LintPass for LargeEnumVariant {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n-        if let ItemEnum(ref def, _) = item.node {\n+        if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def()\n                 .expect(\"already checked whether this is an enum\");"}, {"sha": "bd02eb5c81f10a51df24531ad87389c15b560510", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -68,8 +68,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n         }\n \n         match item.node {\n-            ItemTrait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n-            ItemImpl(_, _, _, _, None, _, ref impl_items) => check_impl_items(cx, item, impl_items),\n+            ItemKind::Trait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n+            ItemKind::Impl(_, _, _, _, None, _, ref impl_items) => check_impl_items(cx, item, impl_items),\n             _ => (),\n         }\n     }\n@@ -79,26 +79,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n             return;\n         }\n \n-        if let ExprBinary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n+        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.node {\n             match cmp {\n-                BiEq => {\n+                BinOpKind::Eq => {\n                     check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n                     check_cmp(cx, expr.span, right, left, \"\", 0); // 0 == len\n                 },\n-                BiNe => {\n+                BinOpKind::Ne => {\n                     check_cmp(cx, expr.span, left, right, \"!\", 0); // len != 0\n                     check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 != len\n                 },\n-                BiGt => {\n+                BinOpKind::Gt => {\n                     check_cmp(cx, expr.span, left, right, \"!\", 0); // len > 0\n                     check_cmp(cx, expr.span, right, left, \"\", 1); // 1 > len\n                 },\n-                BiLt => {\n+                BinOpKind::Lt => {\n                     check_cmp(cx, expr.span, left, right, \"\", 1); // len < 1\n                     check_cmp(cx, expr.span, right, left, \"!\", 0); // 0 < len\n                 },\n-                BiGe => check_cmp(cx, expr.span, left, right, \"!\", 1), // len <= 1\n-                BiLe => check_cmp(cx, expr.span, right, left, \"!\", 1), // 1 >= len\n+                BinOpKind::Ge => check_cmp(cx, expr.span, left, right, \"!\", 1), // len <= 1\n+                BinOpKind::Le => check_cmp(cx, expr.span, right, left, \"!\", 1), // 1 >= len\n                 _ => (),\n             }\n         }\n@@ -194,7 +194,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n }\n \n fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n-    if let (&ExprMethodCall(ref method_path, _, ref args), &ExprLit(ref lit)) = (&method.node, &lit.node) {\n+    if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.node, &lit.node) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name == \"is_empty\" {\n@@ -258,11 +258,10 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n-        ty::TyDynamic(..) => cx.tcx\n-            .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n+        ty::TyDynamic(ref tt, ..) => cx.tcx\n+            .associated_items(tt.principal().expect(\"trait impl not found\").def_id())\n             .any(|item| is_is_empty(cx, &item)),\n-        ty::TyProjection(_) => ty.ty_to_def_id()\n-            .map_or(false, |id| has_is_empty_impl(cx, id)),\n+        ty::TyProjection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyStr => true,\n         _ => false,"}, {"sha": "a72e09f9fdf0f788adee9b8a3d37bbb28febf79d", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -65,20 +65,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n         while let Some(stmt) = it.next() {\n             if_chain! {\n                 if let Some(expr) = it.peek();\n-                if let hir::StmtDecl(ref decl, _) = stmt.node;\n-                if let hir::DeclLocal(ref decl) = decl.node;\n+                if let hir::StmtKind::Decl(ref decl, _) = stmt.node;\n+                if let hir::DeclKind::Local(ref decl) = decl.node;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = decl.pat.node;\n-                if let hir::StmtExpr(ref if_, _) = expr.node;\n-                if let hir::ExprIf(ref cond, ref then, ref else_) = if_.node;\n+                if let hir::StmtKind::Expr(ref if_, _) = expr.node;\n+                if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.node;\n                 if !used_in_expr(cx, canonical_id, cond);\n-                if let hir::ExprBlock(ref then, _) = then.node;\n+                if let hir::ExprKind::Block(ref then, _) = then.node;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n                 if !used_in_expr(cx, canonical_id, value);\n                 then {\n                     let span = stmt.span.to(if_.span);\n \n                     let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n-                        if let hir::ExprBlock(ref else_, _) = else_.node {\n+                        if let hir::ExprKind::Block(ref else_, _) = else_.node {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)\n                             } else if let Some(ref default) = decl.init {\n@@ -140,7 +140,7 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprPath(ref qpath) = expr.node;\n+            if let hir::ExprKind::Path(ref qpath) = expr.node;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n             if self.id == local_id;\n             then {\n@@ -163,9 +163,9 @@ fn check_assign<'a, 'tcx>(\n     if_chain! {\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n-        if let hir::StmtSemi(ref expr, _) = expr.node;\n-        if let hir::ExprAssign(ref var, ref value) = expr.node;\n-        if let hir::ExprPath(ref qpath) = var.node;\n+        if let hir::StmtKind::Semi(ref expr, _) = expr.node;\n+        if let hir::ExprKind::Assign(ref var, ref value) = expr.node;\n+        if let hir::ExprKind::Path(ref qpath) = var.node;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id);\n         if decl == local_id;\n         then {"}, {"sha": "1b371a8141ef6d951d689253d84643407c6cf6b5", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -59,7 +59,7 @@ impl LintPass for LifetimePass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, ref generics, id) = item.node {\n+        if let ItemKind::Fn(ref decl, _, ref generics, id) = item.node {\n             check_fn_inner(cx, decl, Some(id), generics, item.span);\n         }\n     }\n@@ -338,14 +338,14 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n         match ty.node {\n-            TyRptr(ref lt, _) if lt.is_elided() => {\n+            TyKind::Rptr(ref lt, _) if lt.is_elided() => {\n                 self.record(&None);\n             },\n-            TyPath(ref path) => {\n+            TyKind::Path(ref path) => {\n                 if let QPath::Resolved(_, ref path) = *path {\n                     if let Def::Existential(def_id) = path.def {\n                         let node_id = self.cx.tcx.hir.as_local_node_id(def_id).unwrap();\n-                        if let ItemExistential(ref exist_ty) = self.cx.tcx.hir.expect_item(node_id).node {\n+                        if let ItemKind::Existential(ref exist_ty) = self.cx.tcx.hir.expect_item(node_id).node {\n                             for bound in &exist_ty.bounds {\n                                 if let GenericBound::Outlives(_) = *bound {\n                                     self.record(&None);\n@@ -360,7 +360,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 }\n                 self.collect_anonymous_lifetimes(path, ty);\n             }\n-            TyTraitObject(ref bounds, ref lt) => {\n+            TyKind::TraitObject(ref bounds, ref lt) => {\n                 if !lt.is_elided() {\n                     self.abort = true;\n                 }"}, {"sha": "e7da7bde30f2160ea02315f8843ec8c65d51414d", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -23,7 +23,7 @@ use crate::consts::{constant, Constant};\n \n use crate::utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n             last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n-            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then};\n+            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq};\n use crate::utils::paths;\n \n /// **What it does:** Checks for for-loops that manually copy items between\n@@ -411,7 +411,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         // check for never_loop\n         match expr.node {\n-            ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => {\n+            ExprKind::While(_, ref block, _) | ExprKind::Loop(ref block, _, _) => {\n                 match never_loop_block(block, expr.id) {\n                     NeverLoopResult::AlwaysBreak =>\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n@@ -424,7 +424,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprLoop(ref block, _, LoopSource::Loop) = expr.node {\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop) = expr.node {\n             // also check for empty `loop {}` statements\n             if block.stmts.is_empty() && block.expr.is_none() {\n                 span_lint(\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let inner_stmt_expr = extract_expr_from_first_stmt(block);\n             // or extract the first expression (if any) from the block\n             if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(block)) {\n-                if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n+                if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n@@ -476,11 +476,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n             }\n         }\n-        if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n+        if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n             if let (\n                 &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                &ExprMethodCall(ref method_path, _, ref method_args),\n+                &ExprKind::MethodCall(ref method_path, _, ref method_args),\n             ) = (pat, &match_expr.node)\n             {\n                 let iter_expr = &method_args[0];\n@@ -505,14 +505,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         // check for while loops which conditions never change\n-        if let ExprWhile(ref cond, _, _) = expr.node {\n+        if let ExprKind::While(ref cond, _, _) = expr.node {\n             check_infinite_loop(cx, cond, expr);\n         }\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n-        if let StmtSemi(ref expr, _) = stmt.node {\n-            if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+        if let StmtKind::Semi(ref expr, _) = stmt.node {\n+            if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && method.ident.name == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(\n                         cx,\n@@ -584,53 +584,53 @@ fn never_loop_block(block: &Block, main_loop_id: NodeId) -> NeverLoopResult {\n \n fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n     match stmt.node {\n-        StmtSemi(ref e, ..) | StmtExpr(ref e, ..) => Some(e),\n-        StmtDecl(ref d, ..) => decl_to_expr(d),\n+        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n+        StmtKind::Decl(ref d, ..) => decl_to_expr(d),\n     }\n }\n \n fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n     match decl.node {\n-        DeclLocal(ref local) => local.init.as_ref().map(|p| &**p),\n+        DeclKind::Local(ref local) => local.init.as_ref().map(|p| &**p),\n         _ => None,\n     }\n }\n \n fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     match expr.node {\n-        ExprBox(ref e) |\n-        ExprUnary(_, ref e) |\n-        ExprCast(ref e, _) |\n-        ExprType(ref e, _) |\n-        ExprField(ref e, _) |\n-        ExprAddrOf(_, ref e) |\n-        ExprStruct(_, _, Some(ref e)) |\n-        ExprRepeat(ref e, _) => never_loop_expr(e, main_loop_id),\n-        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => {\n+        ExprKind::Box(ref e) |\n+        ExprKind::Unary(_, ref e) |\n+        ExprKind::Cast(ref e, _) |\n+        ExprKind::Type(ref e, _) |\n+        ExprKind::Field(ref e, _) |\n+        ExprKind::AddrOf(_, ref e) |\n+        ExprKind::Struct(_, _, Some(ref e)) |\n+        ExprKind::Repeat(ref e, _) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es) | ExprKind::Tup(ref es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n-        ExprCall(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n-        ExprBinary(_, ref e1, ref e2) |\n-        ExprAssign(ref e1, ref e2) |\n-        ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprIf(ref e, ref e2, ref e3) => {\n+        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, ref e1, ref e2) |\n+        ExprKind::Assign(ref e1, ref e2) |\n+        ExprKind::AssignOp(_, ref e1, ref e2) |\n+        ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n+        ExprKind::If(ref e, ref e2, ref e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3.as_ref().map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n-        ExprLoop(ref b, _, _) => {\n+        ExprKind::Loop(ref b, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprWhile(ref e, ref b, _) => {\n+        ExprKind::While(ref e, ref b, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             let result = never_loop_block(b, main_loop_id);\n             // Break can come from the inner loop so remove them.\n             combine_seq(e, absorb_break(&result))\n         },\n-        ExprMatch(ref e, ref arms, _) => {\n+        ExprKind::Match(ref e, ref arms, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             if arms.is_empty() {\n                 e\n@@ -639,8 +639,8 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprBlock(ref b, _) => never_loop_block(b, main_loop_id),\n-        ExprContinue(d) => {\n+        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Continue(d) => {\n             let id = d.target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n             if id == main_loop_id {\n@@ -649,22 +649,22 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprBreak(_, _) => {\n+        ExprKind::Break(_, _) => {\n             NeverLoopResult::AlwaysBreak\n         },\n-        ExprRet(ref e) => {\n+        ExprKind::Ret(ref e) => {\n             if let Some(ref e) = *e {\n                 combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n             } else {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprStruct(_, _, None) |\n-        ExprYield(_) |\n-        ExprClosure(_, _, _, _, _) |\n-        ExprInlineAsm(_, _, _) |\n-        ExprPath(_) |\n-        ExprLit(_) => NeverLoopResult::Otherwise,\n+        ExprKind::Struct(_, _, None) |\n+        ExprKind::Yield(_) |\n+        ExprKind::Closure(_, _, _, _, _) |\n+        ExprKind::InlineAsm(_, _, _) |\n+        ExprKind::Path(_) |\n+        ExprKind::Lit(_) => NeverLoopResult::Otherwise,\n     }\n }\n \n@@ -701,7 +701,7 @@ fn check_for_loop<'a, 'tcx>(\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> bool {\n     if_chain! {\n-        if let ExprPath(ref qpath) = expr.node;\n+        if let ExprKind::Path(ref qpath) = expr.node;\n         if let QPath::Resolved(None, ref path) = *qpath;\n         if path.segments.len() == 1;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id);\n@@ -754,24 +754,24 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n         match e.node {\n-            ExprLit(ref l) => match l.node {\n+            ExprKind::Lit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n                 _ => None,\n             },\n-            ExprPath(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            ExprKind::Path(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n             _ => None,\n         }\n     }\n \n-    if let ExprIndex(ref seqexpr, ref idx) = expr.node {\n+    if let ExprKind::Index(ref seqexpr, ref idx) = expr.node {\n         let ty = cx.tables.expr_ty(seqexpr);\n         if !is_slice_like(cx, ty) {\n             return None;\n         }\n \n         let offset = match idx.node {\n-            ExprBinary(op, ref lhs, ref rhs) => match op.node {\n-                BinOp_::BiAdd => {\n+            ExprKind::Binary(op, ref lhs, ref rhs) => match op.node {\n+                BinOpKind::Add => {\n                     let offset_opt = if same_var(cx, lhs, var) {\n                         extract_offset(cx, rhs, var)\n                     } else if same_var(cx, rhs, var) {\n@@ -782,10 +782,10 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n \n                     offset_opt.map(Offset::positive)\n                 },\n-                BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n+                BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n                 _ => None,\n             },\n-            ExprPath(..) => if same_var(cx, idx, var) {\n+            ExprKind::Path(..) => if same_var(cx, idx, var) {\n                 Some(Offset::positive(\"0\".into()))\n             } else {\n                 None\n@@ -810,7 +810,7 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     var: ast::NodeId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n-        if let ExprMethodCall(ref method, _, ref args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n         if method.ident.name == \"clone\";\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n@@ -832,7 +832,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         e: &Expr,\n         var: ast::NodeId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n-        if let Expr_::ExprAssign(ref lhs, ref rhs) = e.node {\n+        if let ExprKind::Assign(ref lhs, ref rhs) = e.node {\n             match (get_fixed_offset_var(cx, lhs, var), fetch_cloned_fixed_offset_var(cx, rhs, var)) {\n                 (Some(offset_left), Some(offset_right)) => {\n                     // Source and destination must be different\n@@ -849,7 +849,7 @@ fn get_indexed_assignments<'a, 'tcx>(\n         }\n     }\n \n-    if let Expr_::ExprBlock(ref b, _) = body.node {\n+    if let ExprKind::Block(ref b, _) = body.node {\n         let Block {\n             ref stmts,\n             ref expr,\n@@ -859,8 +859,8 @@ fn get_indexed_assignments<'a, 'tcx>(\n         stmts\n             .iter()\n             .map(|stmt| match stmt.node {\n-                Stmt_::StmtDecl(..) => None,\n-                Stmt_::StmtExpr(ref e, _node_id) | Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n+                StmtKind::Decl(..) => None,\n+                StmtKind::Expr(ref e, _node_id) | StmtKind::Semi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n             })\n             .chain(\n                 expr.as_ref()\n@@ -906,7 +906,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n \n             let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n                 if_chain! {\n-                    if let ExprMethodCall(ref method, _, ref len_args) = end.node;\n+                    if let ExprKind::MethodCall(ref method, _, ref len_args) = end.node;\n                     if method.ident.name == \"len\";\n                     if len_args.len() == 1;\n                     if let Some(arg) = len_args.get(0);\n@@ -1098,10 +1098,10 @@ fn check_for_loop_range<'a, 'tcx>(\n \n fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n-        if let ExprMethodCall(ref method, _, ref len_args) = expr.node;\n+        if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.node;\n         if len_args.len() == 1;\n         if method.ident.name == \"len\";\n-        if let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node;\n+        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].node;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;\n         then {\n@@ -1203,7 +1203,7 @@ fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &s\n \n fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n-    if let ExprMethodCall(ref method, _, ref args) = arg.node {\n+    if let ExprKind::MethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();\n@@ -1377,7 +1377,7 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n                 MutMutable => \"_mut\",\n             };\n             let arg = match arg.node {\n-                ExprAddrOf(_, ref expr) => &**expr,\n+                ExprKind::AddrOf(_, ref expr) => &**expr,\n                 _ => arg,\n             };\n \n@@ -1483,7 +1483,7 @@ fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n \n fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n     if_chain! {\n-        if let ExprPath(ref qpath) = bound.node;\n+        if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n         then {\n             let def = cx.tables.qpath_def(qpath, bound.hir_id);\n@@ -1598,7 +1598,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n     fn check(&mut self, idx: &'tcx Expr, seqexpr: &'tcx Expr, expr: &'tcx Expr) -> bool {\n         if_chain! {\n             // the indexed container is referenced by a name\n-            if let ExprPath(ref seqpath) = seqexpr.node;\n+            if let ExprKind::Path(ref seqpath) = seqexpr.node;\n             if let QPath::Resolved(None, ref seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n             then {\n@@ -1655,7 +1655,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_chain! {\n             // a range index op\n-            if let ExprMethodCall(ref meth, _, ref args) = expr.node;\n+            if let ExprKind::MethodCall(ref meth, _, ref args) = expr.node;\n             if (meth.ident.name == \"index\" && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == \"index_mut\" && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n@@ -1664,14 +1664,14 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         if_chain! {\n             // an index op\n-            if let ExprIndex(ref seqexpr, ref idx) = expr.node;\n+            if let ExprKind::Index(ref seqexpr, ref idx) = expr.node;\n             if !self.check(idx, seqexpr, expr);\n             then { return }\n         }\n \n         if_chain! {\n             // directly using a variable\n-            if let ExprPath(ref qpath) = expr.node;\n+            if let ExprKind::Path(ref qpath) = expr.node;\n             if let QPath::Resolved(None, ref path) = *qpath;\n             if path.segments.len() == 1;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n@@ -1687,20 +1687,20 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         }\n         let old = self.prefer_mutable;\n         match expr.node {\n-            ExprAssignOp(_, ref lhs, ref rhs) |\n-            ExprAssign(ref lhs, ref rhs) => {\n+            ExprKind::AssignOp(_, ref lhs, ref rhs) |\n+            ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.prefer_mutable = true;\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n                 self.visit_expr(rhs);\n             },\n-            ExprAddrOf(mutbl, ref expr) => {\n+            ExprKind::AddrOf(mutbl, ref expr) => {\n                 if mutbl == MutMutable {\n                     self.prefer_mutable = true;\n                 }\n                 self.visit_expr(expr);\n             },\n-            ExprCall(ref f, ref args) => {\n+            ExprKind::Call(ref f, ref args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n                     let ty = self.cx.tables.expr_ty_adjusted(expr);\n@@ -1713,7 +1713,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprMethodCall(_, _, ref args) => {\n+            ExprKind::MethodCall(_, _, ref args) => {\n                 let def_id = self.cx.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n@@ -1809,8 +1809,8 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n     if block.stmts.is_empty() {\n         return None;\n     }\n-    if let StmtDecl(ref decl, _) = block.stmts[0].node {\n-        if let DeclLocal(ref local) = decl.node {\n+    if let StmtKind::Decl(ref decl, _) = block.stmts[0].node {\n+        if let DeclKind::Local(ref local) = decl.node {\n             if let Some(ref expr) = local.init {\n                 Some(expr)\n             } else {\n@@ -1829,8 +1829,8 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     match block.expr {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n         None if !block.stmts.is_empty() => match block.stmts[0].node {\n-            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n-            StmtDecl(..) => None,\n+            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => Some(expr),\n+            StmtKind::Decl(..) => None,\n         },\n         _ => None,\n     }\n@@ -1841,8 +1841,8 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n /// passed expression. The expression may be within a block.\n fn is_simple_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBreak(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprBlock(ref b, _) => match extract_first_expr(b) {\n+        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n+        ExprKind::Block(ref b, _) => match extract_first_expr(b) {\n             Some(subexpr) => is_simple_break_expr(subexpr),\n             None => false,\n         },\n@@ -1882,9 +1882,9 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                 let state = self.states.entry(def_id).or_insert(VarState::Initial);\n \n                 match parent.node {\n-                    ExprAssignOp(op, ref lhs, ref rhs) => {\n+                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                         if lhs.id == expr.id {\n-                            if op.node == BiAdd && is_integer_literal(rhs, 1) {\n+                            if op.node == BinOpKind::Add && is_integer_literal(rhs, 1) {\n                                 *state = match *state {\n                                     VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n                                     _ => VarState::DontWarn,\n@@ -1895,8 +1895,8 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                             }\n                         }\n                     },\n-                    ExprAssign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n-                    ExprAddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n+                    ExprKind::Assign(ref lhs, _) if lhs.id == expr.id => *state = VarState::DontWarn,\n+                    ExprKind::AddrOf(mutability, _) if mutability == MutMutable => *state = VarState::DontWarn,\n                     _ => (),\n                 }\n             }\n@@ -1931,7 +1931,7 @@ struct InitializeVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_decl(&mut self, decl: &'tcx Decl) {\n         // Look for declarations of the variable\n-        if let DeclLocal(ref local) = decl.node {\n+        if let DeclKind::Local(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n                 if let PatKind::Binding(_, _, ident, _) = local.pat.node {\n                     self.name = Some(ident.name);\n@@ -1955,7 +1955,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if self.state == VarState::DontWarn {\n             return;\n         }\n-        if expr == self.end_expr {\n+        if SpanlessEq::new(self.cx).eq_expr(&expr, self.end_expr) {\n             self.past_loop = true;\n             return;\n         }\n@@ -1969,17 +1969,17 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.node {\n-                    ExprAssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.id == expr.id => {\n                         self.state = VarState::DontWarn;\n                     },\n-                    ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n+                    ExprKind::Assign(ref lhs, ref rhs) if lhs.id == expr.id => {\n                         self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n                             VarState::DontWarn\n                         }\n                     },\n-                    ExprAddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n+                    ExprKind::AddrOf(mutability, _) if mutability == MutMutable => self.state = VarState::DontWarn,\n                     _ => (),\n                 }\n             }\n@@ -2005,7 +2005,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n }\n \n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n-    if let ExprPath(ref qpath) = expr.node {\n+    if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n             return Some(node_id);\n@@ -2016,14 +2016,14 @@ fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n \n fn is_loop(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprLoop(..) | ExprWhile(..) => true,\n+        ExprKind::Loop(..) | ExprKind::While(..) => true,\n         _ => false,\n     }\n }\n \n fn is_conditional(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprIf(..) | ExprMatch(..) => true,\n+        ExprKind::If(..) | ExprKind::Match(..) => true,\n         _ => false,\n     }\n }\n@@ -2053,7 +2053,7 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n         }\n         match cx.tcx.hir.find(parent) {\n             Some(NodeExpr(expr)) => match expr.node {\n-                ExprLoop(..) | ExprWhile(..) => {\n+                ExprKind::Loop(..) | ExprKind::While(..) => {\n                     return true;\n                 },\n                 _ => (),\n@@ -2111,7 +2111,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.node {\n-            ExprAssign(ref path, _) | ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n+            ExprKind::Assign(ref path, _) | ExprKind::AssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n                 self.nesting = RuledOut;\n             },\n             _ => walk_expr(self, expr),\n@@ -2137,7 +2137,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n }\n \n fn path_name(e: &Expr) -> Option<Name> {\n-    if let ExprPath(QPath::Resolved(_, ref path)) = e.node {\n+    if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n             return Some(segments[0].ident.name);\n@@ -2193,7 +2193,7 @@ struct VarCollectorVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n     fn insert_def_id(&mut self, ex: &'tcx Expr) {\n         if_chain! {\n-            if let ExprPath(ref qpath) = ex.node;\n+            if let ExprKind::Path(ref qpath) = ex.node;\n             if let QPath::Resolved(None, _) = *qpath;\n             let def = self.cx.tables.qpath_def(qpath, ex.hir_id);\n             then {\n@@ -2214,9 +2214,9 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         match ex.node {\n-            ExprPath(_) => self.insert_def_id(ex),\n+            ExprKind::Path(_) => self.insert_def_id(ex),\n             // If there is any fuction/method call\u2026 we just stop analysis\n-            ExprCall(..) | ExprMethodCall(..) => self.skip = true,\n+            ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n \n             _ => walk_expr(self, ex),\n         }"}, {"sha": "01ce702c17cf78990015fa683ec2151893e4a05c", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n use crate::utils::{get_arg_ident, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n-            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -30,10 +30,10 @@ pub struct Pass;\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n-        if let ExprMethodCall(ref method, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n             if method.ident.name == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, closure_eid, _, _) => {\n+                    ExprKind::Closure(_, ref decl, closure_eid, _, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n                         let closure_expr = remove_blocks(&body.value);\n                         if_chain! {\n@@ -62,11 +62,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                     }\n                                 }\n                                 // explicit clone() calls ( .map(|x| x.clone()) )\n-                                else if let ExprMethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n+                                else if let ExprKind::MethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n                                     if clone_call.ident.name == \"clone\" &&\n                                         clone_args.len() == 1 &&\n                                         match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_name(&clone_args[0], arg_ident)\n+                                        expr_eq_name(cx, &clone_args[0], arg_ident)\n                                     {\n                                         span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                             \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -77,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             }\n                         }\n                     },\n-                    ExprPath(ref path) => if match_qpath(path, &paths::CLONE) {\n+                    ExprKind::Path(ref path) => if match_qpath(path, &paths::CLONE) {\n                         let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                         span_help_and_lint(\n                             cx,\n@@ -98,17 +98,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn expr_eq_name(expr: &Expr, id: ast::Ident) -> bool {\n+fn expr_eq_name(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n-        ExprPath(QPath::Resolved(None, ref path)) => {\n+        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [\n                 PathSegment {\n                     ident: id,\n                     args: None,\n                     infer_types: true,\n                 },\n             ];\n-            !path.is_global() && path.segments[..] == arg_segment\n+            !path.is_global() && SpanlessEq::new(cx).eq_path_segments(&path.segments[..], &arg_segment)\n         },\n         _ => false,\n     }\n@@ -126,8 +126,8 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n \n fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n-        ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n-        _ => expr_eq_name(expr, id),\n+        ExprKind::Unary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n+        _ => expr_eq_name(cx, expr, id),\n     }\n }\n "}, {"sha": "8df573e4c725807aa65e0888ffe5548fdf5756d6", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n use rustc::ty;\n-use rustc_errors::{Applicability};\n+use rustc_errors::Applicability;\n use syntax::codemap::Span;\n use crate::utils::{in_macro, iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n use crate::utils::paths;\n@@ -115,12 +115,12 @@ fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<S\n     }\n \n     match expr.node {\n-        hir::ExprCall(_, _) |\n-        hir::ExprMethodCall(_, _, _) => {\n+        hir::ExprKind::Call(_, _) |\n+        hir::ExprKind::MethodCall(_, _, _) => {\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },\n-        hir::ExprBlock(ref block, _) => {\n+        hir::ExprKind::Block(ref block, _) => {\n             match (&block.stmts[..], block.expr.as_ref()) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n@@ -131,9 +131,9 @@ fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<S\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.node {\n-                        hir::StmtDecl(ref d, _) => Some(d.span),\n-                        hir::StmtExpr(ref e, _) => Some(e.span),\n-                        hir::StmtSemi(_, _) => Some(inner_stmt.span),\n+                        hir::StmtKind::Decl(ref d, _) => Some(d.span),\n+                        hir::StmtKind::Expr(ref e, _) => Some(e.span),\n+                        hir::StmtKind::Semi(_, _) => Some(inner_stmt.span),\n                     }\n                 },\n                 _ => {\n@@ -151,7 +151,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<S\n }\n \n fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Option<(&'tcx hir::Arg, &'a hir::Expr)> {\n-    if let hir::ExprClosure(_, ref decl, inner_expr_id, _, _) = expr.node {\n+    if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.node {\n         let body = cx.tcx.hir.body(inner_expr_id);\n         let body_expr = &body.value;\n \n@@ -175,8 +175,8 @@ fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Op\n /// Anything else will return `_`.\n fn let_binding_name(cx: &LateContext, var_arg: &hir::Expr) -> String {\n     match &var_arg.node {\n-        hir::ExprField(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n-        hir::ExprPath(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n+        hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n+        hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n         _ => \"_\".to_string()\n     }\n }\n@@ -247,8 +247,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n \n-        if let hir::StmtSemi(ref expr, _) = stmt.node {\n-            if let hir::ExprMethodCall(_, _, _) = expr.node {\n+        if let hir::StmtKind::Semi(ref expr, _) = stmt.node {\n+            if let hir::ExprKind::MethodCall(_, _, _) = expr.node {\n                 if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n                     lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n                 }"}, {"sha": "c82d156462d4bd857a6093a8fdbd6aee2f037cf2", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -184,14 +184,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n-        if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.node {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n         }\n-        if let ExprMatch(ref ex, ref arms, _) = expr.node {\n+        if let ExprKind::Match(ref ex, ref arms, _) = expr.node {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n@@ -205,7 +205,7 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n         let els = remove_blocks(&arms[1].body);\n         let els = if is_unit_expr(els) {\n             None\n-        } else if let ExprBlock(_, _) = els.node {\n+        } else if let ExprKind::Block(_, _) = els.node {\n             // matches with blocks that contain statements are prettier as `if let + else`\n             Some(els)\n         } else {\n@@ -221,7 +221,7 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n }\n \n fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n-    if arms[1].pats[0].node == PatKind::Wild {\n+    if is_wild(&arms[1].pats[0]) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n@@ -265,7 +265,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n             // contains any non wildcard patterns? e.g. Err(err)\n-            if inner.iter().any(|pat| pat.node != PatKind::Wild) {\n+            if !inner.iter().all(is_wild) {\n                 return;\n             }\n             print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n@@ -294,7 +294,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                 if arms.len() == 2 && arms[0].pats.len() == 1 {\n                     // no guards\n                     let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n-                        if let ExprLit(ref lit) = arm_bool.node {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.node {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n                                 LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n@@ -356,6 +356,13 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr,\n     }\n }\n \n+fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n+    match pat.node {\n+        PatKind::Wild => true,\n+        _ => false,\n+    }\n+}\n+\n fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n@@ -364,8 +371,8 @@ fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n                 if_chain! {\n                     if path_str == \"Err\";\n-                    if inner.iter().any(|pat| pat.node == PatKind::Wild);\n-                    if let ExprBlock(ref block, _) = arm.body.node;\n+                    if inner.iter().any(is_wild);\n+                    if let ExprKind::Block(ref block, _) = arm.body.node;\n                     if is_panic_block(block);\n                     then {\n                         // `Err(_)` arm with `panic!` found\n@@ -399,7 +406,7 @@ fn is_panic_block(block: &Block) -> bool {\n fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n-        let (title, msg) = if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+        let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n             suggs.push((ex.span, Sugg::hir(cx, inner, \"..\").to_string()));\n             (\n                 \"you don't need to add `&` to both the expression and the patterns\",\n@@ -533,8 +540,8 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n \n fn is_unit_expr(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprTup(ref v) if v.is_empty() => true,\n-        ExprBlock(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        ExprKind::Tup(ref v) if v.is_empty() => true,\n+        ExprKind::Block(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n         _ => false,\n     }\n }\n@@ -554,10 +561,10 @@ fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n         if let PatKind::Binding(rb, _, ident, _) = pats[0].node;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprCall(ref e, ref args) = remove_blocks(&arm.body).node;\n-        if let ExprPath(ref some_path) = e.node;\n+        if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).node;\n+        if let ExprKind::Path(ref some_path) = e.node;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprPath(ref qpath) = args[0].node;\n+        if let ExprKind::Path(ref qpath) = args[0].node;\n         if let &QPath::Resolved(_, ref path2) = qpath;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {"}, {"sha": "11cf8a9a791ac179e8f216d72a618e391cd784be", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use rustc::hir::{Expr, ExprCall, ExprPath};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n \n /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n@@ -30,8 +30,8 @@ impl LintPass for MemForget {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n+            if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.tables.expr_ty(&args[0]);"}, {"sha": "26a0b66094fede459bda3f89ad8daab231ad5b36", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -10,7 +10,7 @@ use syntax::codemap::{Span, BytePos};\n use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self,\n             is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n-            span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n use crate::utils::paths;\n use crate::utils::sugg;\n use crate::consts::{constant, Constant};\n@@ -718,7 +718,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         match expr.node {\n-            hir::ExprMethodCall(ref method_call, ref method_span, ref args) => {\n+            hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args) => {\n                 // Chain calls\n                 // GET_UNWRAP needs to be checked before general `UNWRAP` lints\n                 if let Some(arglists) = method_chain_args(expr, &[\"get\", \"unwrap\"]) {\n@@ -789,12 +789,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     _ => (),\n                 }\n             },\n-            hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n+            hir::ExprKind::Binary(op, ref lhs, ref rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n                     expr,\n                     chain: lhs,\n                     other: rhs,\n-                    eq: op.node == hir::BiEq,\n+                    eq: op.node == hir::BinOpKind::Eq,\n                 };\n                 lint_binary_expr_with_method_call(cx, &mut info);\n             },\n@@ -813,15 +813,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n             if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir.body(id)).next();\n-            if let hir::ItemImpl(_, _, _, _, None, ref self_ty, _) = item.node;\n+            if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n             then {\n                 if cx.access_levels.is_exported(implitem.id) {\n                 // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if name == method_name &&\n                         sig.decl.inputs.len() == n_args &&\n-                        out_type.matches(&sig.decl.output) &&\n-                        self_kind.matches(first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n+                        out_type.matches(cx, &sig.decl.output) &&\n+                        self_kind.matches(cx, first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n                             span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                                 \"defining a method called `{}` on this type; consider implementing \\\n                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -838,9 +838,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         if conv.check(&name.as_str());\n                         if !self_kinds\n                             .iter()\n-                            .any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n+                            .any(|k| k.matches(cx, first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n                         then {\n-                            let lint = if item.vis.node == hir::VisibilityKind::Public {\n+                            let lint = if item.vis.node.is_pub() {\n                                 WRONG_PUB_SELF_CONVENTION\n                             } else {\n                                 WRONG_SELF_CONVENTION\n@@ -889,7 +889,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n         }\n \n         if name == \"unwrap_or\" {\n-            if let hir::ExprPath(ref qpath) = fun.node {\n+            if let hir::ExprKind::Path(ref qpath) = fun.node {\n                 let path = &*last_path_segment(qpath).ident.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n@@ -982,13 +982,13 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n \n     if args.len() == 2 {\n         match args[1].node {\n-            hir::ExprCall(ref fun, ref or_args) => {\n+            hir::ExprKind::Call(ref fun, ref or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n                     check_general_case(cx, name, method_span, fun.span, &args[0], &args[1], or_has_args, expr.span);\n                 }\n             },\n-            hir::ExprMethodCall(_, span, ref or_args) => {\n+            hir::ExprKind::MethodCall(_, span, ref or_args) => {\n                 check_general_case(cx, name, method_span, span, &args[0], &args[1], !or_args.is_empty(), expr.span)\n             },\n             _ => {},\n@@ -999,10 +999,10 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n /// Checks for the `EXPECT_FUN_CALL` lint.\n fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n-        if let hir::ExprAddrOf(_, ref addr_of) = arg.node {\n-            if let hir::ExprCall(ref inner_fun, ref inner_args) = addr_of.node {\n+        if let hir::ExprKind::AddrOf(_, ref addr_of) = arg.node {\n+            if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = addr_of.node {\n                 if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1 {\n-                    if let hir::ExprCall(_, ref format_args) = inner_args[0].node {\n+                    if let hir::ExprKind::Call(_, ref format_args) = inner_args[0].node {\n                         return Some(format_args);\n                     }\n                 }\n@@ -1013,9 +1013,9 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n     }\n \n     fn generate_format_arg_snippet(cx: &LateContext, a: &hir::Expr) -> String {\n-        if let hir::ExprAddrOf(_, ref format_arg) = a.node {\n-            if let hir::ExprMatch(ref format_arg_expr, _, _) = format_arg.node {\n-                if let hir::ExprTup(ref format_arg_expr_tup) = format_arg_expr.node {\n+        if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n+                if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n                     return snippet(cx, format_arg_expr_tup[0].span, \"..\").into_owned();\n                 }\n             }\n@@ -1090,7 +1090,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n \n     if args.len() == 2 {\n         match args[1].node {\n-            hir::ExprLit(_) => {},\n+            hir::ExprKind::Lit(_) => {},\n             _ => check_general_case(cx, name, method_span, &args[0], &args[1], expr.span),\n         }\n     }\n@@ -1133,14 +1133,14 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n                 match cx.tcx.hir.get(parent) {\n                     hir::map::NodeExpr(parent) => match parent.node {\n                         // &*x is a nop, &x.clone() is not\n-                        hir::ExprAddrOf(..) |\n+                        hir::ExprKind::AddrOf(..) |\n                         // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                        hir::ExprMethodCall(..) => return,\n+                        hir::ExprKind::MethodCall(..) => return,\n                         _ => {},\n                     }\n                     hir::map::NodeStmt(stmt) => {\n-                        if let hir::StmtDecl(ref decl, _) = stmt.node {\n-                            if let hir::DeclLocal(ref loc) = decl.node {\n+                        if let hir::StmtKind::Decl(ref decl, _) = stmt.node {\n+                            if let hir::DeclKind::Local(ref loc) = decl.node {\n                                 if let hir::PatKind::Ref(..) = loc.pat.node {\n                                     // let ref y = *x borrows x, let ref y = x.clone() does not\n                                     return;\n@@ -1229,9 +1229,9 @@ fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n \n fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n     if_chain! {\n-        if let hir::ExprCall(ref fun, ref args) = new.node;\n+        if let hir::ExprKind::Call(ref fun, ref args) = new.node;\n         if args.len() == 1;\n-        if let hir::ExprPath(ref path) = fun.node;\n+        if let hir::ExprKind::Path(ref path) = fun.node;\n         if let Def::Method(did) = cx.tables.qpath_def(path, fun.hir_id);\n         if match_def_path(cx.tcx, did, &paths::CSTRING_NEW);\n         then {\n@@ -1274,18 +1274,18 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n     fn check_fold_with_op(\n         cx: &LateContext,\n         fold_args: &[hir::Expr],\n-        op: hir::BinOp_,\n+        op: hir::BinOpKind,\n         replacement_method_name: &str,\n         replacement_has_args: bool) {\n \n         if_chain! {\n             // Extract the body of the closure passed to fold\n-            if let hir::ExprClosure(_, _, body_id, _, _) = fold_args[2].node;\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].node;\n             let closure_body = cx.tcx.hir.body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n-            if let hir::ExprBinary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n+            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node;\n             if bin_op.node == op;\n \n             // Extract the names of the two arguments to the closure\n@@ -1329,19 +1329,19 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n \n     // Check if the first argument to .fold is a suitable literal\n     match fold_args[1].node {\n-        hir::ExprLit(ref lit) => {\n+        hir::ExprKind::Lit(ref lit) => {\n             match lit.node {\n                 ast::LitKind::Bool(false) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiOr, \"any\", true\n+                    cx, fold_args, hir::BinOpKind::Or, \"any\", true\n                 ),\n                 ast::LitKind::Bool(true) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiAnd, \"all\", true\n+                    cx, fold_args, hir::BinOpKind::And, \"all\", true\n                 ),\n                 ast::LitKind::Int(0, _) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiAdd, \"sum\", false\n+                    cx, fold_args, hir::BinOpKind::Add, \"sum\", false\n                 ),\n                 ast::LitKind::Int(1, _) => check_fold_with_op(\n-                    cx, fold_args, hir::BinOp_::BiMul, \"product\", false\n+                    cx, fold_args, hir::BinOpKind::Mul, \"product\", false\n                 ),\n                 _ => return\n             }\n@@ -1437,7 +1437,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n         }\n     }\n \n-    if let hir::ExprMethodCall(ref path, _, ref args) = expr.node {\n+    if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n         if path.ident.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n@@ -1615,7 +1615,7 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n-        let map_or_arg_is_none = if let hir::Expr_::ExprPath(ref qpath) = map_or_args[1].node {\n+        let map_or_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].node {\n             match_qpath(qpath, &paths::OPTION_NONE)\n         } else {\n             false\n@@ -1790,9 +1790,9 @@ fn lint_chars_cmp<'a, 'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprCall(ref fun, ref arg_char) = info.other.node;\n+        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.node;\n         if arg_char.len() == 1;\n-        if let hir::ExprPath(ref qpath) = fun.node;\n+        if let hir::ExprKind::Path(ref qpath) = fun.node;\n         if let Some(segment) = single_segment_path(qpath);\n         if segment.ident.name == \"Some\";\n         then {\n@@ -1844,7 +1844,7 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprLit(ref lit) = info.other.node;\n+        if let hir::ExprKind::Lit(ref lit) = info.other.node;\n         if let ast::LitKind::Char(c) = lit.node;\n         then {\n             span_lint_and_sugg(\n@@ -2030,6 +2030,7 @@ enum SelfKind {\n impl SelfKind {\n     fn matches(\n         self,\n+        cx: &LateContext,\n         ty: &hir::Ty,\n         arg: &hir::Arg,\n         self_ty: &hir::Ty,\n@@ -2047,7 +2048,7 @@ impl SelfKind {\n         // `Self`, `&mut Self`,\n         // and `Box<Self>`, including the equivalent types with `Foo`.\n \n-        let is_actually_self = |ty| is_self_ty(ty) || ty == self_ty;\n+        let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n         if is_self(arg) {\n             match self {\n                 SelfKind::Value => is_actually_self(ty),\n@@ -2056,7 +2057,7 @@ impl SelfKind {\n                         return true;\n                     }\n                     match ty.node {\n-                        hir::TyRptr(_, ref mt_ty) => {\n+                        hir::TyKind::Rptr(_, ref mt_ty) => {\n                             let mutability_match = if self == SelfKind::Ref {\n                                 mt_ty.mutbl == hir::MutImmutable\n                             } else {\n@@ -2127,8 +2128,8 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n     match (&ty.node, &self_ty.node) {\n         (\n-            &hir::TyPath(hir::QPath::Resolved(_, ref ty_path)),\n-            &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path)),\n+            &hir::TyKind::Path(hir::QPath::Resolved(_, ref ty_path)),\n+            &hir::TyKind::Path(hir::QPath::Resolved(_, ref self_ty_path)),\n         ) => ty_path\n             .segments\n             .iter()\n@@ -2139,7 +2140,7 @@ fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n }\n \n fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n-    if let hir::TyPath(ref path) = ty.node {\n+    if let hir::TyKind::Path(ref path) = ty.node {\n         single_segment_path(path)\n     } else {\n         None\n@@ -2173,20 +2174,21 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(self, ty: &hir::FunctionRetTy) -> bool {\n+    fn matches(self, cx: &LateContext, ty: &hir::FunctionRetTy) -> bool {\n+        let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n             (OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n+            (OutType::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n             (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n-            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n+            (OutType::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n+            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }\n }\n \n fn is_bool(ty: &hir::Ty) -> bool {\n-    if let hir::TyPath(ref p) = ty.node {\n+    if let hir::TyKind::Path(ref p) = ty.node {\n         match_qpath(p, &[\"bool\"])\n     } else {\n         false"}, {"sha": "fa2c9fda731e5ef6fef36e4b36bebdaca1c570f9", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -66,8 +66,8 @@ enum MinMax {\n }\n \n fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n-    if let ExprCall(ref path, ref args) = expr.node {\n-        if let ExprPath(ref qpath) = path.node {\n+    if let ExprKind::Call(ref path, ref args) = expr.node {\n+        if let ExprKind::Path(ref qpath) = path.node {\n             opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)).and_then(|def_id| {\n                 if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n                     fetch_const(cx, args, MinMax::Min)"}, {"sha": "c5440420fc1ec2cc331a59a99922d245ebe9c7b0", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -6,7 +6,7 @@ use rustc::ty;\n use syntax::codemap::{ExpnFormat, Span};\n use crate::utils::{get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal,\n             iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint,\n-            span_lint_and_then, walk_ptrs_ty};\n+            span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use crate::utils::sugg::Sugg;\n use syntax::ast::{LitKind, CRATE_NODE_ID};\n use crate::consts::{constant, Constant};\n@@ -269,8 +269,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx Stmt) {\n         if_chain! {\n-            if let StmtDecl(ref d, _) = s.node;\n-            if let DeclLocal(ref l) = d.node;\n+            if let StmtKind::Decl(ref d, _) = s.node;\n+            if let DeclKind::Local(ref l) = d.node;\n             if let PatKind::Binding(an, _, i, None) = l.pat.node;\n             if let Some(ref init) = l.init;\n             then {\n@@ -303,17 +303,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n         };\n         if_chain! {\n-            if let StmtSemi(ref expr, _) = s.node;\n-            if let Expr_::ExprBinary(ref binop, ref a, ref b) = expr.node;\n-            if binop.node == BiAnd || binop.node == BiOr;\n+            if let StmtKind::Semi(ref expr, _) = s.node;\n+            if let ExprKind::Binary(ref binop, ref a, ref b) = expr.node;\n+            if binop.node == BinOpKind::And || binop.node == BinOpKind::Or;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n                 span_lint_and_then(cx,\n                     SHORT_CIRCUIT_STATEMENT,\n                     s.span,\n                     \"boolean short circuit operator in statement may be clearer using an explicit test\",\n                     |db| {\n-                        let sugg = if binop.node == BiOr { !sugg } else { sugg };\n+                        let sugg = if binop.node == BinOpKind::Or { !sugg } else { sugg };\n                         db.span_suggestion(s.span, \"replace it with\",\n                                            format!(\"if {} {{ {}; }}\", sugg, &snippet(cx, b.span, \"..\")));\n                     });\n@@ -323,23 +323,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n-            ExprCast(ref e, ref ty) => {\n+            ExprKind::Cast(ref e, ref ty) => {\n                 check_cast(cx, expr.span, e, ty);\n                 return;\n             },\n-            ExprBinary(ref cmp, ref left, ref right) => {\n+            ExprKind::Binary(ref cmp, ref left, ref right) => {\n                 let op = cmp.node;\n                 if op.is_comparison() {\n-                    if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.node {\n                         check_nan(cx, path, expr);\n                     }\n-                    if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n+                    if let ExprKind::Path(QPath::Resolved(_, ref path)) = right.node {\n                         check_nan(cx, path, expr);\n                     }\n                     check_to_owned(cx, left, right);\n                     check_to_owned(cx, right, left);\n                 }\n-                if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n+                if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n                     if is_allowed(cx, left) || is_allowed(cx, right) {\n                         return;\n                     }\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         );\n                         db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n                     });\n-                } else if op == BiRem && is_integer_literal(right, 1) {\n+                } else if op == BinOpKind::Rem && is_integer_literal(right, 1) {\n                     span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n             },\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         let binding = match expr.node {\n-            ExprPath(ref qpath) => {\n+            ExprKind::Path(ref qpath) => {\n                 let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n@@ -392,7 +392,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     None\n                 }\n             },\n-            ExprField(_, ident) => {\n+            ExprKind::Field(_, ident) => {\n                 let name = ident.as_str();\n                 if name.starts_with('_') && !name.starts_with(\"__\") {\n                     Some(name)\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ident, Some(ref right)) = pat.node {\n-            if right.node == PatKind::Wild {\n+            if let PatKind::Wild = right.node {\n                 span_lint(\n                     cx,\n                     REDUNDANT_PATTERN,\n@@ -467,14 +467,14 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n \n fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n     let (arg_ty, snip) = match expr.node {\n-        ExprMethodCall(.., ref args) if args.len() == 1 => {\n+        ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n                 (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n-        ExprCall(ref path, ref v) if v.len() == 1 => if let ExprPath(ref path) = path.node {\n+        ExprKind::Call(ref path, ref v) if v.len() == 1 => if let ExprKind::Path(ref path) = path.node {\n             if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n                 (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n             } else {\n@@ -520,7 +520,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n             let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n             if parent_impl != CRATE_NODE_ID {\n                 if let map::NodeItem(item) = cx.tcx.hir.get(parent_impl) {\n-                    if let ItemImpl(.., Some(ref trait_ref), _, _) = item.node {\n+                    if let ItemKind::Impl(.., Some(ref trait_ref), _, _) = item.node {\n                         if trait_ref.path.def.def_id() == partial_eq_trait_id {\n                             // we are implementing PartialEq, don't suggest not doing `to_owned`, otherwise\n                             // we go into\n@@ -542,7 +542,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            ExprKind::Assign(_, ref rhs) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n             _ => is_used(cx, parent),\n         }\n     } else {\n@@ -571,8 +571,8 @@ fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n \n fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n     if_chain! {\n-        if let TyPtr(MutTy { mutbl, .. }) = ty.node;\n-        if let ExprLit(ref lit) = e.node;\n+        if let TyKind::Ptr(MutTy { mutbl, .. }) = ty.node;\n+        if let ExprKind::Lit(ref lit) = e.node;\n         if let LitKind::Int(value, ..) = lit.node;\n         if value == 0;\n         if !in_constant(cx, e.id);"}, {"sha": "e527a05c85185addd950ab3f23be4cbb5f6656cc", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -213,7 +213,7 @@ impl EarlyLintPass for MiscEarly {\n                 .name;\n \n             for field in pfields {\n-                if field.node.pat.node == PatKind::Wild {\n+                if let PatKind::Wild = field.node.pat.node {\n                     wilds += 1;\n                 }\n             }\n@@ -231,14 +231,15 @@ impl EarlyLintPass for MiscEarly {\n                 let mut normal = vec![];\n \n                 for field in pfields {\n-                    if field.node.pat.node != PatKind::Wild {\n-                        if let Ok(n) = cx.sess().codemap().span_to_snippet(field.span) {\n+                    match field.node.pat.node {\n+                        PatKind::Wild => {},\n+                        _ => if let Ok(n) = cx.sess().codemap().span_to_snippet(field.span) {\n                             normal.push(n);\n-                        }\n+                        },\n                     }\n                 }\n                 for field in pfields {\n-                    if field.node.pat.node == PatKind::Wild {\n+                    if let PatKind::Wild = field.node.pat.node {\n                         wilds -= 1;\n                         if wilds > 0 {\n                             span_lint("}, {"sha": "eb4dfe8ba1c2554c36694c48a6d987a4ad1a40e7", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -122,9 +122,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n         let desc = match it.node {\n-            hir::ItemConst(..) => \"a constant\",\n-            hir::ItemEnum(..) => \"an enum\",\n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Const(..) => \"a constant\",\n+            hir::ItemKind::Enum(..) => \"an enum\",\n+            hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.name == \"main\" {\n                     let def_id = cx.tcx.hir.local_def_id(it.id);\n@@ -135,19 +135,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 }\n                 \"a function\"\n             },\n-            hir::ItemMod(..) => \"a module\",\n-            hir::ItemStatic(..) => \"a static\",\n-            hir::ItemStruct(..) => \"a struct\",\n-            hir::ItemTrait(..) => \"a trait\",\n-            hir::ItemTraitAlias(..) => \"a trait alias\",\n-            hir::ItemGlobalAsm(..) => \"an assembly blob\",\n-            hir::ItemTy(..) => \"a type alias\",\n-            hir::ItemUnion(..) => \"a union\",\n-            hir::ItemExistential(..) => \"an existential type\",\n-            hir::ItemExternCrate(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemUse(..) => return,\n+            hir::ItemKind::Mod(..) => \"a module\",\n+            hir::ItemKind::Static(..) => \"a static\",\n+            hir::ItemKind::Struct(..) => \"a struct\",\n+            hir::ItemKind::Trait(..) => \"a trait\",\n+            hir::ItemKind::TraitAlias(..) => \"a trait alias\",\n+            hir::ItemKind::GlobalAsm(..) => \"an assembly blob\",\n+            hir::ItemKind::Ty(..) => \"a type alias\",\n+            hir::ItemKind::Union(..) => \"a union\",\n+            hir::ItemKind::Existential(..) => \"an existential type\",\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::ForeignMod(..) |\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::Use(..) => return,\n         };\n \n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);"}, {"sha": "0ca1c53d696e285045dd23c0ea9deb800c846d7f", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -108,11 +108,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             return;\n         }\n         match it.node {\n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 let desc = \"a function\";\n                 check_missing_inline_attrs(cx, &it.attrs, it.span, desc);\n             },\n-            hir::ItemTrait(ref _is_auto, ref _unsafe, ref _generics,\n+            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics,\n                            ref _bounds, ref trait_items)  => {\n                 // note: we need to check if the trait is exported so we can't use\n                 // `LateLintPass::check_trait_item` here.\n@@ -134,20 +134,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                     }\n                 }\n             }\n-            hir::ItemConst(..) |\n-            hir::ItemEnum(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTraitAlias(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemUnion(..) |\n-            hir::ItemExistential(..) |\n-            hir::ItemExternCrate(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemUse(..) => {},\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Mod(..) |\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::GlobalAsm(..) |\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::ForeignMod(..) |\n+            hir::ItemKind::Impl(..) |\n+            hir::ItemKind::Use(..) => {},\n         };\n     }\n "}, {"sha": "ef08e60c4efe5936fd8413e14d5ec5ce67f62edc", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -62,8 +62,8 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             // Let's ignore the generated code.\n             intravisit::walk_expr(self, arg);\n             intravisit::walk_expr(self, body);\n-        } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n-            if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n+        } else if let hir::ExprKind::AddrOf(hir::MutMutable, ref e) = expr.node {\n+            if let hir::ExprKind::AddrOf(hir::MutMutable, _) = e.node {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,\n@@ -87,15 +87,15 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyRptr(\n+        if let hir::TyKind::Rptr(\n             _,\n             hir::MutTy {\n                 ty: ref pty,\n                 mutbl: hir::MutMutable,\n             },\n         ) = ty.node\n         {\n-            if let hir::TyRptr(\n+            if let hir::TyKind::Rptr(\n                 _,\n                 hir::MutTy {\n                     mutbl: hir::MutMutable,"}, {"sha": "b4d6652a65a4d00b7c26b72057bc031056452353", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -36,15 +36,15 @@ impl LintPass for UnnecessaryMutPassed {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         match e.node {\n-            ExprCall(ref fn_expr, ref arguments) => if let ExprPath(ref path) = fn_expr.node {\n+            ExprKind::Call(ref fn_expr, ref arguments) => if let ExprKind::Path(ref path) = fn_expr.node {\n                 check_arguments(\n                     cx,\n                     arguments,\n                     cx.tables.expr_ty(fn_expr),\n                     &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n                 );\n             },\n-            ExprMethodCall(ref path, _, ref arguments) => {\n+            ExprKind::MethodCall(ref path, _, ref arguments) => {\n                 let def_id = cx.tables.type_dependent_defs()[e.hir_id].def_id();\n                 let substs = cx.tables.node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n@@ -69,7 +69,7 @@ fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], typ\n                     ty::TyRawPtr(ty::TypeAndMut {\n                         mutbl: MutImmutable,\n                         ..\n-                    }) => if let ExprAddrOf(MutMutable, _) = argument.node {\n+                    }) => if let ExprKind::AddrOf(MutMutable, _) = argument.node {\n                         span_lint(\n                             cx,\n                             UNNECESSARY_MUT_PASSED,"}, {"sha": "2fd5ff9a246476b1cf59571ff226758968735271", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -60,7 +60,7 @@ impl LintPass for NeedlessBool {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n-        if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n+        if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n                 let snip = Sugg::hir(cx, pred, \"<predicate>\");\n                 let snip = if not { !snip } else { snip };\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     hint,\n                 );\n             };\n-            if let ExprBlock(ref then_block, _) = then_block.node {\n+            if let ExprKind::Block(ref then_block, _) = then_block.node {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                     _ => (),\n                 }\n             } else {\n-                panic!(\"IfExpr 'then' node is not an ExprBlock\");\n+                panic!(\"IfExpr 'then' node is not an ExprKind::Block\");\n             }\n         }\n     }\n@@ -123,7 +123,7 @@ impl LintPass for BoolComparison {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n-        if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Eq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n                 (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n@@ -184,8 +184,8 @@ enum Expression {\n fn fetch_bool_block(block: &Block) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n-        (&[ref e], None) => if let StmtSemi(ref e, _) = e.node {\n-            if let ExprRet(_) = e.node {\n+        (&[ref e], None) => if let StmtKind::Semi(ref e, _) = e.node {\n+            if let ExprKind::Ret(_) = e.node {\n                 fetch_bool_expr(&**e)\n             } else {\n                 Expression::Other\n@@ -199,13 +199,13 @@ fn fetch_bool_block(block: &Block) -> Expression {\n \n fn fetch_bool_expr(expr: &Expr) -> Expression {\n     match expr.node {\n-        ExprBlock(ref block, _) => fetch_bool_block(block),\n-        ExprLit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n+        ExprKind::Block(ref block, _) => fetch_bool_block(block),\n+        ExprKind::Lit(ref lit_ptr) => if let LitKind::Bool(value) = lit_ptr.node {\n             Expression::Bool(value)\n         } else {\n             Expression::Other\n         },\n-        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n+        ExprKind::Ret(Some(ref expr)) => match fetch_bool_expr(expr) {\n             Expression::Bool(value) => Expression::RetBool(value),\n             _ => Expression::Other,\n         },"}, {"sha": "90e41bc6f68ac02916e1a053ca5e6d4b8b494070", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -3,7 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use rustc::hir::{BindingAnnotation, Expr, ExprAddrOf, MutImmutable, Pat, PatKind};\n+use rustc::hir::{BindingAnnotation, Expr, ExprKind, MutImmutable, Pat, PatKind};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         if in_macro(e.span) {\n             return;\n         }\n-        if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n+        if let ExprKind::AddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n                 for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n                     if let [Adjustment {"}, {"sha": "fa0586c1548aafe3b82cc9a070c41d909180aa41", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -88,8 +88,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         // Exclude non-inherent impls\n         if let Some(NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(node_id)) {\n-            if matches!(item.node, ItemImpl(_, _, _, _, Some(_), _, _) |\n-                ItemTrait(..))\n+            if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n+                ItemKind::Trait(..))\n             {\n                 return;\n             }\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                             if match_type(cx, ty, &paths::VEC);\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n-                            if let TyPath(QPath::Resolved(_, ref path)) = input.node;\n+                            if let TyKind::Path(QPath::Resolved(_, ref path)) = input.node;\n                             if let Some(elem_ty) = path.segments.iter()\n                                 .find(|seg| seg.ident.name == \"Vec\")\n                                 .and_then(|ps| ps.args.as_ref())\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                     match node {\n                         map::Node::NodeExpr(e) => {\n                             // `match` and `if let`\n-                            if let ExprMatch(ref c, ..) = e.node {\n+                            if let ExprKind::Match(ref c, ..) = e.node {\n                                 self.spans_need_deref\n                                     .entry(vid)\n                                     .or_insert_with(HashSet::new)\n@@ -350,8 +350,8 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                         map::Node::NodeStmt(s) => {\n                             // `let <pat> = x;`\n                             if_chain! {\n-                                if let StmtDecl(ref decl, _) = s.node;\n-                                if let DeclLocal(ref local) = decl.node;\n+                                if let StmtKind::Decl(ref decl, _) = s.node;\n+                                if let DeclKind::Local(ref local) = decl.node;\n                                 then {\n                                     self.spans_need_deref\n                                         .entry(vid)"}, {"sha": "9c670c1a5b3e7507356d60bf11183df733e1cdd8", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n-use rustc::hir::{Expr, ExprStruct};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::span_lint;\n \n /// **What it does:** Checks for needlessly including a base struct on update\n@@ -32,7 +32,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.non_enum_variant().fields.len() {"}, {"sha": "e0374b80dd810a490150e3af3f2f2c442cbdef80", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -18,20 +18,20 @@ use crate::utils::{self, paths, span_lint, in_external_macro};\n ///\n /// ```rust\n /// use core::cmp::Ordering;\n-/// \n+///\n /// // Bad\n /// let a = 1.0;\n /// let b = std::f64::NAN;\n-/// \n+///\n /// let _not_less_or_equal = !(a <= b);\n ///\n /// // Good\n /// let a = 1.0;\n /// let b = std::f64::NAN;\n-/// \n+///\n /// let _not_less_or_equal = match a.partial_cmp(&b) {\n ///     None | Some(Ordering::Greater) => true,\n-///     _ => false, \n+///     _ => false,\n /// };\n /// ```\n declare_clippy_lint! {\n@@ -54,9 +54,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n         if_chain! {\n \n             if !in_external_macro(cx, expr.span);\n-            if let Expr_::ExprUnary(UnOp::UnNot, ref inner) = expr.node;\n-            if let Expr_::ExprBinary(ref op, ref left, _) = inner.node;\n-            if let BinOp_::BiLe | BinOp_::BiGe | BinOp_::BiLt | BinOp_::BiGt = op.node;\n+            if let ExprKind::Unary(UnOp::UnNot, ref inner) = expr.node;\n+            if let ExprKind::Binary(ref op, ref left, _) = inner.node;\n+            if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n \n             then {\n "}, {"sha": "e30ac8695dc8fef99eabd772f29eaf88668f8b91", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -33,11 +33,11 @@ impl LintPass for NegMultiply {\n #[allow(match_same_arms)]\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(Spanned { node: BiMul, .. }, ref l, ref r) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref l, ref r) = e.node {\n             match (&l.node, &r.node) {\n-                (&ExprUnary(..), &ExprUnary(..)) => (),\n-                (&ExprUnary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n-                (_, &ExprUnary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n+                (&ExprKind::Unary(..), &ExprKind::Unary(..)) => (),\n+                (&ExprKind::Unary(UnNeg, ref lit), _) => check_mul(cx, e.span, lit, r),\n+                (_, &ExprKind::Unary(UnNeg, ref lit)) => check_mul(cx, e.span, lit, l),\n                 _ => (),\n             }\n         }\n@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n \n fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n     if_chain! {\n-        if let ExprLit(ref l) = lit.node;\n+        if let ExprKind::Lit(ref l) = lit.node;\n         if let Constant::Int(val) = consts::lit_to_constant(&l.node, cx.tables.expr_ty(lit));\n         if val == 1;\n         if cx.tables.expr_ty(exp).is_integral();"}, {"sha": "6be340a99f4a09c95a41d8329f77848403224cc3", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -89,7 +89,7 @@ impl LintPass for NewWithoutDefault {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n-        if let hir::ItemImpl(_, _, _, _, None, _, ref items) = item.node {\n+        if let hir::ItemKind::Impl(_, _, _, _, None, _, ref items) = item.node {\n             for assoc_item in items {\n                 if let hir::AssociatedItemKind::Method { has_self: false } = assoc_item.kind {\n                     let impl_item = cx.tcx.hir.impl_item(assoc_item.id);"}, {"sha": "5180ff34877878f89249f9365a98a0441cf3acf9", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::def::Def;\n-use rustc::hir::{BiAnd, BiOr, BlockCheckMode, Expr, Expr_, Stmt, StmtSemi, UnsafeSource};\n+use rustc::hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n use crate::utils::{has_drop, in_macro, snippet_opt, span_lint, span_lint_and_sugg};\n use std::ops::Deref;\n \n@@ -45,26 +45,26 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         return false;\n     }\n     match expr.node {\n-        Expr_::ExprLit(..) | Expr_::ExprClosure(.., _) => true,\n-        Expr_::ExprPath(..) => !has_drop(cx, expr),\n-        Expr_::ExprIndex(ref a, ref b) | Expr_::ExprBinary(_, ref a, ref b) => {\n+        ExprKind::Lit(..) | ExprKind::Closure(.., _) => true,\n+        ExprKind::Path(..) => !has_drop(cx, expr),\n+        ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n             has_no_effect(cx, a) && has_no_effect(cx, b)\n         },\n-        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        Expr_::ExprRepeat(ref inner, _) |\n-        Expr_::ExprCast(ref inner, _) |\n-        Expr_::ExprType(ref inner, _) |\n-        Expr_::ExprUnary(_, ref inner) |\n-        Expr_::ExprField(ref inner, _) |\n-        Expr_::ExprAddrOf(_, ref inner) |\n-        Expr_::ExprBox(ref inner) => has_no_effect(cx, inner),\n-        Expr_::ExprStruct(_, ref fields, ref base) => {\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n+        ExprKind::Repeat(ref inner, _) |\n+        ExprKind::Cast(ref inner, _) |\n+        ExprKind::Type(ref inner, _) |\n+        ExprKind::Unary(_, ref inner) |\n+        ExprKind::Field(ref inner, _) |\n+        ExprKind::AddrOf(_, ref inner) |\n+        ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n+        ExprKind::Struct(_, ref fields, ref base) => {\n             !has_drop(cx, expr) && fields.iter().all(|field| has_no_effect(cx, &field.expr)) && match *base {\n                 Some(ref base) => has_no_effect(cx, base),\n                 None => true,\n             }\n         },\n-        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n             let def = cx.tables.qpath_def(qpath, callee.hir_id);\n             match def {\n                 Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) => {\n@@ -75,7 +75,7 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n         } else {\n             false\n         },\n-        Expr_::ExprBlock(ref block, _) => {\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n                 has_no_effect(cx, expr)\n             } else {\n@@ -97,7 +97,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n-        if let StmtSemi(ref expr, _) = stmt.node {\n+        if let StmtKind::Semi(ref expr, _) = stmt.node {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n@@ -132,19 +132,19 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         return None;\n     }\n     match expr.node {\n-        Expr_::ExprIndex(ref a, ref b) => Some(vec![&**a, &**b]),\n-        Expr_::ExprBinary(ref binop, ref a, ref b) if binop.node != BiAnd && binop.node != BiOr => {\n+        ExprKind::Index(ref a, ref b) => Some(vec![&**a, &**b]),\n+        ExprKind::Binary(ref binop, ref a, ref b) if binop.node != BinOpKind::And && binop.node != BinOpKind::Or => {\n             Some(vec![&**a, &**b])\n         },\n-        Expr_::ExprArray(ref v) | Expr_::ExprTup(ref v) => Some(v.iter().collect()),\n-        Expr_::ExprRepeat(ref inner, _) |\n-        Expr_::ExprCast(ref inner, _) |\n-        Expr_::ExprType(ref inner, _) |\n-        Expr_::ExprUnary(_, ref inner) |\n-        Expr_::ExprField(ref inner, _) |\n-        Expr_::ExprAddrOf(_, ref inner) |\n-        Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        Expr_::ExprStruct(_, ref fields, ref base) => if has_drop(cx, expr) {\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => Some(v.iter().collect()),\n+        ExprKind::Repeat(ref inner, _) |\n+        ExprKind::Cast(ref inner, _) |\n+        ExprKind::Type(ref inner, _) |\n+        ExprKind::Unary(_, ref inner) |\n+        ExprKind::Field(ref inner, _) |\n+        ExprKind::AddrOf(_, ref inner) |\n+        ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n+        ExprKind::Struct(_, ref fields, ref base) => if has_drop(cx, expr) {\n             None\n         } else {\n             Some(\n@@ -156,7 +156,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n                     .collect(),\n             )\n         },\n-        Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n+        ExprKind::Call(ref callee, ref args) => if let ExprKind::Path(ref qpath) = callee.node {\n             let def = cx.tables.qpath_def(qpath, callee.hir_id);\n             match def {\n                 Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..)\n@@ -169,7 +169,7 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         } else {\n             None\n         },\n-        Expr_::ExprBlock(ref block, _) => {\n+        ExprKind::Block(ref block, _) => {\n             if block.stmts.is_empty() {\n                 block.expr.as_ref().and_then(|e| {\n                     match block.rules {"}, {"sha": "981451947bfef18fff0b1ac050d89a540dfd4918", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -164,7 +164,7 @@ impl LintPass for NonCopyConst {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx Item) {\n-        if let ItemConst(hir_ty, ..) = &it.node {\n+        if let ItemKind::Const(hir_ty, ..) = &it.node {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             verify_ty_bound(cx, ty, Source::Item { item: it.span });\n         }\n@@ -182,15 +182,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n             let item_node_id = cx.tcx.hir.get_parent_node(impl_item.id);\n             let item = cx.tcx.hir.expect_item(item_node_id);\n             // ensure the impl is an inherent impl.\n-            if let ItemImpl(_, _, _, _, None, _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n                 verify_ty_bound(cx, ty, Source::Assoc { ty: hir_ty.span, item: impl_item.span });\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprPath(qpath) = &expr.node {\n+        if let ExprKind::Path(qpath) = &expr.node {\n             // Only lint if we use the const item inside a function.\n             if in_constant(cx, expr.id) {\n                 return;\n@@ -213,22 +213,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n                 }\n                 if let Some(map::NodeExpr(parent_expr)) = cx.tcx.hir.find(parent_id) {\n                     match &parent_expr.node {\n-                        ExprAddrOf(..) => {\n+                        ExprKind::AddrOf(..) => {\n                             // `&e` => `e` must be referenced\n                             needs_check_adjustment = false;\n                         }\n-                        ExprField(..) => {\n+                        ExprKind::Field(..) => {\n                             dereferenced_expr = parent_expr;\n                             needs_check_adjustment = true;\n                         }\n-                        ExprIndex(e, _) if ptr::eq(&**e, cur_expr) => {\n+                        ExprKind::Index(e, _) if ptr::eq(&**e, cur_expr) => {\n                             // `e[i]` => desugared to `*Index::index(&e, i)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now.\n                             needs_check_adjustment = false;\n                             break;\n                         }\n-                        ExprUnary(UnDeref, _) => {\n+                        ExprKind::Unary(UnDeref, _) => {\n                             // `*e` => desugared to `*Deref::deref(&e)`,\n                             // meaning `e` must be referenced.\n                             // no need to go further up since a method call is involved now."}, {"sha": "0a1399075e067886b508c9264e003aba6f5c93fa", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -44,9 +44,9 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! { //begin checking variables\n-            if let ExprMatch(ref op, ref body, ref source) = expr.node; //test if expr is a match\n+            if let ExprKind::Match(ref op, ref body, ref source) = expr.node; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let\n-            if let ExprMethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n+            if let ExprKind::MethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n "}, {"sha": "b4559969ac246ca1d66a08b384118b071fa78eba", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::{Expr, ExprLit, ExprMethodCall};\n+use rustc::hir::{Expr, ExprKind};\n use rustc::lint::*;\n use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n@@ -33,7 +33,7 @@ impl LintPass for NonSensical {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprMethodCall(ref path, _, ref arguments) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref arguments) = e.node {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n             if path.ident.name == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -61,13 +61,13 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprMethodCall(ref path, _, ref arguments) = argument.node {\n+    if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.node {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions\n         if match_type(cx, obj_ty, &paths::OPEN_OPTIONS) && arguments.len() >= 2 {\n             let argument_option = match arguments[1].node {\n-                ExprLit(ref span) => {\n+                ExprKind::Lit(ref span) => {\n                     if let Spanned {\n                         node: LitKind::Bool(lit),\n                         .."}, {"sha": "8783055b31eef1ebaa2eeb9c46a5eed8fd05a62e", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use crate::utils::span_lint;\n+use crate::utils::{span_lint, SpanlessEq};\n \n /// **What it does:** Detects classic underflow/overflow checks.\n ///\n@@ -31,24 +31,25 @@ impl LintPass for OverflowCheckConditional {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n-            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node;\n-            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = first.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.node;\n+            if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n             then {\n-                if let BinOp_::BiLt = op.node {\n-                    if let BinOp_::BiAdd = op2.node {\n+                if let BinOpKind::Lt = op.node {\n+                    if let BinOpKind::Add = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                     }\n                 }\n-                if let BinOp_::BiGt = op.node {\n-                    if let BinOp_::BiSub = op2.node {\n+                if let BinOpKind::Gt = op.node {\n+                    if let BinOpKind::Sub = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                     }\n@@ -57,23 +58,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n         }\n \n         if_chain! {\n-            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n-            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n-            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node;\n-            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if let ExprKind::Binary(ref op, ref first, ref second) = expr.node;\n+            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = second.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.node;\n+            if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n             then {\n-                if let BinOp_::BiGt = op.node {\n-                    if let BinOp_::BiAdd = op2.node {\n+                if let BinOpKind::Gt = op.node {\n+                    if let BinOpKind::Add = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n                     }\n                 }\n-                if let BinOp_::BiLt = op.node {\n-                    if let BinOp_::BiSub = op2.node {\n+                if let BinOpKind::Lt = op.node {\n+                    if let BinOpKind::Sub = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n                             \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n                     }"}, {"sha": "24cf6544f6a061f9212cb3fa42f404ba94cc62b8", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -52,10 +52,10 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprBlock(ref block, _) = expr.node;\n+            if let ExprKind::Block(ref block, _) = expr.node;\n             if let Some(ref ex) = block.expr;\n-            if let ExprCall(ref fun, ref params) = ex.node;\n-            if let ExprPath(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref params) = ex.node;\n+            if let ExprKind::Path(ref qpath) = fun.node;\n             if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n             if match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC);\n             if params.len() == 2;\n@@ -86,7 +86,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n \n fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext) {\n     if_chain! {\n-        if let ExprLit(ref lit) = params[0].node;\n+        if let ExprKind::Lit(ref lit) = params[0].node;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();\n         if let LitKind::Str(ref string, _) = lit.node;\n         let string = string.as_str().replace(\"{{\", \"\").replace(\"}}\", \"\");"}, {"sha": "2d283b96f867e14f497654dcd9de502d3b1c7aae", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -38,7 +38,7 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if_chain! {\n-            if let ItemImpl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.node;\n+            if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.node;\n             if !is_automatically_derived(&*item.attrs);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.def.def_id() == eq_trait;"}, {"sha": "22804764d8aaae45b260c1a1f5ad78b30c921f92", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -103,15 +103,15 @@ impl LintPass for PointerPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemFn(ref decl, _, _, body_id) = item.node {\n+        if let ItemKind::Fn(ref decl, _, _, body_id) = item.node {\n             check_fn(cx, decl, item.id, Some(body_id));\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, body_id) = item.node {\n             if let Some(NodeItem(it)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(item.id)) {\n-                if let ItemImpl(_, _, _, _, Some(_), _, _) = it.node {\n+                if let ItemKind::Impl(_, _, _, _, Some(_), _, _) = it.node {\n                     return; // ignore trait impls\n                 }\n             }\n@@ -131,8 +131,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref op, ref l, ref r) = expr.node {\n-            if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n+        if let ExprKind::Binary(ref op, ref l, ref r) = expr.node {\n+            if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n                     cx,\n                     CMP_NULL,\n@@ -159,7 +159,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n             if match_type(cx, ty, &paths::VEC) {\n                 let mut ty_snippet = None;\n                 if_chain! {\n-                    if let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n+                    if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n                     if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n                     then {\n                         let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n@@ -219,8 +219,8 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                 }\n             } else if match_type(cx, ty, &paths::COW) {\n                 if_chain! {\n-                    if let TyRptr(_, MutTy { ref ty, ..} ) = arg.node;\n-                    if let TyPath(ref path) = ty.node;\n+                    if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.node;\n+                    if let TyKind::Path(ref path) = ty.node;\n                     if let QPath::Resolved(None, ref pp) = *path;\n                     if let [ref bx] = *pp.segments;\n                     if let Some(ref params) = bx.args;\n@@ -273,17 +273,17 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n }\n \n fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n-    if let Ty_::TyRptr(ref lt, ref m) = ty.node {\n+    if let TyKind::Rptr(ref lt, ref m) = ty.node {\n         Some((lt, m.mutbl, ty.span))\n     } else {\n         None\n     }\n }\n \n fn is_null_path(expr: &Expr) -> bool {\n-    if let ExprCall(ref pathexp, ref args) = expr.node {\n+    if let ExprKind::Call(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n-            if let ExprPath(ref path) = pathexp.node {\n+            if let ExprKind::Path(ref path) = pathexp.node {\n                 return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);\n             }\n         }"}, {"sha": "b8e7a2646c489e178ddb0fe9bbc811f97f523733", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -52,8 +52,8 @@ impl QuestionMarkPass {\n     /// If it matches, it will suggest to use the question mark operator instead\n     fn check_is_none_and_early_return_none(cx: &LateContext, expr: &Expr) {\n         if_chain! {\n-            if let ExprIf(ref if_expr, ref body, _) = expr.node;\n-            if let ExprMethodCall(ref segment, _, ref args) = if_expr.node;\n+            if let ExprKind::If(ref if_expr, ref body, _) = expr.node;\n+            if let ExprKind::MethodCall(ref segment, _, ref args) = if_expr.node;\n             if segment.ident.name == \"is_none\";\n             if Self::expression_returns_none(cx, body);\n             if let Some(subject) = args.get(0);\n@@ -87,17 +87,17 @@ impl QuestionMarkPass {\n \n     fn expression_returns_none(cx: &LateContext, expression: &Expr) -> bool {\n         match expression.node {\n-            ExprBlock(ref block, _) => {\n+            ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n                     return Self::expression_returns_none(cx, &return_expression);\n                 }\n \n                 false\n             },\n-            ExprRet(Some(ref expr)) => {\n+            ExprKind::Ret(Some(ref expr)) => {\n                 Self::expression_returns_none(cx, expr)\n             },\n-            ExprPath(ref qp) => {\n+            ExprKind::Path(ref qp) => {\n                 if let Def::VariantCtor(def_id, _) = cx.tables.qpath_def(qp, expression.hir_id) {\n                     return match_def_path(cx.tcx, def_id,  &OPTION_NONE);\n                 }\n@@ -113,8 +113,8 @@ impl QuestionMarkPass {\n         if_chain! {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n-            if let StmtSemi(ref expr, _) = expr.node;\n-            if let ExprRet(ref ret_expr) = expr.node;\n+            if let StmtKind::Semi(ref expr, _) = expr.node;\n+            if let ExprKind::Ret(ref ret_expr) = expr.node;\n             if let &Some(ref ret_expr) = ret_expr;\n \n             then {"}, {"sha": "2fb3bf5182cd8b546ac5731a152a734378d10e1c", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::*;\n use syntax::ast::RangeLimits;\n use syntax::codemap::Spanned;\n use crate::utils::{is_integer_literal, paths, snippet, span_lint, span_lint_and_then};\n-use crate::utils::{get_trait_def_id, higher, implements_trait};\n+use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n use crate::utils::sugg::Sugg;\n \n /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n@@ -88,7 +88,7 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprMethodCall(ref path, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n             let name = path.ident.as_str();\n \n             // Range with step_by(0).\n@@ -107,18 +107,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let zip_arg = &args[1];\n                 if_chain! {\n                     // .iter() call\n-                    if let ExprMethodCall(ref iter_path, _, ref iter_args ) = *iter;\n+                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args ) = *iter;\n                     if iter_path.ident.name == \"iter\";\n                     // range expression in .zip() call: 0..x.len()\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_literal(start, 0);\n                     // .len() call\n-                    if let ExprMethodCall(ref len_path, _, ref len_args) = end.node;\n+                    if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.node;\n                     if len_path.ident.name == \"len\" && len_args.len() == 1;\n                     // .iter() and .len() called on same Path\n-                    if let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n-                    if let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n-                    if iter_path.segments == len_path.segments;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n+                    if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n+                    if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n                      then {\n                          span_lint(cx,\n                                    RANGE_ZIP_WITH_LEN,\n@@ -184,7 +184,7 @@ fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n \n fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprBinary(Spanned { node: BiAdd, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n+        ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n             Some(rhs)\n         } else if is_integer_literal(rhs, 1) {\n             Some(lhs)\n@@ -197,7 +197,7 @@ fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n \n fn y_minus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprBinary(Spanned { node: BiSub, .. }, ref lhs, ref rhs) if is_integer_literal(rhs, 1) => Some(lhs),\n+        ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) if is_integer_literal(rhs, 1) => Some(lhs),\n         _ => None,\n     }\n }"}, {"sha": "d179bffd59adebb3b999f51f2e74440efd0213c7", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantFieldNames {\n             return;\n         }\n \n-        if let ExprStruct(_, ref fields, _) = expr.node {\n+        if let ExprKind::Struct(_, ref fields, _) = expr.node {\n             for field in fields {\n                 let name = field.ident.name;\n "}, {"sha": "fbead26a03b0b55d67090cf2d6431512dccdc8ec", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref fun, ref args) = expr.node;\n-            if let ExprPath(ref qpath) = fun.node;\n+            if let ExprKind::Call(ref fun, ref args) = expr.node;\n+            if let ExprKind::Path(ref qpath) = fun.node;\n             if args.len() == 1;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, fun.hir_id));\n             then {\n@@ -176,8 +176,8 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n \n fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         then {\n             for expr in exprs {\n                 check_regex(cx, expr, utf8);\n@@ -192,7 +192,7 @@ fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: boo\n         .allow_invalid_utf8(!utf8)\n         .build();\n \n-    if let ExprLit(ref lit) = expr.node {\n+    if let ExprKind::Lit(ref lit) = expr.node {\n         if let LitKind::Str(ref r, style) = lit.node {\n             let r = &r.as_str();\n             let offset = if let StrStyle::Raw(n) = style { 2 + n } else { 1 };"}, {"sha": "f149e3248772755bfaf848a4399bf8ca26a45a6e", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -37,7 +37,7 @@ impl LintPass for ReplaceConsts {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n-            if let hir::ExprPath(ref qp) = expr.node;\n+            if let hir::ExprKind::Path(ref qp) = expr.node;\n             if let Def::Const(def_id) = cx.tables.qpath_def(qp, expr.hir_id);\n             then {\n                 for &(const_path, repl_snip) in REPLACEMENTS {"}, {"sha": "55c51307e04d2ded4234f9e6420f02ca3370866a", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -29,7 +29,7 @@ impl LintPass for Serde {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Serde {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemImpl(_, _, _, _, Some(ref trait_ref), _, ref items) = item.node {\n+        if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, ref items) = item.node {\n             let did = trait_ref.path.def.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {\n                 if did == visit_did {"}, {"sha": "cc08e1ee816fea8fa44fa6f95706535e3102360e", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -110,8 +110,8 @@ fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, binding\n     let len = bindings.len();\n     for stmt in &block.stmts {\n         match stmt.node {\n-            StmtDecl(ref decl, _) => check_decl(cx, decl, bindings),\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => check_expr(cx, e, bindings),\n+            StmtKind::Decl(ref decl, _) => check_decl(cx, decl, bindings),\n+            StmtKind::Expr(ref e, _) | StmtKind::Semi(ref e, _) => check_expr(cx, e, bindings),\n         }\n     }\n     if let Some(ref o) = block.expr {\n@@ -127,7 +127,7 @@ fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings:\n     if higher::is_from_for_desugar(decl) {\n         return;\n     }\n-    if let DeclLocal(ref local) = decl.node {\n+    if let DeclKind::Local(ref local) = decl.node {\n         let Local {\n             ref pat,\n             ref ty,\n@@ -185,7 +185,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Struct(_, ref pfields, _) => if let Some(init_struct) = init {\n-            if let ExprStruct(_, ref efields, _) = init_struct.node {\n+            if let ExprKind::Struct(_, ref efields, _) = init_struct.node {\n                 for field in pfields {\n                     let name = field.node.ident.name;\n                     let efield = efields\n@@ -205,7 +205,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Tuple(ref inner, _) => if let Some(init_tup) = init {\n-            if let ExprTup(ref tup) = init_tup.node {\n+            if let ExprKind::Tup(ref tup) = init_tup.node {\n                 for (i, p) in inner.iter().enumerate() {\n                     check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                 }\n@@ -220,7 +220,7 @@ fn check_pat<'a, 'tcx>(\n             }\n         },\n         PatKind::Box(ref inner) => if let Some(initp) = init {\n-            if let ExprBox(ref inner_init) = initp.node {\n+            if let ExprKind::Box(ref inner_init) = initp.node {\n                 check_pat(cx, inner, Some(&**inner_init), span, bindings);\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n@@ -306,27 +306,27 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n         return;\n     }\n     match expr.node {\n-        ExprUnary(_, ref e) | ExprField(ref e, _) | ExprAddrOf(_, ref e) | ExprBox(ref e) => {\n+        ExprKind::Unary(_, ref e) | ExprKind::Field(ref e, _) | ExprKind::AddrOf(_, ref e) | ExprKind::Box(ref e) => {\n             check_expr(cx, e, bindings)\n         },\n-        ExprBlock(ref block, _) | ExprLoop(ref block, _, _) => check_block(cx, block, bindings),\n-        // ExprCall\n-        // ExprMethodCall\n-        ExprArray(ref v) | ExprTup(ref v) => for e in v {\n+        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, _, _) => check_block(cx, block, bindings),\n+        // ExprKind::Call\n+        // ExprKind::MethodCall\n+        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => for e in v {\n             check_expr(cx, e, bindings)\n         },\n-        ExprIf(ref cond, ref then, ref otherwise) => {\n+        ExprKind::If(ref cond, ref then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n             check_expr(cx, &**then, bindings);\n             if let Some(ref o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }\n         },\n-        ExprWhile(ref cond, ref block, _) => {\n+        ExprKind::While(ref cond, ref block, _) => {\n             check_expr(cx, cond, bindings);\n             check_block(cx, block, bindings);\n         },\n-        ExprMatch(ref init, ref arms, _) => {\n+        ExprKind::Match(ref init, ref arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n@@ -347,32 +347,32 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n \n fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut Vec<(Name, Span)>) {\n     match ty.node {\n-        TySlice(ref sty) => check_ty(cx, sty, bindings),\n-        TyArray(ref fty, ref anon_const) => {\n+        TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n+        TyKind::Array(ref fty, ref anon_const) => {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings);\n         },\n-        TyPtr(MutTy { ty: ref mty, .. }) | TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n-        TyTup(ref tup) => for t in tup {\n+        TyKind::Ptr(MutTy { ty: ref mty, .. }) | TyKind::Rptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n+        TyKind::Tup(ref tup) => for t in tup {\n             check_ty(cx, t, bindings)\n         },\n-        TyTypeof(ref anon_const) => check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings),\n+        TyKind::Typeof(ref anon_const) => check_expr(cx, &cx.tcx.hir.body(anon_const.body).value, bindings),\n         _ => (),\n     }\n }\n \n fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBox(ref inner) | ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n-        ExprBlock(ref block, _) => {\n+        ExprKind::Box(ref inner) | ExprKind::AddrOf(_, ref inner) => is_self_shadow(name, inner),\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty()\n                 && block\n                     .expr\n                     .as_ref()\n                     .map_or(false, |e| is_self_shadow(name, e))\n         },\n-        ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n-        ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n+        ExprKind::Unary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n+        ExprKind::Path(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }"}, {"sha": "40f5c66ce1582b69bcb9887ae400bd5e371090bb", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -82,12 +82,12 @@ impl LintPass for StringAdd {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if !is_allowed(cx, STRING_ADD_ASSIGN, e.id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n-                        if let ExprAssign(ref target, _) = p.node {\n+                        if let ExprKind::Assign(ref target, _) = p.node {\n                             // avoid duplicate matches\n                             if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n                     \"you added something to a string. Consider using `String::push_str()` instead\",\n                 );\n             }\n-        } else if let ExprAssign(ref target, ref src) = e.node {\n+        } else if let ExprKind::Assign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(\n                     cx,\n@@ -122,8 +122,8 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprBlock(ref block, _) => {\n+        ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n+        ExprKind::Block(ref block, _) => {\n             block.stmts.is_empty()\n                 && block\n                     .expr\n@@ -148,9 +148,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use syntax::ast::LitKind;\n         use crate::utils::{in_macro, snippet};\n \n-        if let ExprMethodCall(ref path, _, ref args) = e.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = e.node {\n             if path.ident.name == \"as_bytes\" {\n-                if let ExprLit(ref lit) = args[0].node {\n+                if let ExprKind::Lit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {\n                             span_lint_and_sugg("}, {"sha": "10db53cc782de7744fdd0910477db9897816a084", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -59,10 +59,15 @@ impl LintPass for SuspiciousImpl {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        use rustc::hir::BinOp_::*;\n-        if let hir::ExprBinary(binop, _, _) = expr.node {\n+        if let hir::ExprKind::Binary(binop, _, _) = expr.node {\n             match binop.node {\n-                BiEq | BiLt | BiLe | BiNe | BiGe | BiGt => return,\n+                | hir::BinOpKind::Eq\n+                | hir::BinOpKind::Lt\n+                | hir::BinOpKind::Le\n+                | hir::BinOpKind::Ne\n+                | hir::BinOpKind::Ge\n+                | hir::BinOpKind::Gt\n+                => return,\n                 _ => {},\n             }\n             // Check if the binary expression is part of another bi/unary expression\n@@ -71,9 +76,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             while parent_expr != ast::CRATE_NODE_ID {\n                 if let hir::map::Node::NodeExpr(e) = cx.tcx.hir.get(parent_expr) {\n                     match e.node {\n-                        hir::ExprBinary(..)\n-                        | hir::ExprUnary(hir::UnOp::UnNot, _)\n-                        | hir::ExprUnary(hir::UnOp::UnNeg, _) => return,\n+                        hir::ExprKind::Binary(..)\n+                        | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n+                        | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => return,\n                         _ => {},\n                     }\n                 }\n@@ -94,7 +99,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                 expr,\n                 binop.node,\n                 &[\"Add\", \"Sub\", \"Mul\", \"Div\"],\n-                &[BiAdd, BiSub, BiMul, BiDiv],\n+                &[\n+                    hir::BinOpKind::Add,\n+                    hir::BinOpKind::Sub,\n+                    hir::BinOpKind::Mul,\n+                    hir::BinOpKind::Div,\n+                ],\n             ) {\n                 span_lint(\n                     cx,\n@@ -124,7 +134,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                     \"ShrAssign\",\n                 ],\n                 &[\n-                    BiAdd, BiSub, BiMul, BiDiv, BiBitAnd, BiBitOr, BiBitXor, BiRem, BiShl, BiShr\n+                    hir::BinOpKind::Add,\n+                    hir::BinOpKind::Sub,\n+                    hir::BinOpKind::Mul,\n+                    hir::BinOpKind::Div,\n+                    hir::BinOpKind::BitAnd,\n+                    hir::BinOpKind::BitOr,\n+                    hir::BinOpKind::BitXor,\n+                    hir::BinOpKind::Rem,\n+                    hir::BinOpKind::Shl,\n+                    hir::BinOpKind::Shr,\n                 ],\n             ) {\n                 span_lint(\n@@ -144,9 +163,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n fn check_binop<'a>(\n     cx: &LateContext,\n     expr: &hir::Expr,\n-    binop: hir::BinOp_,\n+    binop: hir::BinOpKind,\n     traits: &[&'a str],\n-    expected_ops: &[hir::BinOp_],\n+    expected_ops: &[hir::BinOpKind],\n ) -> Option<&'a str> {\n     let mut trait_ids = vec![];\n     let [krate, module] = crate::utils::paths::OPS_MODULE;\n@@ -167,7 +186,7 @@ fn check_binop<'a>(\n     if_chain! {\n         if parent_impl != ast::CRATE_NODE_ID;\n         if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n-        if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n+        if let hir::ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n         if binop != expected_ops[idx];\n         then{\n@@ -185,9 +204,9 @@ struct BinaryExprVisitor {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for BinaryExprVisitor {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBinary(..)\n-            | hir::ExprUnary(hir::UnOp::UnNot, _)\n-            | hir::ExprUnary(hir::UnOp::UnNeg, _) => {\n+            hir::ExprKind::Binary(..)\n+            | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n+            | hir::ExprKind::Unary(hir::UnOp::UnNeg, _) => {\n                 self.in_binary_expr = true\n             },\n             _ => {},"}, {"sha": "dfcc9c39348f2b490908899c5c633f2452a96278", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -61,19 +61,19 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n-            if let StmtDecl(ref tmp, _) = w[0].node;\n-            if let DeclLocal(ref tmp) = tmp.node;\n+            if let StmtKind::Decl(ref tmp, _) = w[0].node;\n+            if let DeclKind::Local(ref tmp) = tmp.node;\n             if let Some(ref tmp_init) = tmp.init;\n             if let PatKind::Binding(_, _, ident, None) = tmp.pat.node;\n \n             // foo() = bar();\n-            if let StmtSemi(ref first, _) = w[1].node;\n-            if let ExprAssign(ref lhs1, ref rhs1) = first.node;\n+            if let StmtKind::Semi(ref first, _) = w[1].node;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = first.node;\n \n             // bar() = t;\n-            if let StmtSemi(ref second, _) = w[2].node;\n-            if let ExprAssign(ref lhs2, ref rhs2) = second.node;\n-            if let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n+            if let StmtKind::Semi(ref second, _) = w[2].node;\n+            if let ExprKind::Assign(ref lhs2, ref rhs2) = second.node;\n+            if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n             if rhs2.segments.len() == 1;\n \n             if ident.as_str() == rhs2.segments[0].ident.as_str();\n@@ -85,8 +85,8 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                     lhs1: &'a Expr,\n                     lhs2: &'a Expr,\n                 ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n-                    if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n-                        if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n+                    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.node {\n+                        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.node {\n                             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n                                 let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n \n@@ -145,11 +145,11 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n-            if let StmtSemi(ref first, _) = w[0].node;\n-            if let StmtSemi(ref second, _) = w[1].node;\n+            if let StmtKind::Semi(ref first, _) = w[0].node;\n+            if let StmtKind::Semi(ref second, _) = w[1].node;\n             if !differing_macro_contexts(first.span, second.span);\n-            if let ExprAssign(ref lhs0, ref rhs0) = first.node;\n-            if let ExprAssign(ref lhs1, ref rhs1) = second.node;\n+            if let ExprKind::Assign(ref lhs0, ref rhs0) = first.node;\n+            if let ExprKind::Assign(ref lhs1, ref rhs1) = second.node;\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n             then {"}, {"sha": "008ab56bda8407906cc85253f418333e23a97892", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::hir::{Expr, ExprAssign, ExprField, ExprStruct, ExprTup};\n+use rustc::hir::{Expr, ExprKind};\n use crate::utils::is_adjusted;\n use crate::utils::span_lint;\n \n@@ -23,7 +23,7 @@ declare_clippy_lint! {\n \n fn is_temporary(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprStruct(..) | ExprTup(..) => true,\n+        ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         _ => false,\n     }\n }\n@@ -39,8 +39,8 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprAssign(ref target, _) = expr.node {\n-            if let ExprField(ref base, _) = target.node {\n+        if let ExprKind::Assign(ref target, _) = expr.node {\n+            if let ExprKind::Field(ref base, _) = target.node {\n                 if is_temporary(base) && !is_adjusted(cx, base) {\n                     span_lint(cx, TEMPORARY_ASSIGNMENT, expr.span, \"assignment to temporary\");\n                 }"}, {"sha": "9914ab0e8db3da61afb23721df82dbe3d6bc269e", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -215,8 +215,8 @@ impl LintPass for Transmute {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(ref qpath) = path_expr.node {\n+        if let ExprKind::Call(ref path_expr, ref args) = e.node {\n+            if let ExprKind::Path(ref qpath) = path_expr.node {\n                 if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n                     if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n@@ -461,7 +461,7 @@ fn get_type_snippet(cx: &LateContext, path: &QPath, to_ref_ty: Ty) -> String {\n             GenericArg::Type(ty) => Some(ty),\n             GenericArg::Lifetime(_) => None,\n         }).nth(1);\n-        if let TyRptr(_, ref to_ty) = to_ty.node;\n+        if let TyKind::Rptr(_, ref to_ty) = to_ty.node;\n         then {\n             return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n         }"}, {"sha": "18c85cd05ab4e86fc6a7159e501118196d4535e7", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -100,8 +100,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n \n         // Exclude non-inherent impls\n         if let Some(NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(node_id)) {\n-            if matches!(item.node, ItemImpl(_, _, _, _, Some(_), _, _) |\n-                ItemTrait(..))\n+            if matches!(item.node, ItemKind::Impl(_, _, _, _, Some(_), _, _) |\n+                ItemKind::Trait(..))\n             {\n                 return;\n             }\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n                 if size <= self.limit;\n-                if let Ty_::TyRptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n+                if let TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n                 then {\n                     let value_type = if is_self(arg) {\n                         \"self\".into()"}, {"sha": "ae4f579a6f22b76576a31b241b713003d0220180", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n     fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n         // skip trait implementations, see #605\n         if let Some(map::NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(id)) {\n-            if let ItemImpl(_, _, _, _, Some(..), _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n                 return;\n             }\n         }\n@@ -186,7 +186,7 @@ fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool\n             GenericArg::Type(ty) => Some(ty),\n             GenericArg::Lifetime(_) => None,\n         });\n-        if let TyPath(ref qpath) = ty.node;\n+        if let TyKind::Path(ref qpath) = ty.node;\n         if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(ty.id)));\n         if match_def_path(cx.tcx, did, path);\n         then {\n@@ -206,7 +206,7 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n         return;\n     }\n     match ast_ty.node {\n-        TyPath(ref qpath) if !is_local => {\n+        TyKind::Path(ref qpath) if !is_local => {\n             let hir_id = cx.tcx.hir.node_to_hir_id(ast_ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if let Some(def_id) = opt_def_id(def) {\n@@ -282,10 +282,10 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                 },\n             }\n         },\n-        TyRptr(ref lt, ref mut_ty) => check_ty_rptr(cx, ast_ty, is_local, lt, mut_ty),\n+        TyKind::Rptr(ref lt, ref mut_ty) => check_ty_rptr(cx, ast_ty, is_local, lt, mut_ty),\n         // recurse\n-        TySlice(ref ty) | TyArray(ref ty, _) | TyPtr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n-        TyTup(ref tys) => for ty in tys {\n+        TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n+        TyKind::Tup(ref tys) => for ty in tys {\n             check_ty(cx, ty, is_local);\n         },\n         _ => {},\n@@ -294,7 +294,7 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n \n fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n-        TyPath(ref qpath) => {\n+        TyKind::Path(ref qpath) => {\n             let hir_id = cx.tcx.hir.node_to_hir_id(mut_ty.ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n             if_chain! {\n@@ -343,7 +343,7 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n // Returns true if given type is `Any` trait.\n fn is_any_trait(t: &hir::Ty) -> bool {\n     if_chain! {\n-        if let TyTraitObject(ref traits, _) = t.node;\n+        if let TyKind::TraitObject(ref traits, _) = t.node;\n         if traits.len() >= 1;\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n@@ -377,7 +377,7 @@ declare_clippy_lint! {\n }\n \n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n-    if let DeclLocal(ref local) = decl.node {\n+    if let DeclKind::Local(ref local) = decl.node {\n         if is_unit(cx.tables.pat_ty(&local.pat)) {\n             if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n                 return;\n@@ -446,11 +446,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         if in_macro(expr.span) {\n             return;\n         }\n-        if let ExprBinary(ref cmp, ref left, _) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() && is_unit(cx.tables.expr_ty(left)) {\n                 let result = match op {\n-                    BiEq | BiLe | BiGe => \"true\",\n+                    BinOpKind::Eq | BinOpKind::Le | BinOpKind::Ge => \"true\",\n                     _ => \"false\",\n                 };\n                 span_lint(\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n             return;\n         }\n         match expr.node {\n-            ExprCall(_, ref args) | ExprMethodCall(_, _, ref args) => {\n+            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n                 for arg in args {\n                     if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n                         let map = &cx.tcx.hir;\n@@ -539,7 +539,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n \n fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n     use syntax_pos::hygiene::CompilerDesugaringKind;\n-    if let ExprCall(ref callee, _) = expr.node {\n+    if let ExprKind::Call(ref callee, _) = expr.node {\n         callee.span.is_compiler_desugaring(CompilerDesugaringKind::QuestionMark)\n     } else {\n         false\n@@ -555,7 +555,7 @@ fn is_unit(ty: Ty) -> bool {\n \n fn is_unit_literal(expr: &Expr) -> bool {\n     match expr.node {\n-        ExprTup(ref slice) if slice.is_empty() => true,\n+        ExprKind::Tup(ref slice) if slice.is_empty() => true,\n         _ => false,\n     }\n }\n@@ -812,7 +812,7 @@ fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_t\n }\n \n fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n-    if let ExprBinary(_, _, _) = op.node {\n+    if let ExprKind::Binary(_, _, _) = op.node {\n         if snip.starts_with('(') && snip.ends_with(')') {\n             return true;\n         }\n@@ -951,9 +951,9 @@ impl LintPass for CastPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprCast(ref ex, _) = expr.node {\n+        if let ExprKind::Cast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tables.expr_ty(ex), cx.tables.expr_ty(expr));\n-            if let ExprLit(ref lit) = ex.node {\n+            if let ExprKind::Lit(ref lit) = ex.node {\n                 use syntax::ast::{LitIntType, LitKind};\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::FloatUnsuffixed(_) => {},\n@@ -1141,7 +1141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         match item.node {\n-            ItemStatic(ref ty, _, _) | ItemConst(ref ty, _) => self.check_type(cx, ty),\n+            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_type(cx, ty),\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n@@ -1214,15 +1214,15 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n-            TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n+            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n \n             // the \"normal\" components of a type: named types, arrays/tuples\n-            TyPath(..) | TySlice(..) | TyTup(..) | TyArray(..) => (10 * self.nest, 1),\n+            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n \n             // function types bring a lot of overhead\n-            TyBareFn(..) => (50 * self.nest, 1),\n+            TyKind::BareFn(..) => (50 * self.nest, 1),\n \n-            TyTraitObject(ref param_bounds, _) => {\n+            TyKind::TraitObject(ref param_bounds, _) => {\n                 let has_lifetime_parameters = param_bounds\n                     .iter()\n                     .any(|bound| bound.bound_generic_params.iter().any(|gen| match gen.kind {\n@@ -1289,8 +1289,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use syntax::ast::{LitKind, UintTy};\n \n-        if let ExprCast(ref e, _) = expr.node {\n-            if let ExprLit(ref l) = e.node {\n+        if let ExprKind::Cast(ref e, _) = expr.node {\n+            if let ExprKind::Lit(ref l) = e.node {\n                 if let LitKind::Char(_) = l.node {\n                     if ty::TyUint(UintTy::U8) == cx.tables.expr_ty(expr).sty && !in_macro(expr.span) {\n                         let msg = \"casting character literal to u8. `char`s \\\n@@ -1362,7 +1362,7 @@ fn is_cast_between_fixed_and_target<'a, 'tcx>(\n     expr: &'tcx Expr\n ) -> bool {\n \n-    if let ExprCast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let precast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n \n@@ -1374,7 +1374,7 @@ fn is_cast_between_fixed_and_target<'a, 'tcx>(\n \n fn detect_absurd_comparison<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    op: BinOp_,\n+    op: BinOpKind,\n     lhs: &'tcx Expr,\n     rhs: &'tcx Expr,\n ) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n@@ -1453,7 +1453,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n         use crate::types::ExtremeType::*;\n         use crate::types::AbsurdComparisonResult::*;\n \n-        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n             if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n                 if !in_macro(expr.span) {\n                     let msg = \"this comparison involving the minimum or maximum element for this \\\n@@ -1564,7 +1564,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n-    if let ExprCast(ref cast_exp, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.node {\n         let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n         // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n@@ -1627,7 +1627,7 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n }\n \n fn err_upcast_comparison(cx: &LateContext, span: Span, expr: &Expr, always: bool) {\n-    if let ExprCast(ref cast_val, _) = expr.node {\n+    if let ExprKind::Cast(ref cast_val, _) = expr.node {\n         span_lint(\n             cx,\n             INVALID_UPCAST_COMPARISONS,\n@@ -1693,7 +1693,7 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.node {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n                 val\n@@ -1797,7 +1797,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n         }\n \n         match item.node {\n-            ItemImpl(_, _, _, ref generics, _, ref ty, ref items) => {\n+            ItemKind::Impl(_, _, _, ref generics, _, ref ty, ref items) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n                 vis.visit_ty(ty);\n \n@@ -1829,7 +1829,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n                     );\n                 }\n             },\n-            ItemFn(ref decl, .., ref generics, body_id) => {\n+            ItemKind::Fn(ref decl, .., ref generics, body_id) => {\n                 let body = cx.tcx.hir.body(body_id);\n \n                 for ty in &decl.inputs {\n@@ -1878,7 +1878,7 @@ enum ImplicitHasherType<'tcx> {\n impl<'tcx> ImplicitHasherType<'tcx> {\n     /// Checks that `ty` is a target type without a BuildHasher.\n     fn new<'a>(cx: &LateContext<'a, 'tcx>, hir_ty: &hir::Ty) -> Option<Self> {\n-        if let TyPath(QPath::Resolved(None, ref path)) = hir_ty.node {\n+        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.node {\n             let params: Vec<_> = path.segments.last().as_ref()?.args.as_ref()?\n                 .args.iter().filter_map(|arg| match arg {\n                     GenericArg::Type(ty) => Some(ty),\n@@ -1984,9 +1984,9 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n \n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         if_chain! {\n-            if let ExprCall(ref fun, ref args) = e.node;\n-            if let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n-            if let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node;\n+            if let ExprKind::Call(ref fun, ref args) = e.node;\n+            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n+            if let TyKind::Path(QPath::Resolved(None, ref ty_path)) = ty.node;\n             then {\n                 if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n                     return;"}, {"sha": "ddd9db9eda3a0e1412e6d2468a82e7ba53d27d9b", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -71,7 +71,7 @@ impl LintPass for Unicode {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unicode {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprLit(ref lit) = expr.node {\n+        if let ExprKind::Lit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span, expr.id)\n             }"}, {"sha": "649a1033371068fee178864f2e47561f2e8047fe", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -40,14 +40,14 @@ impl LintPass for UnusedIoAmount {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n-            hir::StmtSemi(ref expr, _) | hir::StmtExpr(ref expr, _) => &**expr,\n+            hir::StmtKind::Semi(ref expr, _) | hir::StmtKind::Expr(ref expr, _) => &**expr,\n             _ => return,\n         };\n \n         match expr.node {\n-            hir::ExprMatch(ref res, _, _) if is_try(expr).is_some() => {\n-                if let hir::ExprCall(ref func, ref args) = res.node {\n-                    if let hir::ExprPath(ref path) = func.node {\n+            hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n+                if let hir::ExprKind::Call(ref func, ref args) = res.node {\n+                    if let hir::ExprKind::Path(ref path) = func.node {\n                         if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n@@ -57,7 +57,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprMethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n+            hir::ExprKind::MethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_method_call(cx, &args[0], expr);\n                 },\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n }\n \n fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n-    if let hir::ExprMethodCall(ref path, _, _) = call.node {\n+    if let hir::ExprKind::MethodCall(ref path, _, _) = call.node {\n         let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n             span_lint("}, {"sha": "0ae956b9443e8dc543d4c807375c355d0086a7d5", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -69,10 +69,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n-            hir::ExprBreak(destination, _) | hir::ExprContinue(destination) => if let Some(label) = destination.label {\n+            hir::ExprKind::Break(destination, _) | hir::ExprKind::Continue(destination) => if let Some(label) = destination.label {\n                 self.labels.remove(&label.ident.as_str());\n             },\n-            hir::ExprLoop(_, Some(label), _) | hir::ExprWhile(_, _, Some(label)) => {\n+            hir::ExprKind::Loop(_, Some(label), _) | hir::ExprKind::While(_, _, Some(label)) => {\n                 self.labels.insert(label.ident.as_str(), expr.span);\n             },\n             _ => (),"}, {"sha": "fcc3c2f68c1ce86fde16dfe161c510a5b5f63b60", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -78,21 +78,21 @@ fn collect_unwrap_info<'a, 'tcx: 'a>(\n     expr: &'tcx Expr,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n-    if let Expr_::ExprBinary(op, left, right) = &expr.node {\n+    if let ExprKind::Binary(op, left, right) = &expr.node {\n         match (invert, op.node) {\n-            (false, BinOp_::BiAnd) | (false, BinOp_::BiBitAnd) | (true, BinOp_::BiOr) | (true, BinOp_::BiBitOr) => {\n+            (false, BinOpKind::And) | (false, BinOpKind::BitAnd) | (true, BinOpKind::Or) | (true, BinOpKind::BitOr) => {\n                 let mut unwrap_info = collect_unwrap_info(cx, left, invert);\n                 unwrap_info.append(&mut collect_unwrap_info(cx, right, invert));\n                 return unwrap_info;\n             },\n             _ => (),\n         }\n-    } else if let Expr_::ExprUnary(UnNot, expr) = &expr.node {\n+    } else if let ExprKind::Unary(UnNot, expr) = &expr.node {\n         return collect_unwrap_info(cx, expr, !invert);\n     } else {\n         if_chain! {\n-            if let Expr_::ExprMethodCall(method_name, _, args) = &expr.node;\n-            if let Expr_::ExprPath(QPath::Resolved(None, path)) = &args[0].node;\n+            if let ExprKind::MethodCall(method_name, _, args) = &expr.node;\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].node;\n             let ty = cx.tables.expr_ty(&args[0]);\n             if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n             let name = method_name.ident.as_str();\n@@ -131,7 +131,7 @@ impl<'a, 'tcx: 'a> UnwrappableVariablesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let Expr_::ExprIf(cond, then, els) = &expr.node {\n+        if let ExprKind::If(cond, then, els) = &expr.node {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);\n             if let Some(els) = els {\n@@ -140,8 +140,8 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let Expr_::ExprMethodCall(ref method_name, _, ref args) = expr.node;\n-                if let Expr_::ExprPath(QPath::Resolved(None, ref path)) = args[0].node;\n+                if let ExprKind::MethodCall(ref method_name, _, ref args) = expr.node;\n+                if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].node;\n                 if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.ident.as_str());\n                 let call_to_unwrap = method_name.ident.name == \"unwrap\";\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "82dc0fd2b8ad0d4ab1bdcf41046a3a3327f3b867", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -65,7 +65,7 @@ struct TraitImplTyVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> Visitor<'tcx> for TraitImplTyVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx Ty) {\n         let trait_ty = self.type_walker.next();\n-        if let TyPath(QPath::Resolved(_, path)) = &t.node {\n+        if let TyKind::Path(QPath::Resolved(_, path)) = &t.node {\n             let impl_is_self_ty = if let def::Def::SelfTy(..) = path.def {\n                 true\n             } else {\n@@ -137,8 +137,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n             return;\n         }\n         if_chain! {\n-            if let ItemImpl(.., item_type, refs) = &item.node;\n-            if let Ty_::TyPath(QPath::Resolved(_, ref item_path)) = item_type.node;\n+            if let ItemKind::Impl(.., ref item_type, ref refs) = item.node;\n+            if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.node;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = if let Some(ref params) = *parameters {"}, {"sha": "9a848c8a805d2303591f7b06d6ba800d16ac3778", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -5,7 +5,7 @@\n \n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::{Expr, Expr_, QPath, Ty_, Pat, PatKind, BindingAnnotation, StmtSemi, StmtExpr, StmtDecl, Decl_, Stmt};\n+use rustc::hir::{Expr, ExprKind, QPath, TyKind, Pat, PatKind, BindingAnnotation, StmtKind, DeclKind, Stmt};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use syntax::ast::{Attribute, LitKind, DUMMY_NODE_ID};\n use std::collections::HashMap;\n@@ -32,10 +32,10 @@ use crate::utils::get_attr;\n /// ```rust\n /// // ./tests/ui/new_lint.stdout\n /// if_chain!{\n-///     if let Expr_::ExprIf(ref cond, ref then, None) = item.node,\n-///     if let Expr_::ExprBinary(BinOp::Eq, ref left, ref right) = cond.node,\n-///     if let Expr_::ExprPath(ref path) = left.node,\n-///     if let Expr_::ExprLit(ref lit) = right.node,\n+///     if let ExprKind::If(ref cond, ref then, None) = item.node,\n+///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.node,\n+///     if let ExprKind::Path(ref path) = left.node,\n+///     if let ExprKind::Lit(ref lit) = right.node,\n ///     if let LitKind::Int(42, _) = lit.node,\n ///     then {\n ///         // report your lint here\n@@ -192,16 +192,16 @@ struct PrintVisitor {\n \n impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n-        print!(\"    if let Expr_::Expr\");\n+        print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.node\", self.current);\n         match expr.node {\n-            Expr_::ExprBox(ref inner) => {\n+            ExprKind::Box(ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprArray(ref elements) => {\n+            ExprKind::Array(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Array(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -210,7 +210,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            Expr_::ExprCall(ref func, ref args) => {\n+            ExprKind::Call(ref func, ref args) => {\n                 let func_pat = self.next(\"func\");\n                 let args_pat = self.next(\"args\");\n                 println!(\"Call(ref {}, ref {}) = {};\", func_pat, args_pat, current);\n@@ -222,11 +222,11 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(arg);\n                 }\n             },\n-            Expr_::ExprMethodCall(ref _method_name, ref _generics, ref _args) => {\n+            ExprKind::MethodCall(ref _method_name, ref _generics, ref _args) => {\n                 println!(\"MethodCall(ref method_name, ref generics, ref args) = {};\", current);\n-                println!(\"    // unimplemented: `ExprMethodCall` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n             },\n-            Expr_::ExprTup(ref elements) => {\n+            ExprKind::Tup(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Tup(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -235,24 +235,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            Expr_::ExprBinary(ref op, ref left, ref right) => {\n+            ExprKind::Binary(ref op, ref left, ref right) => {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n                 println!(\"Binary(ref {}, ref {}, ref {}) = {};\", op_pat, left_pat, right_pat, current);\n-                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n+                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = left_pat;\n                 self.visit_expr(left);\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n-            Expr_::ExprUnary(ref op, ref inner) => {\n+            ExprKind::Unary(ref op, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprLit(ref lit) => {\n+            ExprKind::Lit(ref lit) => {\n                 let lit_pat = self.next(\"lit\");\n                 println!(\"Lit(ref {}) = {};\", lit_pat, current);\n                 match lit.node {\n@@ -277,27 +277,27 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     },\n                 }\n             },\n-            Expr_::ExprCast(ref expr, ref ty) => {\n+            ExprKind::Cast(ref expr, ref ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 let cast_ty = self.next(\"cast_ty\");\n                 let qp_label = self.next(\"qp\");\n \n                 println!(\"Cast(ref {}, ref {}) = {};\", cast_pat, cast_ty, current);\n-                if let Ty_::TyPath(ref qp) = ty.node {\n-                    println!(\"    if let Ty_::TyPath(ref {}) = {}.node;\", qp_label, cast_ty);\n+                if let TyKind::Path(ref qp) = ty.node {\n+                    println!(\"    if let TyKind::Path(ref {}) = {}.node;\", qp_label, cast_ty);\n                     self.current = qp_label;\n                     self.print_qpath(qp);\n                 }\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            Expr_::ExprType(ref expr, ref _ty) => {\n+            ExprKind::Type(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            Expr_::ExprIf(ref cond, ref then, ref opt_else) => {\n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n                 let cond_pat = self.next(\"cond\");\n                 let then_pat = self.next(\"then\");\n                 if let Some(ref else_) = *opt_else {\n@@ -313,7 +313,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = then_pat;\n                 self.visit_expr(then);\n             },\n-            Expr_::ExprWhile(ref cond, ref body, _) => {\n+            ExprKind::While(ref cond, ref body, _) => {\n                 let cond_pat = self.next(\"cond\");\n                 let body_pat = self.next(\"body\");\n                 let label_pat = self.next(\"label\");\n@@ -323,15 +323,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            Expr_::ExprLoop(ref body, _, desugaring) => {\n+            ExprKind::Loop(ref body, _, desugaring) => {\n                 let body_pat = self.next(\"body\");\n                 let des = loop_desugaring_name(desugaring);\n                 let label_pat = self.next(\"label\");\n                 println!(\"Loop(ref {}, ref {}, {}) = {};\", body_pat, label_pat, des, current);\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            Expr_::ExprMatch(ref expr, ref arms, desugaring) => {\n+            ExprKind::Match(ref expr, ref arms, desugaring) => {\n                 let des = desugaring_name(desugaring);\n                 let expr_pat = self.next(\"expr\");\n                 let arms_pat = self.next(\"arms\");\n@@ -355,23 +355,23 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     }\n                 }\n             },\n-            Expr_::ExprClosure(ref _capture_clause, ref _func, _, _, _) => {\n+            ExprKind::Closure(ref _capture_clause, ref _func, _, _, _) => {\n                 println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n-                println!(\"    // unimplemented: `ExprClosure` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::Closure` is not further destructured at the moment\");\n             },\n-            Expr_::ExprYield(ref sub) => {\n+            ExprKind::Yield(ref sub) => {\n                 let sub_pat = self.next(\"sub\");\n                 println!(\"Yield(ref sub) = {};\", current);\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n-            Expr_::ExprBlock(ref block, _) => {\n+            ExprKind::Block(ref block, _) => {\n                 let block_pat = self.next(\"block\");\n                 println!(\"Block(ref {}) = {};\", block_pat, current);\n                 self.current = block_pat;\n                 self.visit_block(block);\n             },\n-            Expr_::ExprAssign(ref target, ref value) => {\n+            ExprKind::Assign(ref target, ref value) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n                 println!(\"Assign(ref {}, ref {}) = {};\", target_pat, value_pat, current);\n@@ -380,26 +380,26 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            Expr_::ExprAssignOp(ref op, ref target, ref value) => {\n+            ExprKind::AssignOp(ref op, ref target, ref value) => {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n                 println!(\"AssignOp(ref {}, ref {}, ref {}) = {};\", op_pat, target_pat, value_pat, current);\n-                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n+                println!(\"    if BinOpKind::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = target_pat;\n                 self.visit_expr(target);\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            Expr_::ExprField(ref object, ref field_ident) => {\n+            ExprKind::Field(ref object, ref field_ident) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n                 println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n-            Expr_::ExprIndex(ref object, ref index) => {\n+            ExprKind::Index(ref object, ref index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n                 println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n@@ -408,19 +408,19 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = index_pat;\n                 self.visit_expr(index);\n             },\n-            Expr_::ExprPath(ref path) => {\n+            ExprKind::Path(ref path) => {\n                 let path_pat = self.next(\"path\");\n                 println!(\"Path(ref {}) = {};\", path_pat, current);\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n-            Expr_::ExprAddrOf(mutability, ref inner) => {\n+            ExprKind::AddrOf(mutability, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"AddrOf({:?}, ref {}) = {};\", mutability, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            Expr_::ExprBreak(ref _destination, ref opt_value) => {\n+            ExprKind::Break(ref _destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n                 if let Some(ref value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n@@ -432,24 +432,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 }\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprContinue(ref _destination) => {\n+            ExprKind::Continue(ref _destination) => {\n                 let destination_pat = self.next(\"destination\");\n                 println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing\n             },\n-            Expr_::ExprRet(ref opt_value) => if let Some(ref value) = *opt_value {\n+            ExprKind::Ret(ref opt_value) => if let Some(ref value) = *opt_value {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             } else {\n                 println!(\"Ret(None) = {};\", current);\n             },\n-            Expr_::ExprInlineAsm(_, ref _input, ref _output) => {\n+            ExprKind::InlineAsm(_, ref _input, ref _output) => {\n                 println!(\"InlineAsm(_, ref input, ref output) = {};\", current);\n-                println!(\"    // unimplemented: `ExprInlineAsm` is not further destructured at the moment\");\n+                println!(\"    // unimplemented: `ExprKind::InlineAsm` is not further destructured at the moment\");\n             },\n-            Expr_::ExprStruct(ref path, ref fields, ref opt_base) => {\n+            ExprKind::Struct(ref path, ref fields, ref opt_base) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n                 if let Some(ref base) = *opt_base {\n@@ -472,7 +472,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"    // unimplemented: field checks\");\n             },\n             // FIXME: compute length (needs type info)\n-            Expr_::ExprRepeat(ref value, _) => {\n+            ExprKind::Repeat(ref value, _) => {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n                 println!(\"// unimplemented: repeat count check\");\n@@ -588,20 +588,20 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n \n     fn visit_stmt(&mut self, s: &Stmt) {\n-        print!(\"    if let Stmt_::\");\n+        print!(\"    if let StmtKind::\");\n         let current = format!(\"{}.node\", self.current);\n         match s.node {\n             // Could be an item or a local (let) binding:\n-            StmtDecl(ref decl, _) => {\n+            StmtKind::Decl(ref decl, _) => {\n                 let decl_pat = self.next(\"decl\");\n-                println!(\"StmtDecl(ref {}, _) = {}\", decl_pat, current);\n-                print!(\"    if let Decl_::\");\n+                println!(\"Decl(ref {}, _) = {}\", decl_pat, current);\n+                print!(\"    if let DeclKind::\");\n                 let current = format!(\"{}.node\", decl_pat);\n                 match decl.node {\n                     // A local (let) binding:\n-                    Decl_::DeclLocal(ref local) => {\n+                    DeclKind::Local(ref local) => {\n                         let local_pat = self.next(\"local\");\n-                        println!(\"DeclLocal(ref {}) = {};\", local_pat, current);\n+                        println!(\"Local(ref {}) = {};\", local_pat, current);\n                         if let Some(ref init) = local.init {\n                             let init_pat = self.next(\"init\");\n                             println!(\"    if let Some(ref {}) = {}.init\", init_pat, local_pat);\n@@ -612,24 +612,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                         self.visit_pat(&local.pat);\n                     },\n                     // An item binding:\n-                    Decl_::DeclItem(_) => {\n-                        println!(\"DeclItem(item_id) = {};\", current);\n+                    DeclKind::Item(_) => {\n+                        println!(\"Item(item_id) = {};\", current);\n                     },\n                 }\n             }\n \n             // Expr without trailing semi-colon (must have unit type):\n-            StmtExpr(ref e, _) => {\n+            StmtKind::Expr(ref e, _) => {\n                 let e_pat = self.next(\"e\");\n-                println!(\"StmtExpr(ref {}, _) = {}\", e_pat, current);\n+                println!(\"Expr(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },\n \n             // Expr with trailing semi-colon (may have any type):\n-            StmtSemi(ref e, _) => {\n+            StmtKind::Semi(ref e, _) => {\n                 let e_pat = self.next(\"e\");\n-                println!(\"StmtSemi(ref {}, _) = {}\", e_pat, current);\n+                println!(\"Semi(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },\n@@ -674,7 +674,7 @@ fn print_path(path: &QPath, first: &mut bool) {\n             print!(\"{:?}\", segment.ident.as_str());\n         },\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n-            hir::Ty_::TyPath(ref inner_path) => {\n+            hir::TyKind::Path(ref inner_path) => {\n                 print_path(inner_path, first);\n                 if *first {\n                     *first = false;"}, {"sha": "35f41d400ad8417db4f416f14f3ed81d908c3de4", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -2,7 +2,7 @@\n \n #![deny(missing_docs_in_private_items)]\n \n-use rustc::hir::{BinOp_, Expr};\n+use rustc::hir::{BinOpKind, Expr};\n \n #[derive(PartialEq, Eq, Debug, Copy, Clone)]\n /// Represent a normalized comparison operator.\n@@ -19,14 +19,14 @@ pub enum Rel {\n \n /// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or\n /// `lhs != rhs`.\n-pub fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n+pub fn normalize_comparison<'a>(op: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n     match op {\n-        BinOp_::BiLt => Some((Rel::Lt, lhs, rhs)),\n-        BinOp_::BiLe => Some((Rel::Le, lhs, rhs)),\n-        BinOp_::BiGt => Some((Rel::Lt, rhs, lhs)),\n-        BinOp_::BiGe => Some((Rel::Le, rhs, lhs)),\n-        BinOp_::BiEq => Some((Rel::Eq, rhs, lhs)),\n-        BinOp_::BiNe => Some((Rel::Ne, rhs, lhs)),\n+        BinOpKind::Lt => Some((Rel::Lt, lhs, rhs)),\n+        BinOpKind::Le => Some((Rel::Le, lhs, rhs)),\n+        BinOpKind::Gt => Some((Rel::Lt, rhs, lhs)),\n+        BinOpKind::Ge => Some((Rel::Le, rhs, lhs)),\n+        BinOpKind::Eq => Some((Rel::Eq, rhs, lhs)),\n+        BinOpKind::Ne => Some((Rel::Ne, rhs, lhs)),\n         _ => None,\n     }\n }"}, {"sha": "3f0243a91c07a820495aa166e6aed96563473b69", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -9,26 +9,26 @@ use syntax::ast;\n use crate::utils::{is_expn_of, match_def_path, match_qpath, opt_def_id, paths, resolve_node};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n-pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n+pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n     match op {\n-        hir::BiEq => ast::BinOpKind::Eq,\n-        hir::BiGe => ast::BinOpKind::Ge,\n-        hir::BiGt => ast::BinOpKind::Gt,\n-        hir::BiLe => ast::BinOpKind::Le,\n-        hir::BiLt => ast::BinOpKind::Lt,\n-        hir::BiNe => ast::BinOpKind::Ne,\n-        hir::BiOr => ast::BinOpKind::Or,\n-        hir::BiAdd => ast::BinOpKind::Add,\n-        hir::BiAnd => ast::BinOpKind::And,\n-        hir::BiBitAnd => ast::BinOpKind::BitAnd,\n-        hir::BiBitOr => ast::BinOpKind::BitOr,\n-        hir::BiBitXor => ast::BinOpKind::BitXor,\n-        hir::BiDiv => ast::BinOpKind::Div,\n-        hir::BiMul => ast::BinOpKind::Mul,\n-        hir::BiRem => ast::BinOpKind::Rem,\n-        hir::BiShl => ast::BinOpKind::Shl,\n-        hir::BiShr => ast::BinOpKind::Shr,\n-        hir::BiSub => ast::BinOpKind::Sub,\n+        hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n+        hir::BinOpKind::Ge => ast::BinOpKind::Ge,\n+        hir::BinOpKind::Gt => ast::BinOpKind::Gt,\n+        hir::BinOpKind::Le => ast::BinOpKind::Le,\n+        hir::BinOpKind::Lt => ast::BinOpKind::Lt,\n+        hir::BinOpKind::Ne => ast::BinOpKind::Ne,\n+        hir::BinOpKind::Or => ast::BinOpKind::Or,\n+        hir::BinOpKind::Add => ast::BinOpKind::Add,\n+        hir::BinOpKind::And => ast::BinOpKind::And,\n+        hir::BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+        hir::BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+        hir::BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+        hir::BinOpKind::Div => ast::BinOpKind::Div,\n+        hir::BinOpKind::Mul => ast::BinOpKind::Mul,\n+        hir::BinOpKind::Rem => ast::BinOpKind::Rem,\n+        hir::BinOpKind::Shl => ast::BinOpKind::Shl,\n+        hir::BinOpKind::Shr => ast::BinOpKind::Shr,\n+        hir::BinOpKind::Sub => ast::BinOpKind::Sub,\n     }\n }\n \n@@ -87,7 +87,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n     match expr.node {\n-        hir::ExprPath(ref path) => {\n+        hir::ExprKind::Path(ref path) => {\n             if match_qpath(path, &paths::RANGE_FULL_STD) || match_qpath(path, &paths::RANGE_FULL) {\n                 Some(Range {\n                     start: None,\n@@ -98,7 +98,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n                 None\n             }\n         },\n-        hir::ExprCall(ref path, ref args) => if let hir::ExprPath(ref path) = path.node {\n+        hir::ExprKind::Call(ref path, ref args) => if let hir::ExprKind::Path(ref path) = path.node {\n             if match_qpath(path, &paths::RANGE_INCLUSIVE_STD_NEW) || match_qpath(path, &paths::RANGE_INCLUSIVE_NEW) {\n                 Some(Range {\n                     start: Some(&args[0]),\n@@ -111,7 +111,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n         } else {\n             None\n         },\n-        hir::ExprStruct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n+        hir::ExprKind::Struct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n             || match_qpath(path, &paths::RANGE_FROM)\n         {\n             Some(Range {\n@@ -154,9 +154,9 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     // }\n     // ```\n     if_chain! {\n-        if let hir::DeclLocal(ref loc) = decl.node;\n+        if let hir::DeclKind::Local(ref loc) = decl.node;\n         if let Some(ref expr) = loc.init;\n-        if let hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n         then {\n             return true;\n         }\n@@ -171,7 +171,7 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     // }\n     // ```\n     if_chain! {\n-        if let hir::DeclLocal(ref loc) = decl.node;\n+        if let hir::DeclKind::Local(ref loc) = decl.node;\n         if let hir::LocalSource::ForLoopDesugar = loc.source;\n         then {\n             return true;\n@@ -185,15 +185,15 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n     if_chain! {\n-        if let hir::ExprMatch(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n-        if let hir::ExprCall(_, ref iterargs) = iterexpr.node;\n+        if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.node;\n         if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprLoop(ref block, _, _) = arms[0].body.node;\n+        if let hir::ExprKind::Loop(ref block, _, _) = arms[0].body.node;\n         if block.expr.is_none();\n         if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtDecl(ref decl, _) = let_stmt.node;\n-        if let hir::DeclLocal(ref decl) = decl.node;\n-        if let hir::StmtExpr(ref expr, _) = body.node;\n+        if let hir::StmtKind::Decl(ref decl, _) = let_stmt.node;\n+        if let hir::DeclKind::Local(ref decl) = decl.node;\n+        if let hir::StmtKind::Expr(ref expr, _) = body.node;\n         then {\n             return Some((&*decl.pat, &iterargs[0], expr));\n         }\n@@ -213,8 +213,8 @@ pub enum VecArgs<'a> {\n /// from `vec!`.\n pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_chain! {\n-        if let hir::ExprCall(ref fun, ref args) = expr.node;\n-        if let hir::ExprPath(ref path) = fun.node;\n+        if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n+        if let hir::ExprKind::Path(ref path) = fun.node;\n         if is_expn_of(fun.span, \"vec\").is_some();\n         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, path, fun.hir_id));\n         then {\n@@ -225,8 +225,8 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n             else if match_def_path(cx.tcx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                 // `vec![a, b, c]` case\n                 if_chain! {\n-                    if let hir::ExprBox(ref boxed) = args[0].node;\n-                    if let hir::ExprArray(ref args) = boxed.node;\n+                    if let hir::ExprKind::Box(ref boxed) = args[0].node;\n+                    if let hir::ExprKind::Array(ref args) = boxed.node;\n                     then {\n                         return Some(VecArgs::Vec(&*args));\n                     }"}, {"sha": "2c5995f1327c2b28849119236aac8b0a466e9906", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 142, "deletions": 114, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -43,14 +43,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     /// Check whether two statements are the same.\n     pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n         match (&left.node, &right.node) {\n-            (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n-                if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n+            (&StmtKind::Decl(ref l, _), &StmtKind::Decl(ref r, _)) => {\n+                if let (&DeclKind::Local(ref l), &DeclKind::Local(ref r)) = (&l.node, &r.node) {\n                     both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                 } else {\n                     false\n                 }\n             },\n-            (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) | (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => {\n+            (&StmtKind::Expr(ref l, _), &StmtKind::Expr(ref r, _)) | (&StmtKind::Semi(ref l, _), &StmtKind::Semi(ref r, _)) => {\n                 self.eq_expr(l, r)\n             },\n             _ => false,\n@@ -75,69 +75,69 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n \n         match (&left.node, &right.node) {\n-            (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprContinue(li), &ExprContinue(ri)) => {\n+            (&ExprKind::AddrOf(l_mut, ref le), &ExprKind::AddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n+            (&ExprKind::Continue(li), &ExprKind::Continue(ri)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n-            (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n-            (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n+            (&ExprKind::Assign(ref ll, ref lr), &ExprKind::Assign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n+            (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n-            (&ExprBlock(ref l, _), &ExprBlock(ref r, _)) => self.eq_block(l, r),\n-            (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n+            (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n+            (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n                 l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     || swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                         l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     })\n             },\n-            (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n+            (&ExprKind::Break(li, ref le), &ExprKind::Break(ri, ref re)) => {\n                 both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n-            (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n+            (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n+            (&ExprKind::Call(ref l_fun, ref l_args), &ExprKind::Call(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) |\n-            (&ExprType(ref lx, ref lt), &ExprType(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n-            (&ExprField(ref l_f_exp, ref l_f_ident), &ExprField(ref r_f_exp, ref r_f_ident)) => {\n+            (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt)) |\n+            (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => self.eq_expr(lx, rx) && self.eq_ty(lt, rt),\n+            (&ExprKind::Field(ref l_f_exp, ref l_f_ident), &ExprKind::Field(ref r_f_exp, ref r_f_ident)) => {\n                 l_f_ident.name == r_f_ident.name && self.eq_expr(l_f_exp, r_f_exp)\n             },\n-            (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n-            (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n+            (&ExprKind::Index(ref la, ref li), &ExprKind::Index(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n+            (&ExprKind::If(ref lc, ref lt, ref le), &ExprKind::If(ref rc, ref rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-            (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n+            (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n+            (&ExprKind::Loop(ref lb, ref ll, ref lls), &ExprKind::Loop(ref rb, ref rl, ref rls)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n-            (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+            (&ExprKind::Match(ref le, ref la, ref ls), &ExprKind::Match(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) && over(la, ra, |l, r| {\n                     self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r))\n                         && over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             },\n-            (&ExprMethodCall(ref l_path, _, ref l_args), &ExprMethodCall(ref r_path, _, ref r_args)) => {\n-                !self.ignore_fn && l_path == r_path && self.eq_exprs(l_args, r_args)\n+            (&ExprKind::MethodCall(ref l_path, _, ref l_args), &ExprKind::MethodCall(ref r_path, _, ref r_args)) => {\n+                !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprRepeat(ref le, ref ll_id), &ExprRepeat(ref re, ref rl_id)) => {\n+            (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n                 let ll = celcx.expr(&self.cx.tcx.hir.body(ll_id.body).value);\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id.body));\n                 let rl = celcx.expr(&self.cx.tcx.hir.body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n             },\n-            (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n-            (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n+            (&ExprKind::Ret(ref l), &ExprKind::Ret(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n+            (&ExprKind::Path(ref l), &ExprKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (&ExprKind::Struct(ref l_path, ref lf, ref lo), &ExprKind::Struct(ref r_path, ref rf, ref ro)) => {\n                 self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r))\n                     && over(lf, rf, |l, r| self.eq_field(l, r))\n             },\n-            (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n-            (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n-            (&ExprArray(ref l), &ExprArray(ref r)) => self.eq_exprs(l, r),\n-            (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n+            (&ExprKind::Tup(ref l_tup), &ExprKind::Tup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n+            (&ExprKind::Unary(l_op, ref le), &ExprKind::Unary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n+            (&ExprKind::Array(ref l), &ExprKind::Array(ref r)) => self.eq_exprs(l, r),\n+            (&ExprKind::While(ref lc, ref lb, ref ll), &ExprKind::While(ref rc, ref rb, ref rl)) => {\n                 self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             _ => false,\n@@ -225,7 +225,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n+    pub fn eq_path_segments(&mut self, left: &[PathSegment], right: &[PathSegment]) -> bool {\n+        left.len() == right.len() && left.iter().zip(right).all(|(l, r)| self.eq_path_segment(l, r))\n+    }\n+\n+    pub fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n         if left.ident.as_str() != right.ident.as_str() {\n@@ -238,10 +242,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n-        match (&left.node, &right.node) {\n-            (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyArray(ref lt, ref ll_id), &TyArray(ref rt, ref rl_id)) => {\n+    pub fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n+        self.eq_ty_kind(&left.node, &right.node)\n+    }\n+\n+    pub fn eq_ty_kind(&mut self, left: &TyKind, right: &TyKind) -> bool {\n+        match (left, right) {\n+            (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n+            (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n                 let full_table = self.tables;\n \n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n@@ -256,13 +264,13 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 self.tables = full_table;\n                 eq_ty && ll == rl\n             },\n-            (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n-            (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n+            (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n+            (&TyKind::Rptr(_, ref l_rmut), &TyKind::Rptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             },\n-            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n-            (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n-            (&TyInfer, &TyInfer) => true,\n+            (&TyKind::Path(ref l), &TyKind::Path(ref r)) => self.eq_qpath(l, r),\n+            (&TyKind::Tup(ref l), &TyKind::Tup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n+            (&TyKind::Infer, &TyKind::Infer) => true,\n             _ => false,\n         }\n     }\n@@ -272,14 +280,26 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n }\n \n-fn swap_binop<'a>(binop: BinOp_, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOp_, &'a Expr, &'a Expr)> {\n+fn swap_binop<'a>(binop: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOpKind, &'a Expr, &'a Expr)> {\n     match binop {\n-        BiAdd | BiMul | BiBitXor | BiBitAnd | BiEq | BiNe | BiBitOr => Some((binop, rhs, lhs)),\n-        BiLt => Some((BiGt, rhs, lhs)),\n-        BiLe => Some((BiGe, rhs, lhs)),\n-        BiGe => Some((BiLe, rhs, lhs)),\n-        BiGt => Some((BiLt, rhs, lhs)),\n-        BiShl | BiShr | BiRem | BiSub | BiDiv | BiAnd | BiOr => None,\n+        BinOpKind::Add |\n+        BinOpKind::Mul |\n+        BinOpKind::Eq |\n+        BinOpKind::Ne |\n+        BinOpKind::BitAnd |\n+        BinOpKind::BitXor |\n+        BinOpKind::BitOr => Some((binop, rhs, lhs)),\n+        BinOpKind::Lt => Some((BinOpKind::Gt, rhs, lhs)),\n+        BinOpKind::Le => Some((BinOpKind::Ge, rhs, lhs)),\n+        BinOpKind::Ge => Some((BinOpKind::Le, rhs, lhs)),\n+        BinOpKind::Gt => Some((BinOpKind::Lt, rhs, lhs)),\n+        BinOpKind::Shl |\n+        BinOpKind::Shr |\n+        BinOpKind::Rem |\n+        BinOpKind::Sub |\n+        BinOpKind::Div |\n+        BinOpKind::And |\n+        BinOpKind::Or => None,\n     }\n }\n \n@@ -336,7 +356,12 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             self.hash_expr(e);\n         }\n \n-        b.rules.hash(&mut self.s);\n+        match b.rules {\n+            BlockCheckMode::DefaultBlock => 0,\n+            BlockCheckMode::UnsafeBlock(_) => 1,\n+            BlockCheckMode::PushUnsafeBlock(_) => 2,\n+            BlockCheckMode::PopUnsafeBlock(_) => 3,\n+        }.hash(&mut self.s);\n     }\n \n     #[allow(many_single_char_names)]\n@@ -346,51 +371,51 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         }\n \n         match e.node {\n-            ExprAddrOf(m, ref e) => {\n-                let c: fn(_, _) -> _ = ExprAddrOf;\n+            ExprKind::AddrOf(m, ref e) => {\n+                let c: fn(_, _) -> _ = ExprKind::AddrOf;\n                 c.hash(&mut self.s);\n                 m.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprContinue(i) => {\n-                let c: fn(_) -> _ = ExprContinue;\n+            ExprKind::Continue(i) => {\n+                let c: fn(_) -> _ = ExprKind::Continue;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprYield(ref e) => {\n-                let c: fn(_) -> _ = ExprYield;\n+            ExprKind::Yield(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Yield;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprAssign(ref l, ref r) => {\n-                let c: fn(_, _) -> _ = ExprAssign;\n+            ExprKind::Assign(ref l, ref r) => {\n+                let c: fn(_, _) -> _ = ExprKind::Assign;\n                 c.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprAssignOp(ref o, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprAssignOp;\n+            ExprKind::AssignOp(ref o, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::AssignOp;\n                 c.hash(&mut self.s);\n                 o.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprBlock(ref b, _) => {\n-                let c: fn(_, _) -> _ = ExprBlock;\n+            ExprKind::Block(ref b, _) => {\n+                let c: fn(_, _) -> _ = ExprKind::Block;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n             },\n-            ExprBinary(op, ref l, ref r) => {\n-                let c: fn(_, _, _) -> _ = ExprBinary;\n+            ExprKind::Binary(op, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Binary;\n                 c.hash(&mut self.s);\n                 op.node.hash(&mut self.s);\n                 self.hash_expr(l);\n                 self.hash_expr(r);\n             },\n-            ExprBreak(i, ref j) => {\n-                let c: fn(_, _) -> _ = ExprBreak;\n+            ExprKind::Break(i, ref j) => {\n+                let c: fn(_, _) -> _ = ExprKind::Break;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n                     self.hash_name(i.ident.name);\n@@ -399,69 +424,72 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(&*j);\n                 }\n             },\n-            ExprBox(ref e) => {\n-                let c: fn(_) -> _ = ExprBox;\n+            ExprKind::Box(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Box;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n             },\n-            ExprCall(ref fun, ref args) => {\n-                let c: fn(_, _) -> _ = ExprCall;\n+            ExprKind::Call(ref fun, ref args) => {\n+                let c: fn(_, _) -> _ = ExprKind::Call;\n                 c.hash(&mut self.s);\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n-            ExprCast(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprCast;\n+            ExprKind::Cast(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprKind::Cast;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n-            ExprClosure(cap, _, eid, _, _) => {\n-                let c: fn(_, _, _, _, _) -> _ = ExprClosure;\n+            ExprKind::Closure(cap, _, eid, _, _) => {\n+                let c: fn(_, _, _, _, _) -> _ = ExprKind::Closure;\n                 c.hash(&mut self.s);\n-                cap.hash(&mut self.s);\n+                match cap {\n+                    CaptureClause::CaptureByValue => 0,\n+                    CaptureClause::CaptureByRef => 1,\n+                }.hash(&mut self.s);\n                 self.hash_expr(&self.cx.tcx.hir.body(eid).value);\n             },\n-            ExprField(ref e, ref f) => {\n-                let c: fn(_, _) -> _ = ExprField;\n+            ExprKind::Field(ref e, ref f) => {\n+                let c: fn(_, _) -> _ = ExprKind::Field;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 self.hash_name(f.name);\n             },\n-            ExprIndex(ref a, ref i) => {\n-                let c: fn(_, _) -> _ = ExprIndex;\n+            ExprKind::Index(ref a, ref i) => {\n+                let c: fn(_, _) -> _ = ExprKind::Index;\n                 c.hash(&mut self.s);\n                 self.hash_expr(a);\n                 self.hash_expr(i);\n             },\n-            ExprInlineAsm(..) => {\n-                let c: fn(_, _, _) -> _ = ExprInlineAsm;\n+            ExprKind::InlineAsm(..) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::InlineAsm;\n                 c.hash(&mut self.s);\n             },\n-            ExprIf(ref cond, ref t, ref e) => {\n-                let c: fn(_, _, _) -> _ = ExprIf;\n+            ExprKind::If(ref cond, ref t, ref e) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::If;\n                 c.hash(&mut self.s);\n                 self.hash_expr(cond);\n                 self.hash_expr(&**t);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprLit(ref l) => {\n-                let c: fn(_) -> _ = ExprLit;\n+            ExprKind::Lit(ref l) => {\n+                let c: fn(_) -> _ = ExprKind::Lit;\n                 c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n             },\n-            ExprLoop(ref b, ref i, _) => {\n-                let c: fn(_, _, _) -> _ = ExprLoop;\n+            ExprKind::Loop(ref b, ref i, _) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Loop;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprMatch(ref e, ref arms, ref s) => {\n-                let c: fn(_, _, _) -> _ = ExprMatch;\n+            ExprKind::Match(ref e, ref arms, ref s) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Match;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n \n@@ -475,35 +503,35 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprMethodCall(ref path, ref _tys, ref args) => {\n-                let c: fn(_, _, _) -> _ = ExprMethodCall;\n+            ExprKind::MethodCall(ref path, ref _tys, ref args) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::MethodCall;\n                 c.hash(&mut self.s);\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n-            ExprRepeat(ref e, ref l_id) => {\n-                let c: fn(_, _) -> _ = ExprRepeat;\n+            ExprKind::Repeat(ref e, ref l_id) => {\n+                let c: fn(_, _) -> _ = ExprKind::Repeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 let full_table = self.tables;\n                 self.tables = self.cx.tcx.body_tables(l_id.body);\n                 self.hash_expr(&self.cx.tcx.hir.body(l_id.body).value);\n                 self.tables = full_table;\n             },\n-            ExprRet(ref e) => {\n-                let c: fn(_) -> _ = ExprRet;\n+            ExprKind::Ret(ref e) => {\n+                let c: fn(_) -> _ = ExprKind::Ret;\n                 c.hash(&mut self.s);\n                 if let Some(ref e) = *e {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprPath(ref qpath) => {\n-                let c: fn(_) -> _ = ExprPath;\n+            ExprKind::Path(ref qpath) => {\n+                let c: fn(_) -> _ = ExprKind::Path;\n                 c.hash(&mut self.s);\n                 self.hash_qpath(qpath);\n             },\n-            ExprStruct(ref path, ref fields, ref expr) => {\n-                let c: fn(_, _, _) -> _ = ExprStruct;\n+            ExprKind::Struct(ref path, ref fields, ref expr) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::Struct;\n                 c.hash(&mut self.s);\n \n                 self.hash_qpath(path);\n@@ -517,32 +545,32 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprTup(ref tup) => {\n-                let c: fn(_) -> _ = ExprTup;\n+            ExprKind::Tup(ref tup) => {\n+                let c: fn(_) -> _ = ExprKind::Tup;\n                 c.hash(&mut self.s);\n                 self.hash_exprs(tup);\n             },\n-            ExprType(ref e, ref _ty) => {\n-                let c: fn(_, _) -> _ = ExprType;\n+            ExprKind::Type(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprKind::Type;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n                 // TODO: _ty\n             },\n-            ExprUnary(lop, ref le) => {\n-                let c: fn(_, _) -> _ = ExprUnary;\n+            ExprKind::Unary(lop, ref le) => {\n+                let c: fn(_, _) -> _ = ExprKind::Unary;\n                 c.hash(&mut self.s);\n \n                 lop.hash(&mut self.s);\n                 self.hash_expr(le);\n             },\n-            ExprArray(ref v) => {\n-                let c: fn(_) -> _ = ExprArray;\n+            ExprKind::Array(ref v) => {\n+                let c: fn(_) -> _ = ExprKind::Array;\n                 c.hash(&mut self.s);\n \n                 self.hash_exprs(v);\n             },\n-            ExprWhile(ref cond, ref b, l) => {\n-                let c: fn(_, _, _) -> _ = ExprWhile;\n+            ExprKind::While(ref cond, ref b, l) => {\n+                let c: fn(_, _, _) -> _ = ExprKind::While;\n                 c.hash(&mut self.s);\n \n                 self.hash_expr(cond);\n@@ -585,23 +613,23 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_stmt(&mut self, b: &Stmt) {\n         match b.node {\n-            StmtDecl(ref decl, _) => {\n-                let c: fn(_, _) -> _ = StmtDecl;\n+            StmtKind::Decl(ref decl, _) => {\n+                let c: fn(_, _) -> _ = StmtKind::Decl;\n                 c.hash(&mut self.s);\n \n-                if let DeclLocal(ref local) = decl.node {\n+                if let DeclKind::Local(ref local) = decl.node {\n                     if let Some(ref init) = local.init {\n                         self.hash_expr(init);\n                     }\n                 }\n             },\n-            StmtExpr(ref expr, _) => {\n-                let c: fn(_, _) -> _ = StmtExpr;\n+            StmtKind::Expr(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtKind::Expr;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },\n-            StmtSemi(ref expr, _) => {\n-                let c: fn(_, _) -> _ = StmtSemi;\n+            StmtKind::Semi(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtKind::Semi;\n                 c.hash(&mut self.s);\n                 self.hash_expr(expr);\n             },"}, {"sha": "b2b99da3c59a27727dba48af6dcd3623f42009d2", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -122,8 +122,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => print_decl(cx, decl),\n-            hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n+            hir::StmtKind::Decl(ref decl, _) => print_decl(cx, decl),\n+            hir::StmtKind::Expr(ref e, _) | hir::StmtKind::Semi(ref e, _) => print_expr(cx, e, 0),\n         }\n     }\n     // fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n@@ -141,7 +141,7 @@ fn has_attr(attrs: &[Attribute]) -> bool {\n \n fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n     match decl.node {\n-        hir::DeclLocal(ref local) => {\n+        hir::DeclKind::Local(ref local) => {\n             println!(\"local variable of type {}\", cx.tables.node_id_to_type(local.hir_id));\n             println!(\"pattern:\");\n             print_pat(cx, &local.pat, 0);\n@@ -150,7 +150,7 @@ fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n                 print_expr(cx, e, 0);\n             }\n         },\n-        hir::DeclItem(_) => println!(\"item decl\"),\n+        hir::DeclKind::Item(_) => println!(\"item decl\"),\n     }\n }\n \n@@ -160,17 +160,17 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n     println!(\"{}adjustments: {:?}\", ind, cx.tables.adjustments().get(expr.hir_id));\n     match expr.node {\n-        hir::ExprBox(ref e) => {\n+        hir::ExprKind::Box(ref e) => {\n             println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprArray(ref v) => {\n+        hir::ExprKind::Array(ref v) => {\n             println!(\"{}Array\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprCall(ref func, ref args) => {\n+        hir::ExprKind::Call(ref func, ref args) => {\n             println!(\"{}Call\", ind);\n             println!(\"{}function:\", ind);\n             print_expr(cx, func, indent + 1);\n@@ -179,47 +179,47 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprMethodCall(ref path, _, ref args) => {\n+        hir::ExprKind::MethodCall(ref path, _, ref args) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprTup(ref v) => {\n+        hir::ExprKind::Tup(ref v) => {\n             println!(\"{}Tup\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             println!(\"{}Binary\", ind);\n             println!(\"{}op: {:?}\", ind, op.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprUnary(op, ref inner) => {\n+        hir::ExprKind::Unary(op, ref inner) => {\n             println!(\"{}Unary\", ind);\n             println!(\"{}op: {:?}\", ind, op);\n             print_expr(cx, inner, indent + 1);\n         },\n-        hir::ExprLit(ref lit) => {\n+        hir::ExprKind::Lit(ref lit) => {\n             println!(\"{}Lit\", ind);\n             println!(\"{}{:?}\", ind, lit);\n         },\n-        hir::ExprCast(ref e, ref target) => {\n+        hir::ExprKind::Cast(ref e, ref target) => {\n             println!(\"{}Cast\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprType(ref e, ref target) => {\n+        hir::ExprKind::Type(ref e, ref target) => {\n             println!(\"{}Type\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprIf(ref e, _, ref els) => {\n+        hir::ExprKind::If(ref e, _, ref els) => {\n             println!(\"{}If\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, e, indent + 1);\n@@ -228,86 +228,86 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, els, indent + 1);\n             }\n         },\n-        hir::ExprWhile(ref cond, _, _) => {\n+        hir::ExprKind::While(ref cond, _, _) => {\n             println!(\"{}While\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n         },\n-        hir::ExprLoop(..) => {\n+        hir::ExprKind::Loop(..) => {\n             println!(\"{}Loop\", ind);\n         },\n-        hir::ExprMatch(ref cond, _, ref source) => {\n+        hir::ExprKind::Match(ref cond, _, ref source) => {\n             println!(\"{}Match\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n             println!(\"{}source: {:?}\", ind, source);\n         },\n-        hir::ExprClosure(ref clause, _, _, _, _) => {\n+        hir::ExprKind::Closure(ref clause, _, _, _, _) => {\n             println!(\"{}Closure\", ind);\n             println!(\"{}clause: {:?}\", ind, clause);\n         },\n-        hir::ExprYield(ref sub) => {\n+        hir::ExprKind::Yield(ref sub) => {\n             println!(\"{}Yield\", ind);\n             print_expr(cx, sub, indent + 1);\n         },\n-        hir::ExprBlock(_, _) => {\n+        hir::ExprKind::Block(_, _) => {\n             println!(\"{}Block\", ind);\n         },\n-        hir::ExprAssign(ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(ref lhs, ref rhs) => {\n             println!(\"{}Assign\", ind);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprAssignOp(ref binop, ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(ref binop, ref lhs, ref rhs) => {\n             println!(\"{}AssignOp\", ind);\n             println!(\"{}op: {:?}\", ind, binop.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprField(ref e, ident) => {\n+        hir::ExprKind::Field(ref e, ident) => {\n             println!(\"{}Field\", ind);\n             println!(\"{}field name: {}\", ind, ident.name);\n             println!(\"{}struct expr:\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprIndex(ref arr, ref idx) => {\n+        hir::ExprKind::Index(ref arr, ref idx) => {\n             println!(\"{}Index\", ind);\n             println!(\"{}array expr:\", ind);\n             print_expr(cx, arr, indent + 1);\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprPath(hir::QPath::Resolved(ref ty, ref path)) => {\n+        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n             println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n-        hir::ExprPath(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+        hir::ExprKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n-        hir::ExprAddrOf(ref muta, ref e) => {\n+        hir::ExprKind::AddrOf(ref muta, ref e) => {\n             println!(\"{}AddrOf\", ind);\n             println!(\"mutability: {:?}\", muta);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprBreak(_, ref e) => {\n+        hir::ExprKind::Break(_, ref e) => {\n             println!(\"{}Break\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprContinue(_) => println!(\"{}Again\", ind),\n-        hir::ExprRet(ref e) => {\n+        hir::ExprKind::Continue(_) => println!(\"{}Again\", ind),\n+        hir::ExprKind::Ret(ref e) => {\n             println!(\"{}Ret\", ind);\n             if let Some(ref e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprInlineAsm(_, ref input, ref output) => {\n+        hir::ExprKind::InlineAsm(_, ref input, ref output) => {\n             println!(\"{}InlineAsm\", ind);\n             println!(\"{}inputs:\", ind);\n             for e in input {\n@@ -318,7 +318,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprStruct(ref path, ref fields, ref base) => {\n+        hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n             println!(\"{}Struct\", ind);\n             println!(\"{}path: {:?}\", ind, path);\n             for field in fields {\n@@ -330,7 +330,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, base, indent + 1);\n             }\n         },\n-        hir::ExprRepeat(ref val, ref anon_const) => {\n+        hir::ExprKind::Repeat(ref val, ref anon_const) => {\n             println!(\"{}Repeat\", ind);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n@@ -353,7 +353,7 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n         hir::VisibilityKind::Inherited => println!(\"visibility inherited from outer item\"),\n     }\n     match item.node {\n-        hir::ItemExternCrate(ref _renamed_from) => {\n+        hir::ItemKind::ExternCrate(ref _renamed_from) => {\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n@@ -367,46 +367,46 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n                 println!(\"weird extern crate without a crate id\");\n             }\n         },\n-        hir::ItemUse(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n-        hir::ItemStatic(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemConst(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemFn(..) => {\n+        hir::ItemKind::Use(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n+        hir::ItemKind::Static(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n+        hir::ItemKind::Const(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n+        hir::ItemKind::Fn(..) => {\n             let item_ty = cx.tcx.type_of(did);\n             println!(\"function of type {:#?}\", item_ty);\n         },\n-        hir::ItemMod(..) => println!(\"module\"),\n-        hir::ItemForeignMod(ref fm) => println!(\"foreign module with abi: {}\", fm.abi),\n-        hir::ItemGlobalAsm(ref asm) => println!(\"global asm: {:?}\", asm),\n-        hir::ItemTy(..) => {\n+        hir::ItemKind::Mod(..) => println!(\"module\"),\n+        hir::ItemKind::ForeignMod(ref fm) => println!(\"foreign module with abi: {}\", fm.abi),\n+        hir::ItemKind::GlobalAsm(ref asm) => println!(\"global asm: {:?}\", asm),\n+        hir::ItemKind::Ty(..) => {\n             println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemExistential(..) => {\n+        hir::ItemKind::Existential(..) => {\n             println!(\"existential type with real type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemEnum(..) => {\n+        hir::ItemKind::Enum(..) => {\n             println!(\"enum definition of type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemStruct(..) => {\n+        hir::ItemKind::Struct(..) => {\n             println!(\"struct definition of type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemUnion(..) => {\n+        hir::ItemKind::Union(..) => {\n             println!(\"union definition of type {:?}\", cx.tcx.type_of(did));\n         },\n-        hir::ItemTrait(..) => {\n+        hir::ItemKind::Trait(..) => {\n             println!(\"trait decl\");\n             if cx.tcx.trait_is_auto(did) {\n                 println!(\"trait is auto\");\n             } else {\n                 println!(\"trait is not auto\");\n             }\n         },\n-        hir::ItemTraitAlias(..) => {\n+        hir::ItemKind::TraitAlias(..) => {\n             println!(\"trait alias\");\n         }\n-        hir::ItemImpl(_, _, _, _, Some(ref _trait_ref), _, _) => {\n+        hir::ItemKind::Impl(_, _, _, _, Some(ref _trait_ref), _, _) => {\n             println!(\"trait impl\");\n         },\n-        hir::ItemImpl(_, _, _, _, None, _, _) => {\n+        hir::ItemKind::Impl(_, _, _, _, None, _, _) => {\n             println!(\"impl\");\n         },\n     }"}, {"sha": "a348df83a9d18222f20dfd976f48134d509c8393", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::utils::{match_qpath, paths, span_lint};\n use syntax::symbol::LocalInternedString;\n@@ -117,15 +118,17 @@ impl LintPass for LintWithoutLintPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemStatic(ref ty, MutImmutable, body_id) = item.node {\n+        if let hir::ItemKind::Static(ref ty, MutImmutable, body_id) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n-            } else if is_lint_array_type(ty) && item.vis.node == VisibilityKind::Inherited && item.name == \"ARRAY\" {\n-                let mut collector = LintCollector {\n-                    output: &mut self.registered_lints,\n-                    cx,\n-                };\n-                collector.visit_expr(&cx.tcx.hir.body(body_id).value);\n+            } else if is_lint_array_type(ty) && item.name == \"ARRAY\" {\n+                if let VisibilityKind::Inherited = item.vis.node {\n+                    let mut collector = LintCollector {\n+                        output: &mut self.registered_lints,\n+                        cx,\n+                    };\n+                    collector.visit_expr(&cx.tcx.hir.body(body_id).value);\n+                }\n             }\n         }\n     }\n@@ -160,15 +163,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n \n \n fn is_lint_ref_type(ty: &Ty) -> bool {\n-    if let TyRptr(\n+    if let TyKind::Rptr(\n         _,\n         MutTy {\n             ty: ref inner,\n             mutbl: MutImmutable,\n         },\n     ) = ty.node\n     {\n-        if let TyPath(ref path) = inner.node {\n+        if let TyKind::Path(ref path) = inner.node {\n             return match_qpath(path, &paths::LINT);\n         }\n     }\n@@ -177,7 +180,7 @@ fn is_lint_ref_type(ty: &Ty) -> bool {\n \n \n fn is_lint_array_type(ty: &Ty) -> bool {\n-    if let TyPath(ref path) = ty.node {\n+    if let TyKind::Path(ref path) = ty.node {\n         match_qpath(path, &paths::LINT_ARRAY)\n     } else {\n         false"}, {"sha": "c38a925efedfdec07f147491b7eb2038a7ed44fc", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -174,7 +174,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n \n /// Check if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr, var: Name) -> bool {\n-    if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n+    if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.node {\n         if path.segments.len() == 1 && path.segments[0].ident.name == var {\n             return true;\n         }\n@@ -210,7 +210,7 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n     match *path {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n-            TyPath(ref inner_path) => {\n+            TyKind::Path(ref inner_path) => {\n                 !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n                     && segment.ident.name == segments[segments.len() - 1]\n             },\n@@ -330,7 +330,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprMethodCall(ref path, _, ref args) = current.node {\n+        if let ExprKind::MethodCall(ref path, _, ref args) = current.node {\n             if path.ident.name == *method_name {\n                 if args.iter().any(|e| in_macro(e.span)) {\n                     return None;\n@@ -435,7 +435,7 @@ pub fn last_line_of_span<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Span {\n     Span::new(*line_start, span.hi(), span.ctxt())\n }\n \n-/// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n+/// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n     cx: &T,\n@@ -445,7 +445,7 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n ) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n-    if let ExprBlock(_, _) = expr.node {\n+    if let ExprKind::Block(_, _) = expr.node {\n         Cow::Owned(format!(\"{}{}\", code, string))\n     } else if string.is_empty() {\n         Cow::Owned(format!(\"{{ {} }}\", code))\n@@ -524,13 +524,13 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n         match node {\n             Node::NodeBlock(block) => Some(block),\n             Node::NodeItem(&Item {\n-                node: ItemFn(_, _, _, eid),\n+                node: ItemKind::Fn(_, _, _, eid),\n                 ..\n             }) | Node::NodeImplItem(&ImplItem {\n                 node: ImplItemKind::Method(_, eid),\n                 ..\n             }) => match cx.tcx.hir.body(eid).value.node {\n-                ExprBlock(ref block, _) => Some(block),\n+                ExprKind::Block(ref block, _) => Some(block),\n                 _ => None,\n             },\n             _ => None,\n@@ -667,7 +667,7 @@ where\n /// Return the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n     match ty.node {\n-        TyPtr(ref mut_ty) | TyRptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        TyKind::Ptr(ref mut_ty) | TyKind::Rptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n         _ => ty,\n     }\n }\n@@ -695,7 +695,7 @@ pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n /// Check whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     // FIXME: use constant folding\n-    if let ExprLit(ref spanned) = expr.node {\n+    if let ExprKind::Lit(ref spanned) = expr.node {\n         if let LitKind::Int(v, _) = spanned.node {\n             return v == value;\n         }\n@@ -945,7 +945,7 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n /// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n /// themselves.\n pub fn remove_blocks(expr: &Expr) -> &Expr {\n-    if let ExprBlock(ref block, _) = expr.node {\n+    if let ExprKind::Block(ref block, _) = expr.node {\n         if block.stmts.is_empty() {\n             if let Some(ref expr) = block.expr {\n                 remove_blocks(expr)\n@@ -998,7 +998,7 @@ pub fn is_self(slf: &Arg) -> bool {\n \n pub fn is_self_ty(slf: &hir::Ty) -> bool {\n     if_chain! {\n-        if let TyPath(ref qp) = slf.node;\n+        if let TyKind::Path(ref qp) = slf.node;\n         if let QPath::Resolved(None, ref path) = *qp;\n         if let Def::SelfTy(..) = path.def;\n         then {\n@@ -1020,7 +1020,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n             if let PatKind::Binding(_, defid, _, None) = pat[0].node;\n-            if let ExprPath(QPath::Resolved(None, ref path)) = arm.body.node;\n+            if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.node;\n             if let Def::Local(lid) = path.def;\n             if lid == defid;\n             then {\n@@ -1038,7 +1038,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n         }\n     }\n \n-    if let ExprMatch(_, ref arms, ref source) = expr.node {\n+    if let ExprKind::Match(_, ref arms, ref source) = expr.node {\n         // desugared from a `?` operator\n         if let MatchSource::TryDesugar = *source {\n             return Some(expr);"}, {"sha": "4275345d395e245ed7c723500397a6d928f600cb", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref seg, _, ref args) = expr.node {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n                 if seg.ident.name == \"capacity\" {\n                     self.abort = true;"}, {"sha": "ff9424289c5c4f9e158915d142fd2387f539f896", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -46,35 +46,35 @@ impl<'a> Sugg<'a> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             match expr.node {\n-                hir::ExprAddrOf(..) |\n-                hir::ExprBox(..) |\n-                hir::ExprClosure(.., _) |\n-                hir::ExprIf(..) |\n-                hir::ExprUnary(..) |\n-                hir::ExprMatch(..) => Sugg::MaybeParen(snippet),\n-                hir::ExprContinue(..) |\n-                hir::ExprYield(..) |\n-                hir::ExprArray(..) |\n-                hir::ExprBlock(..) |\n-                hir::ExprBreak(..) |\n-                hir::ExprCall(..) |\n-                hir::ExprField(..) |\n-                hir::ExprIndex(..) |\n-                hir::ExprInlineAsm(..) |\n-                hir::ExprLit(..) |\n-                hir::ExprLoop(..) |\n-                hir::ExprMethodCall(..) |\n-                hir::ExprPath(..) |\n-                hir::ExprRepeat(..) |\n-                hir::ExprRet(..) |\n-                hir::ExprStruct(..) |\n-                hir::ExprTup(..) |\n-                hir::ExprWhile(..) => Sugg::NonParen(snippet),\n-                hir::ExprAssign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n-                hir::ExprAssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n-                hir::ExprBinary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n-                hir::ExprCast(..) => Sugg::BinOp(AssocOp::As, snippet),\n-                hir::ExprType(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+                hir::ExprKind::AddrOf(..) |\n+                hir::ExprKind::Box(..) |\n+                hir::ExprKind::Closure(.., _) |\n+                hir::ExprKind::If(..) |\n+                hir::ExprKind::Unary(..) |\n+                hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+                hir::ExprKind::Continue(..) |\n+                hir::ExprKind::Yield(..) |\n+                hir::ExprKind::Array(..) |\n+                hir::ExprKind::Block(..) |\n+                hir::ExprKind::Break(..) |\n+                hir::ExprKind::Call(..) |\n+                hir::ExprKind::Field(..) |\n+                hir::ExprKind::Index(..) |\n+                hir::ExprKind::InlineAsm(..) |\n+                hir::ExprKind::Lit(..) |\n+                hir::ExprKind::Loop(..) |\n+                hir::ExprKind::MethodCall(..) |\n+                hir::ExprKind::Path(..) |\n+                hir::ExprKind::Repeat(..) |\n+                hir::ExprKind::Ret(..) |\n+                hir::ExprKind::Struct(..) |\n+                hir::ExprKind::Tup(..) |\n+                hir::ExprKind::While(..) => Sugg::NonParen(snippet),\n+                hir::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+                hir::ExprKind::AssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n+                hir::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n+                hir::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+                hir::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n             }\n         })\n     }\n@@ -382,21 +382,29 @@ fn associativity(op: &AssocOp) -> Associativity {\n \n /// Convert a `hir::BinOp` to the corresponding assigning binary operator.\n fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n-    use rustc::hir::BinOp_::*;\n     use syntax::parse::token::BinOpToken::*;\n \n     AssocOp::AssignOp(match op.node {\n-        BiAdd => Plus,\n-        BiBitAnd => And,\n-        BiBitOr => Or,\n-        BiBitXor => Caret,\n-        BiDiv => Slash,\n-        BiMul => Star,\n-        BiRem => Percent,\n-        BiShl => Shl,\n-        BiShr => Shr,\n-        BiSub => Minus,\n-        BiAnd | BiEq | BiGe | BiGt | BiLe | BiLt | BiNe | BiOr => panic!(\"This operator does not exist\"),\n+        hir::BinOpKind::Add => Plus,\n+        hir::BinOpKind::BitAnd => And,\n+        hir::BinOpKind::BitOr => Or,\n+        hir::BinOpKind::BitXor => Caret,\n+        hir::BinOpKind::Div => Slash,\n+        hir::BinOpKind::Mul => Star,\n+        hir::BinOpKind::Rem => Percent,\n+        hir::BinOpKind::Shl => Shl,\n+        hir::BinOpKind::Shr => Shr,\n+        hir::BinOpKind::Sub => Minus,\n+\n+        | hir::BinOpKind::And\n+        | hir::BinOpKind::Eq\n+        | hir::BinOpKind::Ge\n+        | hir::BinOpKind::Gt\n+        | hir::BinOpKind::Le\n+        | hir::BinOpKind::Lt\n+        | hir::BinOpKind::Ne\n+        | hir::BinOpKind::Or\n+        => panic!(\"This operator does not exist\"),\n     })\n }\n "}, {"sha": "39ab77c3afa1e25418e0c5652bfd814b0e1c2c3b", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_chain! {\n             if let ty::TyRef(_, ty, _) = cx.tables.expr_ty_adjusted(expr).sty;\n             if let ty::TySlice(..) = ty.sty;\n-            if let ExprAddrOf(_, ref addressee) = expr.node;\n+            if let ExprKind::AddrOf(_, ref addressee) = expr.node;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n                 check_vec_macro(cx, &vec_args, expr.span);"}, {"sha": "556d128bca791debdf4b7dc82544752355979803", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -175,17 +175,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n             // print!()\n-            ExprCall(ref fun, ref args) => {\n+            ExprKind::Call(ref fun, ref args) => {\n                 if_chain! {\n-                    if let ExprPath(ref qpath) = fun.node;\n+                    if let ExprKind::Path(ref qpath) = fun.node;\n                     if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n                     then {\n                         check_print_variants(cx, expr, fun_id, args);\n                     }\n                 }\n             },\n             // write!()\n-            ExprMethodCall(ref fun, _, ref args) => {\n+            ExprKind::MethodCall(ref fun, _, ref args) => {\n                 if fun.ident.name == \"write_fmt\" {\n                     check_write_variants(cx, expr, args);\n                 }\n@@ -206,8 +206,8 @@ fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr,\n         if_chain! {\n             // ensure we're calling Arguments::new_v1 or Arguments::new_v1_formatted\n             if write_args.len() == 2;\n-            if let ExprCall(ref args_fun, ref args_args) = write_args[1].node;\n-            if let ExprPath(ref qpath) = args_fun.node;\n+            if let ExprKind::Call(ref args_fun, ref args_args) = write_args[1].node;\n+            if let ExprKind::Path(ref qpath) = args_fun.node;\n             if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n             if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1) ||\n                match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n@@ -219,9 +219,9 @@ fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr,\n \n                 if_chain! {\n                     if args_args.len() >= 2;\n-                    if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-                    if let ExprMatch(ref args, _, _) = match_expr.node;\n-                    if let ExprTup(ref args) = args.node;\n+                    if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n+                    if let ExprKind::Match(ref args, _, _) = match_expr.node;\n+                    if let ExprKind::Tup(ref args) = args.node;\n                     if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n                     then {\n                         match name {\n@@ -269,21 +269,21 @@ fn check_print_variants<'a, 'tcx>(\n             if_chain! {\n                 // ensure we're calling Arguments::new_v1\n                 if args.len() == 1;\n-                if let ExprCall(ref args_fun, ref args_args) = args[0].node;\n+                if let ExprKind::Call(ref args_fun, ref args_args) = args[0].node;\n                 then {\n                     // Check for literals in the print!/println! args\n                     check_fmt_args_for_literal(cx, args_args, |span| {\n                         span_lint(cx, PRINT_LITERAL, span, \"printing a literal with an empty format string\");\n                     });\n \n                     if_chain! {\n-                        if let ExprPath(ref qpath) = args_fun.node;\n+                        if let ExprKind::Path(ref qpath) = args_fun.node;\n                         if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n                         if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n                         if args_args.len() == 2;\n-                        if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n-                        if let ExprMatch(ref args, _, _) = match_expr.node;\n-                        if let ExprTup(ref args) = args.node;\n+                        if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n+                        if let ExprKind::Match(ref args, _, _) = match_expr.node;\n+                        if let ExprKind::Tup(ref args) = args.node;\n                         if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n                         then {\n                             match name {\n@@ -315,7 +315,7 @@ fn check_print_variants<'a, 'tcx>(\n     // Search for something like\n     // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n     else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-        if let ExprPath(ref qpath) = args[1].node {\n+        if let ExprKind::Path(ref qpath) = args[1].node {\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n                 if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr)\n                     && is_expn_of(expr.span, \"panic\").is_none()\n@@ -341,25 +341,25 @@ where\n         if args.len() >= 2;\n \n         // the match statement\n-        if let ExprAddrOf(_, ref match_expr) = args[1].node;\n-        if let ExprMatch(ref matchee, ref arms, _) = match_expr.node;\n-        if let ExprTup(ref tup) = matchee.node;\n+        if let ExprKind::AddrOf(_, ref match_expr) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, _) = match_expr.node;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n         if arms.len() == 1;\n-        if let ExprArray(ref arm_body_exprs) = arms[0].body.node;\n+        if let ExprKind::Array(ref arm_body_exprs) = arms[0].body.node;\n         then {\n             // it doesn't matter how many args there are in the `write!`/`writeln!`,\n             // if there's one literal, we should warn the user\n             for (idx, tup_arg) in tup.iter().enumerate() {\n                 if_chain! {\n-                    // first, make sure we're dealing with a literal (i.e., an ExprLit)\n-                    if let ExprAddrOf(_, ref tup_val) = tup_arg.node;\n-                    if let ExprLit(_) = tup_val.node;\n+                    // first, make sure we're dealing with a literal (i.e., an ExprKind::Lit)\n+                    if let ExprKind::AddrOf(_, ref tup_val) = tup_arg.node;\n+                    if let ExprKind::Lit(_) = tup_val.node;\n \n                     // next, check the corresponding match arm body to ensure\n                     // this is DISPLAY_FMT_METHOD\n-                    if let ExprCall(_, ref body_args) = arm_body_exprs[idx].node;\n+                    if let ExprKind::Call(_, ref body_args) = arm_body_exprs[idx].node;\n                     if body_args.len() == 2;\n-                    if let ExprPath(ref body_qpath) = body_args[1].node;\n+                    if let ExprKind::Path(ref body_qpath) = body_args[1].node;\n                     if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n                     if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n                     then {\n@@ -371,10 +371,10 @@ where\n                         // and is just \"{}\"\n                         if_chain! {\n                             if args.len() == 3;\n-                            if let ExprAddrOf(_, ref format_expr) = args[2].node;\n-                            if let ExprArray(ref format_exprs) = format_expr.node;\n+                            if let ExprKind::AddrOf(_, ref format_expr) = args[2].node;\n+                            if let ExprKind::Array(ref format_exprs) = format_expr.node;\n                             if format_exprs.len() >= 1;\n-                            if let ExprStruct(_, ref fields, _) = format_exprs[idx].node;\n+                            if let ExprKind::Struct(_, ref fields, _) = format_exprs[idx].node;\n                             if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n                             if check_unformatted(&format_field.expr);\n                             then {\n@@ -429,10 +429,10 @@ fn has_empty_arg<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: Local\n /// Returns the slice of format string parts in an `Arguments::new_v1` call.\n fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(LocalInternedString, usize)> {\n     if_chain! {\n-        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n-        if let ExprArray(ref exprs) = expr.node;\n+        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n+        if let ExprKind::Array(ref exprs) = expr.node;\n         if let Some(expr) = exprs.last();\n-        if let ExprLit(ref lit) = expr.node;\n+        if let ExprKind::Lit(ref lit) = expr.node;\n         if let LitKind::Str(ref lit, _) = lit.node;\n         then {\n             return Some((lit.as_str(), exprs.len()));\n@@ -448,7 +448,7 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) {\n         // `Debug` impl\n         if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n-            if let ItemImpl(_, _, _, _, Some(ref tr), _, _) = item.node {\n+            if let ItemKind::Impl(_, _, _, _, Some(ref tr), _, _) = item.node {\n                 return match_path(&tr.path, &[\"Debug\"]);\n             }\n         }\n@@ -468,15 +468,15 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n /// ```\n pub fn check_unformatted(format_field: &Expr) -> bool {\n     if_chain! {\n-        if let ExprStruct(_, ref fields, _) = format_field.node;\n+        if let ExprKind::Struct(_, ref fields, _) = format_field.node;\n         if let Some(width_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprPath(ref qpath) = width_field.expr.node;\n+        if let ExprKind::Path(ref qpath) = width_field.expr.node;\n         if last_path_segment(qpath).ident.name == \"Implied\";\n         if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"align\");\n-        if let ExprPath(ref qpath) = align_field.expr.node;\n+        if let ExprKind::Path(ref qpath) = align_field.expr.node;\n         if last_path_segment(qpath).ident.name == \"Unknown\";\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == \"precision\");\n-        if let ExprPath(ref qpath_precision) = precision_field.expr.node;\n+        if let ExprKind::Path(ref qpath_precision) = precision_field.expr.node;\n         if last_path_segment(qpath_precision).ident.name == \"Implied\";\n         then {\n             return true;"}, {"sha": "5232d5714f1351bb0be34d910f52cd5496ac7574", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -32,8 +32,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n-            if let ExprBinary(ref op, ref left, ref right) = expr.node;\n-            if let BinOp_::BiDiv = op.node;\n+            if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n+            if let BinOpKind::Div = op.node;\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too."}, {"sha": "3417e603c126e574aa2a7a96ca1b775be9f1ed60", "filename": "mini-macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/mini-macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/mini-macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini-macro%2Fsrc%2Flib.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,4 +1,4 @@\n-#![feature(proc_macro, proc_macro_non_items)]\n+#![feature(use_extern_macros, proc_macro_quote, proc_macro_non_items)]\n extern crate proc_macro;\n \n use proc_macro::{TokenStream, quote};"}, {"sha": "b06fb1d21e3512ed5749a290dfee9f0dde7df55b", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,11 +1,11 @@\n if_chain! {\n-    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let StmtKind::Decl(ref decl, _) = stmt.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprCast(ref expr, ref cast_ty) = init.node;\n-    if let Ty_::TyPath(ref qp) = cast_ty.node;\n+    if let ExprKind::Cast(ref expr, ref cast_ty) = init.node;\n+    if let TyKind::Path(ref qp) = cast_ty.node;\n     if match_qpath(qp, &[\"char\"]);\n-    if let Expr_::ExprLit(ref lit) = expr.node;\n+    if let ExprKind::Lit(ref lit) = expr.node;\n     if let LitKind::Int(69, _) = lit.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local.pat.node;\n     if name.node.as_str() == \"x\";"}, {"sha": "1c25708fb4849f734f6fc20a2dfec6d75e58bb0c", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,14 +1,14 @@\n if_chain! {\n-    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let StmtKind::Decl(ref decl, _) = stmt.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprCall(ref func, ref args) = init.node;\n-    if let Expr_::ExprPath(ref path) = func.node;\n+    if let ExprKind::Call(ref func, ref args) = init.node;\n+    if let ExprKind::Path(ref path) = func.node;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);\n     if args.len() == 2;\n-    if let Expr_::ExprLit(ref lit) = args[0].node;\n+    if let ExprKind::Lit(ref lit) = args[0].node;\n     if let LitKind::Int(3, _) = lit.node;\n-    if let Expr_::ExprLit(ref lit1) = args[1].node;\n+    if let ExprKind::Lit(ref lit1) = args[1].node;\n     if let LitKind::Int(4, _) = lit1.node;\n     if let PatKind::Wild = local.pat.node;\n     then {"}, {"sha": "b99e8e0ade5e5cb3247ef082f179e172acc4c6fa", "filename": "tests/ui/author/for_loop.stdout", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,60 +1,60 @@\n if_chain! {\n-    if let Expr_::ExprBlock(ref block) = expr.node;\n-    if let Stmt_::StmtDecl(ref decl, _) = block.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let ExprKind::Block(ref block) = expr.node;\n+    if let StmtKind::Decl(ref decl, _) = block.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n-    if let Expr_::ExprCall(ref func, ref args) = expr.node;\n-    if let Expr_::ExprPath(ref path) = func.node;\n+    if let ExprKind::Match(ref expr, ref arms, MatchSource::ForLoopDesugar) = init.node;\n+    if let ExprKind::Call(ref func, ref args) = expr.node;\n+    if let ExprKind::Path(ref path) = func.node;\n     if match_qpath(path, &[\"{{root}}\", \"std\", \"iter\", \"IntoIterator\", \"into_iter\"]);\n     if args.len() == 1;\n-    if let Expr_::ExprStruct(ref path1, ref fields, None) = args[0].node;\n+    if let ExprKind::Struct(ref path1, ref fields, None) = args[0].node;\n     if match_qpath(path1, &[\"{{root}}\", \"std\", \"ops\", \"Range\"]);\n     if fields.len() == 2;\n     // unimplemented: field checks\n     if arms.len() == 1;\n-    if let Expr_::ExprLoop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n-    if let Stmt_::StmtDecl(ref decl1, _) = body.node\n-    if let Decl_::DeclLocal(ref local1) = decl1.node;\n+    if let ExprKind::Loop(ref body, ref label, LoopSource::ForLoop) = arms[0].body.node;\n+    if let StmtKind::Decl(ref decl1, _) = body.node\n+    if let DeclKind::Local(ref local1) = decl1.node;\n     if let PatKind::Binding(BindingAnnotation::Mutable, _, name, None) = local1.pat.node;\n     if name.node.as_str() == \"__next\";\n-    if let Stmt_::StmtExpr(ref e, _) = local1.pat.node\n-    if let Expr_::ExprMatch(ref expr1, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n-    if let Expr_::ExprCall(ref func1, ref args1) = expr1.node;\n-    if let Expr_::ExprPath(ref path2) = func1.node;\n+    if let StmtKind::Expr(ref e, _) = local1.pat.node\n+    if let ExprKind::Match(ref expr1, ref arms1, MatchSource::ForLoopDesugar) = e.node;\n+    if let ExprKind::Call(ref func1, ref args1) = expr1.node;\n+    if let ExprKind::Path(ref path2) = func1.node;\n     if match_qpath(path2, &[\"{{root}}\", \"std\", \"iter\", \"Iterator\", \"next\"]);\n     if args1.len() == 1;\n-    if let Expr_::ExprAddrOf(MutMutable, ref inner) = args1[0].node;\n-    if let Expr_::ExprPath(ref path3) = inner.node;\n+    if let ExprKind::AddrOf(MutMutable, ref inner) = args1[0].node;\n+    if let ExprKind::Path(ref path3) = inner.node;\n     if match_qpath(path3, &[\"iter\"]);\n     if arms1.len() == 2;\n-    if let Expr_::ExprAssign(ref target, ref value) = arms1[0].body.node;\n-    if let Expr_::ExprPath(ref path4) = target.node;\n+    if let ExprKind::Assign(ref target, ref value) = arms1[0].body.node;\n+    if let ExprKind::Path(ref path4) = target.node;\n     if match_qpath(path4, &[\"__next\"]);\n-    if let Expr_::ExprPath(ref path5) = value.node;\n+    if let ExprKind::Path(ref path5) = value.node;\n     if match_qpath(path5, &[\"val\"]);\n     if arms1[0].pats.len() == 1;\n     if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pats[0].node;\n     if match_qpath(path6, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n     if fields1.len() == 1;\n     // unimplemented: field checks\n-    if let Expr_::ExprBreak(ref destination, None) = arms1[1].body.node;\n+    if let ExprKind::Break(ref destination, None) = arms1[1].body.node;\n     if arms1[1].pats.len() == 1;\n     if let PatKind::Path(ref path7) = arms1[1].pats[0].node;\n     if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n-    if let Stmt_::StmtDecl(ref decl2, _) = path7.node\n-    if let Decl_::DeclLocal(ref local2) = decl2.node;\n+    if let StmtKind::Decl(ref decl2, _) = path7.node\n+    if let DeclKind::Local(ref local2) = decl2.node;\n     if let Some(ref init1) = local2.init\n-    if let Expr_::ExprPath(ref path8) = init1.node;\n+    if let ExprKind::Path(ref path8) = init1.node;\n     if match_qpath(path8, &[\"__next\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name1, None) = local2.pat.node;\n     if name1.node.as_str() == \"y\";\n-    if let Stmt_::StmtExpr(ref e1, _) = local2.pat.node\n-    if let Expr_::ExprBlock(ref block1) = e1.node;\n-    if let Stmt_::StmtDecl(ref decl3, _) = block1.node\n-    if let Decl_::DeclLocal(ref local3) = decl3.node;\n+    if let StmtKind::Expr(ref e1, _) = local2.pat.node\n+    if let ExprKind::Block(ref block1) = e1.node;\n+    if let StmtKind::Decl(ref decl3, _) = block1.node\n+    if let DeclKind::Local(ref local3) = decl3.node;\n     if let Some(ref init2) = local3.init\n-    if let Expr_::ExprPath(ref path9) = init2.node;\n+    if let ExprKind::Path(ref path9) = init2.node;\n     if match_qpath(path9, &[\"y\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local3.pat.node;\n     if name2.node.as_str() == \"z\";\n@@ -63,7 +63,7 @@ if_chain! {\n     if name3.node.as_str() == \"iter\";\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name4, None) = local.pat.node;\n     if name4.node.as_str() == \"_result\";\n-    if let Expr_::ExprPath(ref path10) = local.pat.node;\n+    if let ExprKind::Path(ref path10) = local.pat.node;\n     if match_qpath(path10, &[\"_result\"]);\n     then {\n         // report your lint here"}, {"sha": "94b25aefabed284196353925164afb34eb70e695", "filename": "tests/ui/author/matches.stout", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor%2Fmatches.stout", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fauthor%2Fmatches.stout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stout?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,32 +1,32 @@\n if_chain! {\n-    if let Stmt_::StmtDecl(ref decl, _) = stmt.node\n-    if let Decl_::DeclLocal(ref local) = decl.node;\n+    if let StmtKind::Decl(ref decl, _) = stmt.node\n+    if let DeclKind::Local(ref local) = decl.node;\n     if let Some(ref init) = local.init\n-    if let Expr_::ExprMatch(ref expr, ref arms, MatchSource::Normal) = init.node;\n-    if let Expr_::ExprLit(ref lit) = expr.node;\n+    if let ExprKind::Match(ref expr, ref arms, MatchSource::Normal) = init.node;\n+    if let ExprKind::Lit(ref lit) = expr.node;\n     if let LitKind::Int(42, _) = lit.node;\n     if arms.len() == 3;\n-    if let Expr_::ExprLit(ref lit1) = arms[0].body.node;\n+    if let ExprKind::Lit(ref lit1) = arms[0].body.node;\n     if let LitKind::Int(5, _) = lit1.node;\n     if arms[0].pats.len() == 1;\n     if let PatKind::Lit(ref lit_expr) = arms[0].pats[0].node\n-    if let Expr_::ExprLit(ref lit2) = lit_expr.node;\n+    if let ExprKind::Lit(ref lit2) = lit_expr.node;\n     if let LitKind::Int(16, _) = lit2.node;\n-    if let Expr_::ExprBlock(ref block) = arms[1].body.node;\n-    if let Stmt_::StmtDecl(ref decl1, _) = block.node\n-    if let Decl_::DeclLocal(ref local1) = decl1.node;\n+    if let ExprKind::Block(ref block) = arms[1].body.node;\n+    if let StmtKind::Decl(ref decl1, _) = block.node\n+    if let DeclKind::Local(ref local1) = decl1.node;\n     if let Some(ref init1) = local1.init\n-    if let Expr_::ExprLit(ref lit3) = init1.node;\n+    if let ExprKind::Lit(ref lit3) = init1.node;\n     if let LitKind::Int(3, _) = lit3.node;\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name, None) = local1.pat.node;\n     if name.node.as_str() == \"x\";\n-    if let Expr_::ExprPath(ref path) = local1.pat.node;\n+    if let ExprKind::Path(ref path) = local1.pat.node;\n     if match_qpath(path, &[\"x\"]);\n     if arms[1].pats.len() == 1;\n     if let PatKind::Lit(ref lit_expr1) = arms[1].pats[0].node\n-    if let Expr_::ExprLit(ref lit4) = lit_expr1.node;\n+    if let ExprKind::Lit(ref lit4) = lit_expr1.node;\n     if let LitKind::Int(17, _) = lit4.node;\n-    if let Expr_::ExprLit(ref lit5) = arms[2].body.node;\n+    if let ExprKind::Lit(ref lit5) = arms[2].body.node;\n     if let LitKind::Int(1, _) = lit5.node;\n     if arms[2].pats.len() == 1;\n     if let PatKind::Wild = arms[2].pats[0].node;"}, {"sha": "6bbc0aebf9c9bd07c860c62a2c23dc2ba0647a01", "filename": "tests/ui/deprecated.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.stderr?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,30 +1,30 @@\n-error: lint str_to_string has been removed: using `str::to_string` is common even today and specialization will likely happen soon\n+error: lint `str_to_string` has been removed: `using `str::to_string` is common even today and specialization will likely happen soon`\n  --> $DIR/deprecated.rs:4:8\n   |\n 4 | #[warn(str_to_string)]\n   |        ^^^^^^^^^^^^^\n   |\n   = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n-error: lint string_to_string has been removed: using `string::to_string` is common even today and specialization will likely happen soon\n+error: lint `string_to_string` has been removed: `using `string::to_string` is common even today and specialization will likely happen soon`\n  --> $DIR/deprecated.rs:6:8\n   |\n 6 | #[warn(string_to_string)]\n   |        ^^^^^^^^^^^^^^^^\n \n-error: lint unstable_as_slice has been removed: `Vec::as_slice` has been stabilized in 1.7\n+error: lint `unstable_as_slice` has been removed: ``Vec::as_slice` has been stabilized in 1.7`\n  --> $DIR/deprecated.rs:8:8\n   |\n 8 | #[warn(unstable_as_slice)]\n   |        ^^^^^^^^^^^^^^^^^\n \n-error: lint unstable_as_mut_slice has been removed: `Vec::as_mut_slice` has been stabilized in 1.7\n+error: lint `unstable_as_mut_slice` has been removed: ``Vec::as_mut_slice` has been stabilized in 1.7`\n   --> $DIR/deprecated.rs:10:8\n    |\n 10 | #[warn(unstable_as_mut_slice)]\n    |        ^^^^^^^^^^^^^^^^^^^^^\n \n-error: lint misaligned_transmute has been removed: this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr\n+error: lint `misaligned_transmute` has been removed: `this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr`\n   --> $DIR/deprecated.rs:12:8\n    |\n 12 | #[warn(misaligned_transmute)]"}, {"sha": "9f6fce2495a3dfdbfd82e10957744fc8e93341d6", "filename": "tests/ui/suspicious_arithmetic_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.rs?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -25,23 +25,23 @@ impl Mul for Foo {\n     type Output = Foo;\n \n     fn mul(self, other: Foo) -> Foo {\n-        Foo(self.0 * other.0 % 42) // OK: BiRem part of BiExpr as parent node\n+        Foo(self.0 * other.0 % 42) // OK: BinOpKind::Rem part of BiExpr as parent node\n     }\n }\n \n impl Sub for Foo {\n     type Output = Foo;\n \n     fn sub(self, other: Self) -> Self {\n-        Foo(self.0 * other.0 - 42) // OK: BiMul part of BiExpr as child node\n+        Foo(self.0 * other.0 - 42) // OK: BinOpKind::Mul part of BiExpr as child node\n     }\n }\n \n impl Div for Foo {\n     type Output = Foo;\n \n     fn div(self, other: Self) -> Self {\n-        Foo(do_nothing(self.0 + other.0) / 42) // OK: BiAdd part of BiExpr as child node\n+        Foo(do_nothing(self.0 + other.0) / 42) // OK: BinOpKind::Add part of BiExpr as child node\n     }\n }\n "}, {"sha": "b311604c0c87eafd4bbc4172d4b9b13d92f02da4", "filename": "tests/ui/trailing_zeros.stdout", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Ftrailing_zeros.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/847e4dcc0d21ccea018629e46dd0baf4939a8261/tests%2Fui%2Ftrailing_zeros.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.stdout?ref=847e4dcc0d21ccea018629e46dd0baf4939a8261", "patch": "@@ -1,13 +1,13 @@\n if_chain! {\n-    if let Expr_::ExprBinary(ref op, ref left, ref right) = expr.node;\n-    if BinOp_::BiEq == op.node;\n-    if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n-    if BinOp_::BiBitAnd == op1.node;\n-    if let Expr_::ExprPath(ref path) = left1.node;\n+    if let ExprKind::Binary(ref op, ref left, ref right) = expr.node;\n+    if BinOpKind::Eq == op.node;\n+    if let ExprKind::Binary(ref op1, ref left1, ref right1) = left.node;\n+    if BinOpKind::BitAnd == op1.node;\n+    if let ExprKind::Path(ref path) = left1.node;\n     if match_qpath(path, &[\"x\"]);\n-    if let Expr_::ExprLit(ref lit) = right1.node;\n+    if let ExprKind::Lit(ref lit) = right1.node;\n     if let LitKind::Int(15, _) = lit.node;\n-    if let Expr_::ExprLit(ref lit1) = right.node;\n+    if let ExprKind::Lit(ref lit1) = right.node;\n     if let LitKind::Int(0, _) = lit1.node;\n     then {\n         // report your lint here"}]}