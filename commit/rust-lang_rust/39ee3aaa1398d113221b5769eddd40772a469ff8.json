{"sha": "39ee3aaa1398d113221b5769eddd40772a469ff8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZWUzYWFhMTM5OGQxMTMyMjFiNTc2OWVkZGQ0MDc3MmE0NjlmZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-26T00:15:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-26T00:15:34Z"}, "message": "Auto merge of #49297 - scottmcm:offset-from, r=dtolnay\n\nIntroduce unsafe offset_from on pointers\n\nAdds intrinsics::exact_div to take advantage of the unsafe, which reduces the implementation from\n```asm\n    sub rcx, rdx\n    mov rax, rcx\n    sar rax, 63\n    shr rax, 62\n    lea rax, [rax + rcx]\n    sar rax, 2\n    ret\n```\ndown to\n```asm\n    sub rcx, rdx\n    sar rcx, 2\n    mov rax, rcx\n    ret\n```\n(for `*const i32`)\n\nSee discussion on the `offset_to` tracking issue https://github.com/rust-lang/rust/issues/41079\n\nSome open questions\n- Would you rather I split the intrinsic PR from the library PR?\n- Do we even want the safe version of the API?  https://github.com/rust-lang/rust/issues/41079#issuecomment-374426786  I've added some text to its documentation that even if it's not UB, it's useless to use it between pointers into different objects.\n\nand todos\n- [x] ~~I need to make a codegen test~~ Done\n- [x] ~~Can the subtraction use nsw/nuw?~~ No, it can't https://github.com/rust-lang/rust/pull/49297#discussion_r176697574\n- [x] ~~Should there be `usize` variants of this, like there are now `add` and `sub` that you almost always want over `offset`?  For example, I imagine `sub_ptr` that returns `usize` and where it's UB if the distance is negative.~~ Can wait for later; C gives a signed result https://github.com/rust-lang/rust/issues/41079#issuecomment-375842235, so we might as well, and this existing to go with `offset` makes sense.", "tree": {"sha": "f03353bfb4f8adbdc8d7bc86e0b6ceb9bf529aff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f03353bfb4f8adbdc8d7bc86e0b6ceb9bf529aff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ee3aaa1398d113221b5769eddd40772a469ff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ee3aaa1398d113221b5769eddd40772a469ff8", "html_url": "https://github.com/rust-lang/rust/commit/39ee3aaa1398d113221b5769eddd40772a469ff8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ee3aaa1398d113221b5769eddd40772a469ff8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3518058e2d47ec04aa8b9756b5d4398bce19faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3518058e2d47ec04aa8b9756b5d4398bce19faf", "html_url": "https://github.com/rust-lang/rust/commit/d3518058e2d47ec04aa8b9756b5d4398bce19faf"}, {"sha": "62649524b94fb83e2ed472088ea1a0cd87079fd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/62649524b94fb83e2ed472088ea1a0cd87079fd2", "html_url": "https://github.com/rust-lang/rust/commit/62649524b94fb83e2ed472088ea1a0cd87079fd2"}], "stats": {"total": 299, "additions": 295, "deletions": 4}, "files": [{"sha": "3b740adc46832d06e0c21c5429d5527542c62a04", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -1314,6 +1314,11 @@ extern \"rust-intrinsic\" {\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n+    /// Performs an exact division, resulting in undefined behavior where\n+    /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n+    #[cfg(not(stage0))]\n+    pub fn exact_div<T>(x: T, y: T) -> T;\n+\n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n     pub fn unchecked_div<T>(x: T, y: T) -> T;\n@@ -1396,3 +1401,8 @@ extern \"rust-intrinsic\" {\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n }\n+\n+#[cfg(stage0)]\n+pub unsafe fn exact_div<T>(a: T, b: T) -> T {\n+    unchecked_div(a, b)\n+}"}, {"sha": "aebd50d9c6b3c8f3c7f08465340d5409f3852aad", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 227, "deletions": 2, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -669,7 +669,7 @@ impl<T: ?Sized> *const T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -700,6 +700,124 @@ impl<T: ?Sized> *const T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        // This is the same sequence that Clang emits for pointer subtraction.\n+        // It can be neither `nsw` nor `nuw` because the input is treated as\n+        // unsigned but then the output is treated as signed, so neither works.\n+        let d = isize::wrapping_sub(self as _, origin as _);\n+        intrinsics::exact_div(d, pointee_size as _)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *const i32 = 3 as _;\n+    /// let ptr2: *const i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        let d = isize::wrapping_sub(self as _, origin as _);\n+        d.wrapping_div(pointee_size as _)\n+    }\n+\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n@@ -1316,7 +1434,7 @@ impl<T: ?Sized> *mut T {\n     /// `mem::size_of::<T>()` then the result of the division is rounded towards\n     /// zero.\n     ///\n-    /// This function returns `None` if `T` is a zero-sized typed.\n+    /// This function returns `None` if `T` is a zero-sized type.\n     ///\n     /// # Examples\n     ///\n@@ -1347,6 +1465,113 @@ impl<T: ?Sized> *mut T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset-1\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T`.\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).offset_from(origin)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// Though this method is safe for any two pointers, note that its result\n+    /// will be mostly useless if the two pointers aren't into the same allocated\n+    /// object, for example if they point to two different local variables.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let mut a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *mut i32 = 3 as _;\n+    /// let ptr2: *mut i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, origin: *const T) -> isize where T: Sized {\n+        (self as *const T).wrapping_offset_from(origin)\n+    }\n+\n     /// Computes the byte offset that needs to be applied in order to\n     /// make the pointer aligned to `align`.\n     /// If it is not possible to align the pointer, the implementation returns"}, {"sha": "403fe4731f118877156e7167d7dea727f913f7ea", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -935,6 +935,11 @@ extern \"C\" {\n                          RHS: ValueRef,\n                          Name: *const c_char)\n                          -> ValueRef;\n+    pub fn LLVMBuildExactUDiv(B: BuilderRef,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n     pub fn LLVMBuildSDiv(B: BuilderRef,\n                          LHS: ValueRef,\n                          RHS: ValueRef,"}, {"sha": "5e2d32b359698a171c5f33fa82e37f741bab9227", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -344,6 +344,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn exactudiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"exactudiv\");\n+        unsafe {\n+            llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n     pub fn sdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n         self.count_insn(\"sdiv\");\n         unsafe {"}, {"sha": "2be29c08360753d900e3ef6623385b050cb9d6ae", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -289,7 +289,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n         \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n         \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n-        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n+        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" | \"exact_div\" => {\n             let ty = arg_tys[0];\n             match int_type_width_signed(ty, cx) {\n                 Some((width, signed)) =>\n@@ -343,6 +343,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                         \"overflowing_add\" => bx.add(args[0].immediate(), args[1].immediate()),\n                         \"overflowing_sub\" => bx.sub(args[0].immediate(), args[1].immediate()),\n                         \"overflowing_mul\" => bx.mul(args[0].immediate(), args[1].immediate()),\n+                        \"exact_div\" =>\n+                            if signed {\n+                                bx.exactsdiv(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.exactudiv(args[0].immediate(), args[1].immediate())\n+                            },\n                         \"unchecked_div\" =>\n                             if signed {\n                                 bx.sdiv(args[0].immediate(), args[1].immediate())"}, {"sha": "da37cec31cf44c00976248e9747c9f0cfe8e6f30", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -283,7 +283,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (1, vec![param(0), param(0)],\n                 tcx.intern_tup(&[param(0), tcx.types.bool])),\n \n-            \"unchecked_div\" | \"unchecked_rem\" =>\n+            \"unchecked_div\" | \"unchecked_rem\" | \"exact_div\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n             \"unchecked_shl\" | \"unchecked_shr\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}, {"sha": "e815d151aeba931b0c3e44d82df388acf3ac07ae", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -1492,3 +1492,11 @@ LLVMRustBuildVectorReduceFMax(LLVMBuilderRef, LLVMValueRef, bool) {\n   return nullptr;\n }\n #endif\n+\n+#if LLVM_VERSION_LT(4, 0)\n+extern \"C\" LLVMValueRef\n+LLVMBuildExactUDiv(LLVMBuilderRef B, LLVMValueRef LHS,\n+                   LLVMValueRef RHS, const char *Name) {\n+  return wrap(unwrap(B)->CreateExactUDiv(unwrap(LHS), unwrap(RHS), Name));\n+}\n+#endif"}, {"sha": "9ba6c0c00063772738deb5905769e4b5c9918673", "filename": "src/test/codegen/exact_div.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Ftest%2Fcodegen%2Fexact_div.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee3aaa1398d113221b5769eddd40772a469ff8/src%2Ftest%2Fcodegen%2Fexact_div.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fexact_div.rs?ref=39ee3aaa1398d113221b5769eddd40772a469ff8", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(core_intrinsics)]\n+\n+use std::intrinsics::exact_div;\n+\n+// CHECK-LABEL: @exact_sdiv\n+#[no_mangle]\n+pub unsafe fn exact_sdiv(x: i32, y: i32) -> i32 {\n+// CHECK: sdiv exact\n+    exact_div(x, y)\n+}\n+\n+// CHECK-LABEL: @exact_udiv\n+#[no_mangle]\n+pub unsafe fn exact_udiv(x: u32, y: u32) -> u32 {\n+// CHECK: udiv exact\n+    exact_div(x, y)\n+}"}]}