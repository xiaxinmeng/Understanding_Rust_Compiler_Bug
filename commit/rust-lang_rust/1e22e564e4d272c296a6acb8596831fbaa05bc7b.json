{"sha": "1e22e564e4d272c296a6acb8596831fbaa05bc7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMjJlNTY0ZTRkMjcyYzI5NmE2YWNiODU5NjgzMWZiYWEwNWJjN2I=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-04-28T02:04:06Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-01T22:38:05Z"}, "message": "Refactor config deserialization", "tree": {"sha": "880ca5a252f2ed15ccc8c1772cb7929f693e3781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/880ca5a252f2ed15ccc8c1772cb7929f693e3781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e22e564e4d272c296a6acb8596831fbaa05bc7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e22e564e4d272c296a6acb8596831fbaa05bc7b", "html_url": "https://github.com/rust-lang/rust/commit/1e22e564e4d272c296a6acb8596831fbaa05bc7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e22e564e4d272c296a6acb8596831fbaa05bc7b/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9c8e683d609d204fd1192e236a92099d94cbef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c8e683d609d204fd1192e236a92099d94cbef2", "html_url": "https://github.com/rust-lang/rust/commit/b9c8e683d609d204fd1192e236a92099d94cbef2"}], "stats": {"total": 240, "additions": 108, "deletions": 132}, "files": [{"sha": "40a793e48cf0de323a36ee066f0bbb6f76dad575", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e22e564e4d272c296a6acb8596831fbaa05bc7b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e22e564e4d272c296a6acb8596831fbaa05bc7b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1e22e564e4d272c296a6acb8596831fbaa05bc7b", "patch": "@@ -382,6 +382,7 @@ mod zero_sized_map_values;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n pub use crate::utils::conf::Conf;\n+use crate::utils::conf::TryConf;\n \n /// Register all pre expansion lints\n ///\n@@ -421,8 +422,7 @@ pub fn read_conf(sess: &Session) -> Conf {\n         file_name\n     };\n \n-    let (conf, errors) = utils::conf::read(&file_name);\n-\n+    let TryConf { conf, errors } = utils::conf::read(&file_name);\n     // all conf errors are non-fatal, we just use the default conf in case of error\n     for error in errors {\n         sess.struct_err(&format!("}, {"sha": "747d92dd742387afb61800d53cbe6029bdac721e", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 104, "deletions": 128, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/1e22e564e4d272c296a6acb8596831fbaa05bc7b/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e22e564e4d272c296a6acb8596831fbaa05bc7b/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=1e22e564e4d272c296a6acb8596831fbaa05bc7b", "patch": "@@ -1,98 +1,111 @@\n //! Read configurations files.\n \n-#![deny(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::module_name_repetitions)]\n \n-use std::lazy::SyncLazy;\n+use serde::de::{Deserializer, IgnoredAny, IntoDeserializer, MapAccess, Visitor};\n+use serde::Deserialize;\n+use std::error::Error;\n use std::path::{Path, PathBuf};\n-use std::sync::Mutex;\n use std::{env, fmt, fs, io};\n \n-/// Error from reading a configuration file.\n-#[derive(Debug)]\n-pub enum Error {\n-    /// An I/O error.\n-    Io(io::Error),\n-    /// Not valid toml or doesn't fit the expected config format\n-    Toml(String),\n+/// Conf with parse errors\n+#[derive(Default)]\n+pub struct TryConf {\n+    pub conf: Conf,\n+    pub errors: Vec<String>,\n }\n \n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::Io(err) => err.fmt(f),\n-            Self::Toml(err) => err.fmt(f),\n+impl TryConf {\n+    fn from_error(error: impl Error) -> Self {\n+        Self {\n+            conf: Conf::default(),\n+            errors: vec![error.to_string()],\n         }\n     }\n }\n \n-impl From<io::Error> for Error {\n-    fn from(e: io::Error) -> Self {\n-        Self::Io(e)\n-    }\n-}\n+macro_rules! define_Conf {\n+    ($(\n+        #[$doc:meta]\n+        $(#[conf_deprecated($dep:literal)])?\n+        ($name:ident: $ty:ty $(= $default:expr)?),\n+    )*) => {\n+        /// Clippy lint configuration\n+        pub struct Conf {\n+            $(#[$doc] pub $name: $ty,)*\n+        }\n \n-/// Vec of errors that might be collected during config toml parsing\n-static ERRORS: SyncLazy<Mutex<Vec<Error>>> = SyncLazy::new(|| Mutex::new(Vec::new()));\n+        mod defaults {\n+            $(pub fn $name() -> $ty { define_Conf!(@default $($default)?) })*\n+        }\n \n-macro_rules! define_Conf {\n-    ($(#[$doc:meta] ($config:ident, $config_str:literal: $Ty:ty, $default:expr),)+) => {\n-        mod helpers {\n-            use serde::Deserialize;\n-            /// Type used to store lint configuration.\n-            #[derive(Deserialize)]\n-            #[serde(rename_all = \"kebab-case\", deny_unknown_fields)]\n-            pub struct Conf {\n-                $(\n-                    #[$doc]\n-                    #[serde(default = $config_str)]\n-                    #[serde(with = $config_str)]\n-                    pub $config: $Ty,\n-                )+\n-                #[allow(dead_code)]\n-                #[serde(default)]\n-                third_party: Option<::toml::Value>,\n+        impl Default for Conf {\n+            fn default() -> Self {\n+                Self { $($name: defaults::$name(),)* }\n             }\n+        }\n \n-            $(\n-                mod $config {\n-                    use serde::Deserialize;\n-                    pub fn deserialize<'de, D: serde::Deserializer<'de>>(deserializer: D) -> Result<$Ty, D::Error> {\n-                        use super::super::{ERRORS, Error};\n-\n-                        Ok(\n-                            <$Ty>::deserialize(deserializer).unwrap_or_else(|e| {\n-                                ERRORS\n-                                    .lock()\n-                                    .expect(\"no threading here\")\n-                                    .push(Error::Toml(e.to_string()));\n-                                super::$config()\n-                            })\n-                        )\n-                    }\n-                }\n+        impl<'de> Deserialize<'de> for TryConf {\n+            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n+                deserializer.deserialize_map(ConfVisitor)\n+            }\n+        }\n+\n+        #[derive(Deserialize)]\n+        #[serde(field_identifier, rename_all = \"kebab-case\")]\n+        #[allow(non_camel_case_types)]\n+        enum Field { $($name,)* third_party, }\n+\n+        struct ConfVisitor;\n+\n+        impl<'de> Visitor<'de> for ConfVisitor {\n+            type Value = TryConf;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                formatter.write_str(\"Conf\")\n+            }\n \n-                #[must_use]\n-                fn $config() -> $Ty {\n-                    let x = $default;\n-                    x\n+            fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error> where V: MapAccess<'de> {\n+                let mut errors = Vec::new();\n+                $(let mut $name = None;)*\n+                // could get `Field` here directly, but get `str` first for diagnostics\n+                while let Some(name) = map.next_key::<&str>()? {\n+                    match Field::deserialize(name.into_deserializer())? {\n+                        $(Field::$name => {\n+                            $(errors.push(format!(\"deprecated field `{}`. {}\", name, $dep));)?\n+                            match map.next_value() {\n+                                Err(e) => errors.push(e.to_string()),\n+                                Ok(value) => match $name {\n+                                    Some(_) => errors.push(format!(\"duplicate field `{}`\", name)),\n+                                    None => $name = Some(value),\n+                                }\n+                            }\n+                        })*\n+                        // white-listed; ignore\n+                        Field::third_party => drop(map.next_value::<IgnoredAny>())\n+                    }\n                 }\n-            )+\n+                let conf = Conf { $($name: $name.unwrap_or_else(defaults::$name),)* };\n+                Ok(TryConf { conf, errors })\n+            }\n         }\n     };\n+    (@default) => (Default::default());\n+    (@default $default:expr) => ($default);\n }\n \n-pub use self::helpers::Conf;\n define_Conf! {\n     /// Lint: CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR. The minimum rust version that the project supports\n-    (msrv, \"msrv\": Option<String>, None),\n+    (msrv: Option<String>),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n-    (blacklisted_names, \"blacklisted_names\": Vec<String>, [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n+    (blacklisted_names: Vec<String> = [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n     /// Lint: COGNITIVE_COMPLEXITY. The maximum cognitive complexity a function can have\n-    (cognitive_complexity_threshold, \"cognitive_complexity_threshold\": u64, 25),\n+    (cognitive_complexity_threshold: u64 = 25),\n     /// DEPRECATED LINT: CYCLOMATIC_COMPLEXITY. Use the Cognitive Complexity lint instead.\n-    (cyclomatic_complexity_threshold, \"cyclomatic_complexity_threshold\": Option<u64>, None),\n+    #[conf_deprecated(\"Please use `cognitive-complexity-threshold` instead.\")]\n+    (cyclomatic_complexity_threshold: Option<u64>),\n     /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n-    (doc_valid_idents, \"doc_valid_idents\": Vec<String>, [\n+    (doc_valid_idents: Vec<String> = [\n         \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n         \"DirectX\",\n         \"ECMAScript\",\n@@ -113,54 +126,47 @@ define_Conf! {\n         \"CamelCase\",\n     ].iter().map(ToString::to_string).collect()),\n     /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n-    (too_many_arguments_threshold, \"too_many_arguments_threshold\": u64, 7),\n+    (too_many_arguments_threshold: u64 = 7),\n     /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n-    (type_complexity_threshold, \"type_complexity_threshold\": u64, 250),\n+    (type_complexity_threshold: u64 = 250),\n     /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n-    (single_char_binding_names_threshold, \"single_char_binding_names_threshold\": u64, 4),\n+    (single_char_binding_names_threshold: u64 = 4),\n     /// Lint: BOXED_LOCAL, USELESS_VEC. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n-    (too_large_for_stack, \"too_large_for_stack\": u64, 200),\n+    (too_large_for_stack: u64 = 200),\n     /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n-    (enum_variant_name_threshold, \"enum_variant_name_threshold\": u64, 3),\n+    (enum_variant_name_threshold: u64 = 3),\n     /// Lint: LARGE_ENUM_VARIANT. The maximum size of a enum's variant to avoid box suggestion\n-    (enum_variant_size_threshold, \"enum_variant_size_threshold\": u64, 200),\n+    (enum_variant_size_threshold: u64 = 200),\n     /// Lint: VERBOSE_BIT_MASK. The maximum allowed size of a bit mask before suggesting to use 'trailing_zeros'\n-    (verbose_bit_mask_threshold, \"verbose_bit_mask_threshold\": u64, 1),\n+    (verbose_bit_mask_threshold: u64 = 1),\n     /// Lint: DECIMAL_LITERAL_REPRESENTATION. The lower bound for linting decimal literals\n-    (literal_representation_threshold, \"literal_representation_threshold\": u64, 16384),\n+    (literal_representation_threshold: u64 = 16384),\n     /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n-    (trivial_copy_size_limit, \"trivial_copy_size_limit\": Option<u64>, None),\n+    (trivial_copy_size_limit: Option<u64>),\n     /// Lint: LARGE_TYPE_PASS_BY_MOVE. The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n-    (pass_by_value_size_limit, \"pass_by_value_size_limit\": u64, 256),\n+    (pass_by_value_size_limit: u64 = 256),\n     /// Lint: TOO_MANY_LINES. The maximum number of lines a function or method can have\n-    (too_many_lines_threshold, \"too_many_lines_threshold\": u64, 100),\n+    (too_many_lines_threshold: u64 = 100),\n     /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS. The maximum allowed size for arrays on the stack\n-    (array_size_threshold, \"array_size_threshold\": u64, 512_000),\n+    (array_size_threshold: u64 = 512_000),\n     /// Lint: VEC_BOX. The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n-    (vec_box_size_threshold, \"vec_box_size_threshold\": u64, 4096),\n+    (vec_box_size_threshold: u64 = 4096),\n     /// Lint: TYPE_REPETITION_IN_BOUNDS. The maximum number of bounds a trait can have to be linted\n-    (max_trait_bounds, \"max_trait_bounds\": u64, 3),\n+    (max_trait_bounds: u64 = 3),\n     /// Lint: STRUCT_EXCESSIVE_BOOLS. The maximum number of bools a struct can have\n-    (max_struct_bools, \"max_struct_bools\": u64, 3),\n+    (max_struct_bools: u64 = 3),\n     /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bools function parameters can have\n-    (max_fn_params_bools, \"max_fn_params_bools\": u64, 3),\n+    (max_fn_params_bools: u64 = 3),\n     /// Lint: WILDCARD_IMPORTS. Whether to allow certain wildcard imports (prelude, super in tests).\n-    (warn_on_all_wildcard_imports, \"warn_on_all_wildcard_imports\": bool, false),\n+    (warn_on_all_wildcard_imports: bool),\n     /// Lint: DISALLOWED_METHOD. The list of disallowed methods, written as fully qualified paths.\n-    (disallowed_methods, \"disallowed_methods\": Vec<String>, Vec::<String>::new()),\n+    (disallowed_methods: Vec<String>),\n     /// Lint: UNREADABLE_LITERAL. Should the fraction of a decimal be linted to include separators.\n-    (unreadable_literal_lint_fractions, \"unreadable_literal_lint_fractions\": bool, true),\n+    (unreadable_literal_lint_fractions: bool = true),\n     /// Lint: UPPER_CASE_ACRONYMS. Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n-    (upper_case_acronyms_aggressive, \"upper_case_acronyms_aggressive\": bool, false),\n+    (upper_case_acronyms_aggressive: bool),\n     /// Lint: _CARGO_COMMON_METADATA. For internal testing only, ignores the current `publish` settings in the Cargo manifest.\n-    (cargo_ignore_publish, \"cargo_ignore_publish\": bool, false),\n-}\n-\n-impl Default for Conf {\n-    #[must_use]\n-    fn default() -> Self {\n-        toml::from_str(\"\").expect(\"we never error on empty config files\")\n-    }\n+    (cargo_ignore_publish: bool),\n }\n \n /// Search for the configuration file.\n@@ -194,43 +200,13 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n     }\n }\n \n-/// Produces a `Conf` filled with the default values and forwards the errors\n-///\n-/// Used internally for convenience\n-fn default(errors: Vec<Error>) -> (Conf, Vec<Error>) {\n-    (Conf::default(), errors)\n-}\n-\n /// Read the `toml` configuration file.\n ///\n /// In case of error, the function tries to continue as much as possible.\n-pub fn read(path: &Path) -> (Conf, Vec<Error>) {\n+pub fn read(path: &Path) -> TryConf {\n     let content = match fs::read_to_string(path) {\n+        Err(e) => return TryConf::from_error(e),\n         Ok(content) => content,\n-        Err(err) => return default(vec![err.into()]),\n     };\n-\n-    assert!(ERRORS.lock().expect(\"no threading -> mutex always safe\").is_empty());\n-    match toml::from_str(&content) {\n-        Ok(toml) => {\n-            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n-\n-            let toml_ref: &Conf = &toml;\n-\n-            let cyc_field: Option<u64> = toml_ref.cyclomatic_complexity_threshold;\n-\n-            if cyc_field.is_some() {\n-                let cyc_err = \"found deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\".to_string();\n-                errors.push(Error::Toml(cyc_err));\n-            }\n-\n-            (toml, errors)\n-        },\n-        Err(e) => {\n-            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n-            errors.push(Error::Toml(e.to_string()));\n-\n-            default(errors)\n-        },\n-    }\n+    toml::from_str(&content).unwrap_or_else(TryConf::from_error)\n }"}, {"sha": "c7bc261de6c5a3f8c10af3ffc10ae0a47df5d579", "filename": "tests/ui-toml/bad_toml_type/conf_bad_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e22e564e4d272c296a6acb8596831fbaa05bc7b/tests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e22e564e4d272c296a6acb8596831fbaa05bc7b/tests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr?ref=1e22e564e4d272c296a6acb8596831fbaa05bc7b", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: invalid type: integer `42`, expected a sequence\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: invalid type: integer `42`, expected a sequence for key `blacklisted-names`\n \n error: aborting due to previous error\n "}, {"sha": "8bf9fe64c6d773c91cc916c84979f333bf5b6a95", "filename": "tests/ui-toml/conf_deprecated_key/conf_deprecated_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e22e564e4d272c296a6acb8596831fbaa05bc7b/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e22e564e4d272c296a6acb8596831fbaa05bc7b/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr?ref=1e22e564e4d272c296a6acb8596831fbaa05bc7b", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: found deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\n \n error: aborting due to previous error\n "}]}