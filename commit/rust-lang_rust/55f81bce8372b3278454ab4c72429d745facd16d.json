{"sha": "55f81bce8372b3278454ab4c72429d745facd16d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZjgxYmNlODM3MmIzMjc4NDU0YWI0YzcyNDI5ZDc0NWZhY2QxNmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-10T02:29:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-10T02:46:23Z"}, "message": "rustc: Fix style of Lint enum", "tree": {"sha": "5e43195d22f760e651559b3945f79492219c3a83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e43195d22f760e651559b3945f79492219c3a83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55f81bce8372b3278454ab4c72429d745facd16d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55f81bce8372b3278454ab4c72429d745facd16d", "html_url": "https://github.com/rust-lang/rust/commit/55f81bce8372b3278454ab4c72429d745facd16d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55f81bce8372b3278454ab4c72429d745facd16d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "520c82e0e971f4107d09ae18670274a278fac382", "url": "https://api.github.com/repos/rust-lang/rust/commits/520c82e0e971f4107d09ae18670274a278fac382", "html_url": "https://github.com/rust-lang/rust/commit/520c82e0e971f4107d09ae18670274a278fac382"}], "stats": {"total": 248, "additions": 124, "deletions": 124}, "files": [{"sha": "d701fed1a521fbde82ac271486efb07f2c907d0b", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=55f81bce8372b3278454ab4c72429d745facd16d", "patch": "@@ -145,7 +145,7 @@ pub struct options {\n     llvm_args: ~[~str],\n     debuginfo: bool,\n     extra_debuginfo: bool,\n-    lint_opts: ~[(lint::lint, lint::level)],\n+    lint_opts: ~[(lint::Lint, lint::level)],\n     save_temps: bool,\n     output_type: back::link::OutputType,\n     // This is mutable for rustpkg, which updates search paths based on the\n@@ -214,7 +214,7 @@ pub struct Session_ {\n     building_library: Cell<bool>,\n     working_dir: Path,\n     lints: RefCell<HashMap<ast::NodeId,\n-                           ~[(lint::lint, codemap::Span, ~str)]>>,\n+                           ~[(lint::Lint, codemap::Span, ~str)]>>,\n     node_id: Cell<ast::NodeId>,\n     outputs: @RefCell<~[OutputStyle]>,\n }\n@@ -268,7 +268,7 @@ impl Session_ {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n-                    lint: lint::lint,\n+                    lint: lint::Lint,\n                     id: ast::NodeId,\n                     sp: Span,\n                     msg: ~str) {\n@@ -443,12 +443,12 @@ pub fn collect_outputs(session: &Session,\n                 Some(n) if \"staticlib\" == n => Some(OutputStaticlib),\n                 Some(n) if \"bin\" == n => Some(OutputExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::unknown_crate_type, ast::CRATE_NODE_ID,\n+                    session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n                                      a.span, ~\"invalid `crate_type` value\");\n                     None\n                 }\n                 _ => {\n-                    session.add_lint(lint::unknown_crate_type, ast::CRATE_NODE_ID,\n+                    session.add_lint(lint::UnknownCrateType, ast::CRATE_NODE_ID,\n                                     a.span, ~\"`crate_type` requires a value\");\n                     None\n                 }"}, {"sha": "c0732e93bee74a38192f8b53aa8c7c6b233f7261", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=55f81bce8372b3278454ab4c72429d745facd16d", "patch": "@@ -233,7 +233,7 @@ pub fn check_crate(sess: Session, crate: &ast::Crate) {\n                                                      directive not necessary\");\n                         }\n                         None => {\n-                            sess.add_lint(lint::unknown_features,\n+                            sess.add_lint(lint::UnknownFeatures,\n                                           ast::CRATE_NODE_ID,\n                                           mi.span,\n                                           ~\"unknown feature\");"}, {"sha": "c4feeabe516a11bfd6a9dda80366b494404a51bd", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=55f81bce8372b3278454ab4c72429d745facd16d", "patch": "@@ -15,7 +15,7 @@\n use middle::ty;\n use middle::typeck;\n use middle::privacy;\n-use middle::lint::dead_code;\n+use middle::lint::DeadCode;\n \n use std::hashmap::HashSet;\n use syntax::ast;\n@@ -328,7 +328,7 @@ impl DeadVisitor {\n \n     fn warn_dead_code(&mut self, id: ast::NodeId,\n                       span: codemap::Span, ident: &ast::Ident) {\n-        self.tcx.sess.add_lint(dead_code, id, span,\n+        self.tcx.sess.add_lint(DeadCode, id, span,\n                                format!(\"code is never used: `{}`\",\n                                        token::ident_to_str(ident)));\n     }"}, {"sha": "91eeb7f2aaf6f38b9fb2a636dd2de5ab9d4a30e1", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=55f81bce8372b3278454ab4c72429d745facd16d", "patch": "@@ -68,43 +68,43 @@ use syntax::ast_util::IdVisitingOperation;\n use syntax::visit::Visitor;\n \n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n-pub enum lint {\n-    ctypes,\n-    unused_imports,\n-    unnecessary_qualification,\n-    while_true,\n-    path_statement,\n-    unrecognized_lint,\n-    non_camel_case_types,\n-    non_uppercase_statics,\n-    non_uppercase_pattern_statics,\n-    type_limits,\n-    type_overflow,\n-    unused_unsafe,\n-    unsafe_block,\n-    attribute_usage,\n-    unknown_features,\n-    unknown_crate_type,\n-\n-    managed_heap_memory,\n-    owned_heap_memory,\n-    heap_memory,\n-\n-    unused_variable,\n-    dead_assignment,\n-    unused_mut,\n-    unnecessary_allocation,\n-    dead_code,\n-    unnecessary_typecast,\n-\n-    missing_doc,\n-    unreachable_code,\n-\n-    deprecated,\n-    experimental,\n-    unstable,\n-\n-    warnings,\n+pub enum Lint {\n+    CTypes,\n+    UnusedImports,\n+    UnnecessaryQualification,\n+    WhileTrue,\n+    PathStatement,\n+    UnrecognizedLint,\n+    NonCamelCaseTypes,\n+    NonUppercaseStatics,\n+    NonUppercasePatternStatics,\n+    TypeLimits,\n+    TypeOverflow,\n+    UnusedUnsafe,\n+    UnsafeBlock,\n+    AttributeUsage,\n+    UnknownFeatures,\n+    UnknownCrateType,\n+\n+    ManagedHeapMemory,\n+    OwnedHeapMemory,\n+    HeapMemory,\n+\n+    UnusedVariable,\n+    DeadAssignment,\n+    UnusedMut,\n+    UnnecessaryAllocation,\n+    DeadCode,\n+    UnnecessaryTypecast,\n+\n+    MissingDoc,\n+    UnreachableCode,\n+\n+    Deprecated,\n+    Experimental,\n+    Unstable,\n+\n+    Warnings,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -124,7 +124,7 @@ pub enum level {\n #[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n pub struct LintSpec {\n     default: level,\n-    lint: lint,\n+    lint: Lint,\n     desc: &'static str,\n }\n \n@@ -140,217 +140,217 @@ enum LintSource {\n static lint_table: &'static [(&'static str, LintSpec)] = &[\n     (\"ctypes\",\n      LintSpec {\n-        lint: ctypes,\n+        lint: CTypes,\n         desc: \"proper use of std::libc types in foreign modules\",\n         default: warn\n      }),\n \n     (\"unused_imports\",\n      LintSpec {\n-        lint: unused_imports,\n+        lint: UnusedImports,\n         desc: \"imports that are never used\",\n         default: warn\n      }),\n \n     (\"unnecessary_qualification\",\n      LintSpec {\n-        lint: unnecessary_qualification,\n+        lint: UnnecessaryQualification,\n         desc: \"detects unnecessarily qualified names\",\n         default: allow\n      }),\n \n     (\"while_true\",\n      LintSpec {\n-        lint: while_true,\n+        lint: WhileTrue,\n         desc: \"suggest using loop { } instead of while(true) { }\",\n         default: warn\n      }),\n \n     (\"path_statement\",\n      LintSpec {\n-        lint: path_statement,\n+        lint: PathStatement,\n         desc: \"path statements with no effect\",\n         default: warn\n      }),\n \n     (\"unrecognized_lint\",\n      LintSpec {\n-        lint: unrecognized_lint,\n+        lint: UnrecognizedLint,\n         desc: \"unrecognized lint attribute\",\n         default: warn\n      }),\n \n     (\"non_camel_case_types\",\n      LintSpec {\n-        lint: non_camel_case_types,\n+        lint: NonCamelCaseTypes,\n         desc: \"types, variants and traits should have camel case names\",\n         default: allow\n      }),\n \n     (\"non_uppercase_statics\",\n      LintSpec {\n-         lint: non_uppercase_statics,\n+         lint: NonUppercaseStatics,\n          desc: \"static constants should have uppercase identifiers\",\n          default: allow\n      }),\n \n     (\"non_uppercase_pattern_statics\",\n      LintSpec {\n-         lint: non_uppercase_pattern_statics,\n+         lint: NonUppercasePatternStatics,\n          desc: \"static constants in match patterns should be all caps\",\n          default: warn\n      }),\n \n     (\"managed_heap_memory\",\n      LintSpec {\n-        lint: managed_heap_memory,\n+        lint: ManagedHeapMemory,\n         desc: \"use of managed (@ type) heap memory\",\n         default: allow\n      }),\n \n     (\"owned_heap_memory\",\n      LintSpec {\n-        lint: owned_heap_memory,\n+        lint: OwnedHeapMemory,\n         desc: \"use of owned (~ type) heap memory\",\n         default: allow\n      }),\n \n     (\"heap_memory\",\n      LintSpec {\n-        lint: heap_memory,\n+        lint: HeapMemory,\n         desc: \"use of any (~ type or @ type) heap memory\",\n         default: allow\n      }),\n \n     (\"type_limits\",\n      LintSpec {\n-        lint: type_limits,\n+        lint: TypeLimits,\n         desc: \"comparisons made useless by limits of the types involved\",\n         default: warn\n      }),\n \n     (\"type_overflow\",\n      LintSpec {\n-        lint: type_overflow,\n+        lint: TypeOverflow,\n         desc: \"literal out of range for its type\",\n         default: warn\n      }),\n \n \n     (\"unused_unsafe\",\n      LintSpec {\n-        lint: unused_unsafe,\n+        lint: UnusedUnsafe,\n         desc: \"unnecessary use of an `unsafe` block\",\n         default: warn\n     }),\n \n     (\"unsafe_block\",\n      LintSpec {\n-        lint: unsafe_block,\n+        lint: UnsafeBlock,\n         desc: \"usage of an `unsafe` block\",\n         default: allow\n     }),\n \n     (\"attribute_usage\",\n      LintSpec {\n-        lint: attribute_usage,\n+        lint: AttributeUsage,\n         desc: \"detects bad use of attributes\",\n         default: warn\n     }),\n \n     (\"unused_variable\",\n      LintSpec {\n-        lint: unused_variable,\n+        lint: UnusedVariable,\n         desc: \"detect variables which are not used in any way\",\n         default: warn\n     }),\n \n     (\"dead_assignment\",\n      LintSpec {\n-        lint: dead_assignment,\n+        lint: DeadAssignment,\n         desc: \"detect assignments that will never be read\",\n         default: warn\n     }),\n \n     (\"unnecessary_typecast\",\n      LintSpec {\n-        lint: unnecessary_typecast,\n+        lint: UnnecessaryTypecast,\n         desc: \"detects unnecessary type casts, that can be removed\",\n         default: allow,\n     }),\n \n     (\"unused_mut\",\n      LintSpec {\n-        lint: unused_mut,\n+        lint: UnusedMut,\n         desc: \"detect mut variables which don't need to be mutable\",\n         default: warn\n     }),\n \n     (\"unnecessary_allocation\",\n      LintSpec {\n-        lint: unnecessary_allocation,\n+        lint: UnnecessaryAllocation,\n         desc: \"detects unnecessary allocations that can be eliminated\",\n         default: warn\n     }),\n \n     (\"dead_code\",\n      LintSpec {\n-        lint: dead_code,\n+        lint: DeadCode,\n         desc: \"detect piece of code that will never be used\",\n         default: warn\n     }),\n \n     (\"missing_doc\",\n      LintSpec {\n-        lint: missing_doc,\n+        lint: MissingDoc,\n         desc: \"detects missing documentation for public members\",\n         default: allow\n     }),\n \n     (\"unreachable_code\",\n      LintSpec {\n-        lint: unreachable_code,\n+        lint: UnreachableCode,\n         desc: \"detects unreachable code\",\n         default: warn\n     }),\n \n     (\"deprecated\",\n      LintSpec {\n-        lint: deprecated,\n+        lint: Deprecated,\n         desc: \"detects use of #[deprecated] items\",\n         default: warn\n     }),\n \n     (\"experimental\",\n      LintSpec {\n-        lint: experimental,\n+        lint: Experimental,\n         desc: \"detects use of #[experimental] items\",\n         default: warn\n     }),\n \n     (\"unstable\",\n      LintSpec {\n-        lint: unstable,\n+        lint: Unstable,\n         desc: \"detects use of #[unstable] items (incl. items with no stability attribute)\",\n         default: allow\n     }),\n \n     (\"warnings\",\n      LintSpec {\n-        lint: warnings,\n+        lint: Warnings,\n         desc: \"mass-change the level for lints which produce warnings\",\n         default: warn\n     }),\n \n     (\"unknown_features\",\n      LintSpec {\n-        lint: unknown_features,\n+        lint: UnknownFeatures,\n         desc: \"unknown features found in crate-level #[feature] directives\",\n         default: deny,\n     }),\n      (\"unknown_crate_type\",\n      LintSpec {\n-         lint: unknown_crate_type,\n+         lint: UnknownCrateType,\n          desc: \"unknown crate type found in #[crate_type] directive\",\n          default: deny,\n      }),\n@@ -389,36 +389,36 @@ struct Context<'a> {\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n-    lint_stack: ~[(lint, level, LintSource)],\n+    lint_stack: ~[(Lint, level, LintSource)],\n \n     // id of the last visited negated expression\n     negated_expr_id: ast::NodeId\n }\n \n impl<'a> Context<'a> {\n-    fn get_level(&self, lint: lint) -> level {\n+    fn get_level(&self, lint: Lint) -> level {\n         match self.cur.find(&(lint as uint)) {\n           Some(&(lvl, _)) => lvl,\n           None => allow\n         }\n     }\n \n-    fn get_source(&self, lint: lint) -> LintSource {\n+    fn get_source(&self, lint: Lint) -> LintSource {\n         match self.cur.find(&(lint as uint)) {\n           Some(&(_, src)) => src,\n           None => Default\n         }\n     }\n \n-    fn set_level(&mut self, lint: lint, level: level, src: LintSource) {\n+    fn set_level(&mut self, lint: Lint, level: level, src: LintSource) {\n         if level == allow {\n             self.cur.remove(&(lint as uint));\n         } else {\n             self.cur.insert(lint as uint, (level, src));\n         }\n     }\n \n-    fn lint_to_str(&self, lint: lint) -> &'static str {\n+    fn lint_to_str(&self, lint: Lint) -> &'static str {\n         for (k, v) in self.dict.iter() {\n             if v.lint == lint {\n                 return *k;\n@@ -427,10 +427,10 @@ impl<'a> Context<'a> {\n         fail!(\"unregistered lint {:?}\", lint);\n     }\n \n-    fn span_lint(&self, lint: lint, span: Span, msg: &str) {\n+    fn span_lint(&self, lint: Lint, span: Span, msg: &str) {\n         let (level, src) = match self.cur.find(&(lint as uint)) {\n             None => { return }\n-            Some(&(warn, src)) => (self.get_level(warnings), src),\n+            Some(&(warn, src)) => (self.get_level(Warnings), src),\n             Some(&pair) => pair,\n         };\n         if level == allow { return }\n@@ -481,7 +481,7 @@ impl<'a> Context<'a> {\n             match self.dict.find_equiv(&lintname) {\n                 None => {\n                     self.span_lint(\n-                        unrecognized_lint,\n+                        UnrecognizedLint,\n                         meta.span,\n                         format!(\"unknown `{}` attribute: `{}`\",\n                         level_to_str(level), lintname));\n@@ -571,7 +571,7 @@ fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n                 ast::ExprLit(@codemap::Spanned {\n                     node: ast::LitBool(true), ..}) =>\n                 {\n-                    cx.span_lint(while_true, e.span,\n+                    cx.span_lint(WhileTrue, e.span,\n                                  \"denote infinite loops with loop { ... }\");\n                 }\n                 _ => ()\n@@ -604,7 +604,7 @@ fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n             let infcx: @infer::InferCtxt = infer::new_infer_ctxt(cx.tcx);\n             let t_t = ast_ty_to_ty(cx, &infcx, ty);\n             if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n-                cx.span_lint(unnecessary_typecast, ty.span,\n+                cx.span_lint(UnnecessaryTypecast, ty.span,\n                              \"unnecessary type cast\");\n             }\n         }\n@@ -616,7 +616,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n     return match e.node {\n         ast::ExprBinary(_, binop, l, r) => {\n             if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n-                cx.span_lint(type_limits, e.span,\n+                cx.span_lint(TypeLimits, e.span,\n                              \"comparison is useless due to type limits\");\n             }\n         },\n@@ -637,7 +637,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                         lit_val *= -1;\n                     }\n                     if  lit_val < min || lit_val > max {\n-                        cx.span_lint(type_overflow, e.span,\n+                        cx.span_lint(TypeOverflow, e.span,\n                                      \"literal out of range for its type\");\n                     }\n                 },\n@@ -653,7 +653,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                         _ => fail!()\n                     };\n                     if  lit_val < min || lit_val > max {\n-                        cx.span_lint(type_overflow, e.span,\n+                        cx.span_lint(TypeOverflow, e.span,\n                                      \"literal out of range for its type\");\n                     }\n                 },\n@@ -765,18 +765,18 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n                 let def_map = cx.tcx.def_map.borrow();\n                 match def_map.get().get_copy(&id) {\n                     ast::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                        cx.span_lint(ctypes, ty.span,\n+                        cx.span_lint(CTypes, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n                                 libc::c_int or libc::c_long should be used\");\n                     }\n                     ast::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                        cx.span_lint(ctypes, ty.span,\n+                        cx.span_lint(CTypes, ty.span,\n                                 \"found rust type `uint` in foreign module, while \\\n                                 libc::c_uint or libc::c_ulong should be used\");\n                     }\n                     ast::DefTy(def_id) => {\n                         if !adt::is_ffi_safe(cx.tcx, def_id) {\n-                            cx.span_lint(ctypes, ty.span,\n+                            cx.span_lint(CTypes, ty.span,\n                                          \"found enum type without foreign-function-safe \\\n                                           representation annotation in foreign module\");\n                             // hmm... this message could be more helpful\n@@ -811,7 +811,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n }\n \n fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n-    let xs = [managed_heap_memory, owned_heap_memory, heap_memory];\n+    let xs = [ManagedHeapMemory, OwnedHeapMemory, HeapMemory];\n     for &lint in xs.iter() {\n         if cx.get_level(lint) == allow { continue }\n \n@@ -838,13 +838,13 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n             t\n         });\n \n-        if n_uniq > 0 && lint != managed_heap_memory {\n+        if n_uniq > 0 && lint != ManagedHeapMemory {\n             let s = ty_to_str(cx.tcx, ty);\n             let m = format!(\"type uses owned (~ type) pointers: {}\", s);\n             cx.span_lint(lint, span, m);\n         }\n \n-        if n_box > 0 && lint != owned_heap_memory {\n+        if n_box > 0 && lint != OwnedHeapMemory {\n             let s = ty_to_str(cx.tcx, ty);\n             let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n             cx.span_lint(lint, span, m);\n@@ -918,7 +918,7 @@ fn check_crate_attrs_usage(cx: &Context, attrs: &[ast::Attribute]) {\n         let name = attr.node.value.name();\n         let mut iter = crate_attrs.iter().chain(other_attrs.iter());\n         if !iter.any(|other_attr| { name.equiv(other_attr) }) {\n-            cx.span_lint(attribute_usage, attr.span, \"unknown crate attribute\");\n+            cx.span_lint(AttributeUsage, attr.span, \"unknown crate attribute\");\n         }\n         if name.equiv(& &\"link\") {\n             cx.tcx.sess.span_err(attr.span,\n@@ -941,21 +941,21 @@ fn check_attrs_usage(cx: &Context, attrs: &[ast::Attribute]) {\n                                        add semicolon at end\",\n                     ast::AttrInner => \"crate-level attribute should be in the root module\",\n                 };\n-                cx.span_lint(attribute_usage, attr.span, msg);\n+                cx.span_lint(AttributeUsage, attr.span, msg);\n                 return;\n             }\n         }\n \n         for &(obs_attr, obs_alter) in obsolete_attrs.iter() {\n             if name.equiv(&obs_attr) {\n-                cx.span_lint(attribute_usage, attr.span,\n+                cx.span_lint(AttributeUsage, attr.span,\n                              format!(\"obsolete attribute: {:s}\", obs_alter));\n                 return;\n             }\n         }\n \n         if !other_attrs.iter().any(|other_attr| { name.equiv(other_attr) }) {\n-            cx.span_lint(attribute_usage, attr.span, \"unknown attribute\");\n+            cx.span_lint(AttributeUsage, attr.span, \"unknown attribute\");\n         }\n     }\n }\n@@ -968,7 +968,7 @@ fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n     match s.node {\n         ast::StmtSemi(@ast::Expr { node: ast::ExprPath(_), .. }, _) => {\n-            cx.span_lint(path_statement, s.span,\n+            cx.span_lint(PathStatement, s.span,\n                          \"path statement with no effect\");\n         }\n         _ => ()\n@@ -990,7 +990,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n     fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(\n-                non_camel_case_types, span,\n+                NonCamelCaseTypes, span,\n                 format!(\"{} `{}` should have a camel case identifier\",\n                     sort, cx.tcx.sess.str_of(ident)));\n         }\n@@ -1022,7 +1022,7 @@ fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n             // ones (some scripts don't have a concept of\n             // upper/lowercase)\n             if s.chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(non_uppercase_statics, it.span,\n+                cx.span_lint(NonUppercaseStatics, it.span,\n                              \"static constant should have an uppercase identifier\");\n             }\n         }\n@@ -1039,7 +1039,7 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n             let ident = path.segments.last().identifier;\n             let s = cx.tcx.sess.str_of(ident);\n             if s.chars().any(|c| c.is_lowercase()) {\n-                cx.span_lint(non_uppercase_pattern_statics, path.span,\n+                cx.span_lint(NonUppercasePatternStatics, path.span,\n                              \"static constant in pattern should be all caps\");\n             }\n         }\n@@ -1054,7 +1054,7 @@ fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n             let used_unsafe = cx.tcx.used_unsafe.borrow();\n             if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n                 !used_unsafe.get().contains(&blk.id) {\n-                cx.span_lint(unused_unsafe, blk.span,\n+                cx.span_lint(UnusedUnsafe, blk.span,\n                              \"unnecessary `unsafe` block\");\n             }\n         }\n@@ -1066,7 +1066,7 @@ fn check_unsafe_block(cx: &Context, e: &ast::Expr) {\n     match e.node {\n         // Don't warn about generated blocks, that'll just pollute the output.\n         ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-            cx.span_lint(unsafe_block, blk.span, \"usage of an `unsafe` block\");\n+            cx.span_lint(UnsafeBlock, blk.span, \"usage of an `unsafe` block\");\n         }\n         _ => ()\n     }\n@@ -1090,7 +1090,7 @@ fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n \n             let used_mut_nodes = cx.tcx.used_mut_nodes.borrow();\n             if !initial_underscore && !used_mut_nodes.get().contains(&p.id) {\n-                cx.span_lint(unused_mut, p.span,\n+                cx.span_lint(UnusedMut, p.span,\n                              \"variable does not need to be mutable\");\n             }\n         }\n@@ -1122,7 +1122,7 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n     };\n \n     let report = |msg| {\n-        cx.span_lint(unnecessary_allocation, e.span, msg);\n+        cx.span_lint(UnnecessaryAllocation, e.span, msg);\n     };\n \n     let adjustment = {\n@@ -1175,7 +1175,7 @@ fn check_missing_doc_attrs(cx: &Context,\n         }\n     });\n     if !has_doc {\n-        cx.span_lint(missing_doc, sp,\n+        cx.span_lint(MissingDoc, sp,\n                      format!(\"missing documentation for {}\", desc));\n     }\n }\n@@ -1322,13 +1322,13 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n     let (lint, label) = match stability {\n         // no stability attributes == Unstable\n-        None => (unstable, \"unmarked\"),\n+        None => (Unstable, \"unmarked\"),\n         Some(attr::Stability { level: attr::Unstable, .. }) =>\n-                (unstable, \"unstable\"),\n+                (Unstable, \"unstable\"),\n         Some(attr::Stability { level: attr::Experimental, .. }) =>\n-                (experimental, \"experimental\"),\n+                (Experimental, \"experimental\"),\n         Some(attr::Stability { level: attr::Deprecated, .. }) =>\n-                (deprecated, \"deprecated\"),\n+                (Deprecated, \"deprecated\"),\n         _ => return\n     };\n "}, {"sha": "ead2ee83d8150cd70c4459bcf6dd2b41f7a5b34c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=55f81bce8372b3278454ab4c72429d745facd16d", "patch": "@@ -103,7 +103,7 @@\n  */\n \n \n-use middle::lint::{unused_variable, dead_assignment};\n+use middle::lint::{UnusedVariable, DeadAssignment};\n use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n@@ -1705,11 +1705,11 @@ impl Liveness {\n                 };\n \n                 if is_assigned {\n-                    self.tcx.sess.add_lint(unused_variable, id, sp,\n+                    self.tcx.sess.add_lint(UnusedVariable, id, sp,\n                         format!(\"variable `{}` is assigned to, \\\n                                   but never used\", *name));\n                 } else {\n-                    self.tcx.sess.add_lint(unused_variable, id, sp,\n+                    self.tcx.sess.add_lint(UnusedVariable, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1727,7 +1727,7 @@ impl Liveness {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.tcx.sess.add_lint(dead_assignment, id, sp,\n+                self.tcx.sess.add_lint(DeadAssignment, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}, {"sha": "8731bf07ec3d2ce5f2b27d8f1f4ae00cdd86db78", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=55f81bce8372b3278454ab4c72429d745facd16d", "patch": "@@ -13,7 +13,7 @@ use driver::session::Session;\n use metadata::csearch;\n use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::lang_items::LanguageItems;\n-use middle::lint::{unnecessary_qualification, unused_imports};\n+use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n \n use syntax::ast::*;\n@@ -4735,7 +4735,7 @@ impl Resolver {\n             let def = self.resolve_module_relative_path(path, namespace);\n             match (def, unqualified_def) {\n                 (Some((d, _)), Some((ud, _))) if d == ud => {\n-                    self.session.add_lint(unnecessary_qualification,\n+                    self.session.add_lint(UnnecessaryQualification,\n                                           id,\n                                           path.span,\n                                           ~\"unnecessary qualification\");\n@@ -5557,7 +5557,7 @@ impl Resolver {\n                     match p.node {\n                         ViewPathSimple(_, _, id) | ViewPathGlob(_, id) => {\n                             if !self.used_imports.contains(&id) {\n-                                self.session.add_lint(unused_imports,\n+                                self.session.add_lint(UnusedImports,\n                                                       id, p.span,\n                                                       ~\"unused import\");\n                             }\n@@ -5566,7 +5566,7 @@ impl Resolver {\n                         ViewPathList(_, ref list, _) => {\n                             for i in list.iter() {\n                                 if !self.used_imports.contains(&i.node.id) {\n-                                    self.session.add_lint(unused_imports,\n+                                    self.session.add_lint(UnusedImports,\n                                                           i.node.id, i.span,\n                                                           ~\"unused import\");\n                                 }"}, {"sha": "f5bbcea431e51c6a6020fbd897428af99eb61fd4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f81bce8372b3278454ab4c72429d745facd16d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=55f81bce8372b3278454ab4c72429d745facd16d", "patch": "@@ -80,7 +80,7 @@ type parameter).\n use middle::const_eval;\n use middle::lang_items::{ExchangeHeapLangItem, GcLangItem};\n use middle::lang_items::{ManagedHeapLangItem};\n-use middle::lint::unreachable_code;\n+use middle::lint::UnreachableCode;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::subst::Subst;\n@@ -3491,7 +3491,7 @@ pub fn check_block_with_expected(fcx: @FnCtxt,\n                   }\n                   _ => false\n                 } {\n-                fcx.ccx.tcx.sess.add_lint(unreachable_code, s_id, s.span,\n+                fcx.ccx.tcx.sess.add_lint(UnreachableCode, s_id, s.span,\n                                           ~\"unreachable statement\");\n                 warned = true;\n             }\n@@ -3513,7 +3513,7 @@ pub fn check_block_with_expected(fcx: @FnCtxt,\n             },\n           Some(e) => {\n             if any_bot && !warned {\n-                fcx.ccx.tcx.sess.add_lint(unreachable_code, e.id, e.span,\n+                fcx.ccx.tcx.sess.add_lint(UnreachableCode, e.id, e.span,\n                                           ~\"unreachable expression\");\n             }\n             check_expr_with_opt_hint(fcx, e, expected);"}]}