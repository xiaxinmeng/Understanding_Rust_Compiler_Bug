{"sha": "4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNzA2ZjU2YmQzYmViMDgzM2Q5ZTA1YjBkYWJkYzNjM2NlNzUwZTQ=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-08-27T02:50:57Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-09-06T23:58:22Z"}, "message": "[nll] teach SCC about `'static`\n\nFixes #53178", "tree": {"sha": "e784b157a2104fc1249faf28c0feb49686057d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e784b157a2104fc1249faf28c0feb49686057d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "html_url": "https://github.com/rust-lang/rust/commit/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db01b6789db9b4f89209ea6e28781dfd66eebbcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/db01b6789db9b4f89209ea6e28781dfd66eebbcb", "html_url": "https://github.com/rust-lang/rust/commit/db01b6789db9b4f89209ea6e28781dfd66eebbcb"}], "stats": {"total": 84, "additions": 71, "deletions": 13}, "files": [{"sha": "b1e8b974379d61c0335e186b785da76f82cc37f0", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph;\n@@ -31,6 +32,7 @@ crate type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n crate trait ConstraintGraphDirecton: Copy + 'static {\n     fn start_region(c: &OutlivesConstraint) -> RegionVid;\n     fn end_region(c: &OutlivesConstraint) -> RegionVid;\n+    fn is_normal() -> bool;\n }\n \n /// In normal mode, a `R1: R2` constraint results in an edge `R1 ->\n@@ -48,6 +50,10 @@ impl ConstraintGraphDirecton for Normal {\n     fn end_region(c: &OutlivesConstraint) -> RegionVid {\n         c.sub\n     }\n+\n+    fn is_normal() -> bool {\n+        true\n+    }\n }\n \n /// In reverse mode, a `R1: R2` constraint results in an edge `R2 ->\n@@ -65,6 +71,10 @@ impl ConstraintGraphDirecton for Reverse {\n     fn end_region(c: &OutlivesConstraint) -> RegionVid {\n         c.sup\n     }\n+\n+    fn is_normal() -> bool {\n+        false\n+    }\n }\n \n impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n@@ -98,21 +108,41 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// Given the constraint set from which this graph was built\n     /// creates a region graph so that you can iterate over *regions*\n     /// and not constraints.\n-    crate fn region_graph<'rg>(&'rg self, set: &'rg ConstraintSet) -> RegionGraph<'rg, D> {\n-        RegionGraph::new(set, self)\n+    crate fn region_graph<'rg>(\n+        &'rg self,\n+        set: &'rg ConstraintSet,\n+        static_region: RegionVid,\n+    ) -> RegionGraph<'rg, D> {\n+        RegionGraph::new(set, self, static_region)\n     }\n \n     /// Given a region `R`, iterate over all constraints `R: R1`.\n     crate fn outgoing_edges<'a>(\n         &'a self,\n         region_sup: RegionVid,\n         constraints: &'a ConstraintSet,\n+        static_region: RegionVid,\n     ) -> Edges<'a, D> {\n-        let first = self.first_constraints[region_sup];\n-        Edges {\n-            graph: self,\n-            constraints,\n-            pointer: first,\n+        //if this is the `'static` region and the graph's direction is normal,\n+        //then setup the Edges iterator to return all regions #53178\n+        if region_sup == static_region && D::is_normal() {\n+            Edges {\n+                graph: self,\n+                constraints,\n+                pointer: None,\n+                next_static_idx: Some(0),\n+                static_region,\n+            }\n+        } else {\n+            //otherwise, just setup the iterator as normal\n+            let first = self.first_constraints[region_sup];\n+            Edges {\n+                graph: self,\n+                constraints,\n+                pointer: first,\n+                next_static_idx: None,\n+                static_region,\n+           }\n         }\n     }\n }\n@@ -121,6 +151,8 @@ crate struct Edges<'s, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n     constraints: &'s ConstraintSet,\n     pointer: Option<ConstraintIndex>,\n+    next_static_idx: Option<usize>,\n+    static_region: RegionVid,\n }\n \n impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n@@ -129,7 +161,21 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(p) = self.pointer {\n             self.pointer = self.graph.next_constraints[p];\n+\n             Some(self.constraints[p])\n+        } else if let Some(next_static_idx) = self.next_static_idx {\n+            self.next_static_idx =\n+                if next_static_idx == (self.graph.first_constraints.len() - 1) {\n+                    None\n+                } else {\n+                    Some(next_static_idx + 1)\n+                };\n+\n+            Some(OutlivesConstraint {\n+                sup: self.static_region,\n+                sub: next_static_idx.into(),\n+                locations: Locations::All,\n+            })\n         } else {\n             None\n         }\n@@ -142,25 +188,31 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n     set: &'s ConstraintSet,\n     constraint_graph: &'s ConstraintGraph<D>,\n+    static_region: RegionVid,\n }\n \n impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n     /// Create a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(set: &'s ConstraintSet, constraint_graph: &'s ConstraintGraph<D>) -> Self {\n+    crate fn new(\n+        set: &'s ConstraintSet,\n+        constraint_graph: &'s ConstraintGraph<D>,\n+        static_region: RegionVid,\n+    ) -> Self {\n         Self {\n             set,\n             constraint_graph,\n+            static_region,\n         }\n     }\n \n     /// Given a region `R`, iterate over all regions `R1` such that\n     /// there exists a constraint `R: R1`.\n     crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, D> {\n         Successors {\n-            edges: self.constraint_graph.outgoing_edges(region_sup, self.set),\n+            edges: self.constraint_graph.outgoing_edges(region_sup, self.set, self.static_region),\n         }\n     }\n }"}, {"sha": "9a8b0f391de9d1339d512a84239c0039964f355a", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "patch": "@@ -58,8 +58,9 @@ impl ConstraintSet {\n     crate fn compute_sccs(\n         &self,\n         constraint_graph: &graph::NormalConstraintGraph,\n+        static_region: RegionVid,\n     ) -> Sccs<RegionVid, ConstraintSccIndex> {\n-        let region_graph = &constraint_graph.region_graph(self);\n+        let region_graph = &constraint_graph.region_graph(self, static_region);\n         Sccs::new(region_graph)\n     }\n }"}, {"sha": "0b9b9b33b3f154577bda5fa1edff3c0998b1899a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "patch": "@@ -201,7 +201,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Otherwise, walk over the outgoing constraints and\n             // enqueue any regions we find, keeping track of how we\n             // reached them.\n-            for constraint in self.constraint_graph.outgoing_edges(r, &self.constraints) {\n+            let fr_static = self.universal_regions.fr_static;\n+            for constraint in self.constraint_graph.outgoing_edges(r,\n+                                                                   &self.constraints,\n+                                                                   fr_static) {\n                 assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {"}, {"sha": "bbdf2a929221093d88f37b7f083a4f5f5807901a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "patch": "@@ -234,7 +234,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let constraints = Rc::new(outlives_constraints); // freeze constraints\n         let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n-        let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph));\n+        let fr_static = universal_regions.fr_static;\n+        let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph, fr_static));\n \n         let mut scc_values = RegionValues::new(elements, universal_regions.len(), max_universe);\n "}, {"sha": "357e9ee72102a6d59400a32847cfac8f616f440a", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=4e706f56bd3beb0833d9e05b0dabdc3c3ce750e4", "patch": "@@ -69,7 +69,8 @@ fn regions_that_outlive_free_regions(\n     // reachable from each free region, we will have all the\n     // regions that are forced to outlive some free region.\n     let rev_constraint_graph = constraint_set.reverse_graph(num_region_vars);\n-    let rev_region_graph = rev_constraint_graph.region_graph(constraint_set);\n+    let fr_static = universal_regions.fr_static;\n+    let rev_region_graph = rev_constraint_graph.region_graph(constraint_set, fr_static);\n \n     // Stack for the depth-first search. Start out with all the free regions.\n     let mut stack: Vec<_> = universal_regions.universal_regions().collect();"}]}