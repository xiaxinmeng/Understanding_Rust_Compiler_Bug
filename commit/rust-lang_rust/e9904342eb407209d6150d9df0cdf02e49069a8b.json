{"sha": "e9904342eb407209d6150d9df0cdf02e49069a8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5OTA0MzQyZWI0MDcyMDlkNjE1MGQ5ZGYwY2RmMDJlNDkwNjlhOGI=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-05T22:34:59Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-05T22:34:59Z"}, "message": "Add fast futex-based thread parker for Windows.", "tree": {"sha": "e41e0aed0908bda9d810493f7e465c8cfb2afc5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e41e0aed0908bda9d810493f7e465c8cfb2afc5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9904342eb407209d6150d9df0cdf02e49069a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9904342eb407209d6150d9df0cdf02e49069a8b", "html_url": "https://github.com/rust-lang/rust/commit/e9904342eb407209d6150d9df0cdf02e49069a8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9904342eb407209d6150d9df0cdf02e49069a8b/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bfde778a419e0bd34c708ebe0c7eebab42f8637", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfde778a419e0bd34c708ebe0c7eebab42f8637", "html_url": "https://github.com/rust-lang/rust/commit/7bfde778a419e0bd34c708ebe0c7eebab42f8637"}], "stats": {"total": 181, "additions": 181, "deletions": 0}, "files": [{"sha": "1aece8632868cd7f30b189d922bf28db7b8fc6cd", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9904342eb407209d6150d9df0cdf02e49069a8b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9904342eb407209d6150d9df0cdf02e49069a8b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=e9904342eb407209d6150d9df0cdf02e49069a8b", "patch": "@@ -36,6 +36,7 @@ pub mod rwlock;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod time;\n cfg_if::cfg_if! {\n     if #[cfg(not(target_vendor = \"uwp\"))] {"}, {"sha": "68a060ba32d0a798139686f8fb8229c26546b786", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/e9904342eb407209d6150d9df0cdf02e49069a8b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9904342eb407209d6150d9df0cdf02e49069a8b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=e9904342eb407209d6150d9df0cdf02e49069a8b", "patch": "@@ -0,0 +1,178 @@\n+use crate::convert::TryFrom;\n+use crate::ptr;\n+use crate::sync::atomic::{\n+    AtomicI8, AtomicUsize,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::{c, dur2timeout};\n+use crate::time::Duration;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+}\n+\n+const PARKED: i8 = -1;\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+\n+// Notes about memory ordering:\n+//\n+// Memory ordering is only relevant for the relative ordering of operations\n+// between different variables. Even Ordering::Relaxed guarantees a\n+// monotonic/consistent order when looking at just a single atomic variable.\n+//\n+// So, since this parker is just a single atomic variable, we only need to look\n+// at the ordering guarantees we need to provide to the 'outside world'.\n+//\n+// The only memory ordering guarantee that parking and unparking provide, is\n+// that things which happened before unpark() are visible on the thread\n+// returning from park() afterwards. Otherwise, it was effectively unparked\n+// before unpark() was called while still consuming the 'token'.\n+//\n+// In other words, unpark() needs to synchronize with the part of park() that\n+// consumes the token and returns.\n+//\n+// This is done with a release-acquire synchronization, by using\n+// Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n+// Ordering::Acquire when checking for this state in park().\n+impl Parker {\n+    pub fn new() -> Self {\n+        Self { state: AtomicI8::new(EMPTY) }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park(&self) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        loop {\n+            // Wait for something to happen.\n+            if c::WaitOnAddress::is_available() {\n+                c::WaitOnAddress(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, c::INFINITE);\n+            } else {\n+                c::NtWaitForKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n+            }\n+            // Change NOTIFIED=>EMPTY and return in that case.\n+            if self.state.compare_and_swap(NOTIFIED, EMPTY, Acquire) == NOTIFIED {\n+                return;\n+            } else {\n+                // Spurious wake up. We loop to try again.\n+            }\n+        }\n+    }\n+\n+    // Assumes this is only called by the thread that owns the Parker,\n+    // which means that `self.state != PARKED`.\n+    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+        // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n+        // first case.\n+        if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n+            return;\n+        }\n+\n+        if c::WaitOnAddress::is_available() {\n+            // Wait for something to happen, assuming it's still set to PARKED.\n+            c::WaitOnAddress(self.ptr(), &PARKED as *const _ as c::LPVOID, 1, dur2timeout(timeout));\n+            // Change NOTIFIED=>EMPTY and return in that case.\n+            if self.state.swap(EMPTY, Acquire) == NOTIFIED {\n+                return;\n+            } else {\n+                // Timeout or spurious wake up.\n+                // We return either way, because we can't easily tell if it was the\n+                // timeout or not.\n+            }\n+        } else {\n+            // Need to wait for unpark() using NtWaitForKeyedEvent.\n+            let handle = keyed_event_handle();\n+\n+            // NtWaitForKeyedEvent uses a unit of 100ns, and uses negative values\n+            // to indicate the monotonic clock.\n+            let mut timeout = match i64::try_from((timeout.as_nanos() + 99) / 100) {\n+                Ok(t) => -t,\n+                Err(_) => i64::MIN,\n+            };\n+\n+            // Wait for unpark() to produce this event.\n+            if c::NtWaitForKeyedEvent(handle, self.ptr(), 0, &mut timeout) == c::STATUS_SUCCESS {\n+                // Awoken by another thread.\n+                self.state.swap(EMPTY, Acquire);\n+            } else {\n+                // Not awoken by another thread (spurious or timeout).\n+                if self.state.swap(EMPTY, Acquire) == NOTIFIED {\n+                    // If the state is NOTIFIED, we *just* missed an unpark(),\n+                    // which is now waiting for us to wait for it.\n+                    // Wait for it to consume the event and unblock it.\n+                    c::NtWaitForKeyedEvent(handle, self.ptr(), 0, ptr::null_mut());\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn unpark(&self) {\n+        // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n+        // wake the thread in the first case.\n+        //\n+        // Note that even NOTIFIED=>NOTIFIED results in a write. This is on\n+        // purpose, to make sure every unpark() has a release-acquire ordering\n+        // with park().\n+        if self.state.swap(NOTIFIED, Release) == PARKED {\n+            if c::WakeByAddressSingle::is_available() {\n+                unsafe {\n+                    c::WakeByAddressSingle(self.ptr());\n+                }\n+            } else {\n+                // If we run NtReleaseKeyedEvent before the waiting thread runs\n+                // NtWaitForKeyedEvent, this (shortly) blocks until we can wake it up.\n+                // If the waiting thread wakes up before we run NtReleaseKeyedEvent\n+                // (e.g. due to a timeout), this blocks until we do wake up a thread.\n+                // To prevent this thread from blocking indefinitely in that case,\n+                // park_impl() will, after seeing the state set to NOTIFIED after\n+                // waking up, call NtWaitForKeyedEvent again to unblock us.\n+                unsafe {\n+                    c::NtReleaseKeyedEvent(keyed_event_handle(), self.ptr(), 0, ptr::null_mut());\n+                }\n+            }\n+        }\n+    }\n+\n+    fn ptr(&self) -> c::LPVOID {\n+        &self.state as *const _ as c::LPVOID\n+    }\n+}\n+\n+fn keyed_event_handle() -> c::HANDLE {\n+    const INVALID: usize = !0;\n+    static HANDLE: AtomicUsize = AtomicUsize::new(INVALID);\n+    match HANDLE.load(Relaxed) {\n+        INVALID => {\n+            let mut handle = c::INVALID_HANDLE_VALUE;\n+            unsafe {\n+                match c::NtCreateKeyedEvent(\n+                    &mut handle,\n+                    c::GENERIC_READ | c::GENERIC_WRITE,\n+                    ptr::null_mut(),\n+                    0,\n+                ) {\n+                    c::STATUS_SUCCESS => {}\n+                    r => panic!(\"Unable to create keyed event handle: error {}\", r),\n+                }\n+            }\n+            match HANDLE.compare_exchange(INVALID, handle as usize, Relaxed, Relaxed) {\n+                Ok(_) => handle,\n+                Err(h) => {\n+                    // Lost the race to another thread initializing HANDLE before we did.\n+                    // Closing our handle and using theirs instead.\n+                    unsafe {\n+                        c::CloseHandle(handle);\n+                    }\n+                    h as c::HANDLE\n+                }\n+            }\n+        }\n+        handle => handle as c::HANDLE,\n+    }\n+}"}, {"sha": "92b17ef44309e299955bdc84d767ea15fe9434bf", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9904342eb407209d6150d9df0cdf02e49069a8b/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9904342eb407209d6150d9df0cdf02e49069a8b/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=e9904342eb407209d6150d9df0cdf02e49069a8b", "patch": "@@ -2,6 +2,8 @@ cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"linux\", target_os = \"android\"))] {\n         mod futex;\n         pub use futex::Parker;\n+    } else if #[cfg(windows)] {\n+        pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;"}]}