{"sha": "955b37b3059a7e06842559af54e1685e33b0cf6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NWIzN2IzMDU5YTdlMDY4NDI1NTlhZjU0ZTE2ODVlMzNiMGNmNmM=", "commit": {"author": {"name": "Tim Diekmann", "email": "21277928+TimDiekmann@users.noreply.github.com", "date": "2020-10-16T06:54:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-16T06:54:38Z"}, "message": "Merge branch 'master' into box-alloc", "tree": {"sha": "f11d1e90021475b287dcef9ab05f3f3bfc004ea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f11d1e90021475b287dcef9ab05f3f3bfc004ea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/955b37b3059a7e06842559af54e1685e33b0cf6c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfiUOuCRBK7hj4Ov3rIwAAdHIIAKvM0vPvozMIVpFQ/W2Oh2YN\n1Z556Ux6SO+DyQOpwhFeINXBzKmZgB8vI9AKu0bGjH8oHWadHcoyffSLrXD5/607\nBHhsttljpfy/VEd6ZbF4sWbzw1U67PxK2nNlKkw4taQOfTRom0YWKcYtIAVjIpGz\nZuAyKJe5a4az9LnPNWjDQNNTRkaVs5SnVVUQGNO0Dz9UX5vY5Ek3MN+RPoNxCwOM\nAHLyT+sV9ijdevUuk0XQcKnrKE4MSrV2tIqrKCqrHeeZV6+jA+wMmX1F3MibsSGV\nfQHovov6IIXhibomxLFlFlayXLkOlW/GrvBHwwPR638/3OSOnf1Y7X827WpLJCI=\n=Mvtr\n-----END PGP SIGNATURE-----\n", "payload": "tree f11d1e90021475b287dcef9ab05f3f3bfc004ea8\nparent d5720bba8f5b278616a2fbd0da39478879a3f68b\nparent 8e6f69afc9b0943003ce51a53d1f59611e6601a3\nauthor Tim Diekmann <21277928+TimDiekmann@users.noreply.github.com> 1602831278 +0200\ncommitter GitHub <noreply@github.com> 1602831278 +0200\n\nMerge branch 'master' into box-alloc"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/955b37b3059a7e06842559af54e1685e33b0cf6c", "html_url": "https://github.com/rust-lang/rust/commit/955b37b3059a7e06842559af54e1685e33b0cf6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/955b37b3059a7e06842559af54e1685e33b0cf6c/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5720bba8f5b278616a2fbd0da39478879a3f68b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5720bba8f5b278616a2fbd0da39478879a3f68b", "html_url": "https://github.com/rust-lang/rust/commit/d5720bba8f5b278616a2fbd0da39478879a3f68b"}, {"sha": "8e6f69afc9b0943003ce51a53d1f59611e6601a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6f69afc9b0943003ce51a53d1f59611e6601a3", "html_url": "https://github.com/rust-lang/rust/commit/8e6f69afc9b0943003ce51a53d1f59611e6601a3"}], "stats": {"total": 27310, "additions": 16033, "deletions": 11277}, "files": [{"sha": "ffab883987c0d374248941c62e170bc1bb7e66e8", "filename": ".github/ISSUE_TEMPLATE/regression.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/.github%2FISSUE_TEMPLATE%2Fregression.md", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/.github%2FISSUE_TEMPLATE%2Fregression.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fregression.md?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -0,0 +1,68 @@\n+---\n+name: Regression\n+about: Report something that unexpectedly changed between Rust versions.\n+labels: C-bug regression-untriaged\n+---\n+<!--\n+Thank you for filing a regression report! \ud83d\udc1b A regression is something that changed between versions of Rust but was not supposed to.\n+\n+Please provide a short summary of the regression, along with any information you feel is relevant to replicate it.\n+-->\n+\n+### Code\n+\n+I tried this code:\n+\n+```rust\n+<code>\n+```\n+\n+I expected to see this happen: *explanation*\n+\n+Instead, this happened: *explanation*\n+\n+### Version it worked on\n+\n+<!--\n+Provide the most recent version this worked on, for example:\n+\n+It most recently worked on: Rust 1.47\n+-->\n+\n+It most recently worked on: <!-- version -->\n+\n+### Version with regression\n+\n+<!--\n+Provide the version you are using that has the regression.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+<!--\n+Did the compiler crash? If so, please provide a backtrace.\n+-->\n+\n+### Backtrace\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary>Backtrace</summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>\n+\n+<!--\n+If you know when this regression occurred, please add a line like below, replacing `{channel}` with one of stable, beta, or nightly.\n+\n+@rustbot modify labels: +regression-from-stable-to-{channel} -regression-untriaged\n+-->"}, {"sha": "6025808eb615d39f974f34ca73e1f77595310a7e", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -89,6 +89,9 @@ jobs:\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -300,6 +303,20 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n             os: macos-latest\n+          - name: dist-aarch64-apple\n+            env:\n+              SCRIPT: \"./x.py dist --stage 2\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --host=aarch64-apple-darwin --target=aarch64-apple-darwin --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              SELECT_XCODE: /Applications/Xcode_12.2.app\n+              USE_XCODE_CLANG: 1\n+              MACOSX_DEPLOYMENT_TARGET: 11.0\n+              MACOSX_STD_DEPLOYMENT_TARGET: 11.0\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+              JEMALLOC_SYS_WITH_LG_PAGE: 14\n+            os: macos-latest\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n@@ -369,7 +386,7 @@ jobs:\n             os: windows-latest-xl\n           - name: dist-x86_64-msvc\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n@@ -379,6 +396,12 @@ jobs:\n               SCRIPT: python x.py dist\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n+          - name: dist-aarch64-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 0\n+            os: windows-latest-xl\n           - name: dist-i686-mingw\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\"\n@@ -437,6 +460,9 @@ jobs:\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -544,6 +570,9 @@ jobs:\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB\n@@ -648,6 +677,9 @@ jobs:\n       - name: install sccache\n         run: src/ci/scripts/install-sccache.sh\n         if: success() && !env.SKIP_JOB\n+      - name: select Xcode\n+        run: src/ci/scripts/select-xcode.sh\n+        if: success() && !env.SKIP_JOB\n       - name: install clang\n         run: src/ci/scripts/install-clang.sh\n         if: success() && !env.SKIP_JOB"}, {"sha": "984113151de4d5b5e057f8845597df3608e6a0e6", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -37,7 +37,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/11.0-2020-09-22\n+\tbranch = rustc/11.0-2020-10-12\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "5ca804cb739ebfa0732bf26f82b86a8369f2d8ce", "filename": "Cargo.lock", "status": "modified", "additions": 95, "deletions": 65, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -132,13 +132,13 @@ checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.50\"\n+version = \"0.3.53\"\n dependencies = [\n  \"addr2line\",\n- \"cfg-if\",\n+ \"cfg-if 1.0.0\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.21.1\",\n  \"rustc-demangle\",\n ]\n \n@@ -243,6 +243,7 @@ dependencies = [\n  \"anyhow\",\n  \"flate2\",\n  \"hex 0.4.2\",\n+ \"num_cpus\",\n  \"rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -294,7 +295,7 @@ checksum = \"81a18687293a1546b67c246452202bbbf143d239cb43494cc163da14979082da\"\n \n [[package]]\n name = \"cargo\"\n-version = \"0.49.0\"\n+version = \"0.50.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -305,7 +306,7 @@ dependencies = [\n  \"clap\",\n  \"core-foundation\",\n  \"crates-io\",\n- \"crossbeam-utils 0.7.2\",\n+ \"crossbeam-utils 0.8.0\",\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n@@ -440,11 +441,17 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+\n [[package]]\n name = \"chalk-derive\"\n-version = \"0.31.0\"\n+version = \"0.32.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ca40c97e20f43e4aac2282d342103d45fafad74ad9bfcbaaf0b5d386f9ce1f39\"\n+checksum = \"2d072b2ba723f0bada7c515d8b3725224bc4f5052d2a92dcbeb0b118ff37084a\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -454,9 +461,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.31.0\"\n+version = \"0.32.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"88e3d545394fbc4f7d8fe203c6a78d2b73f82bb119f21af98de1f924c2518e34\"\n+checksum = \"6fb5475f6083d6d6c509e1c335c4f69ad04144ac090faa1afb134a53c3695841\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -467,19 +474,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.31.0\"\n+version = \"0.32.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8c4183955e084fcc387b515f867ed0e17e9e7301f5eee29c0338d5e63315bb41\"\n+checksum = \"f60cdb0e18c5455cb6a85e8464aad3622b70476018edfa8845691df66f7e9a05\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.31.0\"\n+version = \"0.32.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"50e8407bba06d9e760011a28060e8f3b3f87b82ea53fb8bfaa43614c19c14dcc\"\n+checksum = \"981534d499a8476ecc0b520be4d3864757f96211826a75360fbf2cb6fae362ab\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -548,7 +555,6 @@ dependencies = [\n  \"cargo_metadata 0.11.1\",\n  \"if_chain\",\n  \"itertools 0.9.0\",\n- \"lazy_static\",\n  \"pulldown-cmark 0.8.0\",\n  \"quine-mc_cluskey\",\n  \"quote\",\n@@ -670,6 +676,12 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"const_fn\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce90df4c658c62f12d78f7508cf92f9173e5184a539c10bfe54a3107b3ffd0f2\"\n+\n [[package]]\n name = \"constant_time_eq\"\n version = \"0.1.5\"\n@@ -723,17 +735,17 @@ version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ba125de2af0df55319f41944744ad91c71113bf74a4646efff39afe1f6842db1\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n ]\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09ee0cc8804d5393478d743b035099520087a5186f3b93fa58cec08fa62407b6\"\n+checksum = \"b153fe7cbef478c567df0f972e02e6d736db11affe43dfc9c56a9374d1adfb87\"\n dependencies = [\n- \"cfg-if\",\n  \"crossbeam-utils 0.7.2\",\n+ \"maybe-uninit\",\n ]\n \n [[package]]\n@@ -754,7 +766,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"058ed274caafc1f60c4997b5fc07bf7dc7cca454af7c6e81edffe5f33f70dace\"\n dependencies = [\n  \"autocfg\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"crossbeam-utils 0.7.2\",\n  \"lazy_static\",\n  \"maybe-uninit\",\n@@ -777,7 +789,7 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"774ba60a54c213d409d5353bda12d49cd68d14e45036a285234c8d6f91f92570\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"crossbeam-utils 0.7.2\",\n  \"maybe-uninit\",\n ]\n@@ -788,7 +800,7 @@ version = \"0.6.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"04973fa96e96579258a5091af6003abde64af786b860f18622b82e026cca60e6\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"lazy_static\",\n ]\n \n@@ -799,7 +811,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c3c7c73a2d1e9fc0886a08b93e98eb643461230d5f1925e4036204d5f2e261a8\"\n dependencies = [\n  \"autocfg\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ec91540d98355f690a86367e566ecad2e9e579f230230eb7c21398372be73ea5\"\n+dependencies = [\n+ \"autocfg\",\n+ \"cfg-if 1.0.0\",\n+ \"const_fn\",\n  \"lazy_static\",\n ]\n \n@@ -929,7 +953,7 @@ version = \"2.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"13aea89a5c93364a98e9b37b2fa237effbb694d5cfe01c5b70941f7eb087d5e3\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"dirs-sys\",\n ]\n \n@@ -1071,7 +1095,7 @@ version = \"0.2.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3ed85775dcc68644b5c950ac06a2b23768d3bc9390464151aaf27136998dcf9e\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"libc\",\n  \"redox_syscall\",\n  \"winapi 0.3.9\",\n@@ -1089,7 +1113,7 @@ version = \"1.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"68c90b0fc46cf89d227cc78b40e494ff81287a92dd07631e5af0d06fe3cf885e\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"crc32fast\",\n  \"libc\",\n  \"libz-sys\",\n@@ -1220,7 +1244,7 @@ version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"libc\",\n  \"wasi\",\n ]\n@@ -1231,7 +1255,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ee8025cf36f917e6a52cce185b7c7177689b838b7ec138364e50cc2277a56cf4\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"libc\",\n  \"wasi\",\n ]\n@@ -1249,9 +1273,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.13.8\"\n+version = \"0.13.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6ac22e49b7d886b6802c66662b12609452248b1bc9e87d6d83ecea3db96f557\"\n+checksum = \"ca6f1a0238d7f8f8fd5ee642f4ebac4dbc03e03d1f78fbe7a3ede35dcf7e2224\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1669,9 +1693,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.12.9+1.0.1\"\n+version = \"0.12.14+1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9b33bf3d9d4c45b48ae1ea7c334be69994624dc0a69f833d5d9f7605f24b552b\"\n+checksum = \"8f25af58e6495f7caf2919d08f212de550cfa3ed2f5e744988938ea292b9f549\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1693,9 +1717,9 @@ dependencies = [\n \n [[package]]\n name = \"libssh2-sys\"\n-version = \"0.2.18\"\n+version = \"0.2.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eafa907407504b0e683786d4aba47acf250f114d37357d56608333fd167dd0fc\"\n+checksum = \"ca46220853ba1c512fc82826d0834d87b06bcd3c2a42241b7de72f3d2fe17056\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1760,7 +1784,7 @@ version = \"0.4.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n ]\n \n [[package]]\n@@ -1990,7 +2014,7 @@ version = \"0.6.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fce347092656428bc8eaf6201042cb551b8d67855af7374542a92a0fbfcac430\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"fuchsia-zircon\",\n  \"fuchsia-zircon-sys\",\n  \"iovec\",\n@@ -2071,7 +2095,7 @@ version = \"0.2.34\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2ba7c918ac76704fb42afcbbb43891e72731f3dcca3bef2a19786297baf14af7\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"libc\",\n  \"winapi 0.3.9\",\n ]\n@@ -2122,6 +2146,12 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.21.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"37fd5004feb2ce328a52b0b3d01dbf4ffff72583493900ed15f22d4111c51693\"\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.4.1\"\n@@ -2165,7 +2195,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8d575eff3665419f9b83678ff2815858ad9d11567e082f5ac1814baba4e2bcb4\"\n dependencies = [\n  \"bitflags\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"foreign-types\",\n  \"lazy_static\",\n  \"libc\",\n@@ -2180,9 +2210,9 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.10.2+1.1.1g\"\n+version = \"111.12.0+1.1.1h\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a287fdb22e32b5b60624d4a5a7a02dbe82777f730ec0dbc42a0554326fef5a70\"\n+checksum = \"858a4132194f8570a7ee9eb8629e85b23cbc4565f2d4a162e87556e5956abf61\"\n dependencies = [\n  \"cc\",\n ]\n@@ -2222,14 +2252,14 @@ version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a85ea9fc0d4ac0deb6fe7911d38786b32fc11119afd9e9d38b84ff691ce64220\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n ]\n \n [[package]]\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2240,7 +2270,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2303,7 +2333,7 @@ version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b876b1b9e7ac6e1a74a6da34d25c42e17e8862aa409cbbbdcfc8d86c6f3bc62b\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"cloudabi 0.0.3\",\n  \"libc\",\n  \"redox_syscall\",\n@@ -2318,7 +2348,7 @@ version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d58c7c768d4ba344e3e8d72518ac13e259d7c7ade24167003b8488e10b6740a3\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"cloudabi 0.0.3\",\n  \"libc\",\n  \"redox_syscall\",\n@@ -2332,7 +2362,7 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c361aa727dd08437f2f1447be8b59a33b0edd15e0fcee698f935613d9efbca9b\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"cloudabi 0.1.0\",\n  \"instant\",\n  \"libc\",\n@@ -3036,7 +3066,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"14ffd17a37e00d77926a0713f191c59ff3aeb2b551a024c7cfffce14bab79be8\"\n dependencies = [\n  \"bitflags\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"crossbeam-utils 0.7.2\",\n  \"ena\",\n  \"indexmap\",\n@@ -3212,7 +3242,7 @@ version = \"679.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1c267f15c3cfc82a8a441d2bf86bcccf299d1eb625822468e3d8ee6f7c5a1c89\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"md-5\",\n  \"rustc-ap-rustc_arena\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3338,7 +3368,6 @@ dependencies = [\n name = \"rustc_arena\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_data_structures\",\n  \"smallvec 1.4.2\",\n ]\n \n@@ -3505,7 +3534,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"bitflags\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"crossbeam-utils 0.7.2\",\n  \"ena\",\n  \"indexmap\",\n@@ -4056,7 +4085,7 @@ dependencies = [\n name = \"rustc_span\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"md-5\",\n  \"rustc_arena\",\n  \"rustc_data_structures\",\n@@ -4417,7 +4446,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2933378ddfeda7ea26f48c555bdad8bb446bf8a3d17832dc83e380d444cfb8c1\"\n dependencies = [\n  \"block-buffer 0.9.0\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"cpuid-bool\",\n  \"digest 0.9.0\",\n  \"opaque-debug 0.3.0\",\n@@ -4503,7 +4532,7 @@ version = \"0.3.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"03088793f677dce356f3ccc2edb1b314ad191ab702a5de3faf49304f7e104918\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"libc\",\n  \"redox_syscall\",\n  \"winapi 0.3.9\",\n@@ -4522,7 +4551,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"21ccb4c06ec57bc82d0f610f1a2963d7648700e43a6f513e564b9c89f7991786\"\n dependencies = [\n  \"cc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"libc\",\n  \"psm\",\n  \"winapi 0.3.9\",\n@@ -4534,7 +4563,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"addr2line\",\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"dlmalloc\",\n@@ -4543,7 +4572,7 @@ dependencies = [\n  \"hermit-abi\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object\",\n+ \"object 0.20.0\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n@@ -4676,7 +4705,7 @@ version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"libc\",\n  \"rand\",\n  \"redox_syscall\",\n@@ -4736,7 +4765,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"core\",\n  \"getopts\",\n  \"libc\",\n@@ -5068,9 +5097,9 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.5.6\"\n+version = \"0.5.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ffc92d160b1eef40665be3a05630d003936a3bc7da7421277846c2613e92c71a\"\n+checksum = \"75cf45bb0bef80604d001caaec0d09da99611b3c0fd39d3080468875cdb65645\"\n dependencies = [\n  \"serde\",\n ]\n@@ -5081,7 +5110,7 @@ version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6d79ca061b032d6ce30c660fded31189ca0b9922bf483cd70759f13a2d86786c\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"tracing-attributes\",\n  \"tracing-core\",\n ]\n@@ -5099,9 +5128,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.15\"\n+version = \"0.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f0e00789804e99b20f12bc7003ca416309d28a6f495d6af58d1e2c2842461b5\"\n+checksum = \"f50de3927f93d202783f4513cda820ab47ef17f624b03c096e86ef00c67e6b5f\"\n dependencies = [\n  \"lazy_static\",\n ]\n@@ -5129,9 +5158,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-subscriber\"\n-version = \"0.2.11\"\n+version = \"0.2.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"abd165311cc4d7a555ad11cc77a37756df836182db0d81aac908c8184c584f40\"\n+checksum = \"4ef0a5e15477aa303afbfac3a44cba9b6430fdaad52423b1e6c0dbbe28c3eedd\"\n dependencies = [\n  \"ansi_term 0.12.1\",\n  \"chrono\",\n@@ -5144,6 +5173,7 @@ dependencies = [\n  \"sharded-slab\",\n  \"smallvec 1.4.2\",\n  \"thread_local\",\n+ \"tracing\",\n  \"tracing-core\",\n  \"tracing-log\",\n  \"tracing-serde\",\n@@ -5277,7 +5307,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\","}, {"sha": "29caa852ed47eb7db0c6dab7e47e5c2dae46de7d", "filename": "compiler/rustc_arena/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2FCargo.toml?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -5,5 +5,4 @@ version = \"0.0.0\"\n edition = \"2018\"\n \n [dependencies]\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "c051c607ff217b84600b1c77c223affdeacc82a8", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -16,7 +16,6 @@\n #![feature(maybe_uninit_slice)]\n #![cfg_attr(test, feature(test))]\n \n-use rustc_data_structures::cold_path;\n use smallvec::SmallVec;\n \n use std::alloc::Layout;\n@@ -27,6 +26,12 @@ use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::slice;\n \n+#[inline(never)]\n+#[cold]\n+pub fn cold_path<F: FnOnce() -> R, R>(f: F) -> R {\n+    f()\n+}\n+\n /// An arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated."}, {"sha": "8f156aea2ff5be2e8c6cd3246bad44082f908e0a", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 23, "deletions": 39, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -27,6 +27,7 @@ use crate::token::{self, CommentKind, DelimToken};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable_Generic;\n@@ -166,13 +167,6 @@ pub enum GenericArgs {\n }\n \n impl GenericArgs {\n-    pub fn is_parenthesized(&self) -> bool {\n-        match *self {\n-            Parenthesized(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn is_angle_bracketed(&self) -> bool {\n         match *self {\n             AngleBracketed(..) => true,\n@@ -856,13 +850,6 @@ impl BinOpKind {\n         }\n     }\n \n-    pub fn is_shift(&self) -> bool {\n-        match *self {\n-            BinOpKind::Shl | BinOpKind::Shr => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn is_comparison(&self) -> bool {\n         use BinOpKind::*;\n         // Note for developers: please keep this as is;\n@@ -872,11 +859,6 @@ impl BinOpKind {\n             And | Or | Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr => false,\n         }\n     }\n-\n-    /// Returns `true` if the binary operator takes its arguments by value\n-    pub fn is_by_value(&self) -> bool {\n-        !self.is_comparison()\n-    }\n }\n \n pub type BinOp = Spanned<BinOpKind>;\n@@ -895,14 +877,6 @@ pub enum UnOp {\n }\n \n impl UnOp {\n-    /// Returns `true` if the unary operator takes its argument by value\n-    pub fn is_by_value(u: UnOp) -> bool {\n-        match u {\n-            UnOp::Neg | UnOp::Not => true,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn to_string(op: UnOp) -> &'static str {\n         match op {\n             UnOp::Deref => \"*\",\n@@ -1752,13 +1726,6 @@ impl IntTy {\n         }\n     }\n \n-    pub fn val_to_string(&self, val: i128) -> String {\n-        // Cast to a `u128` so we can correctly print `INT128_MIN`. All integral types\n-        // are parsed as `u128`, so we wouldn't want to print an extra negative\n-        // sign.\n-        format!(\"{}{}\", val as u128, self.name_str())\n-    }\n-\n     pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             IntTy::Isize => return None,\n@@ -1817,10 +1784,6 @@ impl UintTy {\n         }\n     }\n \n-    pub fn val_to_string(&self, val: u128) -> String {\n-        format!(\"{}{}\", val, self.name_str())\n-    }\n-\n     pub fn bit_width(&self) -> Option<u64> {\n         Some(match *self {\n             UintTy::Usize => return None,\n@@ -1864,14 +1827,35 @@ pub enum AssocTyConstraintKind {\n     Bound { bounds: GenericBounds },\n }\n \n-#[derive(Clone, Encodable, Decodable, Debug)]\n+#[derive(Encodable, Decodable, Debug)]\n pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n     pub tokens: Option<TokenStream>,\n }\n \n+impl Clone for Ty {\n+    fn clone(&self) -> Self {\n+        ensure_sufficient_stack(|| Self {\n+            id: self.id,\n+            kind: self.kind.clone(),\n+            span: self.span,\n+            tokens: self.tokens.clone(),\n+        })\n+    }\n+}\n+\n+impl Ty {\n+    pub fn peel_refs(&self) -> &Self {\n+        let mut final_ty = self;\n+        while let TyKind::Rptr(_, MutTy { ty, .. }) = &final_ty.kind {\n+            final_ty = &ty;\n+        }\n+        final_ty\n+    }\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafe,"}, {"sha": "8351be222f6bdd4b2dc81a077ff2619ff1923d7f", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -101,11 +101,6 @@ impl NestedMetaItem {\n         self.meta_item().is_some()\n     }\n \n-    /// Returns `true` if the variant is `Literal`.\n-    pub fn is_literal(&self) -> bool {\n-        self.literal().is_some()\n-    }\n-\n     /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n     pub fn is_word(&self) -> bool {\n         self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n@@ -232,10 +227,6 @@ impl MetaItem {\n     pub fn is_value_str(&self) -> bool {\n         self.value_str().is_some()\n     }\n-\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n }\n \n impl AttrItem {"}, {"sha": "ad9c7391939a99b3a1f7c51e5fe800ab8f123515", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -54,16 +54,6 @@ pub enum DelimToken {\n     NoDelim,\n }\n \n-impl DelimToken {\n-    pub fn len(self) -> usize {\n-        if self == NoDelim { 0 } else { 1 }\n-    }\n-\n-    pub fn is_empty(self) -> bool {\n-        self == NoDelim\n-    }\n-}\n-\n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum LitKind {\n     Bool, // AST only, must never appear in a `Token`\n@@ -810,25 +800,36 @@ impl Nonterminal {\n             if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n                 let filename = source_map.span_to_filename(orig_span);\n                 if let FileName::Real(RealFileName::Named(path)) = filename {\n-                    let matches_prefix = |prefix| {\n-                        // Check for a path that ends with 'prefix*/src/lib.rs'\n+                    let matches_prefix = |prefix, filename| {\n+                        // Check for a path that ends with 'prefix*/src/<filename>'\n                         let mut iter = path.components().rev();\n-                        iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"lib.rs\")\n+                        iter.next().and_then(|p| p.as_os_str().to_str()) == Some(filename)\n                             && iter.next().and_then(|p| p.as_os_str().to_str()) == Some(\"src\")\n                             && iter\n                                 .next()\n                                 .and_then(|p| p.as_os_str().to_str())\n                                 .map_or(false, |p| p.starts_with(prefix))\n                     };\n \n-                    if (macro_name == sym::impl_macros && matches_prefix(\"time-macros-impl\"))\n-                        || (macro_name == sym::arrays && matches_prefix(\"js-sys\"))\n+                    if (macro_name == sym::impl_macros\n+                        && matches_prefix(\"time-macros-impl\", \"lib.rs\"))\n+                        || (macro_name == sym::arrays && matches_prefix(\"js-sys\", \"lib.rs\"))\n                     {\n                         let snippet = source_map.span_to_snippet(orig_span);\n                         if snippet.as_deref() == Ok(\"$name\") {\n                             return Some((*ident, *is_raw));\n                         }\n                     }\n+\n+                    if macro_name == sym::tuple_from_req\n+                        && (matches_prefix(\"actix-web\", \"extract.rs\")\n+                            || matches_prefix(\"actori-web\", \"extract.rs\"))\n+                    {\n+                        let snippet = source_map.span_to_snippet(orig_span);\n+                        if snippet.as_deref() == Ok(\"$T\") {\n+                            return Some((*ident, *is_raw));\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "8acb6b2f375898fbdadd4a79e0a2c256950b05db", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -295,12 +295,6 @@ impl TokenStream {\n                 .collect(),\n         ))\n     }\n-\n-    pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        TokenStream(Lrc::new(\n-            self.0.iter().map(|(tree, is_joint)| (f(tree.clone()), *is_joint)).collect(),\n-        ))\n-    }\n }\n \n // 99.5%+ of the time we have 1 or 2 elements in this vector."}, {"sha": "be5516ef4718b3564514cb930c1aee6a9f022365", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -231,7 +231,6 @@ impl AssocOp {\n     }\n }\n \n-pub const PREC_RESET: i8 = -100;\n pub const PREC_CLOSURE: i8 = -40;\n pub const PREC_JUMP: i8 = -30;\n pub const PREC_RANGE: i8 = -10;"}, {"sha": "2d2caa7a808d7cdc9ce63fab17c7d8067a0079f1", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -985,7 +985,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             asm::InlineAsmReg::parse(\n                                 sess.asm_arch?,\n                                 |feature| sess.target_features.contains(&Symbol::intern(feature)),\n-                                &sess.target.target,\n+                                &sess.target,\n                                 s,\n                             )\n                             .map_err(|e| {"}, {"sha": "d9791fe743cdeeaedcf9af39a53dc24077f0ae12", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -796,7 +796,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match &expr.kind {\n-            ExprKind::LlvmInlineAsm(..) if !self.session.target.target.options.allow_asm => {\n+            ExprKind::LlvmInlineAsm(..) if !self.session.target.options.allow_asm => {\n                 struct_span_err!(\n                     self.session,\n                     expr.span,"}, {"sha": "95f969d7691e015c12f6ae23c9fee40dd43e92a9", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -170,17 +170,11 @@ pub enum Token {\n \n impl Token {\n     crate fn is_eof(&self) -> bool {\n-        match *self {\n-            Token::Eof => true,\n-            _ => false,\n-        }\n+        matches!(self, Token::Eof)\n     }\n \n     pub fn is_hardbreak_tok(&self) -> bool {\n-        match *self {\n-            Token::Break(BreakToken { offset: 0, blank_space: bs }) if bs == SIZE_INFINITY => true,\n-            _ => false,\n-        }\n+        matches!(self, Token::Break(BreakToken { offset: 0, blank_space: SIZE_INFINITY }))\n     }\n }\n \n@@ -491,12 +485,9 @@ impl Printer {\n     }\n \n     fn get_top(&mut self) -> PrintStackElem {\n-        match self.print_stack.last() {\n-            Some(el) => *el,\n-            None => {\n-                PrintStackElem { offset: 0, pbreak: PrintStackBreak::Broken(Breaks::Inconsistent) }\n-            }\n-        }\n+        *self.print_stack.last().unwrap_or({\n+            &PrintStackElem { offset: 0, pbreak: PrintStackBreak::Broken(Breaks::Inconsistent) }\n+        })\n     }\n \n     fn print_begin(&mut self, b: BeginToken, l: isize) {"}, {"sha": "b34ea41ab558a1767962d73861d88b14418c58de", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -0,0 +1,104 @@\n+#[cfg(test)]\n+mod tests;\n+\n+pub mod state;\n+pub use state::{print_crate, AnnNode, Comments, PpAnn, PrintState, State};\n+\n+use rustc_ast as ast;\n+use rustc_ast::token::{Nonterminal, Token, TokenKind};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+\n+pub fn nonterminal_to_string_no_extra_parens(nt: &Nonterminal) -> String {\n+    let state = State::without_insert_extra_parens();\n+    state.nonterminal_to_string(nt)\n+}\n+\n+pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n+    State::new().nonterminal_to_string(nt)\n+}\n+\n+/// Print the token kind precisely, without converting `$crate` into its respective crate name.\n+pub fn token_kind_to_string(tok: &TokenKind) -> String {\n+    State::new().token_kind_to_string(tok)\n+}\n+\n+/// Print the token precisely, without converting `$crate` into its respective crate name.\n+pub fn token_to_string(token: &Token) -> String {\n+    State::new().token_to_string(token)\n+}\n+\n+pub fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n+    State::new().token_to_string_ext(token, convert_dollar_crate)\n+}\n+\n+pub fn ty_to_string(ty: &ast::Ty) -> String {\n+    State::new().ty_to_string(ty)\n+}\n+\n+pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n+    State::new().bounds_to_string(bounds)\n+}\n+\n+pub fn pat_to_string(pat: &ast::Pat) -> String {\n+    State::new().pat_to_string(pat)\n+}\n+\n+pub fn expr_to_string(e: &ast::Expr) -> String {\n+    State::new().expr_to_string(e)\n+}\n+\n+pub fn tt_to_string(tt: &TokenTree) -> String {\n+    State::new().tt_to_string(tt)\n+}\n+\n+pub fn tts_to_string(tokens: &TokenStream) -> String {\n+    State::new().tts_to_string(tokens)\n+}\n+\n+pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n+    State::new().stmt_to_string(stmt)\n+}\n+\n+pub fn item_to_string(i: &ast::Item) -> String {\n+    State::new().item_to_string(i)\n+}\n+\n+pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n+    State::new().generic_params_to_string(generic_params)\n+}\n+\n+pub fn path_to_string(p: &ast::Path) -> String {\n+    State::new().path_to_string(p)\n+}\n+\n+pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n+    State::new().path_segment_to_string(p)\n+}\n+\n+pub fn vis_to_string(v: &ast::Visibility) -> String {\n+    State::new().vis_to_string(v)\n+}\n+\n+pub fn block_to_string(blk: &ast::Block) -> String {\n+    State::new().block_to_string(blk)\n+}\n+\n+pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n+    State::new().meta_list_item_to_string(li)\n+}\n+\n+pub fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n+    State::new().attr_item_to_string(ai)\n+}\n+\n+pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n+    State::new().attribute_to_string(attr)\n+}\n+\n+pub fn param_to_string(arg: &ast::Param) -> String {\n+    State::new().param_to_string(arg)\n+}\n+\n+pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n+    State::new().to_string(f)\n+}"}, {"sha": "9aa066370bb5b1bc38371dd69dad1304569c5eea", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "renamed", "additions": 220, "deletions": 183, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -20,9 +20,6 @@ use rustc_span::{BytePos, FileName, Span};\n \n use std::borrow::Cow;\n \n-#[cfg(test)]\n-mod tests;\n-\n pub enum MacHeader<'a> {\n     Path(&'a ast::Path),\n     Keyword(&'static str),\n@@ -91,6 +88,13 @@ pub struct State<'a> {\n     comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn + 'a),\n     is_expanded: bool,\n+    // If `true`, additional parenthesis (separate from `ExprKind::Paren`)\n+    // are inserted to ensure that proper precedence is preserved\n+    // in the pretty-printed output.\n+    //\n+    // This is usually `true`, except when performing the pretty-print/reparse\n+    // check in `nt_to_tokenstream`\n+    insert_extra_parens: bool,\n }\n \n crate const INDENT_UNIT: usize = 4;\n@@ -112,6 +116,7 @@ pub fn print_crate<'a>(\n         comments: Some(Comments::new(sm, filename, input)),\n         ann,\n         is_expanded,\n+        insert_extra_parens: true,\n     };\n \n     if is_expanded && has_injected_crate {\n@@ -142,13 +147,6 @@ pub fn print_crate<'a>(\n     s.s.eof()\n }\n \n-pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n-    let mut printer =\n-        State { s: pp::mk_printer(), comments: None, ann: &NoAnn, is_expanded: false };\n-    f(&mut printer);\n-    printer.s.eof()\n-}\n-\n // This makes printed token streams look slightly nicer,\n // and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n@@ -231,173 +229,8 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-/// Print the token kind precisely, without converting `$crate` into its respective crate name.\n-pub fn token_kind_to_string(tok: &TokenKind) -> String {\n-    token_kind_to_string_ext(tok, None)\n-}\n-\n-fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>) -> String {\n-    match *tok {\n-        token::Eq => \"=\".to_string(),\n-        token::Lt => \"<\".to_string(),\n-        token::Le => \"<=\".to_string(),\n-        token::EqEq => \"==\".to_string(),\n-        token::Ne => \"!=\".to_string(),\n-        token::Ge => \">=\".to_string(),\n-        token::Gt => \">\".to_string(),\n-        token::Not => \"!\".to_string(),\n-        token::Tilde => \"~\".to_string(),\n-        token::OrOr => \"||\".to_string(),\n-        token::AndAnd => \"&&\".to_string(),\n-        token::BinOp(op) => binop_to_string(op).to_string(),\n-        token::BinOpEq(op) => format!(\"{}=\", binop_to_string(op)),\n-\n-        /* Structural symbols */\n-        token::At => \"@\".to_string(),\n-        token::Dot => \".\".to_string(),\n-        token::DotDot => \"..\".to_string(),\n-        token::DotDotDot => \"...\".to_string(),\n-        token::DotDotEq => \"..=\".to_string(),\n-        token::Comma => \",\".to_string(),\n-        token::Semi => \";\".to_string(),\n-        token::Colon => \":\".to_string(),\n-        token::ModSep => \"::\".to_string(),\n-        token::RArrow => \"->\".to_string(),\n-        token::LArrow => \"<-\".to_string(),\n-        token::FatArrow => \"=>\".to_string(),\n-        token::OpenDelim(token::Paren) => \"(\".to_string(),\n-        token::CloseDelim(token::Paren) => \")\".to_string(),\n-        token::OpenDelim(token::Bracket) => \"[\".to_string(),\n-        token::CloseDelim(token::Bracket) => \"]\".to_string(),\n-        token::OpenDelim(token::Brace) => \"{\".to_string(),\n-        token::CloseDelim(token::Brace) => \"}\".to_string(),\n-        token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".to_string(),\n-        token::Pound => \"#\".to_string(),\n-        token::Dollar => \"$\".to_string(),\n-        token::Question => \"?\".to_string(),\n-        token::SingleQuote => \"'\".to_string(),\n-\n-        /* Literals */\n-        token::Literal(lit) => literal_to_string(lit),\n-\n-        /* Name components */\n-        token::Ident(s, is_raw) => IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string(),\n-        token::Lifetime(s) => s.to_string(),\n-\n-        /* Other */\n-        token::DocComment(comment_kind, attr_style, data) => {\n-            doc_comment_to_string(comment_kind, attr_style, data)\n-        }\n-        token::Eof => \"<eof>\".to_string(),\n-\n-        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n-    }\n-}\n-\n-/// Print the token precisely, without converting `$crate` into its respective crate name.\n-pub fn token_to_string(token: &Token) -> String {\n-    token_to_string_ext(token, false)\n-}\n-\n-fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n-    let convert_dollar_crate = convert_dollar_crate.then_some(token.span);\n-    token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n-}\n-\n-pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n-    match *nt {\n-        token::NtExpr(ref e) => expr_to_string(e),\n-        token::NtMeta(ref e) => attr_item_to_string(e),\n-        token::NtTy(ref e) => ty_to_string(e),\n-        token::NtPath(ref e) => path_to_string(e),\n-        token::NtItem(ref e) => item_to_string(e),\n-        token::NtBlock(ref e) => block_to_string(e),\n-        token::NtStmt(ref e) => stmt_to_string(e),\n-        token::NtPat(ref e) => pat_to_string(e),\n-        token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n-        token::NtLifetime(e) => e.to_string(),\n-        token::NtLiteral(ref e) => expr_to_string(e),\n-        token::NtTT(ref tree) => tt_to_string(tree),\n-        token::NtVis(ref e) => vis_to_string(e),\n-    }\n-}\n-\n-pub fn ty_to_string(ty: &ast::Ty) -> String {\n-    to_string(|s| s.print_type(ty))\n-}\n-\n-pub fn bounds_to_string(bounds: &[ast::GenericBound]) -> String {\n-    to_string(|s| s.print_type_bounds(\"\", bounds))\n-}\n-\n-pub fn pat_to_string(pat: &ast::Pat) -> String {\n-    to_string(|s| s.print_pat(pat))\n-}\n-\n-pub fn expr_to_string(e: &ast::Expr) -> String {\n-    to_string(|s| s.print_expr(e))\n-}\n-\n-pub fn tt_to_string(tt: &TokenTree) -> String {\n-    to_string(|s| s.print_tt(tt, false))\n-}\n-\n-pub fn tts_to_string(tokens: &TokenStream) -> String {\n-    to_string(|s| s.print_tts(tokens, false))\n-}\n-\n-pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    to_string(|s| s.print_stmt(stmt))\n-}\n-\n-pub fn item_to_string(i: &ast::Item) -> String {\n-    to_string(|s| s.print_item(i))\n-}\n-\n-pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n-    to_string(|s| s.print_generic_params(generic_params))\n-}\n-\n-pub fn path_to_string(p: &ast::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0))\n-}\n-\n-pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n-    to_string(|s| s.print_path_segment(p, false))\n-}\n-\n-pub fn vis_to_string(v: &ast::Visibility) -> String {\n-    to_string(|s| s.print_visibility(v))\n-}\n-\n-fn block_to_string(blk: &ast::Block) -> String {\n-    to_string(|s| {\n-        // Containing cbox, will be closed by `print_block` at `}`.\n-        s.cbox(INDENT_UNIT);\n-        // Head-ibox, will be closed by `print_block` after `{`.\n-        s.ibox(0);\n-        s.print_block(blk)\n-    })\n-}\n-\n-pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n-    to_string(|s| s.print_meta_list_item(li))\n-}\n-\n-fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n-    to_string(|s| s.print_attr_item(ai, ai.path.span))\n-}\n-\n-pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n-    to_string(|s| s.print_attribute(attr))\n-}\n-\n-pub fn param_to_string(arg: &ast::Param) -> String {\n-    to_string(|s| s.print_param(arg, false))\n-}\n-\n fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n+    format!(\"{}{}\", State::new().to_string(|s| s.print_visibility(vis)), s)\n }\n \n impl std::ops::Deref for State<'_> {\n@@ -414,6 +247,7 @@ impl std::ops::DerefMut for State<'_> {\n }\n \n pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::DerefMut {\n+    fn insert_extra_parens(&self) -> bool;\n     fn comments(&mut self) -> &mut Option<Comments<'a>>;\n     fn print_ident(&mut self, ident: Ident);\n     fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool);\n@@ -679,7 +513,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_tt(&mut self, tt: &TokenTree, convert_dollar_crate: bool) {\n         match tt {\n             TokenTree::Token(token) => {\n-                self.word(token_to_string_ext(&token, convert_dollar_crate));\n+                let token_str = self.token_to_string_ext(&token, convert_dollar_crate);\n+                self.word(token_str);\n                 if let token::DocComment(..) = token.kind {\n                     self.hardbreak()\n                 }\n@@ -745,14 +580,20 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.space();\n                 }\n             }\n-            _ => self.word(token_kind_to_string(&token::OpenDelim(delim))),\n+            _ => {\n+                let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n+                self.word(token_str)\n+            }\n         }\n         self.ibox(0);\n         self.print_tts(tts, convert_dollar_crate);\n         self.end();\n         match delim {\n             DelimToken::Brace => self.bclose(span),\n-            _ => self.word(token_kind_to_string(&token::CloseDelim(delim))),\n+            _ => {\n+                let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n+                self.word(token_str)\n+            }\n         }\n     }\n \n@@ -818,9 +659,190 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             }\n         }\n     }\n+\n+    fn nonterminal_to_string(&self, nt: &Nonterminal) -> String {\n+        match *nt {\n+            token::NtExpr(ref e) => self.expr_to_string(e),\n+            token::NtMeta(ref e) => self.attr_item_to_string(e),\n+            token::NtTy(ref e) => self.ty_to_string(e),\n+            token::NtPath(ref e) => self.path_to_string(e),\n+            token::NtItem(ref e) => self.item_to_string(e),\n+            token::NtBlock(ref e) => self.block_to_string(e),\n+            token::NtStmt(ref e) => self.stmt_to_string(e),\n+            token::NtPat(ref e) => self.pat_to_string(e),\n+            token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n+            token::NtLifetime(e) => e.to_string(),\n+            token::NtLiteral(ref e) => self.expr_to_string(e),\n+            token::NtTT(ref tree) => self.tt_to_string(tree),\n+            token::NtVis(ref e) => self.vis_to_string(e),\n+        }\n+    }\n+\n+    /// Print the token kind precisely, without converting `$crate` into its respective crate name.\n+    fn token_kind_to_string(&self, tok: &TokenKind) -> String {\n+        self.token_kind_to_string_ext(tok, None)\n+    }\n+\n+    fn token_kind_to_string_ext(\n+        &self,\n+        tok: &TokenKind,\n+        convert_dollar_crate: Option<Span>,\n+    ) -> String {\n+        match *tok {\n+            token::Eq => \"=\".to_string(),\n+            token::Lt => \"<\".to_string(),\n+            token::Le => \"<=\".to_string(),\n+            token::EqEq => \"==\".to_string(),\n+            token::Ne => \"!=\".to_string(),\n+            token::Ge => \">=\".to_string(),\n+            token::Gt => \">\".to_string(),\n+            token::Not => \"!\".to_string(),\n+            token::Tilde => \"~\".to_string(),\n+            token::OrOr => \"||\".to_string(),\n+            token::AndAnd => \"&&\".to_string(),\n+            token::BinOp(op) => binop_to_string(op).to_string(),\n+            token::BinOpEq(op) => format!(\"{}=\", binop_to_string(op)),\n+\n+            /* Structural symbols */\n+            token::At => \"@\".to_string(),\n+            token::Dot => \".\".to_string(),\n+            token::DotDot => \"..\".to_string(),\n+            token::DotDotDot => \"...\".to_string(),\n+            token::DotDotEq => \"..=\".to_string(),\n+            token::Comma => \",\".to_string(),\n+            token::Semi => \";\".to_string(),\n+            token::Colon => \":\".to_string(),\n+            token::ModSep => \"::\".to_string(),\n+            token::RArrow => \"->\".to_string(),\n+            token::LArrow => \"<-\".to_string(),\n+            token::FatArrow => \"=>\".to_string(),\n+            token::OpenDelim(token::Paren) => \"(\".to_string(),\n+            token::CloseDelim(token::Paren) => \")\".to_string(),\n+            token::OpenDelim(token::Bracket) => \"[\".to_string(),\n+            token::CloseDelim(token::Bracket) => \"]\".to_string(),\n+            token::OpenDelim(token::Brace) => \"{\".to_string(),\n+            token::CloseDelim(token::Brace) => \"}\".to_string(),\n+            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".to_string(),\n+            token::Pound => \"#\".to_string(),\n+            token::Dollar => \"$\".to_string(),\n+            token::Question => \"?\".to_string(),\n+            token::SingleQuote => \"'\".to_string(),\n+\n+            /* Literals */\n+            token::Literal(lit) => literal_to_string(lit),\n+\n+            /* Name components */\n+            token::Ident(s, is_raw) => {\n+                IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string()\n+            }\n+            token::Lifetime(s) => s.to_string(),\n+\n+            /* Other */\n+            token::DocComment(comment_kind, attr_style, data) => {\n+                doc_comment_to_string(comment_kind, attr_style, data)\n+            }\n+            token::Eof => \"<eof>\".to_string(),\n+\n+            token::Interpolated(ref nt) => self.nonterminal_to_string(nt),\n+        }\n+    }\n+\n+    /// Print the token precisely, without converting `$crate` into its respective crate name.\n+    fn token_to_string(&self, token: &Token) -> String {\n+        self.token_to_string_ext(token, false)\n+    }\n+\n+    fn token_to_string_ext(&self, token: &Token, convert_dollar_crate: bool) -> String {\n+        let convert_dollar_crate = convert_dollar_crate.then_some(token.span);\n+        self.token_kind_to_string_ext(&token.kind, convert_dollar_crate)\n+    }\n+\n+    fn ty_to_string(&self, ty: &ast::Ty) -> String {\n+        self.to_string(|s| s.print_type(ty))\n+    }\n+\n+    fn bounds_to_string(&self, bounds: &[ast::GenericBound]) -> String {\n+        self.to_string(|s| s.print_type_bounds(\"\", bounds))\n+    }\n+\n+    fn pat_to_string(&self, pat: &ast::Pat) -> String {\n+        self.to_string(|s| s.print_pat(pat))\n+    }\n+\n+    fn expr_to_string(&self, e: &ast::Expr) -> String {\n+        self.to_string(|s| s.print_expr(e))\n+    }\n+\n+    fn tt_to_string(&self, tt: &TokenTree) -> String {\n+        self.to_string(|s| s.print_tt(tt, false))\n+    }\n+\n+    fn tts_to_string(&self, tokens: &TokenStream) -> String {\n+        self.to_string(|s| s.print_tts(tokens, false))\n+    }\n+\n+    fn stmt_to_string(&self, stmt: &ast::Stmt) -> String {\n+        self.to_string(|s| s.print_stmt(stmt))\n+    }\n+\n+    fn item_to_string(&self, i: &ast::Item) -> String {\n+        self.to_string(|s| s.print_item(i))\n+    }\n+\n+    fn generic_params_to_string(&self, generic_params: &[ast::GenericParam]) -> String {\n+        self.to_string(|s| s.print_generic_params(generic_params))\n+    }\n+\n+    fn path_to_string(&self, p: &ast::Path) -> String {\n+        self.to_string(|s| s.print_path(p, false, 0))\n+    }\n+\n+    fn path_segment_to_string(&self, p: &ast::PathSegment) -> String {\n+        self.to_string(|s| s.print_path_segment(p, false))\n+    }\n+\n+    fn vis_to_string(&self, v: &ast::Visibility) -> String {\n+        self.to_string(|s| s.print_visibility(v))\n+    }\n+\n+    fn block_to_string(&self, blk: &ast::Block) -> String {\n+        self.to_string(|s| {\n+            // Containing cbox, will be closed by `print_block` at `}`.\n+            s.cbox(INDENT_UNIT);\n+            // Head-ibox, will be closed by `print_block` after `{`.\n+            s.ibox(0);\n+            s.print_block(blk)\n+        })\n+    }\n+\n+    fn meta_list_item_to_string(&self, li: &ast::NestedMetaItem) -> String {\n+        self.to_string(|s| s.print_meta_list_item(li))\n+    }\n+\n+    fn attr_item_to_string(&self, ai: &ast::AttrItem) -> String {\n+        self.to_string(|s| s.print_attr_item(ai, ai.path.span))\n+    }\n+\n+    fn attribute_to_string(&self, attr: &ast::Attribute) -> String {\n+        self.to_string(|s| s.print_attribute(attr))\n+    }\n+\n+    fn param_to_string(&self, arg: &ast::Param) -> String {\n+        self.to_string(|s| s.print_param(arg, false))\n+    }\n+\n+    fn to_string(&self, f: impl FnOnce(&mut State<'_>)) -> String {\n+        let mut printer = State::new();\n+        printer.insert_extra_parens = self.insert_extra_parens();\n+        f(&mut printer);\n+        printer.s.eof()\n+    }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n+    fn insert_extra_parens(&self) -> bool {\n+        self.insert_extra_parens\n+    }\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }\n@@ -856,6 +878,20 @@ impl<'a> PrintState<'a> for State<'a> {\n }\n \n impl<'a> State<'a> {\n+    pub fn new() -> State<'a> {\n+        State {\n+            s: pp::mk_printer(),\n+            comments: None,\n+            ann: &NoAnn,\n+            is_expanded: false,\n+            insert_extra_parens: true,\n+        }\n+    }\n+\n+    pub(super) fn without_insert_extra_parens() -> State<'a> {\n+        State { insert_extra_parens: false, ..State::new() }\n+    }\n+\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) {\n@@ -1139,7 +1175,7 @@ impl<'a> State<'a> {\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n-                self.head(to_string(|s| {\n+                self.head(self.to_string(|s| {\n                     s.print_visibility(&item.vis);\n                     s.print_unsafety(_mod.unsafety);\n                     s.word(\"mod\");\n@@ -1158,7 +1194,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(to_string(|s| {\n+                self.head(self.to_string(|s| {\n                     s.print_unsafety(nmod.unsafety);\n                     s.word(\"extern\");\n                 }));\n@@ -1366,7 +1402,7 @@ impl<'a> State<'a> {\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n             },\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = to_string(|s| s.print_path(path, false, 0));\n+                let path = self.to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(format!(\"pub({})\", path))\n                 } else {\n@@ -1658,7 +1694,8 @@ impl<'a> State<'a> {\n     }\n \n     /// Prints `expr` or `(expr)` when `needs_par` holds.\n-    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, needs_par: bool) {\n+    fn print_expr_cond_paren(&mut self, expr: &ast::Expr, mut needs_par: bool) {\n+        needs_par &= self.insert_extra_parens;\n         if needs_par {\n             self.popen();\n         }", "previous_filename": "compiler/rustc_ast_pretty/src/pprust.rs"}, {"sha": "9c309345000bbe2b96f601b7b9e91c29df6f99a1", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -75,6 +75,12 @@ pub enum InlineAttr {\n     Never,\n }\n \n+#[derive(Clone, Encodable, Decodable)]\n+pub enum InstructionSetAttr {\n+    ArmA32,\n+    ArmT32,\n+}\n+\n #[derive(Clone, Encodable, Decodable)]\n pub enum OptimizeAttr {\n     None,\n@@ -148,7 +154,7 @@ pub struct ConstStability {\n }\n \n /// The available stability levels.\n-#[derive(Encodable, Decodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n+#[derive(Encodable, Decodable, PartialEq, Copy, Clone, Debug, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub enum StabilityLevel {\n     // Reason for the current stability level and the relevant rust-lang issue"}, {"sha": "36cd6c281b42a7a8b53780b332cd72fa38e5d4b3", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -81,7 +81,7 @@ fn parse_args<'a>(\n         } // accept trailing commas\n \n         // Parse options\n-        if p.eat(&token::Ident(sym::options, false)) {\n+        if p.eat_keyword(sym::options) {\n             parse_options(&mut p, &mut args)?;\n             allow_templates = false;\n             continue;\n@@ -101,19 +101,19 @@ fn parse_args<'a>(\n         };\n \n         let mut explicit_reg = false;\n-        let op = if p.eat(&token::Ident(kw::In, false)) {\n+        let op = if p.eat_keyword(kw::In) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             ast::InlineAsmOperand::In { reg, expr }\n-        } else if p.eat(&token::Ident(sym::out, false)) {\n+        } else if p.eat_keyword(sym::out) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: false }\n-        } else if p.eat(&token::Ident(sym::lateout, false)) {\n+        } else if p.eat_keyword(sym::lateout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n             ast::InlineAsmOperand::Out { reg, expr, late: true }\n-        } else if p.eat(&token::Ident(sym::inout, false)) {\n+        } else if p.eat_keyword(sym::inout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             if p.eat(&token::FatArrow) {\n@@ -123,7 +123,7 @@ fn parse_args<'a>(\n             } else {\n                 ast::InlineAsmOperand::InOut { reg, expr, late: false }\n             }\n-        } else if p.eat(&token::Ident(sym::inlateout, false)) {\n+        } else if p.eat_keyword(sym::inlateout) {\n             let reg = parse_reg(&mut p, &mut explicit_reg)?;\n             let expr = p.parse_expr()?;\n             if p.eat(&token::FatArrow) {\n@@ -133,10 +133,10 @@ fn parse_args<'a>(\n             } else {\n                 ast::InlineAsmOperand::InOut { reg, expr, late: true }\n             }\n-        } else if p.eat(&token::Ident(kw::Const, false)) {\n+        } else if p.eat_keyword(kw::Const) {\n             let expr = p.parse_expr()?;\n             ast::InlineAsmOperand::Const { expr }\n-        } else if p.eat(&token::Ident(sym::sym, false)) {\n+        } else if p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;\n             match expr.kind {\n                 ast::ExprKind::Path(..) => {}\n@@ -164,7 +164,7 @@ fn parse_args<'a>(\n             args.templates.push(template);\n             continue;\n         } else {\n-            return Err(p.expect_one_of(&[], &[]).unwrap_err());\n+            return p.unexpected();\n         };\n \n         allow_templates = false;\n@@ -333,21 +333,22 @@ fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), Diagn\n     p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n \n     while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n-        if p.eat(&token::Ident(sym::pure, false)) {\n+        if p.eat_keyword(sym::pure) {\n             try_set_option(p, args, sym::pure, ast::InlineAsmOptions::PURE);\n-        } else if p.eat(&token::Ident(sym::nomem, false)) {\n+        } else if p.eat_keyword(sym::nomem) {\n             try_set_option(p, args, sym::nomem, ast::InlineAsmOptions::NOMEM);\n-        } else if p.eat(&token::Ident(sym::readonly, false)) {\n+        } else if p.eat_keyword(sym::readonly) {\n             try_set_option(p, args, sym::readonly, ast::InlineAsmOptions::READONLY);\n-        } else if p.eat(&token::Ident(sym::preserves_flags, false)) {\n+        } else if p.eat_keyword(sym::preserves_flags) {\n             try_set_option(p, args, sym::preserves_flags, ast::InlineAsmOptions::PRESERVES_FLAGS);\n-        } else if p.eat(&token::Ident(sym::noreturn, false)) {\n+        } else if p.eat_keyword(sym::noreturn) {\n             try_set_option(p, args, sym::noreturn, ast::InlineAsmOptions::NORETURN);\n-        } else if p.eat(&token::Ident(sym::nostack, false)) {\n+        } else if p.eat_keyword(sym::nostack) {\n             try_set_option(p, args, sym::nostack, ast::InlineAsmOptions::NOSTACK);\n-        } else {\n-            p.expect(&token::Ident(sym::att_syntax, false))?;\n+        } else if p.eat_keyword(sym::att_syntax) {\n             try_set_option(p, args, sym::att_syntax, ast::InlineAsmOptions::ATT_SYNTAX);\n+        } else {\n+            return p.unexpected();\n         }\n \n         // Allow trailing commas"}, {"sha": "5bfd8a2bf561c1e9e1f13bb11dc679e933f629e5", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -120,8 +120,7 @@ fn parse_assert<'a>(\n         };\n \n     if parser.token != token::Eof {\n-        parser.expect_one_of(&[], &[])?;\n-        unreachable!();\n+        return parser.unexpected();\n     }\n \n     Ok(Assert { cond_expr, custom_message })"}, {"sha": "2e52d2a39236a7550ff983289ddbe722401b5aa8", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1137,12 +1137,9 @@ impl<'a> MethodDef<'a> {\n     /// for each of the self-args, carried in precomputed variables.\n \n     /// ```{.text}\n-    /// let __self0_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&self) };\n-    /// let __self1_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&arg1) };\n-    /// let __self2_vi = unsafe {\n-    ///     std::intrinsics::discriminant_value(&arg2) };\n+    /// let __self0_vi = std::intrinsics::discriminant_value(&self);\n+    /// let __self1_vi = std::intrinsics::discriminant_value(&arg1);\n+    /// let __self2_vi = std::intrinsics::discriminant_value(&arg2);\n     ///\n     /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n     ///     match (...) {\n@@ -1325,7 +1322,7 @@ impl<'a> MethodDef<'a> {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n-                Some(deriving::call_intrinsic(cx, sp, sym::unreachable, vec![]))\n+                Some(deriving::call_unreachable(cx, sp))\n             }\n             _ => None,\n         };\n@@ -1356,12 +1353,9 @@ impl<'a> MethodDef<'a> {\n             // with three Self args, builds three statements:\n             //\n             // ```\n-            // let __self0_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&self) };\n-            // let __self1_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&arg1) };\n-            // let __self2_vi = unsafe {\n-            //     std::intrinsics::discriminant_value(&arg2) };\n+            // let __self0_vi = std::intrinsics::discriminant_value(&self);\n+            // let __self1_vi = std::intrinsics::discriminant_value(&arg1);\n+            // let __self2_vi = std::intrinsics::discriminant_value(&arg2);\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n \n@@ -1474,7 +1468,7 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            deriving::call_intrinsic(cx, sp, sym::unreachable, vec![])\n+            deriving::call_unreachable(cx, sp)\n         } else {\n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref"}, {"sha": "bf95093492880236c425931b1e722ef6c141e5c5", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -68,7 +68,14 @@ fn call_intrinsic(\n ) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n     let path = cx.std_path(&[sym::intrinsics, intrinsic]);\n-    let call = cx.expr_call_global(span, path, args);\n+    cx.expr_call_global(span, path, args)\n+}\n+\n+/// Constructs an expression that calls the `unreachable` intrinsic.\n+fn call_unreachable(cx: &ExtCtxt<'_>, span: Span) -> P<ast::Expr> {\n+    let span = cx.with_def_site_ctxt(span);\n+    let path = cx.std_path(&[sym::intrinsics, sym::unreachable]);\n+    let call = cx.expr_call_global(span, path, vec![]);\n \n     cx.expr_block(P(ast::Block {\n         stmts: vec![cx.stmt_expr(call)],"}, {"sha": "b69b00d65f2be522633d4e76112b23d059afed02", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -385,7 +385,7 @@ pub mod printf {\n         if let Start = state {\n             match c {\n                 '1'..='9' => {\n-                    let end = at_next_cp_while(next, is_digit);\n+                    let end = at_next_cp_while(next, char::is_ascii_digit);\n                     match end.next_cp() {\n                         // Yes, this *is* the parameter.\n                         Some(('$', end2)) => {\n@@ -427,7 +427,7 @@ pub mod printf {\n                     move_to!(next);\n                 }\n                 '1'..='9' => {\n-                    let end = at_next_cp_while(next, is_digit);\n+                    let end = at_next_cp_while(next, char::is_ascii_digit);\n                     state = Prec;\n                     width = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n                     move_to!(end);\n@@ -441,7 +441,7 @@ pub mod printf {\n         }\n \n         if let WidthArg = state {\n-            let end = at_next_cp_while(at, is_digit);\n+            let end = at_next_cp_while(at, char::is_ascii_digit);\n             match end.next_cp() {\n                 Some(('$', end2)) => {\n                     state = Prec;\n@@ -473,7 +473,7 @@ pub mod printf {\n         if let PrecInner = state {\n             match c {\n                 '*' => {\n-                    let end = at_next_cp_while(next, is_digit);\n+                    let end = at_next_cp_while(next, char::is_ascii_digit);\n                     match end.next_cp() {\n                         Some(('$', end2)) => {\n                             state = Length;\n@@ -488,7 +488,7 @@ pub mod printf {\n                     }\n                 }\n                 '0'..='9' => {\n-                    let end = at_next_cp_while(next, is_digit);\n+                    let end = at_next_cp_while(next, char::is_ascii_digit);\n                     state = Length;\n                     precision = Some(Num::from_str(at.slice_between(end).unwrap(), None));\n                     move_to!(end);\n@@ -563,12 +563,12 @@ pub mod printf {\n \n     fn at_next_cp_while<F>(mut cur: Cur<'_>, mut pred: F) -> Cur<'_>\n     where\n-        F: FnMut(char) -> bool,\n+        F: FnMut(&char) -> bool,\n     {\n         loop {\n             match cur.next_cp() {\n                 Some((c, next)) => {\n-                    if pred(c) {\n+                    if pred(&c) {\n                         cur = next;\n                     } else {\n                         return cur;\n@@ -579,14 +579,7 @@ pub mod printf {\n         }\n     }\n \n-    fn is_digit(c: char) -> bool {\n-        match c {\n-            '0'..='9' => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn is_flag(c: char) -> bool {\n+    fn is_flag(c: &char) -> bool {\n         match c {\n             '0' | '-' | '+' | ' ' | '#' | '\\'' => true,\n             _ => false,\n@@ -723,17 +716,11 @@ pub mod shell {\n     }\n \n     fn is_ident_head(c: char) -> bool {\n-        match c {\n-            'a'..='z' | 'A'..='Z' | '_' => true,\n-            _ => false,\n-        }\n+        c.is_ascii_alphabetic() || c == '_'\n     }\n \n     fn is_ident_tail(c: char) -> bool {\n-        match c {\n-            '0'..='9' => true,\n-            c => is_ident_head(c),\n-        }\n+        c.is_ascii_alphanumeric() || c == '_'\n     }\n \n     #[cfg(test)]"}, {"sha": "da74f0aeaa193b54cc287a7b0d40a788719879fd", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -37,7 +37,7 @@ struct TestCtxt<'a> {\n pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n     let span_diagnostic = sess.diagnostic();\n     let panic_strategy = sess.panic_strategy();\n-    let platform_panic_strategy = sess.target.target.options.panic_strategy;\n+    let platform_panic_strategy = sess.target.options.panic_strategy;\n \n     // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n     // main test function the name `some_name` without hygiene. This needs to be"}, {"sha": "d02bc41f4af3bc535485afeca5ca31272442b313", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -16,10 +16,10 @@ pub(crate) unsafe fn codegen(\n ) {\n     let llcx = &*mods.llcx;\n     let llmod = mods.llmod();\n-    let usize = match &tcx.sess.target.target.target_pointer_width[..] {\n-        \"16\" => llvm::LLVMInt16TypeInContext(llcx),\n-        \"32\" => llvm::LLVMInt32TypeInContext(llcx),\n-        \"64\" => llvm::LLVMInt64TypeInContext(llcx),\n+    let usize = match tcx.sess.target.pointer_width {\n+        16 => llvm::LLVMInt16TypeInContext(llcx),\n+        32 => llvm::LLVMInt32TypeInContext(llcx),\n+        64 => llvm::LLVMInt64TypeInContext(llcx),\n         tws => bug!(\"Unsupported target word size for int: {}\", tws),\n     };\n     let i8 = llvm::LLVMInt8TypeInContext(llcx);\n@@ -57,7 +57,7 @@ pub(crate) unsafe fn codegen(\n         let name = format!(\"__rust_{}\", method.name);\n         let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n \n-        if tcx.sess.target.target.options.default_hidden_visibility {\n+        if tcx.sess.target.options.default_hidden_visibility {\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n@@ -98,7 +98,7 @@ pub(crate) unsafe fn codegen(\n     // -> ! DIFlagNoReturn\n     llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n \n-    if tcx.sess.target.target.options.default_hidden_visibility {\n+    if tcx.sess.target.options.default_hidden_visibility {\n         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n     }\n     if tcx.sess.must_emit_unwind_tables() {"}, {"sha": "b096664bc74c6a4a4d40fe1a139b2c39d547d08e", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -60,7 +60,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         // Default per-arch clobbers\n         // Basically what clang does\n-        let arch_clobbers = match &self.sess().target.target.arch[..] {\n+        let arch_clobbers = match &self.sess().target.arch[..] {\n             \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n             \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n             _ => Vec::new(),\n@@ -259,7 +259,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n                 InlineAsmArch::Nvptx64 => {}\n                 InlineAsmArch::Hexagon => {}\n-                InlineAsmArch::Mips => {}\n+                InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -710,6 +710,7 @@ fn llvm_fixup_input(\n             // MIPS only supports register-length arithmetics.\n             Primitive::Int(Integer::I8 | Integer::I16, _) => bx.zext(value, bx.cx.type_i32()),\n             Primitive::F32 => bx.bitcast(value, bx.cx.type_i32()),\n+            Primitive::F64 => bx.bitcast(value, bx.cx.type_i64()),\n             _ => value,\n         },\n         _ => value,\n@@ -785,6 +786,7 @@ fn llvm_fixup_output(\n             Primitive::Int(Integer::I8, _) => bx.trunc(value, bx.cx.type_i8()),\n             Primitive::Int(Integer::I16, _) => bx.trunc(value, bx.cx.type_i16()),\n             Primitive::F32 => bx.bitcast(value, bx.cx.type_f32()),\n+            Primitive::F64 => bx.bitcast(value, bx.cx.type_f64()),\n             _ => value,\n         },\n         _ => value,\n@@ -854,6 +856,7 @@ fn llvm_fixup_output_type(\n             // MIPS only supports register-length arithmetics.\n             Primitive::Int(Integer::I8 | Integer::I16, _) => cx.type_i32(),\n             Primitive::F32 => cx.type_i32(),\n+            Primitive::F64 => cx.type_i64(),\n             _ => layout.llvm_type(cx),\n         },\n         _ => layout.llvm_type(cx),"}, {"sha": "2075c2e19110b3df13b94717a5d12b71cc36046e", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -6,7 +6,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::query::Providers;\n@@ -18,7 +18,7 @@ use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n use crate::llvm::{self, Attribute};\n use crate::llvm_util;\n-pub use rustc_attr::{InlineAttr, OptimizeAttr};\n+pub use rustc_attr::{InlineAttr, InstructionSetAttr, OptimizeAttr};\n \n use crate::context::CodegenCx;\n use crate::value::Value;\n@@ -31,7 +31,7 @@ fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n         Hint => Attribute::InlineHint.apply_llfn(Function, val),\n         Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n         Never => {\n-            if cx.tcx().sess.target.target.arch != \"amdgpu\" {\n+            if cx.tcx().sess.target.arch != \"amdgpu\" {\n                 Attribute::NoInline.apply_llfn(Function, val);\n             }\n         }\n@@ -91,8 +91,7 @@ fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         // The function name varies on platforms.\n         // See test/CodeGen/mcount.c in clang.\n         let mcount_name =\n-            CString::new(cx.sess().target.target.options.target_mcount.as_str().as_bytes())\n-                .unwrap();\n+            CString::new(cx.sess().target.options.target_mcount.as_str().as_bytes()).unwrap();\n \n         llvm::AddFunctionAttrStringValue(\n             llfn,\n@@ -106,7 +105,7 @@ fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n-    if !cx.sess().target.target.options.stack_probes {\n+    if !cx.sess().target.options.stack_probes {\n         return;\n     }\n \n@@ -175,7 +174,6 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n         .split(',')\n         .filter(|f| !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)));\n     sess.target\n-        .target\n         .options\n         .features\n         .split(',')\n@@ -194,6 +192,18 @@ pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     );\n }\n \n+pub fn apply_tune_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+    if let Some(tune) = llvm_util::tune_cpu(cx.tcx.sess) {\n+        let tune_cpu = SmallCStr::new(tune);\n+        llvm::AddFunctionAttrStringValue(\n+            llfn,\n+            llvm::AttributePlace::Function,\n+            const_cstr!(\"tune-cpu\"),\n+            tune_cpu.as_c_str(),\n+        );\n+    }\n+}\n+\n /// Sets the `NonLazyBind` LLVM attribute on a given function,\n /// assuming the codegen options allow skipping the PLT.\n pub fn non_lazy_bind(sess: &Session, llfn: &'ll Value) {\n@@ -303,13 +313,20 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     // Without this, ThinLTO won't inline Rust functions into Clang generated\n     // functions (because Clang annotates functions this way too).\n     apply_target_cpu_attr(cx, llfn);\n+    // tune-cpu is only conveyed through the attribute for our purpose.\n+    // The target doesn't care; the subtarget reads our attribute.\n+    apply_tune_cpu_attr(cx, llfn);\n \n     let features = llvm_target_features(cx.tcx.sess)\n         .map(|s| s.to_string())\n         .chain(codegen_fn_attrs.target_features.iter().map(|f| {\n             let feature = &f.as_str();\n             format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n         }))\n+        .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n+            InstructionSetAttr::ArmA32 => \"-thumb-mode\".to_string(),\n+            InstructionSetAttr::ArmT32 => \"+thumb-mode\".to_string(),\n+        }))\n         .collect::<Vec<String>>()\n         .join(\",\");\n \n@@ -326,7 +343,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     // Note that currently the `wasm-import-module` doesn't do anything, but\n     // eventually LLVM 7 should read this and ferry the appropriate import\n     // module to the output file.\n-    if cx.tcx.sess.target.target.arch == \"wasm32\" {\n+    if cx.tcx.sess.target.arch == \"wasm32\" {\n         if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n             llvm::AddFunctionAttrStringValue(\n                 llfn,\n@@ -348,23 +365,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    use rustc_codegen_ssa::target_features::{all_known_features, supported_target_features};\n-    providers.supported_target_features = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        if tcx.sess.opts.actually_rustdoc {\n-            // rustdoc needs to be able to document functions that use all the features, so\n-            // provide them all.\n-            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n-        } else {\n-            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n-        }\n-    };\n-\n-    provide_extern(providers);\n-}\n-\n-pub fn provide_extern(providers: &mut Providers) {\n+pub fn provide_both(providers: &mut Providers) {\n     providers.wasm_import_module_map = |tcx, cnum| {\n         // Build up a map from DefId to a `NativeLib` structure, where\n         // `NativeLib` internally contains information about"}, {"sha": "595655b2ca26fffbc78796e23f210529a2b87df7", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -206,7 +206,7 @@ impl<'a> LlvmArchiveBuilder<'a> {\n     }\n \n     fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n-        let kind = &*self.config.sess.target.target.options.archive_format;\n+        let kind = &*self.config.sess.target.options.archive_format;\n         kind.parse().map_err(|_| kind)\n     }\n "}, {"sha": "ff312bade2521119841215ba6bc802a189adddfd", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 69, "deletions": 192, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -2,14 +2,14 @@ use crate::back::write::{\n     self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n };\n use crate::llvm::archive_ro::ArchiveRO;\n-use crate::llvm::{self, False, True};\n+use crate::llvm::{self, build_string, False, True};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{looks_like_rust_object_file, ModuleCodegen, ModuleKind};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{FatalError, Handler};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n@@ -22,16 +22,14 @@ use tracing::{debug, info};\n use std::ffi::{CStr, CString};\n use std::fs::File;\n use std::io;\n-use std::mem;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n \n-/// We keep track of past LTO imports that were used to produce the current set\n-/// of compiled object files that we might choose to reuse during this\n-/// compilation session.\n-pub const THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-imports.bin\";\n+/// We keep track of the computed LTO cache keys from the previous\n+/// session to determine which CGUs we can reuse.\n+pub const THIN_LTO_KEYS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-keys.bin\";\n \n pub fn crate_type_allows_lto(crate_type: CrateType) -> bool {\n     match crate_type {\n@@ -485,31 +483,31 @@ fn thin_lto(\n         )\n         .ok_or_else(|| write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\"))?;\n \n-        info!(\"thin LTO data created\");\n+        let data = ThinData(data);\n \n-        let (import_map_path, prev_import_map, curr_import_map) =\n-            if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-                let path = incr_comp_session_dir.join(THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME);\n-                // If previous imports have been deleted, or we get an IO error\n-                // reading the file storing them, then we'll just use `None` as the\n-                // prev_import_map, which will force the code to be recompiled.\n-                let prev = if path.exists() {\n-                    ThinLTOImportMaps::load_from_file(&path).ok()\n-                } else {\n-                    None\n-                };\n-                let curr = ThinLTOImportMaps::from_thin_lto_data(data);\n-                (Some(path), prev, curr)\n-            } else {\n-                // If we don't compile incrementally, we don't need to load the\n-                // import data from LLVM.\n-                assert!(green_modules.is_empty());\n-                let curr = ThinLTOImportMaps::default();\n-                (None, None, curr)\n-            };\n-        info!(\"thin LTO import map loaded\");\n+        info!(\"thin LTO data created\");\n \n-        let data = ThinData(data);\n+        let (key_map_path, prev_key_map, curr_key_map) = if let Some(ref incr_comp_session_dir) =\n+            cgcx.incr_comp_session_dir\n+        {\n+            let path = incr_comp_session_dir.join(THIN_LTO_KEYS_INCR_COMP_FILE_NAME);\n+            // If the previous file was deleted, or we get an IO error\n+            // reading the file, then we'll just use `None` as the\n+            // prev_key_map, which will force the code to be recompiled.\n+            let prev =\n+                if path.exists() { ThinLTOKeysMap::load_from_file(&path).ok() } else { None };\n+            let curr = ThinLTOKeysMap::from_thin_lto_modules(&data, &thin_modules, &module_names);\n+            (Some(path), prev, curr)\n+        } else {\n+            // If we don't compile incrementally, we don't need to load the\n+            // import data from LLVM.\n+            assert!(green_modules.is_empty());\n+            let curr = ThinLTOKeysMap::default();\n+            (None, None, curr)\n+        };\n+        info!(\"thin LTO cache key map loaded\");\n+        info!(\"prev_key_map: {:#?}\", prev_key_map);\n+        info!(\"curr_key_map: {:#?}\", curr_key_map);\n \n         // Throw our data in an `Arc` as we'll be sharing it across threads. We\n         // also put all memory referenced by the C++ data (buffers, ids, etc)\n@@ -528,60 +526,14 @@ fn thin_lto(\n         info!(\"checking which modules can be-reused and which have to be re-optimized.\");\n         for (module_index, module_name) in shared.module_names.iter().enumerate() {\n             let module_name = module_name_to_str(module_name);\n-\n-            // If (1.) the module hasn't changed, and (2.) none of the modules\n-            // it imports from have changed, *and* (3.) the import and export\n-            // sets themselves have not changed from the previous compile when\n-            // it was last ThinLTO'ed, then we can re-use the post-ThinLTO\n-            // version of the module. Otherwise, freshly perform LTO\n-            // optimization.\n-            //\n-            // (Note that globally, the export set is just the inverse of the\n-            // import set.)\n-            //\n-            // For further justification of why the above is necessary and sufficient,\n-            // see the LLVM blog post on ThinLTO:\n-            //\n-            // http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html\n-            //\n-            // which states the following:\n-            //\n-            // ```quote\n-            // any particular ThinLTO backend must be redone iff:\n-            //\n-            // 1. The corresponding (primary) module\u2019s bitcode changed\n-            // 2. The list of imports into or exports from the module changed\n-            // 3. The bitcode for any module being imported from has changed\n-            // 4. Any global analysis result affecting either the primary module\n-            //    or anything it imports has changed.\n-            // ```\n-            //\n-            // This strategy means we can always save the computed imports as\n-            // canon: when we reuse the post-ThinLTO version, condition (3.)\n-            // ensures that the current import set is the same as the previous\n-            // one. (And of course, when we don't reuse the post-ThinLTO\n-            // version, the current import set *is* the correct one, since we\n-            // are doing the ThinLTO in this current compilation cycle.)\n-            //\n-            // For more discussion, see rust-lang/rust#59535 (where the import\n-            // issue was discovered) and rust-lang/rust#69798 (where the\n-            // analogous export issue was discovered).\n-            if let (Some(prev_import_map), true) =\n-                (prev_import_map.as_ref(), green_modules.contains_key(module_name))\n+            if let (Some(prev_key_map), true) =\n+                (prev_key_map.as_ref(), green_modules.contains_key(module_name))\n             {\n                 assert!(cgcx.incr_comp_session_dir.is_some());\n \n-                let prev_imports = prev_import_map.imports_of(module_name);\n-                let curr_imports = curr_import_map.imports_of(module_name);\n-                let prev_exports = prev_import_map.exports_of(module_name);\n-                let curr_exports = curr_import_map.exports_of(module_name);\n-                let imports_all_green = curr_imports\n-                    .iter()\n-                    .all(|imported_module| green_modules.contains_key(imported_module));\n-                if imports_all_green\n-                    && equivalent_as_sets(prev_imports, curr_imports)\n-                    && equivalent_as_sets(prev_exports, curr_exports)\n-                {\n+                // If a module exists in both the current and the previous session,\n+                // and has the same LTO cache key in both sessions, then we can re-use it\n+                if prev_key_map.keys.get(module_name) == curr_key_map.keys.get(module_name) {\n                     let work_product = green_modules[module_name].clone();\n                     copy_jobs.push(work_product);\n                     info!(\" - {}: re-used\", module_name);\n@@ -599,10 +551,10 @@ fn thin_lto(\n         }\n \n         // Save the current ThinLTO import information for the next compilation\n-        // session, overwriting the previous serialized imports (if any).\n-        if let Some(path) = import_map_path {\n-            if let Err(err) = curr_import_map.save_to_file(&path) {\n-                let msg = format!(\"Error while writing ThinLTO import data: {}\", err);\n+        // session, overwriting the previous serialized data (if any).\n+        if let Some(path) = key_map_path {\n+            if let Err(err) = curr_key_map.save_to_file(&path) {\n+                let msg = format!(\"Error while writing ThinLTO key data: {}\", err);\n                 return Err(write::llvm_err(&diag_handler, &msg));\n             }\n         }\n@@ -611,24 +563,6 @@ fn thin_lto(\n     }\n }\n \n-/// Given two slices, each with no repeat elements. returns true if and only if\n-/// the two slices have the same contents when considered as sets (i.e. when\n-/// element order is disregarded).\n-fn equivalent_as_sets(a: &[String], b: &[String]) -> bool {\n-    // cheap path: unequal lengths means cannot possibly be set equivalent.\n-    if a.len() != b.len() {\n-        return false;\n-    }\n-    // fast path: before building new things, check if inputs are equivalent as is.\n-    if a == b {\n-        return true;\n-    }\n-    // slow path: general set comparison.\n-    let a: FxHashSet<&str> = a.iter().map(|s| s.as_str()).collect();\n-    let b: FxHashSet<&str> = b.iter().map(|s| s.as_str()).collect();\n-    a == b\n-}\n-\n pub(crate) fn run_pass_manager(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     module: &ModuleCodegen<ModuleLlvm>,\n@@ -942,113 +876,56 @@ pub unsafe fn optimize_thin_module(\n     Ok(module)\n }\n \n-/// Summarizes module import/export relationships used by LLVM's ThinLTO pass.\n-///\n-/// Note that we tend to have two such instances of `ThinLTOImportMaps` in use:\n-/// one loaded from a file that represents the relationships used during the\n-/// compilation associated with the incremetnal build artifacts we are\n-/// attempting to reuse, and another constructed via `from_thin_lto_data`, which\n-/// captures the relationships of ThinLTO in the current compilation.\n+/// Maps LLVM module identifiers to their corresponding LLVM LTO cache keys\n #[derive(Debug, Default)]\n-pub struct ThinLTOImportMaps {\n-    // key = llvm name of importing module, value = list of modules it imports from\n-    imports: FxHashMap<String, Vec<String>>,\n-    // key = llvm name of exporting module, value = list of modules it exports to\n-    exports: FxHashMap<String, Vec<String>>,\n+pub struct ThinLTOKeysMap {\n+    // key = llvm name of importing module, value = LLVM cache key\n+    keys: FxHashMap<String, String>,\n }\n \n-impl ThinLTOImportMaps {\n-    /// Returns modules imported by `llvm_module_name` during some ThinLTO pass.\n-    fn imports_of(&self, llvm_module_name: &str) -> &[String] {\n-        self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n-    }\n-\n-    /// Returns modules exported by `llvm_module_name` during some ThinLTO pass.\n-    fn exports_of(&self, llvm_module_name: &str) -> &[String] {\n-        self.exports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n-    }\n-\n+impl ThinLTOKeysMap {\n     fn save_to_file(&self, path: &Path) -> io::Result<()> {\n         use std::io::Write;\n         let file = File::create(path)?;\n         let mut writer = io::BufWriter::new(file);\n-        for (importing_module_name, imported_modules) in &self.imports {\n-            writeln!(writer, \"{}\", importing_module_name)?;\n-            for imported_module in imported_modules {\n-                writeln!(writer, \" {}\", imported_module)?;\n-            }\n-            writeln!(writer)?;\n+        for (module, key) in &self.keys {\n+            writeln!(writer, \"{} {}\", module, key)?;\n         }\n         Ok(())\n     }\n \n-    fn load_from_file(path: &Path) -> io::Result<ThinLTOImportMaps> {\n+    fn load_from_file(path: &Path) -> io::Result<Self> {\n         use std::io::BufRead;\n-        let mut imports = FxHashMap::default();\n-        let mut exports: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-        let mut current_module: Option<String> = None;\n-        let mut current_imports: Vec<String> = vec![];\n+        let mut keys = FxHashMap::default();\n         let file = File::open(path)?;\n         for line in io::BufReader::new(file).lines() {\n             let line = line?;\n-            if line.is_empty() {\n-                let importing_module = current_module.take().expect(\"Importing module not set\");\n-                for imported in &current_imports {\n-                    exports.entry(imported.clone()).or_default().push(importing_module.clone());\n-                }\n-                imports.insert(importing_module, mem::replace(&mut current_imports, vec![]));\n-            } else if line.starts_with(' ') {\n-                // Space marks an imported module\n-                assert_ne!(current_module, None);\n-                current_imports.push(line.trim().to_string());\n-            } else {\n-                // Otherwise, beginning of a new module (must be start or follow empty line)\n-                assert_eq!(current_module, None);\n-                current_module = Some(line.trim().to_string());\n-            }\n+            let mut split = line.split(\" \");\n+            let module = split.next().unwrap();\n+            let key = split.next().unwrap();\n+            assert_eq!(split.next(), None, \"Expected two space-separated values, found {:?}\", line);\n+            keys.insert(module.to_string(), key.to_string());\n         }\n-        Ok(ThinLTOImportMaps { imports, exports })\n+        Ok(Self { keys })\n     }\n \n-    /// Loads the ThinLTO import map from ThinLTOData.\n-    unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImportMaps {\n-        unsafe extern \"C\" fn imported_module_callback(\n-            payload: *mut libc::c_void,\n-            importing_module_name: *const libc::c_char,\n-            imported_module_name: *const libc::c_char,\n-        ) {\n-            let map = &mut *(payload as *mut ThinLTOImportMaps);\n-            let importing_module_name = CStr::from_ptr(importing_module_name);\n-            let importing_module_name = module_name_to_str(&importing_module_name);\n-            let imported_module_name = CStr::from_ptr(imported_module_name);\n-            let imported_module_name = module_name_to_str(&imported_module_name);\n-\n-            if !map.imports.contains_key(importing_module_name) {\n-                map.imports.insert(importing_module_name.to_owned(), vec![]);\n-            }\n-\n-            map.imports\n-                .get_mut(importing_module_name)\n-                .unwrap()\n-                .push(imported_module_name.to_owned());\n-\n-            if !map.exports.contains_key(imported_module_name) {\n-                map.exports.insert(imported_module_name.to_owned(), vec![]);\n-            }\n-\n-            map.exports\n-                .get_mut(imported_module_name)\n-                .unwrap()\n-                .push(importing_module_name.to_owned());\n-        }\n-\n-        let mut map = ThinLTOImportMaps::default();\n-        llvm::LLVMRustGetThinLTOModuleImports(\n-            data,\n-            imported_module_callback,\n-            &mut map as *mut _ as *mut libc::c_void,\n-        );\n-        map\n+    fn from_thin_lto_modules(\n+        data: &ThinData,\n+        modules: &[llvm::ThinLTOModule],\n+        names: &[CString],\n+    ) -> Self {\n+        let keys = modules\n+            .iter()\n+            .zip(names.iter())\n+            .map(|(module, name)| {\n+                let key = build_string(|rust_str| unsafe {\n+                    llvm::LLVMRustComputeLTOCacheKey(rust_str, module.identifier, data.0);\n+                })\n+                .expect(\"Invalid ThinLTO module key\");\n+                (name.clone().into_string().unwrap(), key)\n+            })\n+            .collect();\n+        Self { keys }\n     }\n }\n "}, {"sha": "ea1a7cfa5d3b5325c88cced137a02431d9344ce8", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -128,40 +128,40 @@ pub fn target_machine_factory(\n     let (opt_level, _) = to_llvm_opt_settings(optlvl);\n     let use_softfp = sess.opts.cg.soft_float;\n \n-    let ffunction_sections = sess.target.target.options.function_sections;\n+    let ffunction_sections = sess.target.options.function_sections;\n     let fdata_sections = ffunction_sections;\n \n     let code_model = to_llvm_code_model(sess.code_model());\n \n     let features = attributes::llvm_target_features(sess).collect::<Vec<_>>();\n-    let mut singlethread = sess.target.target.options.singlethread;\n+    let mut singlethread = sess.target.options.singlethread;\n \n     // On the wasm target once the `atomics` feature is enabled that means that\n     // we're no longer single-threaded, or otherwise we don't want LLVM to\n     // lower atomic operations to single-threaded operations.\n     if singlethread\n-        && sess.target.target.llvm_target.contains(\"wasm32\")\n+        && sess.target.llvm_target.contains(\"wasm32\")\n         && sess.target_features.contains(&sym::atomics)\n     {\n         singlethread = false;\n     }\n \n-    let triple = SmallCStr::new(&sess.target.target.llvm_target);\n+    let triple = SmallCStr::new(&sess.target.llvm_target);\n     let cpu = SmallCStr::new(llvm_util::target_cpu(sess));\n     let features = features.join(\",\");\n     let features = CString::new(features).unwrap();\n-    let abi = SmallCStr::new(&sess.target.target.options.llvm_abiname);\n-    let trap_unreachable = sess.target.target.options.trap_unreachable;\n+    let abi = SmallCStr::new(&sess.target.options.llvm_abiname);\n+    let trap_unreachable = sess.target.options.trap_unreachable;\n     let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n \n     let asm_comments = sess.asm_comments();\n-    let relax_elf_relocations = sess.target.target.options.relax_elf_relocations;\n+    let relax_elf_relocations = sess.target.options.relax_elf_relocations;\n \n     let use_init_array = !sess\n         .opts\n         .debugging_opts\n         .use_ctors_section\n-        .unwrap_or(sess.target.target.options.use_ctors_section);\n+        .unwrap_or(sess.target.options.use_ctors_section);\n \n     Arc::new(move || {\n         let tm = unsafe {"}, {"sha": "1090d4a25c7cfd634c2e11bc92326b47189e5c3c", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -60,7 +60,7 @@ pub fn write_compressed_metadata<'tcx>(\n         unsafe { llvm::LLVMAddGlobal(metadata_llmod, common::val_ty(llconst), buf.as_ptr()) };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let section_name = metadata::metadata_section_name(&tcx.sess.target.target);\n+        let section_name = metadata::metadata_section_name(&tcx.sess.target);\n         let name = SmallCStr::new(section_name);\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n "}, {"sha": "174620ea2fa15962c9fbf651dccedfaa6e86b5e5", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -308,8 +308,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         use rustc_middle::ty::{Int, Uint};\n \n         let new_kind = match ty.kind() {\n-            Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.ptr_width)),\n-            Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.ptr_width)),\n+            Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),\n+            Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.pointer_width)),\n             t @ (Uint(_) | Int(_)) => t.clone(),\n             _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n         };\n@@ -541,7 +541,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn range_metadata(&mut self, load: &'ll Value, range: Range<u128>) {\n-        if self.sess().target.target.arch == \"amdgpu\" {\n+        if self.sess().target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks a i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n             // tripping an assertion. So, for now, just disable this\n@@ -671,7 +671,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // WebAssembly has saturating floating point to integer casts if the\n         // `nontrapping-fptoint` target feature is activated. We'll use those if\n         // they are available.\n-        if self.sess().target.target.arch == \"wasm32\"\n+        if self.sess().target.arch == \"wasm32\"\n             && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n         {\n             let src_ty = self.cx.val_ty(val);\n@@ -696,7 +696,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // WebAssembly has saturating floating point to integer casts if the\n         // `nontrapping-fptoint` target feature is activated. We'll use those if\n         // they are available.\n-        if self.sess().target.target.arch == \"wasm32\"\n+        if self.sess().target.arch == \"wasm32\"\n             && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n         {\n             let src_ty = self.cx.val_ty(val);\n@@ -1427,7 +1427,7 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n-        self.sess().target.target.arch == \"wasm32\"\n+        self.sess().target.arch == \"wasm32\"\n             && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n     }\n }"}, {"sha": "e2003472d1263086807ddd6a1f4a2ba39efb51a3", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -176,7 +176,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n         // should use dllimport for functions.\n         if cx.use_dll_storage_attrs\n             && tcx.is_dllimport_foreign_item(instance_def_id)\n-            && tcx.sess.target.target.target_env != \"gnu\"\n+            && tcx.sess.target.target_env != \"gnu\"\n         {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);"}, {"sha": "b57a23328b66391935c6fe4c91547be15241b3b1", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -92,7 +92,7 @@ fn set_global_alignment(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Alig\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n-    if let Some(min) = cx.sess().target.target.options.min_global_align {\n+    if let Some(min) = cx.sess().target.options.min_global_align {\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n@@ -283,7 +283,7 @@ impl CodegenCx<'ll, 'tcx> {\n             // argument validation.\n             debug_assert!(\n                 !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                    && self.tcx.sess.target.target.options.is_like_windows\n+                    && self.tcx.sess.target.options.is_like_windows\n                     && self.tcx.sess.opts.cg.prefer_dynamic)\n             );\n \n@@ -437,7 +437,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 // will use load-unaligned instructions instead, and thus avoiding the crash.\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n-                if self.tcx.sess.target.target.options.is_like_osx {\n+                if self.tcx.sess.target.options.is_like_osx {\n                     // The `inspect` method is okay here because we checked relocations, and\n                     // because we are doing this access to inspect the final interpreter state\n                     // (not as part of the interpreter execution)."}, {"sha": "150cedde7e833f2808d8185bf57434b8f5839319", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -118,18 +118,18 @@ pub unsafe fn create_module(\n     let mod_name = SmallCStr::new(mod_name);\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n-    let mut target_data_layout = sess.target.target.data_layout.clone();\n+    let mut target_data_layout = sess.target.data_layout.clone();\n     if llvm_util::get_major_version() < 9 {\n         target_data_layout = strip_function_ptr_alignment(target_data_layout);\n     }\n     if llvm_util::get_major_version() < 10 {\n-        if sess.target.target.arch == \"x86\" || sess.target.target.arch == \"x86_64\" {\n+        if sess.target.arch == \"x86\" || sess.target.arch == \"x86_64\" {\n             target_data_layout = strip_x86_address_spaces(target_data_layout);\n         }\n     }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n-    if sess.target.target.options.is_builtin {\n+    if sess.target.options.is_builtin {\n         let tm = crate::back::write::create_informational_target_machine(tcx.sess);\n         llvm::LLVMRustSetDataLayoutFromTargetMachine(llmod, tm);\n         llvm::LLVMRustDisposeTargetMachine(tm);\n@@ -160,7 +160,7 @@ pub unsafe fn create_module(\n             bug!(\n                 \"data-layout for builtin `{}` target, `{}`, \\\n                   differs from LLVM default, `{}`\",\n-                sess.target.target.llvm_target,\n+                sess.target.llvm_target,\n                 target_data_layout,\n                 llvm_data_layout\n             );\n@@ -170,7 +170,7 @@ pub unsafe fn create_module(\n     let data_layout = SmallCStr::new(&target_data_layout);\n     llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n \n-    let llvm_target = SmallCStr::new(&sess.target.target.llvm_target);\n+    let llvm_target = SmallCStr::new(&sess.target.llvm_target);\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n \n     if sess.relocation_model() == RelocModel::Pic {\n@@ -190,7 +190,7 @@ pub unsafe fn create_module(\n     }\n \n     // Control Flow Guard is currently only supported by the MSVC linker on Windows.\n-    if sess.target.target.options.is_like_msvc {\n+    if sess.target.options.is_like_msvc {\n         match sess.opts.cg.control_flow_guard {\n             CFGuard::Disabled => {}\n             CFGuard::NoChecks => {\n@@ -265,7 +265,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         // linker will take care of everything. Fixing this problem will likely\n         // require adding a few attributes to Rust itself (feature gated at the\n         // start) and then strongly recommending static linkage on Windows!\n-        let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_windows;\n+        let use_dll_storage_attrs = tcx.sess.target.options.is_like_windows;\n \n         let check_overflow = tcx.sess.overflow_checks();\n \n@@ -417,7 +417,8 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn apply_target_cpu_attr(&self, llfn: &'ll Value) {\n-        attributes::apply_target_cpu_attr(self, llfn)\n+        attributes::apply_target_cpu_attr(self, llfn);\n+        attributes::apply_tune_cpu_attr(self, llfn);\n     }\n \n     fn create_used_variable(&self) {\n@@ -838,7 +839,7 @@ impl CodegenCx<'b, 'tcx> {\n             return eh_catch_typeinfo;\n         }\n         let tcx = self.tcx;\n-        assert!(self.sess().target.target.options.is_like_emscripten);\n+        assert!(self.sess().target.options.is_like_emscripten);\n         let eh_catch_typeinfo = match tcx.lang_items().eh_catch_typeinfo() {\n             Some(def_id) => self.get_static(def_id),\n             _ => {\n@@ -877,7 +878,7 @@ impl HasDataLayout for CodegenCx<'ll, 'tcx> {\n \n impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n     fn target_spec(&self) -> &Target {\n-        &self.tcx.sess.target.target\n+        &self.tcx.sess.target\n     }\n }\n "}, {"sha": "79721ff7e2d2b10724af97f06f27955090c8825d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -67,5 +67,5 @@ pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n \n     !omit_gdb_pretty_printer_section\n         && cx.sess().opts.debuginfo != DebugInfo::None\n-        && cx.sess().target.target.options.emit_debug_gdb_scripts\n+        && cx.sess().target.options.emit_debug_gdb_scripts\n }"}, {"sha": "5587e6ead1dbb3866bc4223a3487c996fb0906aa", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -874,7 +874,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n \n     // When targeting MSVC, emit MSVC style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let msvc_like_names = cx.tcx.sess.target.target.options.is_like_msvc;\n+    let msvc_like_names = cx.tcx.sess.target.options.is_like_msvc;\n \n     let (name, encoding) = match t.kind() {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n@@ -985,7 +985,7 @@ pub fn compile_unit_metadata(\n     // if multiple object files with the same `DW_AT_name` are linked together.\n     // As a workaround we generate unique names for each object file. Those do\n     // not correspond to an actual source file but that should be harmless.\n-    if tcx.sess.target.target.options.is_like_osx {\n+    if tcx.sess.target.options.is_like_osx {\n         name_in_debuginfo.push(\"@\");\n         name_in_debuginfo.push(codegen_unit_name);\n     }\n@@ -1401,7 +1401,7 @@ fn prepare_union_metadata(\n /// on MSVC we have to use the fallback mode, because LLVM doesn't\n /// lower variant parts to PDB.\n fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n-    cx.sess().target.target.options.is_like_msvc\n+    cx.sess().target.options.is_like_msvc\n }\n \n // FIXME(eddyb) maybe precompute this? Right now it's computed once"}, {"sha": "80e0e7bf2e06cb89af47aa139c57d121cb3f9ebb", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -120,14 +120,12 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n         // for macOS to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n         // Android has the same issue (#22398)\n-        if cx.sess().target.target.options.is_like_osx\n-            || cx.sess().target.target.options.is_like_android\n-        {\n-            llvm::LLVMRustAddModuleFlag(cx.llmod, \"Dwarf Version\\0\".as_ptr().cast(), 2)\n+        if let Some(version) = cx.sess().target.options.dwarf_version {\n+            llvm::LLVMRustAddModuleFlag(cx.llmod, \"Dwarf Version\\0\".as_ptr().cast(), version)\n         }\n \n         // Indicate that we want CodeView debug information on MSVC\n-        if cx.sess().target.target.options.is_like_msvc {\n+        if cx.sess().target.options.is_like_msvc {\n             llvm::LLVMRustAddModuleFlag(cx.llmod, \"CodeView\\0\".as_ptr().cast(), 1)\n         }\n \n@@ -348,7 +346,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             });\n \n             // Arguments types\n-            if cx.sess().target.target.options.is_like_msvc {\n+            if cx.sess().target.options.is_like_msvc {\n                 // FIXME(#42800):\n                 // There is a bug in MSDIA that leads to a crash when it encounters\n                 // a fixed-size array of `u8` or something zero-sized in a"}, {"sha": "517246cd0b24b8a3a641bab86cb95f8b125ef51f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -38,7 +38,7 @@ impl CodegenCx<'ll, '_> {\n         // For MSVC, omit the column number.\n         // Otherwise, emit it. This mimics clang behaviour.\n         // See discussion in https://github.com/rust-lang/rust/issues/42921\n-        if self.sess().target.target.options.is_like_msvc {\n+        if self.sess().target.options.is_like_msvc {\n             DebugLoc { file, line, col: None }\n         } else {\n             DebugLoc { file, line, col }"}, {"sha": "9face7783224e35ff1eec752602d1972350ba5f6", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -42,7 +42,7 @@ fn declare_raw_fn(\n     // be merged.\n     llvm::SetUnnamedAddress(llfn, llvm::UnnamedAddr::Global);\n \n-    if cx.tcx.sess.opts.cg.no_redzone.unwrap_or(cx.tcx.sess.target.target.options.disable_redzone) {\n+    if cx.tcx.sess.opts.cg.no_redzone.unwrap_or(cx.tcx.sess.target.options.disable_redzone) {\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "8379fe472251f04939512aa2d2053ab10eb7af4b", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -367,7 +367,7 @@ fn try_intrinsic(\n         bx.store(bx.const_i32(0), dest, ret_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, try_func, data, catch_func, dest);\n-    } else if bx.sess().target.target.options.is_like_emscripten {\n+    } else if bx.sess().target.options.is_like_emscripten {\n         codegen_emcc_try(bx, try_func, data, catch_func, dest);\n     } else {\n         codegen_gnu_try(bx, try_func, data, catch_func, dest);\n@@ -1722,10 +1722,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n     match ty.kind() {\n         ty::Int(t) => {\n-            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), true))\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.pointer_width)), true))\n         }\n         ty::Uint(t) => {\n-            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), false))\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.pointer_width)), false))\n         }\n         _ => None,\n     }"}, {"sha": "5974b59d39e4290c6ec4f27f79cd70bcee4c51ed", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -23,18 +23,17 @@ use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{ErrorReported, FatalError, Handler};\n-use rustc_middle::dep_graph::{DepGraph, WorkProduct};\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_serialize::json;\n-use rustc_session::config::{self, OptLevel, OutputFilenames, PrintRequest};\n+use rustc_session::config::{OptLevel, OutputFilenames, PrintRequest};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n \n use std::any::Any;\n use std::ffi::CStr;\n-use std::fs;\n use std::sync::Arc;\n \n mod back {\n@@ -116,6 +115,9 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str {\n         llvm_util::target_cpu(sess)\n     }\n+    fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str> {\n+        llvm_util::tune_cpu(sess)\n+    }\n }\n \n impl WriteBackendMethods for LlvmCodegenBackend {\n@@ -249,11 +251,11 @@ impl CodegenBackend for LlvmCodegenBackend {\n     }\n \n     fn provide(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide(providers);\n+        attributes::provide_both(providers);\n     }\n \n     fn provide_extern(&self, providers: &mut ty::query::Providers) {\n-        attributes::provide_extern(providers);\n+        attributes::provide_both(providers);\n     }\n \n     fn codegen_crate<'tcx>(\n@@ -274,47 +276,27 @@ impl CodegenBackend for LlvmCodegenBackend {\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n         sess: &Session,\n-        dep_graph: &DepGraph,\n-    ) -> Result<Box<dyn Any>, ErrorReported> {\n+    ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorReported> {\n         let (codegen_results, work_products) = ongoing_codegen\n             .downcast::<rustc_codegen_ssa::back::write::OngoingCodegen<LlvmCodegenBackend>>()\n             .expect(\"Expected LlvmCodegenBackend's OngoingCodegen, found Box<Any>\")\n             .join(sess);\n-        if sess.opts.debugging_opts.incremental_info {\n-            rustc_codegen_ssa::back::write::dump_incremental_data(&codegen_results);\n-        }\n \n-        sess.time(\"serialize_work_products\", move || {\n-            rustc_incremental::save_work_product_index(sess, &dep_graph, work_products)\n+        sess.time(\"llvm_dump_timing_file\", || {\n+            if sess.opts.debugging_opts.llvm_time_trace {\n+                llvm_util::time_trace_profiler_finish(\"llvm_timings.json\");\n+            }\n         });\n \n-        sess.compile_status()?;\n-\n-        Ok(Box::new(codegen_results))\n+        Ok((codegen_results, work_products))\n     }\n \n     fn link(\n         &self,\n         sess: &Session,\n-        codegen_results: Box<dyn Any>,\n+        codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported> {\n-        let codegen_results = codegen_results\n-            .downcast::<CodegenResults>()\n-            .expect(\"Expected CodegenResults, found Box<Any>\");\n-\n-        if sess.opts.debugging_opts.no_link {\n-            // FIXME: use a binary format to encode the `.rlink` file\n-            let rlink_data = json::encode(&codegen_results).map_err(|err| {\n-                sess.fatal(&format!(\"failed to encode rlink: {}\", err));\n-            })?;\n-            let rlink_file = outputs.with_extension(config::RLINK_EXT);\n-            fs::write(&rlink_file, rlink_data).map_err(|err| {\n-                sess.fatal(&format!(\"failed to write file {}: {}\", rlink_file.display(), err));\n-            })?;\n-            return Ok(());\n-        }\n-\n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n         sess.time(\"link_crate\", || {\n@@ -331,16 +313,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n             );\n         });\n \n-        // Now that we won't touch anything in the incremental compilation directory\n-        // any more, we can finalize it (which involves renaming it)\n-        rustc_incremental::finalize_session_directory(sess, codegen_results.crate_hash);\n-\n-        sess.time(\"llvm_dump_timing_file\", || {\n-            if sess.opts.debugging_opts.llvm_time_trace {\n-                llvm_util::time_trace_profiler_finish(\"llvm_timings.json\");\n-            }\n-        });\n-\n         Ok(())\n     }\n }"}, {"sha": "4c1fee0106a94a9e89782c06ec532884910f28fa", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -2362,4 +2362,10 @@ extern \"C\" {\n         bytecode_len: usize,\n     ) -> bool;\n     pub fn LLVMRustLinkerFree(linker: &'a mut Linker<'a>);\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustComputeLTOCacheKey(\n+        key_out: &RustString,\n+        mod_id: *const c_char,\n+        data: &ThinLTOData,\n+    );\n }"}, {"sha": "53a404ee019444f3e531c21aae4d540160fb457b", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -118,11 +118,6 @@ pub fn SetUnnamedAddress(global: &'a Value, unnamed: UnnamedAddr) {\n     }\n }\n \n-pub fn set_thread_local(global: &'a Value, is_thread_local: bool) {\n-    unsafe {\n-        LLVMSetThreadLocal(global, is_thread_local as Bool);\n-    }\n-}\n pub fn set_thread_local_mode(global: &'a Value, mode: ThreadLocalMode) {\n     unsafe {\n         LLVMSetThreadLocalMode(global, mode);"}, {"sha": "9c1e1b8fac06f304e0fcfc0865375013de8091dc", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -46,7 +46,7 @@ fn require_inited() {\n }\n \n unsafe fn configure_llvm(sess: &Session) {\n-    let n_args = sess.opts.cg.llvm_args.len() + sess.target.target.options.llvm_args.len();\n+    let n_args = sess.opts.cg.llvm_args.len() + sess.target.options.llvm_args.len();\n     let mut llvm_c_strs = Vec::with_capacity(n_args + 1);\n     let mut llvm_args = Vec::with_capacity(n_args + 1);\n \n@@ -57,7 +57,7 @@ unsafe fn configure_llvm(sess: &Session) {\n     }\n \n     let cg_opts = sess.opts.cg.llvm_args.iter();\n-    let tg_opts = sess.target.target.options.llvm_args.iter();\n+    let tg_opts = sess.target.options.llvm_args.iter();\n     let sess_args = cg_opts.chain(tg_opts);\n \n     let user_specified_args: FxHashSet<_> =\n@@ -88,17 +88,15 @@ unsafe fn configure_llvm(sess: &Session) {\n             .opts\n             .debugging_opts\n             .merge_functions\n-            .unwrap_or(sess.target.target.options.merge_functions)\n+            .unwrap_or(sess.target.options.merge_functions)\n         {\n             MergeFunctions::Disabled | MergeFunctions::Trampolines => {}\n             MergeFunctions::Aliases => {\n                 add(\"-mergefunc-use-aliases\", false);\n             }\n         }\n \n-        if sess.target.target.target_os == \"emscripten\"\n-            && sess.panic_strategy() == PanicStrategy::Unwind\n-        {\n+        if sess.target.target_os == \"emscripten\" && sess.panic_strategy() == PanicStrategy::Unwind {\n             add(\"-enable-emscripten-cxx-exceptions\", false);\n         }\n \n@@ -122,7 +120,7 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    ::rustc_llvm::initialize_available_targets();\n+    rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n }\n@@ -140,7 +138,7 @@ pub fn time_trace_profiler_finish(file_name: &str) {\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n-    let arch = if sess.target.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.target.arch };\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n     match (arch, s) {\n         (\"x86\", \"pclmulqdq\") => \"pclmul\",\n         (\"x86\", \"rdrand\") => \"rdrnd\",\n@@ -202,11 +200,7 @@ pub(crate) fn print(req: PrintRequest, sess: &Session) {\n     }\n }\n \n-pub fn target_cpu(sess: &Session) -> &str {\n-    let name = match sess.opts.cg.target_cpu {\n-        Some(ref s) => &**s,\n-        None => &*sess.target.target.options.cpu,\n-    };\n+fn handle_native(name: &str) -> &str {\n     if name != \"native\" {\n         return name;\n     }\n@@ -217,3 +211,19 @@ pub fn target_cpu(sess: &Session) -> &str {\n         str::from_utf8(slice::from_raw_parts(ptr as *const u8, len)).unwrap()\n     }\n }\n+\n+pub fn target_cpu(sess: &Session) -> &str {\n+    let name = match sess.opts.cg.target_cpu {\n+        Some(ref s) => &**s,\n+        None => &*sess.target.options.cpu,\n+    };\n+\n+    handle_native(name)\n+}\n+\n+pub fn tune_cpu(sess: &Session) -> Option<&str> {\n+    match sess.opts.debugging_opts.tune_cpu {\n+        Some(ref s) => Some(handle_native(&**s)),\n+        None => None,\n+    }\n+}"}, {"sha": "5f820f83a9438976c9ce9a0fcb47f66829b915ff", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -52,7 +52,7 @@ fn emit_direct_ptr_va_arg(\n     let next = bx.inbounds_gep(addr, &[full_direct_size]);\n     bx.store(next, va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n \n-    if size.bytes() < slot_size.bytes() && &*bx.tcx().sess.target.target.target_endian == \"big\" {\n+    if size.bytes() < slot_size.bytes() && &*bx.tcx().sess.target.target_endian == \"big\" {\n         let adjusted_size = bx.cx().const_i32((slot_size.bytes() - size.bytes()) as i32);\n         let adjusted = bx.inbounds_gep(addr, &[adjusted_size]);\n         (bx.bitcast(adjusted, bx.cx().type_ptr_to(llty)), addr_align)\n@@ -105,7 +105,7 @@ fn emit_aapcs_va_arg(\n     let mut end = bx.build_sibling_block(\"va_arg.end\");\n     let zero = bx.const_i32(0);\n     let offset_align = Align::from_bytes(4).unwrap();\n-    assert!(&*bx.tcx().sess.target.target.target_endian == \"little\");\n+    assert!(&*bx.tcx().sess.target.target_endian == \"little\");\n \n     let gr_type = target_ty.is_any_ptr() || target_ty.is_integral();\n     let (reg_off, reg_top_index, slot_size) = if gr_type {\n@@ -171,8 +171,8 @@ pub(super) fn emit_va_arg(\n ) -> &'ll Value {\n     // Determine the va_arg implementation to use. The LLVM va_arg instruction\n     // is lacking in some instances, so we should only use it as a fallback.\n-    let target = &bx.cx.tcx.sess.target.target;\n-    let arch = &bx.cx.tcx.sess.target.target.arch;\n+    let target = &bx.cx.tcx.sess.target;\n+    let arch = &bx.cx.tcx.sess.target.arch;\n     match (&**arch, target.options.is_like_windows) {\n         // Windows x86\n         (\"x86\", true) => {"}, {"sha": "ef722ecb599864e7d6e1271e37ca01a2c5fdc061", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -9,9 +9,7 @@ pub fn find_library(name: Symbol, search_paths: &[PathBuf], sess: &Session) -> P\n     // times show up as foo.lib\n     let oslibname = format!(\n         \"{}{}{}\",\n-        sess.target.target.options.staticlib_prefix,\n-        name,\n-        sess.target.target.options.staticlib_suffix\n+        sess.target.options.staticlib_prefix, name, sess.target.options.staticlib_suffix\n     );\n     let unixlibname = format!(\"lib{}.a\", name);\n "}, {"sha": "63d0a88858ec1d159d344e8e622cbb330c930f90", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 55, "deletions": 62, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -15,7 +15,7 @@ use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n-use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel};\n+use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, Target};\n \n use super::archive::ArchiveBuilder;\n use super::command::Command;\n@@ -152,7 +152,7 @@ fn get_linker(\n         _ => match flavor {\n             LinkerFlavor::Lld(f) => Command::lld(linker, f),\n             LinkerFlavor::Msvc\n-                if sess.opts.cg.linker.is_none() && sess.target.target.options.linker.is_none() =>\n+                if sess.opts.cg.linker.is_none() && sess.target.options.linker.is_none() =>\n             {\n                 Command::new(msvc_tool.as_ref().map(|t| t.path()).unwrap_or(linker))\n             }\n@@ -163,7 +163,7 @@ fn get_linker(\n     // UWP apps have API restrictions enforced during Store submissions.\n     // To comply with the Windows App Certification Kit,\n     // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n-    let t = &sess.target.target;\n+    let t = &sess.target;\n     if (flavor == LinkerFlavor::Msvc || flavor == LinkerFlavor::Lld(LldFlavor::Link))\n         && t.target_vendor == \"uwp\"\n     {\n@@ -197,7 +197,7 @@ fn get_linker(\n     // PATH for the child.\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(self_contained);\n     let mut msvc_changed_path = false;\n-    if sess.target.target.options.is_like_msvc {\n+    if sess.target.options.is_like_msvc {\n         if let Some(ref tool) = msvc_tool {\n             cmd.args(tool.args());\n             for &(ref k, ref v) in tool.env() {\n@@ -365,7 +365,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             // After adding all files to the archive, we need to update the\n             // symbol table of the archive. This currently dies on macOS (see\n             // #11162), and isn't necessary there anyway\n-            if !sess.target.target.options.is_like_osx {\n+            if !sess.target.options.is_like_osx {\n                 ab.update_symbols();\n             }\n         }\n@@ -476,10 +476,10 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n     linker::disable_localization(&mut cmd);\n \n-    for &(ref k, ref v) in &sess.target.target.options.link_env {\n+    for &(ref k, ref v) in &sess.target.options.link_env {\n         cmd.env(k, v);\n     }\n-    for k in &sess.target.target.options.link_env_remove {\n+    for k in &sess.target.options.link_env_remove {\n         cmd.env_remove(k);\n     }\n \n@@ -515,7 +515,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         // if the linker doesn't support -no-pie then it should not default to\n         // linking executables as pie. Different versions of gcc seem to use\n         // different quotes in the error message so don't check for them.\n-        if sess.target.target.options.linker_is_gnu\n+        if sess.target.options.linker_is_gnu\n             && flavor != LinkerFlavor::Ld\n             && (out.contains(\"unrecognized command line option\")\n                 || out.contains(\"unknown argument\"))\n@@ -535,7 +535,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n         // Detect '-static-pie' used with an older version of gcc or clang not supporting it.\n         // Fallback from '-static-pie' to '-static' in that case.\n-        if sess.target.target.options.linker_is_gnu\n+        if sess.target.options.linker_is_gnu\n             && flavor != LinkerFlavor::Ld\n             && (out.contains(\"unrecognized command line option\")\n                 || out.contains(\"unknown argument\"))\n@@ -548,7 +548,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n             );\n             // Mirror `add_(pre,post)_link_objects` to replace CRT objects.\n             let self_contained = crt_objects_fallback(sess, crate_type);\n-            let opts = &sess.target.target.options;\n+            let opts = &sess.target.options;\n             let pre_objects = if self_contained {\n                 &opts.pre_link_objects_fallback\n             } else {\n@@ -670,7 +670,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                 // is not a Microsoft LNK error then suggest a way to fix or\n                 // install the Visual Studio build tools.\n                 if let Some(code) = prog.status.code() {\n-                    if sess.target.target.options.is_like_msvc\n+                    if sess.target.options.is_like_msvc\n                         && flavor == LinkerFlavor::Msvc\n                         // Respect the command line override\n                         && sess.opts.cg.linker.is_none()\n@@ -741,7 +741,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n             linker_error.emit();\n \n-            if sess.target.target.options.is_like_msvc && linker_not_found {\n+            if sess.target.options.is_like_msvc && linker_not_found {\n                 sess.note_without_error(\n                     \"the msvc targets depend on the msvc linker \\\n                      but `link.exe` was not found\",\n@@ -758,7 +758,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     // On macOS, debuggers need this utility to get run to do some munging of\n     // the symbols. Note, though, that if the object files are being preserved\n     // for their debug information there's no need for us to run dsymutil.\n-    if sess.target.target.options.is_like_osx\n+    if sess.target.options.is_like_osx\n         && sess.opts.debuginfo != DebugInfo::None\n         && !preserve_objects_for_their_debuginfo(sess)\n     {\n@@ -776,7 +776,7 @@ fn link_sanitizers(sess: &Session, crate_type: CrateType, linker: &mut dyn Linke\n     let needs_runtime = match crate_type {\n         CrateType::Executable => true,\n         CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => {\n-            sess.target.target.options.is_like_osx\n+            sess.target.options.is_like_osx\n         }\n         CrateType::Rlib | CrateType::Staticlib => false,\n     };\n@@ -846,7 +846,7 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n     // If our target enables builtin function lowering in LLVM then the\n     // crates providing these functions don't participate in LTO (e.g.\n     // no_builtins or compiler builtins crates).\n-    !sess.target.target.options.no_builtins\n+    !sess.target.options.no_builtins\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n@@ -906,10 +906,10 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 } else if stem == \"link\" || stem == \"lld-link\" {\n                     LinkerFlavor::Msvc\n                 } else if stem == \"lld\" || stem == \"rust-lld\" {\n-                    LinkerFlavor::Lld(sess.target.target.options.lld_flavor)\n+                    LinkerFlavor::Lld(sess.target.options.lld_flavor)\n                 } else {\n                     // fall back to the value in the target spec\n-                    sess.target.target.linker_flavor\n+                    sess.target.linker_flavor\n                 };\n \n                 Some((linker, flavor))\n@@ -926,8 +926,8 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     if let Some(ret) = infer_from(\n         sess,\n-        sess.target.target.options.linker.clone().map(PathBuf::from),\n-        Some(sess.target.target.linker_flavor),\n+        sess.target.options.linker.clone().map(PathBuf::from),\n+        Some(sess.target.linker_flavor),\n     ) {\n         return ret;\n     }\n@@ -962,7 +962,7 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     // Basically as a result this just means that if we're on OSX and we're\n     // *not* running dsymutil then the object files are the only source of truth\n     // for debug information, so we must preserve them.\n-    if sess.target.target.options.is_like_osx {\n+    if sess.target.options.is_like_osx {\n         return !sess.opts.debugging_opts.run_dsymutil;\n     }\n \n@@ -988,7 +988,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 NativeLibKind::StaticNoBundle\n                 | NativeLibKind::Dylib\n                 | NativeLibKind::Unspecified => {\n-                    if sess.target.target.options.is_like_msvc {\n+                    if sess.target.options.is_like_msvc {\n                         Some(format!(\"{}.lib\", name))\n                     } else {\n                         Some(format!(\"-l{}\", name))\n@@ -1070,16 +1070,13 @@ fn exec_linker(\n     let mut args = String::new();\n     for arg in cmd2.take_args() {\n         args.push_str(\n-            &Escape {\n-                arg: arg.to_str().unwrap(),\n-                is_like_msvc: sess.target.target.options.is_like_msvc,\n-            }\n-            .to_string(),\n+            &Escape { arg: arg.to_str().unwrap(), is_like_msvc: sess.target.options.is_like_msvc }\n+                .to_string(),\n         );\n         args.push('\\n');\n     }\n     let file = tmpdir.join(\"linker-arguments\");\n-    let bytes = if sess.target.target.options.is_like_msvc {\n+    let bytes = if sess.target.options.is_like_msvc {\n         let mut out = Vec::with_capacity((1 + args.len()) * 2);\n         // start the stream with a UTF-16 BOM\n         for c in std::iter::once(0xFEFF).chain(args.encode_utf16()) {\n@@ -1195,7 +1192,7 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     };\n \n     // Adjust the output kind to target capabilities.\n-    let opts = &sess.target.target.options;\n+    let opts = &sess.target.options;\n     let pic_exe_supported = opts.position_independent_executables;\n     let static_pic_exe_supported = opts.static_position_independent_executables;\n     let static_dylib_supported = opts.crt_static_allows_dylibs;\n@@ -1236,14 +1233,14 @@ fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n         return self_contained;\n     }\n \n-    match sess.target.target.options.crt_objects_fallback {\n+    match sess.target.options.crt_objects_fallback {\n         // FIXME: Find a better heuristic for \"native musl toolchain is available\",\n         // based on host and linker path, for example.\n         // (https://github.com/rust-lang/rust/pull/71769#issuecomment-626330237).\n         Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n         Some(CrtObjectsFallback::Mingw) => {\n-            sess.host == sess.target.target\n-                && sess.target.target.target_vendor != \"uwp\"\n+            sess.host == sess.target\n+                && sess.target.target_vendor != \"uwp\"\n                 && detect_self_contained_mingw(&sess)\n         }\n         // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n@@ -1259,7 +1256,7 @@ fn add_pre_link_objects(\n     link_output_kind: LinkOutputKind,\n     self_contained: bool,\n ) {\n-    let opts = &sess.target.target.options;\n+    let opts = &sess.target.options;\n     let objects =\n         if self_contained { &opts.pre_link_objects_fallback } else { &opts.pre_link_objects };\n     for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n@@ -1274,7 +1271,7 @@ fn add_post_link_objects(\n     link_output_kind: LinkOutputKind,\n     self_contained: bool,\n ) {\n-    let opts = &sess.target.target.options;\n+    let opts = &sess.target.options;\n     let objects =\n         if self_contained { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n     for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n@@ -1285,21 +1282,21 @@ fn add_post_link_objects(\n /// Add arbitrary \"pre-link\" args defined by the target spec or from command line.\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_pre_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+    if let Some(args) = sess.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n     cmd.args(&sess.opts.debugging_opts.pre_link_args);\n }\n \n /// Add a link script embedded in the target, if applicable.\n fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_type: CrateType) {\n-    match (crate_type, &sess.target.target.options.link_script) {\n+    match (crate_type, &sess.target.options.link_script) {\n         (CrateType::Cdylib | CrateType::Executable, Some(script)) => {\n-            if !sess.target.target.options.linker_is_gnu {\n+            if !sess.target.options.linker_is_gnu {\n                 sess.fatal(\"can only use link script when linking with GNU-like linker\");\n             }\n \n-            let file_name = [\"rustc\", &sess.target.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n+            let file_name = [\"rustc\", &sess.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n \n             let path = tmpdir.join(file_name);\n             if let Err(e) = fs::write(&path, script) {\n@@ -1338,23 +1335,23 @@ fn add_late_link_args(\n             *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n         });\n     if any_dynamic_crate {\n-        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n+        if let Some(args) = sess.target.options.late_link_args_dynamic.get(&flavor) {\n             cmd.args(args);\n         }\n     } else {\n-        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n+        if let Some(args) = sess.target.options.late_link_args_static.get(&flavor) {\n             cmd.args(args);\n         }\n     }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+    if let Some(args) = sess.target.options.late_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n }\n \n /// Add arbitrary \"post-link\" args defined by the target spec.\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_post_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+    if let Some(args) = sess.target.options.post_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n }\n@@ -1456,7 +1453,7 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained:\n /// Add options making relocation sections in the produced ELF files read-only\n /// and suppressing lazy binding.\n fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) {\n-    match sess.opts.debugging_opts.relro_level.unwrap_or(sess.target.target.options.relro_level) {\n+    match sess.opts.debugging_opts.relro_level.unwrap_or(sess.target.options.relro_level) {\n         RelroLevel::Full => cmd.full_relro(),\n         RelroLevel::Partial => cmd.partial_relro(),\n         RelroLevel::Off => cmd.no_relro(),\n@@ -1487,9 +1484,9 @@ fn add_rpath_args(\n         let mut rpath_config = RPathConfig {\n             used_crates: &codegen_results.crate_info.used_crates_dynamic,\n             out_filename: out_filename.to_path_buf(),\n-            has_rpath: sess.target.target.options.has_rpath,\n-            is_like_osx: sess.target.target.options.is_like_osx,\n-            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n+            has_rpath: sess.target.options.has_rpath,\n+            is_like_osx: sess.target.options.is_like_osx,\n+            linker_is_gnu: sess.target.options.linker_is_gnu,\n             get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n@@ -1517,7 +1514,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     let base_cmd = get_linker(sess, path, flavor, crt_objects_fallback);\n     // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n     // to the linker args construction.\n-    assert!(base_cmd.get_args().is_empty() || sess.target.target.target_vendor == \"uwp\");\n+    assert!(base_cmd.get_args().is_empty() || sess.target.target_vendor == \"uwp\");\n     let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n     let link_output_kind = link_output_kind(sess, crate_type);\n \n@@ -1531,7 +1528,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_link_script(cmd, sess, tmpdir, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.target.target.options.is_like_fuchsia && crate_type == CrateType::Executable {\n+    if sess.target.options.is_like_fuchsia && crate_type == CrateType::Executable {\n         let prefix = if sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::ADDRESS) {\n             \"asan/\"\n         } else {\n@@ -1541,7 +1538,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.target.target.options.eh_frame_header {\n+    if sess.target.options.eh_frame_header {\n         cmd.add_eh_frame_header();\n     }\n \n@@ -1554,7 +1551,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_pre_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.target.target.options.is_like_emscripten {\n+    if sess.target.options.is_like_emscripten {\n         cmd.arg(\"-s\");\n         cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n             \"DISABLE_EXCEPTION_CATCHING=1\"\n@@ -1582,7 +1579,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     cmd.output_filename(out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    if crate_type == CrateType::Executable && sess.target.target.options.is_like_windows {\n+    if crate_type == CrateType::Executable && sess.target.options.is_like_windows {\n         if let Some(ref s) = codegen_results.windows_subsystem {\n             cmd.subsystem(s);\n         }\n@@ -1626,7 +1623,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // OBJECT-FILES-NO, AUDIT-ORDER\n     // We want to prevent the compiler from accidentally leaking in any system libraries,\n     // so by default we tell linkers not to link to any default libraries.\n-    if !sess.opts.cg.default_linker_libraries && sess.target.target.options.no_default_libraries {\n+    if !sess.opts.cg.default_linker_libraries && sess.target.options.no_default_libraries {\n         cmd.no_default_libraries();\n     }\n \n@@ -1845,12 +1842,8 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(config: &config::Config, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !config.target.options.is_like_windows {\n-            &stem[3..]\n-        } else {\n-            stem\n-        }\n+    fn unlib<'a>(target: &Target, stem: &'a str) -> &'a str {\n+        if stem.starts_with(\"lib\") && !target.options.is_like_windows { &stem[3..] } else { stem }\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n@@ -1945,7 +1938,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n                 // though, so we let that object file slide.\n                 let skip_because_lto = are_upstream_rust_objects_already_included(sess)\n                     && is_rust_object\n-                    && (sess.target.target.options.no_builtins\n+                    && (sess.target.options.no_builtins\n                         || !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n \n                 if skip_because_cfg_say_so || skip_because_lto {\n@@ -2088,10 +2081,10 @@ fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n }\n \n fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n-    let arch = &sess.target.target.arch;\n-    let os = &sess.target.target.target_os;\n-    let llvm_target = &sess.target.target.llvm_target;\n-    if sess.target.target.target_vendor != \"apple\"\n+    let arch = &sess.target.arch;\n+    let os = &sess.target.target_os;\n+    let llvm_target = &sess.target.llvm_target;\n+    if sess.target.target_vendor != \"apple\"\n         || !matches!(os.as_str(), \"ios\" | \"tvos\")\n         || flavor != LinkerFlavor::Gcc\n     {"}, {"sha": "3e13a1daecdef89e3636b23ed685b104b1bd4bb5", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -184,7 +184,7 @@ impl<'a> GccLinker<'a> {\n         // * On OSX they have their own linker, not binutils'\n         // * For WebAssembly the only functional linker is LLD, which doesn't\n         //   support hint flags\n-        !self.sess.target.target.options.is_like_osx && self.sess.target.target.arch != \"wasm32\"\n+        !self.sess.target.options.is_like_osx && self.sess.target.arch != \"wasm32\"\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -221,10 +221,8 @@ impl<'a> GccLinker<'a> {\n         let opt_level = match self.sess.opts.optimize {\n             config::OptLevel::No => \"O0\",\n             config::OptLevel::Less => \"O1\",\n-            config::OptLevel::Default => \"O2\",\n+            config::OptLevel::Default | config::OptLevel::Size | config::OptLevel::SizeMin => \"O2\",\n             config::OptLevel::Aggressive => \"O3\",\n-            config::OptLevel::Size => \"Os\",\n-            config::OptLevel::SizeMin => \"Oz\",\n         };\n \n         self.linker_arg(&format!(\"-plugin-opt={}\", opt_level));\n@@ -234,7 +232,7 @@ impl<'a> GccLinker<'a> {\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n         // On mac we need to tell the linker to let this library be rpathed\n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             self.cmd.arg(\"-dynamiclib\");\n             self.linker_arg(\"-dylib\");\n \n@@ -250,17 +248,17 @@ impl<'a> GccLinker<'a> {\n             }\n         } else {\n             self.cmd.arg(\"-shared\");\n-            if self.sess.target.target.options.is_like_windows {\n+            if self.sess.target.options.is_like_windows {\n                 // The output filename already contains `dll_suffix` so\n                 // the resulting import library will have a name in the\n                 // form of libfoo.dll.a\n                 let implib_name =\n                     out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n                         format!(\n                             \"{}{}{}\",\n-                            self.sess.target.target.options.staticlib_prefix,\n+                            self.sess.target.options.staticlib_prefix,\n                             file,\n-                            self.sess.target.target.options.staticlib_suffix\n+                            self.sess.target.options.staticlib_suffix\n                         )\n                     });\n                 if let Some(implib_name) = implib_name {\n@@ -282,7 +280,7 @@ impl<'a> Linker for GccLinker<'a> {\n     fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n         match output_kind {\n             LinkOutputKind::DynamicNoPicExe => {\n-                if !self.is_ld && self.sess.target.target.options.linker_is_gnu {\n+                if !self.is_ld && self.sess.target.options.linker_is_gnu {\n                     self.cmd.arg(\"-no-pie\");\n                 }\n             }\n@@ -293,7 +291,7 @@ impl<'a> Linker for GccLinker<'a> {\n             LinkOutputKind::StaticNoPicExe => {\n                 // `-static` works for both gcc wrapper and ld.\n                 self.cmd.arg(\"-static\");\n-                if !self.is_ld && self.sess.target.target.options.linker_is_gnu {\n+                if !self.is_ld && self.sess.target.options.linker_is_gnu {\n                     self.cmd.arg(\"-no-pie\");\n                 }\n             }\n@@ -322,7 +320,7 @@ impl<'a> Linker for GccLinker<'a> {\n         // any `#[link]` attributes in the `libc` crate, see #72782 for details.\n         // FIXME: Switch to using `#[link]` attributes in the `libc` crate\n         // similarly to other targets.\n-        if self.sess.target.target.target_os == \"vxworks\"\n+        if self.sess.target.target_os == \"vxworks\"\n             && matches!(\n                 output_kind,\n                 LinkOutputKind::StaticNoPicExe\n@@ -387,7 +385,7 @@ impl<'a> Linker for GccLinker<'a> {\n     // functions, etc.\n     fn link_whole_staticlib(&mut self, lib: Symbol, search_path: &[PathBuf]) {\n         self.hint_static();\n-        let target = &self.sess.target.target;\n+        let target = &self.sess.target;\n         if !target.options.is_like_osx {\n             self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\", lib));\n             self.linker_arg(\"--no-whole-archive\");\n@@ -402,7 +400,7 @@ impl<'a> Linker for GccLinker<'a> {\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n         self.hint_static();\n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             self.linker_arg(\"-force_load\");\n             self.linker_arg(&lib);\n         } else {\n@@ -426,9 +424,9 @@ impl<'a> Linker for GccLinker<'a> {\n         // -dead_strip can't be part of the pre_link_args because it's also used\n         // for partial linking when using multiple codegen units (-r).  So we\n         // insert it here.\n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             self.linker_arg(\"-dead_strip\");\n-        } else if self.sess.target.target.options.is_like_solaris {\n+        } else if self.sess.target.options.is_like_solaris {\n             self.linker_arg(\"-zignore\");\n \n         // If we're building a dylib, we don't use --gc-sections because LLVM\n@@ -442,7 +440,7 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn optimize(&mut self) {\n-        if !self.sess.target.target.options.linker_is_gnu {\n+        if !self.sess.target.options.linker_is_gnu {\n             return;\n         }\n \n@@ -456,7 +454,7 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn pgo_gen(&mut self) {\n-        if !self.sess.target.target.options.linker_is_gnu {\n+        if !self.sess.target.options.linker_is_gnu {\n             return;\n         }\n \n@@ -506,7 +504,7 @@ impl<'a> Linker for GccLinker<'a> {\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // Symbol visibility in object files typically takes care of this.\n         if crate_type == CrateType::Executable\n-            && self.sess.target.target.options.override_export_symbols.is_none()\n+            && self.sess.target.options.override_export_symbols.is_none()\n         {\n             return;\n         }\n@@ -515,21 +513,21 @@ impl<'a> Linker for GccLinker<'a> {\n         // The object files have far more public symbols than we actually want to export,\n         // so we hide them all here.\n \n-        if !self.sess.target.target.options.limit_rdylib_exports {\n+        if !self.sess.target.options.limit_rdylib_exports {\n             return;\n         }\n \n         if crate_type == CrateType::ProcMacro {\n             return;\n         }\n \n-        let is_windows = self.sess.target.target.options.is_like_windows;\n+        let is_windows = self.sess.target.options.is_like_windows;\n         let mut arg = OsString::new();\n         let path = tmpdir.join(if is_windows { \"list.def\" } else { \"list\" });\n \n         debug!(\"EXPORTED SYMBOLS:\");\n \n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             // Write a plain, newline-separated list of symbols\n             let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n@@ -575,12 +573,12 @@ impl<'a> Linker for GccLinker<'a> {\n             }\n         }\n \n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             if !self.is_ld {\n                 arg.push(\"-Wl,\")\n             }\n             arg.push(\"-exported_symbols_list,\");\n-        } else if self.sess.target.target.options.is_like_solaris {\n+        } else if self.sess.target.options.is_like_solaris {\n             if !self.is_ld {\n                 arg.push(\"-Wl,\")\n             }\n@@ -1205,7 +1203,7 @@ impl<'a> Linker for WasmLd<'a> {\n }\n \n fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n-    if let Some(ref exports) = tcx.sess.target.target.options.override_export_symbols {\n+    if let Some(ref exports) = tcx.sess.target.options.override_export_symbols {\n         return exports.clone();\n     }\n \n@@ -1295,7 +1293,7 @@ impl<'a> Linker for PtxLinker<'a> {\n         // Provide the linker with fallback to internal `target-cpu`.\n         self.cmd.arg(\"--fallback-arch\").arg(match self.sess.opts.cg.target_cpu {\n             Some(ref s) => s,\n-            None => &self.sess.target.target.options.cpu,\n+            None => &self.sess.target.options.cpu,\n         });\n     }\n "}, {"sha": "dd8d751d0459111eccfe91743754e376173bd829", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -229,8 +229,8 @@ fn exported_symbols_provider_local(\n         // needs to be exported.\n         // However, on platforms that don't allow for Rust dylibs, having\n         // external linkage is enough for monomorphization to be linked to.\n-        let need_visibility = tcx.sess.target.target.options.dynamic_linking\n-            && !tcx.sess.target.target.options.only_cdylib;\n+        let need_visibility =\n+            tcx.sess.target.options.dynamic_linking && !tcx.sess.target.options.only_cdylib;\n \n         let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n \n@@ -391,7 +391,7 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n \n     if is_extern && !std_internal {\n-        let target = &tcx.sess.target.target.llvm_target;\n+        let target = &tcx.sess.target.llvm_target;\n         // WebAssembly cannot export data symbols, so reduce their export level\n         if target.contains(\"emscripten\") {\n             if let Some(Node::Item(&hir::Item { kind: hir::ItemKind::Static(..), .. })) ="}, {"sha": "4d2cea18dcc6887fc65f6091d9b2e0be8805a43a", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -13,7 +13,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n-use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n use rustc_errors::{DiagnosticId, FatalError, Handler, Level};\n@@ -140,7 +139,7 @@ impl ModuleConfig {\n \n         let emit_obj = if !should_emit_obj {\n             EmitObj::None\n-        } else if sess.target.target.options.obj_is_bitcode\n+        } else if sess.target.options.obj_is_bitcode\n             || (sess.opts.cg.linker_plugin_lto.enabled() && !no_builtins)\n         {\n             // This case is selected if the target uses objects as bitcode, or\n@@ -222,11 +221,11 @@ impl ModuleConfig {\n                 false\n             ),\n             emit_obj,\n-            bc_cmdline: sess.target.target.options.bitcode_llvm_cmdline.clone(),\n+            bc_cmdline: sess.target.options.bitcode_llvm_cmdline.clone(),\n \n             verify_llvm_ir: sess.verify_llvm_ir(),\n             no_prepopulate_passes: sess.opts.cg.no_prepopulate_passes,\n-            no_builtins: no_builtins || sess.target.target.options.no_builtins,\n+            no_builtins: no_builtins || sess.target.options.no_builtins,\n \n             // Exclude metadata and allocator modules from time_passes output,\n             // since they throw off the \"LLVM passes\" measurement.\n@@ -253,7 +252,7 @@ impl ModuleConfig {\n                 .opts\n                 .debugging_opts\n                 .merge_functions\n-                .unwrap_or(sess.target.target.options.merge_functions)\n+                .unwrap_or(sess.target.options.merge_functions)\n             {\n                 MergeFunctions::Disabled => false,\n                 MergeFunctions::Trampolines | MergeFunctions::Aliases => {\n@@ -308,7 +307,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub allocator_module_config: Arc<ModuleConfig>,\n     pub tm_factory: TargetMachineFactory<B>,\n     pub msvc_imps_needed: bool,\n-    pub target_pointer_width: String,\n+    pub target_pointer_width: u32,\n     pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n \n@@ -389,7 +388,7 @@ fn need_bitcode_in_object(sess: &Session) -> bool {\n     let requested_for_rlib = sess.opts.cg.embed_bitcode\n         && sess.crate_types().contains(&CrateType::Rlib)\n         && sess.opts.output_types.contains_key(&OutputType::Exe);\n-    let forced_by_target = sess.target.target.options.forces_embed_bitcode;\n+    let forced_by_target = sess.target.options.forces_embed_bitcode;\n     requested_for_rlib || forced_by_target\n }\n \n@@ -414,7 +413,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n-    let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let no_builtins = tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n     let is_compiler_builtins =\n         tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n@@ -463,7 +461,6 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     OngoingCodegen {\n         backend,\n         crate_name,\n-        crate_hash,\n         metadata,\n         windows_subsystem,\n         linker_info,\n@@ -658,15 +655,6 @@ fn produce_final_output_artifacts(\n     // These are used in linking steps and will be cleaned up afterward.\n }\n \n-pub fn dump_incremental_data(_codegen_results: &CodegenResults) {\n-    // FIXME(mw): This does not work at the moment because the situation has\n-    //            become more complicated due to incremental LTO. Now a CGU\n-    //            can have more than two caching states.\n-    // println!(\"[incremental] Re-using {} out of {} modules\",\n-    //           codegen_results.modules.iter().filter(|m| m.pre_existing).count(),\n-    //           codegen_results.modules.len());\n-}\n-\n pub enum WorkItem<B: WriteBackendMethods> {\n     /// Optimize a newly codegened, totally unoptimized module.\n     Optimize(ModuleCodegen<B::Module>),\n@@ -1034,8 +1022,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         tm_factory: TargetMachineFactory(backend.target_machine_factory(tcx.sess, ol)),\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n-        target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n-        target_arch: tcx.sess.target.target.arch.clone(),\n+        target_pointer_width: tcx.sess.target.pointer_width,\n+        target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n     };\n \n@@ -1175,7 +1163,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // necessary. There's already optimizations in place to avoid sending work\n     // back to the coordinator if LTO isn't requested.\n     return thread::spawn(move || {\n-        let max_workers = ::num_cpus::get();\n+        let max_workers = num_cpus::get();\n         let mut worker_id_counter = 0;\n         let mut free_worker_ids = Vec::new();\n         let mut get_worker_id = |free_worker_ids: &mut Vec<usize>| {\n@@ -1531,8 +1519,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     }\n }\n \n-pub const CODEGEN_WORKER_ID: usize = usize::MAX;\n-\n /// `FatalError` is explicitly not `Send`.\n #[must_use]\n pub struct WorkerFatalError;\n@@ -1720,7 +1706,6 @@ impl SharedEmitterMain {\n pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub backend: B,\n     pub crate_name: Symbol,\n-    pub crate_hash: Svh,\n     pub metadata: EncodedMetadata,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: LinkerInfo,\n@@ -1766,7 +1751,6 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         (\n             CodegenResults {\n                 crate_name: self.crate_name,\n-                crate_hash: self.crate_hash,\n                 metadata: self.metadata,\n                 windows_subsystem: self.windows_subsystem,\n                 linker_info: self.linker_info,\n@@ -1881,11 +1865,11 @@ fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     // something is wrong with commandline arg validation.\n     assert!(\n         !(tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-            && tcx.sess.target.target.options.is_like_windows\n+            && tcx.sess.target.options.is_like_windows\n             && tcx.sess.opts.cg.prefer_dynamic)\n     );\n \n-    tcx.sess.target.target.options.is_like_windows &&\n+    tcx.sess.target.options.is_like_windows &&\n         tcx.sess.crate_types().iter().any(|ct| *ct == CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing"}, {"sha": "4d9376091320d2eacb9b3eb2700725b0129b009a", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -327,7 +327,7 @@ fn cast_shift_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n /// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n /// 64-bit MinGW) instead of \"full SEH\".\n pub fn wants_msvc_seh(sess: &Session) -> bool {\n-    sess.target.target.options.is_like_msvc\n+    sess.target.options.is_like_msvc\n }\n \n pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n@@ -393,7 +393,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n         // depending on whether the target needs `argc` and `argv` to be passed in.\n-        let llfty = if cx.sess().target.target.options.main_needs_argc_argv {\n+        let llfty = if cx.sess().target.options.main_needs_argc_argv {\n             cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int())\n         } else {\n             cx.type_func(&[], cx.type_int())\n@@ -464,7 +464,7 @@ fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     bx: &mut Bx,\n ) -> (Bx::Value, Bx::Value) {\n-    if cx.sess().target.target.options.main_needs_argc_argv {\n+    if cx.sess().target.options.main_needs_argc_argv {\n         // Params from native `main()` used as args for rust start function\n         let param_argc = bx.get_param(0);\n         let param_argv = bx.get_param(1);\n@@ -479,8 +479,6 @@ fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub const CODEGEN_WORKER_ID: usize = usize::MAX;\n-\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'tcx>,\n@@ -695,7 +693,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         total_codegen_time.into_inner(),\n     );\n \n-    ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n+    rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n \n     symbol_names_test::report_symbol_names(tcx);\n \n@@ -754,8 +752,8 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n }\n \n fn finalize_tcx(tcx: TyCtxt<'_>) {\n-    tcx.sess.time(\"assert_dep_graph\", || ::rustc_incremental::assert_dep_graph(tcx));\n-    tcx.sess.time(\"serialize_dep_graph\", || ::rustc_incremental::save_dep_graph(tcx));\n+    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n+    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n \n     // We assume that no queries are run past here. If there are new queries\n     // after this point, they'll show up as \"<unknown>\" in self-profiling data."}, {"sha": "c4c51d146a60635565ed7e14ae7dd80e5b0a20dd", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -33,7 +33,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n ) {\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let cpp_like_names = tcx.sess.target.target.options.is_like_msvc;\n+    let cpp_like_names = tcx.sess.target.options.is_like_msvc;\n \n     match *t.kind() {\n         ty::Bool => output.push_str(\"bool\"),"}, {"sha": "70b92b234e94c10803ab30e6514348481197d53d", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -21,7 +21,6 @@ extern crate tracing;\n extern crate rustc_middle;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::LangItem;\n@@ -134,7 +133,6 @@ pub struct CodegenResults {\n     pub modules: Vec<CompiledModule>,\n     pub allocator_module: Option<CompiledModule>,\n     pub metadata_module: Option<CompiledModule>,\n-    pub crate_hash: Svh,\n     pub metadata: rustc_middle::middle::cstore::EncodedMetadata,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo,\n@@ -144,6 +142,7 @@ pub struct CodegenResults {\n pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n     crate::base::provide_both(providers);\n+    crate::target_features::provide(providers);\n }\n \n pub fn provide_extern(providers: &mut Providers) {"}, {"sha": "a051ae25a9c17509980841df3d879459ef525e62", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -12,9 +12,9 @@ use crate::MemFlags;\n use rustc_ast as ast;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::AssertKind;\n+use rustc_middle::mir::{self, SwitchTargets};\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n@@ -24,8 +24,6 @@ use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::abi::{self, LayoutOf};\n use rustc_target::spec::abi::Abi;\n \n-use std::borrow::Cow;\n-\n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n /// e.g., creating a basic block, calling a function, etc.\n struct TerminatorCodegenHelper<'tcx> {\n@@ -198,42 +196,37 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         mut bx: Bx,\n         discr: &mir::Operand<'tcx>,\n         switch_ty: Ty<'tcx>,\n-        values: &Cow<'tcx, [u128]>,\n-        targets: &Vec<mir::BasicBlock>,\n+        targets: &SwitchTargets,\n     ) {\n         let discr = self.codegen_operand(&mut bx, &discr);\n         // `switch_ty` is redundant, sanity-check that.\n         assert_eq!(discr.layout.ty, switch_ty);\n-        if targets.len() == 2 {\n-            // If there are two targets, emit br instead of switch\n-            let lltrue = helper.llblock(self, targets[0]);\n-            let llfalse = helper.llblock(self, targets[1]);\n+        helper.maybe_sideeffect(self.mir, &mut bx, targets.all_targets());\n+\n+        let mut target_iter = targets.iter();\n+        if target_iter.len() == 1 {\n+            // If there are two targets (one conditional, one fallback), emit br instead of switch\n+            let (test_value, target) = target_iter.next().unwrap();\n+            let lltrue = helper.llblock(self, target);\n+            let llfalse = helper.llblock(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n-                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n-                if let [0] = values[..] {\n-                    bx.cond_br(discr.immediate(), llfalse, lltrue);\n-                } else {\n-                    assert_eq!(&values[..], &[1]);\n-                    bx.cond_br(discr.immediate(), lltrue, llfalse);\n+                match test_value {\n+                    0 => bx.cond_br(discr.immediate(), llfalse, lltrue),\n+                    1 => bx.cond_br(discr.immediate(), lltrue, llfalse),\n+                    _ => bug!(),\n                 }\n             } else {\n                 let switch_llty = bx.immediate_backend_type(bx.layout_of(switch_ty));\n-                let llval = bx.const_uint_big(switch_llty, values[0]);\n+                let llval = bx.const_uint_big(switch_llty, test_value);\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n-                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n         } else {\n-            helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n-            let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n-                helper.llblock(self, *otherwise),\n-                values\n-                    .iter()\n-                    .zip(targets)\n-                    .map(|(&value, target)| (value, helper.llblock(self, *target))),\n+                helper.llblock(self, targets.otherwise()),\n+                target_iter.map(|(value, target)| (value, helper.llblock(self, target))),\n             );\n         }\n     }\n@@ -879,7 +872,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let string = match ty.kind() {\n                             ty::Uint(_) => value.to_string(),\n                             ty::Int(int_ty) => {\n-                                match int_ty.normalize(bx.tcx().sess.target.ptr_width) {\n+                                match int_ty.normalize(bx.tcx().sess.target.pointer_width) {\n                                     ast::IntTy::I8 => (value as i8).to_string(),\n                                     ast::IntTy::I16 => (value as i16).to_string(),\n                                     ast::IntTy::I32 => (value as i32).to_string(),\n@@ -975,8 +968,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 helper.funclet_br(self, &mut bx, target);\n             }\n \n-            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                self.codegen_switchint_terminator(helper, bx, discr, switch_ty, values, targets);\n+            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n+                self.codegen_switchint_terminator(helper, bx, discr, switch_ty, targets);\n             }\n \n             mir::TerminatorKind::Return => {"}, {"sha": "2bf1ee43c736636cc2239eb86342da45f7a17257", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -580,8 +580,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n // stuffs.\n fn int_type_width_signed(ty: Ty<'_>, tcx: TyCtxt<'_>) -> Option<(u64, bool)> {\n     match ty.kind() {\n-        ty::Int(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), true)),\n-        ty::Uint(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), false)),\n+        ty::Int(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.pointer_width)), true))\n+        }\n+        ty::Uint(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.pointer_width)), false))\n+        }\n         _ => None,\n     }\n }"}, {"sha": "e1cc0268723a7f2d633b88e92f55ad26ec272be2", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -346,8 +346,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n-                    if bx.cx().sess().target.target.arch == \"arm\"\n-                        || bx.cx().sess().target.target.arch == \"aarch64\"\n+                    if bx.cx().sess().target.arch == \"arm\"\n+                        || bx.cx().sess().target.arch == \"aarch64\"\n                     {\n                         // FIXME(#34427): as workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value."}, {"sha": "a8d88a95f7a27d89b15d16d9a16168edc2a6d87a", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,3 +1,5 @@\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::ty::query::Providers;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n@@ -136,7 +138,7 @@ pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol\n }\n \n pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n-    match &*sess.target.target.arch {\n+    match &*sess.target.arch {\n         \"arm\" => ARM_ALLOWED_FEATURES,\n         \"aarch64\" => AARCH64_ALLOWED_FEATURES,\n         \"x86\" | \"x86_64\" => X86_ALLOWED_FEATURES,\n@@ -148,3 +150,16 @@ pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Opt\n         _ => &[],\n     }\n }\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    providers.supported_target_features = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        if tcx.sess.opts.actually_rustdoc {\n+            // rustdoc needs to be able to document functions that use all the features, so\n+            // whitelist them all\n+            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n+        } else {\n+            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n+        }\n+    };\n+}"}, {"sha": "3fb189e19844deb826543d23def23cd0c57e7101", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,11 @@\n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n-use crate::ModuleCodegen;\n+use crate::{CodegenResults, ModuleCodegen};\n \n use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::ErrorReported;\n-use rustc_middle::dep_graph::DepGraph;\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::query::Providers;\n@@ -80,8 +81,7 @@ pub trait CodegenBackend {\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n         sess: &Session,\n-        dep_graph: &DepGraph,\n-    ) -> Result<Box<dyn Any>, ErrorReported>;\n+    ) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorReported>;\n \n     /// This is called on the returned `Box<dyn Any>` from `join_codegen`\n     ///\n@@ -91,7 +91,7 @@ pub trait CodegenBackend {\n     fn link(\n         &self,\n         sess: &Session,\n-        codegen_results: Box<dyn Any>,\n+        codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorReported>;\n }\n@@ -124,4 +124,5 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         opt_level: config::OptLevel,\n     ) -> Arc<dyn Fn() -> Result<Self::TargetMachine, String> + Send + Sync>;\n     fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str;\n+    fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str>;\n }"}, {"sha": "82518b7f0c388a948b1c6d38518c41a6d8c815f7", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -85,7 +85,7 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n }\n \n pub trait HasCodegen<'tcx>:\n-    Backend<'tcx> + ::std::ops::Deref<Target = <Self as HasCodegen<'tcx>>::CodegenCx>\n+    Backend<'tcx> + std::ops::Deref<Target = <Self as HasCodegen<'tcx>>::CodegenCx>\n {\n     type CodegenCx: CodegenMethods<'tcx>\n         + BackendTypes<"}, {"sha": "43bc0c831558fae8b7c0ba9461574085cc336de5", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -51,7 +51,7 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_int(&self) -> Self::Type {\n-        match &self.sess().target.target.target_c_int_width[..] {\n+        match &self.sess().target.target_c_int_width[..] {\n             \"16\" => self.type_i16(),\n             \"32\" => self.type_i32(),\n             \"64\" => self.type_i64(),"}, {"sha": "ec2f9597b1827cc7108e2008a01c6bdc5c936e40", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -71,8 +71,8 @@ impl Fingerprint {\n     }\n }\n \n-impl ::std::fmt::Display for Fingerprint {\n-    fn fmt(&self, formatter: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n+impl std::fmt::Display for Fingerprint {\n+    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(formatter, \"{:x}-{:x}\", self.0, self.1)\n     }\n }"}, {"sha": "c0193e9fa0c4e6794af88c0d20e0125d5ab52c61", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -129,7 +129,7 @@ pub enum ProcessResult<O, E> {\n struct ObligationTreeId(usize);\n \n type ObligationTreeIdGenerator =\n-    ::std::iter::Map<::std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n+    std::iter::Map<std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n \n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to `process_obligations`,"}, {"sha": "9a28f8f4e21062d5040d9acec2c8da20150b950f", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -93,7 +93,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n     /// Iterate over elements, sorted by key\n     #[inline]\n-    pub fn iter(&self) -> ::std::slice::Iter<'_, (K, V)> {\n+    pub fn iter(&self) -> std::slice::Iter<'_, (K, V)> {\n         self.data.iter()\n     }\n \n@@ -134,7 +134,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n         R: RangeBounds<K>,\n     {\n         let (start, end) = self.range_slice_indices(range);\n-        self.data.splice(start..end, ::std::iter::empty());\n+        self.data.splice(start..end, std::iter::empty());\n     }\n \n     /// Mutate all keys with the given function `f`. This mutation must not\n@@ -241,7 +241,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n impl<K: Ord, V> IntoIterator for SortedMap<K, V> {\n     type Item = (K, V);\n-    type IntoIter = ::std::vec::IntoIter<(K, V)>;\n+    type IntoIter = std::vec::IntoIter<(K, V)>;\n \n     fn into_iter(self) -> Self::IntoIter {\n         self.data.into_iter()"}, {"sha": "579eb1cb7da661e741b99f1e43984367fcc56255", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -20,7 +20,7 @@ pub struct StableHasher {\n }\n \n impl ::std::fmt::Debug for StableHasher {\n-    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(f, \"{:?}\", self.state)\n     }\n }"}, {"sha": "cc562bc1e4d914be4eb6a707a6eae9233ea5b4a0", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -14,12 +14,6 @@ pub struct WorkQueue<T: Idx> {\n }\n \n impl<T: Idx> WorkQueue<T> {\n-    /// Creates a new work queue with all the elements from (0..len).\n-    #[inline]\n-    pub fn with_all(len: usize) -> Self {\n-        WorkQueue { deque: (0..len).map(T::new).collect(), set: BitSet::new_filled(len) }\n-    }\n-\n     /// Creates a new work queue that starts empty, where elements range from (0..len).\n     #[inline]\n     pub fn with_none(len: usize) -> Self {"}, {"sha": "0adc006b6244ec5708c3a37eed204e38947c713e", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -10,7 +10,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n libc = \"0.2\"\n tracing = { version = \"0.1.18\" }\n-tracing-subscriber = { version = \"0.2.10\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n+tracing-subscriber = { version = \"0.2.13\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n tracing-tree = \"0.1.6\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }"}, {"sha": "d99e335a77a000ca076fca569d4d11fd2ad52486", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -134,9 +134,52 @@ pub fn diagnostics_registry() -> Registry {\n     Registry::new(&rustc_error_codes::DIAGNOSTICS)\n }\n \n+pub struct RunCompiler<'a, 'b> {\n+    at_args: &'a [String],\n+    callbacks: &'b mut (dyn Callbacks + Send),\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    emitter: Option<Box<dyn Write + Send>>,\n+    make_codegen_backend:\n+        Option<Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>>,\n+}\n+\n+impl<'a, 'b> RunCompiler<'a, 'b> {\n+    pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n+        Self { at_args, callbacks, file_loader: None, emitter: None, make_codegen_backend: None }\n+    }\n+    pub fn set_make_codegen_backend(\n+        &mut self,\n+        make_codegen_backend: Option<\n+            Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n+        >,\n+    ) -> &mut Self {\n+        self.make_codegen_backend = make_codegen_backend;\n+        self\n+    }\n+    pub fn set_emitter(&mut self, emitter: Option<Box<dyn Write + Send>>) -> &mut Self {\n+        self.emitter = emitter;\n+        self\n+    }\n+    pub fn set_file_loader(\n+        &mut self,\n+        file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    ) -> &mut Self {\n+        self.file_loader = file_loader;\n+        self\n+    }\n+    pub fn run(self) -> interface::Result<()> {\n+        run_compiler(\n+            self.at_args,\n+            self.callbacks,\n+            self.file_loader,\n+            self.emitter,\n+            self.make_codegen_backend,\n+        )\n+    }\n+}\n // Parse args and run the compiler. This is the primary entry point for rustc.\n // The FileLoader provides a way to load files from sources other than the file system.\n-pub fn run_compiler(\n+fn run_compiler(\n     at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),\n     file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n@@ -155,8 +198,7 @@ pub fn run_compiler(\n             ),\n         }\n     }\n-    let diagnostic_output =\n-        emitter.map(|emitter| DiagnosticOutput::Raw(emitter)).unwrap_or(DiagnosticOutput::Default);\n+    let diagnostic_output = emitter.map_or(DiagnosticOutput::Default, DiagnosticOutput::Raw);\n     let matches = match handle_options(&args) {\n         Some(matches) => matches,\n         None => return Ok(()),\n@@ -600,7 +642,7 @@ impl RustcDefaultCalls {\n             let codegen_results: CodegenResults = json::decode(&rlink_data).unwrap_or_else(|err| {\n                 sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n             });\n-            compiler.codegen_backend().link(&sess, Box::new(codegen_results), &outputs)\n+            compiler.codegen_backend().link(&sess, codegen_results, &outputs)\n         } else {\n             sess.fatal(\"rlink must be a file\")\n         }\n@@ -628,7 +670,7 @@ impl RustcDefaultCalls {\n                 Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target.target, path, metadata_loader, &mut v)\n+                    locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v)\n                         .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n                 }\n@@ -672,7 +714,8 @@ impl RustcDefaultCalls {\n         for req in &sess.opts.prints {\n             match *req {\n                 TargetList => {\n-                    let mut targets = rustc_target::spec::get_targets().collect::<Vec<String>>();\n+                    let mut targets =\n+                        rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n                     targets.sort();\n                     println!(\"{}\", targets.join(\"\\n\"));\n                 }\n@@ -681,7 +724,7 @@ impl RustcDefaultCalls {\n                     \"{}\",\n                     sess.target_tlib_path.as_ref().unwrap_or(&sess.host_tlib_path).dir.display()\n                 ),\n-                TargetSpec => println!(\"{}\", sess.target.target.to_json().pretty()),\n+                TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n                 FileNames | CrateName => {\n                     let input = input.unwrap_or_else(|| {\n                         early_error(ErrorOutputType::default(), \"no input file provided\")\n@@ -1215,9 +1258,9 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // If backtraces are enabled, also print the query stack\n     let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n \n-    if backtrace {\n-        TyCtxt::try_print_query_stack(&handler);\n-    }\n+    let num_frames = if backtrace { None } else { Some(2) };\n+\n+    TyCtxt::try_print_query_stack(&handler, num_frames);\n \n     #[cfg(windows)]\n     unsafe {\n@@ -1285,7 +1328,7 @@ pub fn main() -> ! {\n                 })\n             })\n             .collect::<Vec<_>>();\n-        run_compiler(&args, &mut callbacks, None, None, None)\n+        RunCompiler::new(&args, &mut callbacks).run()\n     });\n     // The extra `\\t` is necessary to align this label with the others.\n     print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());"}, {"sha": "0a88759f84c9ab77975922a5bbb86cbff2b43fb1", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -460,6 +460,8 @@ E0774: include_str!(\"./error_codes/E0774.md\"),\n E0775: include_str!(\"./error_codes/E0775.md\"),\n E0776: include_str!(\"./error_codes/E0776.md\"),\n E0777: include_str!(\"./error_codes/E0777.md\"),\n+E0778: include_str!(\"./error_codes/E0778.md\"),\n+E0779: include_str!(\"./error_codes/E0779.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "2c22b86af9246045d7b7710c8860b46d9af2fdf5", "filename": "compiler/rustc_error_codes/src/error_codes/E0007.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,3 +1,5 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n This error indicates that the bindings in a match arm would require a value to\n be moved into more than one location, thus violating unique ownership. Code\n like the following is invalid as it requires the entire `Option<String>` to be\n@@ -6,11 +8,13 @@ inner `String` to be moved into a variable called `s`.\n \n Erroneous code example:\n \n-```compile_fail,E0007\n+```compile_fail,E0382\n+#![feature(bindings_after_at)]\n+\n let x = Some(\"s\".to_string());\n \n match x {\n-    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n+    op_string @ Some(s) => {}, // error: use of moved value\n     None => {},\n }\n ```"}, {"sha": "a58c16b59e91e3f1318badda8105faa4afa34cca", "filename": "compiler/rustc_error_codes/src/error_codes/E0424.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0424.md", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0424.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0424.md?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -21,7 +21,7 @@ impl Foo {\n The `self` keyword can only be used inside methods, which are associated\n functions (functions defined inside of a `trait` or `impl` block) that have a\n `self` receiver as its first parameter, like `self`, `&self`, `&mut self` or\n-`self: &mut Pin<Self>` (this last one is an example of an [\"abitrary `self`\n+`self: &mut Pin<Self>` (this last one is an example of an [\"arbitrary `self`\n type\"](https://github.com/rust-lang/rust/issues/44874)).\n \n Check if the associated function's parameter list should have contained a `self`"}, {"sha": "bc2244219156cae0f4c725b39a23f21d93448365", "filename": "compiler/rustc_error_codes/src/error_codes/E0723.md", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0723.md", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0723.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0723.md?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -3,12 +3,8 @@ An unstable feature in `const` contexts was used.\n Erroneous code example:\n \n ```compile_fail,E0723\n-trait T {}\n-\n-impl T for () {}\n-\n-const fn foo() -> impl T { // error: `impl Trait` in const fn is unstable\n-    ()\n+const fn foo<T: Copy>(_: T) { // error!\n+   // ...\n }\n ```\n \n@@ -18,11 +14,7 @@ feature flag:\n ```\n #![feature(const_fn)]\n \n-trait T {}\n-\n-impl T for () {}\n-\n-const fn foo() -> impl T {\n-    ()\n+const fn foo<T: Copy>(_: T) { // ok!\n+   // ...\n }\n ```"}, {"sha": "467362dca58fdf15fe3d694463661b80e50a9a1a", "filename": "compiler/rustc_error_codes/src/error_codes/E0778.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0778.md", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0778.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0778.md?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -0,0 +1,35 @@\n+The `instruction_set` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0778\n+#![feature(isa_attribute)]\n+\n+#[instruction_set()] // error: expected one argument\n+pub fn something() {}\n+fn main() {}\n+```\n+\n+The parenthesized `instruction_set` attribute requires the parameter to be\n+specified:\n+\n+```\n+#![feature(isa_attribute)]\n+\n+#[cfg_attr(target_arch=\"arm\", instruction_set(arm::a32))]\n+fn something() {}\n+```\n+\n+or:\n+\n+```\n+#![feature(isa_attribute)]\n+\n+#[cfg_attr(target_arch=\"arm\", instruction_set(arm::t32))]\n+fn something() {}\n+```\n+\n+For more information see the [`instruction_set` attribute][isa-attribute]\n+section of the Reference.\n+\n+[isa-attribute]: https://doc.rust-lang.org/reference/attributes/codegen.html"}, {"sha": "146e20c262659213cf4337ab751457433c84800d", "filename": "compiler/rustc_error_codes/src/error_codes/E0779.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0779.md", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0779.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0779.md?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -0,0 +1,32 @@\n+An unknown argument was given to the `instruction_set` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0779\n+#![feature(isa_attribute)]\n+\n+#[instruction_set(intel::x64)] // error: invalid argument\n+pub fn something() {}\n+fn main() {}\n+```\n+\n+The `instruction_set` attribute only supports two arguments currently:\n+\n+ * arm::a32\n+ * arm::t32\n+\n+All other arguments given to the `instruction_set` attribute will return this\n+error. Example:\n+\n+```\n+#![feature(isa_attribute)]\n+\n+#[cfg_attr(target_arch=\"arm\", instruction_set(arm::a32))] // ok!\n+pub fn something() {}\n+fn main() {}\n+```\n+\n+For more information see the [`instruction_set` attribute][isa-attribute]\n+section of the Reference.\n+\n+[isa-attribute]: https://doc.rust-lang.org/reference/attributes/codegen.html"}, {"sha": "91bfc6296b1c7413c3bad5e98b6b7d4218faec1e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -121,11 +121,6 @@ impl Diagnostic {\n         self.level == Level::Cancelled\n     }\n \n-    /// Set the sorting span.\n-    pub fn set_sort_span(&mut self, sp: Span) {\n-        self.sort_span = sp;\n-    }\n-\n     /// Adds a span/label to be included in the resulting snippet.\n     ///\n     /// This is pushed onto the [`MultiSpan`] that was created when the diagnostic\n@@ -535,14 +530,6 @@ impl Diagnostic {\n         &self.message\n     }\n \n-    /// Used by a lint. Copies over all details *but* the \"main\n-    /// message\".\n-    pub fn copy_details_not_message(&mut self, from: &Diagnostic) {\n-        self.span = from.span.clone();\n-        self.code = from.code.clone();\n-        self.children.extend(from.children.iter().cloned())\n-    }\n-\n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n     pub fn sub("}, {"sha": "b5155f8e910d7049654d6a2273ffdbca25a8c98f", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -510,8 +510,6 @@ impl Emitter for SilentEmitter {\n     fn emit_diagnostic(&mut self, _: &Diagnostic) {}\n }\n \n-/// Maximum number of lines we will print for each error; arbitrary.\n-pub const MAX_HIGHLIGHT_LINES: usize = 6;\n /// Maximum number of lines we will print for a multiline suggestion; arbitrary.\n ///\n /// This should be replaced with a more involved mechanism to output multiline suggestions that"}, {"sha": "b0e43a260e91de82cd5aaa6cbeb8f8f9f0bef87c", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -148,17 +148,6 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn map_item_or<F, G>(self, mut f: F, mut or: G) -> Annotatable\n-    where\n-        F: FnMut(P<ast::Item>) -> P<ast::Item>,\n-        G: FnMut(Annotatable) -> Annotatable,\n-    {\n-        match self {\n-            Annotatable::Item(i) => Annotatable::Item(f(i)),\n-            _ => or(self),\n-        }\n-    }\n-\n     pub fn expect_trait_item(self) -> P<ast::AssocItem> {\n         match self {\n             Annotatable::TraitItem(i) => i,\n@@ -1052,9 +1041,6 @@ impl<'a> ExtCtxt<'a> {\n             .chain(components.iter().map(|&s| Ident::with_dummy_span(s)))\n             .collect()\n     }\n-    pub fn name_of(&self, st: &str) -> Symbol {\n-        Symbol::intern(st)\n-    }\n \n     pub fn check_unused_macros(&mut self) {\n         self.resolver.check_unused_macros();"}, {"sha": "1c9bfb902d61a95ae7da7e33e3dc123352d9b83a", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -139,24 +139,6 @@ impl<'a> ExtCtxt<'a> {\n         ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n-    pub fn lifetime_def(\n-        &self,\n-        span: Span,\n-        ident: Ident,\n-        attrs: Vec<ast::Attribute>,\n-        bounds: ast::GenericBounds,\n-    ) -> ast::GenericParam {\n-        let lifetime = self.lifetime(span, ident);\n-        ast::GenericParam {\n-            ident: lifetime.ident,\n-            id: lifetime.id,\n-            attrs: attrs.into(),\n-            bounds,\n-            kind: ast::GenericParamKind::Lifetime,\n-            is_placeholder: false,\n-        }\n-    }\n-\n     pub fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -465,24 +447,6 @@ impl<'a> ExtCtxt<'a> {\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    pub fn pat_none(&self, span: Span) -> P<ast::Pat> {\n-        let some = self.std_path(&[sym::option, sym::Option, sym::None]);\n-        let path = self.path_global(span, some);\n-        self.pat_path(span, path)\n-    }\n-\n-    pub fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let some = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n-        let path = self.path_global(span, some);\n-        self.pat_tuple_struct(span, path, vec![pat])\n-    }\n-\n-    pub fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let some = self.std_path(&[sym::result, sym::Result, sym::Err]);\n-        let path = self.path_global(span, some);\n-        self.pat_tuple_struct(span, path, vec![pat])\n-    }\n-\n     pub fn arm(&self, span: Span, pat: P<ast::Pat>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec![],\n@@ -514,26 +478,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n-    pub fn lambda_fn_decl(\n-        &self,\n-        span: Span,\n-        fn_decl: P<ast::FnDecl>,\n-        body: P<ast::Expr>,\n-        fn_decl_span: Span,\n-    ) -> P<ast::Expr> {\n-        self.expr(\n-            span,\n-            ast::ExprKind::Closure(\n-                ast::CaptureBy::Ref,\n-                ast::Async::No,\n-                ast::Movability::Movable,\n-                fn_decl,\n-                body,\n-                fn_decl_span,\n-            ),\n-        )\n-    }\n-\n     pub fn lambda(&self, span: Span, ids: Vec<Ident>, body: P<ast::Expr>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.param(span, *id, self.ty(span, ast::TyKind::Infer))).collect(),\n@@ -610,47 +554,6 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n \n-    pub fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>>) -> ast::Variant {\n-        let vis_span = span.shrink_to_lo();\n-        let fields: Vec<_> = tys\n-            .into_iter()\n-            .map(|ty| ast::StructField {\n-                span: ty.span,\n-                ty,\n-                ident: None,\n-                vis: ast::Visibility {\n-                    span: vis_span,\n-                    kind: ast::VisibilityKind::Inherited,\n-                    tokens: None,\n-                },\n-                attrs: Vec::new(),\n-                id: ast::DUMMY_NODE_ID,\n-                is_placeholder: false,\n-            })\n-            .collect();\n-\n-        let vdata = if fields.is_empty() {\n-            ast::VariantData::Unit(ast::DUMMY_NODE_ID)\n-        } else {\n-            ast::VariantData::Tuple(fields, ast::DUMMY_NODE_ID)\n-        };\n-\n-        ast::Variant {\n-            attrs: Vec::new(),\n-            data: vdata,\n-            disr_expr: None,\n-            id: ast::DUMMY_NODE_ID,\n-            ident,\n-            vis: ast::Visibility {\n-                span: vis_span,\n-                kind: ast::VisibilityKind::Inherited,\n-                tokens: None,\n-            },\n-            span,\n-            is_placeholder: false,\n-        }\n-    }\n-\n     pub fn item_static(\n         &self,\n         span: Span,"}, {"sha": "0b43225a242f709d37b3193ef51471c1d2ae8a63", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{struct_span_err, Applicability, PResult};\n use rustc_feature::Features;\n-use rustc_parse::parser::Parser;\n+use rustc_parse::parser::{AttemptLocalParseRecovery, Parser};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -921,7 +921,7 @@ pub fn parse_ast_fragment<'a>(\n             let mut stmts = SmallVec::new();\n             // Won't make progress on a `}`.\n             while this.token != token::Eof && this.token != token::CloseDelim(token::Brace) {\n-                if let Some(stmt) = this.parse_full_stmt()? {\n+                if let Some(stmt) = this.parse_full_stmt(AttemptLocalParseRecovery::Yes)? {\n                     stmts.push(stmt);\n                 }\n             }"}, {"sha": "4401ec0a04ea57028ca516088f7d457dae8d88aa", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -270,6 +270,9 @@ declare_features! (\n     (accepted, track_caller, \"1.46.0\", Some(47809), None),\n     /// Allows `#[doc(alias = \"...\")]`.\n     (accepted, doc_alias, \"1.48.0\", Some(50146), None),\n+    /// Allows patterns with concurrent by-move and by-ref bindings.\n+    /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n+    (accepted, move_ref_pattern, \"1.48.0\", Some(68354), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "7fbd070a609b7512aabcc1fd6178aa1162ace5f7", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -526,10 +526,6 @@ declare_features! (\n     /// For example, you can write `x @ Some(y)`.\n     (active, bindings_after_at, \"1.41.0\", Some(65490), None),\n \n-    /// Allows patterns with concurrent by-move and by-ref bindings.\n-    /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n-    (active, move_ref_pattern, \"1.42.0\", Some(68354), None),\n-\n     /// Allows `impl const Trait for T` syntax.\n     (active, const_trait_impl, \"1.42.0\", Some(67792), None),\n \n@@ -596,6 +592,12 @@ declare_features! (\n     /// Allows rustc to inject a default alloc_error_handler\n     (active, default_alloc_error_handler, \"1.48.0\", Some(66741), None),\n \n+    /// Allows argument and return position `impl Trait` in a `const fn`.\n+    (active, const_impl_trait, \"1.48.0\", Some(77463), None),\n+\n+    /// Allows `#[instruction_set(_)]` attribute\n+    (active, isa_attribute, \"1.48.0\", Some(74727), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "527a49b05389af33e4e5aabf7ce0601637406c1f", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -336,6 +336,8 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         optimize, AssumedUsed, template!(List: \"size|speed\"), optimize_attribute,\n         experimental!(optimize),\n     ),\n+    // RFC 2867\n+    gated!(instruction_set, AssumedUsed, template!(List: \"set\"), isa_attribute, experimental!(instruction_set)),\n \n     gated!(ffi_returns_twice, AssumedUsed, template!(Word), experimental!(ffi_returns_twice)),\n     gated!(ffi_pure, AssumedUsed, template!(Word), experimental!(ffi_pure)),"}, {"sha": "7742961e65dbb6198fa9d69a0deed5d8d0e71611", "filename": "compiler/rustc_fs_util/src/lib.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fs_util%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -75,33 +75,6 @@ pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<Li\n     }\n }\n \n-#[derive(Debug)]\n-pub enum RenameOrCopyRemove {\n-    Rename,\n-    CopyRemove,\n-}\n-\n-/// Rename `p` into `q`, preferring to use `rename` if possible.\n-/// If `rename` fails (rename may fail for reasons such as crossing\n-/// filesystem), fallback to copy & remove\n-pub fn rename_or_copy_remove<P: AsRef<Path>, Q: AsRef<Path>>(\n-    p: P,\n-    q: Q,\n-) -> io::Result<RenameOrCopyRemove> {\n-    let p = p.as_ref();\n-    let q = q.as_ref();\n-    match fs::rename(p, q) {\n-        Ok(()) => Ok(RenameOrCopyRemove::Rename),\n-        Err(_) => match fs::copy(p, q) {\n-            Ok(_) => {\n-                fs::remove_file(p)?;\n-                Ok(RenameOrCopyRemove::CopyRemove)\n-            }\n-            Err(e) => Err(e),\n-        },\n-    }\n-}\n-\n #[cfg(unix)]\n pub fn path_to_c_string(p: &Path) -> CString {\n     use std::ffi::OsStr;"}, {"sha": "3f109376a3e34829ac6af07acc02f7acf31c4192", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -118,7 +118,7 @@ impl DefKey {\n \n         let DisambiguatedDefPathData { ref data, disambiguator } = self.disambiguated_data;\n \n-        ::std::mem::discriminant(data).hash(&mut hasher);\n+        std::mem::discriminant(data).hash(&mut hasher);\n         if let Some(name) = data.get_opt_name() {\n             // Get a stable hash by considering the symbol chars rather than\n             // the symbol index.\n@@ -188,10 +188,6 @@ pub struct DefPath {\n }\n \n impl DefPath {\n-    pub fn is_local(&self) -> bool {\n-        self.krate == LOCAL_CRATE\n-    }\n-\n     pub fn make<FN>(krate: CrateNum, start_index: DefIndex, mut get_key: FN) -> DefPath\n     where\n         FN: FnMut(DefIndex) -> DefKey,"}, {"sha": "52727e3a619494dadbadcc8ddafd1df5b967a03e", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -3,7 +3,6 @@ use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::{itemlikevisit, LangItem};\n \n-use rustc_ast::node_id::NodeMap;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_ast::{self as ast, CrateSugar, LlvmAsmDialect};\n use rustc_ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n@@ -306,10 +305,6 @@ impl GenericArgs<'_> {\n         Self { args: &[], bindings: &[], parenthesized: false }\n     }\n \n-    pub fn is_empty(&self) -> bool {\n-        self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n-    }\n-\n     pub fn inputs(&self) -> &[Ty<'_>] {\n         if self.parenthesized {\n             for arg in self.args {\n@@ -467,23 +462,6 @@ impl Generics<'hir> {\n         }\n     }\n \n-    pub fn own_counts(&self) -> GenericParamCount {\n-        // We could cache this as a property of `GenericParamCount`, but\n-        // the aim is to refactor this away entirely eventually and the\n-        // presence of this method will be a constant reminder.\n-        let mut own_counts: GenericParamCount = Default::default();\n-\n-        for param in self.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => own_counts.lifetimes += 1,\n-                GenericParamKind::Type { .. } => own_counts.types += 1,\n-                GenericParamKind::Const { .. } => own_counts.consts += 1,\n-            };\n-        }\n-\n-        own_counts\n-    }\n-\n     pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n         for param in self.params {\n             if name == param.name.ident().name {\n@@ -2679,8 +2657,6 @@ pub struct Upvar {\n     pub span: Span,\n }\n \n-pub type CaptureModeMap = NodeMap<CaptureBy>;\n-\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used."}, {"sha": "cc8ac4cf5be51bdda772dffefb22e27db3066e05", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -45,5 +45,3 @@ pub const CRATE_HIR_ID: HirId = HirId {\n     owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n     local_id: ItemLocalId::from_u32(0),\n };\n-\n-pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;"}, {"sha": "c05d3e44423cff20a2f73cbb0c4a3dde073c0c5d", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -58,25 +58,6 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n }\n \n impl hir::Pat<'_> {\n-    pub fn is_refutable(&self) -> bool {\n-        match self.kind {\n-            PatKind::Lit(_)\n-            | PatKind::Range(..)\n-            | PatKind::Path(hir::QPath::Resolved(Some(..), _) | hir::QPath::TypeRelative(..)) => {\n-                true\n-            }\n-\n-            PatKind::Path(hir::QPath::Resolved(_, ref path))\n-            | PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..)\n-            | PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => match path.res {\n-                Res::Def(DefKind::Variant, _) => true,\n-                _ => false,\n-            },\n-            PatKind::Slice(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, Ident)) {\n@@ -117,15 +98,6 @@ impl hir::Pat<'_> {\n         })\n     }\n \n-    /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-    pub fn contains_bindings_or_wild(&self) -> bool {\n-        self.satisfies(|p| match p.kind {\n-            PatKind::Binding(..) | PatKind::Wild => true,\n-            _ => false,\n-        })\n-    }\n-\n     /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n     fn satisfies(&self, pred: impl Fn(&hir::Pat<'_>) -> bool) -> bool {\n         let mut satisfies = false;"}, {"sha": "57a38adc169134993f07b958ce15bef00d6dd9d1", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -44,19 +44,13 @@ pub trait PpAnn {\n     fn nested(&self, _state: &mut State<'_>, _nested: Nested) {}\n     fn pre(&self, _state: &mut State<'_>, _node: AnnNode<'_>) {}\n     fn post(&self, _state: &mut State<'_>, _node: AnnNode<'_>) {}\n-    fn try_fetch_item(&self, _: hir::HirId) -> Option<&hir::Item<'_>> {\n-        None\n-    }\n }\n \n pub struct NoAnn;\n impl PpAnn for NoAnn {}\n pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate<'_> {\n-    fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item<'_>> {\n-        Some(self.item(item))\n-    }\n     fn nested(&self, state: &mut State<'_>, nested: Nested) {\n         match nested {\n             Nested::Item(id) => state.print_item(self.item(id.id)),\n@@ -141,6 +135,9 @@ impl std::ops::DerefMut for State<'_> {\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n+    fn insert_extra_parens(&self) -> bool {\n+        true\n+    }\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }"}, {"sha": "ff7bbf0562f605ddef2734bc25b6420d8afc97da", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -113,13 +113,6 @@ impl Default for RegionckMode {\n }\n \n impl RegionckMode {\n-    pub fn suppressed(self) -> bool {\n-        match self {\n-            Self::Solve => false,\n-            Self::Erase { suppress_errors } => suppress_errors,\n-        }\n-    }\n-\n     /// Indicates that the MIR borrowck will repeat these region\n     /// checks, so we should ignore errors if NLL is (unconditionally)\n     /// enabled.\n@@ -420,15 +413,6 @@ pub enum SubregionOrigin<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n-/// Places that type/region parameters can appear.\n-#[derive(Clone, Copy, Debug)]\n-pub enum ParameterOrigin {\n-    Path,               // foo::bar\n-    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n-    OverloadedOperator, // a + b when overloaded\n-    OverloadedDeref,    // *a when overloaded\n-}\n-\n /// Times when we replace late-bound regions with variables:\n #[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n@@ -508,21 +492,6 @@ pub enum NLLRegionVariableOrigin {\n     },\n }\n \n-impl NLLRegionVariableOrigin {\n-    pub fn is_universal(self) -> bool {\n-        match self {\n-            NLLRegionVariableOrigin::FreeRegion => true,\n-            NLLRegionVariableOrigin::Placeholder(..) => true,\n-            NLLRegionVariableOrigin::Existential { .. } => false,\n-            NLLRegionVariableOrigin::RootEmptyRegion => false,\n-        }\n-    }\n-\n-    pub fn is_existential(self) -> bool {\n-        !self.is_universal()\n-    }\n-}\n-\n // FIXME(eddyb) investigate overlap between this and `TyOrConstInferVar`.\n #[derive(Copy, Clone, Debug)]\n pub enum FixupError<'tcx> {"}, {"sha": "2fb9f638e360833ffe8ba2ad4614800b73ba1c49", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -28,7 +28,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use std::fmt::Debug;\n \n@@ -119,12 +118,6 @@ pub trait TypeRelatingDelegate<'tcx> {\n     fn forbid_inference_vars() -> bool;\n }\n \n-#[derive(Clone, Debug)]\n-struct ScopesAndKind<'tcx> {\n-    scopes: Vec<BoundRegionScope<'tcx>>,\n-    kind: GenericArg<'tcx>,\n-}\n-\n #[derive(Clone, Debug, Default)]\n struct BoundRegionScope<'tcx> {\n     map: FxHashMap<ty::BoundRegion, ty::Region<'tcx>>,\n@@ -341,7 +334,7 @@ where\n         // been fully instantiated and hence the set of scopes we have\n         // doesn't matter -- just to be sure, put an empty vector\n         // in there.\n-        let old_a_scopes = ::std::mem::take(pair.vid_scopes(self));\n+        let old_a_scopes = std::mem::take(pair.vid_scopes(self));\n \n         // Relate the generalized kind to the original one.\n         let result = pair.relate_generalized_ty(self, generalized_ty);\n@@ -680,7 +673,7 @@ where\n             //   itself occurs. Note that `'b` and `'c` must both\n             //   include P. At the point, the call works because of\n             //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n-            let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n+            let variance = std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n \n             self.relate(a.skip_binder(), b.skip_binder())?;\n \n@@ -709,7 +702,7 @@ where\n             // Reset ambient variance to contravariance. See the\n             // covariant case above for an explanation.\n             let variance =\n-                ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n+                std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n \n             self.relate(a.skip_binder(), b.skip_binder())?;\n "}, {"sha": "eb1a7806256c3e219b5a4324da4ddc5ccb0c0610", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -110,7 +110,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n     pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n-        ::std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n+        std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n     /// Process the region obligations that must be proven (during"}, {"sha": "aaf5e958c269d783658fcfd3914147f4eaca9c93", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -59,9 +59,7 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PredicateObligation<'_>, 32);\n \n-pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n-pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n pub type Selection<'tcx> = ImplSource<'tcx, PredicateObligation<'tcx>>;\n "}, {"sha": "d9c24cc3994824fd48a0220ebca5ed6a028b9020", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -551,6 +551,10 @@ fn write_out_deps(\n             .map(|fmap| escape_dep_filename(&fmap.unmapped_path.as_ref().unwrap_or(&fmap.name)))\n             .collect();\n \n+        if let Some(ref backend) = sess.opts.debugging_opts.codegen_backend {\n+            files.push(backend.to_string());\n+        }\n+\n         if sess.binary_dep_depinfo() {\n             boxed_resolver.borrow().borrow_mut().access(|resolver| {\n                 for cnum in resolver.cstore().crates_untracked() {"}, {"sha": "1de7350a3e21c5d333320954f26871221f04ca2d", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -3,6 +3,7 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -13,7 +14,8 @@ use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::steal::Steal;\n use rustc_middle::ty::{GlobalCtxt, ResolverOutputs, TyCtxt};\n-use rustc_session::config::{OutputFilenames, OutputType};\n+use rustc_serialize::json;\n+use rustc_session::config::{self, OutputFilenames, OutputType};\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n use std::any::Any;\n@@ -331,6 +333,7 @@ impl<'tcx> Queries<'tcx> {\n     pub fn linker(&'tcx self) -> Result<Linker> {\n         let dep_graph = self.dep_graph()?;\n         let prepare_outputs = self.prepare_outputs()?;\n+        let crate_hash = self.global_ctxt()?.peek_mut().enter(|tcx| tcx.crate_hash(LOCAL_CRATE));\n         let ongoing_codegen = self.ongoing_codegen()?;\n \n         let sess = self.session().clone();\n@@ -340,6 +343,7 @@ impl<'tcx> Queries<'tcx> {\n             sess,\n             dep_graph: dep_graph.peek().clone(),\n             prepare_outputs: prepare_outputs.take(),\n+            crate_hash,\n             ongoing_codegen: ongoing_codegen.take(),\n             codegen_backend,\n         })\n@@ -350,18 +354,31 @@ pub struct Linker {\n     sess: Lrc<Session>,\n     dep_graph: DepGraph,\n     prepare_outputs: OutputFilenames,\n+    crate_hash: Svh,\n     ongoing_codegen: Box<dyn Any>,\n     codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n }\n \n impl Linker {\n     pub fn link(self) -> Result<()> {\n-        let codegen_results =\n-            self.codegen_backend.join_codegen(self.ongoing_codegen, &self.sess, &self.dep_graph)?;\n-        let prof = self.sess.prof.clone();\n+        let (codegen_results, work_products) =\n+            self.codegen_backend.join_codegen(self.ongoing_codegen, &self.sess)?;\n+\n+        self.sess.compile_status()?;\n+\n+        let sess = &self.sess;\n         let dep_graph = self.dep_graph;\n+        sess.time(\"serialize_work_products\", || {\n+            rustc_incremental::save_work_product_index(&sess, &dep_graph, work_products)\n+        });\n+\n+        let prof = self.sess.prof.clone();\n         prof.generic_activity(\"drop_dep_graph\").run(move || drop(dep_graph));\n \n+        // Now that we won't touch anything in the incremental compilation directory\n+        // any more, we can finalize it (which involves renaming it)\n+        rustc_incremental::finalize_session_directory(&self.sess, self.crate_hash);\n+\n         if !self\n             .sess\n             .opts\n@@ -371,6 +388,19 @@ impl Linker {\n         {\n             return Ok(());\n         }\n+\n+        if sess.opts.debugging_opts.no_link {\n+            // FIXME: use a binary format to encode the `.rlink` file\n+            let rlink_data = json::encode(&codegen_results).map_err(|err| {\n+                sess.fatal(&format!(\"failed to encode rlink: {}\", err));\n+            })?;\n+            let rlink_file = self.prepare_outputs.with_extension(config::RLINK_EXT);\n+            std::fs::write(&rlink_file, rlink_data).map_err(|err| {\n+                sess.fatal(&format!(\"failed to write file {}: {}\", rlink_file.display(), err));\n+            })?;\n+            return Ok(());\n+        }\n+\n         self.codegen_backend.link(&self.sess, codegen_results, &self.prepare_outputs)\n     }\n }"}, {"sha": "6553d0ecfdb5f973a91a9663a0e73244ee5c346d", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -585,6 +585,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(symbol_mangling_version, SymbolManglingVersion::V0);\n     tracked!(teach, true);\n     tracked!(thinlto, Some(true));\n+    tracked!(tune_cpu, Some(String::from(\"abc\")));\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n     tracked!(treat_err_as_bug, Some(1));\n     tracked!(unleash_the_miri_inside_of_you, true);"}, {"sha": "c1b359c7d0de5f0ca77bfeff9d25b6d7ed8f0eca", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -187,7 +187,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n         config = config.stack_size(size);\n     }\n \n-    let with_pool = move |pool: &rayon::ThreadPool| pool.install(move || f());\n+    let with_pool = move |pool: &rayon::ThreadPool| pool.install(f);\n \n     rustc_span::with_session_globals(edition, || {\n         rustc_span::SESSION_GLOBALS.with(|session_globals| {"}, {"sha": "c5b59a041abf6a99e620ba33397907eccfa488ee", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -48,6 +48,7 @@ impl Token {\n }\n \n /// Enum representing common lexeme types.\n+// perf note: Changing all `usize` to `u32` doesn't change performance. See #77629\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum TokenKind {\n     // Multi-char tokens:\n@@ -160,6 +161,7 @@ pub enum LiteralKind {\n /// - `r##~\"abcde\"##`: `InvalidStarter`\n /// - `r###\"abcde\"##`: `NoTerminator { expected: 3, found: 2, possible_terminator_offset: Some(11)`\n /// - Too many `#`s (>65535): `TooManyDelimiters`\n+// perf note: It doesn't matter that this makes `Token` 36 bytes bigger. See #77629\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum RawStrError {\n     /// Non `#` characters exist between `r` and `\"` eg. `r#~\"..`\n@@ -689,7 +691,12 @@ impl Cursor<'_> {\n         let mut max_hashes = 0;\n \n         // Count opening '#' symbols.\n-        let n_start_hashes = self.eat_while(|c| c == '#');\n+        let mut eaten = 0;\n+        while self.first() == '#' {\n+            eaten += 1;\n+            self.bump();\n+        }\n+        let n_start_hashes = eaten;\n \n         // Check that string is started.\n         match self.bump() {\n@@ -724,16 +731,11 @@ impl Cursor<'_> {\n             // Note that this will not consume extra trailing `#` characters:\n             // `r###\"abcde\"####` is lexed as a `RawStr { n_hashes: 3 }`\n             // followed by a `#` token.\n-            let mut hashes_left = n_start_hashes;\n-            let is_closing_hash = |c| {\n-                if c == '#' && hashes_left != 0 {\n-                    hashes_left -= 1;\n-                    true\n-                } else {\n-                    false\n-                }\n-            };\n-            let n_end_hashes = self.eat_while(is_closing_hash);\n+            let mut n_end_hashes = 0;\n+            while self.first() == '#' && n_end_hashes < n_start_hashes {\n+                n_end_hashes += 1;\n+                self.bump();\n+            }\n \n             if n_end_hashes == n_start_hashes {\n                 return (n_start_hashes, None);\n@@ -807,17 +809,9 @@ impl Cursor<'_> {\n     }\n \n     /// Eats symbols while predicate returns true or until the end of file is reached.\n-    /// Returns amount of eaten symbols.\n-    fn eat_while<F>(&mut self, mut predicate: F) -> usize\n-    where\n-        F: FnMut(char) -> bool,\n-    {\n-        let mut eaten: usize = 0;\n+    fn eat_while(&mut self, mut predicate: impl FnMut(char) -> bool) {\n         while predicate(self.first()) && !self.is_eof() {\n-            eaten += 1;\n             self.bump();\n         }\n-\n-        eaten\n     }\n }"}, {"sha": "48270eb59a0500a9bd4945795549902cf92fa624", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -711,10 +711,6 @@ impl<'tcx> LateContext<'tcx> {\n         }\n     }\n \n-    pub fn current_lint_root(&self) -> hir::HirId {\n-        self.last_node_with_lint_attrs\n-    }\n-\n     /// Check if a `DefId`'s path matches the given absolute type path usage.\n     ///\n     /// Anonymous scopes such as `extern` imports are matched with `kw::Invalid`;"}, {"sha": "1db59bfc39dcef4579fa95f3c17b3332977f3c83", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -64,8 +64,8 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n     BARE_TRAIT_OBJECTS, BROKEN_INTRA_DOC_LINKS, ELIDED_LIFETIMES_IN_PATHS,\n-    EXPLICIT_OUTLIVES_REQUIREMENTS, INVALID_CODEBLOCK_ATTRIBUTES, MISSING_DOC_CODE_EXAMPLES,\n-    PRIVATE_DOC_TESTS,\n+    EXPLICIT_OUTLIVES_REQUIREMENTS, INVALID_CODEBLOCK_ATTRIBUTES, INVALID_HTML_TAGS,\n+    MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n };\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -311,7 +311,8 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         PRIVATE_INTRA_DOC_LINKS,\n         INVALID_CODEBLOCK_ATTRIBUTES,\n         MISSING_DOC_CODE_EXAMPLES,\n-        PRIVATE_DOC_TESTS\n+        PRIVATE_DOC_TESTS,\n+        INVALID_HTML_TAGS\n     );\n \n     // Register renamed and removed lints."}, {"sha": "af14f28ff9f46ab1140f2c1ec3c10a5a5eb27d16", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -304,7 +304,7 @@ fn lint_int_literal<'tcx>(\n     t: ast::IntTy,\n     v: u128,\n ) {\n-    let int_type = t.normalize(cx.sess().target.ptr_width);\n+    let int_type = t.normalize(cx.sess().target.pointer_width);\n     let (min, max) = int_ty_range(int_type);\n     let max = max as u128;\n     let negative = type_limits.negated_expr_id == Some(e.hir_id);\n@@ -352,7 +352,7 @@ fn lint_uint_literal<'tcx>(\n     lit: &hir::Lit,\n     t: ast::UintTy,\n ) {\n-    let uint_type = t.normalize(cx.sess().target.ptr_width);\n+    let uint_type = t.normalize(cx.sess().target.pointer_width);\n     let (min, max) = uint_ty_range(uint_type);\n     let lit_val: u128 = match lit.node {\n         // _v is u8, within range by definition"}, {"sha": "54b22ca49a29e88462243c927dec58ea71714463", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -70,7 +70,7 @@ fn main() {\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     let is_crossed = target != host;\n \n-    let mut optional_components = vec![\n+    let optional_components = &[\n         \"x86\",\n         \"arm\",\n         \"aarch64\",\n@@ -85,6 +85,7 @@ fn main() {\n         \"sparc\",\n         \"nvptx\",\n         \"hexagon\",\n+        \"riscv\",\n     ];\n \n     let mut version_cmd = Command::new(&llvm_config);\n@@ -94,13 +95,9 @@ fn main() {\n     let (major, _minor) = if let (Some(major), Some(minor)) = (parts.next(), parts.next()) {\n         (major, minor)\n     } else {\n-        (6, 0)\n+        (8, 0)\n     };\n \n-    if major > 6 {\n-        optional_components.push(\"riscv\");\n-    }\n-\n     let required_components = &[\n         \"ipo\",\n         \"bitreader\","}, {"sha": "71ca4f23bbb170055974812d0ac498ea915fb6c9", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1212,6 +1212,7 @@ struct LLVMRustThinLTOData {\n   StringMap<FunctionImporter::ImportMapTy> ImportLists;\n   StringMap<FunctionImporter::ExportSetTy> ExportLists;\n   StringMap<GVSummaryMapTy> ModuleToDefinedGVSummaries;\n+  StringMap<std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>> ResolvedODR;\n \n   LLVMRustThinLTOData() : Index(/* HaveGVs = */ false) {}\n };\n@@ -1308,7 +1309,6 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   //\n   // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp` with some of this\n   // being lifted from `lib/LTO/LTO.cpp` as well\n-  StringMap<std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>> ResolvedODR;\n   DenseMap<GlobalValue::GUID, const GlobalValueSummary *> PrevailingCopy;\n   for (auto &I : Ret->Index) {\n     if (I.second.SummaryList.size() > 1)\n@@ -1323,7 +1323,7 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   auto recordNewLinkage = [&](StringRef ModuleIdentifier,\n                               GlobalValue::GUID GUID,\n                               GlobalValue::LinkageTypes NewLinkage) {\n-    ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n+    Ret->ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n   };\n #if LLVM_VERSION_GE(9, 0)\n   thinLTOResolvePrevailingInIndex(Ret->Index, isPrevailing, recordNewLinkage,\n@@ -1491,7 +1491,7 @@ extern \"C\" typedef void (*LLVMRustModuleNameCallback)(void*, // payload\n // Calls `module_name_callback` for each module import done by ThinLTO.\n // The callback is provided with regular null-terminated C strings.\n extern \"C\" void\n-LLVMRustGetThinLTOModuleImports(const LLVMRustThinLTOData *data,\n+LLVMRustGetThinLTOModules(const LLVMRustThinLTOData *data,\n                                 LLVMRustModuleNameCallback module_name_callback,\n                                 void* callback_payload) {\n   for (const auto& importing_module : data->ImportLists) {\n@@ -1653,3 +1653,36 @@ LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n   MD->clearOperands();\n   MD->addOperand(Unit);\n }\n+\n+// Computes the LTO cache key for the provided 'ModId' in the given 'Data',\n+// storing the result in 'KeyOut'.\n+// Currently, this cache key is a SHA-1 hash of anything that could affect\n+// the result of optimizing this module (e.g. module imports, exports, liveness\n+// of access globals, etc).\n+// The precise details are determined by LLVM in `computeLTOCacheKey`, which is\n+// used during the normal linker-plugin incremental thin-LTO process.\n+extern \"C\" void\n+LLVMRustComputeLTOCacheKey(RustStringRef KeyOut, const char *ModId, LLVMRustThinLTOData *Data) {\n+  SmallString<40> Key;\n+  llvm::lto::Config conf;\n+  const auto &ImportList = Data->ImportLists.lookup(ModId);\n+  const auto &ExportList = Data->ExportLists.lookup(ModId);\n+  const auto &ResolvedODR = Data->ResolvedODR.lookup(ModId);\n+  const auto &DefinedGlobals = Data->ModuleToDefinedGVSummaries.lookup(ModId);\n+  std::set<GlobalValue::GUID> CfiFunctionDefs;\n+  std::set<GlobalValue::GUID> CfiFunctionDecls;\n+\n+  // Based on the 'InProcessThinBackend' constructor in LLVM\n+  for (auto &Name : Data->Index.cfiFunctionDefs())\n+    CfiFunctionDefs.insert(\n+        GlobalValue::getGUID(GlobalValue::dropLLVMManglingEscape(Name)));\n+  for (auto &Name : Data->Index.cfiFunctionDecls())\n+    CfiFunctionDecls.insert(\n+        GlobalValue::getGUID(GlobalValue::dropLLVMManglingEscape(Name)));\n+\n+  llvm::computeLTOCacheKey(Key, conf, Data->Index, ModId,\n+      ImportList, ExportList, ResolvedODR, DefinedGlobals, CfiFunctionDefs, CfiFunctionDecls\n+  );\n+\n+  LLVMRustStringWriteImpl(KeyOut, Key.c_str(), Key.size());\n+}"}, {"sha": "44f57cfbe2843a9a567c5a20e4faddfb982efd8d", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -127,7 +127,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         if ty == CrateType::Staticlib\n             || (ty == CrateType::Executable\n                 && sess.crt_static(Some(ty))\n-                && !sess.target.target.options.crt_static_allows_dylibs)\n+                && !sess.target.options.crt_static_allows_dylibs)\n         {\n             for &cnum in tcx.crates().iter() {\n                 if tcx.dep_kind(cnum).macros_only() {"}, {"sha": "f225f8acc89ffe260483ac5c85f053dd78a40527", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -325,7 +325,7 @@ impl<'a> CrateLocator<'a> {\n             hash,\n             host_hash,\n             extra_filename,\n-            target: if is_host { &sess.host } else { &sess.target.target },\n+            target: if is_host { &sess.host } else { &sess.target },\n             triple: if is_host {\n                 TargetTriple::from_triple(config::host_triple())\n             } else {"}, {"sha": "5e65f075ea43f4b196939b30db35372d22b444e1", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -149,7 +149,7 @@ impl Collector<'tcx> {\n             }\n             return;\n         }\n-        let is_osx = self.tcx.sess.target.target.options.is_like_osx;\n+        let is_osx = self.tcx.sess.target.options.is_like_osx;\n         if lib.kind == NativeLibKind::Framework && !is_osx {\n             let msg = \"native frameworks are only available on macOS targets\";\n             match span {"}, {"sha": "b01a55b48da667a6f4b4e97e772182e2fe251fdb", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -313,27 +313,6 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n         Ok(ty)\n     }\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n-    {\n-        let tcx = self.tcx();\n-\n-        let key = ty::CReaderCacheKey { cnum: self.cdata().cnum, pos: shorthand };\n-\n-        if let Some(&pred) = tcx.pred_rcache.borrow().get(&key) {\n-            return Ok(pred);\n-        }\n-\n-        let pred = or_insert_with(self)?;\n-        tcx.pred_rcache.borrow_mut().insert(key, pred);\n-        Ok(pred)\n-    }\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "05b8dad3097e413f52c37020e56525c65c06ceec", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -94,7 +94,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n         let _ = cdata;\n-        tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n+        tcx.calculate_dtor(def_id, |_,_| Ok(()))\n     }\n     variances_of => { tcx.arena.alloc_from_iter(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {"}, {"sha": "bdbc9ab52bf639a4487fe57e1a3f59ef49369e21", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -26,7 +26,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.31.0\"\n+chalk-ir = \"0.32.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "d6c6cef17513dc732cb4852731569a43ddbbbd84", "filename": "compiler/rustc_middle/src/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_hir.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -221,6 +221,12 @@ impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n     }\n }\n \n+impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InstructionSetAttr {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'hir> HashStable<StableHashingContext<'hir>> for attr::OptimizeAttr {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'hir>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "7aba4fc64a929983f5ec782df1087d873582396a", "filename": "compiler/rustc_middle/src/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -5,7 +5,7 @@ use crate::ich::StableHashingContext;\n \n use rustc_ast as ast;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_span::SourceFile;\n+use rustc_span::{BytePos, NormalizedPos, SourceFile};\n \n use smallvec::SmallVec;\n \n@@ -102,34 +102,28 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n     }\n }\n \n-fn stable_byte_pos(pos: ::rustc_span::BytePos, source_file_start: ::rustc_span::BytePos) -> u32 {\n+fn stable_byte_pos(pos: BytePos, source_file_start: BytePos) -> u32 {\n     pos.0 - source_file_start.0\n }\n \n-fn stable_multibyte_char(\n-    mbc: ::rustc_span::MultiByteChar,\n-    source_file_start: ::rustc_span::BytePos,\n-) -> (u32, u32) {\n-    let ::rustc_span::MultiByteChar { pos, bytes } = mbc;\n+fn stable_multibyte_char(mbc: rustc_span::MultiByteChar, source_file_start: BytePos) -> (u32, u32) {\n+    let rustc_span::MultiByteChar { pos, bytes } = mbc;\n \n     (pos.0 - source_file_start.0, bytes as u32)\n }\n \n fn stable_non_narrow_char(\n-    swc: ::rustc_span::NonNarrowChar,\n-    source_file_start: ::rustc_span::BytePos,\n+    swc: rustc_span::NonNarrowChar,\n+    source_file_start: BytePos,\n ) -> (u32, u32) {\n     let pos = swc.pos();\n     let width = swc.width();\n \n     (pos.0 - source_file_start.0, width as u32)\n }\n \n-fn stable_normalized_pos(\n-    np: ::rustc_span::NormalizedPos,\n-    source_file_start: ::rustc_span::BytePos,\n-) -> (u32, u32) {\n-    let ::rustc_span::NormalizedPos { pos, diff } = np;\n+fn stable_normalized_pos(np: NormalizedPos, source_file_start: BytePos) -> (u32, u32) {\n+    let NormalizedPos { pos, diff } = np;\n \n     (pos.0 - source_file_start.0, diff)\n }"}, {"sha": "a4363bb580a2f6c6ad5db697126e765debd23f11", "filename": "compiler/rustc_middle/src/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,5 +1,5 @@\n use crate::mir::mono::Linkage;\n-use rustc_attr::{InlineAttr, OptimizeAttr};\n+use rustc_attr::{InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_session::config::SanitizerSet;\n use rustc_span::symbol::Symbol;\n \n@@ -34,6 +34,10 @@ pub struct CodegenFnAttrs {\n     /// The `#[no_sanitize(...)]` attribute. Indicates sanitizers for which\n     /// instrumentation should be disabled inside the annotated function.\n     pub no_sanitize: SanitizerSet,\n+    /// The `#[instruction_set(set)]` attribute. Indicates if the generated code should\n+    /// be generated against a specific instruction set. Only usable on architectures which allow\n+    /// switching between multiple instruction sets.\n+    pub instruction_set: Option<InstructionSetAttr>,\n }\n \n bitflags! {\n@@ -98,6 +102,7 @@ impl CodegenFnAttrs {\n             linkage: None,\n             link_section: None,\n             no_sanitize: SanitizerSet::empty(),\n+            instruction_set: None,\n         }\n     }\n "}, {"sha": "254b57a005e8e7438148954c9e17fd05cc50321c", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -3,7 +3,6 @@\n //! which are available for use externally when compiled as a library.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefIdSet;\n use rustc_hir::HirId;\n use rustc_macros::HashStable;\n use std::fmt;\n@@ -59,7 +58,3 @@ impl<Id: Hash + Eq + fmt::Debug> fmt::Debug for AccessLevels<Id> {\n         fmt::Debug::fmt(&self.map, f)\n     }\n }\n-\n-/// A set containing all exported definitions from external crates.\n-/// The set does not contain any entries from local crates.\n-pub type ExternalExports = DefIdSet;"}, {"sha": "38cb3c1701f928bf2124aa2e4a1a3ef5f9acb068", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -283,23 +283,27 @@ pub struct ScopeTree {\n     /// To see that this method works, consider:\n     ///\n     /// Let `D` be our binding/temporary and `U` be our other HIR node, with\n-    /// `HIR-postorder(U) < HIR-postorder(D)` (in our example, U would be\n-    /// the yield and D would be one of the calls). Let's show that\n-    /// `D` is storage-dead at `U`.\n+    /// `HIR-postorder(U) < HIR-postorder(D)`. Suppose, as in our example,\n+    /// U is the yield and D is one of the calls.\n+    /// Let's show that `D` is storage-dead at `U`.\n     ///\n     /// Remember that storage-live/storage-dead refers to the state of\n     /// the *storage*, and does not consider moves/drop flags.\n     ///\n     /// Then:\n+    ///\n     ///     1. From the ordering guarantee of HIR visitors (see\n     ///     `rustc_hir::intravisit`), `D` does not dominate `U`.\n+    ///\n     ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n     ///     we might visit `U` without ever getting to `D`).\n+    ///\n     ///     3. However, we guarantee that at each HIR point, each\n     ///     binding/temporary is always either always storage-live\n     ///     or always storage-dead. This is what is being guaranteed\n     ///     by `terminating_scopes` including all blocks where the\n     ///     count of executions is not guaranteed.\n+    ///\n     ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n     ///     QED.\n     ///"}, {"sha": "5ebe38b2d7e09fe9b659a6aee5ef5c24d9dbbde9", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -40,7 +40,7 @@ pub struct Allocation<Tag = (), Extra = ()> {\n     pub extra: Extra,\n }\n \n-pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n+pub trait AllocationExtra<Tag>: std::fmt::Debug + Clone {\n     // There is no constructor in here because the constructor's type depends\n     // on `MemoryKind`, and making things sufficiently generic leads to painful\n     // inference failure."}, {"sha": "cb8782ce8170a4e61655a0cc10b0f51034291edb", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -56,15 +56,6 @@ impl<'tcx> ConstValue<'tcx> {\n         }\n     }\n \n-    pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n-        if let ConstValue::Slice { data, start, end } = *self {\n-            ::std::str::from_utf8(data.inspect_with_uninit_and_ptr_outside_interpreter(start..end))\n-                .ok()\n-        } else {\n-            None\n-        }\n-    }\n-\n     pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar()?.to_bits(size).ok()\n     }\n@@ -465,7 +456,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n-        match ::std::char::from_u32(val) {\n+        match std::char::from_u32(val) {\n             Some(c) => Ok(c),\n             None => throw_ub!(InvalidChar(val)),\n         }"}, {"sha": "16472c787572c8f614ea7833d40c84107700da0a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 57, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n+use crate::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -460,17 +460,6 @@ impl<'tcx> Body<'tcx> {\n         }\n     }\n \n-    /// Checks if `sub` is a sub scope of `sup`\n-    pub fn is_sub_scope(&self, mut sub: SourceScope, sup: SourceScope) -> bool {\n-        while sub != sup {\n-            match self.source_scopes[sub].parent_scope {\n-                None => return false,\n-                Some(p) => sub = p,\n-            }\n-        }\n-        true\n-    }\n-\n     /// Returns the return type; it always return first element from `local_decls` array.\n     #[inline]\n     pub fn return_ty(&self) -> Ty<'tcx> {\n@@ -775,7 +764,7 @@ mod binding_form_impl {\n     impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n         fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n             use super::BindingForm::*;\n-            ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n+            std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n             match self {\n                 Var(binding) => binding.hash_stable(hcx, hasher),\n@@ -813,7 +802,7 @@ pub struct BlockTailInfo {\n /// argument, or the return place.\n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct LocalDecl<'tcx> {\n-    /// Whether this is a mutable minding (i.e., `let x` or `let mut x`).\n+    /// Whether this is a mutable binding (i.e., `let x` or `let mut x`).\n     ///\n     /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n@@ -1978,45 +1967,6 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n-    /// Convenience helper to make a `Scalar` from the given `Operand`, assuming that `Operand`\n-    /// wraps a constant literal value. Panics if this is not the case.\n-    pub fn scalar_from_const(operand: &Operand<'tcx>) -> Scalar {\n-        match operand {\n-            Operand::Constant(constant) => match constant.literal.val.try_to_scalar() {\n-                Some(scalar) => scalar,\n-                _ => panic!(\"{:?}: Scalar value expected\", constant.literal.val),\n-            },\n-            _ => panic!(\"{:?}: Constant expected\", operand),\n-        }\n-    }\n-\n-    /// Convenience helper to make a literal-like constant from a given `&str` slice.\n-    /// Since this is used to synthesize MIR, assumes `user_ty` is None.\n-    pub fn const_from_str(tcx: TyCtxt<'tcx>, val: &str, span: Span) -> Operand<'tcx> {\n-        let tcx = tcx;\n-        let allocation = Allocation::from_byte_aligned_bytes(val.as_bytes());\n-        let allocation = tcx.intern_const_alloc(allocation);\n-        let const_val = ConstValue::Slice { data: allocation, start: 0, end: val.len() };\n-        let ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.types.str_);\n-        Operand::Constant(box Constant {\n-            span,\n-            user_ty: None,\n-            literal: ty::Const::from_value(tcx, const_val, ty),\n-        })\n-    }\n-\n-    /// Convenience helper to make a `ConstValue` from the given `Operand`, assuming that `Operand`\n-    /// wraps a constant value (such as a `&str` slice). Panics if this is not the case.\n-    pub fn value_from_const(operand: &Operand<'tcx>) -> ConstValue<'tcx> {\n-        match operand {\n-            Operand::Constant(constant) => match constant.literal.val.try_to_value() {\n-                Some(const_value) => const_value,\n-                _ => panic!(\"{:?}: ConstValue expected\", constant.literal.val),\n-            },\n-            _ => panic!(\"{:?}: Constant expected\", operand),\n-        }\n-    }\n-\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),\n@@ -2413,10 +2363,6 @@ impl<'tcx> UserTypeProjections {\n         self.contents.is_empty()\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item = (UserTypeProjection, Span)>) -> Self {\n-        UserTypeProjections { contents: projs.collect() }\n-    }\n-\n     pub fn projections_and_spans(\n         &self,\n     ) -> impl Iterator<Item = &(UserTypeProjection, Span)> + ExactSizeIterator {"}, {"sha": "6022194342d02961a8dfa7fa4a475d0f04134fe6", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,9 +1,10 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{Body, Promoted};\n+use crate::mir::{abstract_const, Body, Promoted};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n@@ -407,18 +408,12 @@ pub struct CoverageInfo {\n     pub num_expressions: u32,\n }\n \n+/// Shims which make dealing with `WithOptConstParam` easier.\n+///\n+/// For more information on why this is needed, consider looking\n+/// at the docs for `WithOptConstParam` itself.\n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn mir_borrowck_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx BorrowCheckResult<'tcx> {\n-        if let Some(param_did) = def.const_param_did {\n-            self.mir_borrowck_const_arg((def.did, param_did))\n-        } else {\n-            self.mir_borrowck(def.did)\n-        }\n-    }\n-\n+    #[inline]\n     pub fn mir_const_qualif_opt_const_arg(\n         self,\n         def: ty::WithOptConstParam<LocalDefId>,\n@@ -430,7 +425,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn promoted_mir_of_opt_const_arg(\n+    #[inline]\n+    pub fn promoted_mir_opt_const_arg(\n         self,\n         def: ty::WithOptConstParam<DefId>,\n     ) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n@@ -440,4 +436,28 @@ impl<'tcx> TyCtxt<'tcx> {\n             self.promoted_mir(def.did)\n         }\n     }\n+\n+    #[inline]\n+    pub fn optimized_mir_opt_const_arg(\n+        self,\n+        def: ty::WithOptConstParam<DefId>,\n+    ) -> &'tcx Body<'tcx> {\n+        if let Some((did, param_did)) = def.as_const_arg() {\n+            self.optimized_mir_of_const_arg((did, param_did))\n+        } else {\n+            self.optimized_mir(def.did)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn mir_abstract_const_opt_const_arg(\n+        self,\n+        def: ty::WithOptConstParam<DefId>,\n+    ) -> Result<Option<&'tcx [abstract_const::Node<'tcx>]>, ErrorReported> {\n+        if let Some((did, param_did)) = def.as_const_arg() {\n+            self.mir_abstract_const_of_const_arg((did, param_did))\n+        } else {\n+            self.mir_abstract_const(def.did)\n+        }\n+    }\n }"}, {"sha": "e1071454e6501444f6d05f103f054f3d32a1c935", "filename": "compiler/rustc_middle/src/mir/terminator/mod.rs", "status": "modified", "additions": 89, "deletions": 24, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,7 @@\n use crate::mir::interpret::Scalar;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use smallvec::{smallvec, SmallVec};\n \n use super::{\n     AssertMessage, BasicBlock, InlineAsmOperand, Operand, Place, SourceInfo, Successors,\n@@ -16,6 +17,87 @@ use std::slice;\n \n pub use super::query::*;\n \n+#[derive(Debug, Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n+pub struct SwitchTargets {\n+    /// Possible values. The locations to branch to in each case\n+    /// are found in the corresponding indices from the `targets` vector.\n+    values: SmallVec<[u128; 1]>,\n+\n+    /// Possible branch sites. The last element of this vector is used\n+    /// for the otherwise branch, so targets.len() == values.len() + 1\n+    /// should hold.\n+    //\n+    // This invariant is quite non-obvious and also could be improved.\n+    // One way to make this invariant is to have something like this instead:\n+    //\n+    // branches: Vec<(ConstInt, BasicBlock)>,\n+    // otherwise: Option<BasicBlock> // exhaustive if None\n+    //\n+    // However we\u2019ve decided to keep this as-is until we figure a case\n+    // where some other approach seems to be strictly better than other.\n+    targets: SmallVec<[BasicBlock; 2]>,\n+}\n+\n+impl SwitchTargets {\n+    /// Creates switch targets from an iterator of values and target blocks.\n+    ///\n+    /// The iterator may be empty, in which case the `SwitchInt` instruction is equivalent to\n+    /// `goto otherwise;`.\n+    pub fn new(targets: impl Iterator<Item = (u128, BasicBlock)>, otherwise: BasicBlock) -> Self {\n+        let (values, mut targets): (SmallVec<_>, SmallVec<_>) = targets.unzip();\n+        targets.push(otherwise);\n+        Self { values: values.into(), targets }\n+    }\n+\n+    /// Builds a switch targets definition that jumps to `then` if the tested value equals `value`,\n+    /// and to `else_` if not.\n+    pub fn static_if(value: u128, then: BasicBlock, else_: BasicBlock) -> Self {\n+        Self { values: smallvec![value], targets: smallvec![then, else_] }\n+    }\n+\n+    /// Returns the fallback target that is jumped to when none of the values match the operand.\n+    pub fn otherwise(&self) -> BasicBlock {\n+        *self.targets.last().unwrap()\n+    }\n+\n+    /// Returns an iterator over the switch targets.\n+    ///\n+    /// The iterator will yield tuples containing the value and corresponding target to jump to, not\n+    /// including the `otherwise` fallback target.\n+    ///\n+    /// Note that this may yield 0 elements. Only the `otherwise` branch is mandatory.\n+    pub fn iter(&self) -> SwitchTargetsIter<'_> {\n+        SwitchTargetsIter { inner: self.values.iter().zip(self.targets.iter()) }\n+    }\n+\n+    /// Returns a slice with all possible jump targets (including the fallback target).\n+    pub fn all_targets(&self) -> &[BasicBlock] {\n+        &self.targets\n+    }\n+\n+    pub fn all_targets_mut(&mut self) -> &mut [BasicBlock] {\n+        &mut self.targets\n+    }\n+}\n+\n+pub struct SwitchTargetsIter<'a> {\n+    inner: iter::Zip<slice::Iter<'a, u128>, slice::Iter<'a, BasicBlock>>,\n+}\n+\n+impl<'a> Iterator for SwitchTargetsIter<'a> {\n+    type Item = (u128, BasicBlock);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(val, bb)| (*val, *bb))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n+\n #[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n     /// Block should have one successor in the graph; we jump there.\n@@ -32,23 +114,7 @@ pub enum TerminatorKind<'tcx> {\n         /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n         switch_ty: Ty<'tcx>,\n \n-        /// Possible values. The locations to branch to in each case\n-        /// are found in the corresponding indices from the `targets` vector.\n-        values: Cow<'tcx, [u128]>,\n-\n-        /// Possible branch sites. The last element of this vector is used\n-        /// for the otherwise branch, so targets.len() == values.len() + 1\n-        /// should hold.\n-        //\n-        // This invariant is quite non-obvious and also could be improved.\n-        // One way to make this invariant is to have something like this instead:\n-        //\n-        // branches: Vec<(ConstInt, BasicBlock)>,\n-        // otherwise: Option<BasicBlock> // exhaustive if None\n-        //\n-        // However we\u2019ve decided to keep this as-is until we figure a case\n-        // where some other approach seems to be strictly better than other.\n-        targets: Vec<BasicBlock>,\n+        targets: SwitchTargets,\n     },\n \n     /// Indicates that the landing pad is finished and unwinding should\n@@ -227,12 +293,10 @@ impl<'tcx> TerminatorKind<'tcx> {\n         t: BasicBlock,\n         f: BasicBlock,\n     ) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &[u128] = &[0];\n         TerminatorKind::SwitchInt {\n             discr: cond,\n             switch_ty: tcx.types.bool,\n-            values: From::from(BOOL_SWITCH_FALSE),\n-            targets: vec![f, t],\n+            targets: SwitchTargets::static_if(0, f, t),\n         }\n     }\n \n@@ -263,7 +327,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n                 Some(t).into_iter().chain(slice::from_ref(u))\n             }\n-            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n+            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets.targets[..]),\n             FalseEdge { ref real_target, ref imaginary_target } => {\n                 Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n             }\n@@ -297,7 +361,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n                 Some(t).into_iter().chain(slice::from_mut(u))\n             }\n-            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n+            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets.targets[..]),\n             FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n                 Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n             }\n@@ -469,11 +533,12 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n+            SwitchInt { ref targets, switch_ty, .. } => ty::tls::with(|tcx| {\n                 let param_env = ty::ParamEnv::empty();\n                 let switch_ty = tcx.lift(&switch_ty).unwrap();\n                 let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                values\n+                targets\n+                    .values\n                     .iter()\n                     .map(|&u| {\n                         ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)"}, {"sha": "9297aed66a459e3c1248bf64c650b2b91c180749", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -21,10 +21,9 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n-            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n+            SwitchInt { ref discr, switch_ty, ref targets } => SwitchInt {\n                 discr: discr.fold_with(folder),\n                 switch_ty: switch_ty.fold_with(folder),\n-                values: values.clone(),\n                 targets: targets.clone(),\n             },\n             Drop { ref place, target, unwind } => {"}, {"sha": "58dd0bc00d2040eb761367ee091ebc3cc91ffe53", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -453,7 +453,6 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::SwitchInt {\n                         discr,\n                         switch_ty,\n-                        values: _,\n                         targets: _\n                     } => {\n                         self.visit_operand(discr, location);\n@@ -1187,16 +1186,6 @@ impl PlaceContext {\n         )\n     }\n \n-    /// Returns `true` if this place context represents a storage live marker.\n-    pub fn is_storage_live_marker(&self) -> bool {\n-        matches!(self, PlaceContext::NonUse(NonUseContext::StorageLive))\n-    }\n-\n-    /// Returns `true` if this place context represents a storage dead marker.\n-    pub fn is_storage_dead_marker(&self) -> bool {\n-        matches!(self, PlaceContext::NonUse(NonUseContext::StorageDead))\n-    }\n-\n     /// Returns `true` if this place context represents a use that potentially changes the value.\n     pub fn is_mutating_use(&self) -> bool {\n         matches!(self, PlaceContext::MutatingUse(..))"}, {"sha": "1acb44f6d22f3b80873d463932845a8fe2dd9631", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -92,7 +92,7 @@ rustc_queries! {\n         /// Computes the `DefId` of the corresponding const parameter in case the `key` is a\n         /// const argument and returns `None` otherwise.\n         ///\n-        /// ```rust\n+        /// ```ignore (incomplete)\n         /// let a = foo::<7>();\n         /// //            ^ Calling `opt_const_param_of` for this argument,\n         ///\n@@ -162,10 +162,12 @@ rustc_queries! {\n         /// Specifically this is the bounds written on the trait's type\n         /// definition, or those after the `impl` keyword\n         ///\n+        /// ```ignore (incomplete)\n         /// type X: Bound + 'lt\n-        ///         ^^^^^^^^^^^\n+        /// //      ^^^^^^^^^^^\n         /// impl Debug + Display\n-        ///      ^^^^^^^^^^^^^^^\n+        /// //   ^^^^^^^^^^^^^^^\n+        /// ```\n         ///\n         /// `key` is the `DefId` of the associated type or opaque type.\n         ///\n@@ -176,18 +178,22 @@ rustc_queries! {\n \n         /// Elaborated version of the predicates from `explicit_item_bounds`.\n         ///\n-        /// Example for\n+        /// For example:\n         ///\n+        /// ```\n         /// trait MyTrait {\n-        ///     type MyAType: Eq + ?Sized`\n+        ///     type MyAType: Eq + ?Sized;\n         /// }\n+        /// ```\n         ///\n         /// `explicit_item_bounds` returns `[<Self as MyTrait>::MyAType: Eq]`,\n         /// and `item_bounds` returns\n+        /// ```text\n         /// [\n         ///     <Self as Trait>::MyAType: Eq,\n         ///     <Self as Trait>::MyAType: PartialEq<<Self as Trait>::MyAType>\n         /// ]\n+        /// ```\n         ///\n         /// Bounds from the parent (e.g. with nested impl trait) are not included.\n         query item_bounds(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {"}, {"sha": "aaf6a8570437cf953731d11110a8beaf2a78b5bc", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -182,14 +182,6 @@ pub trait TyDecoder<'tcx>: Decoder {\n     where\n         F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>;\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R;"}, {"sha": "e24ba6d7a1e3db17e5b21beded8a6757061e80bb", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -534,10 +534,6 @@ impl<'tcx> TypeckResults<'tcx> {\n         self.node_type(pat.hir_id)\n     }\n \n-    pub fn pat_ty_opt(&self, pat: &hir::Pat<'_>) -> Option<Ty<'tcx>> {\n-        self.node_type_opt(pat.hir_id)\n-    }\n-\n     // Returns the type of an expression as a monotype.\n     //\n     // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n@@ -1083,7 +1079,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         crate_name: &str,\n         output_filenames: &OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n-        let data_layout = TargetDataLayout::parse(&s.target.target).unwrap_or_else(|err| {\n+        let data_layout = TargetDataLayout::parse(&s.target).unwrap_or_else(|err| {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(arena);\n@@ -1526,7 +1522,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Determines whether identifiers in the assembly have strict naming rules.\n     /// Currently, only NVPTX* targets need it.\n     pub fn has_strict_asm_symbol_naming(self) -> bool {\n-        self.sess.target.target.arch.contains(\"nvptx\")\n+        self.sess.target.arch.contains(\"nvptx\")\n     }\n \n     /// Returns `&'static core::panic::Location<'static>`."}, {"sha": "5524d91a6d5331f7b71de2c2bd53062948236843", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 45, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -97,9 +97,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_types_or_consts(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_CT_INFER)\n     }\n-    fn has_infer_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_CT_INFER)\n-    }\n     fn needs_infer(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_INFER)\n     }\n@@ -113,9 +110,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn needs_subst(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_SUBST)\n     }\n-    fn has_re_placeholders(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_PLACEHOLDER)\n-    }\n     /// \"Free\" regions in this context means that it has any region\n     /// that is not (a) erased or (b) late-bound.\n     fn has_free_regions(&self) -> bool {\n@@ -719,21 +713,15 @@ impl<'tcx> TyCtxt<'tcx> {\n // vars. See comment on `shift_vars_through_binders` method in\n // `subst.rs` for more details.\n \n-enum Direction {\n-    In,\n-    Out,\n-}\n-\n struct Shifter<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n-    direction: Direction,\n }\n \n impl Shifter<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, amount: u32, direction: Direction) -> Self {\n-        Shifter { tcx, current_index: ty::INNERMOST, amount, direction }\n+    pub fn new(tcx: TyCtxt<'tcx>, amount: u32) -> Self {\n+        Shifter { tcx, current_index: ty::INNERMOST, amount }\n     }\n }\n \n@@ -755,13 +743,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     r\n                 } else {\n-                    let debruijn = match self.direction {\n-                        Direction::In => debruijn.shifted_in(self.amount),\n-                        Direction::Out => {\n-                            assert!(debruijn.as_u32() >= self.amount);\n-                            debruijn.shifted_out(self.amount)\n-                        }\n-                    };\n+                    let debruijn = debruijn.shifted_in(self.amount);\n                     let shifted = ty::ReLateBound(debruijn, br);\n                     self.tcx.mk_region(shifted)\n                 }\n@@ -776,13 +758,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n                 } else {\n-                    let debruijn = match self.direction {\n-                        Direction::In => debruijn.shifted_in(self.amount),\n-                        Direction::Out => {\n-                            assert!(debruijn.as_u32() >= self.amount);\n-                            debruijn.shifted_out(self.amount)\n-                        }\n-                    };\n+                    let debruijn = debruijn.shifted_in(self.amount);\n                     self.tcx.mk_ty(ty::Bound(debruijn, bound_ty))\n                 }\n             }\n@@ -796,13 +772,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n-                let debruijn = match self.direction {\n-                    Direction::In => debruijn.shifted_in(self.amount),\n-                    Direction::Out => {\n-                        assert!(debruijn.as_u32() >= self.amount);\n-                        debruijn.shifted_out(self.amount)\n-                    }\n-                };\n+                let debruijn = debruijn.shifted_in(self.amount);\n                 self.tcx.mk_const(ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), ty })\n             }\n         } else {\n@@ -830,16 +800,7 @@ where\n {\n     debug!(\"shift_vars(value={:?}, amount={})\", value, amount);\n \n-    value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n-}\n-\n-pub fn shift_out_vars<'tcx, T>(tcx: TyCtxt<'tcx>, value: &T, amount: u32) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    debug!(\"shift_out_vars(value={:?}, amount={})\", value, amount);\n-\n-    value.fold_with(&mut Shifter::new(tcx, amount, Direction::Out))\n+    value.fold_with(&mut Shifter::new(tcx, amount))\n }\n \n /// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a"}, {"sha": "bf1f5b81c9fd1c1b2d734df02684d5c008a366f2", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -104,14 +104,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         // ```\n         ty.uninhabited_from(self, param_env).contains(self, module)\n     }\n-\n-    pub fn is_ty_uninhabited_from_any_module(\n-        self,\n-        ty: Ty<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        !ty.uninhabited_from(self, param_env).is_empty()\n-    }\n }\n \n impl<'tcx> AdtDef {"}, {"sha": "4a2c97b4a400f6a2b5f9c5acced34241cdd37476", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -291,7 +291,17 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     pub fn mono(tcx: TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, tcx.empty_substs_for_def_id(def_id))\n+        let substs = InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+            ty::GenericParamDefKind::Type { .. } => {\n+                bug!(\"Instance::mono: {:?} has type parameters\", def_id)\n+            }\n+            ty::GenericParamDefKind::Const { .. } => {\n+                bug!(\"Instance::mono: {:?} has const parameters\", def_id)\n+            }\n+        });\n+\n+        Instance::new(def_id, substs)\n     }\n \n     #[inline]"}, {"sha": "91c3dcbfa81cfa9fad6c87a1224a6326505bb5d4", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -106,7 +106,7 @@ impl IntegerExt for Integer {\n         }\n \n         if repr.c() {\n-            match &tcx.sess.target.target.arch[..] {\n+            match &tcx.sess.target.arch[..] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding\n                 // to `at_least == I32` appears to be used on Linux and NetBSD,\n                 // but some systems may use the variant corresponding to no\n@@ -1894,7 +1894,7 @@ impl<'tcx, T: HasTyCtxt<'tcx>> HasTyCtxt<'tcx> for LayoutCx<'tcx, T> {\n     }\n }\n \n-pub type TyAndLayout<'tcx> = ::rustc_target::abi::TyAndLayout<'tcx, Ty<'tcx>>;\n+pub type TyAndLayout<'tcx> = rustc_target::abi::TyAndLayout<'tcx, Ty<'tcx>>;\n \n impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     type Ty = Ty<'tcx>;\n@@ -2548,7 +2548,7 @@ where\n         let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n \n         use rustc_target::spec::abi::Abi::*;\n-        let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n+        let conv = match cx.tcx().sess.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n \n             // It's the ABI's job to select this, not ours.\n@@ -2600,7 +2600,7 @@ where\n             extra_args.to_vec()\n         };\n \n-        let target = &cx.tcx().sess.target.target;\n+        let target = &cx.tcx().sess.target;\n         let target_env_gnu_like = matches!(&target.target_env[..], \"gnu\" | \"musl\");\n         let win_x64_gnu =\n             target.target_os == \"windows\" && target.arch == \"x86_64\" && target.target_env == \"gnu\";\n@@ -2775,7 +2775,7 @@ where\n                     // anyway, we control all calls to it in libstd.\n                     Abi::Vector { .. }\n                         if abi != SpecAbi::PlatformIntrinsic\n-                            && cx.tcx().sess.target.target.options.simd_types_indirect =>\n+                            && cx.tcx().sess.target.options.simd_types_indirect =>\n                     {\n                         arg.make_indirect();\n                         return;"}, {"sha": "275888b0ce24752c32a3aa8a8de9f9e071377af8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -7,7 +7,6 @@ pub use self::Variance::*;\n \n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n-use crate::infer::canonical::Canonical;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::interpret::ErrorHandled;\n@@ -656,8 +655,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n@@ -767,10 +764,6 @@ pub enum IntVarValue {\n pub struct FloatVarValue(pub ast::FloatTy);\n \n impl ty::EarlyBoundRegion {\n-    pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        ty::BoundRegion::BrNamed(self.def_id, self.name)\n-    }\n-\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n     pub fn has_name(&self) -> bool {\n@@ -821,14 +814,6 @@ impl GenericParamDef {\n             bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n         }\n     }\n-\n-    pub fn to_bound_region(&self) -> ty::BoundRegion {\n-        if let GenericParamDefKind::Lifetime = self.kind {\n-            self.to_early_bound_region_data().to_bound_region()\n-        } else {\n-            bug!(\"cannot convert a non-lifetime parameter def to an early bound region\")\n-        }\n-    }\n }\n \n #[derive(Default)]\n@@ -1003,22 +988,6 @@ impl<'tcx> GenericPredicates<'tcx> {\n         instantiated.predicates.extend(self.predicates.iter().map(|(p, _)| p));\n         instantiated.spans.extend(self.predicates.iter().map(|(_, s)| s));\n     }\n-\n-    pub fn instantiate_supertrait(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        poly_trait_ref: &ty::PolyTraitRef<'tcx>,\n-    ) -> InstantiatedPredicates<'tcx> {\n-        assert_eq!(self.parent, None);\n-        InstantiatedPredicates {\n-            predicates: self\n-                .predicates\n-                .iter()\n-                .map(|(pred, _)| pred.subst_supertrait(tcx, poly_trait_ref))\n-                .collect(),\n-            spans: self.predicates.iter().map(|(_, sp)| *sp).collect(),\n-        }\n-    }\n }\n \n #[derive(Debug)]\n@@ -1303,7 +1272,6 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n-pub type PolyOutlivesPredicate<A, B> = ty::Binder<OutlivesPredicate<A, B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n@@ -2953,13 +2921,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n         match instance {\n-            ty::InstanceDef::Item(def) => {\n-                if let Some((did, param_did)) = def.as_const_arg() {\n-                    self.optimized_mir_of_const_arg((did, param_did))\n-                } else {\n-                    self.optimized_mir(def.did)\n-                }\n-            }\n+            ty::InstanceDef::Item(def) => self.optimized_mir_opt_const_arg(def),\n             ty::InstanceDef::VtableShim(..)\n             | ty::InstanceDef::ReifyShim(..)\n             | ty::InstanceDef::Intrinsic(..)"}, {"sha": "a594a8ad51240f8c7d524f5868c08bd47bfb62c4", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -23,7 +23,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         debug!(\n             \"normalize_erasing_regions::<{}>(value={:?}, param_env={:?})\",\n-            ::std::any::type_name::<T>(),\n+            std::any::type_name::<T>(),\n             value,\n             param_env,\n         );"}, {"sha": "86750d5c081113e9126d6745cc74adfcd81efa15", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -96,16 +96,14 @@ fn compute_components(\n             }\n \n             ty::Closure(_, ref substs) => {\n-                for upvar_ty in substs.as_closure().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out, visited);\n-                }\n+                let tupled_ty = substs.as_closure().tupled_upvars_ty();\n+                compute_components(tcx, tupled_ty, out, visited);\n             }\n \n             ty::Generator(_, ref substs, _) => {\n                 // Same as the closure case\n-                for upvar_ty in substs.as_generator().upvar_tys() {\n-                    compute_components(tcx, upvar_ty, out, visited);\n-                }\n+                let tupled_ty = substs.as_generator().tupled_upvars_ty();\n+                compute_components(tcx, tupled_ty, out, visited);\n \n                 // We ignore regions in the generator interior as we don't\n                 // want these to affect region inference"}, {"sha": "08f88eed66f80d0ca131d7bef792ea1bd4ffbbdf", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -663,18 +663,13 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                 } else {\n                     p!(print_def_path(did, substs));\n-                    if substs.as_generator().is_valid() {\n-                        // Search for the first inference variable\n-                        p!(\" upvar_tys=(\");\n-                        let mut uninferred_ty =\n-                            substs.as_generator().upvar_tys().filter(|ty| ty.is_ty_infer());\n-                        if uninferred_ty.next().is_some() {\n-                            p!(write(\"unavailable\"));\n-                        } else {\n-                            self = self.comma_sep(substs.as_generator().upvar_tys())?;\n-                        }\n-                        p!(\")\");\n+                    p!(\" upvar_tys=(\");\n+                    if !substs.as_generator().is_valid() {\n+                        p!(\"unavailable\");\n+                    } else {\n+                        self = self.comma_sep(substs.as_generator().upvar_tys())?;\n                     }\n+                    p!(\")\");\n                 }\n \n                 if substs.as_generator().is_valid() {\n@@ -704,24 +699,17 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                 } else {\n                     p!(print_def_path(did, substs));\n-                    if substs.as_closure().is_valid() {\n-                        // Search for the first inference variable\n-                        let mut uninferred_ty =\n-                            substs.as_closure().upvar_tys().filter(|ty| ty.is_ty_infer());\n-                        if uninferred_ty.next().is_some() {\n-                            // If the upvar substs contain an inference variable we haven't\n-                            // finished capture analysis.\n-                            p!(\" closure_substs=(unavailable)\");\n-                        } else {\n-                            p!(\" closure_kind_ty=\", print(substs.as_closure().kind_ty()));\n-                            p!(\n-                                \" closure_sig_as_fn_ptr_ty=\",\n-                                print(substs.as_closure().sig_as_fn_ptr_ty())\n-                            );\n-                            p!(\" upvar_tys=(\");\n-                            self = self.comma_sep(substs.as_closure().upvar_tys())?;\n-                            p!(\")\");\n-                        }\n+                    if !substs.as_closure().is_valid() {\n+                        p!(\" closure_substs=(unavailable)\");\n+                    } else {\n+                        p!(\" closure_kind_ty=\", print(substs.as_closure().kind_ty()));\n+                        p!(\n+                            \" closure_sig_as_fn_ptr_ty=\",\n+                            print(substs.as_closure().sig_as_fn_ptr_ty())\n+                        );\n+                        p!(\" upvar_tys=(\");\n+                        self = self.comma_sep(substs.as_closure().upvar_tys())?;\n+                        p!(\")\");\n                     }\n                 }\n                 p!(\"]\");\n@@ -1142,7 +1130,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // relocations (we have an active `str` reference here). We don't use this\n                 // result to affect interpreter execution.\n                 let slice = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n-                let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+                let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n                 p!(write(\"{:?}\", s));\n                 Ok(self)\n             }"}, {"sha": "173e9a31928b5d89f0dfbf56a8abc7569098bc87", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -543,7 +543,7 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n // tag matches and the correct amount of bytes was read.\n fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n where\n-    T: Decodable<D> + Eq + ::std::fmt::Debug,\n+    T: Decodable<D> + Eq + std::fmt::Debug,\n     V: Decodable<D>,\n     D: DecoderWithPosition,\n {\n@@ -601,29 +601,6 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         Ok(ty)\n     }\n \n-    fn cached_predicate_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n-    {\n-        let tcx = self.tcx();\n-\n-        let cache_key =\n-            ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n-\n-        if let Some(&pred) = tcx.pred_rcache.borrow().get(&cache_key) {\n-            return Ok(pred);\n-        }\n-\n-        let pred = or_insert_with(self)?;\n-        // This may overwrite the entry, but it should overwrite with the same value.\n-        tcx.pred_rcache.borrow_mut().insert_same(cache_key, pred);\n-        Ok(pred)\n-    }\n-\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -1023,7 +1000,7 @@ where\n     let _timer = tcx\n         .sess\n         .prof\n-        .extra_verbose_generic_activity(\"encode_query_results_for\", ::std::any::type_name::<Q>());\n+        .extra_verbose_generic_activity(\"encode_query_results_for\", std::any::type_name::<Q>());\n \n     let state = Q::query_state(tcx);\n     assert!(state.all_inactive());"}, {"sha": "27bf22dac75cb6fd0bcc30f7899c5eb0a9ce476d", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -124,20 +124,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn try_print_query_stack(handler: &Handler) {\n+    pub fn try_print_query_stack(handler: &Handler, num_frames: Option<usize>) {\n         eprintln!(\"query stack during panic:\");\n \n         // Be careful reyling on global state here: this code is called from\n         // a panic hook, which means that the global `Handler` may be in a weird\n         // state if it was responsible for triggering the panic.\n+        let mut i = 0;\n         ty::tls::with_context_opt(|icx| {\n             if let Some(icx) = icx {\n                 let query_map = icx.tcx.queries.try_collect_active_jobs();\n \n                 let mut current_query = icx.query;\n-                let mut i = 0;\n \n                 while let Some(query) = current_query {\n+                    if Some(i) == num_frames {\n+                        break;\n+                    }\n                     let query_info =\n                         if let Some(info) = query_map.as_ref().and_then(|map| map.get(&query)) {\n                             info\n@@ -163,7 +166,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         });\n \n-        eprintln!(\"end of query stack\");\n+        if num_frames == None || num_frames >= Some(i) {\n+            eprintln!(\"end of query stack\");\n+        } else {\n+            eprintln!(\"we're just showing a limited slice of the query stack\");\n+        }\n     }\n }\n "}, {"sha": "870cc4eee05058252e37c433eead1b4afcec3de5", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -656,6 +656,14 @@ impl<'tcx> UpvarSubsts<'tcx> {\n         };\n         tupled_upvars_ty.expect_ty().tuple_fields()\n     }\n+\n+    #[inline]\n+    pub fn tupled_upvars_ty(self) -> Ty<'tcx> {\n+        match self {\n+            UpvarSubsts::Closure(substs) => substs.as_closure().tupled_upvars_ty(),\n+            UpvarSubsts::Generator(substs) => substs.as_generator().tupled_upvars_ty(),\n+        }\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, TyEncodable, TyDecodable)]"}, {"sha": "7d96adb7c8b4e41373726d3d0c122c6c6cecc5e7", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,5 @@\n // Type substitutions.\n \n-use crate::infer::canonical::Canonical;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n@@ -648,8 +647,6 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n     }\n }\n \n-pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n-\n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]"}, {"sha": "86476dffc0312d4690f786b90f169ca8743501f0", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -123,10 +123,26 @@ impl<'tcx> TyCtxt<'tcx> {\n         self_ty: Ty<'tcx>,\n         mut f: F,\n     ) {\n+        let _: Option<()> = self.find_map_relevant_impl(def_id, self_ty, |did| {\n+            f(did);\n+            None\n+        });\n+    }\n+\n+    /// Applies function to every impl that could possibly match the self type `self_ty` and returns\n+    /// the first non-none value.\n+    pub fn find_map_relevant_impl<T, F: FnMut(DefId) -> Option<T>>(\n+        self,\n+        def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        mut f: F,\n+    ) -> Option<T> {\n         let impls = self.trait_impls_of(def_id);\n \n         for &impl_def_id in impls.blanket_impls.iter() {\n-            f(impl_def_id);\n+            if let result @ Some(_) = f(impl_def_id) {\n+                return result;\n+            }\n         }\n \n         // simplify_type(.., false) basically replaces type parameters and\n@@ -157,14 +173,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(simp) = fast_reject::simplify_type(self, self_ty, true) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n-                    f(impl_def_id);\n+                    if let result @ Some(_) = f(impl_def_id) {\n+                        return result;\n+                    }\n                 }\n             }\n         } else {\n             for &impl_def_id in impls.non_blanket_impls.values().flatten() {\n-                f(impl_def_id);\n+                if let result @ Some(_) = f(impl_def_id) {\n+                    return result;\n+                }\n             }\n         }\n+\n+        None\n     }\n \n     /// Returns an iterator containing all impls"}, {"sha": "b0f0f0ba57fad745d638307aabe7b76f338832a7", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -6,9 +6,9 @@ use crate::mir::interpret::{sign_extend, truncate};\n use crate::ty::fold::TypeFolder;\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n-use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n use crate::ty::TyKind::*;\n-use crate::ty::{self, DefIdTree, GenericParamDefKind, List, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, DefIdTree, List, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n@@ -341,19 +341,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn calculate_dtor(\n         self,\n         adt_did: DefId,\n-        validate: &mut dyn FnMut(Self, DefId) -> Result<(), ErrorReported>,\n+        validate: impl Fn(Self, DefId) -> Result<(), ErrorReported>,\n     ) -> Option<ty::Destructor> {\n         let drop_trait = self.lang_items().drop_trait()?;\n         self.ensure().coherent_trait(drop_trait);\n \n-        let mut dtor_did = None;\n         let ty = self.type_of(adt_did);\n-        self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n+        let dtor_did = self.find_map_relevant_impl(drop_trait, ty, |impl_did| {\n             if let Some(item) = self.associated_items(impl_did).in_definition_order().next() {\n                 if validate(self, impl_did).is_ok() {\n-                    dtor_did = Some(item.def_id);\n+                    return Some(item.def_id);\n                 }\n             }\n+            None\n         });\n \n         Some(ty::Destructor { did: dtor_did? })\n@@ -509,20 +509,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(ty::Binder::bind(env_ty))\n     }\n \n-    /// Given the `DefId` of some item that has no type or const parameters, make\n-    /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> SubstsRef<'tcx> {\n-        InternalSubsts::for_item(self, item_def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => self.lifetimes.re_erased.into(),\n-            GenericParamDefKind::Type { .. } => {\n-                bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n-            }\n-            GenericParamDefKind::Const { .. } => {\n-                bug!(\"empty_substs_for_def_id: {:?} has const parameters\", item_def_id)\n-            }\n-        })\n-    }\n-\n     /// Returns `true` if the node pointed to by `def_id` is a `static` item.\n     pub fn is_static(self, def_id: DefId) -> bool {\n         self.static_mutability(def_id).is_some()\n@@ -646,8 +632,8 @@ impl<'tcx> ty::TyS<'tcx> {\n             }\n             ty::Char => Some(std::char::MAX as u128),\n             ty::Float(fty) => Some(match fty {\n-                ast::FloatTy::F32 => ::rustc_apfloat::ieee::Single::INFINITY.to_bits(),\n-                ast::FloatTy::F64 => ::rustc_apfloat::ieee::Double::INFINITY.to_bits(),\n+                ast::FloatTy::F32 => rustc_apfloat::ieee::Single::INFINITY.to_bits(),\n+                ast::FloatTy::F64 => rustc_apfloat::ieee::Double::INFINITY.to_bits(),\n             }),\n             _ => None,\n         };"}, {"sha": "e1af6fc07cf8fd30be4f2a46c1d3808764ce202b", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,11 +1,11 @@\n use rustc_hir as hir;\n use rustc_hir::Node;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::{self, ClearCrossCrate, Local, LocalInfo, Location};\n+use rustc_middle::mir::{self, ClearCrossCrate, Local, LocalDecl, LocalInfo, Location};\n use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::source_map::DesugaringKind;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::Span;\n \n use crate::borrow_check::diagnostics::BorrowedContentSource;\n@@ -211,36 +211,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             // Suggest removing a `&mut` from the use of a mutable reference.\n             PlaceRef { local, projection: [] }\n-                if {\n-                    self.body\n-                        .local_decls\n-                        .get(local)\n-                        .map(|local_decl| {\n-                            if let Some(box LocalInfo::User(ClearCrossCrate::Set(\n-                                mir::BindingForm::ImplicitSelf(kind),\n-                            ))) = local_decl.local_info\n-                            {\n-                                // Check if the user variable is a `&mut self` and we can therefore\n-                                // suggest removing the `&mut`.\n-                                //\n-                                // Deliberately fall into this case for all implicit self types,\n-                                // so that we don't fall in to the next case with them.\n-                                kind == mir::ImplicitSelfKind::MutRef\n-                            } else if Some(kw::SelfLower) == self.local_names[local] {\n-                                // Otherwise, check if the name is the self kewyord - in which case\n-                                // we have an explicit self. Do the same thing in this case and check\n-                                // for a `self: &mut Self` to suggest removing the `&mut`.\n-                                if let ty::Ref(_, _, hir::Mutability::Mut) = local_decl.ty.kind() {\n-                                    true\n-                                } else {\n-                                    false\n-                                }\n-                            } else {\n-                                false\n-                            }\n-                        })\n-                        .unwrap_or(false)\n-                } =>\n+                if self\n+                    .body\n+                    .local_decls\n+                    .get(local)\n+                    .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local]))\n+                    .unwrap_or(false) =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_label(span, \"try removing `&mut` here\");\n@@ -581,6 +557,34 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n+fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n+    debug!(\"local_info: {:?}, ty.kind(): {:?}\", local_decl.local_info, local_decl.ty.kind());\n+\n+    match local_decl.local_info.as_deref() {\n+        // Check if mutably borrowing a mutable reference.\n+        Some(LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+            mir::VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(Mutability::Not), ..\n+            },\n+        )))) => matches!(local_decl.ty.kind(), ty::Ref(_, _, hir::Mutability::Mut)),\n+        Some(LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(kind)))) => {\n+            // Check if the user variable is a `&mut self` and we can therefore\n+            // suggest removing the `&mut`.\n+            //\n+            // Deliberately fall into this case for all implicit self types,\n+            // so that we don't fall in to the next case with them.\n+            *kind == mir::ImplicitSelfKind::MutRef\n+        }\n+        _ if Some(kw::SelfLower) == local_name => {\n+            // Otherwise, check if the name is the `self` keyword - in which case\n+            // we have an explicit self. Do the same thing in this case and check\n+            // for a `self: &mut Self` to suggest removing the `&mut`.\n+            matches!(local_decl.ty.kind(), ty::Ref(_, _, hir::Mutability::Mut))\n+        }\n+        _ => false,\n+    }\n+}\n+\n fn suggest_ampmut_self<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     local_decl: &mir::LocalDecl<'tcx>,"}, {"sha": "8c05e6fd5d0e4bf32bba4987f59b123241efa96b", "filename": "compiler/rustc_mir/src/borrow_check/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -117,7 +117,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match &terminator.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {"}, {"sha": "4b7af271baef046467f84542839f78ecf5ff71a2", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -671,7 +671,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n         self.check_activations(loc, span, flow_state);\n \n         match term.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { place: ref drop_place, target: _, unwind: _ } => {"}, {"sha": "4fc1c570e4602fbad802d6aa4556b777a4204603", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1777,7 +1777,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup)\n             }\n             TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n+                for target in targets.all_targets() {\n                     self.assert_iscleanup(body, block_data, *target, is_cleanup);\n                 }\n             }"}, {"sha": "6ef73b04238d4d00cd88587a1c54b9df26b0092e", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -343,7 +343,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     // deny-by-default lint\n                     _ => {\n                         if let Some(p) = cid.promoted {\n-                            let span = tcx.promoted_mir_of_opt_const_arg(def.to_global())[p].span;\n+                            let span = tcx.promoted_mir_opt_const_arg(def.to_global())[p].span;\n                             if let err_inval!(ReferencedConstant) = err.error {\n                                 Err(err.report_as_error(\n                                     tcx.at(span),"}, {"sha": "4b235e1aa4a50f46df1363134181168e496eaa1c", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -50,7 +50,7 @@ pub(crate) fn destructure_const<'tcx>(\n     let (field_count, variant, down) = match val.ty.kind() {\n         ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n         ty::Adt(def, _) if def.variants.is_empty() => {\n-            return mir::DestructuredConst { variant: None, fields: tcx.arena.alloc_slice(&[]) };\n+            return mir::DestructuredConst { variant: None, fields: &[] };\n         }\n         ty::Adt(def, _) => {\n             let variant = ecx.read_discriminant(op).unwrap().1;"}, {"sha": "8a9ced91eb3763c66d15f6799f6c7a78e1408526", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::bit_set::BitSet;\n-use rustc_middle::mir::{self, BasicBlock, Location};\n+use rustc_middle::mir::{self, BasicBlock, Location, SwitchTargets};\n use rustc_middle::ty::TyCtxt;\n use std::ops::RangeInclusive;\n \n@@ -488,11 +488,10 @@ impl Direction for Forward {\n                 }\n             }\n \n-            SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n+            SwitchInt { ref targets, ref discr, switch_ty: _ } => {\n                 let mut applier = SwitchIntEdgeEffectApplier {\n                     exit_state,\n-                    targets: targets.as_ref(),\n-                    values: values.as_ref(),\n+                    targets,\n                     propagate,\n                     effects_applied: false,\n                 };\n@@ -504,8 +503,8 @@ impl Direction for Forward {\n                 } = applier;\n \n                 if !effects_applied {\n-                    for &target in targets.iter() {\n-                        propagate(target, exit_state);\n+                    for target in targets.all_targets() {\n+                        propagate(*target, exit_state);\n                     }\n                 }\n             }\n@@ -515,8 +514,7 @@ impl Direction for Forward {\n \n struct SwitchIntEdgeEffectApplier<'a, D, F> {\n     exit_state: &'a mut D,\n-    values: &'a [u128],\n-    targets: &'a [BasicBlock],\n+    targets: &'a SwitchTargets,\n     propagate: F,\n \n     effects_applied: bool,\n@@ -531,15 +529,15 @@ where\n         assert!(!self.effects_applied);\n \n         let mut tmp = None;\n-        for (&value, &target) in self.values.iter().zip(self.targets.iter()) {\n+        for (value, target) in self.targets.iter() {\n             let tmp = opt_clone_from_or_clone(&mut tmp, self.exit_state);\n             apply_edge_effect(tmp, SwitchIntTarget { value: Some(value), target });\n             (self.propagate)(target, tmp);\n         }\n \n         // Once we get to the final, \"otherwise\" branch, there is no need to preserve `exit_state`,\n         // so pass it directly to `apply_edge_effect` to save a clone of the dataflow state.\n-        let otherwise = self.targets.last().copied().unwrap();\n+        let otherwise = self.targets.otherwise();\n         apply_edge_effect(self.exit_state, SwitchIntTarget { value: None, target: otherwise });\n         (self.propagate)(otherwise, self.exit_state);\n "}, {"sha": "1b7264f86a2d159348da7d67d0e24c944ef59f56", "filename": "compiler/rustc_mir/src/dataflow/framework/engine.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fengine.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -2,7 +2,6 @@\n \n use std::borrow::BorrowMut;\n use std::ffi::OsString;\n-use std::fs;\n use std::path::PathBuf;\n \n use rustc_ast as ast;\n@@ -12,7 +11,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, traversal, BasicBlock};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n \n use super::fmt::DebugWithContext;\n@@ -21,7 +20,7 @@ use super::{\n     visit_results, Analysis, Direction, GenKill, GenKillAnalysis, GenKillSet, JoinSemiLattice,\n     ResultsCursor, ResultsVisitor,\n };\n-use crate::util::pretty::dump_enabled;\n+use crate::util::pretty::{create_dump_file, dump_enabled};\n \n /// A dataflow analysis that has converged to fixpoint.\n pub struct Results<'tcx, A>\n@@ -63,15 +62,6 @@ where\n         let blocks = mir::traversal::reachable(body);\n         visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n     }\n-\n-    pub fn visit_in_rpo_with(\n-        &self,\n-        body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = A::Domain>,\n-    ) {\n-        let blocks = mir::traversal::reverse_postorder(body);\n-        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n-    }\n }\n \n /// A solver for dataflow problems.\n@@ -249,7 +239,7 @@ where\n \n         let res = write_graphviz_results(tcx, &body, &results, pass_name);\n         if let Err(e) = res {\n-            warn!(\"Failed to write graphviz dataflow results: {}\", e);\n+            error!(\"Failed to write graphviz dataflow results: {}\", e);\n         }\n \n         results\n@@ -270,6 +260,9 @@ where\n     A: Analysis<'tcx>,\n     A::Domain: DebugWithContext<A>,\n {\n+    use std::fs;\n+    use std::io::{self, Write};\n+\n     let def_id = body.source.def_id();\n     let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n         Ok(attrs) => attrs,\n@@ -278,35 +271,36 @@ where\n         Err(()) => return Ok(()),\n     };\n \n-    let path = match attrs.output_path(A::NAME) {\n-        Some(path) => path,\n+    let mut file = match attrs.output_path(A::NAME) {\n+        Some(path) => {\n+            debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n+            if let Some(parent) = path.parent() {\n+                fs::create_dir_all(parent)?;\n+            }\n+            io::BufWriter::new(fs::File::create(&path)?)\n+        }\n \n         None if tcx.sess.opts.debugging_opts.dump_mir_dataflow\n             && dump_enabled(tcx, A::NAME, def_id) =>\n         {\n-            // FIXME: Use some variant of `pretty::dump_path` for this\n-            let mut path = PathBuf::from(&tcx.sess.opts.debugging_opts.dump_mir_dir);\n-\n-            let crate_name = tcx.crate_name(def_id.krate);\n-            let item_name = ty::print::with_forced_impl_filename_line(|| {\n-                tcx.def_path(def_id).to_filename_friendly_no_crate()\n-            });\n-\n-            let pass_name = pass_name.map(|s| format!(\".{}\", s)).unwrap_or_default();\n-\n-            path.push(format!(\"{}.{}.{}{}.dot\", crate_name, item_name, A::NAME, pass_name));\n-            path\n+            create_dump_file(\n+                tcx,\n+                \".dot\",\n+                None,\n+                A::NAME,\n+                &pass_name.unwrap_or(\"-----\"),\n+                body.source,\n+            )?\n         }\n \n-        None => return Ok(()),\n+        _ => return Ok(()),\n     };\n \n     let style = match attrs.formatter {\n         Some(sym::two_phase) => graphviz::OutputStyle::BeforeAndAfter,\n         _ => graphviz::OutputStyle::AfterOnly,\n     };\n \n-    debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());\n     let mut buf = Vec::new();\n \n     let graphviz = graphviz::Formatter::new(body, results, style);\n@@ -317,10 +311,7 @@ where\n     }\n     dot::render_opts(&graphviz, &mut buf, &render_opts)?;\n \n-    if let Some(parent) = path.parent() {\n-        fs::create_dir_all(parent)?;\n-    }\n-    fs::write(&path, buf)?;\n+    file.write_all(&buf)?;\n \n     Ok(())\n }"}, {"sha": "ec1195d3703b449586750767eb3b6c49fcce718d", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -477,16 +477,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         if let Some(promoted) = promoted {\n-            return Ok(&self.tcx.promoted_mir_of_opt_const_arg(def)[promoted]);\n+            return Ok(&self.tcx.promoted_mir_opt_const_arg(def)[promoted]);\n         }\n         match instance {\n             ty::InstanceDef::Item(def) => {\n                 if self.tcx.is_mir_available(def.did) {\n-                    if let Some((did, param_did)) = def.as_const_arg() {\n-                        Ok(self.tcx.optimized_mir_of_const_arg((did, param_did)))\n-                    } else {\n-                        Ok(self.tcx.optimized_mir(def.did))\n-                    }\n+                    Ok(self.tcx.optimized_mir_opt_const_arg(def))\n                 } else {\n                     throw_unsup!(NoMirFor(def.did))\n                 }"}, {"sha": "66dbacb2f9d4d39af4c2b0421d5f3baf03c1dd27", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -3,6 +3,7 @@\n //! interpreting common C functions leak into CTFE.\n \n use std::borrow::{Borrow, Cow};\n+use std::fmt::Debug;\n use std::hash::Hash;\n \n use rustc_middle::mir;\n@@ -79,19 +80,19 @@ pub trait AllocMap<K: Hash + Eq, V> {\n /// and some use case dependent behaviour can instead be applied.\n pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKind: ::std::fmt::Debug + ::std::fmt::Display + MayLeak + Eq + 'static;\n+    type MemoryKind: Debug + std::fmt::Display + MayLeak + Eq + 'static;\n \n     /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     /// The `Debug` formatting is used for displaying pointers; we cannot use `Display`\n     /// as `()` does not implement that, but it should be \"nice\" output.\n-    type PointerTag: ::std::fmt::Debug + Copy + Eq + Hash + 'static;\n+    type PointerTag: Debug + Copy + Eq + Hash + 'static;\n \n     /// Machines can define extra (non-instance) things that represent values of function pointers.\n     /// For example, Miri uses this to return a function pointer from `dlsym`\n     /// that can later be called to execute the right thing.\n-    type ExtraFnVal: ::std::fmt::Debug + Copy;\n+    type ExtraFnVal: Debug + Copy;\n \n     /// Extra data stored in every call frame.\n     type FrameExtra;"}, {"sha": "d8f27ec95458b2bc852707e18d8088046f0d4efc", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -133,7 +133,7 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n+impl<'tcx, Tag> std::ops::Deref for ImmTy<'tcx, Tag> {\n     type Target = Immediate<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Immediate<Tag> {\n@@ -156,7 +156,7 @@ pub struct OpTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n-impl<'tcx, Tag> ::std::ops::Deref for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag> std::ops::Deref for OpTy<'tcx, Tag> {\n     type Target = Operand<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Operand<Tag> {\n@@ -340,7 +340,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n-        let str = ::std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n+        let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }\n "}, {"sha": "fe25f8ce962f0eab27c4e1e5436e1fed9c662f0f", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -3,6 +3,7 @@\n //! All high-level functions to write to memory work on places as destinations.\n \n use std::convert::TryFrom;\n+use std::fmt::Debug;\n use std::hash::Hash;\n \n use rustc_macros::HashStable;\n@@ -86,7 +87,7 @@ pub struct PlaceTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n-impl<'tcx, Tag> ::std::ops::Deref for PlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag> std::ops::Deref for PlaceTy<'tcx, Tag> {\n     type Target = Place<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &Place<Tag> {\n@@ -101,7 +102,7 @@ pub struct MPlaceTy<'tcx, Tag = ()> {\n     pub layout: TyAndLayout<'tcx>,\n }\n \n-impl<'tcx, Tag> ::std::ops::Deref for MPlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     type Target = MemPlace<Tag>;\n     #[inline(always)]\n     fn deref(&self) -> &MemPlace<Tag> {\n@@ -226,7 +227,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n }\n \n // These are defined here because they produce a place.\n-impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n+impl<'tcx, Tag: Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n     /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n     /// read from the resulting mplace, not to get its address back.\n@@ -251,7 +252,7 @@ impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     }\n }\n \n-impl<Tag: ::std::fmt::Debug> Place<Tag> {\n+impl<Tag: Debug> Place<Tag> {\n     #[inline]\n     pub fn assert_mem_place(self) -> MemPlace<Tag> {\n         match self {\n@@ -261,7 +262,7 @@ impl<Tag: ::std::fmt::Debug> Place<Tag> {\n     }\n }\n \n-impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n+impl<'tcx, Tag: Debug> PlaceTy<'tcx, Tag> {\n     #[inline]\n     pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         MPlaceTy { mplace: self.place.assert_mem_place(), layout: self.layout }\n@@ -272,7 +273,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n impl<'mir, 'tcx: 'mir, Tag, M> InterpCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n-    Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n+    Tag: Debug + Copy + Eq + Hash + 'static,\n     M: Machine<'mir, 'tcx, PointerTag = Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKind>, Allocation<Tag, M::AllocExtra>)>,"}, {"sha": "bb11c2a23bd813c230c94b9dfe0640ffed35701e", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -24,16 +24,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Goto { target } => self.go_to_block(target),\n \n-            SwitchInt { ref discr, ref values, ref targets, switch_ty } => {\n+            SwitchInt { ref discr, ref targets, switch_ty } => {\n                 let discr = self.read_immediate(self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n                 assert_eq!(discr.layout.ty, switch_ty);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n-                assert!(!targets.is_empty());\n-                let mut target_block = targets[targets.len() - 1];\n+                assert!(!targets.iter().is_empty());\n+                let mut target_block = targets.otherwise();\n \n-                for (index, &const_int) in values.iter().enumerate() {\n+                for (const_int, target) in targets.iter() {\n                     // Compare using binary_op, to also support pointer values\n                     let res = self\n                         .overflowing_binary_op(\n@@ -43,7 +43,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         )?\n                         .0;\n                     if res.to_bool()? {\n-                        target_block = targets[index];\n+                        target_block = target;\n                         break;\n                     }\n                 }"}, {"sha": "417176564b92d877df7eb21ca052fcc164401fda", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -197,6 +197,7 @@ use rustc_session::config::EntryFnType;\n use rustc_span::source_map::{dummy_spanned, respan, Span, Spanned, DUMMY_SP};\n use smallvec::SmallVec;\n use std::iter;\n+use std::ops::Range;\n use std::path::PathBuf;\n \n #[derive(PartialEq)]\n@@ -210,9 +211,8 @@ pub enum MonoItemCollectionMode {\n pub struct InliningMap<'tcx> {\n     // Maps a source mono item to the range of mono items\n     // accessed by it.\n-    // The two numbers in the tuple are the start (inclusive) and\n-    // end index (exclusive) within the `targets` vecs.\n-    index: FxHashMap<MonoItem<'tcx>, (usize, usize)>,\n+    // The range selects elements within the `targets` vecs.\n+    index: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n     targets: Vec<MonoItem<'tcx>>,\n \n     // Contains one bit per mono item in the `targets` field. That bit\n@@ -245,7 +245,7 @@ impl<'tcx> InliningMap<'tcx> {\n         }\n \n         let end_index = self.targets.len();\n-        assert!(self.index.insert(source, (start_index, end_index)).is_none());\n+        assert!(self.index.insert(source, start_index..end_index).is_none());\n     }\n \n     // Internally iterate over all items referenced by `source` which will be\n@@ -254,9 +254,9 @@ impl<'tcx> InliningMap<'tcx> {\n     where\n         F: FnMut(MonoItem<'tcx>),\n     {\n-        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n-            for (i, candidate) in self.targets[start_index..end_index].iter().enumerate() {\n-                if self.inlines.contains(start_index + i) {\n+        if let Some(range) = self.index.get(&source) {\n+            for (i, candidate) in self.targets[range.clone()].iter().enumerate() {\n+                if self.inlines.contains(range.start + i) {\n                     f(*candidate);\n                 }\n             }\n@@ -268,8 +268,8 @@ impl<'tcx> InliningMap<'tcx> {\n     where\n         F: FnMut(MonoItem<'tcx>, &[MonoItem<'tcx>]),\n     {\n-        for (&accessor, &(start_index, end_index)) in &self.index {\n-            f(accessor, &self.targets[start_index..end_index])\n+        for (&accessor, range) in &self.index {\n+            f(accessor, &self.targets[range.clone()])\n         }\n     }\n }"}, {"sha": "5083a45b539eda42755450a2ec98608b7b376495", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -532,7 +532,7 @@ fn mono_item_visibility(\n }\n \n fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n-    if !tcx.sess.target.target.options.default_hidden_visibility {\n+    if !tcx.sess.target.options.default_hidden_visibility {\n         return Visibility::Default;\n     }\n "}, {"sha": "fb89b36060a28ace819f2ffa1748cbc471a597a0", "filename": "compiler/rustc_mir/src/transform/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_const_item_mutation.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -34,7 +34,6 @@ impl<'a, 'tcx> ConstMutationChecker<'a, 'tcx> {\n \n     fn is_const_item_without_destructor(&self, local: Local) -> Option<DefId> {\n         let def_id = self.is_const_item(local)?;\n-        let mut any_dtor = |_tcx, _def_id| Ok(());\n \n         // We avoid linting mutation of a const item if the const's type has a\n         // Drop impl. The Drop logic observes the mutation which was performed.\n@@ -54,7 +53,7 @@ impl<'a, 'tcx> ConstMutationChecker<'a, 'tcx> {\n         //\n         //     #[const_mutation_allowed]\n         //     pub const LOG: Log = Log { msg: \"\" };\n-        match self.tcx.calculate_dtor(def_id, &mut any_dtor) {\n+        match self.tcx.calculate_dtor(def_id, |_, _| Ok(())) {\n             Some(_) => None,\n             None => Some(def_id),\n         }"}, {"sha": "63b20c7c0273dc4bf3137278dde6ccaae0b8a1d7", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -558,12 +558,17 @@ pub mod ty {\n     #[derive(Debug)]\n     pub struct ImplTrait;\n     impl NonConstOp for ImplTrait {\n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n-            mcf_status_in_item(ccx)\n+        fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+            Status::Unstable(sym::const_impl_trait)\n         }\n \n         fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n-            mcf_build_error(ccx, span, \"`impl Trait` in const fn is unstable\")\n+            feature_err(\n+                &ccx.tcx.sess.parse_sess,\n+                sym::const_impl_trait,\n+                span,\n+                &format!(\"`impl Trait` is not allowed in {}s\", ccx.const_kind()),\n+            )\n         }\n     }\n "}, {"sha": "f97dcf4852df477a398485fce1207949200a4329", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,7 +1,7 @@\n use crate::{transform::MirPass, util::patch::MirPatch};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{Ty, TyCtxt};\n-use std::{borrow::Cow, fmt::Debug};\n+use std::fmt::Debug;\n \n use super::simplify::simplify_cfg;\n \n@@ -95,24 +95,25 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n                 StatementKind::Assign(box (Place::from(not_equal_temp), not_equal_rvalue)),\n             );\n \n-            let (mut targets_to_jump_to, values_to_jump_to): (Vec<_>, Vec<_>) = opt_to_apply\n+            let new_targets = opt_to_apply\n                 .infos\n                 .iter()\n                 .flat_map(|x| x.second_switch_info.targets_with_values.iter())\n-                .cloned()\n-                .unzip();\n+                .cloned();\n+\n+            let targets = SwitchTargets::new(\n+                new_targets,\n+                opt_to_apply.infos[0].first_switch_info.otherwise_bb,\n+            );\n \n-            // add otherwise case in the end\n-            targets_to_jump_to.push(opt_to_apply.infos[0].first_switch_info.otherwise_bb);\n             // new block that jumps to the correct discriminant case. This block is switched to if the discriminants are equal\n             let new_switch_data = BasicBlockData::new(Some(Terminator {\n                 source_info: opt_to_apply.infos[0].second_switch_info.discr_source_info,\n                 kind: TerminatorKind::SwitchInt {\n                     // the first and second discriminants are equal, so just pick one\n                     discr: Operand::Copy(first_descriminant_place),\n                     switch_ty: discr_type,\n-                    values: Cow::from(values_to_jump_to),\n-                    targets: targets_to_jump_to,\n+                    targets,\n                 },\n             }));\n \n@@ -176,7 +177,7 @@ struct SwitchDiscriminantInfo<'tcx> {\n     /// The basic block that the otherwise branch points to\n     otherwise_bb: BasicBlock,\n     /// Target along with the value being branched from. Otherwise is not included\n-    targets_with_values: Vec<(BasicBlock, u128)>,\n+    targets_with_values: Vec<(u128, BasicBlock)>,\n     discr_source_info: SourceInfo,\n     /// The place of the discriminant used in the switch\n     discr_used_in_switch: Place<'tcx>,\n@@ -211,7 +212,7 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n         let discr = self.find_switch_discriminant_info(bb, switch)?;\n \n         // go through each target, finding a discriminant read, and a switch\n-        let results = discr.targets_with_values.iter().map(|(target, value)| {\n+        let results = discr.targets_with_values.iter().map(|(value, target)| {\n             self.find_discriminant_switch_pairing(&discr, target.clone(), value.clone())\n         });\n \n@@ -253,7 +254,7 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n             }\n \n             // check that the value being matched on is the same. The\n-            if this_bb_discr_info.targets_with_values.iter().find(|x| x.1 == value).is_none() {\n+            if this_bb_discr_info.targets_with_values.iter().find(|x| x.0 == value).is_none() {\n                 trace!(\"NO: values being matched on are not the same\");\n                 return None;\n             }\n@@ -270,7 +271,7 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n             //  ```\n             // We check this by seeing that the value of the first discriminant is the only other discriminant value being used as a target in the second switch\n             if !(this_bb_discr_info.targets_with_values.len() == 1\n-                && this_bb_discr_info.targets_with_values[0].1 == value)\n+                && this_bb_discr_info.targets_with_values[0].0 == value)\n             {\n                 trace!(\n                     \"NO: The second switch did not have only 1 target (besides otherwise) that had the same value as the value from the first switch that got us here\"\n@@ -296,18 +297,14 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n         switch: &Terminator<'tcx>,\n     ) -> Option<SwitchDiscriminantInfo<'tcx>> {\n         match &switch.kind {\n-            TerminatorKind::SwitchInt { discr, targets, values, .. } => {\n+            TerminatorKind::SwitchInt { discr, targets, .. } => {\n                 let discr_local = discr.place()?.as_local()?;\n                 // the declaration of the discriminant read. Place of this read is being used in the switch\n                 let discr_decl = &self.body.local_decls()[discr_local];\n                 let discr_ty = discr_decl.ty;\n                 // the otherwise target lies as the last element\n-                let otherwise_bb = targets.get(values.len())?.clone();\n-                let targets_with_values = targets\n-                    .iter()\n-                    .zip(values.iter())\n-                    .map(|(t, v)| (t.clone(), v.clone()))\n-                    .collect();\n+                let otherwise_bb = targets.otherwise();\n+                let targets_with_values = targets.iter().collect();\n \n                 // find the place of the adt where the discriminant is being read from\n                 // assume this is the last statement of the block"}, {"sha": "039d4753a8c2da96b4e3015e876e8a7f8a3cfd9a", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -71,7 +71,6 @@ use rustc_middle::ty::GeneratorSubsts;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::PanicStrategy;\n-use std::borrow::Cow;\n use std::{iter, ops};\n \n pub struct StateTransform;\n@@ -839,11 +838,12 @@ fn insert_switch<'tcx>(\n ) {\n     let default_block = insert_term_block(body, default);\n     let (assign, discr) = transform.get_discr(body);\n+    let switch_targets =\n+        SwitchTargets::new(cases.iter().map(|(i, bb)| ((*i) as u128, *bb)), default_block);\n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Move(discr),\n         switch_ty: transform.discr_ty,\n-        values: Cow::from(cases.iter().map(|&(i, _)| i as u128).collect::<Vec<_>>()),\n-        targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n+        targets: switch_targets,\n     };\n \n     let source_info = SourceInfo::outermost(body.span);"}, {"sha": "34aaefdcbeab60415679f88d7c6edc71203c3cd6", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -771,7 +771,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 *target = self.update_target(*target);\n             }\n             TerminatorKind::SwitchInt { ref mut targets, .. } => {\n-                for tgt in targets {\n+                for tgt in targets.all_targets_mut() {\n                     *tgt = self.update_target(*tgt);\n                 }\n             }"}, {"sha": "8b2d6b09aa83082d81958ee2dc5e5abbdd03a222", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -46,10 +46,13 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     discr: Operand::Copy(ref place) | Operand::Move(ref place),\n                     switch_ty,\n                     ref targets,\n-                    ref values,\n                     ..\n-                } if targets.len() == 2 && values.len() == 1 && targets[0] != targets[1] => {\n-                    (place, values[0], switch_ty, targets[0], targets[1])\n+                } if targets.iter().len() == 1 => {\n+                    let (value, target) = targets.iter().next().unwrap();\n+                    if target == targets.otherwise() {\n+                        continue;\n+                    }\n+                    (place, value, switch_ty, target, targets.otherwise())\n                 }\n                 // Only optimize switch int statements\n                 _ => continue,"}, {"sha": "ffb84950fc92c9319af82e29f9f4054907a83d94", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -137,7 +137,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> FxHashSet<LocalDefId> {\n /// Generates a default name for the pass based on the name of the\n /// type `T`.\n pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n-    let name = ::std::any::type_name::<T>();\n+    let name = std::any::type_name::<T>();\n     if let Some(tail) = name.rfind(':') { Cow::from(&name[tail + 1..]) } else { Cow::from(name) }\n }\n \n@@ -287,11 +287,7 @@ fn mir_promoted(\n     // this point, before we steal the mir-const result.\n     // Also this means promotion can rely on all const checks having been done.\n     let _ = tcx.mir_const_qualif_opt_const_arg(def);\n-    let _ = if let Some(param_did) = def.const_param_did {\n-        tcx.mir_abstract_const_of_const_arg((def.did, param_did))\n-    } else {\n-        tcx.mir_abstract_const(def.did.to_def_id())\n-    };\n+    let _ = tcx.mir_abstract_const_opt_const_arg(def.to_global());\n     let mut body = tcx.mir_const(def).steal();\n \n     let mut required_consts = Vec::new();"}, {"sha": "7373abcc820ab32c1867c5636394166141c22321", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -124,6 +124,15 @@ impl Candidate {\n             Candidate::Argument { .. } | Candidate::InlineAsm { .. } => true,\n         }\n     }\n+\n+    fn source_info(&self, body: &Body<'_>) -> SourceInfo {\n+        match self {\n+            Candidate::Ref(location) | Candidate::Repeat(location) => *body.source_info(*location),\n+            Candidate::Argument { bb, .. } | Candidate::InlineAsm { bb, .. } => {\n+                *body.source_info(body.terminator_loc(*bb))\n+            }\n+        }\n+    }\n }\n \n fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n@@ -953,6 +962,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             from_hir_call,\n                             fn_span,\n                         },\n+                        source_info: SourceInfo::outermost(terminator.source_info.span),\n                         ..terminator\n                     };\n                 }\n@@ -1163,12 +1173,13 @@ pub fn promote_candidates<'tcx>(\n         // Declare return place local so that `mir::Body::new` doesn't complain.\n         let initial_locals = iter::once(LocalDecl::new(tcx.types.never, body.span)).collect();\n \n+        let mut scope = body.source_scopes[candidate.source_info(body).scope].clone();\n+        scope.parent_scope = None;\n+\n         let mut promoted = Body::new(\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n-            // FIXME: maybe try to filter this to avoid blowing up\n-            // memory usage?\n-            body.source_scopes.clone(),\n+            IndexVec::from_elem_n(scope, 1),\n             initial_locals,\n             IndexVec::new(),\n             0,"}, {"sha": "31e201c3a5bbe215ab51599fb79180813d18733a", "filename": "compiler/rustc_mir/src/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -43,7 +43,7 @@ impl RemoveNoopLandingPads {\n                     // These are all nops in a landing pad\n                 }\n \n-                StatementKind::Assign(box (place, Rvalue::Use(_))) => {\n+                StatementKind::Assign(box (place, Rvalue::Use(_) | Rvalue::Discriminant(_))) => {\n                     if place.as_local().is_some() {\n                         // Writing to a local (e.g., a drop flag) does not\n                         // turn a landing pad to a non-nop"}, {"sha": "5f63c03993d3a7d56a718ed0665961198b840cf1", "filename": "compiler/rustc_mir/src/transform/simplify_branches.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -29,17 +29,16 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n                 TerminatorKind::SwitchInt {\n                     discr: Operand::Constant(ref c),\n                     switch_ty,\n-                    ref values,\n                     ref targets,\n                     ..\n                 } => {\n                     let constant = c.literal.try_eval_bits(tcx, param_env, switch_ty);\n                     if let Some(constant) = constant {\n-                        let (otherwise, targets) = targets.split_last().unwrap();\n-                        let mut ret = TerminatorKind::Goto { target: *otherwise };\n-                        for (&v, t) in values.iter().zip(targets.iter()) {\n+                        let otherwise = targets.otherwise();\n+                        let mut ret = TerminatorKind::Goto { target: otherwise };\n+                        for (v, t) in targets.iter() {\n                             if v == constant {\n-                                ret = TerminatorKind::Goto { target: *t };\n+                                ret = TerminatorKind::Goto { target: t };\n                                 break;\n                             }\n                         }"}, {"sha": "6372f8960ddb66f8f0aa64cbd4b03b6f1cf3adbe", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,8 +1,10 @@\n+use std::iter;\n+\n use super::MirPass;\n use rustc_middle::{\n     mir::{\n         interpret::Scalar, BasicBlock, BinOp, Body, Operand, Place, Rvalue, Statement,\n-        StatementKind, TerminatorKind,\n+        StatementKind, SwitchTargets, TerminatorKind,\n     },\n     ty::{Ty, TyCtxt},\n };\n@@ -43,19 +45,21 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                 Scalar::Ptr(_) => continue,\n             };\n             const FALSE: u128 = 0;\n-            let mut new_targets = opt.targets.clone();\n-            let first_is_false_target = opt.values[0] == FALSE;\n+\n+            let mut new_targets = opt.targets;\n+            let first_value = new_targets.iter().next().unwrap().0;\n+            let first_is_false_target = first_value == FALSE;\n             match opt.op {\n                 BinOp::Eq => {\n                     // if the assignment was Eq we want the true case to be first\n                     if first_is_false_target {\n-                        new_targets.swap(0, 1);\n+                        new_targets.all_targets_mut().swap(0, 1);\n                     }\n                 }\n                 BinOp::Ne => {\n                     // if the assignment was Ne we want the false case to be first\n                     if !first_is_false_target {\n-                        new_targets.swap(0, 1);\n+                        new_targets.all_targets_mut().swap(0, 1);\n                     }\n                 }\n                 _ => unreachable!(),\n@@ -96,7 +100,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                 }\n                 storage_deads_to_remove.push((stmt_idx, opt.bb_idx));\n                 // if we have StorageDeads to remove then make sure to insert them at the top of each target\n-                for bb_idx in new_targets.iter() {\n+                for bb_idx in new_targets.all_targets() {\n                     storage_deads_to_insert.push((\n                         *bb_idx,\n                         Statement {\n@@ -107,13 +111,18 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                 }\n             }\n \n-            let terminator = bb.terminator_mut();\n+            let [bb_cond, bb_otherwise] = match new_targets.all_targets() {\n+                [a, b] => [*a, *b],\n+                e => bug!(\"expected 2 switch targets, got: {:?}\", e),\n+            };\n+\n+            let targets = SwitchTargets::new(iter::once((new_value, bb_cond)), bb_otherwise);\n \n+            let terminator = bb.terminator_mut();\n             terminator.kind = TerminatorKind::SwitchInt {\n                 discr: Operand::Move(opt.to_switch_on),\n                 switch_ty: opt.branch_value_ty,\n-                values: vec![new_value].into(),\n-                targets: new_targets,\n+                targets,\n             };\n         }\n \n@@ -138,15 +147,13 @@ impl<'a, 'tcx> OptimizationFinder<'a, 'tcx> {\n             .iter_enumerated()\n             .filter_map(|(bb_idx, bb)| {\n                 // find switch\n-                let (place_switched_on, values, targets, place_switched_on_moved) = match &bb\n-                    .terminator()\n-                    .kind\n-                {\n-                    rustc_middle::mir::TerminatorKind::SwitchInt {\n-                        discr, values, targets, ..\n-                    } => Some((discr.place()?, values, targets, discr.is_move())),\n-                    _ => None,\n-                }?;\n+                let (place_switched_on, targets, place_switched_on_moved) =\n+                    match &bb.terminator().kind {\n+                        rustc_middle::mir::TerminatorKind::SwitchInt { discr, targets, .. } => {\n+                            Some((discr.place()?, targets, discr.is_move()))\n+                        }\n+                        _ => None,\n+                    }?;\n \n                 // find the statement that assigns the place being switched on\n                 bb.statements.iter().enumerate().rev().find_map(|(stmt_idx, stmt)| {\n@@ -167,7 +174,6 @@ impl<'a, 'tcx> OptimizationFinder<'a, 'tcx> {\n                                         branch_value_scalar,\n                                         branch_value_ty,\n                                         op: *op,\n-                                        values: values.clone().into_owned(),\n                                         targets: targets.clone(),\n                                     })\n                                 }\n@@ -220,8 +226,6 @@ struct OptimizationInfo<'tcx> {\n     branch_value_ty: Ty<'tcx>,\n     /// Either Eq or Ne\n     op: BinOp,\n-    /// Current values used in the switch target. This needs to be replaced with the branch_value\n-    values: Vec<u128>,\n     /// Current targets used in the switch\n-    targets: Vec<BasicBlock>,\n+    targets: SwitchTargets,\n }"}, {"sha": "27bb1def726e1a51ed5cf6f68e3ea848c29f2e84", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -576,15 +576,13 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n             .iter_enumerated()\n             .filter_map(|(bb_idx, bb)| {\n                 let (discr_switched_on, targets_and_values) = match &bb.terminator().kind {\n-                    TerminatorKind::SwitchInt { targets, discr, values, .. } => {\n-                        // if values.len() == targets.len() - 1, we need to include None where no value is present\n-                        // such that the zip does not throw away targets. If no `otherwise` case is in targets, the zip will simply throw away the added None\n-                        let values_extended = values.iter().map(|x|Some(*x)).chain(once(None));\n-                        let targets_and_values:Vec<_> = targets.iter().zip(values_extended)\n-                            .map(|(target, value)| SwitchTargetAndValue{target:*target, value})\n+                    TerminatorKind::SwitchInt { targets, discr, .. } => {\n+                        let targets_and_values: Vec<_> = targets.iter()\n+                            .map(|(val, target)| SwitchTargetAndValue { target, value: Some(val) })\n+                            .chain(once(SwitchTargetAndValue { target: targets.otherwise(), value: None }))\n                             .collect();\n-                        assert_eq!(targets.len(), targets_and_values.len());\n-                        (discr, targets_and_values)},\n+                        (discr, targets_and_values)\n+                    },\n                     _ => return None,\n                 };\n "}, {"sha": "465832c89fd00871b7f7117c0d28ee196152efc4", "filename": "compiler/rustc_mir/src/transform/uninhabited_enum_branching.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,8 +1,10 @@\n //! A pass that eliminates branches on uninhabited enum variants.\n \n use crate::transform::MirPass;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_middle::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, TerminatorKind,\n+    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, SwitchTargets,\n+    TerminatorKind,\n };\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{Ty, TyCtxt};\n@@ -52,9 +54,13 @@ fn variant_discriminants<'tcx>(\n     layout: &TyAndLayout<'tcx>,\n     ty: Ty<'tcx>,\n     tcx: TyCtxt<'tcx>,\n-) -> Vec<u128> {\n+) -> FxHashSet<u128> {\n     match &layout.variants {\n-        Variants::Single { index } => vec![index.as_u32() as u128],\n+        Variants::Single { index } => {\n+            let mut res = FxHashSet::default();\n+            res.insert(index.as_u32() as u128);\n+            res\n+        }\n         Variants::Multiple { variants, .. } => variants\n             .iter_enumerated()\n             .filter_map(|(idx, layout)| {\n@@ -96,21 +102,15 @@ impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n \n             trace!(\"allowed_variants = {:?}\", allowed_variants);\n \n-            if let TerminatorKind::SwitchInt { values, targets, .. } =\n+            if let TerminatorKind::SwitchInt { targets, .. } =\n                 &mut body.basic_blocks_mut()[bb].terminator_mut().kind\n             {\n-                // take otherwise out early\n-                let otherwise = targets.pop().unwrap();\n-                assert_eq!(targets.len(), values.len());\n-                let mut i = 0;\n-                targets.retain(|_| {\n-                    let keep = allowed_variants.contains(&values[i]);\n-                    i += 1;\n-                    keep\n-                });\n-                targets.push(otherwise);\n-\n-                values.to_mut().retain(|var| allowed_variants.contains(var));\n+                let new_targets = SwitchTargets::new(\n+                    targets.iter().filter(|(val, _)| allowed_variants.contains(val)),\n+                    targets.otherwise(),\n+                );\n+\n+                *targets = new_targets;\n             } else {\n                 unreachable!()\n             }"}, {"sha": "f6d39dae3429e18b2651c73abeedb3b38e5454b6", "filename": "compiler/rustc_mir/src/transform/unreachable_prop.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -7,7 +7,6 @@ use crate::transform::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n-use std::borrow::Cow;\n \n pub struct UnreachablePropagation;\n \n@@ -69,14 +68,15 @@ where\n {\n     let terminator = match *terminator_kind {\n         TerminatorKind::Goto { target } if predicate(target) => TerminatorKind::Unreachable,\n-        TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-            let original_targets_len = targets.len();\n-            let (otherwise, targets) = targets.split_last().unwrap();\n+        TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n+            let otherwise = targets.otherwise();\n+\n+            let original_targets_len = targets.iter().len() + 1;\n             let (mut values, mut targets): (Vec<_>, Vec<_>) =\n-                values.iter().zip(targets.iter()).filter(|(_, &t)| !predicate(t)).unzip();\n+                targets.iter().filter(|(_, bb)| !predicate(*bb)).unzip();\n \n-            if !predicate(*otherwise) {\n-                targets.push(*otherwise);\n+            if !predicate(otherwise) {\n+                targets.push(otherwise);\n             } else {\n                 values.pop();\n             }\n@@ -91,8 +91,10 @@ where\n                 TerminatorKind::SwitchInt {\n                     discr: discr.clone(),\n                     switch_ty,\n-                    values: Cow::from(values),\n-                    targets,\n+                    targets: SwitchTargets::new(\n+                        values.iter().copied().zip(targets.iter().copied()),\n+                        *targets.last().unwrap(),\n+                    ),\n                 }\n             } else {\n                 return None;"}, {"sha": "beffffa727e7eda784e1434eca704de885a7908f", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -8,7 +8,7 @@ use super::MirPass;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, Rvalue,\n-    Statement, StatementKind, Terminator, TerminatorKind, VarDebugInfo,\n+    SourceScope, Statement, StatementKind, Terminator, TerminatorKind, VarDebugInfo,\n };\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n@@ -229,9 +229,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_var_debug_info(&mut self, _var_debug_info: &VarDebugInfo<'tcx>) {\n+    fn visit_var_debug_info(&mut self, var_debug_info: &VarDebugInfo<'tcx>) {\n         // Debuginfo can contain field projections, which count as a use of the base local. Skip\n         // debuginfo so that we avoid the storage liveness assertion in that case.\n+        self.visit_source_info(&var_debug_info.source_info);\n     }\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n@@ -334,7 +335,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             TerminatorKind::Goto { target } => {\n                 self.check_edge(location, *target, EdgeKind::Normal);\n             }\n-            TerminatorKind::SwitchInt { targets, values, switch_ty, discr } => {\n+            TerminatorKind::SwitchInt { targets, switch_ty, discr } => {\n                 let ty = discr.ty(&self.body.local_decls, self.tcx);\n                 if ty != *switch_ty {\n                     self.fail(\n@@ -345,19 +346,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         ),\n                     );\n                 }\n-                if targets.len() != values.len() + 1 {\n-                    self.fail(\n-                        location,\n-                        format!(\n-                            \"encountered `SwitchInt` terminator with {} values, but {} targets (should be values+1)\",\n-                            values.len(),\n-                            targets.len(),\n-                        ),\n-                    );\n-                }\n-                for target in targets {\n-                    self.check_edge(location, *target, EdgeKind::Normal);\n+                for (_, target) in targets.iter() {\n+                    self.check_edge(location, target, EdgeKind::Normal);\n                 }\n+                self.check_edge(location, targets.otherwise(), EdgeKind::Normal);\n             }\n             TerminatorKind::Drop { target, unwind, .. } => {\n                 self.check_edge(location, *target, EdgeKind::Normal);\n@@ -441,4 +433,16 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             | TerminatorKind::GeneratorDrop => {}\n         }\n     }\n+\n+    fn visit_source_scope(&mut self, scope: &SourceScope) {\n+        if self.body.source_scopes.get(*scope).is_none() {\n+            self.tcx.sess.diagnostic().delay_span_bug(\n+                self.body.span,\n+                &format!(\n+                    \"broken MIR in {:?} ({}):\\ninvalid source scope {:?}\",\n+                    self.body.source.instance, self.when, scope,\n+                ),\n+            );\n+        }\n+    }\n }"}, {"sha": "0e2d8e5495b72590f535884e2a5a75a1c6300ffc", "filename": "compiler/rustc_mir/src/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -588,8 +588,10 @@ where\n                 kind: TerminatorKind::SwitchInt {\n                     discr: Operand::Move(discr),\n                     switch_ty: discr_ty,\n-                    values: From::from(values.to_owned()),\n-                    targets: blocks,\n+                    targets: SwitchTargets::new(\n+                        values.iter().copied().zip(blocks.iter().copied()),\n+                        *blocks.last().unwrap(),\n+                    ),\n                 },\n             }),\n             is_cleanup: unwind.is_cleanup(),\n@@ -758,8 +760,6 @@ where\n         let elem_size = Place::from(self.new_temp(tcx.types.usize));\n         let len = Place::from(self.new_temp(tcx.types.usize));\n \n-        static USIZE_SWITCH_ZERO: &[u128] = &[0];\n-\n         let base_block = BasicBlockData {\n             statements: vec![\n                 self.assign(elem_size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n@@ -771,11 +771,11 @@ where\n                 kind: TerminatorKind::SwitchInt {\n                     discr: move_(elem_size),\n                     switch_ty: tcx.types.usize,\n-                    values: From::from(USIZE_SWITCH_ZERO),\n-                    targets: vec![\n+                    targets: SwitchTargets::static_if(\n+                        0,\n                         self.drop_loop_pair(ety, false, len),\n                         self.drop_loop_pair(ety, true, len),\n-                    ],\n+                    ),\n                 },\n             }),\n         };"}, {"sha": "e46274770be17532309bade4a4389d767ede36bb", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -28,8 +28,9 @@ use std::mem;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Simplify a candidate so that all match pairs require a test.\n     ///\n-    /// This method will also split a candidate where the only match-pair is an\n-    /// or-pattern into multiple candidates. This is so that\n+    /// This method will also split a candidate, in which the only\n+    /// match-pair is an or-pattern, into multiple candidates.\n+    /// This is so that\n     ///\n     /// match x {\n     ///     0 | 1 => { ... },"}, {"sha": "c41919001477e7408d33dad9a317d87ac443a855", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -167,48 +167,42 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let target_blocks = make_target_blocks(self);\n                 // Variants is a BitVec of indexes into adt_def.variants.\n                 let num_enum_variants = adt_def.variants.len();\n-                let used_variants = variants.count();\n                 debug_assert_eq!(target_blocks.len(), num_enum_variants + 1);\n                 let otherwise_block = *target_blocks.last().unwrap();\n-                let mut targets = Vec::with_capacity(used_variants + 1);\n-                let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n-                for (idx, discr) in adt_def.discriminants(tcx) {\n-                    if variants.contains(idx) {\n-                        debug_assert_ne!(\n-                            target_blocks[idx.index()],\n-                            otherwise_block,\n-                            \"no canididates for tested discriminant: {:?}\",\n-                            discr,\n-                        );\n-                        values.push(discr.val);\n-                        targets.push(target_blocks[idx.index()]);\n-                    } else {\n-                        debug_assert_eq!(\n-                            target_blocks[idx.index()],\n-                            otherwise_block,\n-                            \"found canididates for untested discriminant: {:?}\",\n-                            discr,\n-                        );\n-                    }\n-                }\n-                targets.push(otherwise_block);\n-                debug!(\n-                    \"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n-                    num_enum_variants, values, variants\n+                let switch_targets = SwitchTargets::new(\n+                    adt_def.discriminants(tcx).filter_map(|(idx, discr)| {\n+                        if variants.contains(idx) {\n+                            debug_assert_ne!(\n+                                target_blocks[idx.index()],\n+                                otherwise_block,\n+                                \"no canididates for tested discriminant: {:?}\",\n+                                discr,\n+                            );\n+                            Some((discr.val, target_blocks[idx.index()]))\n+                        } else {\n+                            debug_assert_eq!(\n+                                target_blocks[idx.index()],\n+                                otherwise_block,\n+                                \"found canididates for untested discriminant: {:?}\",\n+                                discr,\n+                            );\n+                            None\n+                        }\n+                    }),\n+                    otherwise_block,\n                 );\n+                debug!(\"num_enum_variants: {}, variants: {:?}\", num_enum_variants, variants);\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty, test.span);\n                 self.cfg.push_assign(block, source_info, discr, Rvalue::Discriminant(place));\n-                assert_eq!(values.len() + 1, targets.len());\n                 self.cfg.terminate(\n                     block,\n                     source_info,\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Move(discr),\n                         switch_ty: discr_ty,\n-                        values: From::from(values),\n-                        targets,\n+                        targets: switch_targets,\n                     },\n                 );\n             }\n@@ -230,11 +224,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 } else {\n                     // The switch may be inexhaustive so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n+                    let otherwise_block = *target_blocks.last().unwrap();\n+                    let switch_targets = SwitchTargets::new(\n+                        options.values().copied().zip(target_blocks),\n+                        otherwise_block,\n+                    );\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place),\n                         switch_ty,\n-                        values: options.values().copied().collect(),\n-                        targets: target_blocks,\n+                        targets: switch_targets,\n                     }\n                 };\n                 self.cfg.terminate(block, source_info, terminator);"}, {"sha": "69de7c7e2ee0bce7acf2f4633665fe3f92cff731", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 68, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -71,13 +71,13 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n         };\n         self.check_irrefutable(&loc.pat, msg, sp);\n-        self.check_patterns(false, &loc.pat);\n+        self.check_patterns(&loc.pat);\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         intravisit::walk_param(self, param);\n         self.check_irrefutable(&param.pat, \"function argument\", None);\n-        self.check_patterns(false, &param.pat);\n+        self.check_patterns(&param.pat);\n     }\n }\n \n@@ -96,14 +96,14 @@ impl PatCtxt<'_, '_> {\n                 }\n                 PatternError::FloatBug => {\n                     // FIXME(#31407) this is only necessary because float parsing is buggy\n-                    ::rustc_middle::mir::interpret::struct_error(\n+                    rustc_middle::mir::interpret::struct_error(\n                         self.tcx.at(pat_span),\n                         \"could not evaluate float literal (see issue #31407)\",\n                     )\n                     .emit();\n                 }\n                 PatternError::NonConstPath(span) => {\n-                    ::rustc_middle::mir::interpret::struct_error(\n+                    rustc_middle::mir::interpret::struct_error(\n                         self.tcx.at(span),\n                         \"runtime values cannot be referenced in patterns\",\n                     )\n@@ -119,10 +119,7 @@ impl PatCtxt<'_, '_> {\n }\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n-    fn check_patterns(&mut self, has_guard: bool, pat: &Pat<'_>) {\n-        if !self.tcx.features().move_ref_pattern {\n-            check_legality_of_move_bindings(self, has_guard, pat);\n-        }\n+    fn check_patterns(&mut self, pat: &Pat<'_>) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n@@ -165,7 +162,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     ) {\n         for arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n-            self.check_patterns(arm.guard.is_some(), &arm.pat);\n+            self.check_patterns(&arm.pat);\n         }\n \n         let mut cx = self.new_cx(scrut.hir_id);\n@@ -601,65 +598,6 @@ fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> b\n     !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n }\n \n-/// Check the legality of legality of by-move bindings.\n-fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat<'_>) {\n-    let sess = cx.tcx.sess;\n-    let typeck_results = cx.typeck_results;\n-\n-    // Find all by-ref spans.\n-    let mut by_ref_spans = Vec::new();\n-    pat.each_binding(|_, hir_id, span, _| {\n-        if let Some(ty::BindByReference(_)) =\n-            typeck_results.extract_binding_mode(sess, hir_id, span)\n-        {\n-            by_ref_spans.push(span);\n-        }\n-    });\n-\n-    // Find bad by-move spans:\n-    let by_move_spans = &mut Vec::new();\n-    let mut check_move = |p: &Pat<'_>, sub: Option<&Pat<'_>>| {\n-        // Check legality of moving out of the enum.\n-        //\n-        // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n-        if sub.map_or(false, |p| p.contains_bindings()) {\n-            struct_span_err!(sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n-                .span_label(p.span, \"binds an already bound by-move value by moving it\")\n-                .emit();\n-        } else if !has_guard && !by_ref_spans.is_empty() {\n-            by_move_spans.push(p.span);\n-        }\n-    };\n-    pat.walk_always(|p| {\n-        if let hir::PatKind::Binding(.., sub) = &p.kind {\n-            if let Some(ty::BindByValue(_)) =\n-                typeck_results.extract_binding_mode(sess, p.hir_id, p.span)\n-            {\n-                if is_binding_by_move(cx, p.hir_id, p.span) {\n-                    check_move(p, sub.as_deref());\n-                }\n-            }\n-        }\n-    });\n-\n-    // Found some bad by-move spans, error!\n-    if !by_move_spans.is_empty() {\n-        let mut err = feature_err(\n-            &sess.parse_sess,\n-            sym::move_ref_pattern,\n-            by_move_spans.clone(),\n-            \"binding by-move and by-ref in the same pattern is unstable\",\n-        );\n-        for span in by_ref_spans.iter() {\n-            err.span_label(*span, \"by-ref pattern here\");\n-        }\n-        for span in by_move_spans.iter() {\n-            err.span_label(*span, \"by-move pattern here\");\n-        }\n-        err.emit();\n-    }\n-}\n-\n /// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n ///\n /// For example, this would reject:"}, {"sha": "d46e9a98825a7de3ca281333cdb0b7b8a59d07d7", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1060,13 +1060,13 @@ crate fn compare_const_vals<'tcx>(\n         use rustc_apfloat::Float;\n         return match *ty.kind() {\n             ty::Float(ast::FloatTy::F32) => {\n-                let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n-                let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n+                let l = rustc_apfloat::ieee::Single::from_bits(a);\n+                let r = rustc_apfloat::ieee::Single::from_bits(b);\n                 l.partial_cmp(&r)\n             }\n             ty::Float(ast::FloatTy::F64) => {\n-                let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n-                let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n+                let l = rustc_apfloat::ieee::Double::from_bits(a);\n+                let r = rustc_apfloat::ieee::Double::from_bits(b);\n                 l.partial_cmp(&r)\n             }\n             ty::Int(ity) => {"}, {"sha": "25deb46e147514c90ffa04162924661d9c46b0b6", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 69, "deletions": 25, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -7,7 +7,7 @@\n #![feature(or_patterns)]\n \n use rustc_ast as ast;\n-use rustc_ast::token::{self, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n@@ -114,16 +114,6 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path, sp: Option<Spa\n     source_file_to_parser(sess, file_to_source_file(sess, path, sp))\n }\n \n-/// Creates a new parser, returning buffered diagnostics if the file doesn't exist,\n-/// or from lexing the initial token stream.\n-pub fn maybe_new_parser_from_file<'a>(\n-    sess: &'a ParseSess,\n-    path: &Path,\n-) -> Result<Parser<'a>, Vec<Diagnostic>> {\n-    let file = try_file_to_source_file(sess, path, None).map_err(|db| vec![db])?;\n-    maybe_source_file_to_parser(sess, file)\n-}\n-\n /// Given a `source_file` and config, returns a parser.\n fn source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>) -> Parser<'_> {\n     panictry_buffer!(&sess.span_diagnostic, maybe_source_file_to_parser(sess, source_file))\n@@ -146,12 +136,6 @@ fn maybe_source_file_to_parser(\n     Ok(parser)\n }\n \n-// Must preserve old name for now, because `quote!` from the *existing*\n-// compiler expands into it.\n-pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser<'_> {\n-    stream_to_parser(sess, tts.into_iter().collect(), crate::MACRO_ARGUMENTS)\n-}\n-\n // Base abstractions\n \n /// Given a session and a path and an optional span (for error reporting),\n@@ -297,7 +281,11 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     };\n \n     // FIXME(#43081): Avoid this pretty-print + reparse hack\n-    let source = pprust::nonterminal_to_string(nt);\n+    // Pretty-print the AST struct without inserting any parenthesis\n+    // beyond those explicitly written by the user (e.g. `ExpnKind::Paren`).\n+    // The resulting stream may have incorrect precedence, but it's only\n+    // ever used for a comparison against the capture tokenstream.\n+    let source = pprust::nonterminal_to_string_no_extra_parens(nt);\n     let filename = FileName::macro_expansion_source_code(&source);\n     let reparsed_tokens = parse_stream_from_source_str(filename, source, sess, Some(span));\n \n@@ -325,15 +313,43 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // modifications, including adding/removing typically non-semantic\n     // tokens such as extra braces and commas, don't happen.\n     if let Some(tokens) = tokens {\n-        if tokenstream_probably_equal_for_proc_macro(&tokens, &reparsed_tokens, sess) {\n+        // Compare with a non-relaxed delim match to start.\n+        if tokenstream_probably_equal_for_proc_macro(&tokens, &reparsed_tokens, sess, false) {\n             return tokens;\n         }\n+\n+        // The check failed. This time, we pretty-print the AST struct with parenthesis\n+        // inserted to preserve precedence. This may cause `None`-delimiters in the captured\n+        // token stream to match up with inserted parenthesis in the reparsed stream.\n+        let source_with_parens = pprust::nonterminal_to_string(nt);\n+        let filename_with_parens = FileName::macro_expansion_source_code(&source_with_parens);\n+        let reparsed_tokens_with_parens = parse_stream_from_source_str(\n+            filename_with_parens,\n+            source_with_parens,\n+            sess,\n+            Some(span),\n+        );\n+\n+        // Compare with a relaxed delim match - we want inserted parenthesis in the\n+        // reparsed stream to match `None`-delimiters in the original stream.\n+        if tokenstream_probably_equal_for_proc_macro(\n+            &tokens,\n+            &reparsed_tokens_with_parens,\n+            sess,\n+            true,\n+        ) {\n+            return tokens;\n+        }\n+\n         info!(\n             \"cached tokens found, but they're not \\\"probably equal\\\", \\\n                 going with stringified version\"\n         );\n-        info!(\"cached tokens: {:?}\", tokens);\n-        info!(\"reparsed tokens: {:?}\", reparsed_tokens);\n+        info!(\"cached   tokens: {}\", pprust::tts_to_string(&tokens));\n+        info!(\"reparsed tokens: {}\", pprust::tts_to_string(&reparsed_tokens_with_parens));\n+\n+        info!(\"cached   tokens debug: {:?}\", tokens);\n+        info!(\"reparsed tokens debug: {:?}\", reparsed_tokens_with_parens);\n     }\n     reparsed_tokens\n }\n@@ -347,6 +363,7 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n     tokens: &TokenStream,\n     reparsed_tokens: &TokenStream,\n     sess: &ParseSess,\n+    relaxed_delim_match: bool,\n ) -> bool {\n     // When checking for `probably_eq`, we ignore certain tokens that aren't\n     // preserved in the AST. Because they are not preserved, the pretty\n@@ -472,7 +489,9 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n     let tokens = tokens.trees().flat_map(|t| expand_token(t, sess));\n     let reparsed_tokens = reparsed_tokens.trees().flat_map(|t| expand_token(t, sess));\n \n-    tokens.eq_by(reparsed_tokens, |t, rt| tokentree_probably_equal_for_proc_macro(&t, &rt, sess))\n+    tokens.eq_by(reparsed_tokens, |t, rt| {\n+        tokentree_probably_equal_for_proc_macro(&t, &rt, sess, relaxed_delim_match)\n+    })\n }\n \n // See comments in `Nonterminal::to_tokenstream` for why we care about\n@@ -484,6 +503,7 @@ pub fn tokentree_probably_equal_for_proc_macro(\n     token: &TokenTree,\n     reparsed_token: &TokenTree,\n     sess: &ParseSess,\n+    relaxed_delim_match: bool,\n ) -> bool {\n     match (token, reparsed_token) {\n         (TokenTree::Token(token), TokenTree::Token(reparsed_token)) => {\n@@ -492,9 +512,33 @@ pub fn tokentree_probably_equal_for_proc_macro(\n         (\n             TokenTree::Delimited(_, delim, tokens),\n             TokenTree::Delimited(_, reparsed_delim, reparsed_tokens),\n-        ) => {\n-            delim == reparsed_delim\n-                && tokenstream_probably_equal_for_proc_macro(tokens, reparsed_tokens, sess)\n+        ) if delim == reparsed_delim => tokenstream_probably_equal_for_proc_macro(\n+            tokens,\n+            reparsed_tokens,\n+            sess,\n+            relaxed_delim_match,\n+        ),\n+        (TokenTree::Delimited(_, DelimToken::NoDelim, tokens), reparsed_token) => {\n+            if relaxed_delim_match {\n+                if let TokenTree::Delimited(_, DelimToken::Paren, reparsed_tokens) = reparsed_token\n+                {\n+                    if tokenstream_probably_equal_for_proc_macro(\n+                        tokens,\n+                        reparsed_tokens,\n+                        sess,\n+                        relaxed_delim_match,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            tokens.len() == 1\n+                && tokentree_probably_equal_for_proc_macro(\n+                    &tokens.trees().next().unwrap(),\n+                    reparsed_token,\n+                    sess,\n+                    relaxed_delim_match,\n+                )\n         }\n         _ => false,\n     }"}, {"sha": "1ea01d95a134e09ae47eac2bc5f6f593f9a09122", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -5,8 +5,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{\n-    self as ast, AngleBracketedArgs, AttrVec, BinOpKind, BindingMode, BlockCheckMode, Expr,\n-    ExprKind, Item, ItemKind, Mutability, Param, Pat, PatKind, PathSegment, QSelf, Ty, TyKind,\n+    self as ast, AngleBracketedArgs, AttrVec, BinOpKind, BindingMode, Block, BlockCheckMode, Expr,\n+    ExprKind, Item, ItemKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QSelf, Ty,\n+    TyKind,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -119,6 +120,28 @@ crate enum ConsumeClosingDelim {\n     No,\n }\n \n+#[derive(Clone, Copy)]\n+pub enum AttemptLocalParseRecovery {\n+    Yes,\n+    No,\n+}\n+\n+impl AttemptLocalParseRecovery {\n+    pub fn yes(&self) -> bool {\n+        match self {\n+            AttemptLocalParseRecovery::Yes => true,\n+            AttemptLocalParseRecovery::No => false,\n+        }\n+    }\n+\n+    pub fn no(&self) -> bool {\n+        match self {\n+            AttemptLocalParseRecovery::Yes => false,\n+            AttemptLocalParseRecovery::No => true,\n+        }\n+    }\n+}\n+\n impl<'a> Parser<'a> {\n     pub(super) fn span_fatal_err<S: Into<MultiSpan>>(\n         &self,\n@@ -321,6 +344,66 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn maybe_suggest_struct_literal(\n+        &mut self,\n+        lo: Span,\n+        s: BlockCheckMode,\n+    ) -> Option<PResult<'a, P<Block>>> {\n+        if self.token.is_ident() && self.look_ahead(1, |t| t == &token::Colon) {\n+            // We might be having a struct literal where people forgot to include the path:\n+            // fn foo() -> Foo {\n+            //     field: value,\n+            // }\n+            let mut snapshot = self.clone();\n+            let path =\n+                Path { segments: vec![], span: self.prev_token.span.shrink_to_lo(), tokens: None };\n+            let struct_expr = snapshot.parse_struct_expr(path, AttrVec::new(), false);\n+            let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n+            return Some(match (struct_expr, block_tail) {\n+                (Ok(expr), Err(mut err)) => {\n+                    // We have encountered the following:\n+                    // fn foo() -> Foo {\n+                    //     field: value,\n+                    // }\n+                    // Suggest:\n+                    // fn foo() -> Foo { Path {\n+                    //     field: value,\n+                    // } }\n+                    err.delay_as_bug();\n+                    self.struct_span_err(expr.span, \"struct literal body without path\")\n+                        .multipart_suggestion(\n+                            \"you might have forgotten to add the struct literal inside the block\",\n+                            vec![\n+                                (expr.span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n+                                (expr.span.shrink_to_hi(), \" }\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    *self = snapshot;\n+                    Ok(self.mk_block(\n+                        vec![self.mk_stmt_err(expr.span)],\n+                        s,\n+                        lo.to(self.prev_token.span),\n+                    ))\n+                }\n+                (Err(mut err), Ok(tail)) => {\n+                    // We have a block tail that contains a somehow valid type ascription expr.\n+                    err.cancel();\n+                    Ok(tail)\n+                }\n+                (Err(mut snapshot_err), Err(err)) => {\n+                    // We don't know what went wrong, emit the normal error.\n+                    snapshot_err.cancel();\n+                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                    Err(err)\n+                }\n+                (Ok(_), Ok(tail)) => Ok(tail),\n+            });\n+        }\n+        None\n+    }\n+\n     pub fn maybe_annotate_with_ascription(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "17cbaf65420f6e0a1ab440c9a240509d13a7f961", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -16,6 +16,7 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, DiagnosticBuilder, PResult};\n use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{BytePos, Pos};\n use std::mem;\n use tracing::debug;\n \n@@ -245,11 +246,7 @@ impl<'a> Parser<'a> {\n                 this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n             })?;\n \n-            // Make sure that the span of the parent node is larger than the span of lhs and rhs,\n-            // including the attributes.\n-            let lhs_span =\n-                lhs.attrs.iter().find(|a| a.style == AttrStyle::Outer).map_or(lhs_span, |a| a.span);\n-            let span = lhs_span.to(rhs.span);\n+            let span = self.mk_expr_sp(&lhs, lhs_span, rhs.span);\n             lhs = match op {\n                 AssocOp::Add\n                 | AssocOp::Subtract\n@@ -410,7 +407,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         let rhs_span = rhs.as_ref().map_or(cur_op_span, |x| x.span);\n-        let span = lhs.span.to(rhs_span);\n+        let span = self.mk_expr_sp(&lhs, lhs.span, rhs_span);\n         let limits =\n             if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n         Ok(self.mk_expr(span, self.mk_range(Some(lhs), rhs, limits)?, AttrVec::new()))\n@@ -570,7 +567,11 @@ impl<'a> Parser<'a> {\n         expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind,\n     ) -> PResult<'a, P<Expr>> {\n         let mk_expr = |this: &mut Self, rhs: P<Ty>| {\n-            this.mk_expr(lhs_span.to(rhs.span), expr_kind(lhs, rhs), AttrVec::new())\n+            this.mk_expr(\n+                this.mk_expr_sp(&lhs, lhs_span, rhs.span),\n+                expr_kind(lhs, rhs),\n+                AttrVec::new(),\n+            )\n         };\n \n         // Save the state of the parser before parsing type normally, in case there is a\n@@ -839,9 +840,10 @@ impl<'a> Parser<'a> {\n         }\n         use FloatComponent::*;\n \n+        let float_str = float.as_str();\n         let mut components = Vec::new();\n         let mut ident_like = String::new();\n-        for c in float.as_str().chars() {\n+        for c in float_str.chars() {\n             if c == '_' || c.is_ascii_alphanumeric() {\n                 ident_like.push(c);\n             } else if matches!(c, '.' | '+' | '-') {\n@@ -857,30 +859,54 @@ impl<'a> Parser<'a> {\n             components.push(IdentLike(ident_like));\n         }\n \n-        // FIXME: Make the span more precise.\n+        // With proc macros the span can refer to anything, the source may be too short,\n+        // or too long, or non-ASCII. It only makes sense to break our span into components\n+        // if its underlying text is identical to our float literal.\n         let span = self.token.span;\n+        let can_take_span_apart =\n+            || self.span_to_snippet(span).as_deref() == Ok(float_str).as_deref();\n+\n         match &*components {\n             // 1e2\n             [IdentLike(i)] => {\n                 self.parse_tuple_field_access_expr(lo, base, Symbol::intern(&i), suffix, None)\n             }\n             // 1.\n             [IdentLike(i), Punct('.')] => {\n+                let (ident_span, dot_span) = if can_take_span_apart() {\n+                    let (span, ident_len) = (span.data(), BytePos::from_usize(i.len()));\n+                    let ident_span = span.with_hi(span.lo + ident_len);\n+                    let dot_span = span.with_lo(span.lo + ident_len);\n+                    (ident_span, dot_span)\n+                } else {\n+                    (span, span)\n+                };\n                 assert!(suffix.is_none());\n                 let symbol = Symbol::intern(&i);\n-                self.token = Token::new(token::Ident(symbol, false), span);\n-                let next_token = Token::new(token::Dot, span);\n+                self.token = Token::new(token::Ident(symbol, false), ident_span);\n+                let next_token = Token::new(token::Dot, dot_span);\n                 self.parse_tuple_field_access_expr(lo, base, symbol, None, Some(next_token))\n             }\n             // 1.2 | 1.2e3\n             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {\n+                let (ident1_span, dot_span, ident2_span) = if can_take_span_apart() {\n+                    let (span, ident1_len) = (span.data(), BytePos::from_usize(i1.len()));\n+                    let ident1_span = span.with_hi(span.lo + ident1_len);\n+                    let dot_span = span\n+                        .with_lo(span.lo + ident1_len)\n+                        .with_hi(span.lo + ident1_len + BytePos(1));\n+                    let ident2_span = self.token.span.with_lo(span.lo + ident1_len + BytePos(1));\n+                    (ident1_span, dot_span, ident2_span)\n+                } else {\n+                    (span, span, span)\n+                };\n                 let symbol1 = Symbol::intern(&i1);\n-                self.token = Token::new(token::Ident(symbol1, false), span);\n-                let next_token1 = Token::new(token::Dot, span);\n+                self.token = Token::new(token::Ident(symbol1, false), ident1_span);\n+                let next_token1 = Token::new(token::Dot, dot_span);\n                 let base1 =\n                     self.parse_tuple_field_access_expr(lo, base, symbol1, None, Some(next_token1));\n                 let symbol2 = Symbol::intern(&i2);\n-                let next_token2 = Token::new(token::Ident(symbol2, false), span);\n+                let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n                 self.bump_with(next_token2); // `.`\n                 self.parse_tuple_field_access_expr(lo, base1, symbol2, suffix, None)\n             }\n@@ -2015,9 +2041,12 @@ impl<'a> Parser<'a> {\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n         if struct_allowed || self.is_certainly_not_a_block() {\n-            // This is a struct literal, but we don't can't accept them here.\n-            let expr = self.parse_struct_expr(path.clone(), attrs.clone());\n+            if let Err(err) = self.expect(&token::OpenDelim(token::Brace)) {\n+                return Some(Err(err));\n+            }\n+            let expr = self.parse_struct_expr(path.clone(), attrs.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n+                // This is a struct literal, but we don't can't accept them here.\n                 self.error_struct_lit_not_allowed_here(path.span, expr.span);\n             }\n             return Some(expr);\n@@ -2035,12 +2064,13 @@ impl<'a> Parser<'a> {\n             .emit();\n     }\n \n+    /// Precondition: already parsed the '{'.\n     pub(super) fn parse_struct_expr(\n         &mut self,\n         pth: ast::Path,\n         mut attrs: AttrVec,\n+        recover: bool,\n     ) -> PResult<'a, P<Expr>> {\n-        self.bump();\n         let mut fields = Vec::new();\n         let mut base = None;\n         let mut recover_async = false;\n@@ -2059,10 +2089,11 @@ impl<'a> Parser<'a> {\n                 let exp_span = self.prev_token.span;\n                 match self.parse_expr() {\n                     Ok(e) => base = Some(e),\n-                    Err(mut e) => {\n+                    Err(mut e) if recover => {\n                         e.emit();\n                         self.recover_stmt();\n                     }\n+                    Err(e) => return Err(e),\n                 }\n                 self.recover_struct_comma_after_dotdot(exp_span);\n                 break;\n@@ -2114,6 +2145,9 @@ impl<'a> Parser<'a> {\n                             );\n                         }\n                     }\n+                    if !recover {\n+                        return Err(e);\n+                    }\n                     e.emit();\n                     self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n                     self.eat(&token::Comma);\n@@ -2290,4 +2324,14 @@ impl<'a> Parser<'a> {\n     pub(super) fn mk_expr_err(&self, span: Span) -> P<Expr> {\n         self.mk_expr(span, ExprKind::Err, AttrVec::new())\n     }\n+\n+    /// Create expression span ensuring the span of the parent node\n+    /// is larger than the span of lhs and rhs, including the attributes.\n+    fn mk_expr_sp(&self, lhs: &P<Expr>, lhs_span: Span, rhs_span: Span) -> Span {\n+        lhs.attrs\n+            .iter()\n+            .find(|a| a.style == AttrStyle::Outer)\n+            .map_or(lhs_span, |a| a.span)\n+            .to(rhs_span)\n+    }\n }"}, {"sha": "48341f71d33eae4ee02a72dc3950f6b192583c08", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1744,7 +1744,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        let span = lo.to(self.token.span);\n+        let span = lo.until(self.token.span);\n \n         Ok(Param {\n             attrs: attrs.into(),"}, {"sha": "c10946812213b4ae3234e43a44f46628cca5dd04", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -10,6 +10,7 @@ mod stmt;\n mod ty;\n \n use crate::lexer::UnmatchedBrace;\n+pub use diagnostics::AttemptLocalParseRecovery;\n use diagnostics::Error;\n pub use path::PathStyle;\n \n@@ -386,7 +387,7 @@ impl<'a> Parser<'a> {\n         next\n     }\n \n-    crate fn unexpected<T>(&mut self) -> PResult<'a, T> {\n+    pub fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),\n             // We can get `Ok(true)` from `recover_closing_delimiter`"}, {"sha": "131ff1ae6b3da9a92f4fb7938a89c9d72140630d", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,5 +1,5 @@\n use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n-use super::diagnostics::Error;\n+use super::diagnostics::{AttemptLocalParseRecovery, Error};\n use super::expr::LhsExpr;\n use super::pat::GateOr;\n use super::path::PathStyle;\n@@ -79,8 +79,8 @@ impl<'a> Parser<'a> {\n             return self.parse_stmt_mac(lo, attrs.into(), path);\n         }\n \n-        let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-            self.parse_struct_expr(path, AttrVec::new())?\n+        let expr = if self.eat(&token::OpenDelim(token::Brace)) {\n+            self.parse_struct_expr(path, AttrVec::new(), true)?\n         } else {\n             let hi = self.prev_token.span;\n             self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n@@ -321,25 +321,37 @@ impl<'a> Parser<'a> {\n             return self.error_block_no_opening_brace();\n         }\n \n-        Ok((self.parse_inner_attributes()?, self.parse_block_tail(lo, blk_mode)?))\n+        let attrs = self.parse_inner_attributes()?;\n+        let tail = if let Some(tail) = self.maybe_suggest_struct_literal(lo, blk_mode) {\n+            tail?\n+        } else {\n+            self.parse_block_tail(lo, blk_mode, AttemptLocalParseRecovery::Yes)?\n+        };\n+        Ok((attrs, tail))\n     }\n \n     /// Parses the rest of a block expression or function body.\n     /// Precondition: already parsed the '{'.\n-    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n+    crate fn parse_block_tail(\n+        &mut self,\n+        lo: Span,\n+        s: BlockCheckMode,\n+        recover: AttemptLocalParseRecovery,\n+    ) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             if self.token == token::Eof {\n                 break;\n             }\n-            let stmt = match self.parse_full_stmt() {\n-                Err(mut err) => {\n+            let stmt = match self.parse_full_stmt(recover) {\n+                Err(mut err) if recover.yes() => {\n                     self.maybe_annotate_with_ascription(&mut err, false);\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(self.mk_stmt_err(self.token.span))\n                 }\n                 Ok(stmt) => stmt,\n+                Err(err) => return Err(err),\n             };\n             if let Some(stmt) = stmt {\n                 stmts.push(stmt);\n@@ -352,7 +364,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a statement, including the trailing semicolon.\n-    pub fn parse_full_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    pub fn parse_full_stmt(\n+        &mut self,\n+        recover: AttemptLocalParseRecovery,\n+    ) -> PResult<'a, Option<Stmt>> {\n         // Skip looking for a trailing semicolon when we have an interpolated statement.\n         maybe_whole!(self, NtStmt, |x| Some(x));\n \n@@ -391,6 +406,9 @@ impl<'a> Parser<'a> {\n                     if let Err(mut e) =\n                         self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n                     {\n+                        if recover.no() {\n+                            return Err(e);\n+                        }\n                         e.emit();\n                         self.recover_stmt();\n                     }\n@@ -432,7 +450,7 @@ impl<'a> Parser<'a> {\n         Stmt { id: DUMMY_NODE_ID, kind, span, tokens: None }\n     }\n \n-    fn mk_stmt_err(&self, span: Span) -> Stmt {\n+    pub(super) fn mk_stmt_err(&self, span: Span) -> Stmt {\n         self.mk_stmt(span, StmtKind::Expr(self.mk_expr_err(span)))\n     }\n "}, {"sha": "1acaa4c6eff5d60e22cc53fe0ccc050ba81c481e", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -287,8 +287,9 @@ impl CheckAttrVisitor<'tcx> {\n                             self.doc_alias_str_error(meta);\n                             return false;\n                         }\n-                        if let Some(c) =\n-                            doc_alias.chars().find(|&c| c == '\"' || c == '\\'' || c.is_whitespace())\n+                        if let Some(c) = doc_alias\n+                            .chars()\n+                            .find(|&c| c == '\"' || c == '\\'' || (c.is_whitespace() && c != ' '))\n                         {\n                             self.tcx\n                                 .sess\n@@ -302,6 +303,16 @@ impl CheckAttrVisitor<'tcx> {\n                                 .emit();\n                             return false;\n                         }\n+                        if doc_alias.starts_with(' ') || doc_alias.ends_with(' ') {\n+                            self.tcx\n+                                .sess\n+                                .struct_span_err(\n+                                    meta.span(),\n+                                    \"`#[doc(alias = \\\"...\\\")]` cannot start or end with ' '\",\n+                                )\n+                                .emit();\n+                            return false;\n+                        }\n                         if let Some(err) = match target {\n                             Target::Impl => Some(\"implementation block\"),\n                             Target::ForeignMod => Some(\"extern block\"),"}, {"sha": "956be925be815eac5b223d198ec1f47b3da6ac06", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -143,7 +143,7 @@ impl ExprVisitor<'tcx> {\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n         let ty = self.typeck_results.expr_ty_adjusted(expr);\n-        let asm_ty_isize = match self.tcx.sess.target.ptr_width {\n+        let asm_ty_isize = match self.tcx.sess.target.pointer_width {\n             16 => InlineAsmType::I16,\n             32 => InlineAsmType::I32,\n             64 => InlineAsmType::I64,\n@@ -184,7 +184,7 @@ impl ExprVisitor<'tcx> {\n                         Some(InlineAsmType::VecI128(fields.len() as u64))\n                     }\n                     ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => {\n-                        Some(match self.tcx.sess.target.ptr_width {\n+                        Some(match self.tcx.sess.target.pointer_width {\n                             16 => InlineAsmType::VecI16(fields.len() as u64),\n                             32 => InlineAsmType::VecI32(fields.len() as u64),\n                             64 => InlineAsmType::VecI64(fields.len() as u64),"}, {"sha": "8650ee05d377a487db2bb64aa8ac6fbb3794b3a9", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -26,7 +26,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n     if items.eh_personality().is_none() {\n         items.missing.push(LangItem::EhPersonality);\n     }\n-    if tcx.sess.target.target.options.is_like_emscripten && items.eh_catch_typeinfo().is_none() {\n+    if tcx.sess.target.options.is_like_emscripten && items.eh_catch_typeinfo().is_none() {\n         items.missing.push(LangItem::EhCatchTypeinfo);\n     }\n "}, {"sha": "7808a28dff0b7ed220cb17f4eb0359f437b8c484", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -165,10 +165,6 @@ impl WorkProductId {\n         cgu_name.hash(&mut hasher);\n         WorkProductId { hash: hasher.finish() }\n     }\n-\n-    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n-        WorkProductId { hash: fingerprint }\n-    }\n }\n \n impl<HCX> HashStable<HCX> for WorkProductId {"}, {"sha": "85335f0ba50c2a5db1bafc607749955122e4bd32", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -402,11 +402,6 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n-    #[inline]\n-    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n-        self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n-    }\n-\n     /// Checks whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n     pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {"}, {"sha": "a27b716b95aee5fcbc0e84ef11676c6b71e9db0c", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,7 +1,5 @@\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::implementation::{\n-    Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n-};\n+use rustc_data_structures::graph::implementation::{Direction, Graph, NodeIndex, INCOMING};\n \n use super::{DepKind, DepNode};\n \n@@ -52,23 +50,8 @@ impl<K: DepKind> DepGraphQuery<K> {\n         }\n     }\n \n-    /// All nodes reachable from `node`. In other words, things that\n-    /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n-        self.reachable_nodes(node, OUTGOING)\n-    }\n-\n     /// All nodes that can reach `node`.\n     pub fn transitive_predecessors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, INCOMING)\n     }\n-\n-    /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n-        if let Some(&index) = self.indices.get(&node) {\n-            self.graph.successor_nodes(index).map(|s| self.graph.node_data(s)).collect()\n-        } else {\n-            vec![]\n-        }\n-    }\n }"}, {"sha": "774a147c114ec3c50e57c0f642f3194a68315908", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -469,24 +469,17 @@ impl<'a> Resolver<'a> {\n             ResolutionError::ParamInNonTrivialAnonConst { name, is_type } => {\n                 let mut err = self.session.struct_span_err(\n                     span,\n-                    \"generic parameters must not be used inside of non-trivial constant values\",\n-                );\n-                err.span_label(\n-                    span,\n-                    &format!(\n-                        \"non-trivial anonymous constants must not depend on the parameter `{}`\",\n-                        name\n-                    ),\n+                    \"generic parameters may not be used in const operations\",\n                 );\n+                err.span_label(span, &format!(\"cannot perform const operation using `{}`\", name));\n \n                 if is_type {\n-                    err.note(\"type parameters are currently not permitted in anonymous constants\");\n+                    err.note(\"type parameters may not be used in const expressions\");\n                 } else {\n-                    err.help(\n-                        &format!(\"it is currently only allowed to use either `{0}` or `{{ {0} }}` as generic constants\",\n-                                 name\n-                        )\n-                    );\n+                    err.help(&format!(\n+                        \"const parameters may only be used as standalone arguments, i.e. `{}`\",\n+                        name\n+                    ));\n                 }\n \n                 err"}, {"sha": "219517b4ab2e2d013afbc6b1292d63478b909956", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -384,6 +384,13 @@ struct DiagnosticMetadata<'ast> {\n \n     /// Used to detect possible `if let` written without `let` and to provide structured suggestion.\n     in_if_condition: Option<&'ast Expr>,\n+\n+    /// If we are currently in a trait object definition. Used to point at the bounds when\n+    /// encountering a struct or enum.\n+    current_trait_object: Option<&'ast [ast::GenericBound]>,\n+\n+    /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n+    current_where_predicate: Option<&'ast WherePredicate>,\n }\n \n struct LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -453,6 +460,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.diagnostic_metadata.current_let_binding = original;\n     }\n     fn visit_ty(&mut self, ty: &'ast Ty) {\n+        let prev = self.diagnostic_metadata.current_trait_object;\n         match ty.kind {\n             TyKind::Path(ref qself, ref path) => {\n                 self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n@@ -464,9 +472,13 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n             }\n+            TyKind::TraitObject(ref bounds, ..) => {\n+                self.diagnostic_metadata.current_trait_object = Some(&bounds[..]);\n+            }\n             _ => (),\n         }\n         visit::walk_ty(self, ty);\n+        self.diagnostic_metadata.current_trait_object = prev;\n     }\n     fn visit_poly_trait_ref(&mut self, tref: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n         self.smart_resolve_path(\n@@ -660,6 +672,14 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         }\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n+\n+    fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n+        debug!(\"visit_where_predicate {:?}\", p);\n+        let previous_value =\n+            replace(&mut self.diagnostic_metadata.current_where_predicate, Some(p));\n+        visit::walk_where_predicate(self, p);\n+        self.diagnostic_metadata.current_where_predicate = previous_value;\n+    }\n }\n \n impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {"}, {"sha": "bee05e7738280ebc56e6e2701b1a07d5bb2d4e7c", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 327, "deletions": 37, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,25 +1,26 @@\n use crate::diagnostics::{ImportSuggestion, LabelSuggestion, TypoSuggestion};\n use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n-use crate::late::{LateResolutionVisitor, RibKind};\n+use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n use crate::path_names_to_string;\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_ast::visit::FnKind;\n use rustc_ast::{self as ast, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n+use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, CtorKind, DefKind};\n+use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n \n use tracing::debug;\n \n@@ -439,27 +440,213 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n         }\n \n-        if !self.type_ascription_suggestion(&mut err, base_span)\n-            && !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span)\n-        {\n-            // Fallback label.\n-            err.span_label(base_span, fallback_label);\n-\n-            match self.diagnostic_metadata.current_let_binding {\n-                Some((pat_sp, Some(ty_sp), None)) if ty_sp.contains(base_span) && could_be_expr => {\n-                    err.span_suggestion_short(\n-                        pat_sp.between(ty_sp),\n-                        \"use `=` if you meant to assign\",\n-                        \" = \".to_string(),\n-                        Applicability::MaybeIncorrect,\n+        if !self.type_ascription_suggestion(&mut err, base_span) {\n+            let mut fallback = false;\n+            if let (\n+                PathSource::Trait(AliasPossibility::Maybe),\n+                Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n+            ) = (source, res)\n+            {\n+                if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n+                    fallback = true;\n+                    let spans: Vec<Span> = bounds\n+                        .iter()\n+                        .map(|bound| bound.span())\n+                        .filter(|&sp| sp != base_span)\n+                        .collect();\n+\n+                    let start_span = bounds.iter().map(|bound| bound.span()).next().unwrap();\n+                    // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n+                    let end_span = bounds.iter().map(|bound| bound.span()).last().unwrap();\n+                    // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n+                    let last_bound_span = spans.last().cloned().unwrap();\n+                    let mut multi_span: MultiSpan = spans.clone().into();\n+                    for sp in spans {\n+                        let msg = if sp == last_bound_span {\n+                            format!(\n+                                \"...because of {} bound{}\",\n+                                if bounds.len() <= 2 { \"this\" } else { \"these\" },\n+                                if bounds.len() <= 2 { \"\" } else { \"s\" },\n+                            )\n+                        } else {\n+                            String::new()\n+                        };\n+                        multi_span.push_span_label(sp, msg);\n+                    }\n+                    multi_span.push_span_label(\n+                        base_span,\n+                        \"expected this type to be a trait...\".to_string(),\n+                    );\n+                    err.span_help(\n+                        multi_span,\n+                        \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n+                         auto-traits; structs and enums can't be bound in that way\",\n                     );\n+                    if bounds.iter().all(|bound| match bound {\n+                        ast::GenericBound::Outlives(_) => true,\n+                        ast::GenericBound::Trait(tr, _) => tr.span == base_span,\n+                    }) {\n+                        let mut sugg = vec![];\n+                        if base_span != start_span {\n+                            sugg.push((start_span.until(base_span), String::new()));\n+                        }\n+                        if base_span != end_span {\n+                            sugg.push((base_span.shrink_to_hi().to(end_span), String::new()));\n+                        }\n+\n+                        err.multipart_suggestion(\n+                            \"if you meant to use a type and not a trait here, remove the bounds\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 }\n-                _ => {}\n+            }\n+\n+            fallback |= self.restrict_assoc_type_in_where_clause(span, &mut err);\n+\n+            if !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span) {\n+                fallback = true;\n+                match self.diagnostic_metadata.current_let_binding {\n+                    Some((pat_sp, Some(ty_sp), None))\n+                        if ty_sp.contains(base_span) && could_be_expr =>\n+                    {\n+                        err.span_suggestion_short(\n+                            pat_sp.between(ty_sp),\n+                            \"use `=` if you meant to assign\",\n+                            \" = \".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            if fallback {\n+                // Fallback label.\n+                err.span_label(base_span, fallback_label);\n             }\n         }\n         (err, candidates)\n     }\n \n+    /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n+    fn restrict_assoc_type_in_where_clause(\n+        &mut self,\n+        span: Span,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) -> bool {\n+        // Detect that we are actually in a `where` predicate.\n+        let (bounded_ty, bounds, where_span) =\n+            if let Some(ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                bounded_ty,\n+                bound_generic_params,\n+                bounds,\n+                span,\n+            })) = self.diagnostic_metadata.current_where_predicate\n+            {\n+                if !bound_generic_params.is_empty() {\n+                    return false;\n+                }\n+                (bounded_ty, bounds, span)\n+            } else {\n+                return false;\n+            };\n+\n+        // Confirm that the target is an associated type.\n+        let (ty, position, path) = if let ast::TyKind::Path(\n+            Some(ast::QSelf { ty, position, .. }),\n+            path,\n+        ) = &bounded_ty.kind\n+        {\n+            // use this to verify that ident is a type param.\n+            let partial_res = if let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n+                bounded_ty.id,\n+                None,\n+                &Segment::from_path(path),\n+                Namespace::TypeNS,\n+                span,\n+                true,\n+                CrateLint::No,\n+            ) {\n+                partial_res\n+            } else {\n+                return false;\n+            };\n+            if !(matches!(\n+                partial_res.base_res(),\n+                hir::def::Res::Def(hir::def::DefKind::AssocTy, _)\n+            ) && partial_res.unresolved_segments() == 0)\n+            {\n+                return false;\n+            }\n+            (ty, position, path)\n+        } else {\n+            return false;\n+        };\n+\n+        if let ast::TyKind::Path(None, type_param_path) = &ty.peel_refs().kind {\n+            // Confirm that the `SelfTy` is a type parameter.\n+            let partial_res = if let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n+                bounded_ty.id,\n+                None,\n+                &Segment::from_path(type_param_path),\n+                Namespace::TypeNS,\n+                span,\n+                true,\n+                CrateLint::No,\n+            ) {\n+                partial_res\n+            } else {\n+                return false;\n+            };\n+            if !(matches!(\n+                partial_res.base_res(),\n+                hir::def::Res::Def(hir::def::DefKind::TyParam, _)\n+            ) && partial_res.unresolved_segments() == 0)\n+            {\n+                return false;\n+            }\n+            if let (\n+                [ast::PathSegment { ident: constrain_ident, args: None, .. }],\n+                [ast::GenericBound::Trait(poly_trait_ref, ast::TraitBoundModifier::None)],\n+            ) = (&type_param_path.segments[..], &bounds[..])\n+            {\n+                if let [ast::PathSegment { ident, args: None, .. }] =\n+                    &poly_trait_ref.trait_ref.path.segments[..]\n+                {\n+                    if ident.span == span {\n+                        err.span_suggestion_verbose(\n+                            *where_span,\n+                            &format!(\"constrain the associated type to `{}`\", ident),\n+                            format!(\n+                                \"{}: {}<{} = {}>\",\n+                                self.r\n+                                    .session\n+                                    .source_map()\n+                                    .span_to_snippet(ty.span) // Account for `<&'a T as Foo>::Bar`.\n+                                    .unwrap_or_else(|_| constrain_ident.to_string()),\n+                                path.segments[..*position]\n+                                    .iter()\n+                                    .map(|segment| path_segment_to_string(segment))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"::\"),\n+                                path.segments[*position..]\n+                                    .iter()\n+                                    .map(|segment| path_segment_to_string(segment))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"::\"),\n+                                ident,\n+                            ),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// Check if the source is call expression and the first argument is `self`. If true,\n     /// return the span of whole call and the span for all arguments expect the first one (`self`).\n     fn call_has_self_arg(&self, source: PathSource<'_>) -> Option<(Span, Option<Span>)> {\n@@ -726,24 +913,8 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     // We already suggested changing `:` into `::` during parsing.\n                     return false;\n                 }\n-                if let Some(variants) = self.collect_enum_variants(def_id) {\n-                    if !variants.is_empty() {\n-                        let msg = if variants.len() == 1 {\n-                            \"try using the enum's variant\"\n-                        } else {\n-                            \"try using one of the enum's variants\"\n-                        };\n \n-                        err.span_suggestions(\n-                            span,\n-                            msg,\n-                            variants.iter().map(path_names_to_string),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                } else {\n-                    err.note(\"you might have meant to use one of the enum's variants\");\n-                }\n+                self.suggest_using_enum_variant(err, source, def_id, span);\n             }\n             (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n                 if let Some((ctor_def, ctor_vis, fields)) =\n@@ -1126,20 +1297,139 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         result\n     }\n \n-    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n+    fn collect_enum_ctors(&mut self, def_id: DefId) -> Option<Vec<(Path, DefId, CtorKind)>> {\n         self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n             let mut variants = Vec::new();\n             enum_module.for_each_child(self.r, |_, ident, _, name_binding| {\n-                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n+                if let Res::Def(DefKind::Ctor(CtorOf::Variant, kind), def_id) = name_binding.res() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n                     segms.push(ast::PathSegment::from_ident(ident));\n-                    variants.push(Path { span: name_binding.span, segments: segms, tokens: None });\n+                    let path = Path { span: name_binding.span, segments: segms, tokens: None };\n+                    variants.push((path, def_id, kind));\n                 }\n             });\n             variants\n         })\n     }\n \n+    /// Adds a suggestion for using an enum's variant when an enum is used instead.\n+    fn suggest_using_enum_variant(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        source: PathSource<'_>,\n+        def_id: DefId,\n+        span: Span,\n+    ) {\n+        let variants = match self.collect_enum_ctors(def_id) {\n+            Some(variants) => variants,\n+            None => {\n+                err.note(\"you might have meant to use one of the enum's variants\");\n+                return;\n+            }\n+        };\n+\n+        let suggest_only_tuple_variants =\n+            matches!(source, PathSource::TupleStruct(..)) || source.is_call();\n+        let mut suggestable_variants = if suggest_only_tuple_variants {\n+            // Suggest only tuple variants regardless of whether they have fields and do not\n+            // suggest path with added parenthesis.\n+            variants\n+                .iter()\n+                .filter(|(.., kind)| *kind == CtorKind::Fn)\n+                .map(|(variant, ..)| path_names_to_string(variant))\n+                .collect::<Vec<_>>()\n+        } else {\n+            variants\n+                .iter()\n+                .filter(|(_, def_id, kind)| {\n+                    // Suggest only variants that have no fields (these can definitely\n+                    // be constructed).\n+                    let has_fields =\n+                        self.r.field_names.get(&def_id).map(|f| f.is_empty()).unwrap_or(false);\n+                    match kind {\n+                        CtorKind::Const => true,\n+                        CtorKind::Fn | CtorKind::Fictive if has_fields => true,\n+                        _ => false,\n+                    }\n+                })\n+                .map(|(variant, _, kind)| (path_names_to_string(variant), kind))\n+                .map(|(variant_str, kind)| {\n+                    // Add constructor syntax where appropriate.\n+                    match kind {\n+                        CtorKind::Const => variant_str,\n+                        CtorKind::Fn => format!(\"({}())\", variant_str),\n+                        CtorKind::Fictive => format!(\"({} {{}})\", variant_str),\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+        };\n+\n+        let non_suggestable_variant_count = variants.len() - suggestable_variants.len();\n+\n+        if !suggestable_variants.is_empty() {\n+            let msg = if non_suggestable_variant_count == 0 && suggestable_variants.len() == 1 {\n+                \"try using the enum's variant\"\n+            } else {\n+                \"try using one of the enum's variants\"\n+            };\n+\n+            err.span_suggestions(\n+                span,\n+                msg,\n+                suggestable_variants.drain(..),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n+        if suggest_only_tuple_variants {\n+            let source_msg = if source.is_call() {\n+                \"to construct\"\n+            } else if matches!(source, PathSource::TupleStruct(..)) {\n+                \"to match against\"\n+            } else {\n+                unreachable!()\n+            };\n+\n+            // If the enum has no tuple variants..\n+            if non_suggestable_variant_count == variants.len() {\n+                err.help(&format!(\"the enum has no tuple variants {}\", source_msg));\n+            }\n+\n+            // If there are also non-tuple variants..\n+            if non_suggestable_variant_count == 1 {\n+                err.help(&format!(\n+                    \"you might have meant {} the enum's non-tuple variant\",\n+                    source_msg\n+                ));\n+            } else if non_suggestable_variant_count >= 1 {\n+                err.help(&format!(\n+                    \"you might have meant {} one of the enum's non-tuple variants\",\n+                    source_msg\n+                ));\n+            }\n+        } else {\n+            let made_suggestion = non_suggestable_variant_count != variants.len();\n+            if made_suggestion {\n+                if non_suggestable_variant_count == 1 {\n+                    err.help(\n+                        \"you might have meant to use the enum's other variant that has fields\",\n+                    );\n+                } else if non_suggestable_variant_count >= 1 {\n+                    err.help(\n+                        \"you might have meant to use one of the enum's other variants that \\\n+                         have fields\",\n+                    );\n+                }\n+            } else {\n+                if non_suggestable_variant_count == 1 {\n+                    err.help(\"you might have meant to use the enum's variant\");\n+                } else if non_suggestable_variant_count >= 1 {\n+                    err.help(\"you might have meant to use one of the enum's variants\");\n+                }\n+            }\n+        }\n+    }\n+\n     crate fn report_missing_type_error(\n         &self,\n         path: &[Segment],"}, {"sha": "6677a5ffe2867e3218078ae027725a2e2e83a19a", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -218,7 +218,7 @@ enum ResolutionError<'a> {\n     ParamInTyOfConstParam(Symbol),\n     /// constant values inside of type parameter defaults must not depend on generic parameters.\n     ParamInAnonConstInTyDefault(Symbol),\n-    /// generic parameters must not be used inside of non-trivial constant values.\n+    /// generic parameters must not be used inside const evaluations.\n     ///\n     /// This error is only emitted when using `min_const_generics`.\n     ParamInNonTrivialAnonConst { name: Symbol, is_type: bool },"}, {"sha": "8b79c93e7605bf98b706175f06616b37d4eb0aff", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -107,7 +107,7 @@ impl serialize::Encoder for Encoder {\n \n     #[inline]\n     fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-        let as_u8: u8 = unsafe { ::std::mem::transmute(v) };\n+        let as_u8: u8 = unsafe { std::mem::transmute(v) };\n         self.emit_u8(as_u8)\n     }\n \n@@ -300,13 +300,13 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     #[inline]\n     fn read_char(&mut self) -> Result<char, Self::Error> {\n         let bits = self.read_u32()?;\n-        Ok(::std::char::from_u32(bits).unwrap())\n+        Ok(std::char::from_u32(bits).unwrap())\n     }\n \n     #[inline]\n     fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error> {\n         let len = self.read_usize()?;\n-        let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n+        let s = std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n         Ok(Cow::Borrowed(s))\n     }"}, {"sha": "f33bebf99d6e1d62a3aa6668c87da27c216cf448", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -34,11 +34,6 @@ use std::iter::{self, FromIterator};\n use std::path::{Path, PathBuf};\n use std::str::{self, FromStr};\n \n-pub struct Config {\n-    pub target: Target,\n-    pub ptr_width: u32,\n-}\n-\n bitflags! {\n     #[derive(Default, Encodable, Decodable)]\n     pub struct SanitizerSet: u8 {\n@@ -740,24 +735,24 @@ pub const fn default_lib_output() -> CrateType {\n }\n \n pub fn default_configuration(sess: &Session) -> CrateConfig {\n-    let end = &sess.target.target.target_endian;\n-    let arch = &sess.target.target.arch;\n-    let wordsz = &sess.target.target.target_pointer_width;\n-    let os = &sess.target.target.target_os;\n-    let env = &sess.target.target.target_env;\n-    let vendor = &sess.target.target.target_vendor;\n-    let min_atomic_width = sess.target.target.min_atomic_width();\n-    let max_atomic_width = sess.target.target.max_atomic_width();\n-    let atomic_cas = sess.target.target.options.atomic_cas;\n-    let layout = TargetDataLayout::parse(&sess.target.target).unwrap_or_else(|err| {\n+    let end = &sess.target.target_endian;\n+    let arch = &sess.target.arch;\n+    let wordsz = sess.target.pointer_width.to_string();\n+    let os = &sess.target.target_os;\n+    let env = &sess.target.target_env;\n+    let vendor = &sess.target.target_vendor;\n+    let min_atomic_width = sess.target.min_atomic_width();\n+    let max_atomic_width = sess.target.max_atomic_width();\n+    let atomic_cas = sess.target.options.atomic_cas;\n+    let layout = TargetDataLayout::parse(&sess.target).unwrap_or_else(|err| {\n         sess.fatal(&err);\n     });\n \n     let mut ret = FxHashSet::default();\n     ret.reserve(6); // the minimum number of insertions\n     // Target bindings.\n     ret.insert((sym::target_os, Some(Symbol::intern(os))));\n-    if let Some(ref fam) = sess.target.target.options.target_family {\n+    if let Some(ref fam) = sess.target.options.target_family {\n         ret.insert((sym::target_family, Some(Symbol::intern(fam))));\n         if fam == \"windows\" {\n             ret.insert((sym::windows, None));\n@@ -767,10 +762,10 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n     }\n     ret.insert((sym::target_arch, Some(Symbol::intern(arch))));\n     ret.insert((sym::target_endian, Some(Symbol::intern(end))));\n-    ret.insert((sym::target_pointer_width, Some(Symbol::intern(wordsz))));\n+    ret.insert((sym::target_pointer_width, Some(Symbol::intern(&wordsz))));\n     ret.insert((sym::target_env, Some(Symbol::intern(env))));\n     ret.insert((sym::target_vendor, Some(Symbol::intern(vendor))));\n-    if sess.target.target.options.has_elf_tls {\n+    if sess.target.options.has_elf_tls {\n         ret.insert((sym::target_thread_local, None));\n     }\n     for &(i, align) in &[\n@@ -792,7 +787,7 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n             };\n             let s = i.to_string();\n             insert_atomic(&s, align);\n-            if &s == wordsz {\n+            if s == wordsz {\n                 insert_atomic(\"ptr\", layout.pointer_align.abi);\n             }\n         }\n@@ -831,7 +826,7 @@ pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateCo\n     user_cfg\n }\n \n-pub fn build_target_config(opts: &Options, target_override: Option<Target>) -> Config {\n+pub fn build_target_config(opts: &Options, target_override: Option<Target>) -> Target {\n     let target_result = target_override.map_or_else(|| Target::search(&opts.target_triple), Ok);\n     let target = target_result.unwrap_or_else(|e| {\n         early_error(\n@@ -844,21 +839,18 @@ pub fn build_target_config(opts: &Options, target_override: Option<Target>) -> C\n         )\n     });\n \n-    let ptr_width = match &target.target_pointer_width[..] {\n-        \"16\" => 16,\n-        \"32\" => 32,\n-        \"64\" => 64,\n-        w => early_error(\n+    if !matches!(target.pointer_width, 16 | 32 | 64) {\n+        early_error(\n             opts.error_format,\n             &format!(\n                 \"target specification was invalid: \\\n              unrecognized target-pointer-width {}\",\n-                w\n+                target.pointer_width\n             ),\n-        ),\n-    };\n+        )\n+    }\n \n-    Config { target, ptr_width }\n+    target\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "fef3164de59be52b46adf78b2869b131b8f3f6c5", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1881,6 +1881,16 @@ declare_lint! {\n     \"detects code samples in docs of private items not documented by rustdoc\"\n }\n \n+declare_lint! {\n+    /// The `invalid_html_tags` lint detects invalid HTML tags. This is a\n+    /// `rustdoc` only lint, see the documentation in the [rustdoc book].\n+    ///\n+    /// [rustdoc book]: ../../../rustdoc/lints.html#invalid_html_tags\n+    pub INVALID_HTML_TAGS,\n+    Allow,\n+    \"detects invalid HTML tags in doc comments\"\n+}\n+\n declare_lint! {\n     /// The `where_clauses_object_safety` lint detects for [object safety] of\n     /// [where clauses].\n@@ -2699,6 +2709,7 @@ declare_lint_pass! {\n         INVALID_CODEBLOCK_ATTRIBUTES,\n         MISSING_CRATE_LEVEL_DOCS,\n         MISSING_DOC_CODE_EXAMPLES,\n+        INVALID_HTML_TAGS,\n         PRIVATE_DOC_TESTS,\n         WHERE_CLAUSES_OBJECT_SAFETY,\n         PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,"}, {"sha": "627adcceb3f4a2e6277916308296d782910fca7e", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1078,6 +1078,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show extended diagnostic help (default: no)\"),\n     terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n         \"set the current terminal width\"),\n+    tune_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"select processor to schedule for (`rustc --print target-cpus` for details)\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     // We default to 1 here since we want to behave like"}, {"sha": "0766c55da7431c486648b8434a66649565ccc675", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -151,18 +151,16 @@ pub fn filename_for_input(\n         CrateType::Rlib => outputs.out_directory.join(&format!(\"lib{}.rlib\", libname)),\n         CrateType::Cdylib | CrateType::ProcMacro | CrateType::Dylib => {\n             let (prefix, suffix) =\n-                (&sess.target.target.options.dll_prefix, &sess.target.target.options.dll_suffix);\n+                (&sess.target.options.dll_prefix, &sess.target.options.dll_suffix);\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n         CrateType::Staticlib => {\n-            let (prefix, suffix) = (\n-                &sess.target.target.options.staticlib_prefix,\n-                &sess.target.target.options.staticlib_suffix,\n-            );\n+            let (prefix, suffix) =\n+                (&sess.target.options.staticlib_prefix, &sess.target.options.staticlib_suffix);\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n         CrateType::Executable => {\n-            let suffix = &sess.target.target.options.exe_suffix;\n+            let suffix = &sess.target.options.exe_suffix;\n             let out_filename = outputs.path(OutputType::Exe);\n             if suffix.is_empty() { out_filename } else { out_filename.with_extension(&suffix[1..]) }\n         }\n@@ -179,35 +177,29 @@ pub fn filename_for_input(\n /// interaction with Rust code through static library is the only\n /// option for now\n pub fn default_output_for_target(sess: &Session) -> CrateType {\n-    if !sess.target.target.options.executables {\n-        CrateType::Staticlib\n-    } else {\n-        CrateType::Executable\n-    }\n+    if !sess.target.options.executables { CrateType::Staticlib } else { CrateType::Executable }\n }\n \n /// Checks if target supports crate_type as output\n pub fn invalid_output_for_target(sess: &Session, crate_type: CrateType) -> bool {\n     match crate_type {\n         CrateType::Cdylib | CrateType::Dylib | CrateType::ProcMacro => {\n-            if !sess.target.target.options.dynamic_linking {\n+            if !sess.target.options.dynamic_linking {\n                 return true;\n             }\n-            if sess.crt_static(Some(crate_type))\n-                && !sess.target.target.options.crt_static_allows_dylibs\n-            {\n+            if sess.crt_static(Some(crate_type)) && !sess.target.options.crt_static_allows_dylibs {\n                 return true;\n             }\n         }\n         _ => {}\n     }\n-    if sess.target.target.options.only_cdylib {\n+    if sess.target.options.only_cdylib {\n         match crate_type {\n             CrateType::ProcMacro | CrateType::Dylib => return true,\n             _ => {}\n         }\n     }\n-    if !sess.target.target.options.executables {\n+    if !sess.target.options.executables {\n         if crate_type == CrateType::Executable {\n             return true;\n         }"}, {"sha": "8312f89b2714c34c298b30fe174a55f6a7e5e6a7", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -102,7 +102,7 @@ impl Mul<usize> for Limit {\n /// Represents the data associated with a compilation\n /// session for a single crate.\n pub struct Session {\n-    pub target: config::Config,\n+    pub target: Target,\n     pub host: Target,\n     pub opts: config::Options,\n     pub host_tlib_path: SearchPath,\n@@ -614,7 +614,7 @@ impl Session {\n     /// Calculates the flavor of LTO to use for this compilation.\n     pub fn lto(&self) -> config::Lto {\n         // If our target has codegen requirements ignore the command line\n-        if self.target.target.options.requires_lto {\n+        if self.target.options.requires_lto {\n             return config::Lto::Fat;\n         }\n \n@@ -682,7 +682,7 @@ impl Session {\n     /// Returns the panic strategy for this compile session. If the user explicitly selected one\n     /// using '-C panic', use that, otherwise use the panic strategy defined by the target.\n     pub fn panic_strategy(&self) -> PanicStrategy {\n-        self.opts.cg.panic.unwrap_or(self.target.target.options.panic_strategy)\n+        self.opts.cg.panic.unwrap_or(self.target.options.panic_strategy)\n     }\n     pub fn fewer_names(&self) -> bool {\n         let more_names = self.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n@@ -706,9 +706,9 @@ impl Session {\n \n     /// Check whether this compile session and crate type use static crt.\n     pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n-        if !self.target.target.options.crt_static_respected {\n+        if !self.target.options.crt_static_respected {\n             // If the target does not opt in to crt-static support, use its default.\n-            return self.target.target.options.crt_static_default;\n+            return self.target.options.crt_static_default;\n         }\n \n         let requested_features = self.opts.cg.target_feature.split(',');\n@@ -725,20 +725,20 @@ impl Session {\n             // We can't check `#![crate_type = \"proc-macro\"]` here.\n             false\n         } else {\n-            self.target.target.options.crt_static_default\n+            self.target.options.crt_static_default\n         }\n     }\n \n     pub fn relocation_model(&self) -> RelocModel {\n-        self.opts.cg.relocation_model.unwrap_or(self.target.target.options.relocation_model)\n+        self.opts.cg.relocation_model.unwrap_or(self.target.options.relocation_model)\n     }\n \n     pub fn code_model(&self) -> Option<CodeModel> {\n-        self.opts.cg.code_model.or(self.target.target.options.code_model)\n+        self.opts.cg.code_model.or(self.target.options.code_model)\n     }\n \n     pub fn tls_model(&self) -> TlsModel {\n-        self.opts.debugging_opts.tls_model.unwrap_or(self.target.target.options.tls_model)\n+        self.opts.debugging_opts.tls_model.unwrap_or(self.target.options.tls_model)\n     }\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n@@ -749,7 +749,7 @@ impl Session {\n         } else if let Some(x) = self.opts.cg.force_frame_pointers {\n             x\n         } else {\n-            !self.target.target.options.eliminate_frame_pointer\n+            !self.target.options.eliminate_frame_pointer\n         }\n     }\n \n@@ -773,7 +773,7 @@ impl Session {\n         // value, if it is provided, or disable them, if not.\n         if self.panic_strategy() == PanicStrategy::Unwind {\n             true\n-        } else if self.target.target.options.requires_uwtable {\n+        } else if self.target.options.requires_uwtable {\n             true\n         } else {\n             self.opts.cg.force_unwind_tables.unwrap_or(false)\n@@ -944,7 +944,7 @@ impl Session {\n         if let Some(n) = self.opts.cli_forced_codegen_units {\n             return n;\n         }\n-        if let Some(n) = self.target.target.options.default_codegen_units {\n+        if let Some(n) = self.target.options.default_codegen_units {\n             return n as usize;\n         }\n \n@@ -1029,11 +1029,11 @@ impl Session {\n     pub fn needs_plt(&self) -> bool {\n         // Check if the current target usually needs PLT to be enabled.\n         // The user can use the command line flag to override it.\n-        let needs_plt = self.target.target.options.needs_plt;\n+        let needs_plt = self.target.options.needs_plt;\n \n         let dbg_opts = &self.opts.debugging_opts;\n \n-        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.target.options.relro_level);\n+        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.options.relro_level);\n \n         // Only enable this optimization by default if full relro is also enabled.\n         // In this case, lazy binding was already unavailable, so nothing is lost.\n@@ -1057,8 +1057,7 @@ impl Session {\n         match self.opts.cg.link_dead_code {\n             Some(explicitly_set) => explicitly_set,\n             None => {\n-                self.opts.debugging_opts.instrument_coverage\n-                    && !self.target.target.options.is_like_msvc\n+                self.opts.debugging_opts.instrument_coverage && !self.target.options.is_like_msvc\n                 // Issue #76038: (rustc `-Clink-dead-code` causes MSVC linker to produce invalid\n                 // binaries when LLVM InstrProf counters are enabled). As described by this issue,\n                 // the \"link dead code\" option produces incorrect binaries when compiled and linked\n@@ -1259,7 +1258,7 @@ pub fn build_session(\n \n     let loader = file_loader.unwrap_or(Box::new(RealFileLoader));\n     let hash_kind = sopts.debugging_opts.src_hash_algorithm.unwrap_or_else(|| {\n-        if target_cfg.target.options.is_like_msvc {\n+        if target_cfg.options.is_like_msvc {\n             SourceFileHashAlgorithm::Sha1\n         } else {\n             SourceFileHashAlgorithm::Md5\n@@ -1369,8 +1368,8 @@ pub fn build_session(\n         if candidate.join(\"library/std/src/lib.rs\").is_file() { Some(candidate) } else { None }\n     };\n \n-    let asm_arch = if target_cfg.target.options.allow_asm {\n-        InlineAsmArch::from_str(&target_cfg.target.arch).ok()\n+    let asm_arch = if target_cfg.options.allow_asm {\n+        InlineAsmArch::from_str(&target_cfg.arch).ok()\n     } else {\n         None\n     };\n@@ -1438,7 +1437,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     // the `dllimport` attributes and `__imp_` symbols in that case.\n     if sess.opts.cg.linker_plugin_lto.enabled()\n         && sess.opts.cg.prefer_dynamic\n-        && sess.target.target.options.is_like_windows\n+        && sess.target.options.is_like_windows\n     {\n         sess.err(\n             \"Linker plugin based LTO is not supported together with \\\n@@ -1466,7 +1465,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n             );\n         }\n \n-        if sess.target.target.options.requires_uwtable && !include_uwtables {\n+        if sess.target.options.requires_uwtable && !include_uwtables {\n             sess.err(\n                 \"target requires unwind tables, they cannot be disabled with \\\n                      `-C force-unwind-tables=no`.\",\n@@ -1481,7 +1480,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     // We should only display this error if we're actually going to run PGO.\n     // If we're just supposed to print out some data, don't show the error (#61002).\n     if sess.opts.cg.profile_generate.enabled()\n-        && sess.target.target.options.is_like_msvc\n+        && sess.target.options.is_like_msvc\n         && sess.panic_strategy() == PanicStrategy::Unwind\n         && sess.opts.prints.iter().all(|&p| p == PrintRequest::NativeStaticLibs)\n     {\n@@ -1586,5 +1585,3 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n     handler.struct_warn(msg).emit();\n }\n-\n-pub type CompileResult = Result<(), ErrorReported>;"}, {"sha": "31f3d8e3791098c434c4711a4ed554239d652e0a", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -619,14 +619,6 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.outer_mark(self))\n     }\n \n-    #[inline]\n-    pub fn outer_mark_with_data(self) -> (ExpnId, Transparency, ExpnData) {\n-        HygieneData::with(|data| {\n-            let (expn_id, transparency) = data.outer_mark(self);\n-            (expn_id, transparency, data.expn_data(expn_id).clone())\n-        })\n-    }\n-\n     pub fn dollar_crate_name(self) -> Symbol {\n         HygieneData::with(|data| data.syntax_context_data[self.0 as usize].dollar_crate_name)\n     }"}, {"sha": "d036c078049909d978628388589673bf56b28d25", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -223,12 +223,6 @@ impl FileName {\n         }\n     }\n \n-    pub fn quote_expansion_source_code(src: &str) -> FileName {\n-        let mut hasher = StableHasher::new();\n-        src.hash(&mut hasher);\n-        FileName::QuoteExpansion(hasher.finish())\n-    }\n-\n     pub fn macro_expansion_source_code(src: &str) -> FileName {\n         let mut hasher = StableHasher::new();\n         src.hash(&mut hasher);\n@@ -1861,7 +1855,7 @@ where\n         }\n \n         if *self == DUMMY_SP {\n-            std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+            Hash::hash(&TAG_INVALID_SPAN, hasher);\n             return;\n         }\n \n@@ -1872,28 +1866,28 @@ where\n         let (file_lo, line_lo, col_lo) = match ctx.byte_pos_to_line_and_col(span.lo) {\n             Some(pos) => pos,\n             None => {\n-                std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+                Hash::hash(&TAG_INVALID_SPAN, hasher);\n                 span.ctxt.hash_stable(ctx, hasher);\n                 return;\n             }\n         };\n \n         if !file_lo.contains(span.hi) {\n-            std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+            Hash::hash(&TAG_INVALID_SPAN, hasher);\n             span.ctxt.hash_stable(ctx, hasher);\n             return;\n         }\n \n-        std::hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n+        Hash::hash(&TAG_VALID_SPAN, hasher);\n         // We truncate the stable ID hash and line and column numbers. The chances\n         // of causing a collision this way should be minimal.\n-        std::hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n+        Hash::hash(&(file_lo.name_hash as u64), hasher);\n \n         let col = (col_lo.0 as u64) & 0xFF;\n         let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n         let len = ((span.hi - span.lo).0 as u64) << 32;\n         let line_col_len = col | line | len;\n-        std::hash::Hash::hash(&line_col_len, hasher);\n+        Hash::hash(&line_col_len, hasher);\n         span.ctxt.hash_stable(ctx, hasher);\n     }\n }"}, {"sha": "3b929c4acb902a99fb2c39d91dc728be3a33f2ae", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -451,15 +451,6 @@ impl SourceMap {\n         }\n     }\n \n-    /// Returns a new `Span` covering the start and end `BytePos`s of the file containing the given\n-    /// `pos`. This can be used to quickly determine if another `BytePos` or `Span` is from the same\n-    /// file.\n-    pub fn lookup_file_span(&self, pos: BytePos) -> Span {\n-        let idx = self.lookup_source_file_idx(pos);\n-        let SourceFile { start_pos, end_pos, .. } = *(*self.files.borrow().source_files)[idx];\n-        Span::with_root_ctxt(start_pos, end_pos)\n-    }\n-\n     /// Returns `Some(span)`, a union of the LHS and RHS span. The LHS must precede the RHS. If\n     /// there are gaps between LHS and RHS, the resulting union will cross these gaps.\n     /// For this to work,"}, {"sha": "28fef65da070aa095da5ebc36f586c20f02dc47c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -212,6 +212,7 @@ symbols! {\n         _d,\n         _e,\n         _task_context,\n+        a32,\n         aarch64_target_feature,\n         abi,\n         abi_amdgpu_kernel,\n@@ -256,6 +257,7 @@ symbols! {\n         arbitrary_enum_discriminant,\n         arbitrary_self_types,\n         arith_offset,\n+        arm,\n         arm_target_feature,\n         array,\n         arrays,\n@@ -359,6 +361,7 @@ symbols! {\n         const_fn_union,\n         const_generics,\n         const_if_match,\n+        const_impl_trait,\n         const_in_array_repeat_expressions,\n         const_indexing,\n         const_let,\n@@ -591,11 +594,13 @@ symbols! {\n         inlateout,\n         inline,\n         inout,\n+        instruction_set,\n         intel,\n         into_iter,\n         into_result,\n         intrinsics,\n         irrefutable_let_patterns,\n+        isa_attribute,\n         isize,\n         issue,\n         issue_5723_bootstrap,\n@@ -1064,6 +1069,7 @@ symbols! {\n         sym,\n         sync,\n         sync_trait,\n+        t32,\n         target_arch,\n         target_endian,\n         target_env,\n@@ -1108,6 +1114,7 @@ symbols! {\n         try_trait,\n         tt,\n         tuple,\n+        tuple_from_req,\n         tuple_indexing,\n         two_phase,\n         ty,"}, {"sha": "2c9caf73b8e425318ff856fbc5aca328f9125a55", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -115,7 +115,6 @@ fn get_symbol_hash<'tcx>(\n         }\n \n         // also include any type parameters (for generic items)\n-        assert!(!substs.has_erasable_regions());\n         substs.hash_stable(&mut hcx, &mut hasher);\n \n         if let Some(instantiating_crate) = instantiating_crate {"}, {"sha": "28b4a78929e5906f86cc13b704dd6dc99015eeb4", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -201,7 +201,7 @@ fn compute_symbol_name(\n     //\n     // [1]: https://bugs.llvm.org/show_bug.cgi?id=44316\n     if is_foreign {\n-        if tcx.sess.target.target.arch != \"wasm32\"\n+        if tcx.sess.target.arch != \"wasm32\"\n             || !tcx.wasm_import_module_map(def_id.krate).contains_key(&def_id)\n         {\n             if let Some(name) = attrs.link_name {"}, {"sha": "822a835293474a654ad5c1d0118e9e0fa752b0f1", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -6,7 +6,7 @@\n \n use rustc_hir as hir;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{Instance, TyCtxt};\n+use rustc_middle::ty::{subst::InternalSubsts, Instance, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n@@ -36,8 +36,11 @@ impl SymbolNamesTest<'tcx> {\n         let def_id = tcx.hir().local_def_id(hir_id);\n         for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n             if tcx.sess.check_name(attr, SYMBOL_NAME) {\n-                // for now, can only use on monomorphic names\n-                let instance = Instance::mono(tcx, def_id.to_def_id());\n+                let def_id = def_id.to_def_id();\n+                let instance = Instance::new(\n+                    def_id,\n+                    tcx.erase_regions(&InternalSubsts::identity_for_item(tcx, def_id)),\n+                );\n                 let mangled = tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n                 if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {"}, {"sha": "16d0b86903ea889e9ad054f07fc179fc02249ed8", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -132,7 +132,7 @@ impl SymbolMangler<'tcx> {\n             self.push(\"u\");\n \n             // FIXME(eddyb) we should probably roll our own punycode implementation.\n-            let mut punycode_bytes = match ::punycode::encode(ident) {\n+            let mut punycode_bytes = match punycode::encode(ident) {\n                 Ok(s) => s.into_bytes(),\n                 Err(()) => bug!(\"symbol_names: punycode encoding failed for ident {:?}\", ident),\n             };\n@@ -259,7 +259,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n     }\n \n     fn print_impl_path(\n-        self,\n+        mut self,\n         impl_def_id: DefId,\n         substs: &'tcx [GenericArg<'tcx>],\n         mut self_ty: Ty<'tcx>,\n@@ -284,12 +284,37 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             }\n         }\n \n-        self.path_append_impl(\n-            |cx| cx.print_def_path(parent_def_id, &[]),\n-            &key.disambiguated_data,\n-            self_ty,\n-            impl_trait_ref,\n-        )\n+        self.push(match impl_trait_ref {\n+            Some(_) => \"X\",\n+            None => \"M\",\n+        });\n+\n+        // Encode impl generic params if the substitutions contain parameters (implying\n+        // polymorphization is enabled) and this isn't an inherent impl.\n+        if impl_trait_ref.is_some() && substs.iter().any(|a| a.has_param_types_or_consts()) {\n+            self = self.path_generic_args(\n+                |this| {\n+                    this.path_append_ns(\n+                        |cx| cx.print_def_path(parent_def_id, &[]),\n+                        'I',\n+                        key.disambiguated_data.disambiguator as u64,\n+                        \"\",\n+                    )\n+                },\n+                substs,\n+            )?;\n+        } else {\n+            self.push_disambiguator(key.disambiguated_data.disambiguator as u64);\n+            self = self.print_def_path(parent_def_id, &[])?;\n+        }\n+\n+        self = self_ty.print(self)?;\n+\n+        if let Some(trait_ref) = impl_trait_ref {\n+            self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n+        }\n+\n+        Ok(self)\n     }\n \n     fn print_region(mut self, region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n@@ -538,6 +563,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         self.push_ident(&name);\n         Ok(self)\n     }\n+\n     fn path_qualified(\n         mut self,\n         self_ty: Ty<'tcx>,\n@@ -552,24 +578,16 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n     }\n \n     fn path_append_impl(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n+        self,\n+        _: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _: &DisambiguatedDefPathData,\n+        _: Ty<'tcx>,\n+        _: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.push(match trait_ref {\n-            Some(_) => \"X\",\n-            None => \"M\",\n-        });\n-        self.push_disambiguator(disambiguated_data.disambiguator as u64);\n-        self = print_prefix(self)?;\n-        self = self_ty.print(self)?;\n-        if let Some(trait_ref) = trait_ref {\n-            self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n-        }\n-        Ok(self)\n+        // Inlined into `print_impl_path`\n+        unreachable!()\n     }\n+\n     fn path_append(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n@@ -603,6 +621,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n             name.as_ref().map_or(\"\", |s| &s[..]),\n         )\n     }\n+\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "047b8cf5cdbe89faa875c6fae1ff43a05b80434d", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -164,12 +164,12 @@ impl TargetDataLayout {\n             ));\n         }\n \n-        if dl.pointer_size.bits().to_string() != target.target_pointer_width {\n+        if dl.pointer_size.bits() != target.pointer_width.into() {\n             return Err(format!(\n                 \"inconsistent target specification: \\\"data-layout\\\" claims \\\n                                 pointers are {}-bit, while \\\"target-pointer-width\\\" is `{}`\",\n                 dl.pointer_size.bits(),\n-                target.target_pointer_width\n+                target.pointer_width\n             ));\n         }\n "}, {"sha": "b19489aa439bf54ddcb27cbbd52baca70c503f1f", "filename": "compiler/rustc_target/src/asm/mips.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmips.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -32,43 +32,44 @@ impl MipsInlineAsmRegClass {\n \n     pub fn supported_types(\n         self,\n-        _arch: InlineAsmArch,\n+        arch: InlineAsmArch,\n     ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n-        match self {\n-            Self::reg => types! { _: I8, I16, I32, F32; },\n-            Self::freg => types! { _: F32; },\n+        match (self, arch) {\n+            (Self::reg, InlineAsmArch::Mips64) => types! { _: I8, I16, I32, I64, F32, F64; },\n+            (Self::reg, _) => types! { _: I8, I16, I32, F32; },\n+            (Self::freg, _) => types! { _: F32, F64; },\n         }\n     }\n }\n \n // The reserved registers are somewhat taken from <https://git.io/JUR1k#L150>.\n def_regs! {\n     Mips MipsInlineAsmReg MipsInlineAsmRegClass {\n-        v0: reg = [\"$2\", \"$v0\"],\n-        v1: reg = [\"$3\", \"$v1\"],\n-        a0: reg = [\"$4\", \"$a0\"],\n-        a1: reg = [\"$5\", \"$a1\"],\n-        a2: reg = [\"$6\", \"$a2\"],\n-        a3: reg = [\"$7\", \"$a3\"],\n+        r2: reg = [\"$2\"],\n+        r3: reg = [\"$3\"],\n+        r4: reg = [\"$4\"],\n+        r5: reg = [\"$5\"],\n+        r6: reg = [\"$6\"],\n+        r7: reg = [\"$7\"],\n         // FIXME: Reserve $t0, $t1 if in mips16 mode.\n-        t0: reg = [\"$8\", \"$t0\"],\n-        t1: reg = [\"$9\", \"$t1\"],\n-        t2: reg = [\"$10\", \"$t2\"],\n-        t3: reg = [\"$11\", \"$t3\"],\n-        t4: reg = [\"$12\", \"$t4\"],\n-        t5: reg = [\"$13\", \"$t5\"],\n-        t6: reg = [\"$14\", \"$t6\"],\n-        t7: reg = [\"$15\", \"$t7\"],\n-        s0: reg = [\"$16\", \"$s0\"],\n-        s1: reg = [\"$17\", \"$s1\"],\n-        s2: reg = [\"$18\", \"$s2\"],\n-        s3: reg = [\"$19\", \"$s3\"],\n-        s4: reg = [\"$20\", \"$s4\"],\n-        s5: reg = [\"$21\", \"$s5\"],\n-        s6: reg = [\"$22\", \"$s6\"],\n-        s7: reg = [\"$23\", \"$s7\"],\n-        t8: reg = [\"$24\", \"$t8\"],\n-        t9: reg = [\"$25\", \"$t9\"],\n+        r8: reg = [\"$8\"],\n+        r9: reg = [\"$9\"],\n+        r10: reg = [\"$10\"],\n+        r11: reg = [\"$11\"],\n+        r12: reg = [\"$12\"],\n+        r13: reg = [\"$13\"],\n+        r14: reg = [\"$14\"],\n+        r15: reg = [\"$15\"],\n+        r16: reg = [\"$16\"],\n+        r17: reg = [\"$17\"],\n+        r18: reg = [\"$18\"],\n+        r19: reg = [\"$19\"],\n+        r20: reg = [\"$20\"],\n+        r21: reg = [\"$21\"],\n+        r22: reg = [\"$22\"],\n+        r23: reg = [\"$23\"],\n+        r24: reg = [\"$24\"],\n+        r25: reg = [\"$25\"],\n         f0: freg = [\"$f0\"],\n         f1: freg = [\"$f1\"],\n         f2: freg = [\"$f2\"],\n@@ -101,21 +102,21 @@ def_regs! {\n         f29: freg = [\"$f29\"],\n         f30: freg = [\"$f30\"],\n         f31: freg = [\"$f31\"],\n-        #error = [\"$0\", \"$zero\"] =>\n+        #error = [\"$0\"] =>\n             \"constant zero cannot be used as an operand for inline asm\",\n-        #error = [\"$1\", \"$at\"] =>\n+        #error = [\"$1\"] =>\n             \"reserved for assembler (Assembler Temp)\",\n-        #error = [\"$26\", \"$k0\"] =>\n+        #error = [\"$26\"] =>\n             \"OS-reserved register cannot be used as an operand for inline asm\",\n-        #error = [\"$27\", \"$k1\"] =>\n+        #error = [\"$27\"] =>\n             \"OS-reserved register cannot be used as an operand for inline asm\",\n-        #error = [\"$28\", \"$gp\"] =>\n+        #error = [\"$28\"] =>\n             \"the global pointer cannot be used as an operand for inline asm\",\n-        #error = [\"$29\", \"$sp\"] =>\n+        #error = [\"$29\"] =>\n             \"the stack pointer cannot be used as an operand for inline asm\",\n-        #error = [\"$30\", \"$s8\", \"$fp\"] =>\n+        #error = [\"$30\"] =>\n             \"the frame pointer cannot be used as an operand for inline asm\",\n-        #error = [\"$31\", \"$ra\"] =>\n+        #error = [\"$31\"] =>\n             \"the return address register cannot be used as an operand for inline asm\",\n     }\n }"}, {"sha": "0d691dc441eb130aef932e306c735948be1da5d8", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -176,6 +176,7 @@ pub enum InlineAsmArch {\n     Nvptx64,\n     Hexagon,\n     Mips,\n+    Mips64,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -192,6 +193,7 @@ impl FromStr for InlineAsmArch {\n             \"nvptx64\" => Ok(Self::Nvptx64),\n             \"hexagon\" => Ok(Self::Hexagon),\n             \"mips\" => Ok(Self::Mips),\n+            \"mips64\" => Ok(Self::Mips64),\n             _ => Err(()),\n         }\n     }\n@@ -259,7 +261,7 @@ impl InlineAsmReg {\n             InlineAsmArch::Hexagon => {\n                 Self::Hexagon(HexagonInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n-            InlineAsmArch::Mips => {\n+            InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n                 Self::Mips(MipsInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n         })\n@@ -409,7 +411,9 @@ impl InlineAsmRegClass {\n                 InlineAsmArch::Hexagon => {\n                     Self::Hexagon(HexagonInlineAsmRegClass::parse(arch, name)?)\n                 }\n-                InlineAsmArch::Mips => Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?),\n+                InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n+                    Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?)\n+                }\n             })\n         })\n     }\n@@ -565,7 +569,7 @@ pub fn allocatable_registers(\n             hexagon::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n-        InlineAsmArch::Mips => {\n+        InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n             let mut map = mips::regclass_map();\n             mips::fill_reg_map(arch, has_feature, target, &mut map);\n             map"}, {"sha": "c15bd9a08fc6bf1059e3f3327b521929b3175ca4", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::apple_base::opts();\n     base.cpu = \"apple-a12\".to_string();\n     base.max_atomic_width = Some(128);\n@@ -14,10 +14,10 @@ pub fn target() -> TargetResult {\n     let arch = \"aarch64\";\n     let llvm_target = super::apple_base::macos_llvm_target(&arch);\n \n-    Ok(Target {\n+    Target {\n         llvm_target,\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: arch.to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"apple\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"\\u{1}mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "0019fc4492dfa8456747e3595abfc84142149875", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n use super::apple_sdk_base::{opts, Arch};\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = opts(Arch::Arm64);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"arm64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -33,5 +33,5 @@ pub fn target() -> TargetResult {\n                 .to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "276682c591d5f5cc9aac37ae416f124568c2fe3e", "filename": "compiler/rustc_target/src/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n use super::apple_sdk_base::{opts, Arch};\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = opts(Arch::Arm64);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"arm64-apple-tvos\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -22,5 +22,5 @@ pub fn target() -> TargetResult {\n             forces_embed_bitcode: true,\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "1f81a03c4a523e650f6d64a7b25d7c3dc71ead86", "filename": "compiler/rustc_target/src/spec/aarch64_fuchsia.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::fuchsia_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-fuchsia\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -16,5 +16,5 @@ pub fn target() -> TargetResult {\n         target_vendor: String::new(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: TargetOptions { unsupported_abis: super::arm_base::unsupported_abis(), ..base },\n-    })\n+    }\n }"}, {"sha": "1ed4f0da79c5ee8b673c152aeb2a153b11fe63b1", "filename": "compiler/rustc_target/src/spec/aarch64_linux_android.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_linux_android.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,18 +1,18 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n // See https://developer.android.com/ndk/guides/abis.html#arm64-v8a\n // for target ABI requirements.\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::android_base::opts();\n     base.max_atomic_width = Some(128);\n     // As documented in http://developer.android.com/ndk/guides/cpu-features.html\n     // the neon (ASIMD) and FP must exist on all android aarch64 targets.\n     base.features = \"+neon,+fp-armv8\".to_string();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { unsupported_abis: super::arm_base::unsupported_abis(), ..base },\n-    })\n+    }\n }"}, {"sha": "32fa2d695406413d5a18a4a351bf1f8df79dbe86", "filename": "compiler/rustc_target/src/spec/aarch64_pc_windows_msvc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_pc_windows_msvc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::windows_msvc_base::opts();\n     base.max_atomic_width = Some(64);\n     base.has_elf_tls = true;\n     base.features = \"+neon,+fp-armv8\".to_string();\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:w-p:64:64-i32:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"pc\".to_string(),\n         linker_flavor: LinkerFlavor::Msvc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "f9d62519bd973cd4dde7bba1de381b688e061e98", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_cloudabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_cloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_cloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_cloudabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::cloudabi_base::opts();\n     base.max_atomic_width = Some(128);\n     base.unsupported_abis = super::arm_base::unsupported_abis();\n     base.linker = Some(\"aarch64-unknown-cloudabi-cc\".to_string());\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-cloudabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "3d00829024085e1ccc37a7ff99655dae884cb7e7", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_freebsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_freebsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::freebsd_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -16,5 +16,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { unsupported_abis: super::arm_base::unsupported_abis(), ..base },\n-    })\n+    }\n }"}, {"sha": "a7050cbee9e3dd3ed2ea0b4cdeeaffdfa59997cc", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_hermit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_hermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_hermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_hermit.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, LldFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::hermit_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-hermit\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -16,5 +16,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: base,\n-    })\n+    }\n }"}, {"sha": "10255012e411d48159fe75892bcd2c5227d512f3", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         target_env: \"gnu\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}_mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "f530163faf7ebf9edc32ec0e2112dea90c24d63b", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         target_env: \"musl\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}_mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "dcb157d7aab84dc0b3a57c82aa9fe3ac348d5264", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_netbsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_netbsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,14 +1,14 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::netbsd_base::opts();\n     base.max_atomic_width = Some(128);\n     base.unsupported_abis = super::arm_base::unsupported_abis();\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-netbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -17,5 +17,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"__mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "6d3e72906d5728a19cb10d56c2765fdcc58944d8", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_none.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -8,7 +8,7 @@\n \n use super::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel, Target, TargetOptions};\n \n-pub fn target() -> Result<Target, String> {\n+pub fn target() -> Target {\n     let opts = TargetOptions {\n         linker: Some(\"rust-lld\".to_owned()),\n         features: \"+strict-align,+neon,+fp-armv8\".to_string(),\n@@ -21,10 +21,10 @@ pub fn target() -> Result<Target, String> {\n         unsupported_abis: super::arm_base::unsupported_abis(),\n         ..Default::default()\n     };\n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-none\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         target_os: \"none\".to_string(),\n         target_env: String::new(),\n@@ -33,5 +33,5 @@ pub fn target() -> Result<Target, String> {\n         arch: \"aarch64\".to_string(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: opts,\n-    })\n+    }\n }"}, {"sha": "784cd7eb3c9dec1557c6b0c688e92e3f630dc101", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_none_softfloat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none_softfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none_softfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none_softfloat.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -8,7 +8,7 @@\n \n use super::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel, Target, TargetOptions};\n \n-pub fn target() -> Result<Target, String> {\n+pub fn target() -> Target {\n     let opts = TargetOptions {\n         linker: Some(\"rust-lld\".to_owned()),\n         features: \"+strict-align,-neon,-fp-armv8\".to_string(),\n@@ -21,10 +21,10 @@ pub fn target() -> Result<Target, String> {\n         unsupported_abis: super::arm_base::unsupported_abis(),\n         ..Default::default()\n     };\n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-none\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         target_os: \"none\".to_string(),\n         target_env: String::new(),\n@@ -33,5 +33,5 @@ pub fn target() -> Result<Target, String> {\n         arch: \"aarch64\".to_string(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: opts,\n-    })\n+    }\n }"}, {"sha": "e03690e86b8cf1754d58f3911fe4e9c7b542e837", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_openbsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_openbsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,14 +1,14 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::openbsd_base::opts();\n     base.max_atomic_width = Some(128);\n     base.unsupported_abis = super::arm_base::unsupported_abis();\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-openbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -17,5 +17,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "13adec9d4c4deeb30ca257ed8b98b8094f1add04", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_redox.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_redox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_redox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_redox.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::redox_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-redox\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -16,5 +16,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "d6af5dd3628bcabf2dde2b00451daa7f46bd545d", "filename": "compiler/rustc_target/src/spec/aarch64_uwp_windows_msvc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_uwp_windows_msvc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,14 +1,14 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::windows_uwp_msvc_base::opts();\n     base.max_atomic_width = Some(64);\n     base.has_elf_tls = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:w-p:64:64-i32:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -17,5 +17,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"uwp\".to_string(),\n         linker_flavor: LinkerFlavor::Msvc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "6fce200a96e7da999b398088a0578508dfc5a036", "filename": "compiler/rustc_target/src/spec/aarch64_wrs_vxworks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_wrs_vxworks.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::vxworks_base::opts();\n     base.max_atomic_width = Some(128);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n@@ -16,5 +16,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"wrs\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { unsupported_abis: super::arm_base::unsupported_abis(), ..base },\n-    })\n+    }\n }"}, {"sha": "0824bc3035828b048b1220a97c9016119350376b", "filename": "compiler/rustc_target/src/spec/android_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fandroid_base.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -9,6 +9,7 @@ pub fn opts() -> TargetOptions {\n         .unwrap()\n         .push(\"-Wl,--allow-multiple-definition\".to_string());\n     base.is_like_android = true;\n+    base.dwarf_version = Some(2);\n     base.position_independent_executables = true;\n     base.has_elf_tls = false;\n     base.requires_uwtable = true;"}, {"sha": "2e3c835c0e5ec28054d87012e216218136631f2d", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -23,6 +23,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         target_family: Some(\"unix\".to_string()),\n         is_like_osx: true,\n+        dwarf_version: Some(2),\n         has_rpath: true,\n         dll_prefix: \"lib\".to_string(),\n         dll_suffix: \".dylib\".to_string(),"}, {"sha": "f9c69217460b9943c5ef65d19b92d40e856c759c", "filename": "compiler/rustc_target/src/spec/arm_linux_androideabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_linux_androideabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::android_base::opts();\n     // https://developer.android.com/ndk/guides/abis.html#armeabi\n     base.features = \"+strict-align,+v5te\".to_string();\n     base.max_atomic_width = Some(32);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"arm-linux-androideabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { unsupported_abis: super::arm_base::unsupported_abis(), ..base },\n-    })\n+    }\n }"}, {"sha": "96a444fc465fc9f149d46d358c1e0642733ae5e1", "filename": "compiler/rustc_target/src/spec/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = Some(64);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "534b98cc60703298e3d564fa8e462c00cad115aa", "filename": "compiler/rustc_target/src/spec/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_gnueabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.max_atomic_width = Some(64);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "e5fa3e3a1cb5e3228ad16eb96a87511dd0e5ab5d", "filename": "compiler/rustc_target/src/spec/arm_unknown_linux_musleabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_musleabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,19 +1,19 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n \n     // Most of these settings are copied from the arm_unknown_linux_gnueabi\n     // target.\n     base.features = \"+strict-align,+v6\".to_string();\n     base.max_atomic_width = Some(64);\n-    Ok(Target {\n+    Target {\n         // It's important we use \"gnueabi\" and not \"musleabi\" here. LLVM uses it\n         // to determine the calling convention and float ABI, and it doesn't\n         // support the \"musleabi\" value.\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "b631a0010a0ea3e5f0ae78da8d218b4089b87a8f", "filename": "compiler/rustc_target/src/spec/arm_unknown_linux_musleabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm_unknown_linux_musleabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,19 +1,19 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n \n     // Most of these settings are copied from the arm_unknown_linux_gnueabihf\n     // target.\n     base.features = \"+strict-align,+v6,+vfp2,-d32\".to_string();\n     base.max_atomic_width = Some(64);\n-    Ok(Target {\n+    Target {\n         // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM\n         // uses it to determine the calling convention and float ABI, and it\n         // doesn't support the \"musleabihf\" value.\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "86d0cd57af398274065cd0f448af996689018ae4", "filename": "compiler/rustc_target/src/spec/armebv7r_none_eabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n // Targets the Big endian Cortex-R4/R5 processor (ARMv7-R)\n \n use crate::spec::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel};\n-use crate::spec::{Target, TargetOptions, TargetResult};\n+use crate::spec::{Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"armebv7r-unknown-none-eabi\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> TargetResult {\n             emit_debug_gdb_scripts: false,\n             ..Default::default()\n         },\n-    })\n+    }\n }"}, {"sha": "9ea44b3b25e3d866a97a333a9a4995882810cb6a", "filename": "compiler/rustc_target/src/spec/armebv7r_none_eabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmebv7r_none_eabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n // Targets the Cortex-R4F/R5F processor (ARMv7-R)\n \n use crate::spec::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel};\n-use crate::spec::{Target, TargetOptions, TargetResult};\n+use crate::spec::{Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"armebv7r-unknown-none-eabihf\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -27,5 +27,5 @@ pub fn target() -> TargetResult {\n             emit_debug_gdb_scripts: false,\n             ..Default::default()\n         },\n-    })\n+    }\n }"}, {"sha": "be32731a869bdcc9494beaa323f0f0dc02a8000f", "filename": "compiler/rustc_target/src/spec/armv4t_unknown_linux_gnueabi.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_unknown_linux_gnueabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::linux_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv4t-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -20,7 +20,8 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n+            has_thumb_interworking: true,\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "4ea4b650623da31059bfbe565db0d8ea2a3362c2", "filename": "compiler/rustc_target/src/spec/armv5te_unknown_linux_gnueabi.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_gnueabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::linux_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv5te-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -20,7 +20,8 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n+            has_thumb_interworking: true,\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "a41a5409ac92ba5949687a2495b6686a639035d2", "filename": "compiler/rustc_target/src/spec/armv5te_unknown_linux_musleabi.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv5te_unknown_linux_musleabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,14 +1,14 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::linux_musl_base::opts();\n-    Ok(Target {\n+    Target {\n         // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM\n         // uses it to determine the calling convention and float ABI, and LLVM\n         // doesn't support the \"musleabihf\" value.\n         llvm_target: \"armv5te-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -23,7 +23,8 @@ pub fn target() -> TargetResult {\n             max_atomic_width: Some(32),\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             target_mcount: \"\\u{1}mcount\".to_string(),\n+            has_thumb_interworking: true,\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "68f6502133a3d509885308f2e596a0cfe1e43219", "filename": "compiler/rustc_target/src/spec/armv6_unknown_freebsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6_unknown_freebsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::freebsd_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv6-unknown-freebsd-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "23a20ca1c9fdf0f4588467afc447619c71258ac2", "filename": "compiler/rustc_target/src/spec/armv6_unknown_netbsd_eabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6_unknown_netbsd_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6_unknown_netbsd_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv6_unknown_netbsd_eabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::netbsd_base::opts();\n     base.max_atomic_width = Some(64);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv6-unknown-netbsdelf-eabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"__mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "24a47dd56a9a929a71b1ea53726948cd08f8aa88", "filename": "compiler/rustc_target/src/spec/armv7_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n use super::apple_sdk_base::{opts, Arch};\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = opts(Arch::Armv7);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:o-p:32:32-Fi8-f64:32:64-v64:32:64-v128:32:128-a:0:32-n32-S32\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "342959883cb7aa1cbd7e2a3170169b4aabe93fa4", "filename": "compiler/rustc_target/src/spec/armv7_linux_androideabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_linux_androideabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,4 +1,4 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n // This target if is for the baseline of the Android v7a ABI\n // in thumb mode. It's named armv7-* instead of thumbv7-*\n@@ -8,16 +8,16 @@ use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n // See https://developer.android.com/ndk/guides/abis.html#v7a\n // for target ABI requirements.\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::android_base::opts();\n     base.features = \"+v7,+thumb-mode,+thumb2,+vfp3,-d32,-neon\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-march=armv7-a\".to_string());\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-none-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { unsupported_abis: super::arm_base::unsupported_abis(), ..base },\n-    })\n+    }\n }"}, {"sha": "d4bb4e963fbd493f2413ba6ae6d680a309266967", "filename": "compiler/rustc_target/src/spec/armv7_unknown_cloudabi_eabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_cloudabi_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_cloudabi_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_cloudabi_eabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,17 +1,17 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::cloudabi_base::opts();\n     base.cpu = \"cortex-a8\".to_string();\n     base.max_atomic_width = Some(64);\n     base.features = \"+v7,+vfp3,+neon\".to_string();\n     base.unsupported_abis = super::arm_base::unsupported_abis();\n     base.linker = Some(\"armv7-unknown-cloudabi-eabihf-cc\".to_string());\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-unknown-cloudabi-eabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"\\u{1}mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "c32e2d4376eb35c310b10e9a0062e3fd4897031d", "filename": "compiler/rustc_target/src/spec/armv7_unknown_freebsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_freebsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::freebsd_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-unknown-freebsd-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "66d3b3e5d07ba3d5a89c331ab7a7bf5fefbc0fea", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_gnueabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,14 +1,14 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n // This target is for glibc Linux on ARMv7 without thumb-mode, NEON or\n // hardfloat.\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::linux_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -25,5 +25,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "c1ef540a01d5348d42db73a3e0ccaaa23c32064e", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_gnueabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,14 +1,14 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n // This target is for glibc Linux on ARMv7 without NEON or\n // thumb-mode. See the thumbv7neon variant for enabling both.\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::linux_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}__gnu_mcount_nc\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "d4d26b1455624611b8e62b7cfc4cb9284bbf9a36", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_musleabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_musleabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,19 +1,19 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n // This target is for musl Linux on ARMv7 without thumb-mode, NEON or\n // hardfloat.\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::linux_musl_base::opts();\n     // Most of these settings are copied from the armv7_unknown_linux_gnueabi\n     // target.\n-    Ok(Target {\n+    Target {\n         // It's important we use \"gnueabi\" and not \"musleabi\" here. LLVM uses it\n         // to determine the calling convention and float ABI, and it doesn't\n         // support the \"musleabi\" value.\n         llvm_target: \"armv7-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -30,5 +30,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "88db04a74e2b3d3a9a3617bd566ef75abda274ea", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_musleabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_musleabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,16 +1,16 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n // This target is for musl Linux on ARMv7 without thumb-mode or NEON.\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::linux_musl_base::opts();\n-    Ok(Target {\n+    Target {\n         // It's important we use \"gnueabihf\" and not \"musleabihf\" here. LLVM\n         // uses it to determine the calling convention and float ABI, and LLVM\n         // doesn't support the \"musleabihf\" value.\n         llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -29,5 +29,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"\\u{1}mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "fe2471ab0d0a0152848b8543a38ada2953d3b15a", "filename": "compiler/rustc_target/src/spec/armv7_unknown_netbsd_eabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_netbsd_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_netbsd_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_netbsd_eabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::netbsd_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-unknown-netbsdelf-eabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -22,5 +22,5 @@ pub fn target() -> TargetResult {\n             target_mcount: \"__mcount\".to_string(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "9b8cefdfa9e81ed2ad59befdf0e3661a23e3489e", "filename": "compiler/rustc_target/src/spec/armv7_wrs_vxworks_eabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_wrs_vxworks_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_wrs_vxworks_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_wrs_vxworks_eabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,11 +1,11 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = super::vxworks_base::opts();\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "4199ac4569a7e81569cedc299e5a9ff7258b5bb9", "filename": "compiler/rustc_target/src/spec/armv7a_none_eabi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -19,7 +19,7 @@\n \n use super::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel, Target, TargetOptions};\n \n-pub fn target() -> Result<Target, String> {\n+pub fn target() -> Target {\n     let opts = TargetOptions {\n         linker: Some(\"rust-lld\".to_owned()),\n         features: \"+v7,+thumb2,+soft-float,-neon,+strict-align\".to_string(),\n@@ -32,10 +32,10 @@ pub fn target() -> Result<Target, String> {\n         emit_debug_gdb_scripts: false,\n         ..Default::default()\n     };\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7a-none-eabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         target_os: \"none\".to_string(),\n         target_env: String::new(),\n@@ -44,5 +44,5 @@ pub fn target() -> Result<Target, String> {\n         arch: \"arm\".to_string(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: opts,\n-    })\n+    }\n }"}, {"sha": "99a065900973f67f7e9fc2444e7361cf02f3bf93", "filename": "compiler/rustc_target/src/spec/armv7a_none_eabihf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7a_none_eabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -7,7 +7,7 @@\n \n use super::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel, Target, TargetOptions};\n \n-pub fn target() -> Result<Target, String> {\n+pub fn target() -> Target {\n     let opts = TargetOptions {\n         linker: Some(\"rust-lld\".to_owned()),\n         features: \"+v7,+vfp3,-d32,+thumb2,-neon,+strict-align\".to_string(),\n@@ -20,10 +20,10 @@ pub fn target() -> Result<Target, String> {\n         emit_debug_gdb_scripts: false,\n         ..Default::default()\n     };\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7a-none-eabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         target_os: \"none\".to_string(),\n         target_env: String::new(),\n@@ -32,5 +32,5 @@ pub fn target() -> Result<Target, String> {\n         arch: \"arm\".to_string(),\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n         options: opts,\n-    })\n+    }\n }"}, {"sha": "f0e79072bc180597e72ccb0f1ca32d9a8814e334", "filename": "compiler/rustc_target/src/spec/armv7r_none_eabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n // Targets the Little-endian Cortex-R4/R5 processor (ARMv7-R)\n \n use crate::spec::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel};\n-use crate::spec::{Target, TargetOptions, TargetResult};\n+use crate::spec::{Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"armv7r-unknown-none-eabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -26,5 +26,5 @@ pub fn target() -> TargetResult {\n             emit_debug_gdb_scripts: false,\n             ..Default::default()\n         },\n-    })\n+    }\n }"}, {"sha": "4c464d2b256a59ab38fda04844976c2b60a399b3", "filename": "compiler/rustc_target/src/spec/armv7r_none_eabihf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7r_none_eabihf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,13 +1,13 @@\n // Targets the Little-endian Cortex-R4F/R5F processor (ARMv7-R)\n \n use crate::spec::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel};\n-use crate::spec::{Target, TargetOptions, TargetResult};\n+use crate::spec::{Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"armv7r-unknown-none-eabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -27,5 +27,5 @@ pub fn target() -> TargetResult {\n             emit_debug_gdb_scripts: false,\n             ..Default::default()\n         },\n-    })\n+    }\n }"}, {"sha": "4c2d70ae34be2f015375e8bd50b272e913b72376", "filename": "compiler/rustc_target/src/spec/armv7s_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n use super::apple_sdk_base::{opts, Arch};\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = opts(Arch::Armv7s);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"armv7s-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:o-p:32:32-Fi8-f64:32:64-v64:32:64-v128:32:128-a:0:32-n32-S32\".to_string(),\n         arch: \"arm\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n             unsupported_abis: super::arm_base::unsupported_abis(),\n             ..base\n         },\n-    })\n+    }\n }"}, {"sha": "1c3f5c4f9e8fd170cd83a6717db6779fa46a1199", "filename": "compiler/rustc_target/src/spec/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fasmjs_unknown_emscripten.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n use super::{wasm32_unknown_emscripten, LinkerFlavor, Target};\n \n-pub fn target() -> Result<Target, String> {\n-    let mut target = wasm32_unknown_emscripten::target()?;\n+pub fn target() -> Target {\n+    let mut target = wasm32_unknown_emscripten::target();\n     target\n         .options\n         .post_link_args\n         .entry(LinkerFlavor::Em)\n         .or_default()\n         .extend(vec![\"-s\".to_string(), \"WASM=0\".to_string()]);\n-    Ok(target)\n+    target\n }"}, {"sha": "01445dc3898a3fdec34c67437d4e5110904b9b8d", "filename": "compiler/rustc_target/src/spec/avr_gnu_base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Favr_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Favr_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Favr_gnu_base.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n /// A base target for AVR devices using the GNU toolchain.\n ///\n /// Requires GNU avr-gcc and avr-binutils on the host system.\n-pub fn target(target_cpu: String) -> TargetResult {\n-    Ok(Target {\n+pub fn target(target_cpu: String) -> Target {\n+    Target {\n         arch: \"avr\".to_string(),\n         data_layout: \"e-P1-p:16:8-i8:8-i16:8-i32:8-i64:8-f32:8-f64:8-n8-a:8\".to_string(),\n         llvm_target: \"avr-unknown-unknown\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"16\".to_string(),\n+        pointer_width: 16,\n         linker_flavor: LinkerFlavor::Gcc,\n         target_os: \"unknown\".to_string(),\n         target_env: \"\".to_string(),\n@@ -49,5 +49,5 @@ pub fn target(target_cpu: String) -> TargetResult {\n             atomic_cas: false,\n             ..TargetOptions::default()\n         },\n-    })\n+    }\n }"}, {"sha": "7e63ae9c5aa263f429364096dda699ac720449c5", "filename": "compiler/rustc_target/src/spec/avr_unknown_gnu_atmega328.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Favr_unknown_gnu_atmega328.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Favr_unknown_gnu_atmega328.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Favr_unknown_gnu_atmega328.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,5 +1,5 @@\n-use crate::spec::TargetResult;\n+use crate::spec::Target;\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     super::avr_gnu_base::target(\"atmega328\".to_owned())\n }"}, {"sha": "82dc5f5465921e981b41d7e717928ada25078584", "filename": "compiler/rustc_target/src/spec/dragonfly_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fdragonfly_base.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -24,6 +24,7 @@ pub fn opts() -> TargetOptions {\n         pre_link_args: args,\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "051325a8df6878f2e1972ed53063c05db9618f46", "filename": "compiler/rustc_target/src/spec/freebsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ffreebsd_base.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -26,6 +26,7 @@ pub fn opts() -> TargetOptions {\n         eliminate_frame_pointer: false, // FIXME 43575\n         relro_level: RelroLevel::Full,\n         abi_return_struct_as_int: true,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "143b93dfeef5916296813c654c45179a6e188975", "filename": "compiler/rustc_target/src/spec/hexagon_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fhexagon_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fhexagon_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fhexagon_unknown_linux_musl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkArgs, LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"hexagonv60\".to_string();\n     base.max_atomic_width = Some(32);\n@@ -17,10 +17,10 @@ pub fn target() -> TargetResult {\n     base.pre_link_args = LinkArgs::new();\n     base.post_link_args = LinkArgs::new();\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"hexagon-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: concat!(\n             \"e-m:e-p:32:32:32-a:0-n16:32-i64:64:64-i32:32\",\n@@ -35,5 +35,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "214214979655af9d8d3a97fd53dbf43fe653c78e", "filename": "compiler/rustc_target/src/spec/i386_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,12 +1,12 @@\n use super::apple_sdk_base::{opts, Arch};\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let base = opts(Arch::I386);\n-    Ok(Target {\n+    Target {\n         llvm_target: \"i386-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:o-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:128-n8:16:32-S128\"\n@@ -17,5 +17,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"apple\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { max_atomic_width: Some(64), stack_probes: true, ..base },\n-    })\n+    }\n }"}, {"sha": "664b9d5d515891bac88d4f476fc0bc5dd6c3ed20", "filename": "compiler/rustc_target/src/spec/i586_pc_windows_msvc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_pc_windows_msvc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,8 +1,8 @@\n-use crate::spec::TargetResult;\n+use crate::spec::Target;\n \n-pub fn target() -> TargetResult {\n-    let mut base = super::i686_pc_windows_msvc::target()?;\n+pub fn target() -> Target {\n+    let mut base = super::i686_pc_windows_msvc::target();\n     base.options.cpu = \"pentium\".to_string();\n     base.llvm_target = \"i586-pc-windows-msvc\".to_string();\n-    Ok(base)\n+    base\n }"}, {"sha": "3276f1d0094f8286fa15f2f79d7b6e2d85562a35", "filename": "compiler/rustc_target/src/spec/i586_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,8 +1,8 @@\n-use crate::spec::TargetResult;\n+use crate::spec::Target;\n \n-pub fn target() -> TargetResult {\n-    let mut base = super::i686_unknown_linux_gnu::target()?;\n+pub fn target() -> Target {\n+    let mut base = super::i686_unknown_linux_gnu::target();\n     base.options.cpu = \"pentium\".to_string();\n     base.llvm_target = \"i586-unknown-linux-gnu\".to_string();\n-    Ok(base)\n+    base\n }"}, {"sha": "5fbf048722691c89d5cd950f474307119412a4c4", "filename": "compiler/rustc_target/src/spec/i586_unknown_linux_musl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi586_unknown_linux_musl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,8 +1,8 @@\n-use crate::spec::TargetResult;\n+use crate::spec::Target;\n \n-pub fn target() -> TargetResult {\n-    let mut base = super::i686_unknown_linux_musl::target()?;\n+pub fn target() -> Target {\n+    let mut base = super::i686_unknown_linux_musl::target();\n     base.options.cpu = \"pentium\".to_string();\n     base.llvm_target = \"i586-unknown-linux-musl\".to_string();\n-    Ok(base)\n+    base\n }"}, {"sha": "9c7e7241b57d7323909daa42fce2240e8a791bf8", "filename": "compiler/rustc_target/src/spec/i686_apple_darwin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::apple_base::opts();\n     base.cpu = \"yonah\".to_string();\n     base.max_atomic_width = Some(64);\n@@ -15,10 +15,10 @@ pub fn target() -> TargetResult {\n     let arch = \"i686\";\n     let llvm_target = super::apple_base::macos_llvm_target(&arch);\n \n-    Ok(Target {\n+    Target {\n         llvm_target,\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:o-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:128-n8:16:32-S128\"\n@@ -29,5 +29,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"apple\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"\\u{1}mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "d116ae62e0fca756c261c682654f872552082994", "filename": "compiler/rustc_target/src/spec/i686_linux_android.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_linux_android.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,9 +1,9 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n // See https://developer.android.com/ndk/guides/abis.html#x86\n // for target ABI requirements.\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::android_base::opts();\n \n     base.max_atomic_width = Some(64);\n@@ -13,10 +13,10 @@ pub fn target() -> TargetResult {\n     base.features = \"+mmx,+sse,+sse2,+sse3,+ssse3\".to_string();\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -27,5 +27,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "84585bd515a2dfc26c214a1739ce55f2ea493d1b", "filename": "compiler/rustc_target/src/spec/i686_pc_windows_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, LldFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::windows_gnu_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.pre_link_args\n@@ -16,10 +16,10 @@ pub fn target() -> TargetResult {\n         .unwrap()\n         .push(\"-Wl,--large-address-aware\".to_string());\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:x-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             i64:64-f80:32-n8:16:32-a:0:32-S32\"\n@@ -30,5 +30,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"pc\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "db20b6094b700f9c515b70eece37c64d7e586759", "filename": "compiler/rustc_target/src/spec/i686_pc_windows_msvc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_pc_windows_msvc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, LldFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::windows_msvc_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n@@ -20,10 +20,10 @@ pub fn target() -> TargetResult {\n         .unwrap()\n         .extend(pre_link_args_msvc);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:x-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             i64:64-f80:32-n8:16:32-a:0:32-S32\"\n@@ -34,5 +34,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"pc\".to_string(),\n         linker_flavor: LinkerFlavor::Msvc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "d9365d59e0e4fdc3d336a55d644cdf99bcd5a7d2", "filename": "compiler/rustc_target/src/spec/i686_unknown_cloudabi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_cloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_cloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_cloudabi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,17 +1,17 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::cloudabi_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.linker = Some(\"i686-unknown-cloudabi-cc\".to_string());\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-cloudabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -22,5 +22,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "ba379a40f5046e7d526b137356b764d3d12ffb7c", "filename": "compiler/rustc_target/src/spec/i686_unknown_freebsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_freebsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::freebsd_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n@@ -9,10 +9,10 @@ pub fn target() -> TargetResult {\n     pre_link_args.push(\"-Wl,-znotext\".to_string());\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -23,5 +23,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "02754b39fa7a2dfd63b77b93eb266759847f00e3", "filename": "compiler/rustc_target/src/spec/i686_unknown_haiku.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_haiku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_haiku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_haiku.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,16 +1,16 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::haiku_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.insert(LinkerFlavor::Gcc, vec![\"-m32\".to_string()]);\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-haiku\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "b7ceaefef939ad45893fdab15de6d55f5f85121a", "filename": "compiler/rustc_target/src/spec/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,16 +1,16 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "9240b56aeaf5801a48fb32bf87fb880ce67272cc", "filename": "compiler/rustc_target/src/spec/i686_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_linux_musl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n@@ -22,10 +22,10 @@ pub fn target() -> TargetResult {\n     // https://llvm.org/bugs/show_bug.cgi?id=30879\n     base.eliminate_frame_pointer = false;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -36,5 +36,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "a4421924a7bb889650970f7d87a4040a9cede113", "filename": "compiler/rustc_target/src/spec/i686_unknown_netbsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_netbsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,16 +1,16 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::netbsd_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-netbsdelf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"__mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "fe5030f661bb61000cae537c1ed0992a76a9115e", "filename": "compiler/rustc_target/src/spec/i686_unknown_openbsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_openbsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,17 +1,17 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::openbsd_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-fuse-ld=lld\".to_string());\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-openbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -22,5 +22,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "676a8ca0acc4b0adbda57403fa28288af72b86e1", "filename": "compiler/rustc_target/src/spec/i686_unknown_uefi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_uefi.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -5,9 +5,9 @@\n // The cdecl ABI is used. It differs from the stdcall or fastcall ABI.\n // \"i686-unknown-windows\" is used to get the minimal subset of windows-specific features.\n \n-use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, LldFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::uefi_msvc_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n@@ -76,10 +76,10 @@ pub fn target() -> TargetResult {\n     // As a result, we choose -gnu for i686 version before those intrisics are implemented in\n     // compiler-builtins. After compiler-builtins implements all required intrinsics, we may\n     // remove -gnu and use the default one.\n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:x-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             i64:64-f80:32-n8:16:32-a:0:32-S32\"\n@@ -91,5 +91,5 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Lld(LldFlavor::Link),\n \n         options: base,\n-    })\n+    }\n }"}, {"sha": "ec5a9cc68ceae94fca94732f1c53a48bdf7cd0fe", "filename": "compiler/rustc_target/src/spec/i686_uwp_windows_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_uwp_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_uwp_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_uwp_windows_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, LldFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::windows_uwp_gnu_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.pre_link_args\n@@ -15,10 +15,10 @@ pub fn target() -> TargetResult {\n         .unwrap()\n         .push(\"-Wl,--large-address-aware\".to_string());\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:x-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             i64:64-f80:32-n8:16:32-a:0:32-S32\"\n@@ -29,5 +29,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"uwp\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "d960a130351860ce75286a732bedbb89cf9d7757", "filename": "compiler/rustc_target/src/spec/i686_uwp_windows_msvc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_uwp_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_uwp_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_uwp_windows_msvc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::windows_uwp_msvc_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.has_elf_tls = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:x-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             i64:64-f80:32-n8:16:32-a:0:32-S32\"\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"uwp\".to_string(),\n         linker_flavor: LinkerFlavor::Msvc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "0e5c7b6143e92382a74283b51cc6475fd9d5bf45", "filename": "compiler/rustc_target/src/spec/i686_wrs_vxworks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_wrs_vxworks.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,16 +1,16 @@\n-use crate::spec::{LinkerFlavor, Target, TargetResult};\n+use crate::spec::{LinkerFlavor, Target};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::vxworks_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m32\".to_string());\n     base.stack_probes = true;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:32-n8:16:32-S128\"\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"wrs\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: base,\n-    })\n+    }\n }"}, {"sha": "5cbd6bcd3d8bb46c640f4763a0d0d099cb2a4b18", "filename": "compiler/rustc_target/src/spec/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_gnuabi64.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mips64-unknown-linux-gnuabi64\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "3ca92dd1d04b229470f9cd17e786174d1e73b1ea", "filename": "compiler/rustc_target/src/spec/mips64_unknown_linux_muslabi64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_muslabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_muslabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64_unknown_linux_muslabi64.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"mips64r2\".to_string();\n     base.features = \"+mips64r2\".to_string();\n     base.max_atomic_width = Some(64);\n-    Ok(Target {\n+    Target {\n         // LLVM doesn't recognize \"muslabi64\" yet.\n         llvm_target: \"mips64-unknown-linux-musl\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"_mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "4761be5b7ef8a93e6095d7ab138922c8fc20e1c2", "filename": "compiler/rustc_target/src/spec/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_gnuabi64.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mips64el-unknown-linux-gnuabi64\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "d87170b6868e89a889562bdc93ffa91cb2a44ea9", "filename": "compiler/rustc_target/src/spec/mips64el_unknown_linux_muslabi64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips64el_unknown_linux_muslabi64.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"mips64r2\".to_string();\n     base.features = \"+mips64r2\".to_string();\n     base.max_atomic_width = Some(64);\n-    Ok(Target {\n+    Target {\n         // LLVM doesn't recognize \"muslabi64\" yet.\n         llvm_target: \"mips64el-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"_mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "e51cf3c59f6ebcec36b5033621413ad3d846694a", "filename": "compiler/rustc_target/src/spec/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mips-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "44d136ee7e90efb79727b8fee7bdeae6296f4daf", "filename": "compiler/rustc_target/src/spec/mips_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_musl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"mips32r2\".to_string();\n     base.features = \"+mips32r2,+soft-float\".to_string();\n     base.max_atomic_width = Some(32);\n     base.crt_static_default = false;\n-    Ok(Target {\n+    Target {\n         llvm_target: \"mips-unknown-linux-musl\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"_mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "7e168836dc7fe5e29315538d61046f3256ce6ea9", "filename": "compiler/rustc_target/src/spec/mips_unknown_linux_uclibc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmips_unknown_linux_uclibc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mips-unknown-linux-uclibc\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "9897b0093fc689ab4d869cc5e6bf4087c3e437e9", "filename": "compiler/rustc_target/src/spec/mipsel_sony_psp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_sony_psp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_sony_psp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_sony_psp.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,17 +1,17 @@\n use crate::spec::{LinkArgs, LinkerFlavor, LldFlavor, RelocModel};\n-use crate::spec::{Target, TargetOptions, TargetResult};\n+use crate::spec::{Target, TargetOptions};\n \n // The PSP has custom linker requirements.\n const LINKER_SCRIPT: &str = include_str!(\"./mipsel_sony_psp_linker_script.ld\");\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut pre_link_args = LinkArgs::new();\n     pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Ld), vec![\"--emit-relocs\".to_string()]);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"mipsel-sony-psp\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -36,5 +36,5 @@ pub fn target() -> TargetResult {\n             link_script: Some(LINKER_SCRIPT.to_string()),\n             ..Default::default()\n         },\n-    })\n+    }\n }"}, {"sha": "509f3e04ba7cce5a525021137b54b97ba0c95763", "filename": "compiler/rustc_target/src/spec/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mipsel-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "0d3691dd5b99f6b34d0e6cc6e8d4a5845fa5f44e", "filename": "compiler/rustc_target/src/spec/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_musl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"mips32r2\".to_string();\n     base.features = \"+mips32r2,+soft-float\".to_string();\n     base.max_atomic_width = Some(32);\n     base.crt_static_default = false;\n-    Ok(Target {\n+    Target {\n         llvm_target: \"mipsel-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"_mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "6d50d9ba81e59588785513e01f24683475db187c", "filename": "compiler/rustc_target/src/spec/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsel_unknown_linux_uclibc.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mipsel-unknown-linux-uclibc\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "d6e71d2922f2f0308fb86acbfbcc1cd856bdb838", "filename": "compiler/rustc_target/src/spec/mipsisa32r6_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mipsisa32r6-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -20,5 +20,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "67e97fd2f0feec0ceb1e1fbe32c6567dcc9cbcee", "filename": "compiler/rustc_target/src/spec/mipsisa32r6el_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa32r6el_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mipsisa32r6el-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"32\".to_string(),\n+        pointer_width: 32,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "c3a7ae8b11ff78243934b15fa27a951e316759a9", "filename": "compiler/rustc_target/src/spec/mipsisa64r6_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6_unknown_linux_gnuabi64.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mipsisa64r6-unknown-linux-gnuabi64\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "467e05a00d473f12b995852c2eb7b22d1046fd43", "filename": "compiler/rustc_target/src/spec/mipsisa64r6el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmipsisa64r6el_unknown_linux_gnuabi64.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"mipsisa64r6el-unknown-linux-gnuabi64\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n@@ -21,5 +21,5 @@ pub fn target() -> TargetResult {\n \n             ..super::linux_base::opts()\n         },\n-    })\n+    }\n }"}, {"sha": "1d3e61c49920845d57b309bf9d5d57921135d64f", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -430,48 +430,23 @@ impl fmt::Display for LinkOutputKind {\n     }\n }\n \n-pub enum LoadTargetError {\n-    BuiltinTargetNotFound(String),\n-    Other(String),\n-}\n-\n pub type LinkArgs = BTreeMap<LinkerFlavor, Vec<String>>;\n-pub type TargetResult = Result<Target, String>;\n \n macro_rules! supported_targets {\n     ( $(($( $triple:literal, )+ $module:ident ),)+ ) => {\n         $(mod $module;)+\n \n         /// List of supported targets\n-        const TARGETS: &[&str] = &[$($($triple),+),+];\n-\n-        fn load_specific(target: &str) -> Result<Target, LoadTargetError> {\n-            match target {\n-                $(\n-                    $($triple)|+ => {\n-                        let mut t = $module::target()\n-                            .map_err(LoadTargetError::Other)?;\n-                        t.options.is_builtin = true;\n-\n-                        // round-trip through the JSON parser to ensure at\n-                        // run-time that the parser works correctly\n-                        t = Target::from_json(t.to_json())\n-                            .map_err(LoadTargetError::Other)?;\n-                        debug!(\"got builtin target: {:?}\", t);\n-                        Ok(t)\n-                    },\n-                )+\n-                    _ => Err(LoadTargetError::BuiltinTargetNotFound(\n-                        format!(\"Unable to find target: {}\", target)))\n-            }\n-        }\n-\n-        pub fn get_targets() -> impl Iterator<Item = String> {\n-            TARGETS.iter().filter_map(|t| -> Option<String> {\n-                load_specific(t)\n-                    .and(Ok(t.to_string()))\n-                    .ok()\n-            })\n+        pub const TARGETS: &[&str] = &[$($($triple),+),+];\n+\n+        fn load_builtin(target: &str) -> Option<Target> {\n+            let mut t = match target {\n+                $( $($triple)|+ => $module::target(), )+\n+                _ => return None,\n+            };\n+            t.options.is_builtin = true;\n+            debug!(\"got builtin target: {:?}\", t);\n+            Some(t)\n         }\n \n         #[cfg(test)]\n@@ -690,8 +665,8 @@ pub struct Target {\n     pub llvm_target: String,\n     /// String to use as the `target_endian` `cfg` variable.\n     pub target_endian: String,\n-    /// String to use as the `target_pointer_width` `cfg` variable.\n-    pub target_pointer_width: String,\n+    /// Number of bits in a pointer. Influences the `target_pointer_width` `cfg` variable.\n+    pub pointer_width: u32,\n     /// Width of c_int type\n     pub target_c_int_width: String,\n     /// OS name to use for conditional compilation.\n@@ -841,6 +816,9 @@ pub struct TargetOptions {\n     pub is_like_emscripten: bool,\n     /// Whether the target toolchain is like Fuchsia's.\n     pub is_like_fuchsia: bool,\n+    /// Version of DWARF to use if not using the default.\n+    /// Useful because some platforms (osx, bsd) only want up to DWARF2.\n+    pub dwarf_version: Option<u32>,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n     /// The MinGW toolchain has a known issue that prevents it from correctly\n@@ -994,6 +972,10 @@ pub struct TargetOptions {\n     /// used to locate unwinding information is passed\n     /// (only has effect if the linker is `ld`-like).\n     pub eh_frame_header: bool,\n+\n+    /// Is true if the target is an ARM architecture using thumb v1 which allows for\n+    /// thumb and arm interworking.\n+    pub has_thumb_interworking: bool,\n }\n \n impl Default for TargetOptions {\n@@ -1033,6 +1015,7 @@ impl Default for TargetOptions {\n             is_like_emscripten: false,\n             is_like_msvc: false,\n             is_like_fuchsia: false,\n+            dwarf_version: None,\n             linker_is_gnu: false,\n             allows_weak_linkage: true,\n             has_rpath: false,\n@@ -1086,6 +1069,7 @@ impl Default for TargetOptions {\n             llvm_args: vec![],\n             use_ctors_section: false,\n             eh_frame_header: true,\n+            has_thumb_interworking: false,\n         }\n     }\n }\n@@ -1127,15 +1111,15 @@ impl Target {\n     /// Maximum integer size in bits that this target can perform atomic\n     /// operations on.\n     pub fn max_atomic_width(&self) -> u64 {\n-        self.options.max_atomic_width.unwrap_or_else(|| self.target_pointer_width.parse().unwrap())\n+        self.options.max_atomic_width.unwrap_or_else(|| self.pointer_width.into())\n     }\n \n     pub fn is_abi_supported(&self, abi: Abi) -> bool {\n         abi.generic() || !self.options.unsupported_abis.contains(&abi)\n     }\n \n     /// Loads a target descriptor from a JSON object.\n-    pub fn from_json(obj: Json) -> TargetResult {\n+    pub fn from_json(obj: Json) -> Result<Target, String> {\n         // While ugly, this code must remain this way to retain\n         // compatibility with existing JSON fields and the internal\n         // expected naming of the Target and TargetOptions structs.\n@@ -1160,7 +1144,9 @@ impl Target {\n         let mut base = Target {\n             llvm_target: get_req_field(\"llvm-target\")?,\n             target_endian: get_req_field(\"target-endian\")?,\n-            target_pointer_width: get_req_field(\"target-pointer-width\")?,\n+            pointer_width: get_req_field(\"target-pointer-width\")?\n+                .parse::<u32>()\n+                .map_err(|_| \"target-pointer-width must be an integer\".to_string())?,\n             target_c_int_width: get_req_field(\"target-c-int-width\")?,\n             data_layout: get_req_field(\"data-layout\")?,\n             arch: get_req_field(\"arch\")?,\n@@ -1185,6 +1171,15 @@ impl Target {\n                     base.options.$key_name = s;\n                 }\n             } );\n+            ($key_name:ident, Option<u32>) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                if let Some(s) = obj.find(&name).and_then(Json::as_u64) {\n+                    if s < 1 || s > 5 {\n+                        return Err(\"Not a valid DWARF version number\".to_string());\n+                    }\n+                    base.options.$key_name = Some(s as u32);\n+                }\n+            } );\n             ($key_name:ident, Option<u64>) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 if let Some(s) = obj.find(&name).and_then(Json::as_u64) {\n@@ -1437,6 +1432,7 @@ impl Target {\n         key!(is_like_emscripten, bool);\n         key!(is_like_android, bool);\n         key!(is_like_fuchsia, bool);\n+        key!(dwarf_version, Option<u32>);\n         key!(linker_is_gnu, bool);\n         key!(allows_weak_linkage, bool);\n         key!(has_rpath, bool);\n@@ -1479,6 +1475,7 @@ impl Target {\n         key!(llvm_args, list);\n         key!(use_ctors_section, bool);\n         key!(eh_frame_header, bool);\n+        key!(has_thumb_interworking, bool);\n \n         // NB: The old name is deprecated, but support for it is retained for\n         // compatibility.\n@@ -1531,11 +1528,9 @@ impl Target {\n \n         match *target_triple {\n             TargetTriple::TargetTriple(ref target_triple) => {\n-                // check if triple is in list of supported targets\n-                match load_specific(target_triple) {\n-                    Ok(t) => return Ok(t),\n-                    Err(LoadTargetError::BuiltinTargetNotFound(_)) => (),\n-                    Err(LoadTargetError::Other(e)) => return Err(e),\n+                // check if triple is in list of built-in targets\n+                if let Some(t) = load_builtin(target_triple) {\n+                    return Ok(t);\n                 }\n \n                 // search for a file named `target_triple`.json in RUST_TARGET_PATH\n@@ -1624,7 +1619,7 @@ impl ToJson for Target {\n \n         target_val!(llvm_target);\n         target_val!(target_endian);\n-        target_val!(target_pointer_width);\n+        d.insert(\"target-pointer-width\".to_string(), self.pointer_width.to_string().to_json());\n         target_val!(target_c_int_width);\n         target_val!(arch);\n         target_val!(target_os, \"os\");\n@@ -1675,6 +1670,7 @@ impl ToJson for Target {\n         target_option_val!(is_like_emscripten);\n         target_option_val!(is_like_android);\n         target_option_val!(is_like_fuchsia);\n+        target_option_val!(dwarf_version);\n         target_option_val!(linker_is_gnu);\n         target_option_val!(allows_weak_linkage);\n         target_option_val!(has_rpath);\n@@ -1717,6 +1713,7 @@ impl ToJson for Target {\n         target_option_val!(llvm_args);\n         target_option_val!(use_ctors_section);\n         target_option_val!(eh_frame_header);\n+        target_option_val!(has_thumb_interworking);\n \n         if default.unsupported_abis != self.options.unsupported_abis {\n             d.insert("}, {"sha": "5bb8109ce265f62af91094792116786cfe01f12a", "filename": "compiler/rustc_target/src/spec/msp430_none_elf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsp430_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsp430_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsp430_none_elf.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,10 @@\n-use crate::spec::{LinkerFlavor, PanicStrategy, RelocModel, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, PanicStrategy, RelocModel, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         llvm_target: \"msp430-none-elf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"16\".to_string(),\n+        pointer_width: 16,\n         target_c_int_width: \"16\".to_string(),\n         data_layout: \"e-m:e-p:16:16-i32:16-i64:16-f32:16-f64:16-a:8-n8:16-S16\".to_string(),\n         arch: \"msp430\".to_string(),\n@@ -60,5 +60,5 @@ pub fn target() -> TargetResult {\n \n             ..Default::default()\n         },\n-    })\n+    }\n }"}, {"sha": "d7baf81fce36caa6265a356540d98de7189722b0", "filename": "compiler/rustc_target/src/spec/netbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnetbsd_base.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -24,6 +24,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         relro_level: RelroLevel::Full,\n         use_ctors_section: true,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "86360c181d1f8d8339a23154e7545d357642c478", "filename": "compiler/rustc_target/src/spec/nvptx64_nvidia_cuda.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnvptx64_nvidia_cuda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnvptx64_nvidia_cuda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnvptx64_nvidia_cuda.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,10 +1,8 @@\n use crate::spec::abi::Abi;\n-use crate::spec::{\n-    LinkerFlavor, MergeFunctions, PanicStrategy, Target, TargetOptions, TargetResult,\n-};\n+use crate::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n-    Ok(Target {\n+pub fn target() -> Target {\n+    Target {\n         arch: \"nvptx64\".to_string(),\n         data_layout: \"e-i64:64-i128:128-v16:16-v32:32-n16:32:64\".to_string(),\n         llvm_target: \"nvptx64-nvidia-cuda\".to_string(),\n@@ -16,7 +14,7 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::PtxLinker,\n \n         target_endian: \"little\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n \n         options: TargetOptions {\n@@ -71,5 +69,5 @@ pub fn target() -> TargetResult {\n \n             ..Default::default()\n         },\n-    })\n+    }\n }"}, {"sha": "92a382e826b999088941156c3202b8a6659d7a07", "filename": "compiler/rustc_target/src/spec/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fopenbsd_base.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -26,6 +26,7 @@ pub fn opts() -> TargetOptions {\n         position_independent_executables: true,\n         eliminate_frame_pointer: false, // FIXME 43575\n         relro_level: RelroLevel::Full,\n+        dwarf_version: Some(2),\n         ..Default::default()\n     }\n }"}, {"sha": "563ff96a4031770da8feea76d8198740d30292ed", "filename": "compiler/rustc_target/src/spec/powerpc64_unknown_freebsd.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_freebsd.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::freebsd_base::opts();\n     base.cpu = \"ppc64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"powerpc64-unknown-freebsd\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n         arch: \"powerpc64\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"_mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "7d37670e5b052167383894a063a972ab4bb49daa", "filename": "compiler/rustc_target/src/spec/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_gnu.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,6 +1,6 @@\n-use crate::spec::{LinkerFlavor, RelroLevel, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, RelroLevel, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n     base.cpu = \"ppc64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n@@ -10,10 +10,10 @@ pub fn target() -> TargetResult {\n     // for now. https://github.com/rust-lang/rust/pull/43170#issuecomment-315411474\n     base.relro_level = RelroLevel::Partial;\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n         arch: \"powerpc64\".to_string(),\n@@ -22,5 +22,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"_mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "e108d75f337612cbdf4de54a6c8b980d0a237050", "filename": "compiler/rustc_target/src/spec/powerpc64_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_linux_musl.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.cpu = \"ppc64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"powerpc64-unknown-linux-musl\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n         arch: \"powerpc64\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"unknown\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { target_mcount: \"_mcount\".to_string(), ..base },\n-    })\n+    }\n }"}, {"sha": "9784c637c7e475eb3bc75b3de3d4744c2ea98159", "filename": "compiler/rustc_target/src/spec/powerpc64_wrs_vxworks.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_wrs_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/955b37b3059a7e06842559af54e1685e33b0cf6c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_wrs_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_wrs_vxworks.rs?ref=955b37b3059a7e06842559af54e1685e33b0cf6c", "patch": "@@ -1,15 +1,15 @@\n-use crate::spec::{LinkerFlavor, Target, TargetOptions, TargetResult};\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n \n-pub fn target() -> TargetResult {\n+pub fn target() -> Target {\n     let mut base = super::vxworks_base::opts();\n     base.cpu = \"ppc64\".to_string();\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.max_atomic_width = Some(64);\n \n-    Ok(Target {\n+    Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_pointer_width: \"64\".to_string(),\n+        pointer_width: 64,\n         target_c_int_width: \"32\".to_string(),\n         data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n         arch: \"powerpc64\".to_string(),\n@@ -18,5 +18,5 @@ pub fn target() -> TargetResult {\n         target_vendor: \"wrs\".to_string(),\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions { ..base },\n-    })\n+    }\n }"}]}