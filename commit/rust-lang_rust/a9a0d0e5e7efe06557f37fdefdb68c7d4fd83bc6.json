{"sha": "a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6", "node_id": "C_kwDOAAsO6NoAKGE5YTBkMGU1ZTdlZmUwNjU1N2YzN2ZkZWZkYjY4YzdkNGZkODNiYzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-16T23:30:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-16T23:30:19Z"}, "message": "Auto merge of #2028 - RalfJung:simd-round, r=RalfJung\n\nimplement SIMD float rounding functions\n\nCc https://github.com/rust-lang/miri/issues/1912", "tree": {"sha": "3025eeca4d13c5d04a6a9057bd8149e6371fd1ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3025eeca4d13c5d04a6a9057bd8149e6371fd1ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6", "html_url": "https://github.com/rust-lang/rust/commit/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c72db3d36e3945ad508de7ea5156969ce1ab6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/39c72db3d36e3945ad508de7ea5156969ce1ab6d", "html_url": "https://github.com/rust-lang/rust/commit/39c72db3d36e3945ad508de7ea5156969ce1ab6d"}, {"sha": "1f237b3b7dc905b7095d540ee91a3a23617a5792", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f237b3b7dc905b7095d540ee91a3a23617a5792", "html_url": "https://github.com/rust-lang/rust/commit/1f237b3b7dc905b7095d540ee91a3a23617a5792"}], "stats": {"total": 131, "additions": 121, "deletions": 10}, "files": [{"sha": "9b6df483b92a8c7518b8937492cf129a341950f4", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6", "patch": "@@ -90,9 +90,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Floating-point operations\n+            \"fabsf32\" => {\n+                let &[ref f] = check_arg_count(args)?;\n+                let f = this.read_scalar(f)?.to_f32()?;\n+                // Can be implemented in soft-floats.\n+                this.write_scalar(Scalar::from_f32(f.abs()), dest)?;\n+            }\n+            \"fabsf64\" => {\n+                let &[ref f] = check_arg_count(args)?;\n+                let f = this.read_scalar(f)?.to_f64()?;\n+                // Can be implemented in soft-floats.\n+                this.write_scalar(Scalar::from_f64(f.abs()), dest)?;\n+            }\n             #[rustfmt::skip]\n             | \"sinf32\"\n-            | \"fabsf32\"\n             | \"cosf32\"\n             | \"sqrtf32\"\n             | \"expf32\"\n@@ -110,7 +121,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n-                    \"fabsf32\" => f.abs(),\n                     \"cosf32\" => f.cos(),\n                     \"sqrtf32\" => f.sqrt(),\n                     \"expf32\" => f.exp(),\n@@ -129,7 +139,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             #[rustfmt::skip]\n             | \"sinf64\"\n-            | \"fabsf64\"\n             | \"cosf64\"\n             | \"sqrtf64\"\n             | \"expf64\"\n@@ -147,7 +156,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n-                    \"fabsf64\" => f.abs(),\n                     \"cosf64\" => f.cos(),\n                     \"sqrtf64\" => f.sqrt(),\n                     \"expf64\" => f.exp(),\n@@ -317,20 +325,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // SIMD operations\n             #[rustfmt::skip]\n             | \"simd_neg\"\n-            | \"simd_fabs\" => {\n+            | \"simd_fabs\"\n+            | \"simd_ceil\"\n+            | \"simd_floor\"\n+            | \"simd_round\"\n+            | \"simd_trunc\" => {\n                 let &[ref op] = check_arg_count(args)?;\n                 let (op, op_len) = this.operand_to_simd(op)?;\n                 let (dest, dest_len) = this.place_to_simd(dest)?;\n \n                 assert_eq!(dest_len, op_len);\n \n+                #[derive(Copy, Clone)]\n+                enum HostFloatOp {\n+                    Ceil,\n+                    Floor,\n+                    Round,\n+                    Trunc,\n+                }\n+                #[derive(Copy, Clone)]\n                 enum Op {\n                     MirOp(mir::UnOp),\n                     Abs,\n+                    HostOp(HostFloatOp),\n                 }\n                 let which = match intrinsic_name {\n                     \"simd_neg\" => Op::MirOp(mir::UnOp::Neg),\n                     \"simd_fabs\" => Op::Abs,\n+                    \"simd_ceil\" => Op::HostOp(HostFloatOp::Ceil),\n+                    \"simd_floor\" => Op::HostOp(HostFloatOp::Floor),\n+                    \"simd_round\" => Op::HostOp(HostFloatOp::Round),\n+                    \"simd_trunc\" => Op::HostOp(HostFloatOp::Trunc),\n                     _ => unreachable!(),\n                 };\n \n@@ -342,14 +367,43 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Op::Abs => {\n                             // Works for f32 and f64.\n                             let ty::Float(float_ty) = op.layout.ty.kind() else {\n-                                bug!(\"simd_fabs operand is not a float\")\n+                                bug!(\"{} operand is not a float\", intrinsic_name)\n                             };\n                             let op = op.to_scalar()?;\n                             match float_ty {\n                                 FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n                                 FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n                             }\n                         }\n+                        Op::HostOp(host_op) => {\n+                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n+                                bug!(\"{} operand is not a float\", intrinsic_name)\n+                            };\n+                            // FIXME using host floats\n+                            match float_ty {\n+                                FloatTy::F32 => {\n+                                    let f = f32::from_bits(op.to_scalar()?.to_u32()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                    };\n+                                    Scalar::from_u32(res.to_bits())\n+                                }\n+                                FloatTy::F64 => {\n+                                    let f = f64::from_bits(op.to_scalar()?.to_u64()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                    };\n+                                    Scalar::from_u64(res.to_bits())\n+                                }\n+                            }\n+\n+                        }\n                     };\n                     this.write_scalar(val, &dest.into())?;\n                 }"}, {"sha": "a15a0a3b1e003d0a9cb85ac09b9dda60f0b1ecd1", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=a9a0d0e5e7efe06557f37fdefdb68c7d4fd83bc6", "patch": "@@ -106,19 +106,39 @@ fn simd_ops_i32() {\n     assert_eq!(a.min(b * i32x4::splat(4)), i32x4::from_array([4, 8, 10, -16]));\n \n     assert_eq!(\n-        i8x4::from_array([i8::MAX, -23, 23, i8::MIN]).saturating_add(i8x4::from_array([1, i8::MIN, i8::MAX, 28])),\n+        i8x4::from_array([i8::MAX, -23, 23, i8::MIN]).saturating_add(i8x4::from_array([\n+            1,\n+            i8::MIN,\n+            i8::MAX,\n+            28\n+        ])),\n         i8x4::from_array([i8::MAX, i8::MIN, i8::MAX, -100])\n     );\n     assert_eq!(\n-        i8x4::from_array([i8::MAX, -28, 27, 42]).saturating_sub(i8x4::from_array([1, i8::MAX, i8::MAX, -80])),\n+        i8x4::from_array([i8::MAX, -28, 27, 42]).saturating_sub(i8x4::from_array([\n+            1,\n+            i8::MAX,\n+            i8::MAX,\n+            -80\n+        ])),\n         i8x4::from_array([126, i8::MIN, -100, 122])\n     );\n     assert_eq!(\n-        u8x4::from_array([u8::MAX, 0, 23, 42]).saturating_add(u8x4::from_array([1, 1, u8::MAX, 200])),\n+        u8x4::from_array([u8::MAX, 0, 23, 42]).saturating_add(u8x4::from_array([\n+            1,\n+            1,\n+            u8::MAX,\n+            200\n+        ])),\n         u8x4::from_array([u8::MAX, 1, u8::MAX, 242])\n     );\n     assert_eq!(\n-        u8x4::from_array([u8::MAX, 0, 23, 42]).saturating_sub(u8x4::from_array([1, 1, u8::MAX, 200])),\n+        u8x4::from_array([u8::MAX, 0, 23, 42]).saturating_sub(u8x4::from_array([\n+            1,\n+            1,\n+            u8::MAX,\n+            200\n+        ])),\n         u8x4::from_array([254, 0, 0, 0])\n     );\n \n@@ -259,6 +279,42 @@ fn simd_gather_scatter() {\n     assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n }\n \n+fn simd_round() {\n+    assert_eq!(\n+        f32x4::from_array([0.9, 1.001, 2.0, -4.5]).ceil(),\n+        f32x4::from_array([1.0, 2.0, 2.0, -4.0])\n+    );\n+    assert_eq!(\n+        f32x4::from_array([0.9, 1.001, 2.0, -4.5]).floor(),\n+        f32x4::from_array([0.0, 1.0, 2.0, -5.0])\n+    );\n+    assert_eq!(\n+        f32x4::from_array([0.9, 1.001, 2.0, -4.5]).round(),\n+        f32x4::from_array([1.0, 1.0, 2.0, -5.0])\n+    );\n+    assert_eq!(\n+        f32x4::from_array([0.9, 1.001, 2.0, -4.5]).trunc(),\n+        f32x4::from_array([0.0, 1.0, 2.0, -4.0])\n+    );\n+\n+    assert_eq!(\n+        f64x4::from_array([0.9, 1.001, 2.0, -4.5]).ceil(),\n+        f64x4::from_array([1.0, 2.0, 2.0, -4.0])\n+    );\n+    assert_eq!(\n+        f64x4::from_array([0.9, 1.001, 2.0, -4.5]).floor(),\n+        f64x4::from_array([0.0, 1.0, 2.0, -5.0])\n+    );\n+    assert_eq!(\n+        f64x4::from_array([0.9, 1.001, 2.0, -4.5]).round(),\n+        f64x4::from_array([1.0, 1.0, 2.0, -5.0])\n+    );\n+    assert_eq!(\n+        f64x4::from_array([0.9, 1.001, 2.0, -4.5]).trunc(),\n+        f64x4::from_array([0.0, 1.0, 2.0, -4.0])\n+    );\n+}\n+\n fn simd_intrinsics() {\n     extern \"platform-intrinsic\" {\n         fn simd_eq<T, U>(x: T, y: T) -> U;\n@@ -299,5 +355,6 @@ fn main() {\n     simd_cast();\n     simd_swizzle();\n     simd_gather_scatter();\n+    simd_round();\n     simd_intrinsics();\n }"}]}