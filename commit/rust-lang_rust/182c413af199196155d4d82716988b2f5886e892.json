{"sha": "182c413af199196155d4d82716988b2f5886e892", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MmM0MTNhZjE5OTE5NjE1NWQ0ZDgyNzE2OTg4YjJmNTg4NmU4OTI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-09T05:05:30Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-07-09T05:25:57Z"}, "message": "Propagate constraints through copy, move, and swap\n\nAssignments and moves with a simple local variable reference on the\nRHS now propagate any typestate constraints the RHS was involved\nin to the LHS. Swaps where both sides are local variables\nexchange the constraints.\n\nThis was a pain in the butt and I'm still not proud of the resulting\ncode. Needs refactoring like whoa.", "tree": {"sha": "3a814b69a62c8e1c92070b5ca9ee6ee2b8b2d5ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a814b69a62c8e1c92070b5ca9ee6ee2b8b2d5ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/182c413af199196155d4d82716988b2f5886e892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/182c413af199196155d4d82716988b2f5886e892", "html_url": "https://github.com/rust-lang/rust/commit/182c413af199196155d4d82716988b2f5886e892", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/182c413af199196155d4d82716988b2f5886e892/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be6febb46d541ebe8cb0f3e0585ffb8bafb39762", "url": "https://api.github.com/repos/rust-lang/rust/commits/be6febb46d541ebe8cb0f3e0585ffb8bafb39762", "html_url": "https://github.com/rust-lang/rust/commit/be6febb46d541ebe8cb0f3e0585ffb8bafb39762"}], "stats": {"total": 575, "additions": 442, "deletions": 133}, "files": [{"sha": "823bd44d6dd7a58b94f197672d52396fbbd21c17", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 258, "deletions": 23, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/182c413af199196155d4d82716988b2f5886e892/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c413af199196155d4d82716988b2f5886e892/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=182c413af199196155d4d82716988b2f5886e892", "patch": "@@ -1,9 +1,9 @@\n+import std::vec;\n import std::ivec;\n+import std::int::str;\n import std::str;\n import std::option;\n-import std::option::none;\n-import std::option::some;\n-import std::option::maybe;\n+import std::option::*;\n import std::int;\n import std::uint;\n import syntax::ast::*;\n@@ -26,19 +26,32 @@ import tstate::ann::empty_states;\n import tstate::ann::pps_len;\n import tstate::ann::set_prestate;\n import tstate::ann::set_poststate;\n+import tstate::ann::set_in_poststate_;\n import tstate::ann::extend_prestate;\n import tstate::ann::extend_poststate;\n import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n+import tstate::ann::set_in_postcond_;\n import tstate::ann::ts_ann;\n import tstate::ann::clear_in_postcond;\n import tstate::ann::clear_in_poststate;\n import tstate::ann::clear_in_poststate_;\n import tritv::*;\n+import bitvectors::promises_;\n \n import syntax::print::pprust::constr_args_to_str;\n+import syntax::print::pprust::constr_arg_to_str;\n import syntax::print::pprust::lit_to_str;\n \n+// Used to communicate which operands should be invalidated\n+// to helper functions\n+tag oper_type {\n+    oper_move;\n+    oper_swap;\n+    oper_assign;\n+    oper_assign_op;\n+    oper_pure;\n+}\n \n /* logging funs */\n fn def_id_to_str(def_id d) -> str {\n@@ -195,6 +208,8 @@ type pred_desc_ = rec((@constr_arg_use)[] args, uint bit_num);\n \n type pred_desc = spanned[pred_desc_];\n \n+// FIXME: Should be node_id, since we can only talk\n+// about locals. \n type constr_arg_use = constr_arg_general[tup(ident, def_id)];\n \n tag constraint {\n@@ -564,9 +579,13 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n }\n \n fn exprs_to_constr_args(ty::ctxt tcx, &(@expr)[] args)\n-        -> (@constr_arg_use)[] {\n+    -> (@constr_arg_use)[] {\n     auto f = bind expr_to_constr_arg(tcx, _);\n-    ret ivec::map(f, args);\n+    let (@constr_arg_use)[] rslt = ~[];\n+    for (@expr e in args) {\n+        rslt += ~[f(e)];\n+    }\n+    rslt\n }\n \n fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n@@ -602,14 +621,9 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n }\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n-    // FIXME: Remove this vec->ivec conversion.\n-    let (@constr_arg_use)[] cau_ivec = ~[];\n-    for (@constr_arg_use cau in p.node.args) {\n-        cau_ivec += ~[cau];\n-    }\n-\n-    ret \"<\" + uint::str(p.node.bit_num) + \", \" +\n-        constr_args_to_str(std::util::fst[ident, def_id], cau_ivec) + \">\";\n+    \"<\" + uint::str(p.node.bit_num) + \", \" +\n+        constr_args_to_str(std::util::fst[ident, def_id],\n+                           p.node.args) + \">\"\n }\n \n fn substitute_constr_args(&ty::ctxt cx, &(@expr)[] actuals,\n@@ -621,8 +635,6 @@ fn substitute_constr_args(&ty::ctxt cx, &(@expr)[] actuals,\n     ret npred(c.node.path, rslt);\n }\n \n-type subst = tup(arg, @expr)[];\n-\n fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n    @constr_arg_use {\n     auto num_actuals = ivec::len(actuals);\n@@ -640,6 +652,144 @@ fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n     }\n }\n \n+fn pred_desc_matches(&(constr_arg_general_[tup(ident, def_id)])[] pattern,\n+                     &pred_desc desc) -> bool {\n+    auto i = 0u;\n+    for (@constr_arg_use c in desc.node.args) {\n+        auto n = pattern.(i);\n+        alt (c.node) {\n+            case (carg_ident(?p)) {\n+                alt (n) {\n+                    case (carg_ident(?q)) {\n+                        if (p._1 != q._1) {\n+                            ret false;\n+                        }\n+                    }\n+                    case (_) { ret false; }\n+                }\n+            }\n+            case (carg_base) {\n+                if (n != carg_base) {\n+                    ret false;\n+                }\n+            }\n+            case (carg_lit(?l)) {\n+                alt (n) {\n+                    case (carg_lit(?m)) {\n+                        if (!lit_eq(l, m)) {\n+                            ret false;\n+                        }\n+                    }\n+                    case (_) { ret false; }\n+                }\n+            }\n+        }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+fn find_instance_(&(constr_arg_general_[tup(ident, def_id)])[] pattern,\n+                  &pred_desc[] descs) -> option::t[uint] {\n+    for (pred_desc d in descs) {\n+        if (pred_desc_matches(pattern, d)) {\n+            ret some(d.node.bit_num);\n+        }\n+    }\n+    ret none;\n+}\n+\n+type inst = tup(ident, def_id);\n+type subst = tup(inst, inst)[];\n+\n+fn find_instances(&fn_ctxt fcx, &subst subst, &constraint c)\n+    -> vec[tup(uint, uint)] {\n+   \n+    let vec[tup(uint, uint)] rslt = [];\n+    if (ivec::len(subst) == 0u) {\n+        ret rslt;\n+    }\n+\n+    alt (c) {\n+        case (cinit(_,_,_)) { /* this is dealt with separately */ }\n+        case (cpred(?p, ?descs)) {\n+            for (pred_desc d in *descs) {\n+                if (args_mention(d.node.args, find_in_subst_bool, subst)) {\n+                    auto old_bit_num = d.node.bit_num;\n+                    auto new = replace(subst, d);\n+                    alt (find_instance_(new, *descs)) {\n+                        case (some(?d1)) {\n+                            rslt += [tup(old_bit_num, d1)];\n+                        }\n+                        case (_) { }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    rslt\n+}\n+\n+fn find_in_subst(def_id id, &subst s) -> option::t[inst] {\n+    for (tup(inst, inst) p in s) {\n+        if (id == p._0._1) {\n+            ret some(p._1);\n+        }\n+    }\n+    ret none;\n+}\n+\n+fn find_in_subst_bool(&subst s, def_id id) -> bool {\n+    is_some(find_in_subst(id, s))\n+}\n+\n+fn insts_to_str(&(constr_arg_general_[inst])[] stuff) -> str {\n+    auto rslt = \"<\";\n+    for (constr_arg_general_[inst] i in stuff) {\n+        rslt += \" \" + alt(i) {\n+            case (carg_ident(?p)) { p._0 }\n+            case (carg_base) { \"*\" }\n+            case (carg_lit(_)) { \"[lit]\" } } + \" \";\n+    }\n+    rslt += \">\";\n+    rslt\n+}\n+\n+fn replace(subst subst, pred_desc d) -> (constr_arg_general_[inst])[] {\n+    let (constr_arg_general_[inst])[] rslt = ~[];\n+    for (@constr_arg_use c in d.node.args) {\n+        alt (c.node) {\n+            case (carg_ident(?p)) {\n+                alt (find_in_subst(p._1, subst)) {\n+                    case (some(?new)) {\n+                        rslt += ~[carg_ident(new)];\n+                    }\n+                    case (_) {\n+                        rslt += ~[c.node];\n+                    }\n+                }\n+            }\n+            case (_) {\n+                //  log_err \"##\";\n+                rslt += ~[c.node];\n+            }\n+         }\n+    }\n+    \n+    /*\n+    for (constr_arg_general_[tup(ident, def_id)] p in rslt) {\n+        alt (p) {\n+            case (carg_ident(?p)) {\n+                log_err p._0;\n+            }\n+            case (_) {}\n+        }\n+    }\n+    */\n+\n+    ret rslt;\n+}\n+\n fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n     alt (ivec::last(p.node.idents)) {\n         case (none) { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n@@ -684,6 +834,56 @@ fn local_node_id_to_def_id(&fn_ctxt fcx, &node_id i) -> option::t[def_id] {\n     }\n }\n \n+fn copy_in_postcond(&fn_ctxt fcx, node_id parent_exp, inst dest, inst src,\n+                    oper_type ty) {\n+    auto post = node_id_to_ts_ann(fcx.ccx, parent_exp).conditions.\n+        postcondition;\n+    copy_in_poststate_two(fcx, post, post, dest, src, ty);\n+}\n+\n+// FIXME refactor\n+fn copy_in_poststate(&fn_ctxt fcx, &poststate post, inst dest, inst src,\n+                     oper_type ty) {\n+    copy_in_poststate_two(fcx, post, post, dest, src, ty);\n+}\n+\n+// In target_post, set the bits corresponding to copies of any\n+// constraints mentioning src that are set in src_post, with\n+// dest substituted for src.\n+// (This doesn't create any new constraints. If a new, substituted\n+// constraint isn't already in the bit vector, it's ignored.)\n+fn copy_in_poststate_two(&fn_ctxt fcx, &poststate src_post,\n+                         &poststate target_post, inst dest, inst src,\n+                         oper_type ty) {\n+    auto subst;\n+    alt (ty) {\n+        case (oper_swap) {\n+            subst = ~[tup(dest, src),\n+                     tup(src, dest)];\n+        }\n+        case (oper_assign_op) {\n+            ret; // Don't do any propagation\n+        }\n+        case (_) {\n+            subst = ~[tup(src, dest)];\n+        }\n+    }\n+\n+    for each (@tup(node_id, constraint) p in\n+              fcx.enclosing.constrs.items()) {\n+        // replace any occurrences of the src def_id with the\n+        // dest def_id\n+        auto instances = find_instances(fcx, subst, p._1);\n+\n+        for (tup(uint,uint) p in instances) { \n+            if (promises_(p._0, src_post)) {\n+                set_in_poststate_(p._1, target_post);\n+            }\n+        }\n+    }\n+}\n+\n+\n /* FIXME should refactor this better */\n fn forget_in_postcond(&fn_ctxt fcx, node_id parent_exp, node_id dead_v) {\n     // In the postcondition given by parent_exp, clear the bits\n@@ -757,13 +957,20 @@ fn forget_in_poststate_still_init(&fn_ctxt fcx, &poststate p, node_id dead_v)\n     ret changed;\n }\n \n-fn constraint_mentions(&fn_ctxt fcx, &norm_constraint c, &def_id v) -> bool {\n+fn any_eq(&(def_id)[] v, def_id d) -> bool {\n+    for (def_id i in v) {\n+        if (i == d) { ret true; }\n+    }\n+    false\n+}\n+\n+fn constraint_mentions(&fn_ctxt fcx, &norm_constraint c, def_id v) -> bool {\n     ret (alt (c.c.node.c) {\n             case (ninit(_)) {\n                 v == local_def(c.c.node.id)\n             }\n             case (npred(_, ?args)) {\n-                args_mention(args, v)\n+                args_mention(args, any_eq, ~[v])\n             }\n         });\n }\n@@ -775,20 +982,42 @@ fn non_init_constraint_mentions(&fn_ctxt fcx, &norm_constraint c,\n                 false\n             }\n             case (npred(_, ?args)) {\n-                args_mention(args, v)\n+                args_mention(args, any_eq, ~[v])\n             }\n         });\n }\n \n-\n-fn args_mention(&(@constr_arg_use)[] args, &def_id v) -> bool {\n-    fn mentions(&def_id v, &@constr_arg_use a) -> bool {\n+fn args_mention[T](&(@constr_arg_use)[] args, fn(&(T)[], def_id) -> bool q,\n+                   &(T)[] s) -> bool {\n+    /*\n+      FIXME\n+      The following version causes an assertion in trans to fail\n+      (something about type_is_tup_like)\n+    fn mentions[T](&(T)[] s, &fn(&(T)[], def_id) -> bool q,\n+                            &@constr_arg_use a) -> bool {\n         alt (a.node) {\n-            case (carg_ident(?p1)) { p1._1 == v }\n+            case (carg_ident(?p1)) {\n+                auto res = q(s, p1._1);\n+                log_err (res);\n+                res\n+                    }\n             case (_)               { false }\n         }\n     }\n-    ret ivec::any[@constr_arg_use](bind mentions(v,_), args);\n+    ret ivec::any(bind mentions(s,q,_), args);\n+    */\n+\n+    for (@constr_arg_use a in args) {\n+        alt (a.node) {\n+            case (carg_ident(?p1)) {\n+                if (q(s, p1._1)) {\n+                    ret true;\n+                }\n+            }\n+            case (_)  {}\n+        }\n+    }\n+    ret false;\n }\n \n fn use_var(&fn_ctxt fcx, &node_id v) {\n@@ -803,6 +1032,12 @@ fn vec_contains(&@mutable (node_id[]) v, &node_id i) -> bool {\n     ret false;\n }\n \n+fn op_to_oper_ty(init_op io) -> oper_type {\n+    alt (io) {\n+        case (init_move) { oper_move }\n+        case (_)         { oper_assign }\n+    }\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "cc108961f197cdea84149dc0e833b39d054fc5c1", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 90, "deletions": 72, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/182c413af199196155d4d82716988b2f5886e892/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c413af199196155d4d82716988b2f5886e892/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=182c413af199196155d4d82716988b2f5886e892", "patch": "@@ -20,43 +20,7 @@ import tstate::ann::pp_clone;\n import tstate::ann::empty_prestate;\n import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n-import aux::crate_ctxt;\n-import aux::fn_ctxt;\n-import aux::num_constraints;\n-import aux::constraint;\n-import aux::expr_pp;\n-import aux::stmt_pp;\n-import aux::block_pp;\n-import aux::clear_pp;\n-import aux::clear_precond;\n-import aux::set_pre_and_post;\n-import aux::copy_pre_post;\n-import aux::copy_pre_post_;\n-import aux::expr_precond;\n-import aux::expr_postcond;\n-import aux::expr_prestate;\n-import aux::expr_poststate;\n-import aux::block_postcond;\n-import aux::fn_info;\n-import aux::log_pp;\n-import aux::node_id_to_def;\n-import aux::node_id_to_def_strict;\n-import aux::node_id_to_ts_ann;\n-import aux::set_postcond_false;\n-import aux::controlflow_expr;\n-import aux::expr_to_constr;\n-import aux::if_ty;\n-import aux::if_check;\n-import aux::plain_if;\n-import aux::forget_in_postcond;\n-import aux::forget_in_postcond_still_init;\n-\n-import aux::constraints_expr;\n-import aux::substitute_constr_args;\n-import aux::ninit;\n-import aux::npred;\n-import aux::path_to_ident;\n-import aux::use_var;\n+import aux::*;\n import bitvectors::bit_num;\n import bitvectors::promises;\n import bitvectors::seq_preconds;\n@@ -66,6 +30,7 @@ import bitvectors::declare_var;\n import bitvectors::gen_poststate;\n import bitvectors::relax_precond_block;\n import bitvectors::gen;\n+import tritv::tritv_clone;\n import syntax::ast::*;\n import std::map::new_int_hash;\n import util::common::new_def_hash;\n@@ -265,6 +230,75 @@ fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, node_id larger_id,\n     }\n }\n \n+fn handle_update(&fn_ctxt fcx, &@expr parent,\n+                 &@expr lhs, &@expr rhs, oper_type ty) {\n+    find_pre_post_expr(fcx, rhs);\n+     alt (lhs.node) {\n+        case (expr_path(?p)) {\n+            auto post = expr_postcond(fcx.ccx, parent);\n+            auto tmp = tritv_clone(post);\n+            \n+            alt (ty) {\n+                case (oper_move) {\n+                    if (is_path(rhs)) {\n+                        forget_in_postcond(fcx, parent.id, rhs.id);\n+                    }\n+                }\n+                case (oper_swap) {\n+                    forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n+                    forget_in_postcond_still_init(fcx, parent.id, rhs.id);\n+                }\n+                case (oper_assign) {\n+                    forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n+                }\n+                case (_) {\n+                    // pure and assign_op require the lhs to be init'd\n+                    auto df = node_id_to_def_strict(fcx.ccx.tcx, lhs.id);\n+                    alt (df) {\n+                        case (def_local(?d_id)) {\n+                            auto i = \n+                                bit_num(fcx,\n+                                 rec(id=d_id._1,\n+                                     c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n+                            require_and_preserve(i, expr_pp(fcx.ccx, lhs));\n+                        }\n+                        case (_) {}\n+                    }\n+                }\n+            }\n+\n+            gen_if_local(fcx, lhs, rhs, parent.id, lhs.id, p);\n+            alt (rhs.node) {\n+                case (expr_path(?p1)) {\n+                    auto d = local_node_id_to_def_id(fcx, lhs.id);\n+                    auto d1 = local_node_id_to_def_id(fcx, rhs.id);\n+                    alt (d) {\n+                        case (some(?id)) {\n+                            alt (d1) {\n+                                case (some(?id1)) {\n+                                    auto instlhs =\n+                                        tup(path_to_ident(fcx.ccx.tcx,\n+                                                          p), id);\n+                                    auto instrhs =\n+                                        tup(path_to_ident(fcx.ccx.tcx,\n+                                                          p1), id1);\n+                                    copy_in_poststate_two(fcx, tmp,\n+                                        post, instlhs, instrhs, ty);\n+                                }\n+                                case (_) {}\n+                            }\n+                        }\n+                        case (_) {}\n+                    }\n+                }\n+                case (_) { /* do nothing */ }\n+            }\n+        }\n+        case (_) { \n+            find_pre_post_expr(fcx, lhs);\n+        }\n+    }\n+}\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n@@ -355,46 +389,17 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             find_pre_post_exprs(fcx, es, e.id);\n         }\n         case (expr_move(?lhs, ?rhs)) {\n-            alt (lhs.node) {\n-                case (expr_path(?p)) {\n-                    gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n-                }\n-                case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], e.id); }\n-            }\n-            if (is_path(rhs)) {\n-                forget_in_postcond(fcx, e.id, rhs.id);\n-            }\n+            handle_update(fcx, e, lhs, rhs, oper_move);\n         }\n         case (expr_swap(?lhs, ?rhs)) {\n-            // Both sides must already be initialized\n-            find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n-            forget_in_postcond_still_init(fcx, e.id, lhs.id);\n-            forget_in_postcond_still_init(fcx, e.id, rhs.id);\n-            // Could be more precise and swap the roles of lhs and rhs\n-            // in any constraints\n+            handle_update(fcx, e, lhs, rhs, oper_swap);\n         }\n         case (expr_assign(?lhs, ?rhs)) {\n-            alt (lhs.node) {\n-                case (expr_path(?p)) {\n-                    gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n-                    forget_in_postcond_still_init(fcx, e.id, lhs.id);\n-                }\n-                case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], e.id); }\n-            }\n+            handle_update(fcx, e, lhs, rhs, oper_assign);\n         }\n         case (expr_recv(?lhs, ?rhs)) {\n-            alt (rhs.node) {\n-                case (expr_path(?p)) {\n-                    gen_if_local(fcx, rhs, lhs, e.id, rhs.id, p);\n-                    forget_in_postcond_still_init(fcx, e.id, lhs.id);\n-                 }\n-                case (_) {\n-                    // doesn't check that rhs is an lval, but\n-                    // that's probably ok\n-\n-                    find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n-                }\n-            }\n+            // note inversion of lhs and rhs\n+            handle_update(fcx, e, rhs, lhs, oper_assign);\n         }\n         case (expr_assign_op(_, ?lhs, ?rhs)) {\n             /* Different from expr_assign in that the lhs *must*\n@@ -600,10 +605,23 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                                initialized to the postcondition */\n \n                             copy_pre_post(fcx.ccx, id, an_init.expr);\n+\n+                            alt (an_init.expr.node) {\n+                                case (expr_path(?p)) {\n+                                    copy_in_postcond(fcx, id,\n+                                      tup(alocal.node.ident,\n+                                          local_def(alocal.node.id)),\n+                                      tup(path_to_ident(fcx.ccx.tcx, p),\n+                                          local_def(an_init.expr.id)),\n+                                             op_to_oper_ty(an_init.op));\n+                                }\n+                                case (_) {}\n+                            }\n+\n                             gen(fcx, id,\n                                 rec(id=alocal.node.id, \n                                     c=ninit(alocal.node.ident)));\n-                            \n+\n                             if (an_init.op == init_move &&\n                                 is_path(an_init.expr)) {\n                                 forget_in_postcond(fcx, id, an_init.expr.id);"}, {"sha": "aaca848acf9145268d869fe056f761563f7b6bcf", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 94, "deletions": 38, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/182c413af199196155d4d82716988b2f5886e892/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182c413af199196155d4d82716988b2f5886e892/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=182c413af199196155d4d82716988b2f5886e892", "patch": "@@ -23,6 +23,8 @@ import tstate::ann::false_postcond;\n import tstate::ann::ts_ann;\n import tstate::ann::set_prestate;\n import tstate::ann::set_poststate;\n+import aux::*;\n+/*\n import aux::crate_ctxt;\n import aux::fn_ctxt;\n import aux::num_constraints;\n@@ -64,6 +66,10 @@ import aux::if_check;\n import aux::plain_if;\n import aux::forget_in_poststate;\n import aux::forget_in_poststate_still_init;\n+import aux::copy_in_poststate;\n+import aux::copy_in_poststate_two;\n+import aux::local_node_id_to_def;\n+*/\n import tritv::tritv_clone;\n import tritv::tritv_set;\n import tritv::ttrue;\n@@ -92,15 +98,6 @@ import util::common::log_stmt;\n import util::common::log_stmt_err;\n import util::common::log_expr_err;\n \n-// Used to communicate which operands should be invalidated\n-// to helper functions\n-tag oper_type {\n-    oper_move;\n-    oper_swap;\n-    oper_assign;\n-    oper_pure;\n-}\n-\n fn seq_states(&fn_ctxt fcx, prestate pres, &(@expr)[] exprs) ->\n    tup(bool, poststate) {\n     auto changed = false;\n@@ -133,30 +130,68 @@ fn find_pre_post_state_sub(&fn_ctxt fcx, &prestate pres, &@expr e,\n     ret changed;\n }\n \n-fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr a, &@expr b,\n-                           node_id parent, oper_type op) -> bool {\n+fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr lhs,\n+                           &@expr rhs, node_id parent, oper_type ty)\n+    -> bool {\n     auto changed = set_prestate_ann(fcx.ccx, parent, pres);\n-    changed = find_pre_post_state_expr(fcx, pres, a) || changed;\n-    changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, a), b)\n+    changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n+    changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs), rhs)\n         || changed;\n \n+    auto post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n+\n+    alt (lhs.node) {\n+        case (expr_path(?p)) {\n     // for termination, need to make sure intermediate changes don't set\n     // changed flag\n-    auto post = tritv_clone(expr_poststate(fcx.ccx, b));\n-    alt (op) {\n-        case (oper_move) {\n-            forget_in_poststate(fcx, post, b.id);\n-            gen_if_local(fcx, post, a); \n-        }\n-        case (oper_swap) {\n-            forget_in_poststate_still_init(fcx, post, a.id);\n-            forget_in_poststate_still_init(fcx, post, b.id);\n-        }\n-        case (oper_assign) {\n-            forget_in_poststate_still_init(fcx, post, a.id);\n-            gen_if_local(fcx, post, a); \n+            // tmp remembers \"old\" constraints we'd otherwise forget,\n+            // for substitution purposes\n+            auto tmp = tritv_clone(post);\n+            \n+            alt (ty) {\n+                case (oper_move) {\n+                    if (is_path(rhs)) {\n+                        forget_in_poststate(fcx, post, rhs.id);\n+                    }\n+                    forget_in_poststate_still_init(fcx, post, lhs.id);\n+                }\n+                case (oper_swap) {\n+                    forget_in_poststate_still_init(fcx, post, lhs.id);\n+                    forget_in_poststate_still_init(fcx, post, rhs.id);\n+                }\n+                case (_) {\n+                    forget_in_poststate_still_init(fcx, post, lhs.id);\n+                }\n+            }\n+\n+            gen_if_local(fcx, post, lhs);\n+            alt (rhs.node) {\n+                case (expr_path(?p1)) {\n+                    auto d = local_node_id_to_def_id(fcx, lhs.id);\n+                    auto d1 = local_node_id_to_def_id(fcx, rhs.id);\n+                    alt (d) {\n+                        case (some(?id)) {\n+                            alt (d1) {\n+                                case (some(?id1)) {\n+                                    auto instlhs =\n+                                        tup(path_to_ident(fcx.ccx.tcx,\n+                                                          p), id);\n+                                    auto instrhs =\n+                                        tup(path_to_ident(fcx.ccx.tcx,\n+                                                          p1), id1);\n+                                    copy_in_poststate_two(fcx, tmp,\n+                                            post, instlhs, instrhs, ty);\n+                                }\n+                                case (_) {}\n+                            }\n+                        }\n+                        case (_) {}\n+                    }\n+                }\n+                case (_) { /* do nothing */ }\n+            }\n         }\n-        case (_) {}\n+        case (_) { }\n     }\n     changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n     ret changed;\n@@ -444,7 +479,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         }\n         case (expr_assign_op(?op, ?lhs, ?rhs)) {\n             ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n-                                        oper_assign);\n+                                        oper_assign_op);\n         }\n         case (expr_while(?test, ?body)) {\n             /*\n@@ -616,29 +651,50 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n \n                             auto post = tritv_clone(expr_poststate(fcx.ccx,\n                                                       an_init.expr));\n+                            alt (an_init.expr.node) {\n+                                case (expr_path(?p)) {\n+\n+                                    auto instlhs =\n+                                        tup(alocal.node.ident,\n+                                            local_def(alocal.node.id));\n+                                    auto rhs_d = local_node_id_to_def_id(fcx,\n+                                                          an_init.expr.id);\n+                                    alt (rhs_d) {\n+                                        case (some(?rhsid)) {\n+                                            auto instrhs = \n+                                                tup(path_to_ident(fcx.ccx.tcx,\n+                                                                  p), rhsid);\n+                                            copy_in_poststate(fcx, post,\n+                                               instlhs, instrhs,\n+                                               op_to_oper_ty(an_init.op));\n+                                        }\n+                                        case (_) { }\n+                                    }\n+                                }\n+                                case (_) { }\n+                            }\n                             if (an_init.op == init_move) {\n-                                clear_in_poststate_expr(fcx, an_init.expr,\n-                                                        post);\n+                                forget_in_poststate(fcx, post,\n+                                                    an_init.expr.id);\n                             }\n-\n                             set_in_poststate_ident(fcx, alocal.node.id,\n                                                    alocal.node.ident, post);\n-\n-                            /* important to do this in one step to ensure\n-                               termination (don't want to set changed to true\n-                               for intermediate changes) */\n-                            ret changed | set_poststate(stmt_ann, post);\n-\n                             /*\n                             log_err \"Summary: stmt = \";\n                             log_stmt_err(*s);\n                             log_err \"prestate = \";\n                             log_tritv_err(fcx, stmt_ann.states.prestate);\n                             log_err \"poststate =\";\n-                            log_tritv_err(fcx, stmt_ann.states.poststate);\n+                            log_tritv_err(fcx, post);\n                             log_err \"changed =\";\n                             log_err changed;\n                             */\n+                            /* important to do this in one step to ensure\n+                               termination (don't want to set changed to true\n+                               for intermediate changes) */\n+                            ret changed | set_poststate(stmt_ann, post);\n+\n+\n                         }\n                         case (none) {\n                             // let int = x; => x is uninit in poststate"}]}