{"sha": "9cfb8b730a473814c2ae090c342abb95e53502db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZmI4YjczMGE0NzM4MTRjMmFlMDkwYzM0MmFiYjk1ZTUzNTAyZGI=", "commit": {"author": {"name": "comex", "email": "comexk@gmail.com", "date": "2017-01-14T23:04:27Z"}, "committer": {"name": "comex", "email": "comexk@gmail.com", "date": "2017-01-14T23:44:35Z"}, "message": "Merge branch 'master' into lint-attr-fix", "tree": {"sha": "ac757a3acf31331c3ef7c9a0f3f063b1d85c9fd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac757a3acf31331c3ef7c9a0f3f063b1d85c9fd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cfb8b730a473814c2ae090c342abb95e53502db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cfb8b730a473814c2ae090c342abb95e53502db", "html_url": "https://github.com/rust-lang/rust/commit/9cfb8b730a473814c2ae090c342abb95e53502db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cfb8b730a473814c2ae090c342abb95e53502db/comments", "author": {"login": "comex", "id": 47517, "node_id": "MDQ6VXNlcjQ3NTE3", "avatar_url": "https://avatars.githubusercontent.com/u/47517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/comex", "html_url": "https://github.com/comex", "followers_url": "https://api.github.com/users/comex/followers", "following_url": "https://api.github.com/users/comex/following{/other_user}", "gists_url": "https://api.github.com/users/comex/gists{/gist_id}", "starred_url": "https://api.github.com/users/comex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/comex/subscriptions", "organizations_url": "https://api.github.com/users/comex/orgs", "repos_url": "https://api.github.com/users/comex/repos", "events_url": "https://api.github.com/users/comex/events{/privacy}", "received_events_url": "https://api.github.com/users/comex/received_events", "type": "User", "site_admin": false}, "committer": {"login": "comex", "id": 47517, "node_id": "MDQ6VXNlcjQ3NTE3", "avatar_url": "https://avatars.githubusercontent.com/u/47517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/comex", "html_url": "https://github.com/comex", "followers_url": "https://api.github.com/users/comex/followers", "following_url": "https://api.github.com/users/comex/following{/other_user}", "gists_url": "https://api.github.com/users/comex/gists{/gist_id}", "starred_url": "https://api.github.com/users/comex/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/comex/subscriptions", "organizations_url": "https://api.github.com/users/comex/orgs", "repos_url": "https://api.github.com/users/comex/repos", "events_url": "https://api.github.com/users/comex/events{/privacy}", "received_events_url": "https://api.github.com/users/comex/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "743535a643ff9c7f5791a71f6b62c27617cdbb3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/743535a643ff9c7f5791a71f6b62c27617cdbb3e", "html_url": "https://github.com/rust-lang/rust/commit/743535a643ff9c7f5791a71f6b62c27617cdbb3e"}, {"sha": "93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6", "html_url": "https://github.com/rust-lang/rust/commit/93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6"}], "stats": {"total": 15173, "additions": 9604, "deletions": 5569}, "files": [{"sha": "8b141416e4f632b1188d801c108a418f731803fa", "filename": ".gitignore", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -73,12 +73,13 @@ __pycache__/\n /obj/\n /rt/\n /rustllvm/\n-/src/libunicode/DerivedCoreProperties.txt\n-/src/libunicode/EastAsianWidth.txt\n-/src/libunicode/HangulSyllableType.txt\n-/src/libunicode/PropList.txt\n-/src/libunicode/Scripts.txt\n-/src/libunicode/UnicodeData.txt\n+/src/libstd_unicode/DerivedCoreProperties.txt\n+/src/libstd_unicode/DerivedNormalizationProps.txt\n+/src/libstd_unicode/PropList.txt\n+/src/libstd_unicode/ReadMe.txt\n+/src/libstd_unicode/Scripts.txt\n+/src/libstd_unicode/SpecialCasing.txt\n+/src/libstd_unicode/UnicodeData.txt\n /stage[0-9]+/\n /target\n /test/"}, {"sha": "c5a9fe246a01c526a52b62c85131c0e9333615bf", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -152,7 +152,7 @@ NAKASHIMA, Makoto <makoto.nksm+github@gmail.com>\n Nathan Wilson <wilnathan@gmail.com>\n Nathaniel Herman <nherman@post.harvard.edu> Nathaniel Herman <nherman@college.harvard.edu>\n Neil Pankey <npankey@gmail.com> <neil@wire.im>\n-Nicholas Mazzuca <npmazzuca@gmail.com> Nicholas <npmazzuca@gmail.com>\n+Nicole Mazzuca <npmazzuca@gmail.com> Nicole <npmazzuca@gmail.com>\n Nick Platt <platt.nicholas@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n Oliver Schneider <oliver.schneider@kit.edu> oli-obk <github6541940@oli-obk.de>"}, {"sha": "6cb2b80214723af921a33da481f4cd93052870a6", "filename": ".travis.yml", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,19 +13,20 @@ osx_image: xcode8.2\n matrix:\n   include:\n     # Linux builders, all docker images\n-    - env: IMAGE=arm-android\n-    - env: IMAGE=cross\n-    - env: IMAGE=i686-gnu\n+    - env: IMAGE=arm-android DEPLOY=1\n+    - env: IMAGE=cross DEPLOY=1\n+    - env: IMAGE=dist-arm-unknown-linux-gnueabi DEPLOY=1\n+    - env: IMAGE=dist-x86_64-unknown-freebsd DEPLOY=1\n+    - env: IMAGE=i686-gnu DEPLOY=1\n     - env: IMAGE=i686-gnu-nopt\n-    - env: IMAGE=x86_64-freebsd\n-    - env: IMAGE=x86_64-gnu\n+    - env: IMAGE=x86_64-gnu DEPLOY=1\n     - env: IMAGE=x86_64-gnu-full-bootstrap\n     - env: IMAGE=x86_64-gnu-aux\n     - env: IMAGE=x86_64-gnu-debug\n     - env: IMAGE=x86_64-gnu-nopt\n     - env: IMAGE=x86_64-gnu-make\n     - env: IMAGE=x86_64-gnu-llvm-3.7 ALLOW_PR=1 RUST_BACKTRACE=1\n-    - env: IMAGE=x86_64-musl\n+    - env: IMAGE=x86_64-musl DEPLOY=1\n     - env: IMAGE=x86_64-gnu-distcheck\n \n     # OSX builders\n@@ -34,27 +35,44 @@ matrix:\n         RUST_CONFIGURE_ARGS=--build=x86_64-apple-darwin\n         SRC=.\n       os: osx\n+      before_script: &osx_before_script >\n+        ulimit -c unlimited\n       install: &osx_install_sccache >\n         curl -L https://api.pub.build.mozilla.org/tooltool/sha512/d0025b286468cc5ada83b23d3fafbc936b9f190eaa7d4a981715b18e8e3bf720a7bcee7bfe758cfdeb8268857f6098fd52dcdd8818232692a30ce91039936596 |\n           tar xJf - -C /usr/local/bin --strip-components=1\n+      after_failure: &osx_after_failure >\n+        echo 'bt all' > cmds;\n+        for file in $(ls /cores); do\n+          echo core file $file;\n+          lldb -c $file `which ld` -b -s cmds;\n+        done\n+\n     - env: >\n-        RUST_CHECK_TARGET=check\n+        SCRIPT=\"./x.py test && ./x.py dist\"\n         RUST_CONFIGURE_ARGS=--build=i686-apple-darwin\n         SRC=.\n+        DEPLOY=1\n       os: osx\n+      before_script: *osx_before_script\n       install: *osx_install_sccache\n+      after_failure: *osx_after_failure\n     - env: >\n         RUST_CHECK_TARGET=check\n         RUST_CONFIGURE_ARGS=--build=x86_64-apple-darwin --disable-rustbuild\n         SRC=.\n       os: osx\n+      before_script: *osx_before_script\n       install: *osx_install_sccache\n+      after_failure: *osx_after_failure\n     - env: >\n-        RUST_CHECK_TARGET=\n+        RUST_CHECK_TARGET=dist\n         RUST_CONFIGURE_ARGS=--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios\n         SRC=.\n+        DEPLOY=1\n       os: osx\n+      before_script: *osx_before_script\n       install: *osx_install_sccache\n+      after_failure: *osx_after_failure\n \n env:\n   global:\n@@ -68,10 +86,10 @@ script:\n       if [ \"$ALLOW_PR\" = \"\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n           echo skipping, not a full build;\n       elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-          git submodule update --init &&\n+          travis_retry git submodule update --init &&\n           src/ci/run.sh;\n       else\n-          git submodule update --init &&\n+          travis_retry git submodule update --init &&\n           src/ci/docker/run.sh $IMAGE;\n       fi\n \n@@ -90,3 +108,29 @@ notifications:\n cache:\n   directories:\n     - $HOME/docker\n+\n+before_deploy:\n+  - mkdir -p deploy/$TRAVIS_COMMIT\n+  - >\n+      if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then\n+          cp build/dist/*.tar.gz deploy/$TRAVIS_COMMIT &&\n+          find \"deploy/$TRAVIS_COMMIT\" -maxdepth 1 -type f -exec sh -c 'shasum -a 256 -b \"{}\" > \"{}.sha256\"' \\;;\n+      else\n+          cp obj/build/dist/*.tar.gz deploy/$TRAVIS_COMMIT &&\n+          find \"deploy/$TRAVIS_COMMIT\" -maxdepth 1 -type f -exec sh -c 'sha256sum -b \"{}\" > \"{}.sha256\"' \\;;\n+      fi\n+\n+deploy:\n+  - provider: s3\n+    bucket: rust-lang-ci\n+    skip_cleanup: true\n+    local_dir: deploy\n+    upload_dir: rustc-builds\n+    acl: public_read\n+    region: us-east-1\n+    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    secret_access_key:\n+      secure: \"FBqDqOTeIPMu6v/WYPf4CFSlh9rLRZGKVtpLa5KkyuOhXRTrnEzBduEtS8/FMIxdQImvurhSvxWvqRybMOi4qoVfjMqqpHAI7uBbidbrvAcJoHNsx6BgUNVCIoH6a0UsAjTUtm6/YPIpzbHoLZXPL0GrHPMk6Mu04qVSmcYNWn4=\"\n+    on:\n+      branch: auto\n+      condition: $DEPLOY = 1"}, {"sha": "58df1aae6d3f099815f5751b009e15745440d656", "filename": "COMPILER_TESTS.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/COMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/COMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COMPILER_TESTS.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -45,6 +45,10 @@ whole, instead of just a few lines inside the test.\n * `should-fail` indicates that the test should fail; used for \"meta testing\",\n   where we test the compiletest program itself to check that it will generate\n   errors in appropriate scenarios. This header is ignored for pretty-printer tests.\n+* `gate-test-X` where `X` is a feature marks the test as \"gate test\" for feature X.\n+  Such tests are supposed to ensure that the compiler errors when usage of a gated\n+  feature is attempted without the proper `#![feature(X)]` tag.\n+  Each unstable lang feature is required to have a gate test.\n \n ## Revisions\n "}, {"sha": "346ef0d8faad722acf081deeb287feb52b786b53", "filename": "appveyor.yml", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -8,10 +8,12 @@ environment:\n   # 32/64 bit MSVC\n   - MSYS_BITS: 64\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-    RUST_CHECK_TARGET: check\n+    SCRIPT: python x.py test && python x.py dist\n+    DEPLOY: 1\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    RUST_CHECK_TARGET: check\n+    SCRIPT: python x.py test && python x.py dist\n+    DEPLOY: 1\n \n   # MSVC makefiles\n   - MSYS_BITS: 64\n@@ -50,10 +52,11 @@ environment:\n   # too long on appveyor and this is tested by rustbuild below.\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    RUST_CHECK_TARGET: check\n+    SCRIPT: python x.py test && python x.py dist\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n     MINGW_DIR: mingw32\n+    DEPLOY: 1\n \n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --disable-rustbuild\n@@ -63,11 +66,12 @@ environment:\n     MINGW_DIR: mingw32\n \n   - MSYS_BITS: 64\n-    RUST_CHECK_TARGET: check\n+    SCRIPT: python x.py test && python x.py dist\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: x86_64-4.9.2-release-win32-seh-rt_v4-rev4.7z\n     MINGW_DIR: mingw64\n+    DEPLOY: 1\n \n clone_depth: 1\n build: false\n@@ -123,6 +127,32 @@ branches:\n   only:\n     - auto\n \n+before_deploy:\n+  - ps: |\n+        New-Item -Path deploy -ItemType directory\n+        Get-ChildItem -Path build\\dist -Filter '*.tar.gz' | Move-Item -Destination deploy\n+        Get-FileHash .\\deploy\\* | ForEach-Object {\n+          [io.file]::WriteAllText($_.Path + \".sha256\", $_.Hash.ToLower() + \"`n\")\n+        }\n+        Get-ChildItem -Path deploy | Foreach-Object {\n+          Push-AppveyorArtifact $_.FullName -FileName ${env:APPVEYOR_REPO_COMMIT}/$_\n+        }\n+\n+deploy:\n+  - provider: S3\n+    skip_cleanup: true\n+    access_key_id: AKIAIPQVNYF2T3DTYIWQ\n+    secret_access_key:\n+      secure: +11jsUNFTQ9dq5Ad1i2+PeUJaXluFJ0zIJAXESE1dFT3Kdjku4/eDdgyjgsB6GnV\n+    bucket: rust-lang-ci\n+    set_public: true\n+    region: us-east-1\n+    artifact: /.*\\.(tar.gz|sha256)/\n+    folder: rustc-builds\n+    on:\n+      branch: auto\n+      DEPLOY: 1\n+\n # init:\n #   - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n # on_finish:"}, {"sha": "fa81684fb48e289b2be7a9f46450da295c4b4ef4", "filename": "configure", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/configure", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -541,6 +541,18 @@ case $CFG_CPUTYPE in\n         CFG_CPUTYPE=x86_64\n         ;;\n \n+    mips | mips64)\n+        if [ \"$CFG_CPUTYPE\" = \"mips64\" ]; then\n+            CFG_OSTYPE=\"${CFG_OSTYPE}abi64\"\n+        fi\n+        ENDIAN=$(printf '\\1' | od -dAn)\n+        if [ \"$ENDIAN\" -eq 1 ]; then\n+            CFG_CPUTYPE=\"${CFG_CPUTYPE}el\"\n+        elif [ \"$ENDIAN\" -ne 256 ]; then\n+            err \"unknown endianness: $ENDIAN (expecting 1 for little or 256 for big)\"\n+        fi\n+        ;;\n+\n     BePC)\n         CFG_CPUTYPE=i686\n         ;;\n@@ -647,6 +659,7 @@ opt_nosave debug-assertions 0 \"build with debugging assertions\"\n opt_nosave llvm-release-debuginfo 0 \"build LLVM with debugger metadata\"\n opt_nosave debuginfo 0 \"build with debugger metadata\"\n opt_nosave debuginfo-lines 0 \"build with line number debugger metadata\"\n+opt_nosave debuginfo-only-std 0 \"build only libstd with debugging information\"\n opt_nosave debug-jemalloc 0 \"build jemalloc with --enable-debug --enable-fill\"\n \n valopt localstatedir \"/var/lib\" \"local state directory\"\n@@ -733,23 +746,26 @@ case \"$CFG_RELEASE_CHANNEL\" in\n     nightly )\n \tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n \tCFG_ENABLE_LLVM_ASSERTIONS=1\n-\n-        # FIXME(#37364) shouldn't have to disable this on windows-gnu\n+        # FIXME(stage0) re-enable this on the next stage0 now that #35566 is\n+        # fixed\n         case \"$CFG_BUILD\" in\n           *-pc-windows-gnu)\n             ;;\n           *)\n-\t    CFG_ENABLE_DEBUGINFO_LINES=1\n+            CFG_ENABLE_DEBUGINFO_LINES=1\n+            CFG_ENABLE_DEBUGINFO_ONLY_STD=1\n             ;;\n         esac\n+\n \t;;\n     beta | stable)\n \tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n         case \"$CFG_BUILD\" in\n           *-pc-windows-gnu)\n             ;;\n           *)\n-\t    CFG_ENABLE_DEBUGINFO_LINES=1\n+            CFG_ENABLE_DEBUGINFO_LINES=1\n+            CFG_ENABLE_DEBUGINFO_ONLY_STD=1\n             ;;\n         esac\n \t;;\n@@ -785,6 +801,7 @@ if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTION\n if [ -n \"$CFG_ENABLE_LLVM_RELEASE_DEBUGINFO\" ]; then putvar CFG_ENABLE_LLVM_RELEASE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n if [ -n \"$CFG_ENABLE_DEBUGINFO_LINES\" ]; then putvar CFG_ENABLE_DEBUGINFO_LINES; fi\n+if [ -n \"$CFG_ENABLE_DEBUGINFO_ONLY_STD\" ]; then putvar CFG_ENABLE_DEBUGINFO_ONLY_STD; fi\n if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n \n step_msg \"looking for build programs\""}, {"sha": "9cd30be6531d121c89d3001cde3a7480d25adfc7", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -175,7 +175,7 @@ endif\n # that the snapshot will be generated with a statically linked rustc so we only\n # have to worry about the distribution of one file (with its native dynamic\n # dependencies)\n-RUSTFLAGS_STAGE0 += -C prefer-dynamic -C no-stack-check\n+RUSTFLAGS_STAGE0 += -C prefer-dynamic\n RUSTFLAGS_STAGE1 += -C prefer-dynamic\n RUST_LIB_FLAGS_ST2 += -C prefer-dynamic\n RUST_LIB_FLAGS_ST3 += -C prefer-dynamic"}, {"sha": "d153945dc091f51f10a5145c7c35a8afa7177bde", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -569,7 +569,6 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n- \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_driver 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "1eda1608c4709c4de84b57b8473ca62cbbaad820", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -6,18 +6,22 @@ version = \"0.0.0\"\n [lib]\n name = \"bootstrap\"\n path = \"lib.rs\"\n+doctest = false\n \n [[bin]]\n name = \"bootstrap\"\n path = \"bin/main.rs\"\n+test = false\n \n [[bin]]\n name = \"rustc\"\n path = \"bin/rustc.rs\"\n+test = false\n \n [[bin]]\n name = \"rustdoc\"\n path = \"bin/rustdoc.rs\"\n+test = false\n \n [dependencies]\n build_helper = { path = \"../build_helper\" }"}, {"sha": "85e8dbce1a955000d839be8289a27069d4180dbf", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -72,7 +72,7 @@ def download(path, url, probably_big, verbose):\n             option = \"-#\"\n         else:\n             option = \"-s\"\n-        run([\"curl\", option, \"-Sf\", \"-o\", path, url], verbose=verbose)\n+        run([\"curl\", option, \"--retry\", \"3\", \"-Sf\", \"-o\", path, url], verbose=verbose)\n \n \n def verify(path, sha_path, verbose):"}, {"sha": "cafdd3aec65bd6e43af0886e6c55dff2385fd902", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -457,6 +457,8 @@ fn krate_android(build: &Build,\n \n         let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n         println!(\"{}\", output);\n+\n+        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n         build.run(Command::new(\"adb\")\n                           .arg(\"pull\")\n                           .arg(&log)\n@@ -516,6 +518,7 @@ pub fn android_copy_libs(build: &Build,\n     }\n \n     println!(\"Android copy libs to emulator ({})\", target);\n+    build.run(Command::new(\"adb\").arg(\"wait-for-device\"));\n     build.run(Command::new(\"adb\").arg(\"remount\"));\n     build.run(Command::new(\"adb\").args(&[\"shell\", \"rm\", \"-r\", ADB_TEST_DIR]));\n     build.run(Command::new(\"adb\").args(&[\"shell\", \"mkdir\", ADB_TEST_DIR]));\n@@ -568,3 +571,14 @@ pub fn distcheck(build: &Build) {\n                      .arg(\"check\")\n                      .current_dir(&dir));\n }\n+\n+/// Test the build system itself\n+pub fn bootstrap(build: &Build) {\n+    let mut cmd = Command::new(&build.cargo);\n+    cmd.arg(\"test\")\n+       .current_dir(build.src.join(\"src/bootstrap\"))\n+       .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n+       .env(\"RUSTC\", &build.rustc);\n+    cmd.arg(\"--\").args(&build.flags.cmd.test_args());\n+    build.run(&mut cmd);\n+}"}, {"sha": "0eeb799672cf200a5406aae656cad80ec16a71fa", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,7 +16,6 @@\n //! compiler. This module is also responsible for assembling the sysroot as it\n //! goes along from the output of the previous stage.\n \n-use std::cmp;\n use std::collections::HashMap;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n@@ -59,7 +58,7 @@ pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n     }\n \n     build.run(&mut cargo);\n-    update_mtime(&libstd_stamp(build, &compiler, target));\n+    update_mtime(build, &libstd_stamp(build, &compiler, target));\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n@@ -145,7 +144,7 @@ pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n-    update_mtime(&libtest_stamp(build, compiler, target));\n+    update_mtime(build, &libtest_stamp(build, compiler, target));\n }\n \n /// Same as `std_link`, only for libtest\n@@ -186,9 +185,16 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     cargo.env(\"CFG_RELEASE\", &build.release)\n          .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n          .env(\"CFG_VERSION\", &build.version)\n-         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or(String::new()))\n+         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or(PathBuf::new()))\n          .env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n \n+    // If we're not building a compiler with debugging information then remove\n+    // these two env vars which would be set otherwise.\n+    if build.config.rust_debuginfo_only_std {\n+        cargo.env_remove(\"RUSTC_DEBUGINFO\");\n+        cargo.env_remove(\"RUSTC_DEBUGINFO_LINES\");\n+    }\n+\n     if let Some(ref ver_date) = build.ver_date {\n         cargo.env(\"CFG_VER_DATE\", ver_date);\n     }\n@@ -258,11 +264,6 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n }\n \n pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n-    // nothing to do in stage0\n-    if compiler.stage == 0 {\n-        return\n-    }\n-\n     let sysroot = build.sysroot(compiler);\n     let _ = fs::remove_dir_all(&sysroot);\n     t!(fs::create_dir_all(&sysroot));\n@@ -388,26 +389,39 @@ pub fn tool(build: &Build, stage: u32, host: &str, tool: &str) {\n }\n \n /// Updates the mtime of a stamp file if necessary, only changing it if it's\n-/// older than some other file in the same directory.\n+/// older than some other library file in the same directory.\n ///\n /// We don't know what file Cargo is going to output (because there's a hash in\n /// the file name) but we know where it's going to put it. We use this helper to\n /// detect changes to that output file by looking at the modification time for\n /// all files in a directory and updating the stamp if any are newer.\n-fn update_mtime(path: &Path) {\n-    let mut max = None;\n-    if let Ok(entries) = path.parent().unwrap().read_dir() {\n-        for entry in entries.map(|e| t!(e)) {\n-            if t!(entry.file_type()).is_file() {\n-                let meta = t!(entry.metadata());\n-                let time = FileTime::from_last_modification_time(&meta);\n-                max = cmp::max(max, Some(time));\n-            }\n-        }\n-    }\n-\n-    if !max.is_none() && max <= Some(mtime(path)) {\n-        return\n+///\n+/// Note that we only consider Rust libraries as that's what we're interested in\n+/// propagating changes from. Files like executables are tracked elsewhere.\n+fn update_mtime(build: &Build, path: &Path) {\n+    let entries = match path.parent().unwrap().join(\"deps\").read_dir() {\n+        Ok(entries) => entries,\n+        Err(_) => return,\n+    };\n+    let files = entries.map(|e| t!(e)).filter(|e| t!(e.file_type()).is_file());\n+    let files = files.filter(|e| {\n+        let filename = e.file_name();\n+        let filename = filename.to_str().unwrap();\n+        filename.ends_with(\".rlib\") ||\n+            filename.ends_with(\".lib\") ||\n+            is_dylib(&filename)\n+    });\n+    let max = files.max_by_key(|entry| {\n+        let meta = t!(entry.metadata());\n+        FileTime::from_last_modification_time(&meta)\n+    });\n+    let max = match max {\n+        Some(max) => max,\n+        None => return,\n+    };\n+\n+    if mtime(&max.path()) > mtime(path) {\n+        build.verbose(&format!(\"updating {:?} as {:?} changed\", path, max.path()));\n+        t!(File::create(path));\n     }\n-    t!(File::create(path));\n }"}, {"sha": "8e2129758f6d0aeba02cc943ab72573292d90360", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -63,6 +63,7 @@ pub struct Config {\n     pub rust_debug_assertions: bool,\n     pub rust_debuginfo: bool,\n     pub rust_debuginfo_lines: bool,\n+    pub rust_debuginfo_only_std: bool,\n     pub rust_rpath: bool,\n     pub rustc_default_linker: Option<String>,\n     pub rustc_default_ar: Option<String>,\n@@ -86,10 +87,10 @@ pub struct Config {\n     pub quiet_tests: bool,\n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n-    pub prefix: Option<String>,\n-    pub docdir: Option<String>,\n-    pub libdir: Option<String>,\n-    pub mandir: Option<String>,\n+    pub prefix: Option<PathBuf>,\n+    pub docdir: Option<PathBuf>,\n+    pub libdir: Option<PathBuf>,\n+    pub mandir: Option<PathBuf>,\n     pub codegen_tests: bool,\n     pub nodejs: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n@@ -144,6 +145,9 @@ struct Build {\n #[derive(RustcDecodable, Default, Clone)]\n struct Install {\n     prefix: Option<String>,\n+    mandir: Option<String>,\n+    docdir: Option<String>,\n+    libdir: Option<String>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -179,6 +183,7 @@ struct Rust {\n     debug_assertions: Option<bool>,\n     debuginfo: Option<bool>,\n     debuginfo_lines: Option<bool>,\n+    debuginfo_only_std: Option<bool>,\n     debug_jemalloc: Option<bool>,\n     use_jemalloc: Option<bool>,\n     backtrace: Option<bool>,\n@@ -272,7 +277,10 @@ impl Config {\n         set(&mut config.full_bootstrap, build.full_bootstrap);\n \n         if let Some(ref install) = toml.install {\n-            config.prefix = install.prefix.clone();\n+            config.prefix = install.prefix.clone().map(PathBuf::from);\n+            config.mandir = install.mandir.clone().map(PathBuf::from);\n+            config.docdir = install.docdir.clone().map(PathBuf::from);\n+            config.libdir = install.libdir.clone().map(PathBuf::from);\n         }\n \n         if let Some(ref llvm) = toml.llvm {\n@@ -298,6 +306,7 @@ impl Config {\n             set(&mut config.rust_debug_assertions, rust.debug_assertions);\n             set(&mut config.rust_debuginfo, rust.debuginfo);\n             set(&mut config.rust_debuginfo_lines, rust.debuginfo_lines);\n+            set(&mut config.rust_debuginfo_only_std, rust.debuginfo_only_std);\n             set(&mut config.rust_optimize, rust.optimize);\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n@@ -390,6 +399,7 @@ impl Config {\n                 (\"DEBUG_ASSERTIONS\", self.rust_debug_assertions),\n                 (\"DEBUGINFO\", self.rust_debuginfo),\n                 (\"DEBUGINFO_LINES\", self.rust_debuginfo_lines),\n+                (\"DEBUGINFO_ONLY_STD\", self.rust_debuginfo_only_std),\n                 (\"JEMALLOC\", self.use_jemalloc),\n                 (\"DEBUG_JEMALLOC\", self.debug_jemalloc),\n                 (\"RPATH\", self.rust_rpath),\n@@ -459,16 +469,16 @@ impl Config {\n                     self.channel = value.to_string();\n                 }\n                 \"CFG_PREFIX\" => {\n-                    self.prefix = Some(value.to_string());\n+                    self.prefix = Some(PathBuf::from(value));\n                 }\n                 \"CFG_DOCDIR\" => {\n-                    self.docdir = Some(value.to_string());\n+                    self.docdir = Some(PathBuf::from(value));\n                 }\n                 \"CFG_LIBDIR\" => {\n-                    self.libdir = Some(value.to_string());\n+                    self.libdir = Some(PathBuf::from(value));\n                 }\n                 \"CFG_MANDIR\" => {\n-                    self.mandir = Some(value.to_string());\n+                    self.mandir = Some(PathBuf::from(value));\n                 }\n                 \"CFG_LLVM_ROOT\" if value.len() > 0 => {\n                     let target = self.target_config.entry(self.build.clone())"}, {"sha": "47e50cb79b41525c14dc18332de3308eadca4071", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -124,7 +124,16 @@\n [install]\n \n # Instead of installing to /usr/local, install to this path instead.\n-#prefix = \"/path/to/install\"\n+#prefix = \"/usr/local\"\n+\n+# Where to install libraries in `prefix` above\n+#libdir = \"lib\"\n+\n+# Where to install man pages in `prefix` above\n+#mandir = \"share/man\"\n+\n+# Where to install documentation in `prefix` above\n+#docdir = \"share/doc/rust\"\n \n # =============================================================================\n # Options for compiling Rust code itself\n@@ -149,6 +158,11 @@\n # Whether or not line number debug information is emitted\n #debuginfo-lines = false\n \n+# Whether or not to only build debuginfo for the standard library if enabled.\n+# If enabled, this will not compile the compiler with debuginfo, just the\n+# standard library.\n+#debuginfo-only-std = false\n+\n # Whether or not jemalloc is built and enabled\n #use-jemalloc = true\n "}, {"sha": "dc45d3817fe308e6ff026a3bf62dac01f8fb66fb", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -354,22 +354,15 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n }\n \n /// Creates the `rust-src` installer component and the plain source tarball\n-pub fn rust_src(build: &Build, host: &str) {\n+pub fn rust_src(build: &Build) {\n     println!(\"Dist src\");\n \n-    if host != build.config.build {\n-        println!(\"\\tskipping, not a build host\");\n-        return\n-    }\n-\n-    let plain_name = format!(\"rustc-{}-src\", package_vers(build));\n     let name = format!(\"rust-src-{}\", package_vers(build));\n     let image = tmpdir(build).join(format!(\"{}-image\", name));\n     let _ = fs::remove_dir_all(&image);\n \n     let dst = image.join(\"lib/rustlib/src\");\n     let dst_src = dst.join(\"rust\");\n-    let plain_dst_src = dst.join(&plain_name);\n     t!(fs::create_dir_all(&dst_src));\n \n     // This is the set of root paths which will become part of the source package\n@@ -449,7 +442,11 @@ pub fn rust_src(build: &Build, host: &str) {\n     build.run(&mut cmd);\n \n     // Rename directory, so that root folder of tarball has the correct name\n-    t!(fs::rename(&dst_src, &plain_dst_src));\n+    let plain_name = format!(\"rustc-{}-src\", package_vers(build));\n+    let plain_dst_src = tmpdir(build).join(&plain_name);\n+    let _ = fs::remove_dir_all(&plain_dst_src);\n+    t!(fs::create_dir_all(&plain_dst_src));\n+    cp_r(&dst_src, &plain_dst_src);\n \n     // Create the version file\n     write_file(&plain_dst_src.join(\"version\"), build.version.as_bytes());\n@@ -458,10 +455,11 @@ pub fn rust_src(build: &Build, host: &str) {\n     let mut cmd = Command::new(\"tar\");\n     cmd.arg(\"-czf\").arg(sanitize_sh(&rust_src_location(build)))\n        .arg(&plain_name)\n-       .current_dir(&dst);\n+       .current_dir(tmpdir(build));\n     build.run(&mut cmd);\n \n     t!(fs::remove_dir_all(&image));\n+    t!(fs::remove_dir_all(&plain_dst_src));\n }\n \n fn install(src: &Path, dstdir: &Path, perms: u32) {"}, {"sha": "d1c9918a73373f95a01dd5e631b9372510a3294b", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -57,12 +57,12 @@ pub fn rustbook(build: &Build, target: &str, name: &str) {\n /// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n ///\n /// In the end, this is just a glorified wrapper around rustdoc!\n-pub fn standalone(build: &Build, stage: u32, target: &str) {\n-    println!(\"Documenting stage{} standalone ({})\", stage, target);\n+pub fn standalone(build: &Build, target: &str) {\n+    println!(\"Documenting standalone ({})\", target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n \n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(0, &build.config.build);\n \n     let favicon = build.src.join(\"src/doc/favicon.inc\");\n     let footer = build.src.join(\"src/doc/footer.inc\");\n@@ -151,8 +151,25 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     let mut cargo = build.cargo(&compiler, Mode::Libstd, target, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n-         .arg(\"--features\").arg(build.std_features())\n-         .arg(\"-p\").arg(\"std\");\n+         .arg(\"--features\").arg(build.std_features());\n+\n+    // We don't want to build docs for internal std dependencies unless\n+    // in compiler-docs mode. When not in that mode, we whitelist the crates\n+    // for which docs must be built.\n+    if build.config.compiler_docs {\n+        cargo.arg(\"-p\").arg(\"std\");\n+    } else {\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"alloc\", \"collections\", \"core\", \"std\", \"std_unicode\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+            // Create all crate output directories first to make sure rustdoc uses\n+            // relative links.\n+            // FIXME: Cargo should probably do this itself.\n+            t!(fs::create_dir_all(out_dir.join(krate)));\n+        }\n+    }\n+\n+\n     build.run(&mut cargo);\n     cp_r(&out_dir, &out)\n }"}, {"sha": "1be823417d765263d9da89c38ffae598a5906c35", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -67,6 +67,7 @@ pub enum Subcommand {\n     },\n     Clean,\n     Dist {\n+        paths: Vec<PathBuf>,\n         install: bool,\n     },\n }\n@@ -249,6 +250,7 @@ To learn more about a subcommand, run `./x.py <command> -h`\n                 opts.optflag(\"\", \"install\", \"run installer as well\");\n                 m = parse(&opts);\n                 Subcommand::Dist {\n+                    paths: remaining_as_path(&m),\n                     install: m.opt_present(\"install\"),\n                 }\n             }"}, {"sha": "efc460f35838c3c4bc1e6e5ec4b6072700bcb249", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,33 +13,45 @@\n //! This module is responsible for installing the standard library,\n //! compiler, and documentation.\n \n+use std::env;\n use std::fs;\n-use std::borrow::Cow;\n-use std::path::Path;\n+use std::path::{Path, PathBuf, Component};\n use std::process::Command;\n \n use Build;\n use dist::{package_vers, sanitize_sh, tmpdir};\n \n /// Installs everything.\n pub fn install(build: &Build, stage: u32, host: &str) {\n-    let prefix = build.config.prefix.as_ref().clone().map(|x| Path::new(x))\n-        .unwrap_or(Path::new(\"/usr/local\"));\n-    let docdir = build.config.docdir.as_ref().clone().map(|x| Cow::Borrowed(Path::new(x)))\n-        .unwrap_or(Cow::Owned(prefix.join(\"share/doc/rust\")));\n-    let libdir = build.config.libdir.as_ref().clone().map(|x| Cow::Borrowed(Path::new(x)))\n-        .unwrap_or(Cow::Owned(prefix.join(\"lib\")));\n-    let mandir = build.config.mandir.as_ref().clone().map(|x| Cow::Borrowed(Path::new(x)))\n-        .unwrap_or(Cow::Owned(prefix.join(\"share/man\")));\n+    let prefix_default = PathBuf::from(\"/usr/local\");\n+    let docdir_default = PathBuf::from(\"share/doc/rust\");\n+    let mandir_default = PathBuf::from(\"share/man\");\n+    let libdir_default = PathBuf::from(\"lib\");\n+    let prefix = build.config.prefix.as_ref().unwrap_or(&prefix_default);\n+    let docdir = build.config.docdir.as_ref().unwrap_or(&docdir_default);\n+    let libdir = build.config.libdir.as_ref().unwrap_or(&libdir_default);\n+    let mandir = build.config.mandir.as_ref().unwrap_or(&mandir_default);\n+\n+    let docdir = prefix.join(docdir);\n+    let libdir = prefix.join(libdir);\n+    let mandir = prefix.join(mandir);\n+\n+    let destdir = env::var_os(\"DESTDIR\").map(PathBuf::from);\n+\n+    let prefix = add_destdir(&prefix, &destdir);\n+    let docdir = add_destdir(&docdir, &destdir);\n+    let libdir = add_destdir(&libdir, &destdir);\n+    let mandir = add_destdir(&mandir, &destdir);\n+\n     let empty_dir = build.out.join(\"tmp/empty_dir\");\n     t!(fs::create_dir_all(&empty_dir));\n     if build.config.docs {\n-        install_sh(&build, \"docs\", \"rust-docs\", stage, host, prefix,\n+        install_sh(&build, \"docs\", \"rust-docs\", stage, host, &prefix,\n                    &docdir, &libdir, &mandir, &empty_dir);\n     }\n-    install_sh(&build, \"std\", \"rust-std\", stage, host, prefix,\n+    install_sh(&build, \"std\", \"rust-std\", stage, host, &prefix,\n                &docdir, &libdir, &mandir, &empty_dir);\n-    install_sh(&build, \"rustc\", \"rustc\", stage, host, prefix,\n+    install_sh(&build, \"rustc\", \"rustc\", stage, host, &prefix,\n                &docdir, &libdir, &mandir, &empty_dir);\n     t!(fs::remove_dir_all(&empty_dir));\n }\n@@ -59,3 +71,17 @@ fn install_sh(build: &Build, package: &str, name: &str, stage: u32, host: &str,\n        .arg(\"--disable-ldconfig\");\n     build.run(&mut cmd);\n }\n+\n+fn add_destdir(path: &Path, destdir: &Option<PathBuf>) -> PathBuf {\n+    let mut ret = match *destdir {\n+        Some(ref dest) => dest.clone(),\n+        None => return path.to_path_buf(),\n+    };\n+    for part in path.components() {\n+        match part {\n+            Component::Normal(s) => ret.push(s),\n+            _ => {}\n+        }\n+    }\n+    return ret\n+}"}, {"sha": "65f3d241b491b18f2bf8e02f519966f1edf19956", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 441, "deletions": 26, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -316,7 +316,6 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n               \"codegen-units\");\n         suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n               \"incremental\");\n-        suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n     }\n \n     if build.config.build.contains(\"msvc\") {\n@@ -363,8 +362,11 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n                  });\n         };\n \n+        suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n         suite(\"check-rpass-full\", \"src/test/run-pass-fulldeps\",\n               \"run-pass\", \"run-pass-fulldeps\");\n+        suite(\"check-rfail-full\", \"src/test/run-fail-fulldeps\",\n+              \"run-fail\", \"run-fail-fulldeps\");\n         suite(\"check-cfail-full\", \"src/test/compile-fail-fulldeps\",\n               \"compile-fail\", \"compile-fail-fulldeps\");\n         suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n@@ -459,6 +461,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|s| s.name(\"tool-tidy\").stage(0))\n          .default(true)\n          .host(true)\n+         .only_build(true)\n          .run(move |s| check::tidy(build, s.target));\n     rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n          .dep(|s| s.name(\"libstd\"))\n@@ -482,6 +485,12 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|s| s.name(\"libtest\"))\n          .run(move |s| check::android_copy_libs(build, &s.compiler(), s.target));\n \n+    rules.test(\"check-bootstrap\", \"src/bootstrap\")\n+         .default(true)\n+         .host(true)\n+         .only_build(true)\n+         .run(move |_| check::bootstrap(build));\n+\n     // ========================================================================\n     // Build tools\n     //\n@@ -508,17 +517,32 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     // ========================================================================\n     // Documentation targets\n     rules.doc(\"doc-book\", \"src/doc/book\")\n-         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build).stage(0))\n+         .dep(move |s| {\n+             s.name(\"tool-rustbook\")\n+              .host(&build.config.build)\n+              .target(&build.config.build)\n+              .stage(0)\n+         })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"book\"));\n     rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n-         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build).stage(0))\n+         .dep(move |s| {\n+             s.name(\"tool-rustbook\")\n+              .host(&build.config.build)\n+              .target(&build.config.build)\n+              .stage(0)\n+         })\n          .default(build.config.docs)\n          .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n     rules.doc(\"doc-standalone\", \"src/doc\")\n-         .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(&build.config.build))\n+         .dep(move |s| {\n+             s.name(\"rustc\")\n+              .host(&build.config.build)\n+              .target(&build.config.build)\n+              .stage(0)\n+         })\n          .default(build.config.docs)\n-         .run(move |s| doc::standalone(build, s.stage, s.target));\n+         .run(move |s| doc::standalone(build, s.target));\n     rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n          .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build).stage(0))\n          .dep(move |s| s.name(\"librustc-link\").stage(0))\n@@ -550,6 +574,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.dist(\"dist-rustc\", \"src/librustc\")\n          .dep(move |s| s.name(\"rustc\").host(&build.config.build))\n          .host(true)\n+         .only_host_build(true)\n          .default(true)\n          .run(move |s| dist::rustc(build, s.stage, s.target));\n     rules.dist(\"dist-std\", \"src/libstd\")\n@@ -564,9 +589,11 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n              }\n          })\n          .default(true)\n+         .only_host_build(true)\n          .run(move |s| dist::std(build, &s.compiler(), s.target));\n     rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n          .default(true)\n+         .only_host_build(true)\n          .run(move |s| {\n              if s.target.contains(\"pc-windows-gnu\") {\n                  dist::mingw(build, s.target)\n@@ -575,16 +602,20 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.dist(\"dist-src\", \"src\")\n          .default(true)\n          .host(true)\n-         .run(move |s| dist::rust_src(build, s.target));\n+         .only_build(true)\n+         .only_host_build(true)\n+         .run(move |_| dist::rust_src(build));\n     rules.dist(\"dist-docs\", \"src/doc\")\n          .default(true)\n+         .only_host_build(true)\n          .dep(|s| s.name(\"default:doc\"))\n          .run(move |s| dist::docs(build, s.stage, s.target));\n     rules.dist(\"dist-analysis\", \"analysis\")\n          .dep(|s| s.name(\"dist-std\"))\n          .default(true)\n+         .only_host_build(true)\n          .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n-    rules.dist(\"install\", \"src\")\n+    rules.dist(\"install\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"default:dist\"))\n          .run(move |s| install::install(build, s.stage, s.target));\n \n@@ -671,6 +702,14 @@ struct Rule<'a> {\n     /// only intended for compiler hosts and not for targets that are being\n     /// generated.\n     host: bool,\n+\n+    /// Whether this rule is only for steps where the host is the build triple,\n+    /// not anything in hosts or targets.\n+    only_host_build: bool,\n+\n+    /// Whether this rule is only for the build triple, not anything in hosts or\n+    /// targets.\n+    only_build: bool,\n }\n \n #[derive(PartialEq)]\n@@ -692,6 +731,8 @@ impl<'a> Rule<'a> {\n             kind: kind,\n             default: false,\n             host: false,\n+            only_host_build: false,\n+            only_build: false,\n         }\n     }\n }\n@@ -727,6 +768,16 @@ impl<'a, 'b> RuleBuilder<'a, 'b> {\n         self.rule.host = host;\n         self\n     }\n+\n+    fn only_build(&mut self, only_build: bool) -> &mut Self {\n+        self.rule.only_build = only_build;\n+        self\n+    }\n+\n+    fn only_host_build(&mut self, only_host_build: bool) -> &mut Self {\n+        self.rule.only_host_build = only_host_build;\n+        self\n+    }\n }\n \n impl<'a, 'b> Drop for RuleBuilder<'a, 'b> {\n@@ -881,11 +932,11 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, test_args: _ } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, test_args: _ } => (Kind::Bench, &paths[..]),\n-            Subcommand::Dist { install } => {\n+            Subcommand::Dist { ref paths, install } => {\n                 if install {\n                     return vec![self.sbuild.name(\"install\")]\n                 } else {\n-                    (Kind::Dist, &[][..])\n+                    (Kind::Dist, &paths[..])\n                 }\n             }\n             Subcommand::Clean => panic!(),\n@@ -896,19 +947,12 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n                 path.ends_with(rule.path)\n             })\n         }).flat_map(|rule| {\n-            let hosts = if self.build.flags.host.len() > 0 {\n+            let hosts = if rule.only_host_build || rule.only_build {\n+                &self.build.config.host[..1]\n+            } else if self.build.flags.host.len() > 0 {\n                 &self.build.flags.host\n             } else {\n-                if kind == Kind::Dist {\n-                    // For 'dist' steps we only distribute artifacts built from\n-                    // the build platform, so only consider that in the hosts\n-                    // array.\n-                    // NOTE: This relies on the fact that the build triple is\n-                    // always placed first, as done in `config.rs`.\n-                    &self.build.config.host[..1]\n-                } else {\n-                    &self.build.config.host\n-                }\n+                &self.build.config.host\n             };\n             let targets = if self.build.flags.target.len() > 0 {\n                 &self.build.flags.target\n@@ -928,6 +972,8 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n                     &self.build.flags.host[..]\n                 } else if self.build.flags.target.len() > 0 {\n                     &[]\n+                } else if rule.only_build {\n+                    &self.build.config.host[..1]\n                 } else {\n                     &self.build.config.host[..]\n                 }\n@@ -955,12 +1001,7 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n \n         // Using `steps` as the top-level targets, make a topological ordering\n         // of what we need to do.\n-        let mut order = Vec::new();\n-        let mut added = HashSet::new();\n-        added.insert(Step::noop());\n-        for step in steps.iter().cloned() {\n-            self.fill(step, &mut order, &mut added);\n-        }\n+        let order = self.expand(steps);\n \n         // Print out what we're doing for debugging\n         self.build.verbose(\"bootstrap build plan:\");\n@@ -979,6 +1020,18 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n     }\n \n+    /// From the top level targets `steps` generate a topological ordering of\n+    /// all steps needed to run those steps.\n+    fn expand(&self, steps: &[Step<'a>]) -> Vec<Step<'a>> {\n+        let mut order = Vec::new();\n+        let mut added = HashSet::new();\n+        added.insert(Step::noop());\n+        for step in steps.iter().cloned() {\n+            self.fill(step, &mut order, &mut added);\n+        }\n+        return order\n+    }\n+\n     /// Performs topological sort of dependencies rooted at the `step`\n     /// specified, pushing all results onto the `order` vector provided.\n     ///\n@@ -1015,3 +1068,365 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         order.push(step);\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::env;\n+\n+    use Build;\n+    use config::Config;\n+    use flags::Flags;\n+\n+    macro_rules! a {\n+        ($($a:expr),*) => (vec![$($a.to_string()),*])\n+    }\n+\n+    fn build(args: &[&str],\n+             extra_host: &[&str],\n+             extra_target: &[&str]) -> Build {\n+        let mut args = args.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n+        args.push(\"--build\".to_string());\n+        args.push(\"A\".to_string());\n+        let flags = Flags::parse(&args);\n+\n+        let mut config = Config::default();\n+        config.docs = true;\n+        config.build = \"A\".to_string();\n+        config.host = vec![config.build.clone()];\n+        config.host.extend(extra_host.iter().map(|s| s.to_string()));\n+        config.target = config.host.clone();\n+        config.target.extend(extra_target.iter().map(|s| s.to_string()));\n+\n+        let mut build = Build::new(flags, config);\n+        let cwd = env::current_dir().unwrap();\n+        build.crates.insert(\"std_shim\".to_string(), ::Crate {\n+            name: \"std_shim\".to_string(),\n+            deps: Vec::new(),\n+            path: cwd.join(\"src/std_shim\"),\n+            doc_step: \"doc-std_shim\".to_string(),\n+            build_step: \"build-crate-std_shim\".to_string(),\n+            test_step: \"test-std_shim\".to_string(),\n+            bench_step: \"bench-std_shim\".to_string(),\n+        });\n+        build.crates.insert(\"test_shim\".to_string(), ::Crate {\n+            name: \"test_shim\".to_string(),\n+            deps: Vec::new(),\n+            path: cwd.join(\"src/test_shim\"),\n+            doc_step: \"doc-test_shim\".to_string(),\n+            build_step: \"build-crate-test_shim\".to_string(),\n+            test_step: \"test-test_shim\".to_string(),\n+            bench_step: \"bench-test_shim\".to_string(),\n+        });\n+        build.crates.insert(\"rustc-main\".to_string(), ::Crate {\n+            name: \"rustc-main\".to_string(),\n+            deps: Vec::new(),\n+            path: cwd.join(\"src/rustc-main\"),\n+            doc_step: \"doc-rustc-main\".to_string(),\n+            build_step: \"build-crate-rustc-main\".to_string(),\n+            test_step: \"test-rustc-main\".to_string(),\n+            bench_step: \"bench-rustc-main\".to_string(),\n+        });\n+        return build\n+    }\n+\n+    #[test]\n+    fn dist_baseline() {\n+        let build = build(&[\"dist\"], &[], &[]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+        assert!(plan.iter().all(|s| s.host == \"A\" ));\n+        assert!(plan.iter().all(|s| s.target == \"A\" ));\n+\n+        let step = super::Step {\n+            name: \"\",\n+            stage: 2,\n+            host: &build.config.build,\n+            target: &build.config.build,\n+        };\n+\n+        assert!(plan.contains(&step.name(\"dist-docs\")));\n+        assert!(plan.contains(&step.name(\"dist-mingw\")));\n+        assert!(plan.contains(&step.name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.name(\"dist-std\")));\n+        assert!(plan.contains(&step.name(\"dist-src\")));\n+    }\n+\n+    #[test]\n+    fn dist_with_targets() {\n+        let build = build(&[\"dist\"], &[], &[\"B\"]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+        assert!(plan.iter().all(|s| s.host == \"A\" ));\n+\n+        let step = super::Step {\n+            name: \"\",\n+            stage: 2,\n+            host: &build.config.build,\n+            target: &build.config.build,\n+        };\n+\n+        assert!(plan.contains(&step.name(\"dist-docs\")));\n+        assert!(plan.contains(&step.name(\"dist-mingw\")));\n+        assert!(plan.contains(&step.name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.name(\"dist-std\")));\n+        assert!(plan.contains(&step.name(\"dist-src\")));\n+\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n+        assert!(!plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n+        assert!(!plan.contains(&step.target(\"B\").name(\"dist-src\")));\n+    }\n+\n+    #[test]\n+    fn dist_with_hosts() {\n+        let build = build(&[\"dist\"], &[\"B\"], &[]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+\n+        let step = super::Step {\n+            name: \"\",\n+            stage: 2,\n+            host: &build.config.build,\n+            target: &build.config.build,\n+        };\n+\n+        assert!(!plan.iter().any(|s| s.host == \"B\"));\n+\n+        assert!(plan.contains(&step.name(\"dist-docs\")));\n+        assert!(plan.contains(&step.name(\"dist-mingw\")));\n+        assert!(plan.contains(&step.name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.name(\"dist-std\")));\n+        assert!(plan.contains(&step.name(\"dist-src\")));\n+\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n+        assert!(!plan.contains(&step.target(\"B\").name(\"dist-src\")));\n+    }\n+\n+    #[test]\n+    fn dist_with_targets_and_hosts() {\n+        let build = build(&[\"dist\"], &[\"B\"], &[\"C\"]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+\n+        let step = super::Step {\n+            name: \"\",\n+            stage: 2,\n+            host: &build.config.build,\n+            target: &build.config.build,\n+        };\n+\n+        assert!(!plan.iter().any(|s| s.host == \"B\"));\n+        assert!(!plan.iter().any(|s| s.host == \"C\"));\n+\n+        assert!(plan.contains(&step.name(\"dist-docs\")));\n+        assert!(plan.contains(&step.name(\"dist-mingw\")));\n+        assert!(plan.contains(&step.name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.name(\"dist-std\")));\n+        assert!(plan.contains(&step.name(\"dist-src\")));\n+\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n+        assert!(!plan.contains(&step.target(\"B\").name(\"dist-src\")));\n+\n+        assert!(plan.contains(&step.target(\"C\").name(\"dist-docs\")));\n+        assert!(plan.contains(&step.target(\"C\").name(\"dist-mingw\")));\n+        assert!(!plan.contains(&step.target(\"C\").name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.target(\"C\").name(\"dist-std\")));\n+        assert!(!plan.contains(&step.target(\"C\").name(\"dist-src\")));\n+    }\n+\n+    #[test]\n+    fn dist_target_with_target_flag() {\n+        let build = build(&[\"dist\", \"--target=C\"], &[\"B\"], &[\"C\"]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+\n+        let step = super::Step {\n+            name: \"\",\n+            stage: 2,\n+            host: &build.config.build,\n+            target: &build.config.build,\n+        };\n+\n+        assert!(!plan.iter().any(|s| s.target == \"A\"));\n+        assert!(!plan.iter().any(|s| s.target == \"B\"));\n+        assert!(!plan.iter().any(|s| s.host == \"B\"));\n+        assert!(!plan.iter().any(|s| s.host == \"C\"));\n+\n+        assert!(plan.contains(&step.target(\"C\").name(\"dist-docs\")));\n+        assert!(plan.contains(&step.target(\"C\").name(\"dist-mingw\")));\n+        assert!(!plan.contains(&step.target(\"C\").name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.target(\"C\").name(\"dist-std\")));\n+        assert!(!plan.contains(&step.target(\"C\").name(\"dist-src\")));\n+    }\n+\n+    #[test]\n+    fn dist_host_with_target_flag() {\n+        let build = build(&[\"dist\", \"--host=B\", \"--target=B\"], &[\"B\"], &[\"C\"]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+\n+        let step = super::Step {\n+            name: \"\",\n+            stage: 2,\n+            host: &build.config.build,\n+            target: &build.config.build,\n+        };\n+\n+        assert!(!plan.iter().any(|s| s.target == \"A\"));\n+        assert!(!plan.iter().any(|s| s.target == \"C\"));\n+        assert!(!plan.iter().any(|s| s.host == \"B\"));\n+        assert!(!plan.iter().any(|s| s.host == \"C\"));\n+\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-docs\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-mingw\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-rustc\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-std\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"dist-src\")));\n+\n+        let all = rules.expand(&plan);\n+        println!(\"all rules: {:#?}\", all);\n+        assert!(!all.contains(&step.name(\"rustc\")));\n+        assert!(!all.contains(&step.name(\"build-crate-std_shim\").stage(1)));\n+    }\n+\n+    #[test]\n+    fn build_default() {\n+        let build = build(&[\"build\"], &[\"B\"], &[\"C\"]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+\n+        let step = super::Step {\n+            name: \"\",\n+            stage: 2,\n+            host: &build.config.build,\n+            target: &build.config.build,\n+        };\n+\n+        // rustc built for all for of (A, B) x (A, B)\n+        assert!(plan.contains(&step.name(\"librustc\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"librustc\")));\n+        assert!(plan.contains(&step.host(\"B\").target(\"A\").name(\"librustc\")));\n+        assert!(plan.contains(&step.host(\"B\").target(\"B\").name(\"librustc\")));\n+\n+        // rustc never built for C\n+        assert!(!plan.iter().any(|s| {\n+            s.name.contains(\"rustc\") && (s.host == \"C\" || s.target == \"C\")\n+        }));\n+\n+        // test built for everything\n+        assert!(plan.contains(&step.name(\"libtest\")));\n+        assert!(plan.contains(&step.target(\"B\").name(\"libtest\")));\n+        assert!(plan.contains(&step.host(\"B\").target(\"A\").name(\"libtest\")));\n+        assert!(plan.contains(&step.host(\"B\").target(\"B\").name(\"libtest\")));\n+        assert!(plan.contains(&step.host(\"A\").target(\"C\").name(\"libtest\")));\n+        assert!(plan.contains(&step.host(\"B\").target(\"C\").name(\"libtest\")));\n+\n+        let all = rules.expand(&plan);\n+        println!(\"all rules: {:#?}\", all);\n+        assert!(all.contains(&step.name(\"rustc\")));\n+        assert!(all.contains(&step.name(\"libstd\")));\n+    }\n+\n+    #[test]\n+    fn build_filtered() {\n+        let build = build(&[\"build\", \"--target=C\"], &[\"B\"], &[\"C\"]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+\n+        assert!(!plan.iter().any(|s| s.name.contains(\"rustc\")));\n+        assert!(plan.iter().all(|s| {\n+            !s.name.contains(\"test_shim\") || s.target == \"C\"\n+        }));\n+    }\n+\n+    #[test]\n+    fn test_default() {\n+        let build = build(&[\"test\"], &[], &[]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+        assert!(plan.iter().all(|s| s.host == \"A\"));\n+        assert!(plan.iter().all(|s| s.target == \"A\"));\n+\n+        assert!(plan.iter().any(|s| s.name.contains(\"-ui\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"cfail\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"cfail-full\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"codegen-units\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"debuginfo\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"docs\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"error-index\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"incremental\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"linkchecker\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"mir-opt\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"pfail\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rfail\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rfail-full\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rmake\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rpass\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rpass-full\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rustc-all\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rustdoc\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"std-all\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"test-all\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"tidy\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"valgrind\")));\n+    }\n+\n+    #[test]\n+    fn test_with_a_target() {\n+        let build = build(&[\"test\", \"--target=C\"], &[], &[\"C\"]);\n+        let rules = super::build_rules(&build);\n+        let plan = rules.plan();\n+        println!(\"rules: {:#?}\", plan);\n+        assert!(plan.iter().all(|s| s.stage == 2));\n+        assert!(plan.iter().all(|s| s.host == \"A\"));\n+        assert!(plan.iter().all(|s| s.target == \"C\"));\n+\n+        assert!(!plan.iter().any(|s| s.name.contains(\"-ui\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"cfail\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"cfail-full\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"codegen-units\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"debuginfo\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"docs\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"error-index\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"incremental\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"linkchecker\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"mir-opt\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"pfail\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rfail\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"rfail-full\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"rmake\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"rpass\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"rpass-full\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"rustc-all\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"rustdoc\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"std-all\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"test-all\")));\n+        assert!(!plan.iter().any(|s| s.name.contains(\"tidy\")));\n+        assert!(plan.iter().any(|s| s.name.contains(\"valgrind\")));\n+    }\n+}"}, {"sha": "e2ef8070b51afb1aedcf19f4187e3cee396c03d0", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -48,4 +48,9 @@ ENV RUST_CONFIGURE_ARGS \\\n       --armv7-linux-androideabi-ndk=/android/ndk-arm-9 \\\n       --i686-linux-android-ndk=/android/ndk-x86-9 \\\n       --aarch64-linux-android-ndk=/android/ndk-aarch64\n-ENV XPY_CHECK test --target arm-linux-androideabi\n+\n+# Just a smoke test in dist to see if this works for now, we should expand this\n+# to all the targets above eventually.\n+ENV SCRIPT \\\n+  python2.7 ../x.py test --target arm-linux-androideabi && \\\n+  python2.7 ../x.py dist --target arm-linux-androideabi"}, {"sha": "24c477d87f1a72975a3f0fb650d37b3e82dd3f99", "filename": "src/ci/docker/arm-android/start-emulator.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Fstart-emulator.sh?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,5 +13,4 @@ set -ex\n ANDROID_EMULATOR_FORCE_32BIT=true \\\n   nohup nohup emulator @arm-18 -no-window -partition-size 2047 \\\n   0<&- &>/dev/null &\n-adb wait-for-device\n exec \"$@\""}, {"sha": "6a6cc23698be2dfeb0fd6fd9446190c44d62e141", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -56,7 +56,12 @@ ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n ENV RUST_CONFIGURE_ARGS \\\n       --target=$TARGETS \\\n       --enable-rustbuild\n-ENV RUST_CHECK_TARGET \"\"\n+\n+# Just a smoke test in dist to see if this works for now, we should expand this\n+# to all the targets above eventually.\n+ENV SCRIPT \\\n+  python2.7 ../x.py build && \\\n+  python2.7 ../x.py dist --target wasm32-unknown-emscripten\n \n ENV AR_s390x_unknown_linux_gnu=s390x-linux-gnu-ar \\\n     CC_s390x_unknown_linux_gnu=s390x-linux-gnu-gcc \\"}, {"sha": "841464a42700df563ac165ba9f39e8dc2c0da908", "filename": "src/ci/docker/dist-arm-unknown-linux-gnueabi/Dockerfile", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fdist-arm-unknown-linux-gnueabi%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fdist-arm-unknown-linux-gnueabi%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-unknown-linux-gnueabi%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -0,0 +1,30 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  g++-arm-linux-gnueabi\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV RUST_CONFIGURE_ARGS --host=arm-unknown-linux-gnueabi\n+ENV SCRIPT \\\n+      python2.7 ../x.py dist \\\n+        --host arm-unknown-linux-gnueabi \\\n+        --target arm-unknown-linux-gnueabi"}, {"sha": "44cc57c2662d648ba26521f205814ed1527f53c6", "filename": "src/ci/docker/dist-x86_64-unknown-freebsd/Dockerfile", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fdist-x86_64-unknown-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fdist-x86_64-unknown-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-unknown-freebsd%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -28,7 +28,11 @@ RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST |\n \n ENV \\\n     AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n-    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc\n+    CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc \\\n+    CXX_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-g++\n \n-ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd\n-ENV RUST_CHECK_TARGET \"\"\n+ENV RUST_CONFIGURE_ARGS --host=x86_64-unknown-freebsd\n+ENV SCRIPT \\\n+      python2.7 ../x.py dist \\\n+        --host x86_64-unknown-freebsd \\\n+        --target x86_64-unknown-freebsd", "previous_filename": "src/ci/docker/x86_64-freebsd/Dockerfile"}, {"sha": "0fd6beaf4c1c0c2291235b305442b536deabe660", "filename": "src/ci/docker/dist-x86_64-unknown-freebsd/build-toolchain.sh", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fdist-x86_64-unknown-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fdist-x86_64-unknown-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-unknown-freebsd%2Fbuild-toolchain.sh?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -77,7 +77,7 @@ cd gcc-$GCC\n mkdir ../gcc-build\n cd ../gcc-build\n ../gcc-$GCC/configure                            \\\n-  --enable-languages=c                           \\\n+  --enable-languages=c,c++                       \\\n   --target=$ARCH-unknown-freebsd10               \\\n   --disable-multilib                             \\\n   --disable-nls                                  \\", "previous_filename": "src/ci/docker/x86_64-freebsd/build-toolchain.sh"}, {"sha": "6583f09be368c5b2f2da522da01ab61b088d2a24", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,4 +23,4 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test && python2.7 ../x.py dist"}, {"sha": "79bb175630635fd02d65f2de28d80c486bb92c8a", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -48,7 +48,5 @@ exec docker \\\n   --env CARGO_HOME=/cargo \\\n   --env LOCAL_USER_ID=`id -u` \\\n   --volume \"$HOME/.cargo:/cargo\" \\\n-  --interactive \\\n-  --tty \\\n   rust-ci \\\n   /checkout/src/ci/run.sh"}, {"sha": "f54e4e562f889f694ea4ee917c911a9638d76819", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -26,4 +26,4 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\\n       --enable-optimize\n-ENV RUST_CHECK_TARGET \"\"\n+ENV SCRIPT python2.7 ../x.py build"}, {"sha": "57a2c103f1e7dc91a52d0fd493660fdf577b1edc", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,4 +23,4 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV XPY_RUN test distcheck\n+ENV SCRIPT python2.7 ../x.py test distcheck"}, {"sha": "206103b92e94df6b037094d34397681c42c3df82", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -25,4 +25,4 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-full-bootstrap\n-ENV RUST_CHECK_TARGET \"\"\n+ENV SCRIPT python2.7 ../x.py build"}, {"sha": "6919487e17c3e6f1a78fa3da13e48a522979e53f", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,4 +23,4 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test && python2.7 ../x.py dist"}, {"sha": "11b85a6c8fdfb24f58e018fee931cd00027a5584", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -29,6 +29,7 @@ RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST |\n ENV RUST_CONFIGURE_ARGS \\\n       --target=x86_64-unknown-linux-musl \\\n       --musl-root-x86_64=/musl-x86_64\n-ENV RUST_CHECK_TARGET check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu\n ENV PATH=$PATH:/musl-x86_64/bin\n-ENV XPY_CHECK test --target x86_64-unknown-linux-musl\n+ENV SCRIPT \\\n+      python2.7 ../x.py test --target x86_64-unknown-linux-musl && \\\n+      python2.7 ../x.py dist --target x86_64-unknown-linux-musl"}, {"sha": "737c3622c694e361bd054cea4f8ed3045a13aadd", "filename": "src/ci/run.sh", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -43,14 +43,10 @@ else\n     ncpus=$(nproc)\n fi\n \n-if [ ! -z \"$XPY_RUN\" ]; then\n-  exec python2.7 $SRC/x.py $XPY_RUN\n+if [ ! -z \"$SCRIPT\" ]; then\n+  sh -x -c \"$SCRIPT\"\n else\n   make -j $ncpus tidy\n   make -j $ncpus\n-  if [ ! -z \"$XPY_CHECK\" ]; then\n-    exec python2.7 $SRC/x.py $XPY_CHECK\n-  else\n-    exec make $RUST_CHECK_TARGET -j $ncpus\n-  fi\n+  make $RUST_CHECK_TARGET -j $ncpus\n fi"}, {"sha": "babbafa078f4a7b52c223da7e658c5ba6bd5276d", "filename": "src/doc/book/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2FSUMMARY.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -52,6 +52,7 @@\n     * [Borrow and AsRef](borrow-and-asref.md)\n     * [Release Channels](release-channels.md)\n     * [Using Rust without the standard library](using-rust-without-the-standard-library.md)\n+    * [Procedural Macros (and custom derive)](procedural-macros.md)\n * [Nightly Rust](nightly-rust.md)\n     * [Compiler Plugins](compiler-plugins.md)\n     * [Inline Assembly](inline-assembly.md)"}, {"sha": "50d4d0170fc70809c82b2dc392b3373f50b81f4c", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -309,7 +309,7 @@ However it is often desired that the callback is targeted to a special\n Rust object. This could be the object that represents the wrapper for the\n respective C object.\n \n-This can be achieved by passing an raw pointer to the object down to the\n+This can be achieved by passing a raw pointer to the object down to the\n C library. The C library can then include the pointer to the Rust object in\n the notification. This will allow the callback to unsafely access the\n referenced Rust object."}, {"sha": "0d6a142ca4f724c178f07987cc50e72f7a9dc962", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,15 +16,12 @@ and one for deallocation. A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n ```rust,ignore\n-#![feature(lang_items, box_syntax, start, libc)]\n+#![feature(lang_items, box_syntax, start, libc, core_intrinsics)]\n #![no_std]\n+use core::intrinsics;\n \n extern crate libc;\n \n-extern {\n-    fn abort() -> !;\n-}\n-\n #[lang = \"owned_box\"]\n pub struct Box<T>(*mut T);\n \n@@ -34,7 +31,7 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n \n     // Check if `malloc` failed:\n     if p as usize == 0 {\n-        abort();\n+        intrinsics::abort();\n     }\n \n     p\n@@ -58,7 +55,7 @@ fn main(argc: isize, argv: *const *const u8) -> isize {\n }\n \n #[lang = \"eh_personality\"] extern fn rust_eh_personality() {}\n-#[lang = \"panic_fmt\"] extern fn rust_begin_panic() -> ! { loop {} }\n+#[lang = \"panic_fmt\"] extern fn rust_begin_panic() -> ! { unsafe { intrinsics::abort() } }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n # #[no_mangle] pub extern fn rust_eh_register_frames () {}\n # #[no_mangle] pub extern fn rust_eh_unregister_frames () {}"}, {"sha": "79f0593be1780cffa167d3bb0cc95cd0a2fe0a8e", "filename": "src/doc/book/no-stdlib.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fno-stdlib.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -37,9 +37,10 @@ The function marked `#[start]` is passed the command line parameters\n in the same format as C:\n \n ```rust,ignore\n-#![feature(lang_items)]\n+#![feature(lang_items, core_intrinsics)]\n #![feature(start)]\n #![no_std]\n+use core::intrinsics;\n \n // Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n@@ -69,7 +70,7 @@ pub extern fn rust_eh_unwind_resume() {\n pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n                                _file: &'static str,\n                                _line: u32) -> ! {\n-    loop {}\n+    unsafe { intrinsics::abort() }\n }\n ```\n \n@@ -79,10 +80,11 @@ correct ABI and the correct name, which requires overriding the\n compiler's name mangling too:\n \n ```rust,ignore\n-#![feature(lang_items)]\n+#![feature(lang_items, core_intrinsics)]\n #![feature(start)]\n #![no_std]\n #![no_main]\n+use core::intrinsics;\n \n // Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n@@ -112,7 +114,7 @@ pub extern fn rust_eh_unwind_resume() {\n pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n                                _file: &'static str,\n                                _line: u32) -> ! {\n-    loop {}\n+    unsafe { intrinsics::abort() }\n }\n ```\n "}, {"sha": "37d3d20c06d966391a0f9241dc1bfe2953365113", "filename": "src/doc/book/procedural-macros.md", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fprocedural-macros.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -0,0 +1,213 @@\n+% Procedural Macros (and custom Derive)\n+\n+As you've seen throughout the rest of the book, Rust provides a mechanism\n+called \"derive\" that lets you implement traits easily. For example,\n+\n+```rust\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+```\n+\n+is a lot simpler than\n+\n+```rust\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+use std::fmt;\n+\n+impl fmt::Debug for Point {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Point {{ x: {}, y: {} }}\", self.x, self.y)\n+    }\n+}\n+```\n+\n+Rust includes several traits that you can derive, but it also lets you define\n+your own. We can accomplish this task through a feature of Rust called\n+\"procedural macros.\" Eventually, procedural macros will allow for all sorts of\n+advanced metaprogramming in Rust, but today, they're only for custom derive.\n+\n+Let's build a very simple trait, and derive it with custom derive.\n+\n+## Hello World\n+\n+So the first thing we need to do is start a new crate for our project.\n+\n+```bash\n+$ cargo new --bin hello-world\n+```\n+\n+All we want is to be able to call `hello_world()` on a derived type. Something\n+like this:\n+\n+```rust,ignore\n+#[derive(HelloWorld)]\n+struct Pancakes;\n+\n+fn main() {\n+    Pancakes::hello_world();\n+}\n+```\n+\n+With some kind of nice output, like `Hello, World! My name is Pancakes.`. \n+\n+Let's go ahead and write up what we think our macro will look like from a user\n+perspective. In `src/main.rs` we write:\n+\n+```rust,ignore\n+#[macro_use]\n+extern crate hello_world_derive;\n+\n+trait HelloWorld {\n+    fn hello_world();\n+}\n+\n+#[derive(HelloWorld)]\n+struct FrenchToast;\n+\n+#[derive(HelloWorld)]\n+struct Waffles;\n+\n+fn main() {\n+    FrenchToast::hello_world();\n+    Waffles::hello_world();\n+}\n+```\n+\n+Great. So now we just need to actually write the procedural macro. At the\n+moment, procedural macros need to be in their own crate. Eventually, this\n+restriction may be lifted, but for now, it's required. As such, there's a\n+convention; for a crate named `foo`, a custom derive procedural macro is called\n+`foo-derive`. Let's start a new crate called `hello-world-derive` inside our\n+`hello-world` project.\n+\n+```bash\n+$ cargo new hello-world-derive\n+```\n+\n+To make sure that our `hello-world` crate is able to find this new crate we've\n+created, we'll add it to our toml:\n+\n+```toml\n+[dependencies]\n+hello-world-derive = { path = \"hello-world-derive\" }\n+```\n+\n+As for our the source of our `hello-world-derive` crate, here's an example:\n+\n+```rust,ignore\n+extern crate proc_macro;\n+extern crate syn;\n+#[macro_use]\n+extern crate quote;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(HelloWorld)]\n+pub fn hello_world(input: TokenStream) -> TokenStream {\n+    // Construct a string representation of the type definition\n+    let s = input.to_string();\n+    \n+    // Parse the string representation\n+    let ast = syn::parse_macro_input(&s).unwrap();\n+\n+    // Build the impl\n+    let gen = impl_hello_world(&ast);\n+    \n+    // Return the generated impl\n+    gen.parse().unwrap()\n+}\n+```\n+\n+So there is a lot going on here. We have introduced two new crates: [`syn`] and\n+[`quote`]. As you may have noticed, `input: TokenSteam` is immediately converted\n+to a `String`. This `String` is a string representation of the Rust code for which\n+we are deriving `HelloWorld` for. At the moment, the only thing you can do with a\n+`TokenStream` is convert it to a string. A richer API will exist in the future.\n+\n+So what we really need is to be able to _parse_ Rust code into something\n+usable. This is where `syn` comes to play. `syn` is a crate for parsing Rust\n+code. The other crate we've introduced is `quote`. It's essentially the dual of\n+`syn` as it will make generating Rust code really easy. We could write this\n+stuff on our own, but it's much simpler to use these libraries. Writing a full\n+parser for Rust code is no simple task.\n+\n+[`syn`]: https://crates.io/crates/syn\n+[`quote`]: https://crates.io/crates/quote\n+\n+The comments seem to give us a pretty good idea of our overall strategy. We\n+are going to take a `String` of the Rust code for the type we are deriving, parse\n+it using `syn`, construct the implementation of `hello_world` (using `quote`),\n+then pass it back to Rust compiler.\n+\n+One last note: you'll see some `unwrap()`s there. If you want to provide an\n+error for a procedural macro, then you should `panic!` with the error message.\n+In this case, we're keeping it as simple as possible.\n+\n+Great, so let's write `impl_hello_world(&ast)`.\n+\n+```rust,ignore\n+fn impl_hello_world(ast: &syn::MacroInput) -> quote::Tokens {\n+    let name = &ast.ident;\n+    quote! {\n+        impl HelloWorld for #name {\n+            fn hello_world() {\n+                println!(\"Hello, World! My name is {}\", stringify!(#name));\n+            }\n+        }\n+    }\n+}\n+```\n+\n+So this is where quotes comes in. The `ast` argument is a struct that gives us\n+a representation of our type (which can be either a `struct` or an `enum`).\n+Check out the [docs](https://docs.rs/syn/0.10.5/syn/struct.MacroInput.html),\n+there is some useful information there. We are able to get the name of the\n+type using `ast.ident`. The `quote!` macro let's us write up the Rust code\n+that we wish to return and convert it into `Tokens`. `quote!` let's us use some\n+really cool templating mechanics; we simply write `#name` and `quote!` will\n+replace it with the variable named `name`. You can even do some repetition\n+similar to regular macros work. You should check out the\n+[docs](https://docs.rs/quote) for a good introduction.\n+\n+So I think that's it. Oh, well, we do need to add dependencies for `syn` and\n+`quote` in the `cargo.toml` for `hello-world-derive`.\n+\n+```toml\n+[dependencies]\n+syn = \"0.10.5\"\n+quote = \"0.3.10\"\n+```\n+\n+That should be it. Let's try to compile `hello-world`.\n+\n+```bash\n+error: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type\n+ --> hello-world-derive/src/lib.rs:8:3\n+  |\n+8 | #[proc_macro_derive(HelloWorld)]\n+  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+```\n+\n+Oh, so it appears that we need to declare that our `hello-world-derive` crate is\n+a `proc-macro` crate type. How do we do this? Like this:\n+\n+```toml\n+[lib]\n+proc-macro = true\n+```\n+\n+Ok so now, let's compile `hello-world`. Executing `cargo run` now yields:\n+\n+```bash\n+Hello, World! My name is FrenchToast\n+Hello, World! My name is Waffles\n+```\n+\n+We've done it!"}, {"sha": "a2146b669e3c6d65dfad480a03e89106326af2fc", "filename": "src/doc/book/strings.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fbook%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstrings.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -163,8 +163,8 @@ let hachi = &dog[0..2];\n with this error:\n \n ```text\n-thread 'main' panicked at 'index 0 and/or 2 in `\u5fe0\u72ac\u30cf\u30c1\u516c` do not lie on\n-character boundary'\n+thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside '\u5fe0'\n+(bytes 0..3) of `\u5fe0\u72ac\u30cf\u30c1\u516c`'\n ```\n \n ## Concatenation"}, {"sha": "b699946cecaa2314d94072b1ef644ab3cc2b4f11", "filename": "src/doc/nomicon/coercions.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fnomicon%2Fcoercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fnomicon%2Fcoercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fcoercions.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -17,6 +17,7 @@ Coercion is allowed between the following types:\n     * `&T` to `*const T`\n     * `&mut T` to `*mut T`\n * Unsizing: `T` to `U` if `T` implements `CoerceUnsized<U>`\n+* Deref coercion: Expression `&x` of type `&T` to `&*x` of type `&U` if `T` derefs to `U` (i.e. `T: Deref<Target=U>`)\n \n `CoerceUnsized<Pointer<U>> for Pointer<T> where T: Unsize<U>` is implemented\n for all pointer types (including smart pointers like Box and Rc). Unsize is\n@@ -27,8 +28,9 @@ only implemented automatically, and enables the following transformations:\n * `Foo<..., T, ...>` => `Foo<..., U, ...>` where:\n     * `T: Unsize<U>`\n     * `Foo` is a struct\n-    * Only the last field of `Foo` has type `T`\n+    * Only the last field of `Foo` has type involving `T`\n     * `T` is not part of the type of any other fields\n+    * `Bar<T>: Unsize<Bar<U>>`, if the last field of `Foo` has type `Bar<T>`\n \n Coercions occur at a *coercion site*. Any location that is explicitly typed\n will cause a coercion to its type. If inference is necessary, the coercion will"}, {"sha": "f54933827b3305cff1b1864ce3bdac7c227beda3", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -125,7 +125,7 @@ is that some Drop implementations will not access borrowed data even\n though their type gives them the capability for such access.\n \n For example, this variant of the above `Inspector` example will never\n-accessed borrowed data:\n+access borrowed data:\n \n ```rust,ignore\n struct Inspector<'a>(&'a u8, &'static str);"}, {"sha": "1f3693f542f357848605fe9586678cbeac9f50c0", "filename": "src/doc/nomicon/unbounded-lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -11,7 +11,7 @@ lifetime can be regarded as `'static`.\n \n Almost no reference is `'static`, so this is probably wrong. `transmute` and\n `transmute_copy` are the two other primary offenders. One should endeavor to\n-bound an unbounded lifetime as quick as possible, especially across function\n+bound an unbounded lifetime as quickly as possible, especially across function\n boundaries.\n \n Given a function, any output lifetimes that don't derive from inputs are"}, {"sha": "4112b328f612ee380416aebe5763036126ea7efa", "filename": "src/doc/reference.md", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -555,26 +555,24 @@ mod a {\n # fn main() {}\n ```\n \n-# Syntax extensions\n+# Macros\n \n A number of minor features of Rust are not central enough to have their own\n syntax, and yet are not implementable as functions. Instead, they are given\n names, and invoked through a consistent syntax: `some_extension!(...)`.\n \n-Users of `rustc` can define new syntax extensions in two ways:\n-\n-* [Compiler plugins][plugin] can include arbitrary Rust code that\n-  manipulates syntax trees at compile time. Note that the interface\n-  for compiler plugins is considered highly unstable.\n+Users of `rustc` can define new macros in two ways:\n \n * [Macros](book/macros.html) define new syntax in a higher-level,\n   declarative way.\n+* [Procedural Macros][procedural macros] can be used to implement custom derive.\n+\n+And one unstable way: [compiler plugins][plugin].\n \n ## Macros\n \n `macro_rules` allows users to define syntax extension in a declarative way.  We\n-call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n-from the \"procedural macros\" defined in [compiler plugins][plugin].\n+call such extensions \"macros by example\" or simply \"macros\".\n \n Currently, macros can expand to expressions, statements, items, or patterns.\n \n@@ -652,6 +650,28 @@ Rust syntax is restricted in two ways:\n \n [RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\n \n+## Procedrual Macros\n+\n+\"Procedrual macros\" are the second way to implement a macro. For now, the only\n+thing they can be used for is to implement derive on your own types. See\n+[the book][procedural macros] for a tutorial.\n+\n+Procedural macros involve a few different parts of the language and its\n+standard libraries. First is the `proc_macro` crate, included with Rust,\n+that defines an interface for building a procedrual macro. The \n+`#[proc_macro_derive(Foo)]` attribute is used to mark the the deriving\n+function. This function must have the type signature:\n+\n+```rust,ignore\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Hello)]\n+pub fn hello_world(input: TokenStream) -> TokenStream\n+```\n+\n+Finally, procedural macros must be in their own crate, with the `proc-macro`\n+crate type.\n+\n # Crates and source files\n \n Although Rust, like any other language, can be implemented by an interpreter as\n@@ -2319,6 +2339,9 @@ impl<T: PartialEq> PartialEq for Foo<T> {\n }\n ```\n \n+You can implement `derive` for your own type through [procedural\n+macros](#procedural-macros).\n+\n ### Compiler Features\n \n Certain aspects of Rust may be implemented in the compiler, but they're not\n@@ -4122,6 +4145,16 @@ be ignored in favor of only building the artifacts specified by command line.\n   in dynamic libraries. This form of output is used to produce statically linked\n   executables as well as `staticlib` outputs.\n \n+* `--crate-type=proc-macro`, `#[crate_type = \"proc-macro\"]` - The output\n+  produced is not specified, but if a `-L` path is provided to it then the\n+  compiler will recognize the output artifacts as a macro and it can be loaded\n+  for a program. If a crate is compiled with the `proc-macro` crate type it\n+  will forbid exporting any items in the crate other than those functions\n+  tagged `#[proc_macro_derive]` and those functions must also be placed at the\n+  crate root. Finally, the compiler will automatically set the\n+  `cfg(proc_macro)` annotation whenever any crate type of a compilation is the\n+  `proc-macro` crate type.\n+\n Note that these outputs are stackable in the sense that if multiple are\n specified, then the compiler will produce each form of output at once without\n having to recompile. However, this only applies for outputs specified by the\n@@ -4299,3 +4332,4 @@ that have since been removed):\n \n [ffi]: book/ffi.html\n [plugin]: book/compiler-plugins.html\n+[procedural macros]: book/procedural-macros.html"}, {"sha": "e5389c112e81170057688808023024651a3d2912", "filename": "src/etc/unicode.py", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,10 +23,7 @@\n # Since this should not require frequent updates, we just store this\n # out-of-line and check the unicode.rs file into git.\n \n-import fileinput, re, os, sys, operator\n-\n-bytes_old = 0\n-bytes_new = 0\n+import fileinput, re, os, sys, operator, math\n \n preamble = '''// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n@@ -362,7 +359,23 @@ def emit_trie_lookup_range_table(f):\n         let leaf = r.r5[((child as usize) << 6) + ((c >> 6) & 0x3f)];\n         trie_range_leaf(c, r.r6[leaf as usize])\n     }\n-}\\n\n+}\n+\n+pub struct SmallBoolTrie {\n+    r1: &'static [u8],  // first level\n+    r2: &'static [u64],  // leaves\n+}\n+\n+impl SmallBoolTrie {\n+    fn lookup(&self, c: char) -> bool {\n+        let c = c as usize;\n+        match self.r1.get(c >> 6) {\n+            Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n+            None => false,\n+        }\n+    }\n+}\n+\n \"\"\")\n \n def compute_trie(rawdata, chunksize):\n@@ -379,8 +392,6 @@ def compute_trie(rawdata, chunksize):\n     return (root, child_data)\n \n def emit_bool_trie(f, name, t_data, is_pub=True):\n-    global bytes_old, bytes_new\n-    bytes_old += 8 * len(t_data)\n     CHUNK = 64\n     rawdata = [False] * 0x110000\n     for (lo, hi) in t_data:\n@@ -433,15 +444,50 @@ def emit_bool_trie(f, name, t_data, is_pub=True):\n     f.write(\"\\n        ],\\n\")\n \n     f.write(\"    };\\n\\n\")\n-    bytes_new += 256 + 992 + 256 + 8 * len(r3) + len(r5) + 8 * len(r6)\n+\n+def emit_small_bool_trie(f, name, t_data, is_pub=True):\n+    last_chunk = max(int(hi / 64) for (lo, hi) in t_data)\n+    n_chunks = last_chunk + 1\n+    chunks = [0] * n_chunks\n+    for (lo, hi) in t_data:\n+        for cp in range(lo, hi + 1):\n+            if int(cp / 64) >= len(chunks):\n+                print(cp, int(cp / 64), len(chunks), lo, hi)\n+            chunks[int(cp / 64)] |= 1 << (cp & 63)\n+\n+    pub_string = \"\"\n+    if is_pub:\n+        pub_string = \"pub \"\n+    f.write(\"    %sconst %s: &'static super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n+            % (pub_string, name))\n+\n+    (r1, r2) = compute_trie(chunks, 1)\n+\n+    f.write(\"        r1: &[\\n\")\n+    data = ','.join(str(node) for node in r1)\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+\n+    f.write(\"        r2: &[\\n\")\n+    data = ','.join('0x%016x' % node for node in r2)\n+    format_table_content(f, data, 12)\n+    f.write(\"\\n        ],\\n\")\n+\n+    f.write(\"    };\\n\\n\")\n \n def emit_property_module(f, mod, tbl, emit):\n     f.write(\"pub mod %s {\\n\" % mod)\n     for cat in sorted(emit):\n-        emit_bool_trie(f, \"%s_table\" % cat, tbl[cat])\n-        f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n-        f.write(\"        super::trie_lookup_range_table(c, %s_table)\\n\" % cat)\n-        f.write(\"    }\\n\\n\")\n+        if cat in [\"Cc\", \"White_Space\", \"Pattern_White_Space\"]:\n+            emit_small_bool_trie(f, \"%s_table\" % cat, tbl[cat])\n+            f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n+            f.write(\"        %s_table.lookup(c)\\n\" % cat)\n+            f.write(\"    }\\n\\n\")\n+        else:\n+            emit_bool_trie(f, \"%s_table\" % cat, tbl[cat])\n+            f.write(\"    pub fn %s(c: char) -> bool {\\n\" % cat)\n+            f.write(\"        super::trie_lookup_range_table(c, %s_table)\\n\" % cat)\n+            f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\\n\")\n \n def emit_conversions_module(f, to_upper, to_lower, to_title):\n@@ -543,4 +589,3 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n         # normalizations and conversions module\n         emit_norm_module(rf, canon_decomp, compat_decomp, combines, norm_props)\n         emit_conversions_module(rf, to_upper, to_lower, to_title)\n-    #print 'bytes before = %d, bytes after = %d' % (bytes_old, bytes_new)"}, {"sha": "459dc94f33686531efd9ada73e127cfc776dfebf", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -708,7 +708,7 @@ impl<T: ?Sized> Arc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Drop for Arc<T> {\n+unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n     /// Drops the `Arc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n@@ -736,7 +736,6 @@ impl<T: ?Sized> Drop for Arc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n-    #[unsafe_destructor_blind_to_params]\n     #[inline]\n     fn drop(&mut self) {\n         // Because `fetch_sub` is already atomic, we do not need to synchronize"}, {"sha": "5409ade292360d31e96afed17d8ade6d39c5d0f2", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -587,15 +587,15 @@ impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n /// ```\n #[rustc_paren_sugar]\n #[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when Box<FnOnce> becomes usable\", issue = \"28796\")]\n+           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n pub trait FnBox<A> {\n     type Output;\n \n     fn call_box(self: Box<Self>, args: A) -> Self::Output;\n }\n \n #[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when Box<FnOnce> becomes usable\", issue = \"28796\")]\n+           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n impl<A, F> FnBox<A> for F\n     where F: FnOnce<A>\n {\n@@ -607,7 +607,7 @@ impl<A, F> FnBox<A> for F\n }\n \n #[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when Box<FnOnce> becomes usable\", issue = \"28796\")]\n+           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n     type Output = R;\n \n@@ -617,7 +617,7 @@ impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n }\n \n #[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when Box<FnOnce> becomes usable\", issue = \"28796\")]\n+           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n     type Output = R;\n "}, {"sha": "c67106cf57aaf0ea2ab83f573d45c324d5f540bd", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -70,7 +70,7 @@\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n #![no_std]\n #![needs_allocator]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(allocator)]\n #![feature(box_syntax)]\n@@ -79,9 +79,10 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n-#![feature(dropck_parametricity)]\n+#![feature(dropck_eyepatch)]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![feature(fundamental)]\n+#![feature(generic_param_attrs)]\n #![feature(lang_items)]\n #![feature(needs_allocator)]\n #![feature(optin_builtin_traits)]"}, {"sha": "357a2724e0020cff95807f63246af3f52ecd4691", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -539,8 +539,7 @@ impl<T> RawVec<T> {\n     }\n }\n \n-impl<T> Drop for RawVec<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T> Drop for RawVec<T> {\n     /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n     fn drop(&mut self) {\n         let elem_size = mem::size_of::<T>();"}, {"sha": "010e378ef2f48238ea3880be935b6e2f1f25e737", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -644,7 +644,7 @@ impl<T: ?Sized> Deref for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Drop for Rc<T> {\n+unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// Drops the `Rc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n@@ -672,7 +672,6 @@ impl<T: ?Sized> Drop for Rc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n-    #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self.ptr;"}, {"sha": "241f8149d24d2fbd3d2f619fe2195156c3f9fb48", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,7 +16,7 @@\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"27783\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n #![feature(allocator)]\n #![feature(libc)]\n #![feature(staged_api)]"}, {"sha": "de2b75f62b68a4483eecebe53c6aa74d5044d719", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -12,7 +12,7 @@\n #![crate_type = \"rlib\"]\n #![no_std]\n #![allocator]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n #![unstable(feature = \"alloc_system\",\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\","}, {"sha": "a3cfc15895eb73cfb4dae3108482efd378eed447", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -26,14 +26,14 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(no_crate_inject, attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(alloc)]\n #![feature(core_intrinsics)]\n+#![feature(dropck_eyepatch)]\n #![feature(heap_api)]\n-#![feature(heap_api)]\n+#![feature(generic_param_attrs)]\n #![feature(staged_api)]\n-#![feature(dropck_parametricity)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]\n@@ -258,8 +258,7 @@ impl<T> TypedArena<T> {\n     }\n }\n \n-impl<T> Drop for TypedArena<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // Determine how much was filled."}, {"sha": "7d245f79f6998ccd61a816ecf50d907b314fc96d", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -153,8 +153,7 @@\n \n use core::ops::{Deref, DerefMut};\n use core::iter::{FromIterator, FusedIterator};\n-use core::mem::swap;\n-use core::mem::size_of;\n+use core::mem::{swap, size_of};\n use core::ptr;\n use core::fmt;\n \n@@ -226,12 +225,15 @@ pub struct BinaryHeap<T> {\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n pub struct PeekMut<'a, T: 'a + Ord> {\n     heap: &'a mut BinaryHeap<T>,\n+    sift: bool,\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n impl<'a, T: Ord> Drop for PeekMut<'a, T> {\n     fn drop(&mut self) {\n-        self.heap.sift_down(0);\n+        if self.sift {\n+            self.heap.sift_down(0);\n+        }\n     }\n }\n \n@@ -250,6 +252,16 @@ impl<'a, T: Ord> DerefMut for PeekMut<'a, T> {\n     }\n }\n \n+impl<'a, T: Ord> PeekMut<'a, T> {\n+    /// Removes the peeked value from the heap and returns it.\n+    #[unstable(feature = \"binary_heap_peek_mut_pop\", issue = \"38863\")]\n+    pub fn pop(mut this: PeekMut<'a, T>) -> T {\n+        let value = this.heap.pop().unwrap();\n+        this.sift = false;\n+        value\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for BinaryHeap<T> {\n     fn clone(&self) -> Self {\n@@ -385,7 +397,10 @@ impl<T: Ord> BinaryHeap<T> {\n         if self.is_empty() {\n             None\n         } else {\n-            Some(PeekMut { heap: self })\n+            Some(PeekMut {\n+                heap: self,\n+                sift: true,\n+            })\n         }\n     }\n "}, {"sha": "85e1e133b7d9afae99aa91de58c5d9aa18b0425e", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -137,8 +137,7 @@ pub struct BTreeMap<K, V> {\n }\n \n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n-impl<K, V> Drop for BTreeMap<K, V> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n     fn drop(&mut self) {\n         unsafe {\n             for _ in ptr::read(self).into_iter() {\n@@ -1991,11 +1990,11 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n-    /// let s = \"hoho\".to_owned();\n+    /// let s = \"hoho\".to_string();\n     ///\n     /// map.entry(\"poneyland\").or_insert_with(|| s);\n     ///\n-    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {"}, {"sha": "561d8860dc8803f3d5d0e141d19f7c8d12db6edf", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -27,24 +27,26 @@\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![cfg_attr(not(test), feature(char_escape_debug))]\n #![feature(core_intrinsics)]\n-#![feature(dropck_parametricity)]\n+#![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n #![feature(fused)]\n+#![feature(generic_param_attrs)]\n #![feature(heap_api)]\n #![feature(inclusive_range)]\n #![feature(lang_items)]\n #![feature(nonzero)]\n #![feature(pattern)]\n #![feature(placement_in)]\n+#![feature(placement_in_syntax)]\n #![feature(placement_new_protocol)]\n #![feature(shared)]\n #![feature(slice_get_slice)]"}, {"sha": "7f913d4afe476aeea2c8611f3e87062f9bbb76fd", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -726,8 +726,7 @@ impl<T> LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for LinkedList<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n         while let Some(_) = self.pop_front_node() {}\n     }"}, {"sha": "805021516db713b8b98370a879aef52a82216a2e", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -423,7 +423,7 @@ impl<T> [T] {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n-    /// Returns an raw pointer to the slice's buffer.\n+    /// Returns a raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage."}, {"sha": "27cf0268c99bbb30a33d38ba013358261e3c3521", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 77, "deletions": 6, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -77,7 +77,7 @@ use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem;\n-use core::ops::{Index, IndexMut};\n+use core::ops::{InPlace, Index, IndexMut, Place, Placer};\n use core::ops;\n use core::ptr;\n use core::ptr::Shared;\n@@ -370,7 +370,8 @@ impl<T> Vec<T> {\n     /// * `capacity` needs to be the capacity that the pointer was allocated with.\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n-    /// internal datastructures.\n+    /// internal datastructures. For example it is **not** safe\n+    /// to build a `Vec<u8>` from a pointer to a C `char` array and a `size_t`.\n     ///\n     /// The ownership of `ptr` is effectively transferred to the\n     /// `Vec<T>` which may then deallocate, reallocate or change the\n@@ -1246,6 +1247,29 @@ impl<T: Clone> Vec<T> {\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.spec_extend(other.iter())\n     }\n+\n+    /// Returns a place for insertion at the back of the `Vec`.\n+    ///\n+    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n+    /// but may be more efficient.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(collection_placement)]\n+    /// #![feature(placement_in_syntax)]\n+    ///\n+    /// let mut vec = vec![1, 2];\n+    /// vec.place_back() <- 3;\n+    /// vec.place_back() <- 4;\n+    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n+    /// ```\n+    #[unstable(feature = \"collection_placement\",\n+               reason = \"placement protocol is subject to change\",\n+               issue = \"30172\")]\n+    pub fn place_back(&mut self) -> PlaceBack<T> {\n+        PlaceBack { vec: self }\n+    }\n }\n \n // Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n@@ -1763,8 +1787,7 @@ impl<T: Ord> Ord for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Vec<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // use drop for [T]\n@@ -2033,8 +2056,7 @@ impl<T: Clone> Clone for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for IntoIter<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n         for _x in self.by_ref() {}\n@@ -2119,3 +2141,52 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Drain<'a, T> {}\n+\n+/// A place for insertion at the back of a `Vec`.\n+///\n+/// See [`Vec::place_back`](struct.Vec.html#method.place_back) for details.\n+#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"struct name and placement protocol are subject to change\",\n+           issue = \"30172\")]\n+pub struct PlaceBack<'a, T: 'a> {\n+    vec: &'a mut Vec<T>,\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n+    type Place = PlaceBack<'a, T>;\n+\n+    fn make_place(self) -> Self {\n+        // This will panic or abort if we would allocate > isize::MAX bytes\n+        // or if the length increment would overflow for zero-sized types.\n+        if self.vec.len == self.vec.buf.cap() {\n+            self.vec.buf.double();\n+        }\n+        self\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> Place<T> for PlaceBack<'a, T> {\n+    fn pointer(&mut self) -> *mut T {\n+        unsafe { self.vec.as_mut_ptr().offset(self.vec.len as isize) }\n+    }\n+}\n+\n+#[unstable(feature = \"collection_placement\",\n+           reason = \"placement protocol is subject to change\",\n+           issue = \"30172\")]\n+impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n+    type Owner = &'a mut T;\n+\n+    unsafe fn finalize(mut self) -> &'a mut T {\n+        let ptr = self.pointer();\n+        self.vec.len += 1;\n+        &mut *ptr\n+    }\n+}"}, {"sha": "76e44c815793feefa5a6c82be214b68273c5b6e4", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -69,8 +69,7 @@ impl<T: Clone> Clone for VecDeque<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for VecDeque<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T> Drop for VecDeque<T> {\n     fn drop(&mut self) {\n         let (front, back) = self.as_mut_slices();\n         unsafe {\n@@ -1228,9 +1227,8 @@ impl<T> VecDeque<T> {\n         self.pop_front()\n     }\n \n-    /// Inserts an element at `index` within the `VecDeque`. Whichever\n-    /// end is closer to the insertion point will be moved to make room,\n-    /// and all the affected elements will be moved to new positions.\n+    /// Inserts an element at `index` within the `VecDeque`, shifting all elements with indices\n+    /// greater than or equal to `index` towards the back.\n     ///\n     /// Element at index 0 is the front of the queue.\n     ///\n@@ -1239,14 +1237,19 @@ impl<T> VecDeque<T> {\n     /// Panics if `index` is greater than `VecDeque`'s length\n     ///\n     /// # Examples\n+    ///\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = VecDeque::new();\n-    /// buf.push_back(10);\n-    /// buf.push_back(12);\n-    /// buf.insert(1, 11);\n-    /// assert_eq!(Some(&11), buf.get(1));\n+    /// let mut vec_deque = VecDeque::new();\n+    /// vec_deque.push_back('a');\n+    /// vec_deque.push_back('b');\n+    /// vec_deque.push_back('c');\n+    ///\n+    /// vec_deque.insert(1, 'd');\n+    ///\n+    /// let vec = vec_deque.into_iter().collect::<Vec<_>>();\n+    /// assert_eq!(vec, ['a', 'd', 'b', 'c']);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {"}, {"sha": "1df341d1fc28a1e35dcd5ab36e89d0002b2db559", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::collections::BinaryHeap;\n-use std::collections::binary_heap::Drain;\n+use std::collections::binary_heap::{Drain, PeekMut};\n \n #[test]\n fn test_iterator() {\n@@ -94,6 +94,19 @@ fn test_peek_mut() {\n     assert_eq!(heap.peek(), Some(&9));\n }\n \n+#[test]\n+fn test_peek_mut_pop() {\n+    let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n+    let mut heap = BinaryHeap::from(data);\n+    assert_eq!(heap.peek(), Some(&10));\n+    {\n+        let mut top = heap.peek_mut().unwrap();\n+        *top -= 2;\n+        assert_eq!(PeekMut::pop(top), 8);\n+    }\n+    assert_eq!(heap.peek(), Some(&9));\n+}\n+\n #[test]\n fn test_push() {\n     let mut heap = BinaryHeap::from(vec![2, 4, 9]);"}, {"sha": "bec3965a9589be5036db63e6b5554ad90b7e6ef4", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -11,15 +11,18 @@\n #![deny(warnings)]\n \n #![feature(binary_heap_extras)]\n+#![feature(binary_heap_peek_mut_pop)]\n #![feature(box_syntax)]\n #![feature(btree_range)]\n+#![feature(collection_placement)]\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n #![feature(dedup_by)]\n #![feature(enumset)]\n #![feature(exact_size_is_empty)]\n #![feature(pattern)]\n+#![feature(placement_in_syntax)]\n #![feature(rand)]\n #![feature(repeat_str)]\n #![feature(step_by)]"}, {"sha": "5e685847e3c81afcee49be68bf9b9570addde49b", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -383,17 +383,29 @@ tempus vel, gravida nec quam.\";\n \n // check the panic includes the prefix of the sliced string\n #[test]\n-#[should_panic(expected=\"Lorem ipsum dolor sit amet\")]\n+#[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n fn test_slice_fail_truncated_1() {\n     &LOREM_PARAGRAPH[..1024];\n }\n // check the truncation in the panic message\n #[test]\n-#[should_panic(expected=\"luctus, im`[...] do not lie on character boundary\")]\n+#[should_panic(expected=\"luctus, im`[...]\")]\n fn test_slice_fail_truncated_2() {\n     &LOREM_PARAGRAPH[..1024];\n }\n \n+#[test]\n+#[should_panic(expected=\"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\")]\n+fn test_slice_fail_boundary_1() {\n+    &\"abc\u03b1\u03b2\u03b3\"[4..];\n+}\n+\n+#[test]\n+#[should_panic(expected=\"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\")]\n+fn test_slice_fail_boundary_2() {\n+    &\"abc\u03b1\u03b2\u03b3\"[2..6];\n+}\n+\n #[test]\n fn test_slice_from() {\n     assert_eq!(&\"abcd\"[0..], \"abcd\");"}, {"sha": "6d0f1eaffaa7bb6c432690f12ae437d7a9896102", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -12,6 +12,7 @@ use std::ascii::AsciiExt;\n use std::borrow::Cow;\n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n+use std::panic;\n use std::vec::{Drain, IntoIter};\n \n use test::Bencher;\n@@ -615,6 +616,24 @@ fn assert_covariance() {\n     }\n }\n \n+#[test]\n+fn test_placement() {\n+    let mut vec = vec![1];\n+    assert_eq!(vec.place_back() <- 2, &2);\n+    assert_eq!(vec.len(), 2);\n+    assert_eq!(vec.place_back() <- 3, &3);\n+    assert_eq!(vec.len(), 3);\n+    assert_eq!(&vec, &[1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_placement_panic() {\n+    let mut vec = vec![1, 2, 3];\n+    fn mkpanic() -> usize { panic!() }\n+    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { vec.place_back() <- mkpanic(); }));\n+    assert_eq!(vec.len(), 3);\n+}\n+\n #[bench]\n fn bench_new(b: &mut Bencher) {\n     b.iter(|| {"}, {"sha": "ab9a71e1ec6a68e462dc5da38d45344c9053db26", "filename": "src/libcompiler_builtins/build.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -192,14 +192,12 @@ fn main() {\n \n     if !target.contains(\"ios\") {\n         sources.extend(&[\"absvti2.c\",\n-                         \"addtf3.c\",\n                          \"addvti3.c\",\n                          \"ashlti3.c\",\n                          \"ashrti3.c\",\n                          \"clzti2.c\",\n                          \"cmpti2.c\",\n                          \"ctzti2.c\",\n-                         \"divtf3.c\",\n                          \"divti3.c\",\n                          \"ffsti2.c\",\n                          \"fixdfti.c\",\n@@ -216,17 +214,13 @@ fn main() {\n                          \"floatuntixf.c\",\n                          \"lshrti3.c\",\n                          \"modti3.c\",\n-                         \"multf3.c\",\n                          \"multi3.c\",\n                          \"mulvti3.c\",\n                          \"negti2.c\",\n                          \"negvti2.c\",\n                          \"parityti2.c\",\n                          \"popcountti2.c\",\n-                         \"powitf2.c\",\n-                         \"subtf3.c\",\n                          \"subvti3.c\",\n-                         \"trampoline_setup.c\",\n                          \"ucmpti2.c\",\n                          \"udivmodti4.c\",\n                          \"udivti3.c\",\n@@ -242,10 +236,6 @@ fn main() {\n                          \"atomic_thread_fence.c\"]);\n     }\n \n-    if !target.contains(\"redox\") && !target.contains(\"windows\") {\n-        sources.extend(&[\"emutls.c\"]);\n-    }\n-\n     if target.contains(\"msvc\") {\n         if target.contains(\"x86_64\") {\n             sources.extend(&[\"x86_64/floatdidf.c\", \"x86_64/floatdisf.c\", \"x86_64/floatdixf.c\"]);"}, {"sha": "78f3cd5576e1e9f8a77fe0de0804d8a81f144199", "filename": "src/libcore/any.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -101,7 +101,7 @@ pub trait Any: 'static {\n     ///\n     /// fn main() {\n     ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// }\n     /// ```\n     #[unstable(feature = \"get_type_id\",\n@@ -154,7 +154,7 @@ impl Any {\n     ///\n     /// fn main() {\n     ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_owned());\n+    ///     is_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -188,7 +188,7 @@ impl Any {\n     ///\n     /// fn main() {\n     ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_owned());\n+    ///     print_if_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -219,7 +219,7 @@ impl Any {\n     ///\n     /// fn main() {\n     ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_owned();\n+    ///     let mut s = \"starlord\".to_string();\n     ///\n     ///     modify_if_u32(&mut x);\n     ///     modify_if_u32(&mut s);\n@@ -259,7 +259,7 @@ impl Any+Send {\n     ///\n     /// fn main() {\n     ///     is_string(&0);\n-    ///     is_string(&\"cookie monster\".to_owned());\n+    ///     is_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -285,7 +285,7 @@ impl Any+Send {\n     ///\n     /// fn main() {\n     ///     print_if_string(&0);\n-    ///     print_if_string(&\"cookie monster\".to_owned());\n+    ///     print_if_string(&\"cookie monster\".to_string());\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -309,7 +309,7 @@ impl Any+Send {\n     ///\n     /// fn main() {\n     ///     let mut x = 10u32;\n-    ///     let mut s = \"starlord\".to_owned();\n+    ///     let mut s = \"starlord\".to_string();\n     ///\n     ///     modify_if_u32(&mut x);\n     ///     modify_if_u32(&mut s);\n@@ -359,7 +359,7 @@ impl TypeId {\n     ///\n     /// fn main() {\n     ///     assert_eq!(is_string(&0), false);\n-    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "367422f55364a997d5a83b85d7e94820b37bde69", "filename": "src/libcore/char.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -17,7 +17,7 @@\n \n use char_private::is_printable;\n use convert::TryFrom;\n-use fmt;\n+use fmt::{self, Write};\n use slice;\n use iter::FusedIterator;\n use mem::transmute;\n@@ -588,6 +588,16 @@ impl ExactSizeIterator for EscapeUnicode {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeUnicode {}\n \n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for EscapeUnicode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for c in self.clone() {\n+            f.write_char(c)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// An iterator that yields the literal escape code of a `char`.\n ///\n /// This `struct` is created by the [`escape_default()`] method on [`char`]. See\n@@ -691,6 +701,16 @@ impl ExactSizeIterator for EscapeDefault {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDefault {}\n \n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for c in self.clone() {\n+            f.write_char(c)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// An iterator that yields the literal escape code of a `char`.\n ///\n /// This `struct` is created by the [`escape_debug()`] method on [`char`]. See its\n@@ -715,6 +735,13 @@ impl ExactSizeIterator for EscapeDebug { }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDebug {}\n \n+#[stable(feature = \"char_struct_display\", since = \"1.17.0\")]\n+impl fmt::Display for EscapeDebug {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n \n \n /// An iterator over an iterator of bytes of the characters the bytes represent"}, {"sha": "31a0cc6884184237d0585576eba900f2b7ee8c41", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1156,10 +1156,58 @@ extern \"rust-intrinsic\" {\n     /// Returns the number of bits set in an integer type `T`\n     pub fn ctpop<T>(x: T) -> T;\n \n-    /// Returns the number of leading bits unset in an integer type `T`\n+    /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(core_intrinsics)]\n+    ///\n+    /// use std::intrinsics::ctlz;\n+    ///\n+    /// let x = 0b0001_1100_u8;\n+    /// let num_leading = unsafe { ctlz(x) };\n+    /// assert_eq!(num_leading, 3);\n+    /// ```\n+    ///\n+    /// An `x` with value `0` will return the bit width of `T`.\n+    ///\n+    /// ```\n+    /// #![feature(core_intrinsics)]\n+    ///\n+    /// use std::intrinsics::ctlz;\n+    ///\n+    /// let x = 0u16;\n+    /// let num_leading = unsafe { ctlz(x) };\n+    /// assert_eq!(num_leading, 16);\n+    /// ```\n     pub fn ctlz<T>(x: T) -> T;\n \n-    /// Returns the number of trailing bits unset in an integer type `T`\n+    /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(core_intrinsics)]\n+    ///\n+    /// use std::intrinsics::cttz;\n+    ///\n+    /// let x = 0b0011_1000_u8;\n+    /// let num_trailing = unsafe { cttz(x) };\n+    /// assert_eq!(num_trailing, 3);\n+    /// ```\n+    ///\n+    /// An `x` with value `0` will return the bit width of `T`:\n+    ///\n+    /// ```\n+    /// #![feature(core_intrinsics)]\n+    ///\n+    /// use std::intrinsics::cttz;\n+    ///\n+    /// let x = 0u16;\n+    /// let num_trailing = unsafe { cttz(x) };\n+    /// assert_eq!(num_trailing, 16);\n+    /// ```\n     pub fn cttz<T>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`."}, {"sha": "91c09c5530565144660d761ae36784e17d7fcec0", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1612,7 +1612,7 @@ pub trait Iterator {\n \n     /// Returns the maximum element of an iterator.\n     ///\n-    /// If the two elements are equally maximum, the latest element is\n+    /// If several elements are equally maximum, the last element is\n     /// returned.\n     ///\n     /// # Examples\n@@ -1638,7 +1638,7 @@ pub trait Iterator {\n \n     /// Returns the minimum element of an iterator.\n     ///\n-    /// If the two elements are equally minimum, the first element is\n+    /// If several elements are equally minimum, the first element is\n     /// returned.\n     ///\n     /// # Examples\n@@ -1665,8 +1665,8 @@ pub trait Iterator {\n     /// Returns the element that gives the maximum value from the\n     /// specified function.\n     ///\n-    /// Returns the rightmost element if the comparison determines two elements\n-    /// to be equally maximum.\n+    /// If several elements are equally maximum, the last element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n@@ -1690,8 +1690,8 @@ pub trait Iterator {\n     /// Returns the element that gives the maximum value with respect to the\n     /// specified comparison function.\n     ///\n-    /// Returns the rightmost element if the comparison determines two elements\n-    /// to be equally maximum.\n+    /// If several elements are equally maximum, the last element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n@@ -1715,8 +1715,8 @@ pub trait Iterator {\n     /// Returns the element that gives the minimum value from the\n     /// specified function.\n     ///\n-    /// Returns the latest element if the comparison determines two elements\n-    /// to be equally minimum.\n+    /// If several elements are equally minimum, the first element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n@@ -1739,8 +1739,8 @@ pub trait Iterator {\n     /// Returns the element that gives the minimum value with respect to the\n     /// specified comparison function.\n     ///\n-    /// Returns the latest element if the comparison determines two elements\n-    /// to be equally minimum.\n+    /// If several elements are equally minimum, the first element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1e127148300678661582bb50771ca60ca275a98d", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -260,7 +260,10 @@ impl<I: Iterator> IntoIterator for I {\n ///\n /// Iterators produce a series of values, and collections can also be thought\n /// of as a series of values. The `Extend` trait bridges this gap, allowing you\n-/// to extend a collection by including the contents of that iterator.\n+/// to extend a collection by including the contents of that iterator. When\n+/// extending a collection with an already existing key, that entry is updated\n+/// or, in the case of collections that permit multiple entries with equal\n+/// keys, that entry is inserted.\n ///\n /// # Examples\n ///\n@@ -670,6 +673,87 @@ macro_rules! float_sum_product {\n integer_sum_product! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n float_sum_product! { f32 f64 }\n \n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Result::Ok` values.\n+///\n+/// If an error is encountered, the iterator stops and the error is\n+/// stored. The error may be recovered later via `reconstruct`.\n+struct ResultShunt<I, E> {\n+    iter: I,\n+    error: Option<E>,\n+}\n+\n+impl<I, T, E> ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Result<T, _>`. Any errors will stop the inner iterator and\n+    /// the overall result will be an error.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n+        where F: FnMut(&mut Self) -> U\n+    {\n+        let mut shunt = ResultShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        ResultShunt {\n+            iter: iter,\n+            error: None,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Result` value. This should\n+    /// *always* be called, otherwise any potential error would be\n+    /// lost.\n+    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n+        match self.error {\n+            None => Ok(val),\n+            Some(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl<I, T, E> Iterator for ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Ok(v)) => Some(v),\n+            Some(Err(e)) => {\n+                self.error = Some(e);\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n+    where T: Sum<U>,\n+{\n+    fn sum<I>(iter: I) -> Result<T, E>\n+        where I: Iterator<Item = Result<U, E>>,\n+    {\n+        ResultShunt::process(iter, |i| i.sum())\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n+    where T: Product<U>,\n+{\n+    fn product<I>(iter: I) -> Result<T, E>\n+        where I: Iterator<Item = Result<U, E>>,\n+    {\n+        ResultShunt::process(iter, |i| i.product())\n+    }\n+}\n+\n /// An iterator that always continues to yield `None` when exhausted.\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed"}, {"sha": "35324f7b5968ff6e14bd78e0367e75e6b88571f3", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -65,7 +65,7 @@\n #![no_core]\n #![deny(missing_docs)]\n #![deny(missing_debug_implementations)]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(allow_internal_unstable)]\n #![feature(asm)]"}, {"sha": "ba52edb1ae837fd10b7a7ed3e61f162e770d5b3e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -404,10 +404,11 @@ macro_rules! write {\n /// use std::io::Write;\n ///\n /// let mut w = Vec::new();\n+/// writeln!(&mut w).unwrap();\n /// writeln!(&mut w, \"test\").unwrap();\n /// writeln!(&mut w, \"formatted {}\", \"arguments\").unwrap();\n ///\n-/// assert_eq!(&w[..], \"test\\nformatted arguments\\n\".as_bytes());\n+/// assert_eq!(&w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n /// ```\n ///\n /// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n@@ -427,6 +428,9 @@ macro_rules! write {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! writeln {\n+    ($dst:expr) => (\n+        write!($dst, \"\\n\")\n+    );\n     ($dst:expr, $fmt:expr) => (\n         write!($dst, concat!($fmt, \"\\n\"))\n     );"}, {"sha": "798f1e6cbeb844b842b798568bf585261cc75d22", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -100,13 +100,26 @@ pub trait Sized {\n ///\n /// All implementations of `Unsize` are provided automatically by the compiler.\n ///\n+/// `Unsize` is implemented for:\n+///\n+/// - `[T; N]` is `Unsize<[T]>`\n+/// - `T` is `Unsize<Trait>` when `T: Trait`\n+/// - `Foo<..., T, ...>` is `Unsize<Foo<..., U, ...>>` if:\n+///   - `T: Unsize<U>`\n+///   - Foo is a struct\n+///   - Only the last field of `Foo` has a type involving `T`\n+///   - `T` is not part of the type of any other fields\n+///   - `Bar<T>: Unsize<Bar<U>>`, if the last field of `Foo` has type `Bar<T>`\n+///\n /// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n /// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n-/// types. See the [DST coercion RFC][RFC982] for more details.\n+/// types. See the [DST coercion RFC][RFC982] and [the nomicon entry on coercion][nomicon-coerce]\n+/// for more details.\n ///\n /// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n /// [rc]: ../../std/rc/struct.Rc.html\n /// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n #[lang=\"unsize\"]\n pub trait Unsize<T: ?Sized> {\n@@ -234,12 +247,10 @@ pub trait Unsize<T: ?Sized> {\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n-/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get a\n-/// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n-/// [E0205].\n+/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get\n+/// the error [E0204].\n ///\n /// [E0204]: ../../error-index.html#E0204\n-/// [E0205]: ../../error-index.html#E0205\n ///\n /// ## When *should* my type be `Copy`?\n ///"}, {"sha": "04354e2e33f960eda46172974b88606ea012fb74", "filename": "src/libcore/num/i128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi128.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -14,4 +14,4 @@\n \n #![unstable(feature = \"i128\", issue=\"35118\")]\n \n-int_module! { i128 }\n+int_module! { i128, #[unstable(feature = \"i128\", issue=\"35118\")] }"}, {"sha": "04311d687ea92ad94e5f1a4bd9dcaa1f977e4fd1", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,13 +10,14 @@\n \n #![doc(hidden)]\n \n-macro_rules! int_module { ($T:ident) => (\n-\n-/// The smallest value that can be represented by this integer type.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN: $T = $T::min_value();\n-/// The largest value that can be represented by this integer type.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: $T = $T::max_value();\n-\n-) }\n+macro_rules! int_module {\n+    ($T:ident) => (int_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n+    ($T:ident, $($attr: tt)*) => (\n+        /// The smallest value that can be represented by this integer type.\n+        $($attr)*\n+        pub const MIN: $T = $T::min_value();\n+        /// The largest value that can be represented by this integer type.\n+        $($attr)*\n+        pub const MAX: $T = $T::max_value();\n+    )\n+}"}, {"sha": "987ac3e000732827772db9fd76609cea2c12b389", "filename": "src/libcore/num/u128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu128.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,4 +13,4 @@\n //! *[See also the `u128` primitive type](../../std/primitive.u128.html).*\n \n #![unstable(feature = \"i128\", issue=\"35118\")]\n-uint_module! { u128 }\n+uint_module! { u128, #[unstable(feature = \"i128\", issue=\"35118\")] }"}, {"sha": "2e59b39278ab6a9716b57b6bb21d3eba105ced19", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,13 +10,14 @@\n \n #![doc(hidden)]\n \n-macro_rules! uint_module { ($T:ident) => (\n-\n-/// The smallest value that can be represented by this integer type.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MIN: $T = $T::min_value();\n-/// The largest value that can be represented by this integer type.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: $T = $T::max_value();\n-\n-) }\n+macro_rules! uint_module {\n+    ($T:ident) => (uint_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n+    ($T:ident, $($attr: tt)*) => (\n+        /// The smallest value that can be represented by this integer type.\n+        $($attr)*\n+        pub const MIN: $T = $T::min_value();\n+        /// The largest value that can be represented by this integer type.\n+        $($attr)*\n+        pub const MAX: $T = $T::max_value();\n+    )\n+}"}, {"sha": "94df72f28fa9ce7b058fe824bc81fb850e88cfe7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -2710,6 +2710,35 @@ mod impls {\n \n /// Trait that indicates that this is a pointer or a wrapper for one,\n /// where unsizing can be performed on the pointee.\n+///\n+/// See the [DST coercion RfC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce]\n+/// for more details.\n+///\n+/// For builtin pointer types, pointers to `T` will coerce to pointers to `U` if `T: Unsize<U>`\n+/// by converting from a thin pointer to a fat pointer.\n+///\n+/// For custom types, the coercion here works by coercing `Foo<T>` to `Foo<U>`\n+/// provided an impl of `CoerceUnsized<Foo<U>> for Foo<T>` exists.\n+/// Such an impl can only be written if `Foo<T>` has only a single non-phantomdata\n+/// field involving `T`. If the type of that field is `Bar<T>`, an implementation\n+/// of `CoerceUnsized<Bar<U>> for Bar<T>` must exist. The coercion will work by\n+/// by coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields\n+/// from `Foo<T>` to create a `Foo<U>`. This will effectively drill down to a pointer\n+/// field and coerce that.\n+///\n+/// Generally, for smart pointers you will implement\n+/// `CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized`, with an\n+/// optional `?Sized` bound on `T` itself. For wrapper types that directly embed `T`\n+/// like `Cell<T>` and `RefCell<T>`, you\n+/// can directly implement `CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>`.\n+/// This will let coercions of types like `Cell<Box<T>>` work.\n+///\n+/// [`Unsize`][unsize] is used to mark types which can be coerced to DSTs if behind\n+/// pointers. It is implemented automatically by the compiler.\n+///\n+/// [dst-coerce]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+/// [unsize]: ../marker/trait.Unsize.html\n+/// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n #[lang=\"coerce_unsized\"]\n pub trait CoerceUnsized<T> {"}, {"sha": "bf5a59c45e4d383acc53ebec1a080d9e747b2c0a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -74,7 +74,10 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n ///\n /// # Safety\n ///\n-/// This is only unsafe because it accepts a raw pointer.\n+/// This function copies the memory through the raw pointers passed to it\n+/// as arguments.\n+///\n+/// Ensure that these pointers are valid before calling `swap`.\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {"}, {"sha": "f02df88bb2efa4d89dea460f7aad3d1cf71a3a88", "filename": "src/libcore/result.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -798,6 +798,31 @@ impl<T: fmt::Debug, E> Result<T, E> {\n             Err(e) => e,\n         }\n     }\n+\n+    /// Unwraps a result, yielding the content of an `Err`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an `Ok`, with a panic message including the\n+    /// passed message, and the content of the `Ok`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```{.should_panic}\n+    /// # #![feature(result_expect_err)]\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_expect_err\", issue = \"39041\")]\n+    pub fn expect_err(self, msg: &str) -> E {\n+        match self {\n+            Ok(t) => unwrap_failed(msg, t),\n+            Err(e) => e,\n+        }\n+    }\n }\n \n impl<T: Default, E> Result<T, E> {"}, {"sha": "49a6b1b5fceb77a417309ee15bf9c4489790f07b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1232,26 +1232,31 @@ fn contains_nonascii(x: usize) -> bool {\n /// invalid sequence.\n #[inline(always)]\n fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n-    let mut offset = 0;\n+    let mut index = 0;\n     let len = v.len();\n-    while offset < len {\n-        let old_offset = offset;\n+\n+    let usize_bytes = mem::size_of::<usize>();\n+    let ascii_block_size = 2 * usize_bytes;\n+    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n+\n+    while index < len {\n+        let old_offset = index;\n         macro_rules! err { () => {{\n             return Err(Utf8Error {\n                 valid_up_to: old_offset\n             })\n         }}}\n \n         macro_rules! next { () => {{\n-            offset += 1;\n+            index += 1;\n             // we needed data, but there was none: error!\n-            if offset >= len {\n+            if index >= len {\n                 err!()\n             }\n-            v[offset]\n+            v[index]\n         }}}\n \n-        let first = v[offset];\n+        let first = v[index];\n         if first >= 128 {\n             let w = UTF8_CHAR_WIDTH[first as usize];\n             let second = next!();\n@@ -1294,38 +1299,32 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n                 }\n                 _ => err!()\n             }\n-            offset += 1;\n+            index += 1;\n         } else {\n             // Ascii case, try to skip forward quickly.\n             // When the pointer is aligned, read 2 words of data per iteration\n             // until we find a word containing a non-ascii byte.\n-            let usize_bytes = mem::size_of::<usize>();\n-            let bytes_per_iteration = 2 * usize_bytes;\n             let ptr = v.as_ptr();\n-            let align = (ptr as usize + offset) & (usize_bytes - 1);\n+            let align = (ptr as usize + index) & (usize_bytes - 1);\n             if align == 0 {\n-                if len >= bytes_per_iteration {\n-                    while offset <= len - bytes_per_iteration {\n-                        unsafe {\n-                            let u = *(ptr.offset(offset as isize) as *const usize);\n-                            let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n-\n-                            // break if there is a nonascii byte\n-                            let zu = contains_nonascii(u);\n-                            let zv = contains_nonascii(v);\n-                            if zu || zv {\n-                                break;\n-                            }\n+                while index < blocks_end {\n+                    unsafe {\n+                        let block = ptr.offset(index as isize) as *const usize;\n+                        // break if there is a nonascii byte\n+                        let zu = contains_nonascii(*block);\n+                        let zv = contains_nonascii(*block.offset(1));\n+                        if zu | zv {\n+                            break;\n                         }\n-                        offset += bytes_per_iteration;\n                     }\n+                    index += ascii_block_size;\n                 }\n                 // step from the point where the wordwise loop stopped\n-                while offset < len && v[offset] < 128 {\n-                    offset += 1;\n+                while index < len && v[index] < 128 {\n+                    index += 1;\n                 }\n             } else {\n-                offset += 1;\n+                index += 1;\n             }\n         }\n     }\n@@ -1746,13 +1745,31 @@ fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n #[cold]\n fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     const MAX_DISPLAY_LENGTH: usize = 256;\n-    let (truncated, s) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);\n+    let (truncated, s_trunc) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);\n     let ellipsis = if truncated { \"[...]\" } else { \"\" };\n \n+    // 1. out of bounds\n+    if begin > s.len() || end > s.len() {\n+        let oob_index = if begin > s.len() { begin } else { end };\n+        panic!(\"byte index {} is out of bounds of `{}`{}\", oob_index, s_trunc, ellipsis);\n+    }\n+\n+    // 2. begin <= end\n     assert!(begin <= end, \"begin <= end ({} <= {}) when slicing `{}`{}\",\n-            begin, end, s, ellipsis);\n-    panic!(\"index {} and/or {} in `{}`{} do not lie on character boundary\",\n-          begin, end, s, ellipsis);\n+            begin, end, s_trunc, ellipsis);\n+\n+    // 3. character boundary\n+    let index = if !s.is_char_boundary(begin) { begin } else { end };\n+    // find the character\n+    let mut char_start = index;\n+    while !s.is_char_boundary(char_start) {\n+        char_start -= 1;\n+    }\n+    // `char_start` must be less than len and a char boundary\n+    let ch = s[char_start..].chars().next().unwrap();\n+    let char_range = char_start .. char_start + ch.len_utf8();\n+    panic!(\"byte index {} is not a char boundary; it is inside {:?} (bytes {:?}) of `{}`{}\",\n+           index, ch, char_range, s_trunc, ellipsis);\n }\n \n #[stable(feature = \"core\", since = \"1.6.0\")]"}, {"sha": "e4012ec91e2b3f1fdd8a0132d934e01dac18ee03", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 99, "deletions": 125, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -75,47 +75,53 @@ fn test_to_digit() {\n \n #[test]\n fn test_to_lowercase() {\n-    fn lower(c: char) -> Vec<char> {\n-        c.to_lowercase().collect()\n+    fn lower(c: char) -> String {\n+        let iter: String = c.to_lowercase().collect();\n+        let disp: String = c.to_lowercase().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    assert_eq!(lower('A'), ['a']);\n-    assert_eq!(lower('\u00d6'), ['\u00f6']);\n-    assert_eq!(lower('\u00df'), ['\u00df']);\n-    assert_eq!(lower('\u00dc'), ['\u00fc']);\n-    assert_eq!(lower('\ud83d\udca9'), ['\ud83d\udca9']);\n-    assert_eq!(lower('\u03a3'), ['\u03c3']);\n-    assert_eq!(lower('\u03a4'), ['\u03c4']);\n-    assert_eq!(lower('\u0399'), ['\u03b9']);\n-    assert_eq!(lower('\u0393'), ['\u03b3']);\n-    assert_eq!(lower('\u039c'), ['\u03bc']);\n-    assert_eq!(lower('\u0391'), ['\u03b1']);\n-    assert_eq!(lower('\u03a3'), ['\u03c3']);\n-    assert_eq!(lower('\u01c5'), ['\u01c6']);\n-    assert_eq!(lower('\ufb01'), ['\ufb01']);\n-    assert_eq!(lower('\u0130'), ['i', '\\u{307}']);\n+    assert_eq!(lower('A'), \"a\");\n+    assert_eq!(lower('\u00d6'), \"\u00f6\");\n+    assert_eq!(lower('\u00df'), \"\u00df\");\n+    assert_eq!(lower('\u00dc'), \"\u00fc\");\n+    assert_eq!(lower('\ud83d\udca9'), \"\ud83d\udca9\");\n+    assert_eq!(lower('\u03a3'), \"\u03c3\");\n+    assert_eq!(lower('\u03a4'), \"\u03c4\");\n+    assert_eq!(lower('\u0399'), \"\u03b9\");\n+    assert_eq!(lower('\u0393'), \"\u03b3\");\n+    assert_eq!(lower('\u039c'), \"\u03bc\");\n+    assert_eq!(lower('\u0391'), \"\u03b1\");\n+    assert_eq!(lower('\u03a3'), \"\u03c3\");\n+    assert_eq!(lower('\u01c5'), \"\u01c6\");\n+    assert_eq!(lower('\ufb01'), \"\ufb01\");\n+    assert_eq!(lower('\u0130'), \"i\\u{307}\");\n }\n \n #[test]\n fn test_to_uppercase() {\n-    fn upper(c: char) -> Vec<char> {\n-        c.to_uppercase().collect()\n+    fn upper(c: char) -> String {\n+        let iter: String = c.to_uppercase().collect();\n+        let disp: String = c.to_uppercase().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    assert_eq!(upper('a'), ['A']);\n-    assert_eq!(upper('\u00f6'), ['\u00d6']);\n-    assert_eq!(upper('\u00df'), ['S', 'S']); // not \u1e9e: Latin capital letter sharp s\n-    assert_eq!(upper('\u00fc'), ['\u00dc']);\n-    assert_eq!(upper('\ud83d\udca9'), ['\ud83d\udca9']);\n-\n-    assert_eq!(upper('\u03c3'), ['\u03a3']);\n-    assert_eq!(upper('\u03c4'), ['\u03a4']);\n-    assert_eq!(upper('\u03b9'), ['\u0399']);\n-    assert_eq!(upper('\u03b3'), ['\u0393']);\n-    assert_eq!(upper('\u03bc'), ['\u039c']);\n-    assert_eq!(upper('\u03b1'), ['\u0391']);\n-    assert_eq!(upper('\u03c2'), ['\u03a3']);\n-    assert_eq!(upper('\u01c5'), ['\u01c4']);\n-    assert_eq!(upper('\ufb01'), ['F', 'I']);\n-    assert_eq!(upper('\u1f80'), ['\u1f08', '\u0399']);\n+    assert_eq!(upper('a'), \"A\");\n+    assert_eq!(upper('\u00f6'), \"\u00d6\");\n+    assert_eq!(upper('\u00df'), \"SS\"); // not \u1e9e: Latin capital letter sharp s\n+    assert_eq!(upper('\u00fc'), \"\u00dc\");\n+    assert_eq!(upper('\ud83d\udca9'), \"\ud83d\udca9\");\n+\n+    assert_eq!(upper('\u03c3'), \"\u03a3\");\n+    assert_eq!(upper('\u03c4'), \"\u03a4\");\n+    assert_eq!(upper('\u03b9'), \"\u0399\");\n+    assert_eq!(upper('\u03b3'), \"\u0393\");\n+    assert_eq!(upper('\u03bc'), \"\u039c\");\n+    assert_eq!(upper('\u03b1'), \"\u0391\");\n+    assert_eq!(upper('\u03c2'), \"\u03a3\");\n+    assert_eq!(upper('\u01c5'), \"\u01c4\");\n+    assert_eq!(upper('\ufb01'), \"FI\");\n+    assert_eq!(upper('\u1f80'), \"\u1f08\u0399\");\n }\n \n #[test]\n@@ -144,107 +150,75 @@ fn test_is_digit() {\n #[test]\n fn test_escape_debug() {\n     fn string(c: char) -> String {\n-        c.escape_debug().collect()\n+        let iter: String = c.escape_debug().collect();\n+        let disp: String = c.escape_debug().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    let s = string('\\n');\n-    assert_eq!(s, \"\\\\n\");\n-    let s = string('\\r');\n-    assert_eq!(s, \"\\\\r\");\n-    let s = string('\\'');\n-    assert_eq!(s, \"\\\\'\");\n-    let s = string('\"');\n-    assert_eq!(s, \"\\\\\\\"\");\n-    let s = string(' ');\n-    assert_eq!(s, \" \");\n-    let s = string('a');\n-    assert_eq!(s, \"a\");\n-    let s = string('~');\n-    assert_eq!(s, \"~\");\n-    let s = string('\u00e9');\n-    assert_eq!(s, \"\u00e9\");\n-    let s = string('\u6587');\n-    assert_eq!(s, \"\u6587\");\n-    let s = string('\\x00');\n-    assert_eq!(s, \"\\\\u{0}\");\n-    let s = string('\\x1f');\n-    assert_eq!(s, \"\\\\u{1f}\");\n-    let s = string('\\x7f');\n-    assert_eq!(s, \"\\\\u{7f}\");\n-    let s = string('\\u{80}');\n-    assert_eq!(s, \"\\\\u{80}\");\n-    let s = string('\\u{ff}');\n-    assert_eq!(s, \"\\u{ff}\");\n-    let s = string('\\u{11b}');\n-    assert_eq!(s, \"\\u{11b}\");\n-    let s = string('\\u{1d4b6}');\n-    assert_eq!(s, \"\\u{1d4b6}\");\n-    let s = string('\\u{200b}'); // zero width space\n-    assert_eq!(s, \"\\\\u{200b}\");\n-    let s = string('\\u{e000}'); // private use 1\n-    assert_eq!(s, \"\\\\u{e000}\");\n-    let s = string('\\u{100000}'); // private use 2\n-    assert_eq!(s, \"\\\\u{100000}\");\n+    assert_eq!(string('\\n'), \"\\\\n\");\n+    assert_eq!(string('\\r'), \"\\\\r\");\n+    assert_eq!(string('\\''), \"\\\\'\");\n+    assert_eq!(string('\"'), \"\\\\\\\"\");\n+    assert_eq!(string(' '), \" \");\n+    assert_eq!(string('a'), \"a\");\n+    assert_eq!(string('~'), \"~\");\n+    assert_eq!(string('\u00e9'), \"\u00e9\");\n+    assert_eq!(string('\u6587'), \"\u6587\");\n+    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n+    assert_eq!(string('\\x1f'), \"\\\\u{1f}\");\n+    assert_eq!(string('\\x7f'), \"\\\\u{7f}\");\n+    assert_eq!(string('\\u{80}'), \"\\\\u{80}\");\n+    assert_eq!(string('\\u{ff}'), \"\\u{ff}\");\n+    assert_eq!(string('\\u{11b}'), \"\\u{11b}\");\n+    assert_eq!(string('\\u{1d4b6}'), \"\\u{1d4b6}\");\n+    assert_eq!(string('\\u{200b}'),\"\\\\u{200b}\");      // zero width space\n+    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\");     // private use 1\n+    assert_eq!(string('\\u{100000}'), \"\\\\u{100000}\"); // private use 2\n }\n \n #[test]\n fn test_escape_default() {\n     fn string(c: char) -> String {\n-        c.escape_default().collect()\n+        let iter: String = c.escape_default().collect();\n+        let disp: String = c.escape_default().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n     }\n-    let s = string('\\n');\n-    assert_eq!(s, \"\\\\n\");\n-    let s = string('\\r');\n-    assert_eq!(s, \"\\\\r\");\n-    let s = string('\\'');\n-    assert_eq!(s, \"\\\\'\");\n-    let s = string('\"');\n-    assert_eq!(s, \"\\\\\\\"\");\n-    let s = string(' ');\n-    assert_eq!(s, \" \");\n-    let s = string('a');\n-    assert_eq!(s, \"a\");\n-    let s = string('~');\n-    assert_eq!(s, \"~\");\n-    let s = string('\u00e9');\n-    assert_eq!(s, \"\\\\u{e9}\");\n-    let s = string('\\x00');\n-    assert_eq!(s, \"\\\\u{0}\");\n-    let s = string('\\x1f');\n-    assert_eq!(s, \"\\\\u{1f}\");\n-    let s = string('\\x7f');\n-    assert_eq!(s, \"\\\\u{7f}\");\n-    let s = string('\\u{80}');\n-    assert_eq!(s, \"\\\\u{80}\");\n-    let s = string('\\u{ff}');\n-    assert_eq!(s, \"\\\\u{ff}\");\n-    let s = string('\\u{11b}');\n-    assert_eq!(s, \"\\\\u{11b}\");\n-    let s = string('\\u{1d4b6}');\n-    assert_eq!(s, \"\\\\u{1d4b6}\");\n-    let s = string('\\u{200b}'); // zero width space\n-    assert_eq!(s, \"\\\\u{200b}\");\n-    let s = string('\\u{e000}'); // private use 1\n-    assert_eq!(s, \"\\\\u{e000}\");\n-    let s = string('\\u{100000}'); // private use 2\n-    assert_eq!(s, \"\\\\u{100000}\");\n+    assert_eq!(string('\\n'), \"\\\\n\");\n+    assert_eq!(string('\\r'), \"\\\\r\");\n+    assert_eq!(string('\\''), \"\\\\'\");\n+    assert_eq!(string('\"'), \"\\\\\\\"\");\n+    assert_eq!(string(' '), \" \");\n+    assert_eq!(string('a'), \"a\");\n+    assert_eq!(string('~'), \"~\");\n+    assert_eq!(string('\u00e9'), \"\\\\u{e9}\");\n+    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n+    assert_eq!(string('\\x1f'), \"\\\\u{1f}\");\n+    assert_eq!(string('\\x7f'), \"\\\\u{7f}\");\n+    assert_eq!(string('\\u{80}'), \"\\\\u{80}\");\n+    assert_eq!(string('\\u{ff}'), \"\\\\u{ff}\");\n+    assert_eq!(string('\\u{11b}'), \"\\\\u{11b}\");\n+    assert_eq!(string('\\u{1d4b6}'), \"\\\\u{1d4b6}\");\n+    assert_eq!(string('\\u{200b}'), \"\\\\u{200b}\"); // zero width space\n+    assert_eq!(string('\\u{e000}'), \"\\\\u{e000}\"); // private use 1\n+    assert_eq!(string('\\u{100000}'), \"\\\\u{100000}\"); // private use 2\n }\n \n #[test]\n fn test_escape_unicode() {\n-    fn string(c: char) -> String { c.escape_unicode().collect() }\n-\n-    let s = string('\\x00');\n-    assert_eq!(s, \"\\\\u{0}\");\n-    let s = string('\\n');\n-    assert_eq!(s, \"\\\\u{a}\");\n-    let s = string(' ');\n-    assert_eq!(s, \"\\\\u{20}\");\n-    let s = string('a');\n-    assert_eq!(s, \"\\\\u{61}\");\n-    let s = string('\\u{11b}');\n-    assert_eq!(s, \"\\\\u{11b}\");\n-    let s = string('\\u{1d4b6}');\n-    assert_eq!(s, \"\\\\u{1d4b6}\");\n+    fn string(c: char) -> String {\n+        let iter: String = c.escape_unicode().collect();\n+        let disp: String = c.escape_unicode().to_string();\n+        assert_eq!(iter, disp);\n+        iter\n+    }\n+\n+    assert_eq!(string('\\x00'), \"\\\\u{0}\");\n+    assert_eq!(string('\\n'), \"\\\\u{a}\");\n+    assert_eq!(string(' '), \"\\\\u{20}\");\n+    assert_eq!(string('a'), \"\\\\u{61}\");\n+    assert_eq!(string('\\u{11b}'), \"\\\\u{11b}\");\n+    assert_eq!(string('\\u{1d4b6}'), \"\\\\u{1d4b6}\");\n }\n \n #[test]"}, {"sha": "99d312930533f31ec482d683f6c2e4010014c5f3", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -614,6 +614,14 @@ fn test_iterator_sum() {\n     assert_eq!(v[..0].iter().cloned().sum::<i32>(), 0);\n }\n \n+#[test]\n+fn test_iterator_sum_result() {\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Ok(10));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n+}\n+\n #[test]\n fn test_iterator_product() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n@@ -622,6 +630,14 @@ fn test_iterator_product() {\n     assert_eq!(v[..0].iter().cloned().product::<i32>(), 1);\n }\n \n+#[test]\n+fn test_iterator_product_result() {\n+    let v: &[Result<i32, ()>] = &[Ok(1), Ok(2), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Ok(24));\n+    let v: &[Result<i32, ()>] = &[Ok(1), Err(()), Ok(3), Ok(4)];\n+    assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Err(()));\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}, {"sha": "ee47b510ee0744fef35629d023734c4782a78c7a", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,6 +23,7 @@\n #![feature(nonzero)]\n #![feature(rand)]\n #![feature(raw)]\n+#![feature(result_expect_err)]\n #![feature(sip_hash_13)]\n #![feature(slice_patterns)]\n #![feature(step_by)]"}, {"sha": "4c5f19dee12935efbbeb6b09f12ecbabf5b6765e", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -151,6 +151,19 @@ pub fn test_expect_err() {\n     err.expect(\"Got expected error\");\n }\n \n+\n+#[test]\n+pub fn test_expect_err_err() {\n+    let ok: Result<&'static str, isize> = Err(100);\n+    assert_eq!(ok.expect_err(\"Unexpected ok\"), 100);\n+}\n+#[test]\n+#[should_panic(expected=\"Got expected ok: \\\"All good\\\"\")]\n+pub fn test_expect_err_ok() {\n+    let err: Result<&'static str, isize> = Ok(\"All good\");\n+    err.expect_err(\"Got expected ok\");\n+}\n+\n #[test]\n pub fn test_iter() {\n     let ok: Result<isize, &'static str> = Ok(100);"}, {"sha": "8365e9db2a947c3e85199d92d751ee318440afef", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -22,7 +22,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(libc)]\n #![feature(staged_api)]"}, {"sha": "f5a687de64e486866ebf5dc9d519de567bca09f8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,7 +23,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(staged_api)]\n #![feature(unicode)]"}, {"sha": "a5cd9fab2cf4bca92f621174243f803c904c6b0d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -90,6 +90,7 @@\n        test(attr(deny(warnings))))]\n \n #![deny(missing_docs)]\n+#![deny(warnings)]\n #![feature(staged_api)]\n \n use self::Name::*;\n@@ -968,7 +969,6 @@ fn test_split_within() {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use super::Fail::*;\n \n     use std::result::Result::{Err, Ok};\n     use std::result;"}, {"sha": "8e587ad211de80c3c2e50b5d9672a1e527690794", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -292,7 +292,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(str_escape)]\n "}, {"sha": "7d57bdcdbb56540f37afe5a934ce12d33a6ca7fc", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1 +1 @@\n-Subproject commit 98589876259e19f13eab81b033ced95bbb6deca0\n+Subproject commit 7d57bdcdbb56540f37afe5a934ce12d33a6ca7fc"}, {"sha": "057df647c7257df027fd7d6eab6d8ab52c2a64a9", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -168,7 +168,7 @@\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(deny(warnings))))]\n #![deny(missing_docs)]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(staged_api)]\n "}, {"sha": "348180a48dc38323e6c33913f004922fa84fac2e", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -21,7 +21,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(staged_api)]\n "}, {"sha": "90f4b364482e6390f6cb552e6dfe00575339df1a", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -30,7 +30,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(alloc)]\n #![feature(core_intrinsics)]"}, {"sha": "93bc867462568cf4641ee1280757b4d94127ca3a", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,22 +15,19 @@\n //! Currently the primary use of this crate is to provide the ability to define\n //! new custom derive modes through `#[proc_macro_derive]`.\n //!\n-//! Added recently as part of [RFC 1681] this crate is currently *unstable* and\n-//! requires the `#![feature(proc_macro_lib)]` directive to use.\n-//!\n-//! [RFC 1681]: https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\n-//!\n //! Note that this crate is intentionally very bare-bones currently. The main\n //! type, `TokenStream`, only supports `fmt::Display` and `FromStr`\n //! implementations, indicating that it can only go to and come from a string.\n //! This functionality is intended to be expanded over time as more surface\n //! area for macro authors is stabilized.\n+//!\n+//! See [the book](../../book/procedural-macros.html) for more.\n \n #![crate_name = \"proc_macro\"]\n-#![unstable(feature = \"proc_macro_lib\", issue = \"27812\")]\n+#![stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n #![deny(missing_docs)]\n \n #![feature(rustc_private)]\n@@ -55,12 +52,14 @@ use syntax::ptr::P;\n ///\n /// The API of this type is intentionally bare-bones, but it'll be expanded over\n /// time!\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n pub struct TokenStream {\n     inner: Vec<P<ast::Item>>,\n }\n \n /// Error returned from `TokenStream::from_str`.\n #[derive(Debug)]\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n pub struct LexError {\n     _inner: (),\n }\n@@ -131,6 +130,7 @@ pub mod __internal {\n     }\n }\n \n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n     type Err = LexError;\n \n@@ -154,6 +154,7 @@ impl FromStr for TokenStream {\n     }\n }\n \n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for item in self.inner.iter() {"}, {"sha": "0a7d352584872c3f921997b1ed28419d92366af4", "filename": "src/libproc_macro_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibproc_macro_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibproc_macro_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -80,7 +80,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "0dd9aaab1c63a4b922d8685b2fbd05f27c85ce40", "filename": "src/libproc_macro_tokens/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibproc_macro_tokens%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibproc_macro_tokens%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -52,7 +52,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(staged_api)]\n #![feature(rustc_private)]"}, {"sha": "0cf70880d328ba0fb61bdab3add134c1d2a569f5", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,7 +23,7 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n #![no_std]\n #![unstable(feature = \"rand\",\n             reason = \"use `rand` from crates.io\","}, {"sha": "35afdd75cb8c4f47baf90f1a59af38cb8ecf41b9", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -18,6 +18,7 @@ use hir::{self, PatKind};\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n@@ -42,10 +43,23 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let fn_exit = graph.add_node(CFGNodeData::Exit);\n     let body_exit;\n \n+    // Find the function this expression is from.\n+    let mut node_id = body.id;\n+    loop {\n+        let node = tcx.map.get(node_id);\n+        if hir::map::blocks::FnLikeNode::from_node(node).is_some() {\n+            break;\n+        }\n+        let parent = tcx.map.get_parent_node(node_id);\n+        assert!(node_id != parent);\n+        node_id = parent;\n+    }\n+\n     let mut cfg_builder = CFGBuilder {\n+        tcx: tcx,\n+        tables: tcx.item_tables(tcx.map.local_def_id(node_id)),\n         graph: graph,\n         fn_exit: fn_exit,\n-        tcx: tcx,\n         loop_scopes: Vec::new()\n     };\n     body_exit = cfg_builder.expr(body, entry);\n@@ -310,11 +324,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n-            hir::ExprBinary(_, ref l, ref r) if self.tcx.tables().is_method_call(expr.id) => {\n+            hir::ExprBinary(_, ref l, ref r) if self.tables.is_method_call(expr.id) => {\n                 self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n-            hir::ExprUnary(_, ref e) if self.tcx.tables().is_method_call(expr.id) => {\n+            hir::ExprUnary(_, ref e) if self.tables.is_method_call(expr.id) => {\n                 self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n@@ -368,9 +382,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let fn_ty = match self.tcx.tables().method_map.get(&method_call) {\n+        let fn_ty = match self.tables.method_map.get(&method_call) {\n             Some(method) => method.ty,\n-            None => self.tcx.tables().expr_ty_adjusted(func_or_rcvr)\n+            None => self.tables.expr_ty_adjusted(func_or_rcvr)\n         };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "a68876b5ae9c0b6bdbe03bc862f5727317c75b14", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -113,6 +113,7 @@ pub enum DepNode<D: Clone + Debug> {\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n+    Tables(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -162,6 +163,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature,\n             AssociatedItemDefIds,\n             InherentImpls,\n+            Tables,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -230,6 +232,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n+            Tables(ref d) => op(d).map(Tables),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "91e88e2c73ff892947f387eff7f606cbbfc1a94f", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -45,15 +45,6 @@ pub struct FnLikeNode<'a> { node: map::Node<'a> }\n /// corresponds to some FnLikeNode.\n pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n-/// Components shared by fn-like things (fn items, methods, closures).\n-pub struct FnParts<'a> {\n-    pub decl: &'a FnDecl,\n-    pub body: ast::BodyId,\n-    pub kind: FnKind<'a>,\n-    pub span: Span,\n-    pub id:   NodeId,\n-}\n-\n impl MaybeFnLike for ast::Item {\n     fn is_fn_like(&self) -> bool {\n         match self.node { ast::ItemFn(..) => true, _ => false, }\n@@ -165,16 +156,6 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn to_fn_parts(self) -> FnParts<'a> {\n-        FnParts {\n-            decl: self.decl(),\n-            body: self.body(),\n-            kind: self.kind(),\n-            span: self.span(),\n-            id:   self.id(),\n-        }\n-    }\n-\n     pub fn body(self) -> ast::BodyId {\n         self.handle(|i: ItemFnParts<'a>|  i.body,\n                     |_, _, _: &'a ast::MethodSig, _, body: ast::BodyId, _, _|  body,"}, {"sha": "bd0ff695d093a518ca58c395b59953f5cf477fc0", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,10 +23,6 @@ pub struct NodeCollector<'ast> {\n     pub(super) map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n-    /// If true, completely ignore nested items. We set this when loading\n-    /// HIR from metadata, since in that case we only want the HIR for\n-    /// one specific item (and not the ones nested inside of it).\n-    pub ignore_nested_items: bool\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -35,30 +31,12 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n-            ignore_nested_items: false\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n         collector\n     }\n \n-    pub(super) fn extend(krate: &'ast Crate,\n-                         parent: &'ast InlinedItem,\n-                         parent_node: NodeId,\n-                         map: Vec<MapEntry<'ast>>)\n-                         -> NodeCollector<'ast> {\n-        let mut collector = NodeCollector {\n-            krate: krate,\n-            map: map,\n-            parent_node: parent_node,\n-            ignore_nested_items: true\n-        };\n-\n-        collector.insert_entry(parent_node, RootInlinedParent(parent));\n-\n-        collector\n-    }\n-\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -92,27 +70,19 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        if !self.ignore_nested_items {\n-            self.visit_item(self.krate.item(item.id))\n-        }\n+        self.visit_item(self.krate.item(item.id));\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        if !self.ignore_nested_items {\n-            self.visit_trait_item(self.krate.trait_item(item_id))\n-        }\n+        self.visit_trait_item(self.krate.trait_item(item_id));\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        if !self.ignore_nested_items {\n-            self.visit_impl_item(self.krate.impl_item(item_id))\n-        }\n+        self.visit_impl_item(self.krate.impl_item(item_id));\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        if !self.ignore_nested_items {\n-            self.visit_body(self.krate.body(id))\n-        }\n+        self.visit_body(self.krate.body(id));\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {"}, {"sha": "7c0621279fd6f607f26e0675ec4484c8886db298", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 79, "deletions": 163, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -25,28 +25,18 @@ use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::intravisit::Visitor;\n use hir::print::Nested;\n+use util::nodemap::DefIdMap;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n use std::io;\n-use std::mem;\n \n pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n \n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Debug)]\n-struct InlinedItem {\n-    def_id: DefId,\n-    body: Body,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n@@ -99,7 +89,6 @@ enum MapEntry<'ast> {\n \n     /// Roots for node trees.\n     RootCrate,\n-    RootInlinedParent(&'ast InlinedItem)\n }\n \n impl<'ast> Clone for MapEntry<'ast> {\n@@ -152,8 +141,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryVisibility(id, _) => id,\n \n             NotPresent |\n-            RootCrate |\n-            RootInlinedParent(_) => return None,\n+            RootCrate => return None,\n         })\n     }\n \n@@ -225,15 +213,15 @@ impl<'ast> MapEntry<'ast> {\n pub struct Forest {\n     krate: Crate,\n     pub dep_graph: DepGraph,\n-    inlined_items: TypedArena<InlinedItem>\n+    inlined_bodies: TypedArena<Body>\n }\n \n impl Forest {\n     pub fn new(krate: Crate, dep_graph: &DepGraph) -> Forest {\n         Forest {\n             krate: krate,\n             dep_graph: dep_graph.clone(),\n-            inlined_items: TypedArena::new()\n+            inlined_bodies: TypedArena::new()\n         }\n     }\n \n@@ -263,20 +251,15 @@ pub struct Map<'ast> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: RefCell<Vec<MapEntry<'ast>>>,\n+    map: Vec<MapEntry<'ast>>,\n \n     definitions: Definitions,\n \n-    /// All NodeIds that are numerically greater or equal to this value come\n-    /// from inlined items.\n-    local_node_id_watermark: NodeId,\n+    /// Bodies inlined from other crates are cached here.\n+    inlined_bodies: RefCell<DefIdMap<&'ast Body>>,\n }\n \n impl<'ast> Map<'ast> {\n-    pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n-        id >= self.local_node_id_watermark\n-    }\n-\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n@@ -289,111 +272,71 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n-        let map = self.map.borrow();\n         let mut id = id0;\n-        if !self.is_inlined_node_id(id) {\n-            let mut last_expr = None;\n-            loop {\n-                let entry = map[id.as_usize()];\n-                match entry {\n-                    EntryItem(..) |\n-                    EntryTraitItem(..) |\n-                    EntryImplItem(..) => {\n-                        if let Some(last_id) = last_expr {\n-                            // The body may have a separate dep node\n-                            if entry.is_body_owner(last_id) {\n-                                let def_id = self.local_def_id(id);\n-                                return DepNode::HirBody(def_id);\n-                            }\n+        let mut last_expr = None;\n+        loop {\n+            let entry = self.map[id.as_usize()];\n+            match entry {\n+                EntryItem(..) |\n+                EntryTraitItem(..) |\n+                EntryImplItem(..) => {\n+                    if let Some(last_id) = last_expr {\n+                        // The body may have a separate dep node\n+                        if entry.is_body_owner(last_id) {\n+                            let def_id = self.local_def_id(id);\n+                            return DepNode::HirBody(def_id);\n                         }\n-                        return DepNode::Hir(self.local_def_id(id));\n                     }\n+                    return DepNode::Hir(self.local_def_id(id));\n+                }\n \n-                    EntryVariant(p, v) => {\n-                        id = p;\n+                EntryVariant(p, v) => {\n+                    id = p;\n \n-                        if last_expr.is_some() {\n-                            if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n-                                // The enum parent holds both Hir and HirBody nodes.\n-                                let def_id = self.local_def_id(id);\n-                                return DepNode::HirBody(def_id);\n-                            }\n+                    if last_expr.is_some() {\n+                        if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n+                            // The enum parent holds both Hir and HirBody nodes.\n+                            let def_id = self.local_def_id(id);\n+                            return DepNode::HirBody(def_id);\n                         }\n                     }\n+                }\n \n-                    EntryForeignItem(p, _) |\n-                    EntryField(p, _) |\n-                    EntryStmt(p, _) |\n-                    EntryTy(p, _) |\n-                    EntryTraitRef(p, _) |\n-                    EntryLocal(p, _) |\n-                    EntryPat(p, _) |\n-                    EntryBlock(p, _) |\n-                    EntryStructCtor(p, _) |\n-                    EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) |\n-                    EntryVisibility(p, _) =>\n-                        id = p,\n-\n-                    EntryExpr(p, _) => {\n-                        last_expr = Some(id);\n-                        id = p;\n-                    }\n-\n-                    RootCrate => {\n-                        return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n-                    }\n-\n-                    RootInlinedParent(_) =>\n-                        bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n-\n-                    NotPresent =>\n-                        // Some nodes, notably macro definitions, are not\n-                        // present in the map for whatever reason, but\n-                        // they *do* have def-ids. So if we encounter an\n-                        // empty hole, check for that case.\n-                        return self.opt_local_def_id(id)\n-                                   .map(|def_id| DepNode::Hir(def_id))\n-                                   .unwrap_or_else(|| {\n-                                       bug!(\"Walking parents from `{}` \\\n-                                             led to `NotPresent` at `{}`\",\n-                                            id0, id)\n-                                   }),\n+                EntryForeignItem(p, _) |\n+                EntryField(p, _) |\n+                EntryStmt(p, _) |\n+                EntryTy(p, _) |\n+                EntryTraitRef(p, _) |\n+                EntryLocal(p, _) |\n+                EntryPat(p, _) |\n+                EntryBlock(p, _) |\n+                EntryStructCtor(p, _) |\n+                EntryLifetime(p, _) |\n+                EntryTyParam(p, _) |\n+                EntryVisibility(p, _) =>\n+                    id = p,\n+\n+                EntryExpr(p, _) => {\n+                    last_expr = Some(id);\n+                    id = p;\n                 }\n-            }\n-        } else {\n-            // reading from an inlined def-id is really a read out of\n-            // the metadata from which we loaded the item.\n-            loop {\n-                match map[id.as_usize()] {\n-                    EntryItem(p, _) |\n-                    EntryForeignItem(p, _) |\n-                    EntryTraitItem(p, _) |\n-                    EntryImplItem(p, _) |\n-                    EntryVariant(p, _) |\n-                    EntryField(p, _) |\n-                    EntryExpr(p, _) |\n-                    EntryStmt(p, _) |\n-                    EntryTy(p, _) |\n-                    EntryTraitRef(p, _) |\n-                    EntryLocal(p, _) |\n-                    EntryPat(p, _) |\n-                    EntryBlock(p, _) |\n-                    EntryStructCtor(p, _) |\n-                    EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) |\n-                    EntryVisibility(p, _) =>\n-                        id = p,\n-\n-                    RootInlinedParent(parent) =>\n-                        return DepNode::MetaData(parent.def_id),\n-\n-                    RootCrate =>\n-                        bug!(\"node {} has crate ancestor but is inlined\", id0),\n-\n-                    NotPresent =>\n-                        bug!(\"node {} is inlined but not present in map\", id0),\n+\n+                RootCrate => {\n+                    return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n                 }\n+\n+                NotPresent =>\n+                    // Some nodes, notably macro definitions, are not\n+                    // present in the map for whatever reason, but\n+                    // they *do* have def-ids. So if we encounter an\n+                    // empty hole, check for that case.\n+                    return self.opt_local_def_id(id)\n+                               .map(|def_id| DepNode::Hir(def_id))\n+                               .unwrap_or_else(|| {\n+                                   bug!(\"Walking parents from `{}` \\\n+                                         led to `NotPresent` at `{}`\",\n+                                        id0, id)\n+                               }),\n             }\n         }\n     }\n@@ -442,11 +385,11 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn entry_count(&self) -> usize {\n-        self.map.borrow().len()\n+        self.map.len()\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id.as_usize()).cloned()\n+        self.map.get(id.as_usize()).cloned()\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -483,7 +426,7 @@ impl<'ast> Map<'ast> {\n     /// for embedded constant expressions (e.g. `N` in `[T; N]`).\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n-        if self.map.borrow()[parent.as_usize()].is_body_owner(node_id) {\n+        if self.map[parent.as_usize()].is_body_owner(node_id) {\n             parent\n         } else {\n             node_id\n@@ -644,11 +587,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n-        let parent = self.get_parent(id);\n-        match self.find_entry(parent) {\n-            Some(RootInlinedParent(ii)) => ii.def_id,\n-            _ => self.local_def_id(parent)\n-        }\n+        self.local_def_id(self.get_parent(id))\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n@@ -660,8 +599,6 @@ impl<'ast> Map<'ast> {\n                     _ => None\n                 }\n             }\n-            /// Wrong but OK, because the only inlined foreign items are intrinsics.\n-            Some(RootInlinedParent(_)) => Some(Abi::RustIntrinsic),\n             _ => None\n         };\n         match abi {\n@@ -737,11 +674,17 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_inlined_body(&self, id: NodeId) -> &'ast Body {\n-        match self.find_entry(id) {\n-            Some(RootInlinedParent(inlined_item)) => &inlined_item.body,\n-            _ => bug!(\"expected inlined item, found {}\", self.node_to_string(id)),\n-        }\n+    pub fn get_inlined_body(&self, def_id: DefId) -> Option<&'ast Body> {\n+        self.inlined_bodies.borrow().get(&def_id).map(|&body| {\n+            self.dep_graph.read(DepNode::MetaData(def_id));\n+            body\n+        })\n+    }\n+\n+    pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'ast Body {\n+        let body = self.forest.inlined_bodies.alloc(body);\n+        self.inlined_bodies.borrow_mut().insert(def_id, body);\n+        body\n     }\n \n     /// Returns the name associated with the given NodeId's AST.\n@@ -824,7 +767,6 @@ impl<'ast> Map<'ast> {\n             Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n \n             Some(RootCrate) => self.forest.krate.span,\n-            Some(RootInlinedParent(parent)) => parent.body.value.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n@@ -973,41 +915,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    let local_node_id_watermark = NodeId::new(map.len());\n-\n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n-        map: RefCell::new(map),\n+        map: map,\n         definitions: definitions,\n-        local_node_id_watermark: local_node_id_watermark,\n+        inlined_bodies: RefCell::new(DefIdMap()),\n     }\n }\n \n-/// Used for bodies loaded from external crate that are being inlined into this\n-/// crate.\n-pub fn map_decoded_body<'ast>(map: &Map<'ast>,\n-                              def_id: DefId,\n-                              body: Body,\n-                              parent_id: NodeId)\n-                              -> &'ast Body {\n-    let _ignore = map.forest.dep_graph.in_ignore();\n-\n-    let ii = map.forest.inlined_items.alloc(InlinedItem {\n-        def_id: def_id,\n-        body: body\n-    });\n-\n-    let mut collector = NodeCollector::extend(map.krate(),\n-                                              ii,\n-                                              parent_id,\n-                                              mem::replace(&mut *map.map.borrow_mut(), vec![]));\n-    collector.visit_body(&ii.body);\n-    *map.map.borrow_mut() = collector.map;\n-\n-    &ii.body\n-}\n-\n /// Identical to the `PpAnn` implementation for `hir::Crate`,\n /// except it avoids creating a dependency on the whole crate.\n impl<'ast> print::PpAnn for Map<'ast> {"}, {"sha": "c06c53810d7536eabcf5cf19e214b018e5940965", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1210,6 +1210,7 @@ impl<'a> State<'a> {\n \n     pub fn print_expr(&mut self, expr: &hir::Expr) -> io::Result<()> {\n         self.maybe_print_comment(expr.span.lo)?;\n+        self.print_outer_attributes(&expr.attrs)?;\n         self.ibox(indent_unit)?;\n         self.ann.pre(self, NodeExpr(expr))?;\n         match expr.node {"}, {"sha": "095d2a78a94cd993e0b5a0597f07f50006404afc", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -113,6 +113,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        fn trait_item_scope_tag(item: &hir::TraitItem) -> &'static str {\n+            match item.node {\n+                hir::TraitItemKind::Method(..) => \"method body\",\n+                hir::TraitItemKind::Const(..) |\n+                hir::TraitItemKind::Type(..) => \"associated item\"\n+            }\n+        }\n+\n+        fn impl_item_scope_tag(item: &hir::ImplItem) -> &'static str {\n+            match item.node {\n+                hir::ImplItemKind::Method(..) => \"method body\",\n+                hir::ImplItemKind::Const(..) |\n+                hir::ImplItemKind::Type(_) => \"associated item\"\n+            }\n+        }\n+\n         fn explain_span<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                         heading: &str, span: Span)\n                                         -> (String, Option<Span>) {\n@@ -148,6 +164,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     },\n                     Some(ast_map::NodeStmt(_)) => \"statement\",\n                     Some(ast_map::NodeItem(it)) => item_scope_tag(&it),\n+                    Some(ast_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n+                    Some(ast_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -186,23 +204,31 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                match self.map.find(fr.scope.node_id(&self.region_maps)) {\n-                    Some(ast_map::NodeBlock(ref blk)) => {\n-                        let (msg, opt_span) = explain_span(self, \"block\", blk.span);\n-                        (format!(\"{} {}\", prefix, msg), opt_span)\n-                    }\n-                    Some(ast_map::NodeItem(it)) => {\n-                        let tag = item_scope_tag(&it);\n-                        let (msg, opt_span) = explain_span(self, tag, it.span);\n-                        (format!(\"{} {}\", prefix, msg), opt_span)\n+                let node = fr.scope.node_id(&self.region_maps);\n+                let unknown;\n+                let tag = match self.map.find(node) {\n+                    Some(ast_map::NodeBlock(_)) |\n+                    Some(ast_map::NodeExpr(_)) => \"body\",\n+                    Some(ast_map::NodeItem(it)) => item_scope_tag(&it),\n+                    Some(ast_map::NodeTraitItem(it)) => trait_item_scope_tag(&it),\n+                    Some(ast_map::NodeImplItem(it)) => impl_item_scope_tag(&it),\n+\n+                    // this really should not happen, but it does:\n+                    // FIXME(#27942)\n+                    Some(_) => {\n+                        unknown = format!(\"unexpected node ({}) for scope {:?}.  \\\n+                                           Please report a bug.\",\n+                                          self.map.node_to_string(node), fr.scope);\n+                        &unknown\n                     }\n-                    Some(_) | None => {\n-                        // this really should not happen, but it does:\n-                        // FIXME(#27942)\n-                        (format!(\"{} unknown free region bounded by scope {:?}\",\n-                                 prefix, fr.scope), None)\n+                    None => {\n+                        unknown = format!(\"unknown node for scope {:?}.  \\\n+                                           Please report a bug.\", fr.scope);\n+                        &unknown\n                     }\n-                }\n+                };\n+                let (msg, opt_span) = explain_span(self, tag, self.map.span(node));\n+                (format!(\"{} {}\", prefix, msg), opt_span)\n             }\n \n             ty::ReStatic => (\"the static lifetime\".to_owned(), None),"}, {"sha": "b44e1563ee7ed64839a37013561808666a029e2e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 139, "deletions": 53, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -27,7 +27,6 @@ use middle::region::CodeExtent;\n use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n-use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n@@ -37,10 +36,11 @@ use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n+use std::ops::Deref;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n-use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use arena::DroplessArena;\n \n use self::combine::CombineFields;\n@@ -76,28 +76,63 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-/// A version of &ty::Tables which can be global or local.\n-/// Only the local version supports borrow_mut.\n+/// A version of &ty::Tables which can be `Missing` (not needed),\n+/// `InProgress` (during typeck) or `Interned` (result of typeck).\n+/// Only the `InProgress` version supports `borrow_mut`.\n #[derive(Copy, Clone)]\n pub enum InferTables<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    Global(&'a RefCell<ty::Tables<'gcx>>),\n-    Local(&'a RefCell<ty::Tables<'tcx>>)\n+    Interned(&'a ty::Tables<'gcx>),\n+    InProgress(&'a RefCell<ty::Tables<'tcx>>),\n+    Missing\n+}\n+\n+pub enum InferTablesRef<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    Interned(&'a ty::Tables<'gcx>),\n+    InProgress(Ref<'a, ty::Tables<'tcx>>)\n+}\n+\n+impl<'a, 'gcx, 'tcx> Deref for InferTablesRef<'a, 'gcx, 'tcx> {\n+    type Target = ty::Tables<'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        match *self {\n+            InferTablesRef::Interned(tables) => tables,\n+            InferTablesRef::InProgress(ref tables) => tables\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> InferTables<'a, 'gcx, 'tcx> {\n-    pub fn borrow(self) -> Ref<'a, ty::Tables<'tcx>> {\n+    pub fn borrow(self) -> InferTablesRef<'a, 'gcx, 'tcx> {\n         match self {\n-            InferTables::Global(tables) => tables.borrow(),\n-            InferTables::Local(tables) => tables.borrow()\n+            InferTables::Interned(tables) => InferTablesRef::Interned(tables),\n+            InferTables::InProgress(tables) => InferTablesRef::InProgress(tables.borrow()),\n+            InferTables::Missing => {\n+                bug!(\"InferTables: infcx.tables.borrow() with no tables\")\n+            }\n+        }\n+    }\n+\n+    pub fn expect_interned(self) -> &'a ty::Tables<'gcx> {\n+        match self {\n+            InferTables::Interned(tables) => tables,\n+            InferTables::InProgress(_) => {\n+                bug!(\"InferTables: infcx.tables.expect_interned() during type-checking\");\n+            }\n+            InferTables::Missing => {\n+                bug!(\"InferTables: infcx.tables.expect_interned() with no tables\")\n+            }\n         }\n     }\n \n     pub fn borrow_mut(self) -> RefMut<'a, ty::Tables<'tcx>> {\n         match self {\n-            InferTables::Global(_) => {\n+            InferTables::Interned(_) => {\n                 bug!(\"InferTables: infcx.tables.borrow_mut() outside of type-checking\");\n             }\n-            InferTables::Local(tables) => tables.borrow_mut()\n+            InferTables::InProgress(tables) => tables.borrow_mut(),\n+            InferTables::Missing => {\n+                bug!(\"InferTables: infcx.tables.borrow_mut() with no tables\")\n+            }\n         }\n     }\n }\n@@ -370,27 +405,84 @@ impl fmt::Display for FixupError {\n     }\n }\n \n+pub trait InferEnv<'a, 'tcx> {\n+    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>);\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (None, None, None)\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::ParameterEnvironment<'tcx> {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (None, None, Some(self))\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for (&'a ty::Tables<'tcx>, ty::ParameterEnvironment<'tcx>) {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (Some(self.0), None, Some(self.1))\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for (ty::Tables<'tcx>, ty::ParameterEnvironment<'tcx>) {\n+    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        (None, Some(self.0), Some(self.1))\n+    }\n+}\n+\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n+    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                -> (Option<&'a ty::Tables<'tcx>>,\n+                    Option<ty::Tables<'tcx>>,\n+                    Option<ty::ParameterEnvironment<'tcx>>) {\n+        let item_id = tcx.map.body_owner(self);\n+        (Some(tcx.item_tables(tcx.map.local_def_id(item_id))),\n+         None,\n+         Some(ty::ParameterEnvironment::for_item(tcx, item_id)))\n+    }\n+}\n+\n /// Helper type of a temporary returned by tcx.infer_ctxt(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: DroplessArena,\n-    tables: Option<RefCell<ty::Tables<'tcx>>>,\n+    fresh_tables: Option<RefCell<ty::Tables<'tcx>>>,\n+    tables: Option<&'a ty::Tables<'gcx>>,\n     param_env: Option<ty::ParameterEnvironment<'gcx>>,\n     projection_mode: Reveal,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n-    pub fn infer_ctxt(self,\n-                      tables: Option<ty::Tables<'tcx>>,\n-                      param_env: Option<ty::ParameterEnvironment<'gcx>>,\n-                      projection_mode: Reveal)\n-                      -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+    pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self,\n+                                             env: E,\n+                                             projection_mode: Reveal)\n+                                             -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+        let (tables, fresh_tables, param_env) = env.to_parts(self);\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n-            tables: tables.map(RefCell::new),\n+            fresh_tables: fresh_tables.map(RefCell::new),\n+            tables: tables,\n             param_env: param_env,\n             projection_mode: projection_mode,\n         }\n@@ -399,16 +491,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     /// Fake InferCtxt with the global tcx. Used by pre-MIR borrowck\n     /// for MemCategorizationContext/ExprUseVisitor.\n     /// If any inference functionality is used, ICEs will occur.\n-    pub fn borrowck_fake_infer_ctxt(self, param_env: ty::ParameterEnvironment<'gcx>)\n+    pub fn borrowck_fake_infer_ctxt(self, body: hir::BodyId)\n                                     -> InferCtxt<'a, 'gcx, 'gcx> {\n+        let (tables, _, param_env) = body.to_parts(self);\n         InferCtxt {\n             tcx: self,\n-            tables: InferTables::Global(&self.tables),\n+            tables: InferTables::Interned(tables.unwrap()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(self),\n-            parameter_environment: param_env,\n+            parameter_environment: param_env.unwrap(),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n@@ -428,15 +521,14 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref arena,\n-            ref tables,\n+            ref fresh_tables,\n+            tables,\n             ref mut param_env,\n             projection_mode,\n         } = *self;\n-        let tables = if let Some(ref tables) = *tables {\n-            InferTables::Local(tables)\n-        } else {\n-            InferTables::Global(&global_tcx.tables)\n-        };\n+        let tables = tables.map(InferTables::Interned).unwrap_or_else(|| {\n+            fresh_tables.as_ref().map_or(InferTables::Missing, InferTables::InProgress)\n+        });\n         let param_env = param_env.take().unwrap_or_else(|| {\n             global_tcx.empty_parameter_environment()\n         });\n@@ -555,7 +647,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+        self.infer_ctxt((), Reveal::All).enter(|infcx| {\n             value.trans_normalize(&infcx)\n         })\n     }\n@@ -573,7 +665,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(None, Some(env.clone()), Reveal::All).enter(|infcx| {\n+        self.infer_ctxt(env.clone(), Reveal::All).enter(|infcx| {\n             value.trans_normalize(&infcx)\n        })\n     }\n@@ -1490,8 +1582,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // Even if the type may have no inference variables, during\n             // type-checking closure types are in local tables only.\n             let local_closures = match self.tables {\n-                InferTables::Local(_) => ty.has_closure_types(),\n-                InferTables::Global(_) => false\n+                InferTables::InProgress(_) => ty.has_closure_types(),\n+                _ => false\n             };\n             if !local_closures {\n                 return ty.moves_by_default(self.tcx.global_tcx(), self.param_env(), span);\n@@ -1526,15 +1618,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::Adjustment<'tcx>>> {\n-        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<adjustment::Adjustment<'tcx>> {\n-            &tables.adjustments\n-        }\n-\n-        Ref::map(self.tables.borrow(), project_adjustments)\n-    }\n-\n     pub fn is_method_call(&self, id: ast::NodeId) -> bool {\n         self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n     }\n@@ -1555,30 +1638,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>\n     {\n-        if def_id.is_local() {\n-            self.tables.borrow().closure_kinds.get(&def_id).cloned()\n-        } else {\n-            // During typeck, ALL closures are local. But afterwards,\n-            // during trans, we see closure ids from other traits.\n-            // That may require loading the closure data out of the\n-            // cstore.\n-            Some(self.tcx.closure_kind(def_id))\n+        if let InferTables::InProgress(tables) = self.tables {\n+            if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+                return tables.borrow().closure_kinds.get(&id).cloned();\n+            }\n         }\n+\n+        // During typeck, ALL closures are local. But afterwards,\n+        // during trans, we see closure ids from other traits.\n+        // That may require loading the closure data out of the\n+        // cstore.\n+        Some(self.tcx.closure_kind(def_id))\n     }\n \n     pub fn closure_type(&self,\n                         def_id: DefId,\n                         substs: ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        if let InferTables::Local(tables) = self.tables {\n-            if let Some(ty) = tables.borrow().closure_tys.get(&def_id) {\n-                return ty.subst(self.tcx, substs.substs);\n+        if let InferTables::InProgress(tables) = self.tables {\n+            if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+                if let Some(ty) = tables.borrow().closure_tys.get(&id) {\n+                    return ty.subst(self.tcx, substs.substs);\n+                }\n             }\n         }\n \n-        let closure_ty = self.tcx.closure_type(def_id, substs);\n-        closure_ty\n+        self.tcx.closure_type(def_id, substs)\n     }\n }\n "}, {"sha": "151d7cd17ab14296284f34100e667cf71ae02302", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -21,7 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(associated_consts)]\n #![feature(box_patterns)]"}, {"sha": "96fb168581b2169ee141d09a22cf9280c50a4155", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -70,6 +70,12 @@ declare_lint! {\n     \"detects unreachable code paths\"\n }\n \n+declare_lint! {\n+    pub UNREACHABLE_PATTERNS,\n+    Warn,\n+    \"detects unreachable patterns\"\n+}\n+\n declare_lint! {\n     pub WARNINGS,\n     Warn,\n@@ -239,6 +245,7 @@ impl LintPass for HardwiredLints {\n             UNUSED_ASSIGNMENTS,\n             DEAD_CODE,\n             UNREACHABLE_CODE,\n+            UNREACHABLE_PATTERNS,\n             WARNINGS,\n             UNUSED_FEATURES,\n             STABLE_FEATURES,"}, {"sha": "7d85f3607b597445aac03cb7f1256ac05ca4534c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -27,7 +27,7 @@ use self::TargetLint::*;\n \n use dep_graph::DepNode;\n use middle::privacy::AccessLevels;\n-use ty::TyCtxt;\n+use ty::{self, TyCtxt};\n use session::{config, early_error, Session};\n use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n use lint::{EarlyLintPassObject, LateLintPassObject};\n@@ -336,6 +336,9 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n+    /// Side-tables for the body we are in.\n+    pub tables: &'a ty::Tables<'tcx>,\n+\n     /// The crate being checked.\n     pub krate: &'a hir::Crate,\n \n@@ -702,24 +705,6 @@ impl<'a> EarlyContext<'a> {\n     }\n }\n \n-impl<'a, 'tcx> LateContext<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           krate: &'a hir::Crate,\n-           access_levels: &'a AccessLevels) -> LateContext<'a, 'tcx> {\n-        // We want to own the lint store, so move it out of the session.\n-        let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n-                                      LintStore::new());\n-\n-        LateContext {\n-            tcx: tcx,\n-            krate: krate,\n-            access_levels: access_levels,\n-            lints: lint_store,\n-            level_stack: vec![],\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     /// Get the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n@@ -796,6 +781,14 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n+    }\n+\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);\n@@ -837,10 +830,15 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n                 body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n+        // Wrap in tables here, not just in visit_nested_body,\n+        // in order for `check_fn` to be able to use them.\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body_id);\n         let body = self.tcx.map.body(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n+        self.tables = old_tables;\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -1209,7 +1207,17 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n     let krate = tcx.map.krate();\n-    let mut cx = LateContext::new(tcx, krate, access_levels);\n+\n+    // We want to own the lint store, so move it out of the session.\n+    let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), LintStore::new());\n+    let mut cx = LateContext {\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        krate: krate,\n+        access_levels: access_levels,\n+        lints: lint_store,\n+        level_stack: vec![],\n+    };\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {"}, {"sha": "f583f601726edc25319e49c90510ed7f1627a0c7", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,23 +15,21 @@ use hir::def_id::DefId;\n use rustc_const_math::*;\n use self::ConstVal::*;\n \n+use std::collections::BTreeMap;\n+\n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal {\n     Float(ConstFloat),\n     Integral(ConstInt),\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n-    Struct(ast::NodeId),\n-    Tuple(ast::NodeId),\n     Function(DefId),\n-    Array(ast::NodeId, u64),\n-    Repeat(ast::NodeId, u64),\n+    Struct(BTreeMap<ast::Name, ConstVal>),\n+    Tuple(Vec<ConstVal>),\n+    Array(Vec<ConstVal>),\n+    Repeat(Box<ConstVal>, u64),\n     Char(char),\n-    /// A value that only occurs in case `eval_const_expr` reported an error. You should never\n-    /// handle this case. Its sole purpose is to allow more errors to be reported instead of\n-    /// causing a fatal error.\n-    Dummy,\n }\n \n impl ConstVal {\n@@ -48,7 +46,6 @@ impl ConstVal {\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n             Char(..) => \"char\",\n-            Dummy => \"dummy value\",\n         }\n     }\n }"}, {"sha": "496a3d4a498478ce148a59f0d7d9170ec81a7267", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -211,6 +211,7 @@ pub trait CrateStore<'tcx> {\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n+    fn is_exported_symbol(&self, def_id: DefId) -> bool;\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -258,11 +259,6 @@ pub trait CrateStore<'tcx> {\n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n-    /// Take a look if we need to inline or monomorphize this. If so, we\n-    /// will emit code for this item in the local crate, and thus\n-    /// create a translation item for it.\n-    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool;\n-\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum>;\n@@ -368,6 +364,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n+    fn is_exported_symbol(&self, def_id: DefId) -> bool { false }\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -436,9 +433,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n-    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool {\n-        bug!(\"can_have_local_instance\")\n-    }\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that."}, {"sha": "5af62d0172f5cad4ca88f09713248097b8877eff", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -49,6 +49,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     live_symbols: Box<FxHashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n@@ -57,19 +58,6 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a, 'tcx> {\n-        MarkSymbolVisitor {\n-            worklist: worklist,\n-            tcx: tcx,\n-            live_symbols: box FxHashSet(),\n-            struct_has_extern_repr: false,\n-            ignore_non_const_paths: false,\n-            inherited_pub_visibility: false,\n-            ignore_variant_stack: vec![],\n-        }\n-    }\n-\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             if should_explore(self.tcx, node_id) {\n@@ -109,12 +97,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n         let method_call = ty::MethodCall::expr(id);\n-        let method = self.tcx.tables().method_map[&method_call];\n+        let method = self.tables.method_map[&method_call];\n         self.check_def_id(method.def_id);\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n+        match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().field_named(name).did);\n             }\n@@ -123,7 +111,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n+        match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().fields[idx].did);\n             }\n@@ -134,7 +122,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n+        let variant = match self.tables.node_id_to_type(lhs.id).sty {\n             ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n@@ -209,7 +197,15 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n     }\n \n     fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n@@ -227,7 +223,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.id);\n                 self.handle_definition(def);\n             }\n             hir::ExprMethodCall(..) => {\n@@ -267,7 +263,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_pattern_match(pat, path.def, fields);\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.id);\n                 self.handle_definition(def);\n             }\n             _ => ()\n@@ -393,7 +389,16 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        krate: &hir::Crate)\n                        -> Box<FxHashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n-    let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n+    let mut symbol_visitor = MarkSymbolVisitor {\n+        worklist: worklist,\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        live_symbols: box FxHashSet(),\n+        struct_has_extern_repr: false,\n+        ignore_non_const_paths: false,\n+        inherited_pub_visibility: false,\n+        ignore_variant_stack: vec![],\n+    };\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n }"}, {"sha": "c42e8fcb08ced9906e7a7f4ef1631859f15abe42", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -52,6 +52,7 @@ fn type_is_unsafe_function(ty: Ty) -> bool {\n \n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n \n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n@@ -94,7 +95,15 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n     }\n \n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n@@ -163,7 +172,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.tables().method_map[&method_call].ty;\n+                let base_type = self.tables.method_map[&method_call].ty;\n                 debug!(\"effect: method call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n@@ -172,15 +181,15 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprCall(ref base, _) => {\n-                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n+                let base_type = self.tables.expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n+                let base_type = self.tables.expr_ty_adjusted(base);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -204,7 +213,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tcx.tables().expr_ty_adjusted(base_expr).sty {\n+                if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n                     if adt.is_union() {\n                         self.require_unsafe(field.span, \"access to union field\");\n                     }\n@@ -218,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n+            if let ty::TyAdt(adt, ..) = self.tables.pat_ty(pat).sty {\n                 if adt.is_union() {\n                     for field in fields {\n                         self.require_unsafe(field.span, \"matching on union field\");\n@@ -236,6 +245,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n+        tables: &ty::Tables::empty(),\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };\n "}, {"sha": "0eacbba3fdd446ec4d100b4c3a7f80b5ec298cb2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -708,7 +708,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n         let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n+        let adj = infcx.tables.borrow().adjustments.get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny |\n@@ -989,7 +989,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = tcx.tables().qpath_def(qpath, pat.id);\n+            let def = infcx.tables.borrow().qpath_def(qpath, pat.id);\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {"}, {"sha": "d42b866d47209c5663692c12570a6c78e95158e0", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -19,7 +19,7 @@ use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n use syntax_pos::Span;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -33,18 +33,6 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n-    fn visit_const(&mut self, item_id: ast::NodeId, body: hir::BodyId) {\n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n-            let mut visitor = ExprVisitor {\n-                infcx: &infcx\n-            };\n-            visitor.visit_nested_body(body);\n-        });\n-    }\n-}\n-\n struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n }\n@@ -118,64 +106,36 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    // const, static and N in [T; N].\n-    fn visit_body(&mut self, body: &'tcx hir::Body) {\n-        self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        let body = self.tcx.map.body(body_id);\n+        self.tcx.infer_ctxt(body_id, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n             visitor.visit_body(body);\n         });\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(body)) = item.node {\n-            self.visit_const(item.id, body);\n-        } else {\n-            intravisit::walk_trait_item(self, item);\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, body) = item.node {\n-            self.visit_const(item.id, body);\n-        } else {\n-            intravisit::walk_impl_item(self, item);\n-        }\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, id: ast::NodeId) {\n-        if let FnKind::Closure(..) = fk {\n-            span_bug!(s, \"intrinsicck: closure outside of function\")\n-        }\n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n-            let mut visitor = ExprVisitor {\n-                infcx: &infcx\n-            };\n-            visitor.visit_fn(fk, fd, b, s, id);\n-        });\n+        self.visit_body(body);\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.infcx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n-            self.infcx.tcx.tables().qpath_def(qpath, expr.id)\n+            self.infcx.tables.borrow().qpath_def(qpath, expr.id)\n         } else {\n             Def::Err\n         };\n         match def {\n             Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n+                let typ = self.infcx.tables.borrow().node_id_to_type(expr.id);\n+                let typ = self.infcx.tcx.lift_to_global(&typ).unwrap();\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                         let from = bare_fn_ty.sig.skip_binder().inputs()[0];"}, {"sha": "5307b4ec774524e85958893d782f62c8263f3159", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -351,22 +351,6 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        check_local(self, l);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        check_expr(self, ex);\n-    }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        check_arm(self, a);\n-    }\n-}\n-\n fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n                           fk: FnKind<'tcx>,\n                           decl: &'tcx hir::FnDecl,\n@@ -394,24 +378,13 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     // and so forth:\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n-    // Special nodes and variables:\n-    // - exit_ln represents the end of the fn, either by return or panic\n-    // - implicit_ret_var is a pseudo-variable that represents\n-    //   an implicit return\n-    let specials = Specials {\n-        exit_ln: fn_maps.add_live_node(ExitNode),\n-        fallthrough_ln: fn_maps.add_live_node(ExitNode),\n-        no_ret_var: fn_maps.add_variable(ImplicitRet),\n-        clean_exit_var: fn_maps.add_variable(CleanExit)\n-    };\n-\n     // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, specials);\n+    let mut lsets = Liveness::new(&mut fn_maps, body_id);\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n     lsets.visit_body(body);\n-    lsets.check_ret(id, sp, fk, entry_ln, body);\n+    lsets.check_ret(id, sp, entry_ln, body);\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n@@ -539,6 +512,7 @@ const ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx: 'a> {\n     ir: &'a mut IrMaps<'a, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n     users: Vec<Users>,\n@@ -553,11 +527,26 @@ struct Liveness<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'a, 'tcx>, specials: Specials) -> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'a, 'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n+        // Special nodes and variables:\n+        // - exit_ln represents the end of the fn, either by return or panic\n+        // - implicit_ret_var is a pseudo-variable that represents\n+        //   an implicit return\n+        let specials = Specials {\n+            exit_ln: ir.add_live_node(ExitNode),\n+            fallthrough_ln: ir.add_live_node(ExitNode),\n+            no_ret_var: ir.add_variable(ImplicitRet),\n+            clean_exit_var: ir.add_variable(CleanExit)\n+        };\n+\n+        let tables = ir.tcx.body_tables(body);\n+\n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n+\n         Liveness {\n             ir: ir,\n+            tables: tables,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n             users: vec![invalid_users(); num_live_nodes * num_vars],\n@@ -1065,7 +1054,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // an overloaded assign op is like a method call\n-            if self.ir.tcx.tables().is_method_call(expr.id) {\n+            if self.tables.is_method_call(expr.id) {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n@@ -1092,8 +1081,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.ir.tcx.tables().is_method_call(expr.id) &&\n-                self.ir.tcx.tables().expr_ty_adjusted(&f).fn_ret().0.is_never();\n+            let diverges = !self.tables.is_method_call(expr.id) &&\n+                self.tables.expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1105,7 +1094,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprMethodCall(.., ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.tables().method_map[&method_call].ty;\n+            let method_ty = self.tables.method_map[&method_call].ty;\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let succ = if method_ty.fn_ret().0.is_never() {\n                 self.s.exit_ln\n@@ -1355,6 +1344,22 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n+impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+        check_local(self, l);\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+        check_expr(self, ex);\n+    }\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n+        check_arm(self, a);\n+    }\n+}\n+\n fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n     match local.init {\n         Some(_) => {\n@@ -1389,7 +1394,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        if !this.ir.tcx.tables().is_method_call(expr.id) {\n+        if !this.tables.is_method_call(expr.id) {\n             this.check_lvalue(&l);\n         }\n \n@@ -1432,15 +1437,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,\n-                 fk: FnKind,\n                  entry_ln: LiveNode,\n                  body: &hir::Body)\n     {\n-        let fn_ty = if let FnKind::Closure(_) = fk {\n-            self.ir.tcx.tables().node_id_to_type(id)\n-        } else {\n-            self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id))\n-        };\n+        let fn_ty = self.ir.tcx.item_type(self.ir.tcx.map.local_def_id(id));\n         let fn_ret = match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n@@ -1457,8 +1457,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n             let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n-            let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n-                                                Reveal::All).enter(|infcx| {\n+            let is_nil = self.ir.tcx.infer_ctxt(param_env, Reveal::All).enter(|infcx| {\n                 let cause = traits::ObligationCause::dummy();\n                 traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n             });"}, {"sha": "92e69d7d729578092ed1b927f5ffd1a31ae42db3", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n-        match self.infcx.adjustments().get(&expr.id) {\n+        match self.infcx.tables.borrow().adjustments.get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)"}, {"sha": "6eaf3448d0284c28dbd8b018015da37a490cffcc", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -79,6 +79,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -90,17 +91,25 @@ struct ReachableContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n             hir::ExprPath(ref qpath) => {\n-                Some(self.tcx.tables().qpath_def(qpath, expr.id))\n+                Some(self.tables.qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                let def_id = self.tables.method_map[&method_call].def_id;\n                 Some(Def::Method(def_id))\n             }\n             _ => None\n@@ -135,20 +144,6 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n-    // Creates a new reachability computation context.\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n-        let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-            *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n-            *ty == config::CrateTypeProcMacro\n-        });\n-        ReachableContext {\n-            tcx: tcx,\n-            reachable_symbols: NodeSet(),\n-            worklist: Vec::new(),\n-            any_library: any_library,\n-        }\n-    }\n-\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n@@ -369,7 +364,17 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 -> NodeSet {\n     let _task = tcx.dep_graph.in_task(DepNode::Reachability);\n \n-    let mut reachable_context = ReachableContext::new(tcx);\n+    let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n+        *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n+        *ty == config::CrateTypeProcMacro\n+    });\n+    let mut reachable_context = ReachableContext {\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        reachable_symbols: NodeSet(),\n+        worklist: Vec::new(),\n+        any_library: any_library,\n+    };\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass along with all local lang items and impl items."}, {"sha": "e6c9d2c36d013fa9d9677e260534b0148605d1be", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -18,7 +18,7 @@ use hir::map as hir_map;\n use lint;\n use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n-use ty::TyCtxt;\n+use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -432,6 +432,36 @@ struct Checker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    // (See issue #38412)\n+    fn skip_stability_check_due_to_privacy(self, def_id: DefId) -> bool {\n+        let visibility = {\n+            // Check if `def_id` is a trait method.\n+            match self.sess.cstore.associated_item(def_id) {\n+                Some(ty::AssociatedItem { container: ty::TraitContainer(trait_def_id), .. }) => {\n+                    // Trait methods do not declare visibility (even\n+                    // for visibility info in cstore). Use containing\n+                    // trait instead, so methods of pub traits are\n+                    // themselves considered pub.\n+                    self.sess.cstore.visibility(trait_def_id)\n+                }\n+                _ => {\n+                    // Otherwise, cstore info works directly.\n+                    self.sess.cstore.visibility(def_id)\n+                }\n+            }\n+        };\n+\n+        match visibility {\n+            // must check stability for pub items.\n+            ty::Visibility::Public => false,\n+\n+            // these are not visible outside crate; therefore\n+            // stability markers are irrelevant, if even present.\n+            ty::Visibility::Restricted(..) |\n+            ty::Visibility::Invisible => true,\n+        }\n+    }\n+\n     pub fn check_stability(self, def_id: DefId, id: NodeId, span: Span) {\n         if self.sess.codemap().span_allows_unstable(span) {\n             debug!(\"stability: \\\n@@ -492,6 +522,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.stability.borrow_mut().used_features.insert(feature.clone(), level.clone());\n         }\n \n+        // Issue 38412: private items lack stability markers.\n+        if self.skip_stability_check_due_to_privacy(def_id) {\n+            return\n+        }\n+\n         match stability {\n             Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n                 if !self.stability.borrow().active_features.contains(feature) {"}, {"sha": "5bae0e347f7c40cc7369070d2bbd773735f55325", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -29,7 +29,7 @@ use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n use std::vec::IntoIter;\n-use syntax::ast::{self, Name};\n+use syntax::ast::Name;\n use syntax_pos::Span;\n \n mod cache;\n@@ -888,6 +888,10 @@ impl<'tcx> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Deref)\n     }\n \n+    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: usize) -> Lvalue<'tcx> {\n+        self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n+    }\n+\n     pub fn index(self, index: Operand<'tcx>) -> Lvalue<'tcx> {\n         self.elem(ProjectionElem::Index(index))\n     }\n@@ -1267,17 +1271,12 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         }\n         Bool(b) => write!(fmt, \"{:?}\", b),\n         Function(def_id) => write!(fmt, \"{}\", item_path_str(def_id)),\n-        Struct(node_id) | Tuple(node_id) | Array(node_id, _) | Repeat(node_id, _) =>\n-            write!(fmt, \"{}\", node_to_string(node_id)),\n+        Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n+            bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n         Char(c) => write!(fmt, \"{:?}\", c),\n-        Dummy => bug!(),\n     }\n }\n \n-fn node_to_string(node_id: ast::NodeId) -> String {\n-    ty::tls::with(|tcx| tcx.map.node_to_user_string(node_id))\n-}\n-\n fn item_path_str(def_id: DefId) -> String {\n     ty::tls::with(|tcx| tcx.item_path_str(def_id))\n }"}, {"sha": "104c851e057e6fa524aa2d18d9b592cee8c5f88f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1175,14 +1175,15 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                              assumed.\", \"[KIND=]NAME\"),\n         opt::multi_s(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n-                   \"[bin|lib|rlib|dylib|cdylib|staticlib]\"),\n+                   \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\"),\n         opt::opt_s(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n         opt::multi_s(\"\", \"emit\", \"Comma separated list of types of output for \\\n                               the compiler to emit\",\n                  \"[asm|llvm-bc|llvm-ir|obj|metadata|link|dep-info]\"),\n         opt::multi_s(\"\", \"print\", \"Comma separated list of compiler information to \\\n-                               print on stdout\", &print_opts.join(\"|\")),\n+                               print on stdout\", &format!(\"[{}]\",\n+                               &print_opts.join(\"|\"))),\n         opt::flagmulti_s(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n         opt::opt_s(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),"}, {"sha": "4893e240911273cf6e7954486f8186a826fb104d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -474,7 +474,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    tcx.infer_ctxt(None, Some(elaborated_env), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(elaborated_env, Reveal::NotSpecializable).enter(|infcx| {\n         let predicates = match fully_normalize(&infcx, cause,\n                                                &infcx.parameter_environment.caller_bounds) {\n             Ok(predicates) => predicates,\n@@ -576,7 +576,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();\n         let cause = ObligationCause::dummy();"}, {"sha": "0fe054b30ba3174a1c1bfa3cbe6b6fbc0d1bc51f", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -123,7 +123,7 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n     match ancestors.defs(tcx, name, ty::AssociatedKind::Method).next() {\n         Some(node_item) => {\n-            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, impl_data.impl_def_id,\n                                               substs, node_item.node);\n@@ -189,7 +189,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .subst(tcx, &penv.free_substs);\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(None, Some(penv), Reveal::ExactMatch).enter(|infcx| {\n+    let result = tcx.infer_ctxt(penv, Reveal::ExactMatch).enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref ="}, {"sha": "368b1fb4bcbd38ca4d61e0356fa993a2a19b860c", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "ed5b470849c41f4ef948c095443cee2ba0e974f2", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -235,6 +235,11 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                             })\n                         });\n \n+                    if def.is_union() {\n+                        // unions don't have destructors regardless of the child types\n+                        res = res - TC::NeedsDrop;\n+                    }\n+\n                     if def.has_dtor() {\n                         res = res | TC::OwnsDtor;\n                     }"}, {"sha": "3df64ebd1581b66237b088c3d5d7d30f473e531f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -33,6 +33,7 @@ use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n+use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -64,6 +65,7 @@ pub struct GlobalArenas<'tcx> {\n     trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDef>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n+    tables: TypedArena<ty::Tables<'tcx>>,\n }\n \n impl<'tcx> GlobalArenas<'tcx> {\n@@ -74,6 +76,7 @@ impl<'tcx> GlobalArenas<'tcx> {\n             trait_def: TypedArena::new(),\n             adt_def: TypedArena::new(),\n             mir: TypedArena::new(),\n+            tables: TypedArena::new(),\n         }\n     }\n }\n@@ -188,6 +191,7 @@ pub struct CommonTypes<'tcx> {\n     pub err: Ty<'tcx>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Tables<'tcx> {\n     /// Resolved definitions for `<T>::X` associated paths.\n     pub type_relative_path_defs: NodeMap<Def>,\n@@ -210,13 +214,11 @@ pub struct Tables<'tcx> {\n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_tys: DefIdMap<ty::ClosureTy<'tcx>>,\n+    /// Records the type of each closure.\n+    pub closure_tys: NodeMap<ty::ClosureTy<'tcx>>,\n \n-    /// Records the type of each closure. The def ID is the ID of the\n-    /// expression defining the closure.\n-    pub closure_kinds: DefIdMap<ty::ClosureKind>,\n+    /// Records the type of each closure.\n+    pub closure_kinds: NodeMap<ty::ClosureKind>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n@@ -232,7 +234,7 @@ pub struct Tables<'tcx> {\n     pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n }\n \n-impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n+impl<'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n             type_relative_path_defs: NodeMap(),\n@@ -241,8 +243,8 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n             adjustments: NodeMap(),\n             method_map: FxHashMap(),\n             upvar_capture_map: FxHashMap(),\n-            closure_tys: DefIdMap(),\n-            closure_kinds: DefIdMap(),\n+            closure_tys: NodeMap(),\n+            closure_kinds: NodeMap(),\n             liberated_fn_sigs: NodeMap(),\n             fru_field_types: NodeMap()\n         }\n@@ -400,7 +402,7 @@ pub struct GlobalCtxt<'tcx> {\n     free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n     // FIXME: jroesch make this a refcell\n \n-    pub tables: RefCell<Tables<'tcx>>,\n+    pub tables: RefCell<DepTrackingMap<maps::Tables<'tcx>>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n     pub associated_items: RefCell<DepTrackingMap<maps::AssociatedItems<'tcx>>>,\n@@ -459,6 +461,8 @@ pub struct GlobalCtxt<'tcx> {\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n+    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n+\n     pub lang_items: middle::lang_items::LanguageItems,\n \n     /// Maps from def-id of a type or region parameter to its\n@@ -521,6 +525,14 @@ pub struct GlobalCtxt<'tcx> {\n     /// Caches CoerceUnsized kinds for impls on custom types.\n     pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::adjustment::CustomCoerceUnsized>>,\n \n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_tys: RefCell<DepTrackingMap<maps::ClosureTypes<'tcx>>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kinds: RefCell<DepTrackingMap<maps::ClosureKinds<'tcx>>>,\n+\n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n     pub cast_kinds: RefCell<NodeMap<ty::cast::CastKind>>,\n@@ -642,6 +654,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.mir.alloc(RefCell::new(mir))\n     }\n \n+    pub fn alloc_tables(self, tables: ty::Tables<'gcx>) -> &'gcx ty::Tables<'gcx> {\n+        self.global_arenas.tables.alloc(tables)\n+    }\n+\n     pub fn alloc_trait_def(self, def: ty::TraitDef) -> &'gcx ty::TraitDef {\n         self.global_arenas.trait_def.alloc(def)\n     }\n@@ -740,7 +756,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             variance_computed: Cell::new(false),\n             sess: s,\n             trait_map: resolutions.trait_map,\n-            tables: RefCell::new(Tables::empty()),\n+            tables: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -760,6 +776,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n+            inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n@@ -773,6 +790,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             repr_hint_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n+            closure_tys: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            closure_kinds: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),"}, {"sha": "16bc65603f1353188b082cf02114d4f45fef31ee", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+use rustc_data_structures::small_vec::SmallVec;\n+use syntax::ast::CRATE_NODE_ID;\n+use ty::context::TyCtxt;\n+use ty::{DefId, DefIdTree};\n+\n+/// Represents a forest of DefIds closed under the ancestor relation. That is,\n+/// if a DefId representing a module is contained in the forest then all\n+/// DefIds defined in that module or submodules are also implicitly contained\n+/// in the forest.\n+///\n+/// This is used to represent a set of modules in which a type is visibly\n+/// uninhabited.\n+#[derive(Clone)]\n+pub struct DefIdForest {\n+    /// The minimal set of DefIds required to represent the whole set.\n+    /// If A and B are DefIds in the DefIdForest, and A is a desecendant\n+    /// of B, then only B will be in root_ids.\n+    /// We use a SmallVec here because (for its use for cacheing inhabitedness)\n+    /// its rare that this will contain even two ids.\n+    root_ids: SmallVec<[DefId; 1]>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> DefIdForest {\n+    /// Create an empty forest.\n+    pub fn empty() -> DefIdForest {\n+        DefIdForest {\n+            root_ids: SmallVec::new(),\n+        }\n+    }\n+\n+    /// Create a forest consisting of a single tree representing the entire\n+    /// crate.\n+    #[inline]\n+    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n+        let crate_id = tcx.map.local_def_id(CRATE_NODE_ID);\n+        DefIdForest::from_id(crate_id)\n+    }\n+\n+    /// Create a forest containing a DefId and all its descendants.\n+    pub fn from_id(id: DefId) -> DefIdForest {\n+        let mut root_ids = SmallVec::new();\n+        root_ids.push(id);\n+        DefIdForest {\n+            root_ids: root_ids,\n+        }\n+    }\n+\n+    /// Test whether the forest is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.root_ids.is_empty()\n+    }\n+\n+    /// Test whether the forest conains a given DefId.\n+    pub fn contains(&self,\n+                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    id: DefId) -> bool\n+    {\n+        for root_id in self.root_ids.iter() {\n+            if tcx.is_descendant_of(id, *root_id) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Calculate the intersection of a collection of forests.\n+    pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                           iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n+    {\n+        let mut ret = DefIdForest::full(tcx);\n+        let mut next_ret = SmallVec::new();\n+        let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n+        for next_forest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if next_forest.contains(tcx, id) {\n+                    next_ret.push(id);\n+                } else {\n+                    old_ret.push(id);\n+                }\n+            }\n+            ret.root_ids.extend(old_ret.drain(..));\n+\n+            for id in next_forest.root_ids {\n+                if ret.contains(tcx, id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+\n+    /// Calculate the union of a collection of forests.\n+    pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n+    {\n+        let mut ret = DefIdForest::empty();\n+        let mut next_ret = SmallVec::new();\n+        for next_forest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if !next_forest.contains(tcx, id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            for id in next_forest.root_ids {\n+                if !next_ret.contains(&id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+}\n+"}, {"sha": "c5b75839e99b7dd634703119272b4da0f52783e7", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use util::nodemap::FxHashSet;\n+use ty::context::TyCtxt;\n+use ty::{AdtDef, VariantDef, FieldDef, TyS};\n+use ty::{DefId, Substs};\n+use ty::{AdtKind, Visibility};\n+use ty::TypeVariants::*;\n+\n+pub use self::def_id_forest::DefIdForest;\n+\n+mod def_id_forest;\n+\n+// The methods in this module calculate DefIdForests of modules in which a\n+// AdtDef/VariantDef/FieldDef is visibly uninhabited.\n+//\n+// # Example\n+// ```rust\n+// enum Void {}\n+// mod a {\n+//     pub mod b {\n+//         pub struct SecretlyUninhabited {\n+//             _priv: !,\n+//         }\n+//     }\n+// }\n+//\n+// mod c {\n+//     pub struct AlsoSecretlyUninhabited {\n+//         _priv: Void,\n+//     }\n+//     mod d {\n+//     }\n+// }\n+//\n+// struct Foo {\n+//     x: a::b::SecretlyUninhabited,\n+//     y: c::AlsoSecretlyUninhabited,\n+// }\n+// ```\n+// In this code, the type Foo will only be visibly uninhabited inside the\n+// modules b, c and d. Calling uninhabited_from on Foo or its AdtDef will\n+// return the forest of modules {b, c->d} (represented in a DefIdForest by the\n+// set {b, c})\n+//\n+// We need this information for pattern-matching on Foo or types that contain\n+// Foo.\n+//\n+// # Example\n+// ```rust\n+// let foo_result: Result<T, Foo> = ... ;\n+// let Ok(t) = foo_result;\n+// ```\n+// This code should only compile in modules where the uninhabitedness of Foo is\n+// visible.\n+\n+impl<'a, 'gcx, 'tcx> AdtDef {\n+    /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>) -> DefIdForest\n+    {\n+        if !visited.insert((self.did, substs)) {\n+            return DefIdForest::empty();\n+        }\n+\n+        let ret = DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n+            v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n+        }));\n+        visited.remove(&(self.did, substs));\n+        ret\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> VariantDef {\n+    /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>,\n+                adt_kind: AdtKind) -> DefIdForest\n+    {\n+        match adt_kind {\n+            AdtKind::Union => {\n+                DefIdForest::intersection(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, false)\n+                }))\n+            },\n+            AdtKind::Struct => {\n+                DefIdForest::union(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, false)\n+                }))\n+            },\n+            AdtKind::Enum => {\n+                DefIdForest::union(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, true)\n+                }))\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> FieldDef {\n+    /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>,\n+                is_enum: bool) -> DefIdForest\n+    {\n+        let mut data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(visited, tcx);\n+        // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n+        // Visibility::Invisible so we need to override self.vis if we're\n+        // dealing with an enum.\n+        if is_enum {\n+            data_uninhabitedness()\n+        } else {\n+            match self.vis {\n+                Visibility::Invisible => DefIdForest::empty(),\n+                Visibility::Restricted(from) => {\n+                    let forest = DefIdForest::from_id(from);\n+                    let iter = Some(forest).into_iter().chain(Some(data_uninhabitedness()));\n+                    DefIdForest::intersection(tcx, iter)\n+                },\n+                Visibility::Public => data_uninhabitedness(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n+    /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    {\n+        match tcx.lift_to_global(&self) {\n+            Some(global_ty) => {\n+                {\n+                    let cache = tcx.inhabitedness_cache.borrow();\n+                    if let Some(forest) = cache.get(&global_ty) {\n+                        return forest.clone();\n+                    }\n+                }\n+                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n+                let mut cache = tcx.inhabitedness_cache.borrow_mut();\n+                cache.insert(global_ty, forest.clone());\n+                forest\n+            },\n+            None => {\n+                let forest = self.uninhabited_from_inner(visited, tcx);\n+                forest\n+            },\n+        }\n+    }\n+\n+    fn uninhabited_from_inner(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    {\n+        match self.sty {\n+            TyAdt(def, substs) => {\n+                def.uninhabited_from(visited, tcx, substs)\n+            },\n+\n+            TyNever => DefIdForest::full(tcx),\n+            TyTuple(ref tys) => {\n+                DefIdForest::union(tcx, tys.iter().map(|ty| {\n+                    ty.uninhabited_from(visited, tcx)\n+                }))\n+            },\n+            TyArray(ty, len) => {\n+                if len == 0 {\n+                    DefIdForest::empty()\n+                } else {\n+                    ty.uninhabited_from(visited, tcx)\n+                }\n+            }\n+            TyRef(_, ref tm) => tm.ty.uninhabited_from(visited, tcx),\n+\n+            _ => DefIdForest::empty(),\n+        }\n+    }\n+}\n+"}, {"sha": "59d22d270b15d49f946af7ec5b272586d8078ea4", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -46,3 +46,6 @@ dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }\n dep_map_ty! { Mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>> }\n+dep_map_ty! { ClosureKinds: ItemSignature(DefId) -> ty::ClosureKind }\n+dep_map_ty! { ClosureTypes: ItemSignature(DefId) -> ty::ClosureTy<'tcx> }\n+dep_map_ty! { Tables: Tables(DefId) -> &'tcx ty::Tables<'tcx> }"}, {"sha": "a88b1e3ece9641b1ffdc80bf44ad9edb0b780246", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -29,7 +29,7 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeSet, NodeMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -78,6 +78,7 @@ pub mod cast;\n pub mod error;\n pub mod fast_reject;\n pub mod fold;\n+pub mod inhabitedness;\n pub mod item_path;\n pub mod layout;\n pub mod _match;\n@@ -226,6 +227,20 @@ pub enum Visibility {\n \n pub trait DefIdTree: Copy {\n     fn parent(self, id: DefId) -> Option<DefId>;\n+\n+    fn is_descendant_of(self, mut descendant: DefId, ancestor: DefId) -> bool {\n+        if descendant.krate != ancestor.krate {\n+            return false;\n+        }\n+\n+        while descendant != ancestor {\n+            match self.parent(descendant) {\n+                Some(parent) => descendant = parent,\n+                None => return false,\n+            }\n+        }\n+        true\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n@@ -252,7 +267,7 @@ impl Visibility {\n     }\n \n     /// Returns true if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from<T: DefIdTree>(self, mut module: DefId, tree: T) -> bool {\n+    pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n@@ -263,14 +278,7 @@ impl Visibility {\n             Visibility::Restricted(module) => module,\n         };\n \n-        while module != restriction {\n-            match tree.parent(module) {\n-                Some(parent) => module = parent,\n-                None => return false,\n-            }\n-        }\n-\n-        true\n+        tree.is_descendant_of(module, restriction)\n     }\n \n     /// Returns true if this visibility is at least as accessible as the given visibility\n@@ -313,7 +321,7 @@ pub struct MethodCallee<'tcx> {\n /// needed to add to the side tables. Thus to disambiguate\n /// we also keep track of whether there's an adjustment in\n /// our key.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct MethodCall {\n     pub expr_id: NodeId,\n     pub autoderef: u32\n@@ -493,7 +501,7 @@ impl<T> Slice<T> {\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n     pub var_id: NodeId,\n     pub closure_expr_id: NodeId,\n@@ -1406,20 +1414,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        if !visited.insert((self.did, substs)) {\n-            return false;\n-        };\n-        self.variants.iter().all(|v| {\n-            v.is_uninhabited_recurse(visited, block, tcx, substs, self.is_union())\n-        })\n-    }\n-\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         !self.is_union() && !self.is_enum()\n@@ -1754,36 +1748,12 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n         self.find_field_named(name).unwrap()\n     }\n-\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>,\n-                                  is_union: bool) -> bool {\n-        if is_union {\n-            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n-        } else {\n-            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         tcx.item_type(self.did).subst(tcx, subst)\n     }\n-\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        block.map_or(true, |b| tcx.vis_is_accessible_from(self.vis, b)) &&\n-        self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n-    }\n }\n \n /// Records the substitutions used to translate the polytype for an\n@@ -1947,8 +1917,30 @@ impl BorrowKind {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn tables(self) -> Ref<'a, Tables<'gcx>> {\n-        self.tables.borrow()\n+    pub fn body_tables(self, body: hir::BodyId) -> &'gcx Tables<'gcx> {\n+        self.item_tables(self.map.body_owner_def_id(body))\n+    }\n+\n+    pub fn item_tables(self, def_id: DefId) -> &'gcx Tables<'gcx> {\n+        self.tables.memoize(def_id, || {\n+            if def_id.is_local() {\n+                // Closures' tables come from their outermost function,\n+                // as they are part of the same \"inference environment\".\n+                let outer_def_id = self.closure_base_def_id(def_id);\n+                if outer_def_id != def_id {\n+                    return self.item_tables(outer_def_id);\n+                }\n+\n+                bug!(\"No def'n found for {:?} in tcx.tables\", def_id);\n+            }\n+\n+            // Cross-crate side-tables only exist alongside serialized HIR.\n+            self.sess.cstore.maybe_get_item_body(self.global_tcx(), def_id).map(|_| {\n+                self.tables.borrow()[&def_id]\n+            }).unwrap_or_else(|| {\n+                bug!(\"tcx.item_tables({:?}): missing from metadata\", def_id)\n+            })\n+        })\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2484,12 +2476,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // If this is a local def-id, it should be inserted into the\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n-        if let Some(&kind) = self.tables.borrow().closure_kinds.get(&def_id) {\n+        if let Some(&kind) = self.closure_kinds.borrow().get(&def_id) {\n             return kind;\n         }\n \n         let kind = self.sess.cstore.closure_kind(def_id);\n-        self.tables.borrow_mut().closure_kinds.insert(def_id, kind);\n+        self.closure_kinds.borrow_mut().insert(def_id, kind);\n         kind\n     }\n \n@@ -2501,12 +2493,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // If this is a local def-id, it should be inserted into the\n         // tables by typeck; else, it will be retreived from\n         // the external crate metadata.\n-        if let Some(ty) = self.tables.borrow().closure_tys.get(&def_id) {\n+        if let Some(ty) = self.closure_tys.borrow().get(&def_id) {\n             return ty.subst(self, substs.substs);\n         }\n \n         let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n-        self.tables.borrow_mut().closure_tys.insert(def_id, ty.clone());\n+        self.closure_tys.borrow_mut().insert(def_id, ty.clone());\n         ty.subst(self, substs.substs)\n     }\n "}, {"sha": "81b0a55841ad839e58547a58565e207dca8af488", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -22,7 +22,7 @@ use std::fmt;\n use std::iter;\n use std::cmp::Ordering;\n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId};\n+use syntax::ast::{self, Name};\n use syntax::symbol::{keywords, InternedString};\n use util::nodemap::FxHashSet;\n \n@@ -979,29 +979,52 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Checks whether a type is uninhabited.\n-    /// If `block` is `Some(id)` it also checks that the uninhabited-ness is visible from `id`.\n-    pub fn is_uninhabited(&self, block: Option<NodeId>, cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    /// Checks whether a type is visibly uninhabited from a particular module.\n+    /// # Example\n+    /// ```rust\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n+    pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = FxHashSet::default();\n-        self.is_uninhabited_recurse(&mut visited, block, cx)\n-    }\n-\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        match self.sty {\n-            TyAdt(def, substs) => {\n-                def.is_uninhabited_recurse(visited, block, cx, substs)\n-            },\n-\n-            TyNever => true,\n-            TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited_recurse(visited, block, cx)),\n-            TyArray(ty, len) => len > 0 && ty.is_uninhabited_recurse(visited, block, cx),\n-            TyRef(_, ref tm) => tm.ty.is_uninhabited_recurse(visited, block, cx),\n-\n-            _ => false,\n-        }\n+        let forest = self.uninhabited_from(&mut visited, tcx);\n+\n+        // To check whether this type is uninhabited at all (not just from the\n+        // given node) you could check whether the forest is empty.\n+        // ```\n+        // forest.is_empty()\n+        // ```\n+        forest.contains(tcx, module)\n     }\n \n     pub fn is_primitive(&self) -> bool {"}, {"sha": "65bec9ecdaf959ffa3b7bef709284ebffaa0bdb4", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@ use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as ast_map;\n use traits::{self, Reveal};\n-use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n@@ -120,9 +120,8 @@ impl IntTypeExt for attr::IntType {\n \n \n #[derive(Copy, Clone)]\n-pub enum CopyImplementationError {\n-    InfrigingField(Name),\n-    InfrigingVariant(Name),\n+pub enum CopyImplementationError<'tcx> {\n+    InfrigingField(&'tcx ty::FieldDef),\n     NotAnAdt,\n     HasDestructor\n }\n@@ -145,37 +144,30 @@ pub enum Representability {\n impl<'tcx> ParameterEnvironment<'tcx> {\n     pub fn can_type_implement_copy<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        self_type: Ty<'tcx>, span: Span)\n-                                       -> Result<(),CopyImplementationError> {\n+                                       -> Result<(), CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(None, Some(self.clone()), Reveal::ExactMatch).enter(|infcx| {\n-            let adt = match self_type.sty {\n-                ty::TyAdt(adt, substs) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        for field in adt.all_fields() {\n-                            let field_ty = field.ty(tcx, substs);\n-                            if infcx.type_moves_by_default(field_ty, span) {\n-                                return Err(CopyImplementationError::InfrigingField(\n-                                    field.name))\n-                            }\n-                        }\n-                        adt\n-                    }\n-                    AdtKind::Enum => {\n-                        for variant in &adt.variants {\n-                            for field in &variant.fields {\n-                                let field_ty = field.ty(tcx, substs);\n-                                if infcx.type_moves_by_default(field_ty, span) {\n-                                    return Err(CopyImplementationError::InfrigingVariant(\n-                                        variant.name))\n-                                }\n-                            }\n-                        }\n-                        adt\n-                    }\n-                },\n+        tcx.infer_ctxt(self.clone(), Reveal::NotSpecializable).enter(|infcx| {\n+            let (adt, substs) = match self_type.sty {\n+                ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt)\n             };\n \n+            let field_implements_copy = |field: &ty::FieldDef| {\n+                let cause = traits::ObligationCause::dummy();\n+                match traits::fully_normalize(&infcx, cause, &field.ty(tcx, substs)) {\n+                    Ok(ty) => !infcx.type_moves_by_default(ty, span),\n+                    Err(..) => false\n+                }\n+            };\n+\n+            for variant in &adt.variants {\n+                for field in &variant.fields {\n+                    if !field_implements_copy(field) {\n+                        return Err(CopyImplementationError::InfrigingField(field));\n+                    }\n+                }\n+            }\n+\n             if adt.has_dtor() {\n                 return Err(CopyImplementationError::HasDestructor);\n             }\n@@ -544,7 +536,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n         let result =\n-            tcx.infer_ctxt(None, Some(param_env.clone()), Reveal::ExactMatch)\n+            tcx.infer_ctxt(param_env.clone(), Reveal::ExactMatch)\n             .enter(|infcx| {\n                 traits::type_known_to_meet_bound(&infcx, self, def_id, span)\n             });"}, {"sha": "000e4eb59bf05c7f65981c10f58629c64030896d", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -28,7 +28,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(box_syntax)]\n #![feature(const_fn)]"}, {"sha": "c5e1e107753ffa80c56b543d5e04e29daa5c689b", "filename": "src/librustc_back/target/redox_base.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -25,22 +25,14 @@ pub fn opts() -> TargetOptions {\n             \"-Wl,--as-needed\".to_string(),\n \n             // Always enable NX protection when it is available\n-            \"-Wl,-z,noexecstack\".to_string(),\n-\n-            // Static link\n-            \"-static\".to_string()\n-        ],\n-        late_link_args: vec![\n-            \"-lc\".to_string(),\n-            \"-lm\".to_string()\n+            \"-Wl,-z,noexecstack\".to_string()\n         ],\n         executables: true,\n         relocation_model: \"static\".to_string(),\n         disable_redzone: true,\n         eliminate_frame_pointer: false,\n         target_family: None,\n         linker_is_gnu: true,\n-        no_default_libraries: true,\n         lib_allocation_crate: \"alloc_system\".to_string(),\n         exe_allocation_crate: \"alloc_system\".to_string(),\n         has_elf_tls: true,"}, {"sha": "671fb4f4319b35f5d1c592aee2ddf4145dac6524", "filename": "src/librustc_back/target/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -19,6 +19,8 @@ pub fn target() -> TargetResult {\n     // Pass the -vector feature string to LLVM to respect this assumption.\n     base.features = \"-vector\".to_string();\n     base.max_atomic_width = Some(64);\n+    // see #36994\n+    base.exe_allocation_crate = \"alloc_system\".to_string();\n \n     Ok(Target {\n         llvm_target: \"s390x-unknown-linux-gnu\".to_string(),"}, {"sha": "edd474b2e9edc441992e141c77a7254dc3404468", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@\n #![crate_type = \"rlib\"]\n #![no_std]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "0605644d497db4c2927ca47433571ef7e4dd05ee", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -188,12 +188,10 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n-                                     fn_id: ast::NodeId,\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n-    let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body.id());\n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n         dfcx_loans: dfcx_loans,"}, {"sha": "c33ced52e2bd6aee181faebf9e37f6acd99fa0a9", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n \n use std::rc::Rc;\n use syntax::ast;\n@@ -34,12 +34,10 @@ struct GatherMoveInfo<'tcx> {\n \n pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              move_data: &MoveData<'tcx>,\n-                             decl_id: ast::NodeId,\n-                             _decl_span: Span,\n-                             var_id: ast::NodeId) {\n-    let ty = bccx.tcx.tables().node_id_to_type(var_id);\n-    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), ty));\n-    move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n+                             var_id: ast::NodeId,\n+                             var_ty: Ty<'tcx>) {\n+    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n+    move_data.add_move(bccx.tcx, loan_path, var_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,"}, {"sha": "7101d843b4ce3798558469d1f5883bcceeecda5f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -18,14 +18,14 @@\n \n use borrowck::*;\n use borrowck::move_data::MoveData;\n+use rustc::infer::InferCtxt;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n \n use syntax::ast;\n-use syntax::ast::NodeId;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Expr;\n@@ -40,20 +40,20 @@ mod gather_moves;\n mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    fn_id: NodeId,\n-                                    body: &hir::Body)\n+                                    body: hir::BodyId)\n                                     -> (Vec<Loan<'tcx>>,\n                                         move_data::MoveData<'tcx>) {\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body);\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n+        infcx: &infcx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.region_maps.node_extent(body.value.id),\n+        item_ub: bccx.tcx.region_maps.node_extent(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n-    let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+    let body = glcx.bccx.tcx.map.body(body);\n     euv::ExprUseVisitor::new(&mut glcx, &infcx).consume_body(body);\n \n     glcx.report_potential_errors();\n@@ -63,6 +63,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n     move_data: move_data::MoveData<'tcx>,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan<'tcx>>,\n@@ -158,8 +159,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                                         mode);\n     }\n \n-    fn decl_without_init(&mut self, id: ast::NodeId, span: Span) {\n-        gather_moves::gather_decl(self.bccx, &self.move_data, id, span, id);\n+    fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n+        let ty = self.infcx.tables.borrow().node_id_to_type(id);\n+        gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n \n@@ -516,19 +518,17 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n /// sure the loans being taken are sound.\n struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    item_id: ast::NodeId\n+    body_id: hir::BodyId,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let param_env = ty::ParameterEnvironment::for_item(self.bccx.tcx,\n-                                                               self.item_id);\n-            let infcx = self.bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+            let infcx = self.bccx.tcx.borrowck_fake_infer_ctxt(self.body_id);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n@@ -545,16 +545,14 @@ impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer<'a, 'tcx>(bccx: &mut BorrowckCtxt<'a, 'tcx>,\n-                                                    item_id: ast::NodeId,\n-                                                    body: hir::BodyId) {\n-\n+pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, body: hir::BodyId) {\n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", body);\n \n     let mut sicx = StaticInitializerCtxt {\n         bccx: bccx,\n-        item_id: item_id\n+        body_id: body\n     };\n \n-    sicx.visit_nested_body(body);\n+    let body = sicx.bccx.tcx.map.body(body);\n+    sicx.visit_body(body);\n }"}, {"sha": "c0e038d183dad59e2d91e30401ab9cbe161a61b5", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -24,7 +24,7 @@ use self::InteriorKind::*;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n-use rustc::hir::map::blocks::{FnParts, FnLikeNode};\n+use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n@@ -89,14 +89,14 @@ impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Const(_, Some(expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ti.id, expr);\n+            gather_loans::gather_loans_in_static_initializer(self, expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, ii.id, expr);\n+            gather_loans::gather_loans_in_static_initializer(self, expr);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -143,7 +143,7 @@ fn borrowck_item<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>, item: &'tcx hir::I\n     match item.node {\n         hir::ItemStatic(.., ex) |\n         hir::ItemConst(_, ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, item.id, ex);\n+            gather_loans::gather_loans_in_static_initializer(this, ex);\n         }\n         _ => { }\n     }\n@@ -179,7 +179,7 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n                        move_data: flowed_moves } =\n-        build_borrowck_dataflow_data(this, &cfg, body, id);\n+        build_borrowck_dataflow_data(this, &cfg, body_id);\n \n     move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n                                                     this.tcx,\n@@ -189,31 +189,26 @@ fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                                  &flowed_moves.move_data,\n                                                  id);\n \n-    check_loans::check_loans(this,\n-                             &loan_dfcx,\n-                             &flowed_moves,\n-                             &all_loans[..],\n-                             id,\n-                             body);\n+    check_loans::check_loans(this, &loan_dfcx, &flowed_moves, &all_loans[..], body);\n \n     intravisit::walk_fn(this, fk, decl, body_id, sp, id);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           cfg: &cfg::CFG,\n-                                          body: &'tcx hir::Body,\n-                                          id: ast::NodeId)\n+                                          body_id: hir::BodyId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n+    let body = tcx.map.body(body_id);\n     let id_range = {\n         let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.map);\n         visitor.visit_body(body);\n         visitor.result()\n     };\n     let (all_loans, move_data) =\n-        gather_loans::gather_loans_in_fn(this, id, body);\n+        gather_loans::gather_loans_in_fn(this, body_id);\n \n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n@@ -246,7 +241,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    fn_parts: FnParts<'tcx>,\n+    body: hir::BodyId,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n@@ -262,13 +257,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n         }\n     };\n \n-    let body = tcx.map.body(fn_parts.body);\n-\n-    let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n-                                                     cfg,\n-                                                     body,\n-                                                     fn_parts.id);\n-\n+    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body);\n     (bccx, dataflow_data)\n }\n "}, {"sha": "d3b22884a3d8c037e6b67c4adfc3636d121e27fc", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![allow(non_camel_case_types)]\n "}, {"sha": "f4b3646fce02c02840c0bc1061961273b0c67653", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 206, "deletions": 103, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -17,14 +17,14 @@ use eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n@@ -144,37 +144,38 @@ impl<'a, 'tcx> FromIterator<Vec<&'a Pattern<'tcx>>> for Matrix<'a, 'tcx> {\n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    /// A wild pattern with an error type - it exists to avoid having to normalize\n-    /// associated types to get field types.\n-    pub wild_pattern: &'a Pattern<'tcx>,\n+    /// The module in which the match occurs. This is necessary for\n+    /// checking inhabited-ness of types because whether a type is (visibly)\n+    /// inhabited can depend on whether it was defined in the current module or\n+    /// not. eg. `struct Foo { _private: ! }` cannot be seen to be empty\n+    /// outside it's module and should not be matchable with an empty match\n+    /// statement.\n+    pub module: DefId,\n     pub pattern_arena: &'a TypedArena<Pattern<'tcx>>,\n     pub byte_array_map: FxHashMap<*const Pattern<'tcx>, Vec<&'a Pattern<'tcx>>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        module: DefId,\n         f: F) -> R\n         where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n     {\n-        let wild_pattern = Pattern {\n-            ty: tcx.types.err,\n-            span: DUMMY_SP,\n-            kind: box PatternKind::Wild\n-        };\n-\n         let pattern_arena = TypedArena::new();\n \n         f(MatchCheckCtxt {\n             tcx: tcx,\n-            wild_pattern: &wild_pattern,\n+            module: module,\n             pattern_arena: &pattern_arena,\n             byte_array_map: FxHashMap(),\n         })\n     }\n \n     // convert a byte-string pattern to a list of u8 patterns.\n-    fn lower_byte_str_pattern(&mut self, pat: &'a Pattern<'tcx>) -> Vec<&'a Pattern<'tcx>> {\n+    fn lower_byte_str_pattern<'p>(&mut self, pat: &'p Pattern<'tcx>) -> Vec<&'p Pattern<'tcx>>\n+            where 'a: 'p\n+    {\n         let pattern_arena = &*self.pattern_arena;\n         let tcx = self.tcx;\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n@@ -269,8 +270,14 @@ impl<'tcx> Witness<'tcx> {\n         ty: Ty<'tcx>)\n         -> Self\n     {\n-        let arity = constructor_arity(cx, ctor, ty);\n-        self.0.extend(repeat(cx.wild_pattern).take(arity).cloned());\n+        let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n+        self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n+            Pattern {\n+                ty: ty,\n+                span: DUMMY_SP,\n+                kind: box PatternKind::Wild,\n+            }\n+        }));\n         self.apply_constructor(cx, ctor, ty)\n     }\n \n@@ -310,10 +317,11 @@ impl<'tcx> Witness<'tcx> {\n                         }\n                     }).collect();\n \n-                    if let ty::TyAdt(adt, _) = ty.sty {\n+                    if let ty::TyAdt(adt, substs) = ty.sty {\n                         if adt.variants.len() > 1 {\n                             PatternKind::Variant {\n                                 adt_def: adt,\n+                                substs: substs,\n                                 variant_index: ctor.variant_index_for_adt(adt),\n                                 subpatterns: pats\n                             }\n@@ -356,51 +364,65 @@ impl<'tcx> Witness<'tcx> {\n     }\n }\n \n-/// Return the set of constructors from the same type as the first column of `matrix`,\n-/// that are matched only by wildcard patterns from that first column.\n-///\n-/// Therefore, if there is some pattern that is unmatched by `matrix`, it will\n-/// still be unmatched if the first constructor is replaced by any of the constructors\n-/// in the return value.\n-fn missing_constructors(cx: &mut MatchCheckCtxt,\n-                        matrix: &Matrix,\n-                        pcx: PatternContext) -> Vec<Constructor> {\n-    let used_constructors: Vec<Constructor> =\n-        matrix.0.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n-        .collect();\n-    debug!(\"used_constructors = {:?}\", used_constructors);\n-    all_constructors(cx, pcx).into_iter()\n-        .filter(|c| !used_constructors.contains(c))\n-        .collect()\n-}\n-\n /// This determines the set of all possible constructors of a pattern matching\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n+/// but is instead bounded by the maximum fixed length of slice patterns in\n+/// the column of patterns being analyzed.\n ///\n /// This intentionally does not list ConstantValue specializations for\n /// non-booleans, because we currently assume that there is always a\n /// \"non-standard constant\" that matches. See issue #12483.\n ///\n-/// but is instead bounded by the maximum fixed length of slice patterns in\n-/// the column of patterns being analyzed.\n-fn all_constructors(_cx: &mut MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructor> {\n+/// We make sure to omit constructors that are statically impossible. eg for\n+/// Option<!> we do not include Some(_) in the returned list of constructors.\n+fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                                  pcx: PatternContext<'tcx>) -> Vec<Constructor>\n+{\n+    debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n-        ty::TySlice(_) =>\n-            (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect(),\n-        ty::TyArray(_, length) => vec![Slice(length)],\n-        ty::TyAdt(def, _) if def.is_enum() && def.variants.len() > 1 =>\n-            def.variants.iter().map(|v| Variant(v.did)).collect(),\n-        _ => vec![Single]\n+        ty::TySlice(ref sub_ty) => {\n+            if sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+                vec![Slice(0)]\n+            } else {\n+                (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n+            }\n+        }\n+        ty::TyArray(ref sub_ty, length) => {\n+            if length == 0 || !sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+                vec![Slice(length)]\n+            } else {\n+                vec![]\n+            }\n+        }\n+        ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n+            def.variants.iter().filter_map(|v| {\n+                let mut visited = FxHashSet::default();\n+                let forest = v.uninhabited_from(&mut visited,\n+                                                cx.tcx, substs,\n+                                                AdtKind::Enum);\n+                if forest.contains(cx.tcx, cx.module) {\n+                    None\n+                } else {\n+                    Some(Variant(v.did))\n+                }\n+            }).collect()\n+        }\n+        _ => {\n+            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx) {\n+                vec![]\n+            } else {\n+                vec![Single]\n+            }\n+        }\n     }\n }\n \n-fn max_slice_length<'a, 'tcx, I>(\n+fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     patterns: I) -> usize\n-    where I: Iterator<Item=&'a Pattern<'tcx>>\n+    where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n     // The exhaustiveness-checking paper does not include any details on\n     // checking variable-length slice patterns. However, they are matched\n@@ -491,6 +513,12 @@ fn max_slice_length<'a, 'tcx, I>(\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+/// The algorithm from the paper has been modified to correctly handle empty\n+/// types. The changes are:\n+///   (0) We don't exit early if the pattern matrix has zero rows. We just\n+///       continue to recurse over columns.\n+///   (1) all_constructors will only return constructors that are statically\n+///       possible. eg. it will only return Ok for Result<T, !>\n ///\n /// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n /// vectors `m` is defined as there being a set of inputs that will match `v`\n@@ -500,29 +528,30 @@ fn max_slice_length<'a, 'tcx, I>(\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-///\n-/// Note: is_useful doesn't work on empty types, as the paper notes.\n-/// So it assumes that v is non-empty.\n-pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                           matrix: &Matrix<'a, 'tcx>,\n-                           v: &[&'a Pattern<'tcx>],\n+pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                           matrix: &Matrix<'p, 'tcx>,\n+                           v: &[&'p Pattern<'tcx>],\n                            witness: WitnessPreference)\n                            -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:?}, {:?})\", matrix, v);\n-    if rows.is_empty() {\n-        return match witness {\n-            ConstructWitness => UsefulWithWitness(vec![Witness(\n-                repeat(cx.wild_pattern).take(v.len()).cloned().collect()\n-            )]),\n-            LeaveOutWitness => Useful\n-        };\n-    }\n-    if rows[0].is_empty() {\n-        return NotUseful;\n-    }\n \n-    let &Matrix(ref rows) = matrix;\n+    // The base case. We are pattern-matching on () and the return value is\n+    // based on whether our matrix has a row or not.\n+    // NOTE: This could potentially be optimized by checking rows.is_empty()\n+    // first and then, if v is non-empty, the return value is based on whether\n+    // the type of the tuple we're checking is inhabited or not.\n+    if v.is_empty() {\n+        return if rows.is_empty() {\n+            match witness {\n+                ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n+                LeaveOutWitness => Useful,\n+            }\n+        } else {\n+            NotUseful\n+        }\n+    };\n+\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n \n@@ -541,10 +570,28 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n-        let constructors = missing_constructors(cx, matrix, pcx);\n-        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n-        if constructors.is_empty() {\n-            all_constructors(cx, pcx).into_iter().map(|c| {\n+\n+        let used_ctors: Vec<Constructor> = rows.iter().flat_map(|row| {\n+            pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n+        }).collect();\n+        debug!(\"used_ctors = {:?}\", used_ctors);\n+        let all_ctors = all_constructors(cx, pcx);\n+        debug!(\"all_ctors = {:?}\", all_ctors);\n+        let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n+            !used_ctors.contains(*c)\n+        }).cloned().collect();\n+        debug!(\"missing_ctors = {:?}\", missing_ctors);\n+\n+        // `missing_ctors` is the set of constructors from the same type as the\n+        // first column of `matrix` that are matched only by wildcard patterns\n+        // from the first column.\n+        //\n+        // Therefore, if there is some pattern that is unmatched by `matrix`,\n+        // it will still be unmatched if the first constructor is replaced by\n+        // any of the constructors in `missing_ctors`\n+\n+        if missing_ctors.is_empty() {\n+            all_ctors.into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n@@ -558,31 +605,53 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n-                    UsefulWithWitness(pats.into_iter().flat_map(|witness| {\n-                        constructors.iter().map(move |ctor| {\n-                            witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n-                        })\n-                    }).collect())\n+                    let new_witnesses = if used_ctors.is_empty() {\n+                        // All constructors are unused. Add wild patterns\n+                        // rather than each individual constructor\n+                        pats.into_iter().map(|mut witness| {\n+                            witness.0.push(Pattern {\n+                                ty: pcx.ty,\n+                                span: DUMMY_SP,\n+                                kind: box PatternKind::Wild,\n+                            });\n+                            witness\n+                        }).collect()\n+                    } else {\n+                        pats.into_iter().flat_map(|witness| {\n+                            missing_ctors.iter().map(move |ctor| {\n+                                witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                            })\n+                        }).collect()\n+                    };\n+                    UsefulWithWitness(new_witnesses)\n                 }\n                 result => result\n             }\n         }\n     }\n }\n \n-fn is_useful_specialized<'a, 'tcx>(\n+fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    &Matrix(ref m): &Matrix<'a, 'tcx>,\n-    v: &[&'a Pattern<'tcx>],\n+    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    v: &[&'p Pattern<'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n-    let arity = constructor_arity(cx, &ctor, lty);\n+    let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n+    let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n+        Pattern {\n+            ty: ty,\n+            span: DUMMY_SP,\n+            kind: box PatternKind::Wild,\n+        }\n+    }).collect();\n+    let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n     let matrix = Matrix(m.iter().flat_map(|r| {\n-        specialize(cx, &r[..], &ctor, 0, arity)\n+        specialize(cx, &r[..], &ctor, &wild_patterns)\n     }).collect());\n-    match specialize(cx, v, &ctor, 0, arity) {\n+    match specialize(cx, v, &ctor, &wild_patterns) {\n         Some(v) => match is_useful(cx, &matrix, &v[..], witness) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses.into_iter()\n@@ -657,6 +726,33 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize\n     }\n }\n \n+/// This computes the types of the sub patterns that a constructor should be\n+/// expanded to.\n+///\n+/// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n+fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                                             ctor: &Constructor,\n+                                             ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n+{\n+    debug!(\"constructor_sub_pattern_tys({:?}, {:?})\", ctor, ty);\n+    match ty.sty {\n+        ty::TyTuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n+        ty::TyBox(ty) => vec![ty],\n+        ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n+            Slice(length) => repeat(ty).take(length).collect(),\n+            ConstantValue(_) => vec![],\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n+        },\n+        ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n+        ty::TyAdt(adt, substs) => {\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n+                field.ty(cx.tcx, substs)\n+            }).collect()\n+        }\n+        _ => vec![],\n+    }\n+}\n+\n fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                                     ctor: &Constructor,\n                                     prefix: &[Pattern],\n@@ -708,19 +804,18 @@ fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n     Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n }\n \n-fn patterns_for_variant<'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    subpatterns: &'a [FieldPattern<'tcx>],\n-    arity: usize)\n-    -> Vec<&'a Pattern<'tcx>>\n+fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n+    subpatterns: &'p [FieldPattern<'tcx>],\n+    wild_patterns: &[&'p Pattern<'tcx>])\n+    -> Vec<&'p Pattern<'tcx>>\n {\n-    let mut result = vec![cx.wild_pattern; arity];\n+    let mut result = wild_patterns.to_owned();\n \n     for subpat in subpatterns {\n         result[subpat.field.index()] = &subpat.pattern;\n     }\n \n-    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, arity, result);\n+    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, wild_patterns, result);\n     result\n }\n \n@@ -732,35 +827,41 @@ fn patterns_for_variant<'a, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize<'a, 'tcx>(\n+fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    r: &[&'a Pattern<'tcx>],\n-    constructor: &Constructor, col: usize, arity: usize)\n-    -> Option<Vec<&'a Pattern<'tcx>>>\n+    r: &[&'p Pattern<'tcx>],\n+    constructor: &Constructor,\n+    wild_patterns: &[&'p Pattern<'tcx>])\n+    -> Option<Vec<&'p Pattern<'tcx>>>\n {\n-    let pat = &r[col];\n+    let pat = &r[0];\n \n     let head: Option<Vec<&Pattern>> = match *pat.kind {\n-        PatternKind::Binding { .. } | PatternKind::Wild =>\n-            Some(vec![cx.wild_pattern; arity]),\n+        PatternKind::Binding { .. } | PatternKind::Wild => {\n+            Some(wild_patterns.to_owned())\n+        },\n \n-        PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n+        PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n             if *constructor == Variant(variant.did) {\n-                Some(patterns_for_variant(cx, subpatterns, arity))\n+                Some(patterns_for_variant(subpatterns, wild_patterns))\n             } else {\n                 None\n             }\n         }\n \n-        PatternKind::Leaf { ref subpatterns } => Some(patterns_for_variant(cx, subpatterns, arity)),\n-        PatternKind::Deref { ref subpattern } => Some(vec![subpattern]),\n+        PatternKind::Leaf { ref subpatterns } => {\n+            Some(patterns_for_variant(subpatterns, wild_patterns))\n+        }\n+        PatternKind::Deref { ref subpattern } => {\n+            Some(vec![subpattern])\n+        }\n \n         PatternKind::Constant { ref value } => {\n             match *constructor {\n                 Slice(..) => match *value {\n                     ConstVal::ByteStr(ref data) => {\n-                        if arity == data.len() {\n+                        if wild_patterns.len() == data.len() {\n                             Some(cx.lower_byte_str_pattern(pat))\n                         } else {\n                             None\n@@ -796,11 +897,14 @@ fn specialize<'a, 'tcx>(\n             match *constructor {\n                 Slice(..) => {\n                     let pat_len = prefix.len() + suffix.len();\n-                    if let Some(slice_count) = arity.checked_sub(pat_len) {\n+                    if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n                         if slice_count == 0 || slice.is_some() {\n                             Some(\n                                 prefix.iter().chain(\n-                                repeat(cx.wild_pattern).take(slice_count).chain(\n+                                wild_patterns.iter().map(|p| *p)\n+                                                    .skip(prefix.len())\n+                                                    .take(slice_count)\n+                                                    .chain(\n                                 suffix.iter()\n                             )).collect())\n                         } else {\n@@ -824,11 +928,10 @@ fn specialize<'a, 'tcx>(\n             }\n         }\n     };\n-    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n+    debug!(\"specialize({:?}, {:?}) = {:?}\", r[0], wild_patterns, head);\n \n     head.map(|mut head| {\n-        head.extend_from_slice(&r[..col]);\n-        head.extend_from_slice(&r[col + 1..]);\n+        head.extend_from_slice(&r[1 ..]);\n         head\n     })\n }"}, {"sha": "400af3c7023460fa4d5652a8b77b1218080f690b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -24,8 +24,9 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::session::Session;\n use rustc::traits::Reveal;\n-use rustc::ty::{self, TyCtxt};\n-use rustc_errors::DiagnosticBuilder;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::lint;\n+use rustc_errors::{Diagnostic, Level, DiagnosticBuilder};\n \n use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n@@ -35,7 +36,7 @@ use rustc_back::slice;\n \n use syntax::ast;\n use syntax::ptr::P;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n@@ -50,6 +51,7 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n \n         MatchVisitor {\n             tcx: self.tcx,\n+            tables: self.tcx.body_tables(b),\n             param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n         }.visit_body(self.tcx.map.body(b));\n     }\n@@ -67,6 +69,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n \n struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n     param_env: &'a ty::ParameterEnvironment<'tcx>\n }\n \n@@ -80,7 +83,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n \n         match ex.node {\n             hir::ExprMatch(ref scrut, ref arms, source) => {\n-                self.check_match(scrut, arms, source, ex.span);\n+                self.check_match(scrut, arms, source);\n             }\n             _ => {}\n         }\n@@ -131,8 +134,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n         &self,\n         scrut: &hir::Expr,\n         arms: &[hir::Arm],\n-        source: hir::MatchSource,\n-        span: Span)\n+        source: hir::MatchSource)\n     {\n         for arm in arms {\n             // First, check legality of move bindings.\n@@ -150,12 +152,13 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n+        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(scrut.id));\n+        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n                 arm.pats.iter().map(|pat| {\n-                    let mut patcx = PatternContext::new(self.tcx);\n+                    let mut patcx = PatternContext::new(self.tcx, self.tables);\n                     let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n                     if !patcx.errors.is_empty() {\n                         self.report_inlining_errors(patcx, pat.span);\n@@ -174,32 +177,14 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Fourth, check for unreachable arms.\n             check_arms(cx, &inlined_arms, source);\n \n-            // Finally, check if the whole match expression is exhaustive.\n-            // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n-            if inlined_arms.is_empty() {\n-                if !pat_ty.is_uninhabited(Some(scrut.id), self.tcx) {\n-                    // We know the type is inhabited, so this must be wrong\n-                    let mut err = create_e0004(self.tcx.sess, span,\n-                                               format!(\"non-exhaustive patterns: type {} \\\n-                                                        is non-empty\",\n-                                                       pat_ty));\n-                    span_help!(&mut err, span,\n-                               \"Please ensure that all possible cases are being handled; \\\n-                                possibly adding wildcards or more match arms.\");\n-                    err.emit();\n-                }\n-                // If the type *is* uninhabited, it's vacuously exhaustive\n-                return;\n-            }\n-\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![pat.0])\n                 .collect();\n-            check_exhaustive(cx, scrut.span, &matrix, source);\n+            let scrut_ty = self.tables.node_id_to_type(scrut.id);\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, source);\n         })\n     }\n \n@@ -210,13 +195,21 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             \"local binding\"\n         };\n \n-        MatchCheckCtxt::create_and_enter(self.tcx, |ref mut cx| {\n-            let mut patcx = PatternContext::new(self.tcx);\n+        let module = self.tcx.map.local_def_id(self.tcx.map.get_module_parent(pat.id));\n+        MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n+            let mut patcx = PatternContext::new(self.tcx, self.tables);\n+            let pattern = patcx.lower_pattern(pat);\n+            let pattern_ty = pattern.ty;\n             let pats : Matrix = vec![vec![\n-                expand_pattern(cx, patcx.lower_pattern(pat))\n+                expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let witness = match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n+            let wild_pattern = Pattern {\n+                ty: pattern_ty,\n+                span: DUMMY_SP,\n+                kind: box PatternKind::Wild,\n+            };\n+            let witness = match is_useful(cx, &pats, &[&wild_pattern], ConstructWitness) {\n                 UsefulWithWitness(witness) => witness,\n                 NotUseful => return,\n                 Useful => bug!()\n@@ -237,7 +230,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), _, name, None) = p.node {\n-            let pat_ty = cx.tcx.tables().pat_ty(p);\n+            let pat_ty = cx.tables.pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() && edef.variants.iter().any(|variant| {\n                     variant.name == name.node && variant.ctor_kind == CtorKind::Const\n@@ -324,14 +317,16 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         },\n \n                         hir::MatchSource::Normal => {\n-                            let mut err = struct_span_err!(cx.tcx.sess, pat.span, E0001,\n-                                                           \"unreachable pattern\");\n-                            err.span_label(pat.span, &\"this is an unreachable pattern\");\n+                            let mut diagnostic = Diagnostic::new(Level::Warning,\n+                                                                 \"unreachable pattern\");\n+                            diagnostic.set_span(pat.span);\n                             // if we had a catchall pattern, hint at that\n                             if let Some(catchall) = catchall {\n-                                err.span_note(catchall, \"this pattern matches any value\");\n+                                diagnostic.span_label(pat.span, &\"this is an unreachable pattern\");\n+                                diagnostic.span_note(catchall, \"this pattern matches any value\");\n                             }\n-                            err.emit();\n+                            cx.tcx.sess.add_lint_diagnostic(lint::builtin::UNREACHABLE_PATTERNS,\n+                                                            hir_pat.id, diagnostic);\n                         },\n \n                         hir::MatchSource::TryDesugar => {\n@@ -353,13 +348,19 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n }\n \n fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                              scrut_ty: Ty<'tcx>,\n                               sp: Span,\n                               matrix: &Matrix<'a, 'tcx>,\n                               source: hir::MatchSource) {\n-    match is_useful(cx, matrix, &[cx.wild_pattern], ConstructWitness) {\n+    let wild_pattern = Pattern {\n+        ty: scrut_ty,\n+        span: DUMMY_SP,\n+        kind: box PatternKind::Wild,\n+    };\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n-                vec![cx.wild_pattern]\n+                vec![&wild_pattern]\n             } else {\n                 pats.iter().map(|w| w.single_pattern()).collect()\n             };\n@@ -456,7 +457,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, _, ref sub) = p.node {\n-                let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n+                let pat_ty = cx.tables.node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));\n                 }\n@@ -471,13 +472,11 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                      Reveal::NotSpecializable).enter(|infcx| {\n+    cx.tcx.infer_ctxt((cx.tables, cx.param_env.clone()), Reveal::NotSpecializable).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n-        let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n-        visitor.walk_expr(guard);\n+        ExprUseVisitor::new(&mut checker, &infcx).walk_expr(guard);\n     });\n }\n "}, {"sha": "8c8b2b5da36dc65d7e13a787e7bf349c09f44000", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,6 +16,8 @@\n register_long_diagnostics! {\n \n E0001: r##\"\n+## Note: this error code is no longer emitted by the compiler.\n+\n This error suggests that the expression arm corresponding to the noted pattern\n will never be reached as for all possible values of the expression being\n matched, one of the preceding patterns will match.\n@@ -25,10 +27,10 @@ one is too specific or the ordering is incorrect.\n \n For example, the following `match` block has too many arms:\n \n-```compile_fail,E0001\n+```\n match Some(0) {\n     Some(bar) => {/* ... */}\n-    None => {/* ... */}\n+    x => {/* ... */} // This handles the `None` case\n     _ => {/* ... */} // All possible cases have already been handled\n }\n ```"}, {"sha": "c899d2109f51cf54140098dc3456795b1a3e9d2f", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 209, "deletions": 194, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -52,34 +52,24 @@ macro_rules! math {\n \n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n-                                  -> Option<&'tcx Expr> {\n-    let variant_expr = |variants: &'tcx [hir::Variant], id: ast::NodeId |\n-                        -> Option<&'tcx Expr> {\n-        for variant in variants {\n-            if variant.node.data.id() == id {\n-                return variant.node.disr_expr.map(|e| {\n-                    &tcx.map.body(e).value\n-                });\n-            }\n-        }\n-        None\n-    };\n-\n+                                  -> Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>)> {\n     if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.map.get_parent(variant_node_id);\n-        match tcx.map.find(enum_node_id) {\n-            None => None,\n-            Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants, variant_node_id)\n+        if let Some(ast_map::NodeItem(it)) = tcx.map.find(enum_node_id) {\n+            if let hir::ItemEnum(ref edef, _) = it.node {\n+                for variant in &edef.variants {\n+                    if variant.node.data.id() == variant_node_id {\n+                        return variant.node.disr_expr.map(|e| {\n+                            let def_id = tcx.map.body_owner_def_id(e);\n+                            (&tcx.map.body(e).value,\n+                             tcx.tables.borrow().get(&def_id).cloned())\n+                        });\n+                    }\n                 }\n-                _ => None\n-            },\n-            Some(_) => None\n+            }\n         }\n-    } else {\n-        None\n     }\n+    None\n }\n \n /// * `def_id` is the id of the constant.\n@@ -90,17 +80,22 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         substs: Option<&'tcx Substs<'tcx>>)\n-                                        -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n+                                        -> Option<(&'tcx Expr,\n+                                                   Option<&'a ty::Tables<'tcx>>,\n+                                                   Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n             None => None,\n-            Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemConst(ref ty, body) => {\n-                    Some((&tcx.map.body(body).value,\n-                          tcx.ast_ty_to_prim_ty(ty)))\n-                }\n-                _ => None\n-            },\n+            Some(ast_map::NodeItem(&hir::Item {\n+                node: hir::ItemConst(ref ty, body), ..\n+            })) |\n+            Some(ast_map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Const(ref ty, body), ..\n+            })) => {\n+                Some((&tcx.map.body(body).value,\n+                      tcx.tables.borrow().get(&def_id).cloned(),\n+                      tcx.ast_ty_to_prim_ty(ty)))\n+            }\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                 hir::TraitItemKind::Const(ref ty, default) => {\n                     if let Some(substs) = substs {\n@@ -111,6 +106,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let trait_id = tcx.map.local_def_id(trait_id);\n                         let default_value = default.map(|body| {\n                             (&tcx.map.body(body).value,\n+                             tcx.tables.borrow().get(&def_id).cloned(),\n                              tcx.ast_ty_to_prim_ty(ty))\n                         });\n                         resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n@@ -126,18 +122,12 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n                 _ => None\n             },\n-            Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                hir::ImplItemKind::Const(ref ty, body) => {\n-                    Some((&tcx.map.body(body).value,\n-                          tcx.ast_ty_to_prim_ty(ty)))\n-                }\n-                _ => None\n-            },\n             Some(_) => None\n         }\n     } else {\n-        let expr_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, Some(tcx.sess.cstore.item_type(tcx, def_id)))\n+        let expr_tables_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+            (&body.value, Some(tcx.item_tables(def_id)),\n+             Some(tcx.sess.cstore.item_type(tcx, def_id)))\n         });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n@@ -148,34 +138,38 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // substitutions for the reference to it.\n                 if let Some(trait_id) = trait_id {\n                     if let Some(substs) = substs {\n-                        resolve_trait_associated_const(tcx, def_id, expr_ty, trait_id, substs)\n+                        resolve_trait_associated_const(tcx, def_id, expr_tables_ty,\n+                                                       trait_id, substs)\n                     } else {\n                         None\n                     }\n                 } else {\n-                    expr_ty\n+                    expr_tables_ty\n                 }\n             },\n-            Some(Def::Const(..)) => expr_ty,\n+            Some(Def::Const(..)) => expr_tables_ty,\n             _ => None\n         }\n     }\n }\n \n fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<&'tcx hir::Body>\n+                                   -> Option<(&'tcx hir::Body, Option<&'a ty::Tables<'tcx>>)>\n {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         FnLikeNode::from_node(tcx.map.get(node_id)).and_then(|fn_like| {\n             if fn_like.constness() == hir::Constness::Const {\n-                Some(tcx.map.body(fn_like.body()))\n+                Some((tcx.map.body(fn_like.body()),\n+                      tcx.tables.borrow().get(&def_id).cloned()))\n             } else {\n                 None\n             }\n         })\n     } else {\n         if tcx.sess.cstore.is_const_fn(def_id) {\n-            tcx.sess.cstore.maybe_get_item_body(tcx, def_id)\n+            tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+                (body, Some(tcx.item_tables(def_id)))\n+            })\n         } else {\n             None\n         }\n@@ -230,30 +224,38 @@ pub fn note_const_eval_err<'a, 'tcx>(\n     }\n }\n \n-pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 e: &Expr) -> ConstVal {\n-    match eval_const_expr_checked(tcx, e) {\n-        Ok(r) => r,\n-        // non-const path still needs to be a fatal error, because enums are funky\n-        Err(s) => {\n-            report_const_eval_err(tcx, &s, e.span, \"expression\").emit();\n-            match s.kind {\n-                NonConstPath |\n-                UnimplementedConstVal(_) => tcx.sess.abort_if_errors(),\n-                _ => {}\n-            }\n-            Dummy\n-        },\n-    }\n+pub struct ConstContext<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: Option<&'a ty::Tables<'tcx>>,\n+    fn_args: Option<DefIdMap<ConstVal>>\n }\n \n-pub fn eval_const_expr_checked<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         e: &Expr) -> EvalResult\n-{\n-    eval_const_expr_partial(tcx, e, ExprTypeChecked, None)\n-}\n+impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n+        let def_id = tcx.map.body_owner_def_id(body);\n+        ConstContext {\n+            tcx: tcx,\n+            tables: tcx.tables.borrow().get(&def_id).cloned(),\n+            fn_args: None\n+        }\n+    }\n+\n+    pub fn with_tables(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &'a ty::Tables<'tcx>) -> Self {\n+        ConstContext {\n+            tcx: tcx,\n+            tables: Some(tables),\n+            fn_args: None\n+        }\n+    }\n \n-pub type FnArgMap<'a> = Option<&'a DefIdMap<ConstVal>>;\n+    /// Evaluate a constant expression in a context where the expression isn't\n+    /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n+    /// but a few places need to evaluate constants during type-checking, like\n+    /// computing the length of an array. (See also the FIXME above EvalHint.)\n+    pub fn eval(&self, e: &Expr, ty_hint: EvalHint<'tcx>) -> EvalResult {\n+        eval_const_expr_partial(self, e, ty_hint)\n+    }\n+}\n \n #[derive(Clone, Debug)]\n pub struct ConstEvalErr {\n@@ -433,20 +435,16 @@ macro_rules! signal {\n     }\n }\n \n-/// Evaluate a constant expression in a context where the expression isn't\n-/// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n-/// but a few places need to evaluate constants during type-checking, like\n-/// computing the length of an array. (See also the FIXME above EvalHint.)\n-pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         e: &Expr,\n-                                         ty_hint: EvalHint<'tcx>,\n-                                         fn_args: FnArgMap) -> EvalResult {\n+fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n+                                     e: &Expr,\n+                                     ty_hint: EvalHint<'tcx>) -> EvalResult {\n+    let tcx = cx.tcx;\n     // Try to compute the type of the expression based on the EvalHint.\n     // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n     let ety = match ty_hint {\n         ExprTypeChecked => {\n             // After type-checking, expr_ty is guaranteed to succeed.\n-            Some(tcx.tables().expr_ty(e))\n+            cx.tables.map(|tables| tables.expr_ty(e))\n         }\n         UncheckedExprHint(ty) => {\n             // Use the type hint; it's not guaranteed to be right, but it's\n@@ -457,7 +455,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // This expression might not be type-checked, and we have no hint.\n             // Try to query the context for a type anyway; we might get lucky\n             // (for example, if the expression was imported from another crate).\n-            tcx.tables().expr_ty_opt(e)\n+            cx.tables.and_then(|tables| tables.expr_ty_opt(e))\n         }\n     };\n     let result = match e.node {\n@@ -466,33 +464,36 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let hir::ExprLit(ref lit) = inner.node {\n             use syntax::ast::*;\n             use syntax::ast::LitIntType::*;\n-            const I8_OVERFLOW: u128 = i8::max_value() as u128 + 1;\n-            const I16_OVERFLOW: u128 = i16::max_value() as u128 + 1;\n-            const I32_OVERFLOW: u128 = i32::max_value() as u128 + 1;\n-            const I64_OVERFLOW: u128 = i64::max_value() as u128 + 1;\n-            const I128_OVERFLOW: u128 = i128::max_value() as u128 + 1;\n+            const I8_OVERFLOW: u128 = i8::min_value() as u8 as u128;\n+            const I16_OVERFLOW: u128 = i16::min_value() as u16 as u128;\n+            const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n+            const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n+            const I128_OVERFLOW: u128 = i128::min_value() as u128;\n             match (&lit.node, ety.map(|t| &t.sty)) {\n-                (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n+                (&LitKind::Int(I8_OVERFLOW, _), Some(&ty::TyInt(IntTy::I8))) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n                     return Ok(Integral(I8(i8::min_value())))\n                 },\n-                (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n+                (&LitKind::Int(I16_OVERFLOW, _), Some(&ty::TyInt(IntTy::I16))) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n                     return Ok(Integral(I16(i16::min_value())))\n                 },\n-                (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n+                (&LitKind::Int(I32_OVERFLOW, _), Some(&ty::TyInt(IntTy::I32))) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n                     return Ok(Integral(I32(i32::min_value())))\n                 },\n-                (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n+                (&LitKind::Int(I64_OVERFLOW, _), Some(&ty::TyInt(IntTy::I64))) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n                     return Ok(Integral(I64(i64::min_value())))\n                 },\n-                (&LitKind::Int(I128_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I128))) |\n-                (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n-                    return Ok(Integral(I128(i128::min_value())))\n+                (&LitKind::Int(n, _), Some(&ty::TyInt(IntTy::I128))) |\n+                (&LitKind::Int(n, Signed(IntTy::I128)), _) => {\n+                    // SNAP: replace n in pattern with I128_OVERFLOW and remove this if.\n+                    if n == I128_OVERFLOW {\n+                        return Ok(Integral(I128(i128::min_value())))\n+                    }\n                 },\n-                (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n+                (&LitKind::Int(n, _), Some(&ty::TyInt(IntTy::Is))) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n                     match tcx.sess.target.int_type {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n@@ -510,14 +511,14 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => {},\n             }\n         }\n-        match eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)? {\n+        match cx.eval(inner, ty_hint)? {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)? {\n+        match cx.eval(inner, ty_hint)? {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n@@ -533,8 +534,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (eval_const_expr_partial(tcx, &a, ty_hint, fn_args)?,\n-               eval_const_expr_partial(tcx, &b, b_ty, fn_args)?) {\n+        match (cx.eval(a, ty_hint)?,\n+               cx.eval(b, b_ty)?) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -604,13 +605,13 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let base_hint = if let ExprTypeChecked = ty_hint {\n             ExprTypeChecked\n         } else {\n-            match tcx.tables().expr_ty_opt(&base) {\n+            match cx.tables.and_then(|tables| tables.expr_ty_opt(&base)) {\n                 Some(t) => UncheckedExprHint(t),\n                 None => ty_hint\n             }\n         };\n \n-        let val = match eval_const_expr_partial(tcx, &base, base_hint, fn_args) {\n+        let val = match cx.eval(base, base_hint) {\n             Ok(val) => val,\n             Err(ConstEvalErr { kind: ErroneousReferencedConstant(\n                 box ConstEvalErr { kind: TypeMismatch(_, val), .. }), .. }) |\n@@ -623,7 +624,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     // we had a type hint, so we can't have an unknown type\n                     None => bug!(),\n                 };\n-                eval_const_expr_partial(tcx, &base, hint, fn_args)?\n+                cx.eval(base, hint)?\n             },\n             Err(e) => return Err(e),\n         };\n@@ -633,22 +634,29 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-          let def = tcx.tables().qpath_def(qpath, e.id);\n+          let def = cx.tables.map(|tables| tables.qpath_def(qpath, e.id)).unwrap_or_else(|| {\n+            // There are no tables so we can only handle already-resolved HIR.\n+            match *qpath {\n+                hir::QPath::Resolved(_, ref path) => path.def,\n+                hir::QPath::TypeRelative(..) => Def::Err\n+            }\n+          });\n           match def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(tcx.tables().node_id_item_substs(e.id)\n+                      Some(cx.tables.and_then(|tables| tables.node_id_item_substs(e.id))\n                         .unwrap_or_else(|| tcx.intern_substs(&[])))\n                   } else {\n                       None\n                   };\n-                  if let Some((expr, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n+                  if let Some((expr, tables, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n                       let item_hint = match ty {\n                           Some(ty) => ty_hint.checked_or(ty),\n                           None => ty_hint,\n                       };\n-                      match eval_const_expr_partial(tcx, expr, item_hint, None) {\n+                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n+                      match cx.eval(expr, item_hint) {\n                           Ok(val) => val,\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n@@ -660,8 +668,9 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }\n               },\n               Def::VariantCtor(variant_def, ..) => {\n-                  if let Some(const_expr) = lookup_variant_by_id(tcx, variant_def) {\n-                      match eval_const_expr_partial(tcx, const_expr, ty_hint, None) {\n+                  if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n+                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n+                      match cx.eval(expr, ty_hint) {\n                           Ok(val) => val,\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n@@ -673,11 +682,11 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }\n               }\n               Def::StructCtor(..) => {\n-                  ConstVal::Struct(e.id)\n+                  ConstVal::Struct(Default::default())\n               }\n               Def::Local(def_id) => {\n-                  debug!(\"Def::Local({:?}): {:?}\", def_id, fn_args);\n-                  if let Some(val) = fn_args.and_then(|args| args.get(&def_id)) {\n+                  debug!(\"Def::Local({:?}): {:?}\", def_id, cx.fn_args);\n+                  if let Some(val) = cx.fn_args.as_ref().and_then(|args| args.get(&def_id)) {\n                       val.clone()\n                   } else {\n                       signal!(e, NonConstPath);\n@@ -690,14 +699,14 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n       }\n       hir::ExprCall(ref callee, ref args) => {\n           let sub_ty_hint = ty_hint.erase_hint();\n-          let callee_val = eval_const_expr_partial(tcx, callee, sub_ty_hint, fn_args)?;\n+          let callee_val = cx.eval(callee, sub_ty_hint)?;\n           let did = match callee_val {\n               Function(did) => did,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let body = match lookup_const_fn_by_id(tcx, did) {\n-              Some(body) => body,\n+          let (body, tables) = match lookup_const_fn_by_id(tcx, did) {\n+              Some(x) => x,\n               None => signal!(e, NonConstPath),\n           };\n \n@@ -710,66 +719,69 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n           let mut call_args = DefIdMap();\n           for (arg, arg_expr) in arg_defs.into_iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n-              let arg_val = eval_const_expr_partial(\n-                  tcx,\n-                  arg_expr,\n-                  arg_hint,\n-                  fn_args\n-              )?;\n+              let arg_val = cx.eval(arg_expr, arg_hint)?;\n               debug!(\"const call arg: {:?}\", arg);\n               if let Some(def_id) = arg {\n                 assert!(call_args.insert(def_id, arg_val).is_none());\n               }\n           }\n           debug!(\"const call({:?})\", call_args);\n-          eval_const_expr_partial(tcx, &body.value, ty_hint, Some(&call_args))?\n+          let callee_cx = ConstContext {\n+            tcx: tcx,\n+            tables: tables,\n+            fn_args: Some(call_args)\n+          };\n+          callee_cx.eval(&body.value, ty_hint)?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n           Ok(val) => val,\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n+            Some(ref expr) => cx.eval(expr, ty_hint)?,\n             None => signal!(e, UnimplementedConstVal(\"empty block\")),\n         }\n       }\n-      hir::ExprType(ref e, _) => eval_const_expr_partial(tcx, &e, ty_hint, fn_args)?,\n-      hir::ExprTup(_) => Tuple(e.id),\n-      hir::ExprStruct(..) => Struct(e.id),\n+      hir::ExprType(ref e, _) => cx.eval(e, ty_hint)?,\n+      hir::ExprTup(ref fields) => {\n+        let field_hint = ty_hint.erase_hint();\n+        Tuple(fields.iter().map(|e| cx.eval(e, field_hint)).collect::<Result<_, _>>()?)\n+      }\n+      hir::ExprStruct(_, ref fields, _) => {\n+        let field_hint = ty_hint.erase_hint();\n+        Struct(fields.iter().map(|f| {\n+            cx.eval(&f.expr, field_hint).map(|v| (f.name.node, v))\n+        }).collect::<Result<_, _>>()?)\n+      }\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr_hint = ty_hint.erase_hint();\n-        let arr = eval_const_expr_partial(tcx, arr, arr_hint, fn_args)?;\n+        let arr = cx.eval(arr, arr_hint)?;\n         let idx_hint = ty_hint.checked_or(tcx.types.usize);\n-        let idx = match eval_const_expr_partial(tcx, idx, idx_hint, fn_args)? {\n+        let idx = match cx.eval(idx, idx_hint)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n             Integral(_) => bug!(),\n             _ => signal!(idx, IndexNotInt),\n         };\n         assert_eq!(idx as usize as u64, idx);\n         match arr {\n-            Array(_, n) if idx >= n => {\n-                signal!(e, IndexOutOfBounds { len: n, index: idx })\n+            Array(ref v) => {\n+                if let Some(elem) = v.get(idx as usize) {\n+                    elem.clone()\n+                } else {\n+                    let n = v.len() as u64;\n+                    assert_eq!(n as usize as u64, n);\n+                    signal!(e, IndexOutOfBounds { len: n, index: idx })\n+                }\n             }\n-            Array(v, n) => if let hir::ExprArray(ref v) = tcx.map.expect_expr(v).node {\n-                assert_eq!(n as usize as u64, n);\n-                eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args)?\n-            } else {\n-                bug!()\n-            },\n \n-            Repeat(_, n) if idx >= n => {\n+            Repeat(.., n) if idx >= n => {\n                 signal!(e, IndexOutOfBounds { len: n, index: idx })\n             }\n-            Repeat(elem, _) => eval_const_expr_partial(\n-                tcx,\n-                &tcx.map.expect_expr(elem),\n-                ty_hint,\n-                fn_args,\n-            )?,\n+            Repeat(ref elem, _) => (**elem).clone(),\n \n             ByteStr(ref data) if idx >= data.len() as u64 => {\n                 signal!(e, IndexOutOfBounds { len: data.len() as u64, index: idx })\n@@ -781,52 +793,51 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n-      hir::ExprArray(ref v) => Array(e.id, v.len() as u64),\n-      hir::ExprRepeat(_, n) => {\n+      hir::ExprArray(ref v) => {\n+        let elem_hint = ty_hint.erase_hint();\n+        Array(v.iter().map(|e| cx.eval(e, elem_hint)).collect::<Result<_, _>>()?)\n+      }\n+      hir::ExprRepeat(ref elem, count) => {\n+          let elem_hint = ty_hint.erase_hint();\n           let len_hint = ty_hint.checked_or(tcx.types.usize);\n-          let n = &tcx.map.body(n).value;\n-          Repeat(\n-              e.id,\n-              match eval_const_expr_partial(tcx, n, len_hint, fn_args)? {\n-                  Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-                  Integral(_) => signal!(e, RepeatCountNotNatural),\n-                  _ => signal!(e, RepeatCountNotInt),\n-              },\n-          )\n+          let n = if let Some(ty) = ety {\n+            // For cross-crate constants, we have the type already,\n+            // but not the body for `count`, so use the type.\n+            match ty.sty {\n+                ty::TyArray(_, n) => n as u64,\n+                _ => bug!()\n+            }\n+          } else {\n+            let n = &tcx.map.body(count).value;\n+            match ConstContext::new(tcx, count).eval(n, len_hint)? {\n+                Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+                Integral(_) => signal!(e, RepeatCountNotNatural),\n+                _ => signal!(e, RepeatCountNotInt),\n+            }\n+          };\n+          Repeat(Box::new(cx.eval(elem, elem_hint)?), n)\n       },\n       hir::ExprTupField(ref base, index) => {\n         let base_hint = ty_hint.erase_hint();\n-        let c = eval_const_expr_partial(tcx, base, base_hint, fn_args)?;\n-        if let Tuple(tup_id) = c {\n-            if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n-                if index.node < fields.len() {\n-                    eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args)?\n-                } else {\n-                    signal!(e, TupleIndexOutOfBounds);\n-                }\n+        let c = cx.eval(base, base_hint)?;\n+        if let Tuple(ref fields) = c {\n+            if let Some(elem) = fields.get(index.node) {\n+                elem.clone()\n             } else {\n-                bug!()\n+                signal!(e, TupleIndexOutOfBounds);\n             }\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n         let base_hint = ty_hint.erase_hint();\n-        // Get the base expression if it is a struct and it is constant\n-        let c = eval_const_expr_partial(tcx, base, base_hint, fn_args)?;\n-        if let Struct(struct_id) = c {\n-            if let hir::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n-                // Check that the given field exists and evaluate it\n-                // if the idents are compared run-pass/issue-19244 fails\n-                if let Some(f) = fields.iter().find(|f| f.name.node\n-                                                     == field_name.node) {\n-                    eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args)?\n-                } else {\n-                    signal!(e, MissingStructField);\n-                }\n+        let c = cx.eval(base, base_hint)?;\n+        if let Struct(ref fields) = c {\n+            if let Some(f) = fields.get(&field_name.node) {\n+                f.clone()\n             } else {\n-                bug!()\n+                signal!(e, MissingStructField);\n             }\n         } else {\n             signal!(base, ExpectedConstStruct);\n@@ -909,17 +920,17 @@ fn infer<'a, 'tcx>(i: ConstInt,\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>,\n+    default_value: Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>, Option<ty::Ty<'tcx>>)>,\n     trait_id: DefId,\n     rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n+) -> Option<(&'tcx Expr, Option<&'a ty::Tables<'tcx>>, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                                  trait_ref.to_poly_trait_predicate());\n@@ -1160,36 +1171,40 @@ pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n     }\n }\n \n-pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   span: Span,\n-                                   a: &Expr,\n-                                   b: &Expr) -> Result<Ordering, ErrorReported> {\n-    let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n-        Ok(a) => a,\n-        Err(e) => {\n-            report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n-            return Err(ErrorReported);\n-        }\n-    };\n-    let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked, None) {\n-        Ok(b) => b,\n-        Err(e) => {\n-            report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n-            return Err(ErrorReported);\n-        }\n-    };\n-    compare_const_vals(tcx, span, &a, &b)\n+impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n+    pub fn compare_lit_exprs(&self,\n+                             span: Span,\n+                             a: &Expr,\n+                             b: &Expr) -> Result<Ordering, ErrorReported> {\n+        let tcx = self.tcx;\n+        let a = match self.eval(a, ExprTypeChecked) {\n+            Ok(a) => a,\n+            Err(e) => {\n+                report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n+                return Err(ErrorReported);\n+            }\n+        };\n+        let b = match self.eval(b, ExprTypeChecked) {\n+            Ok(b) => b,\n+            Err(e) => {\n+                report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n+                return Err(ErrorReported);\n+            }\n+        };\n+        compare_const_vals(tcx, span, &a, &b)\n+    }\n }\n \n \n /// Returns the value of the length-valued expression\n pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             count_expr: &hir::Expr,\n+                             count: hir::BodyId,\n                              reason: &str)\n                              -> Result<usize, ErrorReported>\n {\n     let hint = UncheckedExprHint(tcx.types.usize);\n-    match eval_const_expr_partial(tcx, count_expr, hint, None) {\n+    let count_expr = &tcx.map.body(count).value;\n+    match ConstContext::new(tcx, count).eval(count_expr, hint) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);"}, {"sha": "fbd15b6eb103531fbd6e746ddd7c31c9de95b869", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 53, "deletions": 34, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,7 +13,8 @@ use eval;\n use rustc::lint;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, TypeVariants, Region};\n+use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -67,6 +68,7 @@ pub enum PatternKind<'tcx> {\n     /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n         adt_def: &'tcx AdtDef,\n+        substs: &'tcx Substs<'tcx>,\n         variant_index: usize,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n@@ -117,8 +119,7 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::Tuple(_) |\n         ConstVal::Function(_) |\n         ConstVal::Array(..) |\n-        ConstVal::Repeat(..) |\n-        ConstVal::Dummy => bug!(\"{:?} not printable in a pattern\", value)\n+        ConstVal::Repeat(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n@@ -259,12 +260,15 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n \n pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tables: &'a ty::Tables<'gcx>,\n     pub errors: Vec<PatternError>,\n }\n \n impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n-    pub fn from_hir(tcx: TyCtxt<'a, 'gcx, 'tcx>, pat: &hir::Pat) -> Self {\n-        let mut pcx = PatternContext::new(tcx);\n+    pub fn from_hir(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    tables: &'a ty::Tables<'gcx>,\n+                    pat: &hir::Pat) -> Self {\n+        let mut pcx = PatternContext::new(tcx, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n             span_bug!(pat.span, \"encountered errors lowering pattern: {:?}\", pcx.errors)\n@@ -275,12 +279,12 @@ impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        PatternContext { tcx: tcx, errors: vec![] }\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, tables: &'a ty::Tables<'gcx>) -> Self {\n+        PatternContext { tcx: tcx, tables: tables, errors: vec![] }\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tcx.tables().node_id_to_type(pat.id);\n+        let mut ty = self.tables.node_id_to_type(pat.id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -307,7 +311,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tcx.tables().node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -332,7 +336,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                let ty = self.tcx.tables().node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyTuple(ref tys) => {\n                         let subpatterns =\n@@ -353,7 +357,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n             PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n+                let var_ty = self.tables.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n@@ -390,9 +394,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             }\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n+                let def = self.tables.qpath_def(qpath, pat.id);\n+                let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n@@ -406,13 +409,12 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                        pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                self.lower_variant_or_leaf(def, subpatterns)\n+                self.lower_variant_or_leaf(def, ty, subpatterns)\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n-                let adt_def = match pat_ty.sty {\n+                let def = self.tables.qpath_def(qpath, pat.id);\n+                let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n                         span_bug!(\n@@ -439,7 +441,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, subpatterns)\n+                self.lower_variant_or_leaf(def, ty, subpatterns)\n             }\n         };\n \n@@ -529,6 +531,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n     fn lower_variant_or_leaf(\n         &mut self,\n         def: Def,\n+        ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n         -> PatternKind<'tcx>\n     {\n@@ -537,8 +540,14 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n+                    let substs = match ty.sty {\n+                        TypeVariants::TyAdt(_, substs) => substs,\n+                        TypeVariants::TyFnDef(_, substs, _) => substs,\n+                        _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n+                    };\n                     PatternKind::Variant {\n                         adt_def: adt_def,\n+                        substs: substs,\n                         variant_index: adt_def.variant_index_with_id(variant_id),\n                         subpatterns: subpatterns,\n                     }\n@@ -562,34 +571,41 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n-        let def = self.tcx.tables().qpath_def(qpath, id);\n+        let ty = self.tables.node_id_to_type(id);\n+        let def = self.tables.qpath_def(qpath, id);\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let tcx = self.tcx.global_tcx();\n-                let substs = tcx.tables().node_id_item_substs(id)\n+                let substs = self.tables.node_id_item_substs(id)\n                     .unwrap_or_else(|| tcx.intern_substs(&[]));\n                 match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n-                    Some((const_expr, _const_ty)) => {\n-                        return self.lower_const_expr(const_expr, pat_id, span);\n+                    Some((const_expr, const_tables, _const_ty)) => {\n+                        // Enter the inlined constant's tables temporarily.\n+                        let old_tables = self.tables;\n+                        self.tables = const_tables.expect(\"missing tables after typeck\");\n+                        let pat = self.lower_const_expr(const_expr, pat_id, span);\n+                        self.tables = old_tables;\n+                        return pat;\n                     }\n                     None => {\n                         self.errors.push(PatternError::StaticInPattern(span));\n                         PatternKind::Wild\n                     }\n                 }\n             }\n-            _ => self.lower_variant_or_leaf(def, vec![])\n+            _ => self.lower_variant_or_leaf(def, ty, vec![]),\n         };\n \n         Pattern {\n             span: span,\n-            ty: self.tcx.tables().node_id_to_type(id),\n+            ty: ty,\n             kind: Box::new(kind),\n         }\n     }\n \n     fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n-        match eval::eval_const_expr_checked(self.tcx.global_tcx(), expr) {\n+        let const_cx = eval::ConstContext::with_tables(self.tcx.global_tcx(), self.tables);\n+        match const_cx.eval(expr, eval::EvalHint::ExprTypeChecked) {\n             Ok(value) => {\n                 PatternKind::Constant { value: value }\n             }\n@@ -605,7 +621,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                         pat_id: ast::NodeId,\n                         span: Span)\n                         -> Pattern<'tcx> {\n-        let pat_ty = self.tcx.tables().expr_ty(expr);\n+        let pat_ty = self.tables.expr_ty(expr);\n         debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n         match pat_ty.sty {\n             ty::TyFloat(_) => {\n@@ -651,7 +667,8 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                     hir::ExprPath(ref qpath) => qpath,\n                     _ => bug!()\n                 };\n-                let def = self.tcx.tables().qpath_def(qpath, callee.id);\n+                let ty = self.tables.node_id_to_type(callee.id);\n+                let def = self.tables.qpath_def(qpath, callee.id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n                     _ => {\n@@ -661,14 +678,13 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                 pattern: self.lower_const_expr(expr, pat_id, span)\n                             }\n                         }).collect();\n-                        self.lower_variant_or_leaf(def, subpatterns)\n+                        self.lower_variant_or_leaf(def, ty, subpatterns)\n                     }\n                 }\n             }\n \n             hir::ExprStruct(ref qpath, ref fields, None) => {\n-                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n-                let pat_ty = self.tcx.tables().node_id_to_type(expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -696,7 +712,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, subpatterns)\n+                self.lower_variant_or_leaf(def, pat_ty, subpatterns)\n             }\n \n             hir::ExprArray(ref exprs) => {\n@@ -776,8 +792,9 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal,\n-    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal, Region,\n+    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n@@ -828,10 +845,12 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             },\n             PatternKind::Variant {\n                 adt_def,\n+                substs,\n                 variant_index,\n                 ref subpatterns,\n             } => PatternKind::Variant {\n                 adt_def: adt_def.fold_with(folder),\n+                substs: substs.fold_with(folder),\n                 variant_index: variant_index.fold_with(folder),\n                 subpatterns: subpatterns.fold_with(folder)\n             },"}, {"sha": "53f185b661b4193873588c6ddbdfa77e772de906", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -661,7 +661,7 @@ impl ::std::ops::Neg for ConstInt {\n             a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n             a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n             U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n-            Infer(a @ 0...ubounds::I64MAX) => Ok(InferSigned(-(a as i128))),\n+            Infer(a @ 0...ubounds::I128MAX) => Ok(InferSigned(-(a as i128))),\n             Infer(_) => Err(Overflow(Op::Neg)),\n             InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n         }"}, {"sha": "cd933c0059945660771c224e4ee135442984b29f", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -26,6 +26,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(const_fn)]\n+#![cfg_attr(not(stage0), feature(i128))]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "78af655852d1b0656ade7f7ce031ad0e38d71434", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -19,6 +19,7 @@ use std::ops::{Deref, DerefMut};\n use std::iter::{self, IntoIterator, FromIterator};\n use std::slice;\n use std::vec;\n+use std::collections::range::RangeArgument;\n \n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n \n@@ -71,6 +72,19 @@ impl<A: Array> AccumulateVec<A> {\n             AccumulateVec::Heap(ref mut vec) => vec.pop(),\n         }\n     }\n+\n+    pub fn drain<R>(&mut self, range: R) -> Drain<A>\n+        where R: RangeArgument<usize>\n+    {\n+        match *self {\n+            AccumulateVec::Array(ref mut v) => {\n+                Drain::Array(v.drain(range))\n+            },\n+            AccumulateVec::Heap(ref mut v) => {\n+                Drain::Heap(v.drain(range))\n+            },\n+        }\n+    }\n }\n \n impl<A: Array> Deref for AccumulateVec<A> {\n@@ -132,6 +146,31 @@ impl<A: Array> Iterator for IntoIter<A> {\n     }\n }\n \n+pub enum Drain<'a, A: Array>\n+        where A::Element: 'a\n+{\n+    Array(array_vec::Drain<'a, A>),\n+    Heap(vec::Drain<'a, A::Element>),\n+}\n+\n+impl<'a, A: Array> Iterator for Drain<'a, A> {\n+    type Item = A::Element;\n+\n+    fn next(&mut self) -> Option<A::Element> {\n+        match *self {\n+            Drain::Array(ref mut drain) => drain.next(),\n+            Drain::Heap(ref mut drain) => drain.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match *self {\n+            Drain::Array(ref drain) => drain.size_hint(),\n+            Drain::Heap(ref drain) => drain.size_hint(),\n+        }\n+    }\n+}\n+\n impl<A: Array> IntoIterator for AccumulateVec<A> {\n     type Item = A::Element;\n     type IntoIter = IntoIter<A>;"}, {"sha": "844e9041d202984a8d312149510a10871b491775", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -12,12 +12,13 @@\n \n use std::marker::Unsize;\n use std::iter::Extend;\n-use std::ptr::{self, drop_in_place};\n+use std::ptr::{self, drop_in_place, Shared};\n use std::ops::{Deref, DerefMut, Range};\n use std::hash::{Hash, Hasher};\n use std::slice;\n use std::fmt;\n use std::mem;\n+use std::collections::range::RangeArgument;\n \n pub unsafe trait Array {\n     type Element;\n@@ -103,6 +104,44 @@ impl<A: Array> ArrayVec<A> {\n             None\n         }\n     }\n+\n+    pub fn drain<R>(&mut self, range: R) -> Drain<A>\n+        where R: RangeArgument<usize>\n+    {\n+        // Memory safety\n+        //\n+        // When the Drain is first created, it shortens the length of\n+        // the source vector to make sure no uninitalized or moved-from elements\n+        // are accessible at all if the Drain's destructor never gets to run.\n+        //\n+        // Drain will ptr::read out the values to remove.\n+        // When finished, remaining tail of the vec is copied back to cover\n+        // the hole, and the vector length is restored to the new length.\n+        //\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+        assert!(start <= end);\n+        assert!(end <= len);\n+\n+        unsafe {\n+            // set self.vec length's to start, to be safe in case Drain is leaked\n+            self.set_len(start);\n+            // Use the borrow in the IterMut to indicate borrowing behavior of the\n+            // whole Drain iterator (like &mut T).\n+            let range_slice = {\n+                let arr = &mut self.values as &mut [ManuallyDrop<_>];\n+                slice::from_raw_parts_mut(arr.as_mut_ptr().offset(start as isize),\n+                                          end - start)\n+            };\n+            Drain {\n+                tail_start: end,\n+                tail_len: len - end,\n+                iter: range_slice.iter(),\n+                array_vec: Shared::new(self as *mut _),\n+            }\n+        }\n+    }\n }\n \n impl<A> Default for ArrayVec<A>\n@@ -179,6 +218,51 @@ impl<A: Array> Iterator for Iter<A> {\n     }\n }\n \n+pub struct Drain<'a, A: Array>\n+        where A::Element: 'a\n+{\n+    tail_start: usize,\n+    tail_len: usize,\n+    iter: slice::Iter<'a, ManuallyDrop<A::Element>>,\n+    array_vec: Shared<ArrayVec<A>>,\n+}\n+\n+impl<'a, A: Array> Iterator for Drain<'a, A> {\n+    type Item = A::Element;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A::Element> {\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const ManuallyDrop<_>).value })\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl<'a, A: Array> Drop for Drain<'a, A> {\n+    fn drop(&mut self) {\n+        // exhaust self first\n+        while let Some(_) = self.next() {}\n+\n+        if self.tail_len > 0 {\n+            unsafe {\n+                let source_array_vec = &mut **self.array_vec;\n+                // memmove back untouched tail, update to new length\n+                let start = source_array_vec.len();\n+                let tail = self.tail_start;\n+                {\n+                    let mut arr = &mut source_array_vec.values as &mut [ManuallyDrop<_>];\n+                    let src = arr.as_ptr().offset(tail as isize);\n+                    let dst = arr.as_mut_ptr().offset(start as isize);\n+                    ptr::copy(src, dst, self.tail_len);\n+                };\n+                source_array_vec.set_len(start + self.tail_len);\n+            }\n+        }\n+    }\n+}\n+\n impl<A: Array> IntoIterator for ArrayVec<A> {\n     type Item = A::Element;\n     type IntoIter = Iter<A>;"}, {"sha": "31492e2621945dd292d556f556fd61d4a3d36fb6", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -113,17 +113,20 @@ fn blake2b_compress(ctx: &mut Blake2bCtx, last: bool) {\n     }\n \n     {\n-        // Re-interpret the input buffer in the state as u64s\n+        // Re-interpret the input buffer in the state as an array\n+        // of little-endian u64s, converting them to machine\n+        // endianness. It's OK to modify the buffer in place\n+        // since this is the last time  this data will be accessed\n+        // before it's overwritten.\n+\n         let m: &mut [u64; 16] = unsafe {\n             let b: &mut [u8; 128] = &mut ctx.b;\n             ::std::mem::transmute(b)\n         };\n \n-        // It's OK to modify the buffer in place since this is the last time\n-        // this data will be accessed before it's overwritten\n         if cfg!(target_endian = \"big\") {\n             for word in &mut m[..] {\n-                *word = word.to_be();\n+                *word = u64::from_le(*word);\n             }\n         }\n \n@@ -209,9 +212,10 @@ fn blake2b_final(ctx: &mut Blake2bCtx)\n \n     blake2b_compress(ctx, true);\n \n+    // Modify our buffer to little-endian format as it will be read\n+    // as a byte array. It's OK to modify the buffer in place since\n+    // this is the last time this data will be accessed.\n     if cfg!(target_endian = \"big\") {\n-        // Make sure that the data is in memory in little endian format, as is\n-        // demanded by BLAKE2\n         for word in &mut ctx.h {\n             *word = word.to_le();\n         }"}, {"sha": "4623e52ffc2fd4f4e98ca4c5da3231577ddd17a5", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,8 +23,10 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n+#![feature(shared)]\n+#![feature(collections_range)]\n #![feature(nonzero)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "442c139f14c06ec81f143ce9284055509ca424ea", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -716,8 +716,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n                                                      is_proc_macro_crate,\n                                                      is_test_crate,\n                                                      num_crate_types,\n-                                                     sess.diagnostic(),\n-                                                     &sess.features.borrow())\n+                                                     sess.diagnostic())\n         });\n     }\n \n@@ -1335,9 +1334,10 @@ pub fn build_output_filenames(input: &Input,\n                                            .values()\n                                            .filter(|a| a.is_none())\n                                            .count();\n-            let ofile = if unnamed_output_types > 1 {\n-                sess.warn(\"ignoring specified output filename because multiple outputs were \\\n-                           requested\");\n+            let ofile = if unnamed_output_types > 1 &&\n+                            sess.opts.output_types.contains_key(&OutputType::Exe) {\n+                sess.warn(\"ignoring specified output filename for 'link' output because multiple \\\n+                           outputs were requested\");\n                 None\n             } else {\n                 Some(out_file.clone())"}, {"sha": "25049b3d2badb53ca19341efb07e41000c7a4f7e", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -21,7 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(box_syntax)]\n #![feature(libc)]"}, {"sha": "afacfb6e3f9fd6a1cd839121c988c6673d8a45cf", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -39,6 +39,7 @@ use syntax_pos;\n \n use graphviz as dot;\n \n+use std::cell::Cell;\n use std::fs::File;\n use std::io::{self, Write};\n use std::iter;\n@@ -236,7 +237,11 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let annotation = TypedAnnotation { tcx: tcx };\n+                    let empty_tables = ty::Tables::empty();\n+                    let annotation = TypedAnnotation {\n+                        tcx: tcx,\n+                        tables: Cell::new(&empty_tables)\n+                    };\n                     let _ignore = tcx.dep_graph.in_ignore();\n                     f(&annotation, payload, ast_map.forest.krate())\n                 }),\n@@ -488,6 +493,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n \n struct TypedAnnotation<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: Cell<&'a ty::Tables<'tcx>>,\n }\n \n impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n@@ -511,7 +517,13 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n-        pprust_hir::PpAnn::nested(&self.tcx.map, state, nested)\n+        let old_tables = self.tables.get();\n+        if let pprust_hir::Nested::Body(id) = nested {\n+            self.tables.set(self.tcx.body_tables(id));\n+        }\n+        pprust_hir::PpAnn::nested(&self.tcx.map, state, nested)?;\n+        self.tables.set(old_tables);\n+        Ok(())\n     }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n@@ -525,7 +537,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n                 pp::space(&mut s.s)?;\n                 pp::word(&mut s.s, \"as\")?;\n                 pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tcx.tables().expr_ty(expr).to_string())?;\n+                pp::word(&mut s.s, &self.tables.get().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),\n@@ -751,7 +763,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n         }\n         blocks::Code::FnLike(fn_like) => {\n             let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.to_fn_parts(), &cfg);\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx, fn_like.body(), &cfg);\n \n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,"}, {"sha": "ede35d052ad51407488c7435a5614e4cbfa4a14b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -149,7 +149,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n \n             body(Env { infcx: &infcx });\n             let free_regions = FreeRegionMap::new();"}, {"sha": "77c6c3683641726fb5d3850183da315fb0c51424", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -703,6 +703,40 @@ impl EmitterWriter {\n         }\n     }\n \n+    /// Add a left margin to every line but the first, given a padding length and the label being\n+    /// displayed.\n+    fn msg_with_padding(&self, msg: &str, padding: usize, label: &str) -> String {\n+        // The extra 5 ` ` is padding that's always needed to align to the `note: `:\n+        //\n+        //   error: message\n+        //     --> file.rs:13:20\n+        //      |\n+        //   13 |     <CODE>\n+        //      |      ^^^^\n+        //      |\n+        //      = note: multiline\n+        //              message\n+        //   ++^^^----xx\n+        //    |  |   | |\n+        //    |  |   | magic `2`\n+        //    |  |   length of label\n+        //    |  magic `3`\n+        //    `max_line_num_len`\n+        let padding = (0..padding + label.len() + 5)\n+            .map(|_| \" \")\n+            .collect::<String>();\n+\n+        msg.split('\\n').enumerate().fold(\"\".to_owned(), |mut acc, x| {\n+            if x.0 != 0 {\n+                acc.push_str(\"\\n\");\n+                // Align every line with first one.\n+                acc.push_str(&padding);\n+            }\n+            acc.push_str(&x.1);\n+            acc\n+        })\n+    }\n+\n     fn emit_message_default(&mut self,\n                             msp: &MultiSpan,\n                             msg: &str,\n@@ -721,7 +755,9 @@ impl EmitterWriter {\n             draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n             buffer.append(0, &level.to_string(), Style::HeaderMsg);\n             buffer.append(0, \": \", Style::NoStyle);\n-            buffer.append(0, msg, Style::NoStyle);\n+\n+            let message = self.msg_with_padding(msg, max_line_num_len, \"note\");\n+            buffer.append(0, &message, Style::NoStyle);\n         } else {\n             buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n             match code {\n@@ -854,7 +890,9 @@ impl EmitterWriter {\n \n             buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n             buffer.append(0, \": \", Style::HeaderMsg);\n-            buffer.append(0, msg, Style::HeaderMsg);\n+\n+            let message = self.msg_with_padding(msg, max_line_num_len, \"suggestion\");\n+            buffer.append(0, &message, Style::HeaderMsg);\n \n             let lines = cm.span_to_lines(primary_span).unwrap();\n \n@@ -930,7 +968,7 @@ impl EmitterWriter {\n                                                             max_line_num_len,\n                                                             true) {\n                                 Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n+                                _ => (),\n                             }\n                         }\n                     }"}, {"sha": "bcae7b262c6260f3af914426a306abe5c6f507af", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(custom_attribute)]\n #![allow(unused_attributes)]"}, {"sha": "ea0a0034c3e9230ac1fcb513527bb6fe9c1b524e", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -17,7 +17,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "8d86e7e2e8b9ea7d563465a20490a9e06989ada6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tcx.tables().node_id_to_type(e.id);\n+        let ty = cx.tables.node_id_to_type(e.id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -738,8 +738,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             // is this a recursive call?\n             let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n                 match method {\n-                    Some(ref method) => expr_refers_to_this_method(cx.tcx, method, node_id),\n-                    None => expr_refers_to_this_fn(cx.tcx, id, node_id),\n+                    Some(ref method) => expr_refers_to_this_method(cx, method, node_id),\n+                    None => expr_refers_to_this_fn(cx, id, node_id),\n                 }\n             } else {\n                 false\n@@ -787,63 +787,62 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // Functions for identifying if the given Expr NodeId `id`\n         // represents a call to the function `fn_id`/method `method`.\n \n-        fn expr_refers_to_this_fn(tcx: TyCtxt, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n-            match tcx.map.get(id) {\n+        fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n+            match cx.tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        tcx.tables().qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.id)\n                     } else {\n                         return false;\n                     };\n-                    def.def_id() == tcx.map.local_def_id(fn_id)\n+                    def.def_id() == cx.tcx.map.local_def_id(fn_id)\n                 }\n                 _ => false,\n             }\n         }\n \n         // Check if the expression `id` performs a call to `method`.\n-        fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                method: &ty::AssociatedItem,\n-                                                id: ast::NodeId)\n-                                                -> bool {\n+        fn expr_refers_to_this_method(cx: &LateContext,\n+                                      method: &ty::AssociatedItem,\n+                                      id: ast::NodeId)\n+                                      -> bool {\n             use rustc::ty::adjustment::*;\n \n             // Check for method calls and overloaded operators.\n-            let opt_m = tcx.tables().method_map.get(&ty::MethodCall::expr(id)).cloned();\n+            let opt_m = cx.tables.method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n-                if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n                     return true;\n                 }\n             }\n \n             // Check for overloaded autoderef method calls.\n-            let opt_adj = tcx.tables().adjustments.get(&id).cloned();\n+            let opt_adj = cx.tables.adjustments.get(&id).cloned();\n             if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n                 for i in 0..autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables().method_map.get(&method_call)\n-                                                            .cloned() {\n-                        if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                    if let Some(m) = cx.tables.method_map.get(&method_call).cloned() {\n+                        if method_call_refers_to_method(cx.tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n                     }\n                 }\n             }\n \n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n-            match tcx.map.get(id) {\n+            match cx.tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        tcx.tables().qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.id)\n                     } else {\n                         return false;\n                     };\n                     match def {\n                         Def::Method(def_id) => {\n-                            let substs = tcx.tables().node_id_item_substs(callee.id)\n-                                .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                            let substs = cx.tables.node_id_item_substs(callee.id)\n+                                .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                             method_call_refers_to_method(\n-                                tcx, method, def_id, substs, id)\n+                                cx.tcx, method, def_id, substs, id)\n                         }\n                         _ => false,\n                     }\n@@ -882,8 +881,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     // checking, so it's always local\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n-                    let param_env = Some(ty::ParameterEnvironment::for_item(tcx, node_id));\n-                    tcx.infer_ctxt(None, param_env, Reveal::NotSpecializable).enter(|infcx| {\n+                    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n+                    tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound.\n@@ -1073,15 +1072,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                cx.tcx.tables().qpath_def(qpath, expr.id)\n+                cx.tables.qpath_def(qpath, expr.id)\n             } else {\n                 return None;\n             };\n             if let Def::Fn(did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let typ = cx.tcx.tables().node_id_to_type(expr.id);\n+                let typ = cx.tables.node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n                         let from = bare_fn.sig.skip_binder().inputs()[0];"}, {"sha": "60497fe171ccb391cf970177a0e383265774a83e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -26,7 +26,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![cfg_attr(test, feature(test))]\n #![feature(box_patterns)]\n@@ -165,6 +165,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     DEAD_CODE,\n                     UNUSED_MUT,\n                     UNREACHABLE_CODE,\n+                    UNREACHABLE_PATTERNS,\n                     UNUSED_MUST_USE,\n                     UNUSED_UNSAFE,\n                     PATH_STATEMENTS,"}, {"sha": "2a77e9a4a7c8b5b0c58c9d093b4de57e9b5bcf9d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 13, "deletions": 63, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, Primitive};\n use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n-use rustc_const_eval::eval_const_expr_partial;\n+use rustc_const_eval::ConstContext;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -35,32 +35,6 @@ use rustc::hir;\n \n use rustc_i128::{i128, u128};\n \n-register_long_diagnostics! {\n-E0519: r##\"\n-It is not allowed to negate an unsigned integer.\n-You can negate a signed integer and cast it to an\n-unsigned integer or use the `!` operator.\n-\n-```\n-let x: usize = -1isize as usize;\n-let y: usize = !0;\n-assert_eq!(x, y);\n-```\n-\n-Alternatively you can use the `Wrapping` newtype\n-or the `wrapping_neg` operation that all\n-integral types support:\n-\n-```\n-use std::num::Wrapping;\n-let x: Wrapping<usize> = -Wrapping(1);\n-let Wrapping(x) = x;\n-let y: usize = 1.wrapping_neg();\n-assert_eq!(x, y);\n-```\n-\"##\n-}\n-\n declare_lint! {\n     UNUSED_COMPARISONS,\n     Warn,\n@@ -109,38 +83,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref expr) => {\n-                if let hir::ExprLit(ref lit) = expr.node {\n-                    match lit.node {\n-                        ast::LitKind::Int(_, ast::LitIntType::Unsigned(_)) => {\n-                            forbid_unsigned_negation(cx, e.span);\n-                        }\n-                        ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n-                            if let ty::TyUint(_) = cx.tcx.tables().node_id_to_type(e.id).sty {\n-                                forbid_unsigned_negation(cx, e.span);\n-                            }\n-                        }\n-                        _ => (),\n-                    }\n-                } else {\n-                    let t = cx.tcx.tables().node_id_to_type(expr.id);\n-                    if let ty::TyUint(_) = t.sty {\n-                        forbid_unsigned_negation(cx, e.span);\n-                    }\n-                }\n                 // propagate negation, if the negation itself isn't negated\n                 if self.negated_expr_id != e.id {\n                     self.negated_expr_id = expr.id;\n                 }\n             }\n             hir::ExprBinary(binop, ref l, ref r) => {\n-                if is_comparison(binop) && !check_limits(cx.tcx, binop, &l, &r) {\n+                if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n                     cx.span_lint(UNUSED_COMPARISONS,\n                                  e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tcx.tables().node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tables.node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -154,7 +110,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 false\n                             }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n+                            let const_cx = ConstContext::with_tables(cx.tcx, cx.tables);\n+                            match const_cx.eval(&r, ExprTypeChecked) {\n                                 Ok(ConstVal::Integral(i)) => {\n                                     i.is_negative() ||\n                                     i.to_u64()\n@@ -173,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tcx.tables().node_id_to_type(e.id).sty {\n+                match cx.tables.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -318,11 +275,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn check_limits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  binop: hir::BinOp,\n-                                  l: &hir::Expr,\n-                                  r: &hir::Expr)\n-                                  -> bool {\n+        fn check_limits(cx: &LateContext,\n+                        binop: hir::BinOp,\n+                        l: &hir::Expr,\n+                        r: &hir::Expr)\n+                        -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n                 (&hir::ExprLit(_), _) => (l, r, true),\n                 (_, &hir::ExprLit(_)) => (r, l, false),\n@@ -331,7 +288,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match tcx.tables().node_id_to_type(expr.id).sty {\n+            match cx.tables.node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {\n@@ -369,13 +326,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 _ => false,\n             }\n         }\n-\n-        fn forbid_unsigned_negation(cx: &LateContext, span: Span) {\n-            cx.sess()\n-                .struct_span_err_with_code(span, \"unary negation of unsigned integer\", \"E0519\")\n-                .span_help(span, \"use a cast or the `!` operator\")\n-                .emit();\n-        }\n     }\n }\n \n@@ -747,7 +697,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n                 let t = cx.tcx.item_type(cx.tcx.map.local_def_id(it.id));\n-                let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+                let layout = cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx).unwrap_or_else(|e| {\n                         bug!(\"failed to get layout for `{}`: {}\", t, e)"}, {"sha": "48d9f5e72c26dab57a38b58deeb2d5879522939e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             return;\n         }\n \n-        let t = cx.tcx.tables().expr_ty(&expr);\n+        let t = cx.tables.expr_ty(&expr);\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyNever => return,\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n             _ => return,\n         }\n \n-        if let Some(adjustment) = cx.tcx.tables().adjustments.get(&e.id) {\n+        if let Some(adjustment) = cx.tables.adjustments.get(&e.id) {\n             if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n                 match autoref {\n                     Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {"}, {"sha": "b1615b9e38bde11e25ad248d82363734bebc10c7", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -20,7 +20,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(associated_consts)]\n #![feature(box_syntax)]"}, {"sha": "3c14d38cc38211a6ad32612476a1d54ef28648c8", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 11, "deletions": 107, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -8,59 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::map as ast_map;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n-use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange, NestedVisitorMap};\n-\n-use cstore::CrateMetadata;\n use encoder::EncodeContext;\n use schema::*;\n \n use rustc::hir;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TyCtxt, Ty};\n-\n-use syntax::ast;\n+use rustc::ty;\n \n use rustc_serialize::Encodable;\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n-    id_range: IdRange,\n-    body: Lazy<hir::Body>,\n-    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>,\n+    pub body: Lazy<hir::Body>,\n+    pub tables: Lazy<ty::Tables<'tcx>>,\n     pub nested_bodies: LazySeq<hir::Body>,\n     pub rvalue_promotable_to_static: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-enum TableEntry<'tcx> {\n-    TypeRelativeDef(Def),\n-    NodeType(Ty<'tcx>),\n-    ItemSubsts(ty::ItemSubsts<'tcx>),\n-    Adjustment(ty::adjustment::Adjustment<'tcx>),\n-}\n-\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    pub fn encode_body(&mut self, body: hir::BodyId) -> Lazy<Ast<'tcx>> {\n-        let body = self.tcx.map.body(body);\n-\n-        let mut id_visitor = IdRangeComputingVisitor::new(&self.tcx.map);\n-        id_visitor.visit_body(body);\n+    pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n+        let body = self.tcx.map.body(body_id);\n+        let lazy_body = self.lazy(body);\n \n-        let body_pos = self.position();\n-        body.encode(self).unwrap();\n-\n-        let tables_pos = self.position();\n-        let tables_count = {\n-            let mut visitor = SideTableEncodingIdVisitor {\n-                ecx: self,\n-                count: 0,\n-            };\n-            visitor.visit_body(body);\n-            visitor.count\n-        };\n+        let tables = self.tcx.body_tables(body_id);\n+        let lazy_tables = self.lazy(tables);\n \n         let nested_pos = self.position();\n         let nested_count = {\n@@ -76,44 +48,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n \n         self.lazy(&Ast {\n-            id_range: id_visitor.result(),\n-            body: Lazy::with_position(body_pos),\n-            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count),\n+            body: lazy_body,\n+            tables: lazy_tables,\n             nested_bodies: LazySeq::with_position_and_length(nested_pos, nested_count),\n             rvalue_promotable_to_static: rvalue_promotable_to_static\n         })\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    count: usize,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.ecx.tcx.map)\n-    }\n-\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        debug!(\"Encoding side tables for id {}\", id);\n-\n-        let tcx = self.ecx.tcx;\n-        let mut encode = |entry: Option<TableEntry>| {\n-            if let Some(entry) = entry {\n-                (id, entry).encode(self.ecx).unwrap();\n-                self.count += 1;\n-            }\n-        };\n-\n-        encode(tcx.tables().type_relative_path_defs.get(&id).cloned()\n-                  .map(TableEntry::TypeRelativeDef));\n-        encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n-        encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n-        encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n-    }\n-}\n-\n struct NestedBodyEncodingVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n     count: usize,\n@@ -132,41 +74,3 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedBodyEncodingVisitor<'a, 'b, 'tcx> {\n         self.visit_body(body);\n     }\n }\n-\n-/// Decodes an item's body from its AST in the cdata's metadata and adds it to the\n-/// ast-map.\n-pub fn decode_body<'a, 'tcx>(cdata: &CrateMetadata,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             def_id: DefId,\n-                             ast: Ast<'tcx>)\n-                             -> &'tcx hir::Body {\n-    debug!(\"> Decoding inlined fn: {}\", tcx.item_path_str(def_id));\n-\n-    let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n-    let start = tcx.sess.reserve_node_ids(cnt);\n-    let id_ranges = [ast.id_range,\n-                     IdRange {\n-                         min: start,\n-                         max: ast::NodeId::new(start.as_usize() + cnt),\n-                     }];\n-\n-    for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n-        match entry {\n-            TableEntry::TypeRelativeDef(def) => {\n-                tcx.tables.borrow_mut().type_relative_path_defs.insert(id, def);\n-            }\n-            TableEntry::NodeType(ty) => {\n-                tcx.tables.borrow_mut().node_types.insert(id, ty);\n-            }\n-            TableEntry::ItemSubsts(item_substs) => {\n-                tcx.tables.borrow_mut().item_substs.insert(id, item_substs);\n-            }\n-            TableEntry::Adjustment(adj) => {\n-                tcx.tables.borrow_mut().adjustments.insert(id, adj);\n-            }\n-        }\n-    }\n-\n-    let body = ast.body.decode((cdata, tcx, id_ranges));\n-    ast_map::map_decoded_body(&tcx.map, def_id, body, tcx.sess.next_node_id())\n-}"}, {"sha": "8f7b9c24cbf8a5c4adc8de1a62f3f2b00c40def1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -302,10 +302,13 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode(&metadata)\n         });\n \n+        let exported_symbols = crate_root.exported_symbols.decode(&metadata).collect();\n+\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n             def_path_table: def_path_table,\n+            exported_symbols: exported_symbols,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),"}, {"sha": "761041ad7198aa6cdd3d146d3199280bc6d5998b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -80,6 +80,8 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: DefPathTable,\n \n+    pub exported_symbols: FxHashSet<DefIndex>,\n+\n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n \n@@ -97,7 +99,6 @@ pub struct CStore {\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n-    pub inlined_item_cache: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n@@ -112,7 +113,6 @@ impl CStore {\n             statically_included_foreign_items: RefCell::new(FxHashSet()),\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n-            inlined_item_cache: RefCell::new(FxHashMap()),\n         }\n     }\n "}, {"sha": "7cd26df0246eab36eca935717958451e8f723384", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -226,6 +226,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_is_statically_included_foreign_item(def_id)\n     }\n \n+    fn is_exported_symbol(&self, def_id: DefId) -> bool {\n+        self.get_crate_data(def_id.krate).exported_symbols.contains(&def_id.index)\n+    }\n+\n     fn is_dllimport_foreign_item(&self, def_id: DefId) -> bool {\n         if def_id.krate == LOCAL_CRATE {\n             self.dllimport_foreign_items.borrow().contains(&def_id.index)\n@@ -434,27 +438,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                                def_id: DefId)\n                                -> Option<&'tcx hir::Body>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-\n-        if let Some(&cached) = self.inlined_item_cache.borrow().get(&def_id) {\n-            return cached.map(|root_id| {\n-                // Already inline\n-                debug!(\"maybe_get_item_body({}): already inline\", tcx.item_path_str(def_id));\n-                tcx.map.expect_inlined_body(root_id)\n-            });\n+        if let Some(cached) = tcx.map.get_inlined_body(def_id) {\n+            return Some(cached);\n         }\n \n+        self.dep_graph.read(DepNode::MetaData(def_id));\n         debug!(\"maybe_get_item_body({}): inlining item\", tcx.item_path_str(def_id));\n \n-        let inlined = self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index);\n-\n-        self.inlined_item_cache.borrow_mut().insert(def_id, inlined.map(|body| {\n-            let root_id = tcx.map.get_parent_node(body.value.id);\n-            assert_eq!(tcx.map.get_parent_node(root_id), root_id);\n-            root_id\n-        }));\n-\n-        inlined\n+        self.get_crate_data(def_id.krate).maybe_get_item_body(tcx, def_id.index)\n     }\n \n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n@@ -479,11 +470,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).is_item_mir_available(def.index)\n     }\n \n-    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        def.is_local() || self.get_crate_data(def.krate).can_have_local_instance(tcx, def.index)\n-    }\n-\n     fn crates(&self) -> Vec<CrateNum>\n     {\n         let mut result = vec![];"}, {"sha": "4abdee345c2985011e4a2d9e87954652ef95d47f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 87, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -10,13 +10,11 @@\n \n // Decoding metadata from a single crate's metadata\n \n-use astencode::decode_body;\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n-use rustc::hir::intravisit::IdRange;\n \n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n@@ -40,7 +38,7 @@ use std::u32;\n \n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n-use syntax::ast::{self, NodeId};\n+use syntax::ast;\n use syntax::codemap;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use rustc_i128::{u128, i128};\n@@ -50,8 +48,6 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'a Session>,\n     tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n-    from_id_range: IdRange,\n-    to_id_range: IdRange,\n \n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n@@ -67,18 +63,12 @@ pub trait Metadata<'a, 'tcx>: Copy {\n     fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n-        let id_range = IdRange {\n-            min: NodeId::from_u32(u32::MIN),\n-            max: NodeId::from_u32(u32::MAX),\n-        };\n         let tcx = self.tcx();\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n             cdata: self.cdata(),\n             sess: self.sess().or(tcx.map(|tcx| tcx.sess)),\n             tcx: tcx,\n-            from_id_range: id_range,\n-            to_id_range: id_range,\n             last_filemap_index: 0,\n             lazy_state: LazyState::NoNode,\n         }\n@@ -128,26 +118,6 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>\n     }\n }\n \n-// HACK(eddyb) Only used by astencode to customize the from/to IdRange's.\n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>, [IdRange; 2]) {\n-    fn raw_bytes(self) -> &'a [u8] {\n-        self.0.raw_bytes()\n-    }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self.0)\n-    }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n-        Some(self.1)\n-    }\n-\n-    fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n-        let mut dcx = (self.0, self.1).decoder(pos);\n-        dcx.from_id_range = self.2[0];\n-        dcx.to_id_range = self.2[1];\n-        dcx\n-    }\n-}\n-\n impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n         let mut dcx = meta.decoder(self.position);\n@@ -256,28 +226,6 @@ impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n-        let id = u32::decode(self)?;\n-\n-        // from_id_range should be non-empty\n-        assert!(!self.from_id_range.empty());\n-        // Make sure that translating the NodeId will actually yield a\n-        // meaningful result\n-        if !self.from_id_range.contains(NodeId::from_u32(id)) {\n-            bug!(\"NodeId::decode: {} out of DecodeContext range ({:?} -> {:?})\",\n-                 id,\n-                 self.from_id_range,\n-                 self.to_id_range);\n-        }\n-\n-        // Use wrapping arithmetic because otherwise it introduces control flow.\n-        // Maybe we should just have the control flow? -- aatch\n-        Ok(NodeId::from_u32(id.wrapping_sub(self.from_id_range.min.as_u32())\n-            .wrapping_add(self.to_id_range.min.as_u32())))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<CrateNum> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n         let cnum = CrateNum::from_u32(u32::decode(self)?);\n@@ -497,14 +445,6 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Closure(_) => return None,\n         })\n     }\n-    fn is_const_fn(&self, meta: &CrateMetadata) -> bool {\n-        let constness = match *self {\n-            EntryKind::Method(data) => data.decode(meta).fn_data.constness,\n-            EntryKind::Fn(data) => data.decode(meta).constness,\n-            _ => hir::Constness::NotConst,\n-        };\n-        constness == hir::Constness::Const\n-    }\n }\n \n impl<'a, 'tcx> CrateMetadata {\n@@ -829,7 +769,14 @@ impl<'a, 'tcx> CrateMetadata {\n                                -> Option<&'tcx hir::Body> {\n         if self.is_proc_macro(id) { return None; }\n         self.entry(id).ast.map(|ast| {\n-            decode_body(self, tcx, self.local_def_id(id), ast.decode(self))\n+            let def_id = self.local_def_id(id);\n+            let ast = ast.decode(self);\n+\n+            let tables = ast.tables.decode((self, tcx));\n+            tcx.tables.borrow_mut().insert(def_id, tcx.alloc_tables(tables));\n+\n+            let body = ast.body.decode((self, tcx));\n+            tcx.map.intern_inlined_body(def_id, body)\n         })\n     }\n \n@@ -849,29 +796,6 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn can_have_local_instance(&self,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   id: DefIndex) -> bool {\n-        self.maybe_entry(id).map_or(false, |item| {\n-            let item = item.decode(self);\n-            // if we don't have a MIR, then this item was never meant to be locally instantiated\n-            // or we have a bug in the metadata serialization\n-            item.mir.is_some() && (\n-                // items with generics always can have local instances if monomorphized\n-                item.generics.map_or(false, |generics| {\n-                    let generics = generics.decode((self, tcx));\n-                    generics.parent_types != 0 || !generics.types.is_empty()\n-                }) ||\n-                match item.kind {\n-                    EntryKind::Closure(_) => true,\n-                    _ => false,\n-                } ||\n-                item.kind.is_const_fn(self) ||\n-                attr::requests_inline(&self.get_attributes(&item))\n-            )\n-        })\n-    }\n-\n     pub fn maybe_get_item_mir(&self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               id: DefIndex)\n@@ -1076,7 +1000,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_exported_symbols(&self) -> Vec<DefId> {\n-        self.root.exported_symbols.decode(self).map(|index| self.local_def_id(index)).collect()\n+        self.exported_symbols.iter().map(|&index| self.local_def_id(index)).collect()\n     }\n \n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n@@ -1088,7 +1012,12 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn is_const_fn(&self, id: DefIndex) -> bool {\n-        self.entry(id).kind.is_const_fn(self)\n+        let constness = match self.entry(id).kind {\n+            EntryKind::Method(data) => data.decode(self).fn_data.constness,\n+            EntryKind::Fn(data) => data.decode(self).constness,\n+            _ => hir::Constness::NotConst,\n+        };\n+        constness == hir::Constness::Const\n     }\n \n     pub fn is_foreign_item(&self, id: DefIndex) -> bool {"}, {"sha": "7de768b7b9049447c6ed9995545d7a73ef918d79", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1037,7 +1037,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables().closure_tys[&def_id]),\n+            ty: self.lazy(&tcx.closure_tys.borrow()[&def_id]),\n         };\n \n         Entry {"}, {"sha": "484e0df658303a881d2c0dcfc1e6924002b14e6c", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,13 +15,12 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(box_patterns)]\n #![feature(conservative_impl_trait)]\n #![feature(core_intrinsics)]\n #![feature(proc_macro_internals)]\n-#![feature(proc_macro_lib)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "b071834122367421000e107fd2e06fd2324baba9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -26,6 +26,7 @@ use build::{BlockAnd, BlockAndExtension, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n+use rustc_data_structures::fx::FxHashSet;\n \n use std::mem;\n \n@@ -93,11 +94,30 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Range { .. } |\n-            PatternKind::Variant { .. } |\n             PatternKind::Slice { .. } => {\n                 Err(match_pair)\n             }\n \n+            PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n+                let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n+                    i == variant_index || {\n+                        let mut visited = FxHashSet::default();\n+                        let node_set = v.uninhabited_from(&mut visited,\n+                                                          self.hir.tcx(),\n+                                                          substs,\n+                                                          adt_def.adt_kind());\n+                        !node_set.is_empty()\n+                    }\n+                });\n+                if irrefutable {\n+                    let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n+                    candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n+                    Ok(())\n+                } else {\n+                    Err(match_pair)\n+                }\n+            },\n+\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n                 self.prefix_slice_suffix(&mut candidate.match_pairs,\n                                          &match_pair.lvalue,"}, {"sha": "8b4a013bad0a369be8bbc4c7b488bf1d3122dcae", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// It is a bug to call this with a simplifyable pattern.\n     pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n-            PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n+            PatternKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Switch {\n@@ -451,7 +451,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n             (&TestKind::Switch { adt_def: tested_adt_def, .. },\n-             &PatternKind::Variant { adt_def, variant_index, ref subpatterns }) => {\n+             &PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. }) => {\n                 assert_eq!(adt_def, tested_adt_def);\n                 let new_candidate =\n                     self.candidate_after_variant_switch(match_pair_index,"}, {"sha": "7347841a5f1ef396ecd473c467601891cb4cda88", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -169,7 +169,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.map.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = tcx.tables().upvar_capture(ty::UpvarId {\n+            let by_ref = hir.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n             }).map_or(false, |capture| match capture {\n@@ -195,13 +195,12 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n }\n \n pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                       item_id: ast::NodeId,\n                                        body_id: hir::BodyId)\n                                        -> Mir<'tcx> {\n     let tcx = hir.tcx();\n     let ast_expr = &tcx.map.body(body_id).value;\n-    let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n-    let span = tcx.map.span(item_id);\n+    let ty = hir.tables().expr_ty_adjusted(ast_expr);\n+    let span = tcx.map.span(tcx.map.body_owner(body_id));\n     let mut builder = Builder::new(hir, span, 0, ty);\n \n     let extent = tcx.region_maps.temporary_scope(ast_expr.id)\n@@ -306,7 +305,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let lvalue = Lvalue::Local(Local::new(index + 1));\n \n             if let Some(pattern) = pattern {\n-                let pattern = Pattern::from_hir(self.hir.tcx(), pattern);\n+                let pattern = Pattern::from_hir(self.hir.tcx(), self.hir.tables(), pattern);\n                 scope = self.declare_bindings(scope, ast_body.span, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }"}, {"sha": "4b3d62fd6d6efe3042a68e32dd8ff71599b3c273", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -61,7 +61,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         let remainder_extent =\n                             cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n \n-                        let pattern = Pattern::from_hir(cx.tcx, &local.pat);\n+                        let pattern = Pattern::from_hir(cx.tcx, cx.tables(), &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n@@ -82,7 +82,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tcx.tables().node_id_to_type(block.id);\n+    let block_ty = cx.tables().node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "fe10fb57c35e888caec43b8fe9cd975db3d7bc0f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -17,7 +17,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval as const_eval;\n+use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -33,7 +33,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n-        let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n+        let adj = cx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n                expr,\n@@ -80,13 +80,13 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     let i = i as u32;\n                     let adjusted_ty =\n                         expr.ty.adjust_for_autoderef(cx.tcx, self.id, self.span, i, |mc| {\n-                            cx.tcx.tables().method_map.get(&mc).map(|m| m.ty)\n+                            cx.tables().method_map.get(&mc).map(|m| m.ty)\n                         });\n                     debug!(\"make_mirror: autoderef #{}, adjusted_ty={:?}\",\n                            i,\n                            adjusted_ty);\n                     let method_key = ty::MethodCall::autoderef(self.id, i);\n-                    let meth_ty = cx.tcx.tables().method_map.get(&method_key).map(|m| m.ty);\n+                    let meth_ty = cx.tables().method_map.get(&method_key).map(|m| m.ty);\n                     let kind = if let Some(meth_ty) = meth_ty {\n                         debug!(\"make_mirror: overloaded autoderef (meth_ty={:?})\", meth_ty);\n \n@@ -217,7 +217,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n-    let expr_ty = cx.tcx.tables().expr_ty(expr);\n+    let expr_ty = cx.tables().expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     let kind = match expr.node {\n@@ -236,7 +236,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprCall(ref fun, ref args) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 // The callee is something implementing Fn, FnMut, or FnOnce.\n                 // Find the actual method implementation being called and\n                 // build the appropriate UFCS call expression with the\n@@ -285,9 +285,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx\n-                        .tables()\n-                        .node_id_item_substs(fun.id)\n+                    let substs = cx.tables().node_id_item_substs(fun.id)\n                         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n                     let field_refs = args.iter()\n                         .enumerate()\n@@ -307,7 +305,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tcx.tables().node_id_to_type(fun.id),\n+                        ty: cx.tables().node_id_to_type(fun.id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -337,7 +335,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -361,7 +359,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 let pass_args = if op.node.is_by_value() {\n                     PassArgs::ByValue\n                 } else {\n@@ -421,7 +419,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprIndex(ref lhs, ref index) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n                                   ty::MethodCall::expr(expr.id),\n@@ -437,7 +435,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnDeref, ref arg) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n                                   ty::MethodCall::expr(expr.id),\n@@ -450,7 +448,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNot, ref arg) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx,\n                                     expr,\n                                     ty::MethodCall::expr(expr.id),\n@@ -466,7 +464,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprUnary(hir::UnOp::UnNeg, ref arg) => {\n-            if cx.tcx.tables().is_method_call(expr.id) {\n+            if cx.tables().is_method_call(expr.id) {\n                 overloaded_operator(cx,\n                                     expr,\n                                     ty::MethodCall::expr(expr.id),\n@@ -500,8 +498,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n                                         base: base.to_ref(),\n-                                        field_types: cx.tcx.tables().fru_field_types[&expr.id]\n-                                            .clone(),\n+                                        field_types: cx.tables().fru_field_types[&expr.id].clone(),\n                                     }\n                                 }),\n                             }\n@@ -541,7 +538,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprClosure(..) => {\n-            let closure_ty = cx.tcx.tables().expr_ty(expr);\n+            let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n                 ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n@@ -562,7 +559,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprPath(ref qpath) => {\n-            let def = cx.tcx.tables().qpath_def(qpath, expr.id);\n+            let def = cx.tables().qpath_def(qpath, expr.id);\n             convert_path_expr(cx, expr, def)\n         }\n \n@@ -575,17 +572,21 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         // Now comes the rote stuff:\n-        hir::ExprRepeat(ref v, c) => {\n-            let c = &cx.tcx.map.body(c).value;\n+        hir::ExprRepeat(ref v, count) => {\n+            let tcx = cx.tcx.global_tcx();\n+            let c = &cx.tcx.map.body(count).value;\n+            let count = match ConstContext::new(tcx, count).eval(c, EvalHint::ExprTypeChecked) {\n+                Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n+                Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                Err(s) => fatal_const_eval_err(tcx, &s, c.span, \"expression\")\n+            };\n+\n             ExprKind::Repeat {\n                 value: v.to_ref(),\n                 count: TypedConstVal {\n-                    ty: cx.tcx.tables().expr_ty(c),\n+                    ty: cx.tcx.types.usize,\n                     span: c.span,\n-                    value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n-                        ConstVal::Integral(ConstInt::Usize(u)) => u,\n-                        other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n-                    },\n+                    value: count\n                 }\n             }\n         }\n@@ -627,7 +628,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n         hir::ExprField(ref source, name) => {\n-            let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n+            let index = match cx.tables().expr_ty_adjusted(source).sty {\n                 ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n@@ -679,7 +680,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n-    let callee = cx.tcx.tables().method_map[&method_call];\n+    let callee = cx.tables().method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -703,7 +704,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n \n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, p)).collect(),\n+        patterns: arm.pats.iter().map(|p| Pattern::from_hir(cx.tcx, cx.tables(), p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }\n@@ -713,9 +714,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tcx\n-        .tables()\n-        .node_id_item_substs(expr.id)\n+    let substs = cx.tables().node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n@@ -728,7 +727,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n-            match cx.tcx.tables().node_id_to_type(expr.id).sty {\n+            match cx.tables().node_id_to_type(expr.id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::TyAdt(adt_def, substs) => {\n@@ -776,7 +775,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                    id_var,\n                    index,\n                    closure_expr_id);\n-            let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n+            let var_ty = cx.tables().node_id_to_type(id_var);\n \n             let body_id = match cx.tcx.map.find(closure_expr_id) {\n                 Some(map::NodeExpr(expr)) => {\n@@ -793,7 +792,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tcx.tables().node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -869,7 +868,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tcx.tables().upvar_capture(upvar_id) {\n+            let upvar_capture = match cx.tables().upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n                     span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n@@ -948,7 +947,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n             argrefs.extend(args.iter()\n                 .map(|arg| {\n-                    let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n+                    let arg_ty = cx.tables().expr_ty_adjusted(arg);\n                     let adjusted_ty = cx.tcx.mk_ref(region,\n                                                     ty::TypeAndMut {\n                                                         ty: arg_ty,\n@@ -990,7 +989,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n     // to find the type &T of the content returned by the method;\n-    let ref_ty = cx.tcx.tables().method_map[&method_call].ty.fn_ret();\n+    let ref_ty = cx.tables().method_map[&method_call].ty.fn_ret();\n     let ref_ty = cx.tcx.no_late_bound_regions(&ref_ty).unwrap();\n     // callees always have all late-bound regions fully instantiated,\n \n@@ -1019,9 +1018,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tcx.tables().upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tcx.tables().node_id_to_type(id_var);\n+    let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "4b553a71b83259df57478b4a33273efe42a83dfa", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -18,9 +18,8 @@ use hair::*;\n use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval as const_eval;\n+use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n@@ -52,17 +51,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Promoted(..) => bug!(),\n         };\n \n-        let src_node_id = src.item_id();\n-\n-        // We are going to be accessing various tables\n-        // generated by TypeckItemBody; we also assume\n-        // that the body passes type check. These tables\n-        // are not individually tracked, so just register\n-        // a read here.\n-        let src_def_id = infcx.tcx.map.local_def_id(src_node_id);\n-        infcx.tcx.dep_graph.read(DepNode::TypeckItemBody(src_def_id));\n-\n-        let attrs = infcx.tcx.map.attrs(src_node_id);\n+        let attrs = infcx.tcx.map.attrs(src.item_id());\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -128,7 +117,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value { value: const_eval::eval_const_expr(self.tcx.global_tcx(), e) }\n+        let tcx = self.tcx.global_tcx();\n+        match ConstContext::with_tables(tcx, self.tables()).eval(e, EvalHint::ExprTypeChecked) {\n+            Ok(value) => Literal::Value { value: value },\n+            Err(s) => fatal_const_eval_err(tcx, &s, e.span, \"expression\")\n+        }\n     }\n \n     pub fn trait_method(&mut self,\n@@ -177,6 +170,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n+    pub fn tables(&self) -> &'a ty::Tables<'gcx> {\n+        self.infcx.tables.expect_interned()\n+    }\n+\n     pub fn check_overflow(&self) -> bool {\n         self.check_overflow\n     }"}, {"sha": "e7493850aa7cdc4dad3cd020d2c76c7c5c4e0e47", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -17,7 +17,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![crate_name = \"rustc_mir\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n \n #![feature(associated_consts)]"}, {"sha": "453c3e43b6b86c6e7955fafb153ea11384c71399", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 48, "deletions": 153, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -18,19 +18,18 @@\n \n use build;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n use rustc::mir::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n-use rustc::infer::InferCtxtBuilder;\n+use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::hir;\n-use rustc::hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -80,34 +79,50 @@ struct BuildMir<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-/// Helper type of a temporary returned by BuildMir::cx(...).\n-/// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Cx<'b, 'gcx, 'tcx>).\n-struct CxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    src: MirSource,\n-    def_id: DefId,\n-    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>\n-}\n+fn build<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                         body_id: hir::BodyId)\n+                         -> (Mir<'tcx>, MirSource) {\n+    let tcx = infcx.tcx.global_tcx();\n \n-impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n-    fn cx<'b>(&'b mut self, src: MirSource) -> CxBuilder<'b, 'gcx, 'tcx> {\n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n-        let def_id = self.tcx.map.local_def_id(src.item_id());\n-        CxBuilder {\n-            src: src,\n-            infcx: self.tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable),\n-            def_id: def_id\n-        }\n+    let item_id = tcx.map.body_owner(body_id);\n+    let src = MirSource::from_node(tcx, item_id);\n+    let cx = Cx::new(infcx, src);\n+    if let MirSource::Fn(id) = src {\n+        // fetch the fully liberated fn signature (that is, all bound\n+        // types/lifetimes replaced)\n+        let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+\n+        let ty = tcx.item_type(tcx.map.local_def_id(id));\n+        let (abi, implicit_argument) = if let ty::TyClosure(..) = ty.sty {\n+            (Abi::Rust, Some((closure_self_ty(tcx, id, body_id), None)))\n+        } else {\n+            (ty.fn_abi(), None)\n+        };\n+\n+        let body = tcx.map.body(body_id);\n+        let explicit_arguments =\n+            body.arguments\n+                .iter()\n+                .enumerate()\n+                .map(|(index, arg)| {\n+                    (fn_sig.inputs()[index], Some(&*arg.pat))\n+                });\n+\n+        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+        (build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body), src)\n+    } else {\n+        (build::construct_const(cx, body_id), src)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n-    fn build<F>(&'tcx mut self, f: F)\n-        where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> Mir<'tcx>\n-    {\n-        let (src, def_id) = (self.src, self.def_id);\n-        self.infcx.enter(|infcx| {\n-            let mut mir = f(Cx::new(&infcx, src));\n+impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+            let (mut mir, src) = build(&infcx, body_id);\n \n             // Convert the Mir to global types.\n             let tcx = infcx.tcx.global_tcx();\n@@ -117,152 +132,32 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n             };\n             globalizer.visit_mir(&mut mir);\n             let mir = unsafe {\n-                mem::transmute::<Mir, Mir<'gcx>>(mir)\n+                mem::transmute::<Mir, Mir<'tcx>>(mir)\n             };\n \n             pretty::dump_mir(tcx, \"mir_map\", &0, src, &mir);\n \n             let mir = tcx.alloc_mir(mir);\n+            let def_id = tcx.map.local_def_id(src.item_id());\n             assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n         });\n-    }\n-}\n-\n-impl<'a, 'gcx> BuildMir<'a, 'gcx> {\n-    fn build_const_integer(&mut self, body: hir::BodyId) {\n-        let body = self.tcx.map.body(body);\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        // Type-checking should not let closures get\n-        // this far in an integer constant position.\n-        if let hir::ExprClosure(..) = body.value.node {\n-            return;\n-        }\n-        self.cx(MirSource::Const(body.value.id)).build(|cx| {\n-            build::construct_const(cx, body.value.id, body.id())\n-        });\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n-    }\n-\n-    // Const and static items.\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n-            hir::ItemConst(_, expr) => {\n-                self.cx(MirSource::Const(item.id)).build(|cx| {\n-                    build::construct_const(cx, item.id, expr)\n-                });\n-            }\n-            hir::ItemStatic(_, m, expr) => {\n-                self.cx(MirSource::Static(item.id, m)).build(|cx| {\n-                    build::construct_const(cx, item.id, expr)\n-                });\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    // Trait associated const defaults.\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(expr)) = item.node {\n-            self.cx(MirSource::Const(item.id)).build(|cx| {\n-                build::construct_const(cx, item.id, expr)\n-            });\n-        }\n-        intravisit::walk_trait_item(self, item);\n-    }\n-\n-    // Impl associated const.\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, expr) = item.node {\n-            self.cx(MirSource::Const(item.id)).build(|cx| {\n-                build::construct_const(cx, item.id, expr)\n-            });\n-        }\n-        intravisit::walk_impl_item(self, item);\n-    }\n-\n-    // Repeat counts, i.e. [expr; constant].\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprRepeat(_, count) = expr.node {\n-            self.build_const_integer(count);\n-        }\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    // Array lengths, i.e. [T; constant].\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyArray(_, length) = ty.node {\n-            self.build_const_integer(length);\n-        }\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n-    // Enum variant discriminant values.\n-    fn visit_variant(&mut self, v: &'tcx hir::Variant,\n-                     g: &'tcx hir::Generics, item_id: ast::NodeId) {\n-        if let Some(expr) = v.node.disr_expr {\n-            self.build_const_integer(expr);\n-        }\n-        intravisit::walk_variant(self, v, g, item_id);\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fk: FnKind<'tcx>,\n-                decl: &'tcx hir::FnDecl,\n-                body_id: hir::BodyId,\n-                span: Span,\n-                id: ast::NodeId) {\n-        // fetch the fully liberated fn signature (that is, all bound\n-        // types/lifetimes replaced)\n-        let fn_sig = match self.tcx.tables().liberated_fn_sigs.get(&id) {\n-            Some(f) => f.clone(),\n-            None => {\n-                span_bug!(span, \"no liberated fn sig for {:?}\", id);\n-            }\n-        };\n-\n-        let (abi, implicit_argument) = if let FnKind::Closure(..) = fk {\n-            (Abi::Rust, Some((closure_self_ty(self.tcx, id, body_id.node_id), None)))\n-        } else {\n-            let def_id = self.tcx.map.local_def_id(id);\n-            (self.tcx.item_type(def_id).fn_abi(), None)\n-        };\n \n         let body = self.tcx.map.body(body_id);\n-        let explicit_arguments =\n-            body.arguments\n-                .iter()\n-                .enumerate()\n-                .map(|(index, arg)| {\n-                    (fn_sig.inputs()[index], Some(&*arg.pat))\n-                });\n-\n-        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-        self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n-        });\n-\n-        intravisit::walk_fn(self, fk, decl, body_id, span, id);\n+        self.visit_body(body);\n     }\n }\n \n fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n-                             body_id: ast::NodeId)\n+                             body_id: hir::BodyId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.tables().node_id_to_type(closure_expr_id);\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be\n     // &self or &mut self and hence will have a bound region with\n     // number 0, hokey.\n     let region = ty::Region::ReFree(ty::FreeRegion {\n-        scope: tcx.region_maps.item_extent(body_id),\n+        scope: tcx.region_maps.item_extent(body_id.node_id),\n         bound_region: ty::BoundRegion::BrAnon(0),\n     });\n     let region = tcx.mk_region(region);"}, {"sha": "57cf4b1e8b02bf06edaa1cb49310b8e4c5289d40", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 80, "deletions": 91, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -66,6 +66,7 @@ impl TempState {\n /// A \"root candidate\" for promotion, which will become the\n /// returned value in a promoted MIR, unless it's a subset\n /// of a larger candidate.\n+#[derive(Debug)]\n pub enum Candidate {\n     /// Borrow of a constant temporary.\n     Ref(Location),\n@@ -96,11 +97,8 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n             // Ignore drops, if the temp gets promoted,\n             // then it's constant and thus drop is noop.\n             // Storage live ranges are also irrelevant.\n-            match context {\n-                LvalueContext::Drop |\n-                LvalueContext::StorageLive |\n-                LvalueContext::StorageDead => return,\n-                _ => {}\n+            if context.is_drop() || context.is_storage_marker() {\n+                return;\n             }\n \n             let temp = &mut self.temps[index];\n@@ -117,15 +115,17 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n                     _ => { /* mark as unpromotable below */ }\n                 }\n             } else if let TempState::Defined { ref mut uses, .. } = *temp {\n-                match context {\n-                    LvalueContext::Borrow {..} |\n-                    LvalueContext::Consume |\n-                    LvalueContext::Inspect => {\n-                        *uses += 1;\n-                        return;\n-                    }\n-                    _ => { /* mark as unpromotable below */ }\n+                // We always allow borrows, even mutable ones, as we need\n+                // to promote mutable borrows of some ZSTs e.g. `&mut []`.\n+                let allowed_use = match context {\n+                    LvalueContext::Borrow {..} => true,\n+                    _ => context.is_nonmutating_use()\n+                };\n+                if allowed_use {\n+                    *uses += 1;\n+                    return;\n                 }\n+                /* mark as unpromotable below */\n             }\n             *temp = TempState::Unpromotable;\n         }\n@@ -190,15 +190,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     /// promoted MIR, recursing through temps.\n     fn promote_temp(&mut self, temp: Local) -> Local {\n         let old_keep_original = self.keep_original;\n-        let (bb, stmt_idx) = match self.temps[temp] {\n-            TempState::Defined {\n-                location: Location { block, statement_index },\n-                uses\n-            } if uses > 0 => {\n+        let loc = match self.temps[temp] {\n+            TempState::Defined { location, uses } if uses > 0 => {\n                 if uses > 1 {\n                     self.keep_original = true;\n                 }\n-                (block, statement_index)\n+                location\n             }\n             state =>  {\n                 span_bug!(self.promoted.span, \"{:?} not promotable: {:?}\",\n@@ -209,91 +206,82 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.temps[temp] = TempState::PromotedOut;\n         }\n \n-        let no_stmts = self.source[bb].statements.len();\n+        let no_stmts = self.source[loc.block].statements.len();\n+        let new_temp = self.promoted.local_decls.push(\n+            LocalDecl::new_temp(self.source.local_decls[temp].ty));\n+\n+        debug!(\"promote({:?} @ {:?}/{:?}, {:?})\",\n+               temp, loc, no_stmts, self.keep_original);\n \n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n-        let (mut rvalue, mut call) = (None, None);\n-        let source_info = if stmt_idx < no_stmts {\n-            let statement = &mut self.source[bb].statements[stmt_idx];\n-            let rhs = match statement.kind {\n-                StatementKind::Assign(_, ref mut rhs) => rhs,\n-                _ => {\n-                    span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n-                              statement);\n-                }\n+        if loc.statement_index < no_stmts {\n+            let (mut rvalue, source_info) = {\n+                let statement = &mut self.source[loc.block].statements[loc.statement_index];\n+                let rhs = match statement.kind {\n+                    StatementKind::Assign(_, ref mut rhs) => rhs,\n+                    _ => {\n+                        span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n+                                  statement);\n+                    }\n+                };\n+\n+                (if self.keep_original {\n+                    rhs.clone()\n+                } else {\n+                    let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n+                    mem::replace(rhs, unit)\n+                }, statement.source_info)\n             };\n-            if self.keep_original {\n-                rvalue = Some(rhs.clone());\n-            } else {\n-                let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n-                rvalue = Some(mem::replace(rhs, unit));\n-            }\n-            statement.source_info\n-        } else if self.keep_original {\n-            let terminator = self.source[bb].terminator().clone();\n-            call = Some(terminator.kind);\n-            terminator.source_info\n+\n+            self.visit_rvalue(&mut rvalue, loc);\n+            self.assign(new_temp, rvalue, source_info.span);\n         } else {\n-            let terminator = self.source[bb].terminator_mut();\n-            let target = match terminator.kind {\n-                TerminatorKind::Call {\n-                    destination: ref mut dest @ Some(_),\n-                    ref mut cleanup, ..\n-                } => {\n-                    // No cleanup necessary.\n-                    cleanup.take();\n-\n-                    // We'll put a new destination in later.\n-                    dest.take().unwrap().1\n+            let terminator = if self.keep_original {\n+                self.source[loc.block].terminator().clone()\n+            } else {\n+                let terminator = self.source[loc.block].terminator_mut();\n+                let target = match terminator.kind {\n+                    TerminatorKind::Call { destination: Some((_, target)), .. } => target,\n+                    ref kind => {\n+                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                    }\n+                };\n+                Terminator {\n+                    source_info: terminator.source_info,\n+                    kind: mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n+                        target: target\n+                    })\n+                }\n+            };\n+\n+            match terminator.kind {\n+                TerminatorKind::Call { mut func, mut args, .. } => {\n+                    self.visit_operand(&mut func, loc);\n+                    for arg in &mut args {\n+                        self.visit_operand(arg, loc);\n+                    }\n+\n+                    let last = self.promoted.basic_blocks().last().unwrap();\n+                    let new_target = self.new_block();\n+\n+                    *self.promoted[last].terminator_mut() = Terminator {\n+                        kind: TerminatorKind::Call {\n+                            func: func,\n+                            args: args,\n+                            cleanup: None,\n+                            destination: Some((Lvalue::Local(new_temp), new_target))\n+                        },\n+                        ..terminator\n+                    };\n                 }\n                 ref kind => {\n                     span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                 }\n             };\n-            call = Some(mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n-                target: target\n-            }));\n-            terminator.source_info\n         };\n \n-        // Then, recurse for components in the Rvalue or Call.\n-        if stmt_idx < no_stmts {\n-            self.visit_rvalue(rvalue.as_mut().unwrap(), Location {\n-                block: bb,\n-                statement_index: stmt_idx\n-            });\n-        } else {\n-            self.visit_terminator_kind(bb, call.as_mut().unwrap(), Location {\n-                block: bb,\n-                statement_index: no_stmts\n-            });\n-        }\n-\n-        let new_temp = self.promoted.local_decls.push(\n-            LocalDecl::new_temp(self.source.local_decls[temp].ty));\n-\n-        // Inject the Rvalue or Call into the promoted MIR.\n-        if stmt_idx < no_stmts {\n-            self.assign(new_temp, rvalue.unwrap(), source_info.span);\n-        } else {\n-            let last = self.promoted.basic_blocks().last().unwrap();\n-            let new_target = self.new_block();\n-            let mut call = call.unwrap();\n-            match call {\n-                TerminatorKind::Call { ref mut destination, ..}  => {\n-                    *destination = Some((Lvalue::Local(new_temp), new_target));\n-                }\n-                _ => bug!()\n-            }\n-            let terminator = self.promoted[last].terminator_mut();\n-            terminator.source_info.span = source_info.span;\n-            terminator.kind = call;\n-        }\n-\n-        // Restore the old duplication state.\n         self.keep_original = old_keep_original;\n-\n         new_temp\n     }\n \n@@ -355,6 +343,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     mut temps: IndexVec<Local, TempState>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n+    debug!(\"promote_candidates({:?})\", candidates);\n     for candidate in candidates.into_iter().rev() {\n         let (span, ty) = match candidate {\n             Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {"}, {"sha": "fea27ee5c54837736cc049d957cb7b835ad10a4e", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -993,9 +993,9 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n                     Entry::Vacant(entry) => {\n                         // Guard against `const` recursion.\n                         entry.insert(Qualif::RECURSIVE);\n+                        Mode::Const\n                     }\n                 }\n-                Mode::Const\n             }\n             MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n             MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n@@ -1038,7 +1038,7 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+            tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 fulfillment_cx.register_bound(&infcx, ty,"}, {"sha": "0fabbe6678ad8810c029db2a1434d810e494eca1", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -725,7 +725,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, src.item_id());\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "8f12817511ad3bbccd6c9a90b992d67151825a1c", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -26,10 +26,9 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n-use rustc_const_eval::{ConstEvalErr, compare_lit_exprs};\n-use rustc_const_eval::{eval_const_expr_partial};\n+use rustc_const_eval::{ConstEvalErr, ConstContext};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n-use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n+use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath, BadType};\n use rustc_const_eval::ErrKind::UnresolvedPath;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_math::{ConstMathErr, Op};\n@@ -61,15 +60,18 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     promotable: bool,\n     mut_rvalue_borrows: NodeSet,\n     param_env: ty::ParameterEnvironment<'tcx>,\n+    tables: &'a ty::Tables<'tcx>,\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n-        if let Err(err) = eval_const_expr_partial(self.tcx, expr, ExprTypeChecked, None) {\n+        let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n+        if let Err(err) = const_cx.eval(expr, ExprTypeChecked) {\n             match err.kind {\n                 UnimplementedConstVal(_) => {}\n                 IndexOpFeatureGated => {}\n                 ErroneousReferencedConstant(_) => {}\n+                BadType(_) => {}\n                 _ => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            expr.id,\n@@ -111,36 +113,42 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body.node_id) {\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        match self.tcx.rvalue_promotable_to_static.borrow_mut().entry(body_id.node_id) {\n             Entry::Occupied(_) => return,\n             Entry::Vacant(entry) => {\n                 // Prevent infinite recursion on re-entry.\n                 entry.insert(false);\n             }\n         }\n \n-        let item_id = self.tcx.map.body_owner(body);\n+        let item_id = self.tcx.map.body_owner(body_id);\n \n         let outer_in_fn = self.in_fn;\n         self.in_fn = match MirSource::from_node(self.tcx, item_id) {\n             MirSource::Fn(_) => true,\n             _ => false\n         };\n \n-        let body = self.tcx.map.body(body);\n+        let outer_tables = self.tables;\n+        self.tables = self.tcx.item_tables(self.tcx.map.local_def_id(item_id));\n+\n+        let body = self.tcx.map.body(body_id);\n         if !self.in_fn {\n             self.check_const_eval(&body.value);\n         }\n \n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        let outer_param_env = mem::replace(&mut self.param_env, param_env);\n-        self.tcx.infer_ctxt(None, Some(self.param_env.clone()), Reveal::NotSpecializable)\n-            .enter(|infcx| euv::ExprUseVisitor::new(self, &infcx).consume_body(body));\n+        let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+            let param_env = infcx.parameter_environment.clone();\n+            let outer_penv = mem::replace(&mut self.param_env, param_env);\n+            euv::ExprUseVisitor::new(self, &infcx).consume_body(body);\n+            outer_penv\n+        });\n \n         self.visit_body(body);\n \n-        self.param_env = outer_param_env;\n+        self.param_env = outer_penv;\n+        self.tables = outer_tables;\n         self.in_fn = outer_in_fn;\n     }\n \n@@ -150,10 +158,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                 self.check_const_eval(lit);\n             }\n             PatKind::Range(ref start, ref end) => {\n-                self.check_const_eval(start);\n-                self.check_const_eval(end);\n-\n-                match compare_lit_exprs(self.tcx, p.span, start, end) {\n+                let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n+                match const_cx.compare_lit_exprs(p.span, start, end) {\n                     Ok(Ordering::Less) |\n                     Ok(Ordering::Equal) => {}\n                     Ok(Ordering::Greater) => {\n@@ -193,7 +199,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer = self.promotable;\n         self.promotable = true;\n \n-        let node_ty = self.tcx.tables().node_id_to_type(ex.id);\n+        let node_ty = self.tables.node_id_to_type(ex.id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -219,7 +225,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         if self.in_fn && self.promotable {\n-            match eval_const_expr_partial(self.tcx, ex, ExprTypeChecked, None) {\n+            let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n+            match const_cx.eval(ex, ExprTypeChecked) {\n                 Ok(_) => {}\n                 Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n                 Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n@@ -230,6 +237,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n                 Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n+                Err(ConstEvalErr { kind: BadType(_), .. }) => {}\n                 Err(msg) => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            ex.id,\n@@ -262,14 +270,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     match e.node {\n         hir::ExprUnary(..) |\n         hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tcx.tables().method_map.contains_key(&method_call) => {\n+        hir::ExprIndex(..) if v.tables.method_map.contains_key(&method_call) => {\n             v.promotable = false;\n         }\n         hir::ExprBox(_) => {\n             v.promotable = false;\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tcx.tables().node_id_to_type(inner.id).sty {\n+            match v.tables.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -279,7 +287,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tcx.tables().node_id_to_type(lhs.id).sty {\n+            match v.tables.node_id_to_type(lhs.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -301,7 +309,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n-            let def = v.tcx.tables().qpath_def(qpath, e.id);\n+            let def = v.tables.qpath_def(qpath, e.id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n@@ -337,7 +345,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n             let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                v.tcx.tables().qpath_def(qpath, callee.id)\n+                v.tables.qpath_def(qpath, callee.id)\n             } else {\n                 Def::Err\n             };\n@@ -359,14 +367,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let method = v.tcx.tables().method_map[&method_call];\n+            let method = v.tables.method_map[&method_call];\n             match v.tcx.associated_item(method.def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(method.def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n             }\n         }\n         hir::ExprStruct(..) => {\n-            if let ty::TyAdt(adt, ..) = v.tcx.tables().expr_ty(e).sty {\n+            if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n                     v.promotable = false;\n@@ -420,7 +428,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n     use rustc::ty::adjustment::*;\n \n-    match v.tcx.tables().adjustments.get(&e.id).map(|adj| adj.kind) {\n+    match v.tables.adjustments.get(&e.id).map(|adj| adj.kind) {\n         None |\n         Some(Adjust::NeverToAny) |\n         Some(Adjust::ReifyFnPointer) |\n@@ -429,7 +437,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n \n         Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n-                .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n+                .any(|autoderef| v.tables.is_overloaded_autoderef(e.id, autoderef)) {\n                 v.promotable = false;\n             }\n         }\n@@ -440,6 +448,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_item_likes_in_krate(DepNode::CheckConst,\n                                       &mut CheckCrateVisitor {\n                                           tcx: tcx,\n+                                          tables: &ty::Tables::empty(),\n                                           in_fn: false,\n                                           promotable: false,\n                                           mut_rvalue_borrows: NodeSet(),"}, {"sha": "143c1efed5a9382a37ec5c75a1a8781a64b5ec91", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -21,7 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(rustc_diagnostic_macros)]\n #![feature(staged_api)]"}, {"sha": "78b591a48cca5f23e02f50e4f1b06ebb4566b096", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -14,11 +14,11 @@\n use rustc::dep_graph::DepNode;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n-use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n+use rustc::ty::{self, TyCtxt};\n use rustc::traits::Reveal;\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -33,28 +33,19 @@ struct RvalueContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+        NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'tcx>,\n-                fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId,\n-                s: Span,\n-                fn_id: ast::NodeId) {\n-        // FIXME (@jroesch) change this to be an inference context\n-        let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n-        self.tcx.infer_ctxt(None, Some(param_env.clone()),\n-                            Reveal::NotSpecializable).enter(|infcx| {\n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        let body = self.tcx.map.body(body_id);\n+        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n             let mut delegate = RvalueContextDelegate {\n                 tcx: infcx.tcx,\n-                param_env: &param_env\n+                param_env: &infcx.parameter_environment\n             };\n-            let body = infcx.tcx.map.body(b);\n-            let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n-            euv.consume_body(body);\n+            euv::ExprUseVisitor::new(&mut delegate, &infcx).consume_body(body);\n         });\n-        intravisit::walk_fn(self, fk, fd, b, s, fn_id)\n+        self.visit_body(body);\n     }\n }\n "}, {"sha": "296c133115f4eadd0e7e1cc1eda194ec47b1461a", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,7 +13,7 @@\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![feature(staged_api)]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n #![allow(bad_style)]\n \n pub struct Intrinsic {"}, {"sha": "8d4e61ad8e54ec68844e5878ec9ea9a0f43e3231", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -57,7 +57,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "ef7a1f695ffb4b33c02ee3d47ef997bf72bc54ee", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -392,6 +392,7 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     curitem: DefId,\n     in_foreign: bool,\n+    tables: &'a ty::Tables<'tcx>,\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n@@ -435,6 +436,14 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.map)\n     }\n \n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.tables;\n+        self.tables = self.tcx.body_tables(body);\n+        let body = self.tcx.map.body(body);\n+        self.visit_body(body);\n+        self.tables = old_tables;\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, self.tcx.map.local_def_id(item.id));\n         intravisit::walk_item(self, item);\n@@ -445,12 +454,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method = self.tcx.tables().method_map[&method_call];\n+                let method = self.tables.method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(ref qpath, ref expr_fields, _) => {\n-                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n-                let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n+                let def = self.tables.qpath_def(qpath, expr.id);\n+                let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n@@ -511,15 +520,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pattern.id);\n-                let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n+                let def = self.tables.qpath_def(qpath, pattern.id);\n+                let adt = self.tables.pat_ty(pattern).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n             PatKind::TupleStruct(_, ref fields, ddpos) => {\n-                match self.tcx.tables().pat_ty(pattern).sty {\n+                match self.tables.pat_ty(pattern).sty {\n                     // enum fields have no privacy at this time\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let expected_len = def.struct_variant().fields.len();\n@@ -1203,6 +1212,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         curitem: DefId::local(CRATE_DEF_INDEX),\n         in_foreign: false,\n         tcx: tcx,\n+        tables: &ty::Tables::empty(),\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "5be21bc62c56cefbacdecbf2320947f0b3559695", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -168,6 +168,7 @@ impl<'a> Resolver<'a> {\n                             target: binding,\n                             source: source,\n                             result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                            type_ns_only: false,\n                         };\n                         self.add_import_directive(\n                             module_path, subclass, view_path.span, item.id, vis, expansion,\n@@ -195,10 +196,10 @@ impl<'a> Resolver<'a> {\n \n                         for source_item in source_items {\n                             let node = source_item.node;\n-                            let (module_path, ident, rename) = {\n+                            let (module_path, ident, rename, type_ns_only) = {\n                                 if node.name.name != keywords::SelfValue.name() {\n                                     let rename = node.rename.unwrap_or(node.name);\n-                                    (module_path.clone(), node.name, rename)\n+                                    (module_path.clone(), node.name, rename, false)\n                                 } else {\n                                     let ident = *module_path.last().unwrap();\n                                     if ident.name == keywords::CrateRoot.name() {\n@@ -212,13 +213,14 @@ impl<'a> Resolver<'a> {\n                                     }\n                                     let module_path = module_path.split_last().unwrap().1;\n                                     let rename = node.rename.unwrap_or(ident);\n-                                    (module_path.to_vec(), ident, rename)\n+                                    (module_path.to_vec(), ident, rename, true)\n                                 }\n                             };\n                             let subclass = SingleImport {\n                                 target: rename,\n                                 source: ident,\n                                 result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                                type_ns_only: type_ns_only,\n                             };\n                             let id = source_item.node.id;\n                             self.add_import_directive("}, {"sha": "56e8c75b859a12802bfe0f44d19fd2a98b2d6857", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 118, "deletions": 45, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(associated_consts)]\n #![feature(rustc_diagnostic_macros)]\n@@ -894,6 +894,7 @@ enum NameBindingKind<'a> {\n         binding: &'a NameBinding<'a>,\n         directive: &'a ImportDirective<'a>,\n         used: Cell<bool>,\n+        legacy_self_import: bool,\n     },\n     Ambiguity {\n         b1: &'a NameBinding<'a>,\n@@ -1346,8 +1347,13 @@ impl<'a> Resolver<'a> {\n         }\n \n         match binding.kind {\n-            NameBindingKind::Import { directive, binding, ref used } if !used.get() => {\n+            NameBindingKind::Import { directive, binding, ref used, legacy_self_import }\n+                    if !used.get() => {\n                 used.set(true);\n+                if legacy_self_import {\n+                    self.warn_legacy_self_import(directive);\n+                    return false;\n+                }\n                 self.used_imports.insert((directive.id, ns));\n                 self.add_to_glob_map(directive.id, ident);\n                 self.record_use(ident, ns, binding, span)\n@@ -2084,10 +2090,25 @@ impl<'a> Resolver<'a> {\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n             let code = source.error_code(def.is_some());\n-            let base_msg = if let Some(def) = def {\n-                format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str)\n+            let (base_msg, fallback_label) = if let Some(def) = def {\n+                (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n+                 format!(\"not a {}\", expected))\n             } else {\n-                format!(\"unresolved {} `{}`\", expected, path_str)\n+                let item_str = path[path.len() - 1];\n+                let (mod_prefix, mod_str) = if path.len() == 1 {\n+                    (format!(\"\"), format!(\"this scope\"))\n+                } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n+                    (format!(\"\"), format!(\"the crate root\"))\n+                } else {\n+                    let mod_path = &path[..path.len() - 1];\n+                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS), None) {\n+                        PathResult::Module(module) => module.def(),\n+                        _ => None,\n+                    }.map_or(format!(\"\"), |def| format!(\"{} \", def.kind_name()));\n+                    (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n+                };\n+                (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n+                 format!(\"not found in {}\", mod_str))\n             };\n             let mut err = this.session.struct_span_err_with_code(span, &base_msg, code);\n \n@@ -2170,19 +2191,13 @@ impl<'a> Resolver<'a> {\n             }\n \n             // Try Levenshtein if nothing else worked.\n-            if path.len() == 1 {\n-                if let Some(candidate) = this.lookup_typo_candidate(name, ns, is_expected) {\n-                    err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n-                    return err;\n-                }\n+            if let Some(candidate) = this.lookup_typo_candidate(path, ns, is_expected) {\n+                err.span_label(span, &format!(\"did you mean `{}`?\", candidate));\n+                return err;\n             }\n \n-            // Fallback labels.\n-            if def.is_some() {\n-                err.span_label(span, &format!(\"not a {}\", expected));\n-            } else {\n-                err.span_label(span, &format!(\"no resolution found\"));\n-            }\n+            // Fallback label.\n+            err.span_label(span, &fallback_label);\n             err\n         };\n         let report_errors = |this: &mut Self, def: Option<Def>| {\n@@ -2336,20 +2351,19 @@ impl<'a> Resolver<'a> {\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n \n-        if path.len() == 1 || global_by_default || result.base_def == Def::Err {\n-            return Some(result);\n-        }\n-\n-        let unqualified_result = {\n-            match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n-                PathResult::NonModule(path_res) => path_res.base_def,\n-                PathResult::Module(module) => module.def().unwrap(),\n-                _ => return Some(result),\n+        if path.len() > 1 && !global_by_default && result.base_def != Def::Err &&\n+           path[0].name != keywords::CrateRoot.name() && path[0].name != \"$crate\" {\n+            let unqualified_result = {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n+                    PathResult::NonModule(path_res) => path_res.base_def,\n+                    PathResult::Module(module) => module.def().unwrap(),\n+                    _ => return Some(result),\n+                }\n+            };\n+            if result.base_def == unqualified_result {\n+                let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n+                self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n             }\n-        };\n-        if result.base_def == unqualified_result && path[0].name != \"$crate\" {\n-            let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-            self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n         }\n \n         Some(result)\n@@ -2411,13 +2425,15 @@ impl<'a> Resolver<'a> {\n \n             match binding {\n                 Ok(binding) => {\n+                    let def = binding.def();\n+                    let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(def);\n                     if let Some(next_module) = binding.module() {\n                         module = Some(next_module);\n-                    } else if binding.def() == Def::Err {\n+                    } else if def == Def::Err {\n                         return PathResult::NonModule(err_path_resolution());\n-                    } else if opt_ns.is_some() && !(opt_ns == Some(MacroNS) && !is_last) {\n+                    } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n                         return PathResult::NonModule(PathResolution {\n-                            base_def: binding.def(),\n+                            base_def: def,\n                             depth: path.len() - i - 1,\n                         });\n                     } else {\n@@ -2631,21 +2647,72 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       name: Name,\n+                                       path: &[Ident],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn)\n-                                       -> Option<Name>\n+                                       -> Option<String>\n         where FilterFn: Fn(Def) -> bool\n     {\n-        // FIXME: bindings in ribs provide quite modest set of candidates,\n-        // extend it with other names in scope.\n-        let names = self.ribs[ns].iter().rev().flat_map(|rib| {\n-            rib.bindings.iter().filter_map(|(ident, def)| {\n-                if filter_fn(*def) { Some(&ident.name) } else { None }\n-            })\n-        });\n-        match find_best_match_for_name(names, &name.as_str(), None) {\n-            Some(found) if found != name => Some(found),\n+        let add_module_candidates = |module: Module, names: &mut Vec<Name>| {\n+            for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n+                if let Some(binding) = resolution.borrow().binding {\n+                    if filter_fn(binding.def()) {\n+                        names.push(ident.name);\n+                    }\n+                }\n+            }\n+        };\n+\n+        let mut names = Vec::new();\n+        let prefix_str = if path.len() == 1 {\n+            // Search in lexical scope.\n+            // Walk backwards up the ribs in scope and collect candidates.\n+            for rib in self.ribs[ns].iter().rev() {\n+                // Locals and type parameters\n+                for (ident, def) in &rib.bindings {\n+                    if filter_fn(*def) {\n+                        names.push(ident.name);\n+                    }\n+                }\n+                // Items in scope\n+                if let ModuleRibKind(module) = rib.kind {\n+                    // Items from this module\n+                    add_module_candidates(module, &mut names);\n+\n+                    if let ModuleKind::Block(..) = module.kind {\n+                        // We can see through blocks\n+                    } else {\n+                        // Items from the prelude\n+                        if let Some(prelude) = self.prelude {\n+                            if !module.no_implicit_prelude {\n+                                add_module_candidates(prelude, &mut names);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // Add primitive types to the mix\n+            if filter_fn(Def::PrimTy(TyBool)) {\n+                for (name, _) in &self.primitive_type_table.primitive_types {\n+                    names.push(*name);\n+                }\n+            }\n+            String::new()\n+        } else {\n+            // Search in module.\n+            let mod_path = &path[..path.len() - 1];\n+            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS), None) {\n+                add_module_candidates(module, &mut names);\n+            }\n+            names_to_string(mod_path) + \"::\"\n+        };\n+\n+        let name = path[path.len() - 1].name;\n+        // Make sure error reporting is deterministic.\n+        names.sort_by_key(|name| name.as_str());\n+        match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n+            Some(found) if found != name => Some(format!(\"{}{}\", prefix_str, found)),\n             _ => None,\n         }\n     }\n@@ -2982,8 +3049,8 @@ impl<'a> Resolver<'a> {\n             let participle = |binding: &NameBinding| {\n                 if binding.is_import() { \"imported\" } else { \"defined\" }\n             };\n-            let msg1 = format!(\"`{}` could resolve to the name {} here\", name, participle(b1));\n-            let msg2 = format!(\"`{}` could also resolve to the name {} here\", name, participle(b2));\n+            let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(b1));\n+            let msg2 = format!(\"`{}` could also refer to the name {} here\", name, participle(b2));\n             let note = if !lexical && b1.is_glob_import() {\n                 format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n             } else if let Def::Macro(..) = b1.def() {\n@@ -3111,6 +3178,12 @@ impl<'a> Resolver<'a> {\n         err.emit();\n         self.name_already_seen.insert(name, span);\n     }\n+\n+    fn warn_legacy_self_import(&self, directive: &'a ImportDirective<'a>) {\n+        let (id, span) = (directive.id, directive.span);\n+        let msg = \"`self` no longer imports values\".to_string();\n+        self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n+    }\n }\n \n fn is_struct_like(def: Def) -> bool {"}, {"sha": "403797b6d318ed37833fd8fa679bee9cc0223f02", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -380,8 +380,8 @@ impl<'a> Resolver<'a> {\n                 MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n                 MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n             };\n-            let msg1 = format!(\"`{}` could resolve to the macro {} here\", ident, participle);\n-            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", ident);\n+            let msg1 = format!(\"`{}` could refer to the macro {} here\", ident, participle);\n+            let msg2 = format!(\"`{}` could also refer to the macro imported here\", ident);\n             self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n                 .span_note(legacy_span, &msg1)\n                 .span_note(resolution.span, &msg2)"}, {"sha": "65e599ac6c7e8c89275942d2bbc706fbb45f64c8", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -21,6 +21,7 @@ use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::*;\n+use rustc::util::nodemap::FxHashSet;\n \n use syntax::ast::{Ident, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n@@ -40,6 +41,7 @@ pub enum ImportDirectiveSubclass<'a> {\n         target: Ident,\n         source: Ident,\n         result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n+        type_ns_only: bool,\n     },\n     GlobImport {\n         is_prelude: bool,\n@@ -295,6 +297,7 @@ impl<'a> Resolver<'a> {\n                 binding: binding,\n                 directive: directive,\n                 used: Cell::new(false),\n+                legacy_self_import: false,\n             },\n             span: directive.span,\n             vis: vis,\n@@ -502,8 +505,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         directive.imported_module.set(Some(module));\n-        let (source, target, result) = match directive.subclass {\n-            SingleImport { source, target, ref result } => (source, target, result),\n+        let (source, target, result, type_ns_only) = match directive.subclass {\n+            SingleImport { source, target, ref result, type_ns_only } =>\n+                (source, target, result, type_ns_only),\n             GlobImport { .. } => {\n                 self.resolve_glob_import(directive);\n                 return true;\n@@ -512,7 +516,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         let mut indeterminate = false;\n-        self.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = result[ns].get() {\n                 result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n             } else {\n@@ -572,8 +576,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => return None,\n         };\n \n-        let (ident, result) = match directive.subclass {\n-            SingleImport { source, ref result, .. } => (source, result),\n+        let (ident, result, type_ns_only) = match directive.subclass {\n+            SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n                 return Some(\"Cannot glob-import a module into itself.\".to_string());\n@@ -591,19 +595,36 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         let mut all_ns_err = true;\n-        self.per_ns(|this, ns| {\n+        let mut legacy_self_import = None;\n+        self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n                 if this.record_use(ident, ns, binding, directive.span) {\n                     this.resolution(module, ident, ns).borrow_mut().binding =\n                         Some(this.dummy_binding);\n                 }\n             }\n+        } else if let Ok(binding) = this.resolve_ident_in_module(module, ident, ns, false, None) {\n+            legacy_self_import = Some(directive);\n+            let binding = this.arenas.alloc_name_binding(NameBinding {\n+                kind: NameBindingKind::Import {\n+                    binding: binding,\n+                    directive: directive,\n+                    used: Cell::new(false),\n+                    legacy_self_import: true,\n+                },\n+                ..*binding\n+            });\n+            let _ = this.try_define(directive.parent, ident, ns, binding);\n         });\n \n         if all_ns_err {\n+            if let Some(directive) = legacy_self_import {\n+                self.warn_legacy_self_import(directive);\n+                return None;\n+            }\n             let mut all_ns_failed = true;\n-            self.per_ns(|this, ns| {\n+            self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                 match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n@@ -728,7 +749,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         let mut reexports = Vec::new();\n         if module as *const _ == self.graph_root as *const _ {\n-            reexports = mem::replace(&mut self.macro_exports, Vec::new());\n+            let mut exported_macro_names = FxHashSet();\n+            for export in mem::replace(&mut self.macro_exports, Vec::new()).into_iter().rev() {\n+                if exported_macro_names.insert(export.name) {\n+                    reexports.push(export);\n+                }\n+            }\n         }\n \n         for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {"}, {"sha": "4e4b35702898d064599346585161e24eae10ae44", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -99,7 +99,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n     }\n \n-    fn nest<F>(&mut self, scope_id: NodeId, f: F)\n+    fn nest_scope<F>(&mut self, scope_id: NodeId, f: F)\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n         let parent_scope = self.cur_scope;\n@@ -108,6 +108,16 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.cur_scope = parent_scope;\n     }\n \n+    fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n+        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n+    {\n+        let old_tables = self.save_ctxt.tables;\n+        let item_def_id = self.tcx.map.local_def_id(item_id);\n+        self.save_ctxt.tables = self.tcx.item_tables(item_def_id);\n+        f(self);\n+        self.save_ctxt.tables = old_tables;\n+    }\n+\n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n         let crate_root = source_file.map(|source_file| {\n@@ -337,7 +347,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = match self.tcx.tables().node_types.get(&id) {\n+                let typ = match self.save_ctxt.tables.node_types.get(&id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -378,7 +388,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n             let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n-                self.process_formals(&sig.decl.inputs, &method_data.qualname);\n+                self.nest_tables(id, |v| {\n+                    v.process_formals(&sig.decl.inputs, &method_data.qualname)\n+                });\n             }\n \n             // If the method is defined in an impl, then try and find the corresponding\n@@ -448,7 +460,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         // walk the fn body\n         if let Some(body) = body {\n-            self.nest(id, |v| v.visit_block(body));\n+            self.nest_tables(id, |v| v.nest_scope(id, |v| v.visit_block(body)));\n         }\n     }\n \n@@ -458,9 +470,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n                 self.dumper.type_ref(trait_ref_data.lower(self.tcx));\n             }\n-\n-            visit::walk_path(self, &trait_ref.path);\n         }\n+        self.process_path(trait_ref.ref_id, &trait_ref.path, Some(recorder::TypeRef));\n     }\n \n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n@@ -520,7 +531,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 self.dumper.function(fn_data.clone().lower(self.tcx));\n             }\n \n-            self.process_formals(&decl.inputs, &fn_data.qualname);\n+            self.nest_tables(item.id, |v| v.process_formals(&decl.inputs, &fn_data.qualname));\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n         }\n \n@@ -532,7 +543,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             self.visit_ty(&ret_ty);\n         }\n \n-        self.nest(item.id, |v| v.visit_block(&body));\n+        self.nest_tables(item.id, |v| v.nest_scope(item.id, |v| v.visit_block(&body)));\n     }\n \n     fn process_static_or_const_item(&mut self,\n@@ -744,8 +755,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 if !self.span.filter_generated(Some(trait_ref_data.span), item.span) {\n                     self.dumper.type_ref(trait_ref_data.clone().lower(self.tcx));\n                 }\n-\n-                visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n             }\n \n             if !self.span.filter_generated(Some(impl_data.span), item.span) {\n@@ -761,6 +770,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         if !has_self_ref {\n             self.visit_ty(&typ);\n         }\n+        if let &Some(ref trait_ref) = trait_ref {\n+            self.process_path(trait_ref.ref_id, &trait_ref.path, Some(recorder::TypeRef));\n+        }\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n             let map = &self.tcx.map;\n@@ -989,9 +1001,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     fn process_pat(&mut self, p: &'l ast::Pat) {\n         match p.node {\n-            PatKind::Struct(ref path, ref fields, _) => {\n-                visit::walk_path(self, path);\n-                let adt = match self.tcx.tables().node_id_to_type_opt(p.id) {\n+            PatKind::Struct(ref _path, ref fields, _) => {\n+                // FIXME do something with _path?\n+                let adt = match self.save_ctxt.tables.node_id_to_type_opt(p.id) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n                         visit::walk_pat(self, p);\n@@ -1032,7 +1044,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let typ = match self.tcx.tables().node_types.get(&id) {\n+            let typ = match self.save_ctxt.tables.node_types.get(&id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1286,7 +1298,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 self.process_trait(item, generics, trait_refs, methods),\n             Mod(ref m) => {\n                 self.process_mod(item);\n-                self.nest(item.id, |v| visit::walk_mod(v, m));\n+                self.nest_scope(item.id, |v| visit::walk_mod(v, m));\n             }\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n@@ -1331,23 +1343,26 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n         self.process_macro_use(t.span, t.id);\n         match t.node {\n             ast::TyKind::Path(_, ref path) => {\n-                if self.span.filter_generated(None, t.span) {\n+                if generated_code(t.span) {\n                     return;\n                 }\n \n                 if let Some(id) = self.lookup_def_id(t.id) {\n-                    let sub_span = self.span.sub_span_for_type_name(t.span);\n-                    self.dumper.type_ref(TypeRefData {\n-                        span: sub_span.expect(\"No span found for type ref\"),\n-                        ref_id: Some(id),\n-                        scope: self.cur_scope,\n-                        qualname: String::new()\n-                    }.lower(self.tcx));\n+                    if let Some(sub_span) = self.span.sub_span_for_type_name(t.span) {\n+                        self.dumper.type_ref(TypeRefData {\n+                            span: sub_span,\n+                            ref_id: Some(id),\n+                            scope: self.cur_scope,\n+                            qualname: String::new()\n+                        }.lower(self.tcx));\n+                    }\n                 }\n \n                 self.write_sub_paths_truncated(path);\n-\n-                visit::walk_path(self, path);\n+            }\n+            ast::TyKind::Array(ref element, ref length) => {\n+                self.visit_ty(element);\n+                self.nest_tables(length.id, |v| v.visit_expr(length));\n             }\n             _ => visit::walk_ty(self, t),\n         }\n@@ -1367,7 +1382,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n-                let adt = match self.tcx.tables().expr_ty_opt(&hir_expr) {\n+                let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n                         visit::walk_expr(self, ex);\n@@ -1399,7 +1414,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                         return;\n                     }\n                 };\n-                let ty = match self.tcx.tables().expr_ty_adjusted_opt(&hir_node) {\n+                let ty = match self.save_ctxt.tables.expr_ty_adjusted_opt(&hir_node) {\n                     Some(ty) => &ty.sty,\n                     None => {\n                         visit::walk_expr(self, ex);\n@@ -1427,7 +1442,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n             ast::ExprKind::Closure(_, ref decl, ref body, _fn_decl_span) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n-                self.process_formals(&decl.inputs, &id);\n \n                 // walk arg and return types\n                 for arg in &decl.inputs {\n@@ -1439,7 +1453,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 }\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_expr(body));\n+                self.nest_tables(ex.id, |v| {\n+                    v.process_formals(&decl.inputs, &id);\n+                    v.nest_scope(ex.id, |v| v.visit_expr(body))\n+                });\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {\n@@ -1455,6 +1472,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                 visit::walk_block(self, block);\n                 opt_else.as_ref().map(|el| visit::walk_expr(self, el));\n             }\n+            ast::ExprKind::Repeat(ref element, ref count) => {\n+                self.visit_expr(element);\n+                self.nest_tables(count.id, |v| v.visit_expr(count));\n+            }\n             _ => {\n                 visit::walk_expr(self, ex)\n             }\n@@ -1492,7 +1513,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'l> for DumpVisitor<'l, 'tcx, 'll,\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.tcx.tables().node_types\n+                    let typ = self.save_ctxt.tables.node_types\n                                   .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);"}, {"sha": "0fbe29880b9994462e223421154d1ca909359144", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n@@ -84,6 +84,7 @@ pub mod recorder {\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tables: &'l ty::Tables<'tcx>,\n     analysis: &'l ty::CrateAnalysis<'tcx>,\n     span_utils: SpanUtils<'tcx>,\n }\n@@ -93,24 +94,6 @@ macro_rules! option_try(\n );\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-               analysis: &'l ty::CrateAnalysis<'tcx>)\n-               -> SaveContext<'l, 'tcx> {\n-        let span_utils = SpanUtils::new(&tcx.sess);\n-        SaveContext::from_span_utils(tcx, analysis, span_utils)\n-    }\n-\n-    pub fn from_span_utils(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n-                           analysis: &'l ty::CrateAnalysis<'tcx>,\n-                           span_utils: SpanUtils<'tcx>)\n-                           -> SaveContext<'l, 'tcx> {\n-        SaveContext {\n-            tcx: tcx,\n-            analysis: analysis,\n-            span_utils: span_utils,\n-        }\n-    }\n-\n     // List external crates used by the current crate.\n     pub fn get_external_crates(&self) -> Vec<CrateData> {\n         let mut result = Vec::new();\n@@ -460,7 +443,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.map.expect_expr(expr.id);\n-        let ty = self.tcx.tables().expr_ty_adjusted_opt(&hir_node);\n+        let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n@@ -474,7 +457,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         return None;\n                     }\n                 };\n-                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n+                match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -493,7 +476,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n-                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n+                match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n@@ -514,7 +497,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::MethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let method_id = self.tcx.tables().method_map[&method_call].def_id;\n+                let method_id = self.tables.method_map[&method_call].def_id;\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n@@ -551,7 +534,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n-                self.tcx.tables().qpath_def(qpath, id)\n+                self.tables.qpath_def(qpath, id)\n             }\n \n             Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n@@ -914,7 +897,12 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     root_path.pop();\n     let output = &mut output_file;\n \n-    let save_ctxt = SaveContext::new(tcx, analysis);\n+    let save_ctxt = SaveContext {\n+        tcx: tcx,\n+        tables: &ty::Tables::empty(),\n+        analysis: analysis,\n+        span_utils: SpanUtils::new(&tcx.sess),\n+    };\n \n     macro_rules! dump {\n         ($new_dumper: expr) => {{"}, {"sha": "ad4bb0fce22ad699922cb2b627f1bd54f7399a44", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -10,7 +10,8 @@\n \n use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n-use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n+use builder::Builder;\n+use common::{type_is_fat_ptr, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -236,7 +237,7 @@ impl ArgType {\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &BlockAndBuilder, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &Builder, mut val: ValueRef, dst: ValueRef) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -251,11 +252,8 @@ impl ArgType {\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n                 let cast_dst = bcx.pointercast(dst, ty.ptr_to());\n-                let store = bcx.store(val, cast_dst);\n                 let llalign = llalign_of_min(ccx, self.ty);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(store, llalign);\n-                }\n+                bcx.store(val, cast_dst, Some(llalign));\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -272,11 +270,11 @@ impl ArgType {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.fcx().alloca(ty, \"abi_cast\");\n+                let llscratch = bcx.alloca(ty, \"abi_cast\");\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value...\n-                bcx.store(val, llscratch);\n+                bcx.store(val, llscratch, None);\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bcx,\n@@ -292,18 +290,18 @@ impl ArgType {\n             if self.original_ty == Type::i1(ccx) {\n                 val = bcx.zext(val, Type::i8(ccx));\n             }\n-            bcx.store(val, dst);\n+            bcx.store(val, dst, None);\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &BlockAndBuilder, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(&self, bcx: &Builder, idx: &mut usize, dst: ValueRef) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n         if self.is_ignore() {\n             return;\n         }\n-        let val = llvm::get_param(bcx.fcx().llfn, *idx as c_uint);\n+        let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n         *idx += 1;\n         self.store(bcx, val, dst);\n     }"}, {"sha": "c3b9a56ac9778569b4d1e4e835ff2571fbcae58d", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 16, "deletions": 370, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -49,53 +49,20 @@ use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n use common::*;\n-use glue;\n+use builder::Builder;\n use base;\n use machine;\n use monomorphize;\n use type_::Type;\n use type_of;\n-use value::Value;\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum BranchKind {\n-    Switch,\n-    Single\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct MaybeSizedValue {\n-    pub value: ValueRef,\n-    pub meta: ValueRef,\n-}\n-\n-impl MaybeSizedValue {\n-    pub fn sized(value: ValueRef) -> MaybeSizedValue {\n-        MaybeSizedValue {\n-            value: value,\n-            meta: std::ptr::null_mut()\n-        }\n-    }\n-\n-    pub fn unsized_(value: ValueRef, meta: ValueRef) -> MaybeSizedValue {\n-        MaybeSizedValue {\n-            value: value,\n-            meta: meta\n-        }\n-    }\n-\n-    pub fn has_meta(&self) -> bool {\n-        !self.meta.is_null()\n-    }\n-}\n \n /// Given an enum, struct, closure, or tuple, extracts fields.\n /// Treats closures as a struct with one variant.\n /// `empty_if_no_variants` is a switch to deal with empty enums.\n /// If true, `variant_index` is disregarded and an empty Vec returned in this case.\n-fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                            variant_index: usize,\n-                            empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n+pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n+                                variant_index: usize,\n+                                empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n     match t.sty {\n         ty::TyAdt(ref def, _) if def.variants.len() == 0 && empty_if_no_variants => {\n             Vec::default()\n@@ -300,28 +267,6 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>\n     }\n }\n \n-/// Obtain a representation of the discriminant sufficient to translate\n-/// destructuring; this may or may not involve the actual discriminant.\n-pub fn trans_switch<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    scrutinee: ValueRef,\n-    range_assert: bool\n-) -> (BranchKind, Option<ValueRef>) {\n-    let l = bcx.ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum { .. } | layout::General { .. } |\n-        layout::RawNullablePointer { .. } | layout::StructWrappedNullablePointer { .. } => {\n-            (BranchKind::Switch, Some(trans_get_discr(bcx, t, scrutinee, None, range_assert)))\n-        }\n-        layout::Univariant { .. } | layout::UntaggedUnion { .. } => {\n-            // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n-            (BranchKind::Single, None)\n-        },\n-        _ => bug!(\"{} is not an enum.\", t)\n-    }\n-}\n-\n pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n     match *l {\n         layout::CEnum { signed, .. }=> signed,\n@@ -331,7 +276,7 @@ pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n \n /// Obtain the actual discriminant of a value.\n pub fn trans_get_discr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     t: Ty<'tcx>,\n     scrutinee: ValueRef,\n     cast_to: Option<Type>,\n@@ -358,7 +303,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx,\n-                monomorphize::field_ty(bcx.ccx.tcx(), substs,\n+                monomorphize::field_ty(bcx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]));\n             bcx.icmp(cmp, bcx.load(scrutinee), C_null(llptrty))\n         }\n@@ -374,7 +319,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n }\n \n fn struct_wrapped_nullable_bitdiscr(\n-    bcx: &BlockAndBuilder,\n+    bcx: &Builder,\n     nndiscr: u64,\n     discrfield: &layout::FieldPath,\n     scrutinee: ValueRef\n@@ -387,7 +332,7 @@ fn struct_wrapped_nullable_bitdiscr(\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n+fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n               range_assert: bool)\n     -> ValueRef {\n     let llty = Type::from_integer(bcx.ccx, ity);\n@@ -415,7 +360,7 @@ fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u\n /// discriminant-like value returned by `trans_switch`.\n ///\n /// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n+pub fn trans_case<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum { discr, .. }\n@@ -435,19 +380,17 @@ pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value:\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n-) {\n+pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr) {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n             assert_discr_in_range(Disr(min), Disr(max), to);\n             bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n-                  val);\n+                  val, None);\n         }\n         layout::General{ discr, .. } => {\n             bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n-                  bcx.struct_gep(val, 0));\n+                  bcx.struct_gep(val, 0), None);\n         }\n         layout::Univariant { .. }\n         | layout::UntaggedUnion { .. }\n@@ -458,7 +401,7 @@ pub fn trans_set_discr<'a, 'tcx>(\n             let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             if to.0 != nndiscr {\n                 let llptrty = type_of::sizing_type_of(bcx.ccx, nnty);\n-                bcx.store(C_null(llptrty), val);\n+                bcx.store(C_null(llptrty), val, None);\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n@@ -476,323 +419,26 @@ pub fn trans_set_discr<'a, 'tcx>(\n                     let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n                     let llptrptr = bcx.gepi(val, &path[..]);\n                     let llptrty = val_ty(llptrptr).element_type();\n-                    bcx.store(C_null(llptrty), llptrptr);\n+                    bcx.store(C_null(llptrty), llptrptr, None);\n                 }\n             }\n         }\n         _ => bug!(\"Cannot handle {} represented as {:#?}\", t, l)\n     }\n }\n \n-fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>) -> bool {\n+fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n-fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n+pub fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n     if min <= max {\n         assert!(min <= discr && discr <= max)\n     } else {\n         assert!(min <= discr || discr <= max)\n     }\n }\n \n-/// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    val: MaybeSizedValue,\n-    discr: Disr,\n-    ix: usize\n-) -> ValueRef {\n-    let l = bcx.ccx.layout_of(t);\n-    debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n-    // Note: if this ever needs to generate conditionals (e.g., if we\n-    // decide to do some kind of cdr-coding-like non-unique repr\n-    // someday), it will need to return a possibly-new bcx as well.\n-    match *l {\n-        layout::Univariant { ref variant, .. } => {\n-            assert_eq!(discr, Disr(0));\n-            struct_field_ptr(bcx, &variant,\n-             &compute_fields(bcx.ccx, t, 0, false),\n-             val, ix, false)\n-        }\n-        layout::Vector { count, .. } => {\n-            assert_eq!(discr.0, 0);\n-            assert!((ix as u64) < count);\n-            bcx.struct_gep(val.value, ix)\n-        }\n-        layout::General { discr: d, ref variants, .. } => {\n-            let mut fields = compute_fields(bcx.ccx, t, discr.0 as usize, false);\n-            fields.insert(0, d.to_ty(&bcx.ccx.tcx(), false));\n-            struct_field_ptr(bcx, &variants[discr.0 as usize],\n-             &fields,\n-             val, ix + 1, true)\n-        }\n-        layout::UntaggedUnion { .. } => {\n-            let fields = compute_fields(bcx.ccx, t, 0, false);\n-            let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n-            bcx.pointercast(val.value, ty.ptr_to())\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } |\n-        layout::StructWrappedNullablePointer { nndiscr,  .. } if discr.0 != nndiscr => {\n-            let nullfields = compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n-            // The unit-like case might have a nonzero number of unit-like fields.\n-            // (e.d., Result of Either with (), as one side.)\n-            let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n-            assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n-            bcx.pointercast(val.value, ty.ptr_to())\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n-            assert_eq!(ix, 0);\n-            assert_eq!(discr.0, nndiscr);\n-            let ty = type_of::type_of(bcx.ccx, nnty);\n-            bcx.pointercast(val.value, ty.ptr_to())\n-        }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            assert_eq!(discr.0, nndiscr);\n-            struct_field_ptr(bcx, &nonnull,\n-             &compute_fields(bcx.ccx, t, discr.0 as usize, false),\n-             val, ix, false)\n-        }\n-        _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n-    }\n-}\n-\n-fn struct_field_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    st: &layout::Struct,\n-    fields: &Vec<Ty<'tcx>>,\n-    val: MaybeSizedValue,\n-    ix: usize,\n-    needs_cast: bool\n-) -> ValueRef {\n-    let fty = fields[ix];\n-    let ccx = bcx.ccx;\n-\n-    let ptr_val = if needs_cast {\n-        let fields = st.field_index_by_increasing_offset().map(|i| {\n-            type_of::in_memory_type_of(ccx, fields[i])\n-        }).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n-        bcx.pointercast(val.value, real_ty.ptr_to())\n-    } else {\n-        val.value\n-    };\n-\n-    // Simple case - we can just GEP the field\n-    //   * First field - Always aligned properly\n-    //   * Packed struct - There is no alignment padding\n-    //   * Field is sized - pointer is properly aligned already\n-    if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n-        bcx.ccx.shared().type_is_sized(fty) {\n-        return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n-    }\n-\n-    // If the type of the last field is [T] or str, then we don't need to do\n-    // any adjusments\n-    match fty.sty {\n-        ty::TySlice(..) | ty::TyStr => {\n-            return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n-        }\n-        _ => ()\n-    }\n-\n-    // There's no metadata available, log the case and just do the GEP.\n-    if !val.has_meta() {\n-        debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-               ix, Value(ptr_val));\n-        return bcx.struct_gep(ptr_val, ix);\n-    }\n-\n-    // We need to get the pointer manually now.\n-    // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n-    // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n-    // because the field may have an arbitrary alignment in the LLVM representation\n-    // anyway.\n-    //\n-    // To demonstrate:\n-    //   struct Foo<T: ?Sized> {\n-    //      x: u16,\n-    //      y: T\n-    //   }\n-    //\n-    // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n-    // the `y` field has 16-bit alignment.\n-\n-    let meta = val.meta;\n-\n-\n-    let offset = st.offsets[ix].bytes();\n-    let unaligned_offset = C_uint(bcx.ccx, offset);\n-\n-    // Get the alignment of the field\n-    let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n-\n-    // Bump the unaligned offset up to the appropriate alignment using the\n-    // following expression:\n-    //\n-    //   (unaligned offset + (align - 1)) & -align\n-\n-    // Calculate offset\n-    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n-    let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n-                         bcx.neg(align));\n-\n-    debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n-\n-    // Cast and adjust pointer\n-    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n-    let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n-\n-    // Finally, cast back to the type expected\n-    let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n-    debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n-    bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n-}\n-\n-/// Construct a constant value, suitable for initializing a\n-/// GlobalVariable, given a case and constant values for its fields.\n-/// Note that this may have a different LLVM type (and different\n-/// alignment!) from the representation's `type_of`, so it needs a\n-/// pointer cast before use.\n-///\n-/// The LLVM type system does not directly support unions, and only\n-/// pointers can be bitcast, so a constant (and, by extension, the\n-/// GlobalVariable initialized by it) will have a type that can vary\n-/// depending on which case of an enum it is.\n-///\n-/// To understand the alignment situation, consider `enum E { V64(u64),\n-/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n-/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n-/// i32, i32}`, which is 4-byte aligned.\n-///\n-/// Currently the returned value has the same size as the type, but\n-/// this could be changed in the future to avoid allocating unnecessary\n-/// space after values of shorter-than-maximum cases.\n-pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: Disr,\n-                             vals: &[ValueRef]) -> ValueRef {\n-    let l = ccx.layout_of(t);\n-    let dl = &ccx.tcx().data_layout;\n-    match *l {\n-        layout::CEnum { discr: d, min, max, .. } => {\n-            assert_eq!(vals.len(), 0);\n-            assert_discr_in_range(Disr(min), Disr(max), discr);\n-            C_integral(Type::from_integer(ccx, d), discr.0, true)\n-        }\n-        layout::General { discr: d, ref variants, .. } => {\n-            let variant = &variants[discr.0 as usize];\n-            let lldiscr = C_integral(Type::from_integer(ccx, d), discr.0 as u64, true);\n-            let mut vals_with_discr = vec![lldiscr];\n-            vals_with_discr.extend_from_slice(vals);\n-            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n-            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n-            if needed_padding > 0 {\n-                contents.push(padding(ccx, needed_padding));\n-            }\n-            C_struct(ccx, &contents[..], false)\n-        }\n-        layout::UntaggedUnion { ref variants, .. }=> {\n-            assert_eq!(discr, Disr(0));\n-            let contents = build_const_union(ccx, variants, vals[0]);\n-            C_struct(ccx, &contents, variants.packed)\n-        }\n-        layout::Univariant { ref variant, .. } => {\n-            assert_eq!(discr, Disr(0));\n-            let contents = build_const_struct(ccx, &variant, vals);\n-            C_struct(ccx, &contents[..], variant.packed)\n-        }\n-        layout::Vector { .. } => {\n-            C_vector(vals)\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(ccx, t, nndiscr as usize, false)[0];\n-            if discr.0 == nndiscr {\n-                assert_eq!(vals.len(), 1);\n-                vals[0]\n-            } else {\n-                C_null(type_of::sizing_type_of(ccx, nnty))\n-            }\n-        }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            if discr.0 == nndiscr {\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n-            } else {\n-                let fields = compute_fields(ccx, t, nndiscr as usize, false);\n-                let vals = fields.iter().map(|&ty| {\n-                    // Always use null even if it's not the `discrfield`th\n-                    // field; see #8506.\n-                    C_null(type_of::sizing_type_of(ccx, ty))\n-                }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n-            }\n-        }\n-        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n-    }\n-}\n-\n-/// Building structs is a little complicated, because we might need to\n-/// insert padding if a field's value is less aligned than its type.\n-///\n-/// Continuing the example from `trans_const`, a value of type `(u32,\n-/// E)` should have the `E` at offset 8, but if that field's\n-/// initializer is 4-byte aligned then simply translating the tuple as\n-/// a two-element struct will locate it at offset 4, and accesses to it\n-/// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                st: &layout::Struct,\n-                                vals: &[ValueRef])\n-                                -> Vec<ValueRef> {\n-    assert_eq!(vals.len(), st.offsets.len());\n-\n-    if vals.len() == 0 {\n-        return Vec::new();\n-    }\n-\n-    // offset of current value\n-    let mut offset = 0;\n-    let mut cfields = Vec::new();\n-    cfields.reserve(st.offsets.len()*2);\n-\n-    let parts = st.field_index_by_increasing_offset().map(|i| {\n-        (&vals[i], st.offsets[i].bytes())\n-    });\n-    for (&val, target_offset) in parts {\n-        if offset < target_offset {\n-            cfields.push(padding(ccx, target_offset - offset));\n-            offset = target_offset;\n-        }\n-        assert!(!is_undef(val));\n-        cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n-    }\n-\n-    if offset < st.stride().bytes() {\n-        cfields.push(padding(ccx, st.stride().bytes() - offset));\n-    }\n-\n-    cfields\n-}\n-\n-fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               un: &layout::Union,\n-                               field_val: ValueRef)\n-                               -> Vec<ValueRef> {\n-    let mut cfields = vec![field_val];\n-\n-    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n-    let size = un.stride().bytes();\n-    if offset != size {\n-        cfields.push(padding(ccx, size - offset));\n-    }\n-\n-    cfields\n-}\n-\n-fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(ccx), size))\n-}\n-\n // FIXME this utility routine should be somewhere more general\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }"}, {"sha": "c95d414701876ef6a4d4c9e19d57b12925db5bc5", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,6 +15,7 @@ use base;\n use common::*;\n use type_of;\n use type_::Type;\n+use builder::Builder;\n \n use rustc::hir;\n use rustc::ty::Ty;\n@@ -25,7 +26,7 @@ use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n pub fn trans_inline_asm<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n     outputs: Vec<(ValueRef, Ty<'tcx>)>,\n     mut inputs: Vec<ValueRef>\n@@ -105,7 +106,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n     for (i, (_, &(val, _))) in outputs.enumerate() {\n         let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i) };\n-        bcx.store(v, val);\n+        bcx.store(v, val, None);\n     }\n \n     // Store expn_id in a metadata node so we can map LLVM errors"}, {"sha": "9c982be3fa03ef7215009152e8ebd779bfe0c9dd", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -51,7 +51,13 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths {\n-        ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)));\n+        if rpath.contains(',') {\n+            ret.push(\"-Wl,-rpath\".into());\n+            ret.push(\"-Xlinker\".into());\n+            ret.push(rpath.clone());\n+        } else {\n+            ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)));\n+        }\n     }\n     return ret;\n }\n@@ -258,4 +264,19 @@ mod tests {\n             assert_eq!(res, \"$ORIGIN/../lib\");\n         }\n     }\n+\n+    #[test]\n+    fn test_xlinker() {\n+        let args = rpaths_to_flags(&[\n+            \"a/normal/path\".to_string(),\n+            \"a,comma,path\".to_string()\n+        ]);\n+\n+        assert_eq!(args, vec![\n+            \"-Wl,-rpath,a/normal/path\".to_string(),\n+            \"-Wl,-rpath\".to_string(),\n+            \"-Xlinker\".to_string(),\n+            \"a,comma,path\".to_string()\n+        ]);\n+    }\n }"}, {"sha": "8f8c48a06b2c086bc749b72513442d3067b46ae4", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -152,6 +152,15 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             assert!(!substs.has_erasable_regions());\n             assert!(!substs.needs_subst());\n             substs.visit_with(&mut hasher);\n+\n+            // If this is an instance of a generic function, we also hash in\n+            // the ID of the instantiating crate. This avoids symbol conflicts\n+            // in case the same instances is emitted in two crates of the same\n+            // project.\n+            if substs.types().next().is_some() {\n+                hasher.hash(scx.tcx().crate_name.as_str());\n+                hasher.hash(scx.sess().local_crate_disambiguator().as_str());\n+            }\n         }\n     });\n "}, {"sha": "4cdde24ed48b568a1f69c6cd4690cc62f29ce010", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 46, "deletions": 53, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -37,8 +37,9 @@ use llvm;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::StartFnLangItem;\n use rustc::ty::subst::Substs;\n+use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n@@ -47,14 +48,15 @@ use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::{self, DataTypeKind, Session};\n use abi::{self, Abi, FnType};\n+use mir::lvalue::LvalueRef;\n use adt;\n use attributes;\n use builder::Builder;\n use callee::{Callee};\n-use common::{BlockAndBuilder, C_bool, C_bytes_in_context, C_i32, C_uint};\n+use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef};\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n use common;\n@@ -161,7 +163,7 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n }\n \n pub fn compare_simd_types<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef,\n     t: Ty<'tcx>,\n@@ -218,7 +220,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n pub fn unsize_thin_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     src: ValueRef,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>\n@@ -242,7 +244,7 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                      src: ValueRef,\n                                      src_ty: Ty<'tcx>,\n                                      dst: ValueRef,\n@@ -278,19 +280,19 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 monomorphize::field_ty(bcx.tcx(), substs_b, f)\n             });\n \n-            let src = adt::MaybeSizedValue::sized(src);\n-            let dst = adt::MaybeSizedValue::sized(dst);\n+            let src = LvalueRef::new_sized_ty(src, src_ty);\n+            let dst = LvalueRef::new_sized_ty(dst, dst_ty);\n \n             let iter = src_fields.zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n                 if type_is_zero_size(bcx.ccx, dst_fty) {\n                     continue;\n                 }\n \n-                let src_f = adt::trans_field_ptr(bcx, src_ty, src, Disr(0), i);\n-                let dst_f = adt::trans_field_ptr(bcx, dst_ty, dst, Disr(0), i);\n+                let src_f = src.trans_field_ptr(bcx, i);\n+                let dst_f = dst.trans_field_ptr(bcx, i);\n                 if src_fty == dst_fty {\n-                    memcpy_ty(bcx, dst_f, src_f, src_fty);\n+                    memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n                 } else {\n                     coerce_unsized_into(bcx, src_f, src_fty, dst_f, dst_fty);\n                 }\n@@ -322,7 +324,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &BlockAndBuilder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n+    cx: &Builder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n@@ -421,26 +423,26 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n+pub fn store_ty<'a, 'tcx>(cx: &Builder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.ccx, t) {\n         let lladdr = cx.extract_value(v, abi::FAT_PTR_ADDR);\n         let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n         store_fat_ptr(cx, lladdr, llextra, dst, t);\n     } else {\n-        cx.store(from_immediate(cx, v), dst);\n+        cx.store(from_immediate(cx, v), dst, None);\n     }\n }\n \n-pub fn store_fat_ptr<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn store_fat_ptr<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n                                data: ValueRef,\n                                extra: ValueRef,\n                                dst: ValueRef,\n                                _ty: Ty<'tcx>) {\n     // FIXME: emit metadata\n-    cx.store(data, get_dataptr(cx, dst));\n-    cx.store(extra, get_meta(cx, dst));\n+    cx.store(data, get_dataptr(cx, dst), None);\n+    cx.store(extra, get_meta(cx, dst), None);\n }\n \n pub fn load_fat_ptr<'a, 'tcx>(\n@@ -459,15 +461,15 @@ pub fn load_fat_ptr<'a, 'tcx>(\n     (ptr, meta)\n }\n \n-pub fn from_immediate(bcx: &BlockAndBuilder, val: ValueRef) -> ValueRef {\n+pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     if val_ty(val) == Type::i1(bcx.ccx) {\n         bcx.zext(val, Type::i8(bcx.ccx))\n     } else {\n         val\n     }\n }\n \n-pub fn to_immediate(bcx: &BlockAndBuilder, val: ValueRef, ty: Ty) -> ValueRef {\n+pub fn to_immediate(bcx: &Builder, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n         bcx.trunc(val, Type::i1(bcx.ccx))\n     } else {\n@@ -524,25 +526,22 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n }\n \n pub fn memcpy_ty<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>\n+    bcx: &Builder<'a, 'tcx>,\n+    dst: ValueRef,\n+    src: ValueRef,\n+    t: Ty<'tcx>,\n+    align: Option<u32>,\n ) {\n     let ccx = bcx.ccx;\n \n     if type_is_zero_size(ccx, t) {\n         return;\n     }\n \n-    if t.is_structural() {\n-        let llty = type_of::type_of(ccx, t);\n-        let llsz = llsize_of(ccx, llty);\n-        let llalign = type_of::align_of(ccx, t);\n-        call_memcpy(bcx, dst, src, llsz, llalign as u32);\n-    } else if common::type_is_fat_ptr(bcx.ccx, t) {\n-        let (data, extra) = load_fat_ptr(bcx, src, t);\n-        store_fat_ptr(bcx, data, extra, dst, t);\n-    } else {\n-        store_ty(bcx, load_ty(bcx, src, t), dst, t);\n-    }\n+    let llty = type_of::type_of(ccx, t);\n+    let llsz = llsize_of(ccx, llty);\n+    let llalign = align.unwrap_or_else(|| type_of::align_of(ccx, t));\n+    call_memcpy(bcx, dst, src, llsz, llalign as u32);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n@@ -558,11 +557,6 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn alloc_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    assert!(!ty.has_param_types());\n-    bcx.fcx().alloca(type_of::type_of(bcx.ccx, ty), name)\n-}\n-\n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n@@ -598,43 +592,47 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, lldecl);\n     let mir = ccx.tcx().item_mir(instance.def);\n-    mir::trans_mir(&fcx, fn_ty, &mir, instance, &sig, abi);\n+    mir::trans_mir(ccx, lldecl, fn_ty, &mir, instance, &sig, abi);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,\n                                  disr: Disr,\n-                                 llfndecl: ValueRef) {\n-    attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n-    attributes::set_frame_pointer_elimination(ccx, llfndecl);\n+                                 llfn: ValueRef) {\n+    attributes::inline(llfn, attributes::InlineAttr::Hint);\n+    attributes::set_frame_pointer_elimination(ccx, llfn);\n \n     let ctor_ty = ccx.tcx().item_type(def_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, llfndecl);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n     if !fn_ty.ret.is_ignore() {\n         // But if there are no nested returns, we skip the indirection\n         // and have a single retslot\n         let dest = if fn_ty.ret.is_indirect() {\n-            get_param(fcx.llfn, 0)\n+            get_param(llfn, 0)\n         } else {\n             // We create an alloca to hold a pointer of type `ret.original_ty`\n             // which will hold the pointer to the right alloca which has the\n             // final ret value\n-            fcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+            bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+        };\n+        // Can return unsized value\n+        let mut dest_val = LvalueRef::new_sized_ty(dest, sig.output());\n+        dest_val.ty = LvalueTy::Downcast {\n+            adt_def: sig.output().ty_adt_def().unwrap(),\n+            substs: substs,\n+            variant_index: disr.0 as usize,\n         };\n-        let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(&bcx, sig.output(), dest_val, Disr::from(disr), i);\n+            let lldestptr = dest_val.trans_field_ptr(&bcx, i);\n             let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n@@ -761,12 +759,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         // `main` should respect same config for frame pointer elimination as rest of code\n         attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-        let llbb = unsafe {\n-            let name = CString::new(\"top\").unwrap();\n-            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, name.as_ptr())\n-        };\n-        let bld = Builder::with_ccx(ccx);\n-        bld.position_at_end(llbb);\n+        let bld = Builder::new_block(ccx, llfn, \"top\");\n \n         debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx, &bld);\n "}, {"sha": "cf7f3e9501d1a6e677a2576eac5e93681c4f84f4", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -19,12 +19,17 @@ use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n+use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc::session::Session;\n+use type_of;\n \n use std::borrow::Cow;\n use std::ffi::CString;\n use std::ptr;\n use syntax_pos::Span;\n \n+// All Builders must have an llfn associated with them\n+#[must_use]\n pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n@@ -46,6 +51,20 @@ fn noname() -> *const c_char {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    pub fn new_block<'b>(ccx: &'a CrateContext<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+        let builder = Builder::with_ccx(ccx);\n+        let llbb = unsafe {\n+            let name = CString::new(name).unwrap();\n+            llvm::LLVMAppendBasicBlockInContext(\n+                ccx.llcx(),\n+                llfn,\n+                name.as_ptr()\n+            )\n+        };\n+        builder.position_at_end(llbb);\n+        builder\n+    }\n+\n     pub fn with_ccx(ccx: &'a CrateContext<'a, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n@@ -57,6 +76,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'tcx> {\n+        Builder::new_block(self.ccx, self.llfn(), name)\n+    }\n+\n+    pub fn sess(&self) -> &Session {\n+        self.ccx.sess()\n+    }\n+\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.ccx.tcx()\n+    }\n+\n+    pub fn llfn(&self) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMGetBasicBlockParent(self.llbb())\n+        }\n+    }\n+\n+    pub fn llbb(&self) -> BasicBlockRef {\n+        unsafe {\n+            llvm::LLVMGetInsertBlock(self.llbuilder)\n+        }\n+    }\n+\n     fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n             self.ccx.stats().n_llvm_insns.set(self.ccx.stats().n_llvm_insns.get() + 1);\n@@ -435,6 +478,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+        let builder = Builder::with_ccx(self.ccx);\n+        builder.position_at_start(unsafe {\n+            llvm::LLVMGetFirstBasicBlock(self.llfn())\n+        });\n+        builder.dynamic_alloca(ty, name)\n+    }\n+\n+    pub fn alloca_ty(&self, ty: Ty<'tcx>, name: &str) -> ValueRef {\n+        assert!(!ty.has_param_types());\n+        self.alloca(type_of::type_of(self.ccx, ty), name)\n+    }\n+\n     pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n@@ -512,13 +568,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         value\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n-            llvm::LLVMBuildStore(self.llbuilder, val, ptr)\n+            let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+            if let Some(align) = align {\n+                llvm::LLVMSetAlignment(store, align as c_uint);\n+            }\n+            store\n         }\n     }\n "}, {"sha": "58d0c46850353697ddf9d908ac330ef682e438ff", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -23,11 +23,10 @@ use rustc::traits;\n use abi::{Abi, FnType};\n use attributes;\n use base;\n-use base::*;\n-use common::{\n-    self, CrateContext, FunctionContext, SharedCrateContext\n-};\n-use adt::MaybeSizedValue;\n+use builder::Builder;\n+use common::{self, CrateContext, SharedCrateContext};\n+use cleanup::CleanupScope;\n+use mir::lvalue::LvalueRef;\n use consts;\n use declare;\n use value::Value;\n@@ -235,18 +234,37 @@ fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n            trait_closure_kind={:?}, llfn={:?})\",\n            llfn_closure_kind, trait_closure_kind, Value(llfn));\n \n-    match (llfn_closure_kind, trait_closure_kind) {\n+    match needs_fn_once_adapter_shim(llfn_closure_kind, trait_closure_kind) {\n+        Ok(true) => trans_fn_once_adapter_shim(ccx,\n+                                               def_id,\n+                                               substs,\n+                                               method_instance,\n+                                               llfn),\n+        Ok(false) => llfn,\n+        Err(()) => {\n+            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                 llfn_closure_kind,\n+                 trait_closure_kind);\n+        }\n+    }\n+}\n+\n+pub fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n+                                  trait_closure_kind: ty::ClosureKind)\n+                                  -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n         (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n         (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n         (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n             // No adapter needed.\n-            llfn\n+           Ok(false)\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n             // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n             // `fn(&mut self, ...)`. In fact, at trans time, these are\n             // basically the same thing, so we can just return llfn.\n-            llfn\n+            Ok(false)\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n         (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n@@ -258,13 +276,9 @@ fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n             //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n             //\n             // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, def_id, substs, method_instance, llfn)\n-        }\n-        _ => {\n-            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                 llfn_closure_kind,\n-                 trait_closure_kind);\n+            Ok(true)\n         }\n+        _ => Err(()),\n     }\n }\n \n@@ -330,8 +344,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n     let orig_fn_ty = fn_ty;\n-    let fcx = FunctionContext::new(ccx, lloncefn);\n-    let mut bcx = fcx.get_entry_block();\n+    let mut bcx = Builder::new_block(ccx, lloncefn, \"entry-block\");\n \n     let callee = Callee {\n         data: Fn(llreffn),\n@@ -340,15 +353,15 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // the first argument (`self`) will be the (by value) closure env.\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(lloncefn);\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n     let self_idx = fn_ty.ret.is_indirect() as usize;\n     let env_arg = &orig_fn_ty.args[0];\n     let llenv = if env_arg.is_indirect() {\n         llargs[self_idx]\n     } else {\n-        let scratch = alloc_ty(&bcx, closure_ty, \"self\");\n+        let scratch = bcx.alloca_ty(closure_ty, \"self\");\n         let mut llarg_idx = self_idx;\n         env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch);\n         scratch\n@@ -365,12 +378,14 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.schedule_drop_mem(MaybeSizedValue::sized(llenv), closure_ty);\n+    let self_scope = CleanupScope::schedule_drop_mem(\n+        &bcx, LvalueRef::new_sized_ty(llenv, closure_ty)\n+    );\n \n     let llfn = callee.reify(bcx.ccx);\n     let llret;\n     if let Some(landing_pad) = self_scope.landing_pad {\n-        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+        let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n         llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n         bcx = normal_bcx;\n     } else {\n@@ -489,10 +504,9 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(llfn);\n \n     let self_arg = llargs.remove(fn_ty.ret.is_indirect() as usize);\n     let llfnpointer = llfnpointer.unwrap_or_else(|| {"}, {"sha": "5d89a67d3fd80890029273f3c6b01bfc64c406ac", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -20,11 +20,12 @@\n \n use llvm::BasicBlockRef;\n use base;\n-use adt::MaybeSizedValue;\n-use common::{BlockAndBuilder, FunctionContext, Funclet};\n+use mir::lvalue::LvalueRef;\n+use rustc::mir::tcx::LvalueTy;\n+use builder::Builder;\n+use common::Funclet;\n use glue;\n use type_::Type;\n-use rustc::ty::Ty;\n \n pub struct CleanupScope<'tcx> {\n     // Cleanup to run upon scope exit.\n@@ -36,14 +37,13 @@ pub struct CleanupScope<'tcx> {\n \n #[derive(Copy, Clone)]\n pub struct DropValue<'tcx> {\n-    val: MaybeSizedValue,\n-    ty: Ty<'tcx>,\n+    val: LvalueRef<'tcx>,\n     skip_dtor: bool,\n }\n \n impl<'tcx> DropValue<'tcx> {\n-    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &BlockAndBuilder<'a, 'tcx>) {\n-        glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n+    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &Builder<'a, 'tcx>) {\n+        glue::call_drop_glue(bcx, self.val, self.skip_dtor, funclet)\n     }\n \n     /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n@@ -52,13 +52,13 @@ impl<'tcx> DropValue<'tcx> {\n     ///     landing_pad -> ... cleanups ... -> [resume]\n     ///\n     /// This should only be called once per function, as it creates an alloca for the landingpad.\n-    fn get_landing_pad<'a>(&self, fcx: &FunctionContext<'a, 'tcx>) -> BasicBlockRef {\n+    fn get_landing_pad<'a>(&self, bcx: &Builder<'a, 'tcx>) -> BasicBlockRef {\n         debug!(\"get_landing_pad\");\n-        let bcx = fcx.build_new_block(\"cleanup_unwind\");\n+        let bcx = bcx.build_sibling_block(\"cleanup_unwind\");\n         let llpersonality = bcx.ccx.eh_personality();\n         bcx.set_personality_fn(llpersonality);\n \n-        if base::wants_msvc_seh(fcx.ccx.sess()) {\n+        if base::wants_msvc_seh(bcx.sess()) {\n             let pad = bcx.cleanup_pad(None, &[]);\n             let funclet = Some(Funclet::new(pad));\n             self.trans(funclet.as_ref(), &bcx);\n@@ -68,10 +68,10 @@ impl<'tcx> DropValue<'tcx> {\n             // The landing pad return type (the type being propagated). Not sure\n             // what this represents but it's determined by the personality\n             // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n+            let llretty = Type::struct_(bcx.ccx, &[Type::i8p(bcx.ccx), Type::i32(bcx.ccx)], false);\n \n             // The only landing pad clause will be 'cleanup'\n-            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.fcx().llfn);\n+            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.llfn());\n \n             // The landing pad block is a cleanup\n             bcx.set_cleanup(llretval);\n@@ -92,46 +92,55 @@ impl<'tcx> DropValue<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n+impl<'a, 'tcx> CleanupScope<'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n-    pub fn schedule_drop_mem(&self, val: MaybeSizedValue, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n-        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+    pub fn schedule_drop_mem(\n+        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n+    ) -> CleanupScope<'tcx> {\n+        if let LvalueTy::Downcast { .. } = val.ty {\n+            bug!(\"Cannot drop downcast ty yet\");\n+        }\n+        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n+            return CleanupScope::noop();\n+        }\n         let drop = DropValue {\n             val: val,\n-            ty: ty,\n             skip_dtor: false,\n         };\n \n-        CleanupScope::new(self, drop)\n+        CleanupScope::new(bcx, drop)\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self, val: MaybeSizedValue, ty: Ty<'tcx>)\n-        -> CleanupScope<'tcx> {\n+    pub fn schedule_drop_adt_contents(\n+        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n+    ) -> CleanupScope<'tcx> {\n+        if let LvalueTy::Downcast { .. } = val.ty {\n+            bug!(\"Cannot drop downcast ty yet\");\n+        }\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n-        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n+            return CleanupScope::noop();\n+        }\n \n         let drop = DropValue {\n             val: val,\n-            ty: ty,\n             skip_dtor: true,\n         };\n \n-        CleanupScope::new(self, drop)\n+        CleanupScope::new(bcx, drop)\n     }\n-}\n \n-impl<'tcx> CleanupScope<'tcx> {\n-    fn new<'a>(fcx: &FunctionContext<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n+    fn new(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n         CleanupScope {\n             cleanup: Some(drop_val),\n-            landing_pad: if !fcx.ccx.sess().no_landing_pads() {\n-                Some(drop_val.get_landing_pad(fcx))\n+            landing_pad: if !bcx.sess().no_landing_pads() {\n+                Some(drop_val.get_landing_pad(bcx))\n             } else {\n                 None\n             },\n@@ -145,7 +154,7 @@ impl<'tcx> CleanupScope<'tcx> {\n         }\n     }\n \n-    pub fn trans<'a>(self, bcx: &'a BlockAndBuilder<'a, 'tcx>) {\n+    pub fn trans(self, bcx: &'a Builder<'a, 'tcx>) {\n         if let Some(cleanup) = self.cleanup {\n             cleanup.trans(None, &bcx);\n         }"}, {"sha": "5e409a2aa5520e076afd3a7d1dbb16d05f9c2c9b", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 153, "deletions": 42, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -205,13 +205,14 @@ use rustc::mir::visit::Visitor as MirVisitor;\n use syntax::abi::Abi;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n+use callee::needs_fn_once_adapter_shim;\n use context::SharedCrateContext;\n use common::fulfill_obligation;\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItem, DefPathBasedNames};\n+use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n use std::iter;\n \n@@ -336,6 +337,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n+\n+            // Sanity check whether this ended up being collected accidentally\n+            debug_assert!(should_trans_locally(scx.tcx(), def_id));\n+\n             let ty = scx.tcx().item_type(def_id);\n             let ty = glue::get_drop_glue_type(scx, ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n@@ -345,6 +350,9 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             collect_neighbours(scx, Instance::mono(scx, def_id), &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n+            // Sanity check whether this ended up being collected accidentally\n+            debug_assert!(should_trans_locally(scx.tcx(), instance.def));\n+\n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n                                                                instance,\n@@ -373,7 +381,7 @@ fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         callees: &[TransItem<'tcx>],\n                                         inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n-        trans_item.needs_local_copy(tcx)\n+        trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n     let inlining_candidates = callees.into_iter()\n@@ -489,15 +497,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         .require(ExchangeMallocFnLangItem)\n                         .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n \n-                assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n-                let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n-                let exchange_malloc_fn_trans_item =\n-                    create_fn_trans_item(self.scx,\n-                                         exchange_malloc_fn_def_id,\n-                                         empty_substs,\n-                                         self.param_substs);\n+                if should_trans_locally(self.scx.tcx(), exchange_malloc_fn_def_id) {\n+                    let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n+                    let exchange_malloc_fn_trans_item =\n+                        create_fn_trans_item(self.scx,\n+                                             exchange_malloc_fn_def_id,\n+                                             empty_substs,\n+                                             self.param_substs);\n \n-                self.output.push(exchange_malloc_fn_trans_item);\n+                    self.output.push(exchange_malloc_fn_trans_item);\n+                }\n             }\n             _ => { /* not interesting */ }\n         }\n@@ -568,7 +577,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                 callee_substs,\n                                                 self.param_substs);\n \n-            if let Some((callee_def_id, callee_substs)) = dispatched {\n+            if let StaticDispatchResult::Dispatched {\n+                    def_id: callee_def_id,\n+                    substs: callee_substs,\n+                    fn_once_adjustment,\n+                } = dispatched {\n                 // if we have a concrete impl (which we might not have\n                 // in the case of something compiler generated like an\n                 // object shim or a closure that is handled differently),\n@@ -581,6 +594,17 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                           callee_substs,\n                                                           self.param_substs);\n                     self.output.push(trans_item);\n+\n+                    // This call will instantiate an FnOnce adapter, which drops\n+                    // the closure environment. Therefore we need to make sure\n+                    // that we collect the drop-glue for the environment type.\n+                    if let Some(env_ty) = fn_once_adjustment {\n+                        let env_ty = glue::get_drop_glue_type(self.scx, env_ty);\n+                        if self.scx.type_needs_drop(env_ty) {\n+                            let dg = DropGlueKind::Ty(env_ty);\n+                            self.output.push(TransItem::DropGlue(dg));\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -593,7 +617,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             match tcx.item_type(def_id).sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n-                    // always instantiated inline and don't result in\n+                    // always instantiated inline and don't result in a\n                     // translation item. Same for FFI functions.\n                     if let Some(hir_map::NodeForeignItem(_)) = tcx.map.get_if_local(def_id) {\n                         return false;\n@@ -609,7 +633,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 _ => return false\n             }\n \n-            can_have_local_instance(tcx, def_id)\n+            should_trans_locally(tcx, def_id)\n         }\n     }\n \n@@ -659,10 +683,27 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> bool {\n-    tcx.sess.cstore.can_have_local_instance(tcx, def_id)\n+// Returns true if we should translate an instance in the local crate.\n+// Returns false if we can just link to the upstream crate and therefore don't\n+// need a translation item.\n+fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  def_id: DefId)\n+                                  -> bool {\n+    if def_id.is_local() {\n+        true\n+    } else {\n+        if tcx.sess.cstore.is_exported_symbol(def_id) ||\n+           tcx.sess.cstore.is_foreign_item(def_id) {\n+            // We can link to the item in question, no instance needed in this\n+            // crate\n+            false\n+        } else {\n+            if !tcx.sess.cstore.is_item_mir_available(def_id) {\n+                bug!(\"Cannot create local trans-item for {:?}\", def_id)\n+            }\n+            true\n+        }\n+    }\n }\n \n fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -682,14 +723,15 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n     if let ty::TyBox(content_type) = ty.sty {\n         let def_id = scx.tcx().require_lang_item(BoxFreeFnLangItem);\n-        assert!(can_have_local_instance(scx.tcx(), def_id));\n-        let box_free_fn_trans_item =\n-            create_fn_trans_item(scx,\n-                                 def_id,\n-                                 scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n-                                 scx.tcx().intern_substs(&[]));\n-\n-        output.push(box_free_fn_trans_item);\n+\n+        if should_trans_locally(scx.tcx(), def_id) {\n+            let box_free_fn_trans_item =\n+                create_fn_trans_item(scx,\n+                                     def_id,\n+                                     scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n+                                     scx.tcx().intern_substs(&[]));\n+            output.push(box_free_fn_trans_item);\n+        }\n     }\n \n     // If the type implements Drop, also add a translation item for the\n@@ -719,7 +761,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             _ => bug!()\n         };\n \n-        if can_have_local_instance(scx.tcx(), destructor_did) {\n+        if should_trans_locally(scx.tcx(), destructor_did) {\n             let trans_item = create_fn_trans_item(scx,\n                                                   destructor_did,\n                                                   substs,\n@@ -793,15 +835,13 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             bug!(\"encountered unexpected type\");\n         }\n     }\n-\n-\n }\n \n fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 fn_def_id: DefId,\n                                 fn_substs: &'tcx Substs<'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n-                                -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+                                -> StaticDispatchResult<'tcx> {\n     debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n            def_id_to_string(scx.tcx(), fn_def_id),\n            fn_substs,\n@@ -818,18 +858,38 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         debug!(\" => regular function\");\n         // The function is not part of an impl or trait, no dispatching\n         // to be done\n-        Some((fn_def_id, fn_substs))\n+        StaticDispatchResult::Dispatched {\n+            def_id: fn_def_id,\n+            substs: fn_substs,\n+            fn_once_adjustment: None,\n+        }\n     }\n }\n \n+enum StaticDispatchResult<'tcx> {\n+    // The call could be resolved statically as going to the method with\n+    // `def_id` and `substs`.\n+    Dispatched {\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+\n+        // If this is a call to a closure that needs an FnOnce adjustment,\n+        // this contains the new self type of the call (= type of the closure\n+        // environment)\n+        fn_once_adjustment: Option<ty::Ty<'tcx>>,\n+    },\n+    // This goes to somewhere that we don't know at compile-time\n+    Unknown\n+}\n+\n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                              trait_method: &ty::AssociatedItem,\n                                              trait_id: DefId,\n                                              callee_substs: &'tcx Substs<'tcx>,\n                                              param_substs: &'tcx Substs<'tcx>)\n-                                             -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+                                             -> StaticDispatchResult<'tcx> {\n     let tcx = scx.tcx();\n     debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n                                             trait_id={}, \\\n@@ -850,17 +910,56 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // the actual function:\n     match vtbl {\n         traits::VtableImpl(impl_data) => {\n-            Some(traits::find_method(tcx, trait_method.name, rcvr_substs, &impl_data))\n+            let (def_id, substs) = traits::find_method(tcx,\n+                                                       trait_method.name,\n+                                                       rcvr_substs,\n+                                                       &impl_data);\n+            StaticDispatchResult::Dispatched {\n+                def_id: def_id,\n+                substs: substs,\n+                fn_once_adjustment: None,\n+            }\n         }\n         traits::VtableClosure(closure_data) => {\n-            Some((closure_data.closure_def_id, closure_data.substs.substs))\n+            let closure_def_id = closure_data.closure_def_id;\n+            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            let actual_closure_kind = tcx.closure_kind(closure_def_id);\n+\n+            let needs_fn_once_adapter_shim =\n+                match needs_fn_once_adapter_shim(actual_closure_kind,\n+                                                 trait_closure_kind) {\n+                Ok(true) => true,\n+                _ => false,\n+            };\n+\n+            let fn_once_adjustment = if needs_fn_once_adapter_shim {\n+                Some(tcx.mk_closure_from_closure_substs(closure_def_id,\n+                                                        closure_data.substs))\n+            } else {\n+                None\n+            };\n+\n+            StaticDispatchResult::Dispatched {\n+                def_id: closure_def_id,\n+                substs: closure_data.substs.substs,\n+                fn_once_adjustment: fn_once_adjustment,\n+            }\n         }\n-        // Trait object and function pointer shims are always\n-        // instantiated in-place, and as they are just an ABI-adjusting\n-        // indirect call they do not have any dependencies.\n-        traits::VtableFnPointer(..) |\n+        traits::VtableFnPointer(ref data) => {\n+            // If we know the destination of this fn-pointer, we'll have to make\n+            // sure that this destination actually gets instantiated.\n+            if let ty::TyFnDef(def_id, substs, _) = data.fn_ty.sty {\n+                // The destination of the pointer might be something that needs\n+                // further dispatching, such as a trait method, so we do that.\n+                do_static_dispatch(scx, def_id, substs, param_substs)\n+            } else {\n+                StaticDispatchResult::Unknown\n+            }\n+        }\n+        // Trait object shims are always instantiated in-place, and as they are\n+        // just an ABI-adjusting indirect call they do not have any dependencies.\n         traits::VtableObject(..) => {\n-            None\n+            StaticDispatchResult::Unknown\n         }\n         _ => {\n             bug!(\"static call to invalid vtable: {:?}\", vtbl)\n@@ -994,9 +1093,20 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n-                .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs,\n-                                                                  param_substs))\n-                .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n+                .filter_map(|(def_id, substs)| {\n+                    if let StaticDispatchResult::Dispatched {\n+                        def_id,\n+                        substs,\n+                        // We already add the drop-glue for the closure env\n+                        // unconditionally below.\n+                        fn_once_adjustment: _ ,\n+                    } = do_static_dispatch(scx, def_id, substs, param_substs) {\n+                        Some((def_id, substs))\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .filter(|&(def_id, _)| should_trans_locally(scx.tcx(), def_id))\n                 .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n             output.extend(methods);\n         }\n@@ -1171,7 +1281,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if can_have_local_instance(tcx, method.def_id) {\n+                    if should_trans_locally(tcx, method.def_id) {\n                         let item = create_fn_trans_item(scx,\n                                                         method.def_id,\n                                                         callee_substs,\n@@ -1203,6 +1313,7 @@ fn collect_neighbours<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     visitor.visit_mir(&mir);\n     for promoted in &mir.promoted {\n+        visitor.mir = promoted;\n         visitor.visit_mir(promoted);\n     }\n }"}, {"sha": "419267cb269c98e68159bf45ae8a2a81da995334", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 26, "deletions": 222, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -12,11 +12,9 @@\n \n //! Code that is useful in various trans modules.\n \n-use session::Session;\n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, ContextRef, TypeKind};\n+use llvm::{ValueRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n-use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::util::common::MemoizationMap;\n@@ -37,49 +35,40 @@ use rustc::hir;\n use libc::{c_uint, c_char};\n use std::borrow::Cow;\n use std::iter;\n-use std::ops::Deref;\n-use std::ffi::CString;\n \n use syntax::ast;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use syntax_pos::Span;\n \n use rustc_i128::u128;\n \n pub use context::{CrateContext, SharedCrateContext};\n \n pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-        ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-        ty::TyBox(ty) => {\n-            !ccx.shared().type_is_sized(ty)\n-        }\n-        _ => {\n-            false\n-        }\n+    if let Layout::FatPointer { .. } = *ccx.layout_of(ty) {\n+        true\n+    } else {\n+        false\n     }\n }\n \n pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    use machine::llsize_of_alloc;\n-    use type_of::sizing_type_of;\n-\n-    let simple = ty.is_scalar() ||\n-        ty.is_unique() || ty.is_region_ptr() ||\n-        ty.is_simd();\n-    if simple && !type_is_fat_ptr(ccx, ty) {\n-        return true;\n-    }\n-    if !ccx.shared().type_is_sized(ty) {\n-        return false;\n-    }\n-    match ty.sty {\n-        ty::TyAdt(..) | ty::TyTuple(..) | ty::TyArray(..) | ty::TyClosure(..) => {\n-            let llty = sizing_type_of(ccx, ty);\n-            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n+    let layout = ccx.layout_of(ty);\n+    match *layout {\n+        Layout::CEnum { .. } |\n+        Layout::Scalar { .. } |\n+        Layout::Vector { .. } => true,\n+\n+        Layout::FatPointer { .. } => false,\n+\n+        Layout::Array { .. } |\n+        Layout::Univariant { .. } |\n+        Layout::General { .. } |\n+        Layout::UntaggedUnion { .. } |\n+        Layout::RawNullablePointer { .. } |\n+        Layout::StructWrappedNullablePointer { .. } => {\n+            !layout.is_unsized() && layout.size(&ccx.tcx().data_layout).bytes() == 0\n         }\n-        _ => type_is_zero_size(ccx, ty)\n     }\n }\n \n@@ -172,191 +161,6 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n *\n */\n \n-use Disr;\n-\n-/// The concrete version of ty::FieldDef. The name is the field index if\n-/// the field is numeric.\n-pub struct Field<'tcx>(pub ast::Name, pub Ty<'tcx>);\n-\n-/// The concrete version of ty::VariantDef\n-pub struct VariantInfo<'tcx> {\n-    pub discr: Disr,\n-    pub fields: Vec<Field<'tcx>>\n-}\n-\n-impl<'a, 'tcx> VariantInfo<'tcx> {\n-    pub fn from_ty(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   ty: Ty<'tcx>,\n-                   opt_def: Option<Def>)\n-                   -> Self\n-    {\n-        match ty.sty {\n-            ty::TyAdt(adt, substs) => {\n-                let variant = match opt_def {\n-                    None => adt.struct_variant(),\n-                    Some(def) => adt.variant_of_def(def)\n-                };\n-\n-                VariantInfo {\n-                    discr: Disr::from(variant.disr_val),\n-                    fields: variant.fields.iter().map(|f| {\n-                        Field(f.name, monomorphize::field_ty(tcx, substs, f))\n-                    }).collect()\n-                }\n-            }\n-\n-            ty::TyTuple(ref v) => {\n-                VariantInfo {\n-                    discr: Disr(0),\n-                    fields: v.iter().enumerate().map(|(i, &t)| {\n-                        Field(Symbol::intern(&i.to_string()), t)\n-                    }).collect()\n-                }\n-            }\n-\n-            _ => {\n-                bug!(\"cannot get field types from the type {:?}\", ty);\n-            }\n-        }\n-    }\n-}\n-\n-// Function context. Every LLVM function we create will have one of these.\n-pub struct FunctionContext<'a, 'tcx: 'a> {\n-    // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-    // address of the first instruction in the sequence of\n-    // instructions for this function that will go in the .text\n-    // section of the executable we're generating.\n-    pub llfn: ValueRef,\n-\n-    // A marker for the place where we want to insert the function's static\n-    // allocas, so that LLVM will coalesce them into a single alloca call.\n-    alloca_insert_pt: Option<ValueRef>,\n-\n-    // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-\n-    alloca_builder: Builder<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    /// Create a function context for the given function.\n-    /// Call FunctionContext::get_entry_block for the first entry block.\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, llfndecl: ValueRef) -> FunctionContext<'a, 'tcx> {\n-        let mut fcx = FunctionContext {\n-            llfn: llfndecl,\n-            alloca_insert_pt: None,\n-            ccx: ccx,\n-            alloca_builder: Builder::with_ccx(ccx),\n-        };\n-\n-        let val = {\n-            let entry_bcx = fcx.build_new_block(\"entry-block\");\n-            let val = entry_bcx.load(C_null(Type::i8p(ccx)));\n-            fcx.alloca_builder.position_at_start(entry_bcx.llbb());\n-            val\n-        };\n-\n-        // Use a dummy instruction as the insertion point for all allocas.\n-        // This is later removed in the drop of FunctionContext.\n-        fcx.alloca_insert_pt = Some(val);\n-\n-        fcx\n-    }\n-\n-    pub fn get_entry_block(&'a self) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(unsafe {\n-            llvm::LLVMGetFirstBasicBlock(self.llfn)\n-        }, self)\n-    }\n-\n-    pub fn new_block(&'a self, name: &str) -> BasicBlockRef {\n-        unsafe {\n-            let name = CString::new(name).unwrap();\n-            llvm::LLVMAppendBasicBlockInContext(\n-                self.ccx.llcx(),\n-                self.llfn,\n-                name.as_ptr()\n-            )\n-        }\n-    }\n-\n-    pub fn build_new_block(&'a self, name: &str) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(self.new_block(name), self)\n-    }\n-\n-    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n-        self.alloca_builder.dynamic_alloca(ty, name)\n-    }\n-}\n-\n-impl<'a, 'tcx> Drop for FunctionContext<'a, 'tcx> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.unwrap());\n-        }\n-    }\n-}\n-\n-#[must_use]\n-pub struct BlockAndBuilder<'a, 'tcx: 'a> {\n-    // The BasicBlockRef returned from a call to\n-    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n-    // block to the function pointed to by llfn.  We insert\n-    // instructions into that block by way of this block context.\n-    // The block pointing to this one in the function's digraph.\n-    llbb: BasicBlockRef,\n-\n-    // The function context for the function to which this block is\n-    // attached.\n-    fcx: &'a FunctionContext<'a, 'tcx>,\n-\n-    builder: Builder<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> BlockAndBuilder<'a, 'tcx> {\n-    pub fn new(llbb: BasicBlockRef, fcx: &'a FunctionContext<'a, 'tcx>) -> Self {\n-        let builder = Builder::with_ccx(fcx.ccx);\n-        // Set the builder's position to this block's end.\n-        builder.position_at_end(llbb);\n-        BlockAndBuilder {\n-            llbb: llbb,\n-            fcx: fcx,\n-            builder: builder,\n-        }\n-    }\n-\n-    pub fn at_start<F, R>(&self, f: F) -> R\n-        where F: FnOnce(&BlockAndBuilder<'a, 'tcx>) -> R\n-    {\n-        self.position_at_start(self.llbb);\n-        let r = f(self);\n-        self.position_at_end(self.llbb);\n-        r\n-    }\n-\n-    pub fn fcx(&self) -> &'a FunctionContext<'a, 'tcx> {\n-        self.fcx\n-    }\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.ccx.tcx()\n-    }\n-    pub fn sess(&self) -> &'a Session {\n-        self.ccx.sess()\n-    }\n-\n-    pub fn llbb(&self) -> BasicBlockRef {\n-        self.llbb\n-    }\n-}\n-\n-impl<'a, 'tcx> Deref for BlockAndBuilder<'a, 'tcx> {\n-    type Target = Builder<'a, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.builder\n-    }\n-}\n-\n /// A structure representing an active landing pad for the duration of a basic\n /// block.\n ///\n@@ -654,7 +458,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n         // Do the initial selection for the obligation. This yields the\n         // shallow result we are looking for -- that is, what specific impl.\n-        tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n             let mut selcx = SelectionContext::new(&infcx);\n \n             let obligation_cause = traits::ObligationCause::misc(span,\n@@ -725,7 +529,7 @@ pub fn langcall(tcx: TyCtxt,\n // of Java. (See related discussion on #1877 and #10183.)\n \n pub fn build_unchecked_lshift<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef\n ) -> ValueRef {\n@@ -736,7 +540,7 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n }\n \n pub fn build_unchecked_rshift<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n+    bcx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n@@ -749,13 +553,13 @@ pub fn build_unchecked_rshift<'a, 'tcx>(\n     }\n }\n \n-fn shift_mask_rhs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n     bcx.and(rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false))\n }\n \n pub fn shift_mask_val<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     llty: Type,\n     mask_llty: Type,\n     invert: bool"}, {"sha": "a9c1edfdc66cc600ae6c7d9afffc2ac44ee02cb3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -95,8 +95,6 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                 let sym = ccx.symbol_map()\n                              .get(TransItem::Static(id))\n                              .expect(\"Local statics should always be in the SymbolMap\");\n-                // Make sure that this is never executed for something inlined.\n-                assert!(!ccx.tcx().map.is_inlined_node_id(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()"}, {"sha": "5efdd129a32b83c330e789f33df119422cfce0d9", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -851,7 +851,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n-        self.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n+        self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n             ty.layout(&infcx).unwrap_or_else(|e| {\n                 match e {\n                     ty::layout::LayoutError::SizeOverflow(_) =>"}, {"sha": "c6f8ba7b6dc78d79c5fdcb2f7955e086c24c1b27", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -14,7 +14,7 @@ use super::utils::{DIB, span_start};\n \n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n use rustc::mir::{Mir, VisibilityScope};\n \n use libc::c_uint;\n@@ -44,7 +44,7 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &FunctionDebugContext)\n+pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &FunctionDebugContext)\n     -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n@@ -71,7 +71,7 @@ pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &Funct\n     // Instantiate all scopes.\n     for idx in 0..mir.visibility_scopes.len() {\n         let scope = VisibilityScope::new(idx);\n-        make_mir_scope(fcx.ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n+        make_mir_scope(ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n     }\n \n     scopes"}, {"sha": "7a739071506dbe2f3b1c933d92dd4d4ef96f6b70", "filename": "src/librustc_trans/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -45,7 +45,7 @@\n //!\n //! All private state used by the module is stored within either the\n //! CrateDebugContext struct (owned by the CrateContext) or the\n-//! FunctionDebugContext (owned by the FunctionContext).\n+//! FunctionDebugContext (owned by the MirContext).\n //!\n //! This file consists of three conceptual sections:\n //! 1. The public interface of the module"}, {"sha": "1473e55b2643cbef4b8f6aef5ccf759fe45d8cd8", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1738,14 +1738,6 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let tcx = cx.tcx();\n \n-    // Don't create debuginfo for globals inlined from other crates. The other\n-    // crate should already contain debuginfo for it. More importantly, the\n-    // global might not even exist in un-inlined form anywhere which would lead\n-    // to a linker errors.\n-    if tcx.map.is_inlined_node_id(node_id) {\n-        return;\n-    }\n-\n     let node_def_id = tcx.map.local_def_id(node_id);\n     let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n "}, {"sha": "9117f49cf3ea5b8aaa3ec3fc0a343df1e0113a81", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -27,7 +27,8 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::{CrateContext, BlockAndBuilder};\n+use common::CrateContext;\n+use builder::Builder;\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n@@ -423,7 +424,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                dbg_context: &FunctionDebugContext,\n                                variable_name: ast::Name,\n                                variable_type: Ty<'tcx>,"}, {"sha": "e99e26261a3a1017d366f2a4af32142c1e358866", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -38,7 +38,7 @@ pub fn set_source_location(\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", builder.ccx.sess().codemap().span_to_string(span));\n+        debug!(\"set_source_location: {}\", builder.sess().codemap().span_to_string(span));\n         let loc = span_start(builder.ccx, span);\n         InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {"}, {"sha": "b24f00ee6976d039c14c889d5507976193441709", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 95, "deletions": 74, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,18 +13,22 @@\n // Code relating to drop glue.\n \n use std;\n+use std::ptr;\n use std::iter;\n \n use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::BoxFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n-use rustc::ty::{self, AdtKind, Ty, TypeFoldable};\n+use rustc::ty::{self, layout, AdtDef, AdtKind, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n-use adt::{self, MaybeSizedValue};\n+use rustc::mir::tcx::LvalueTy;\n+use mir::lvalue::LvalueRef;\n+use adt;\n use base::*;\n use callee::Callee;\n+use cleanup::CleanupScope;\n use common::*;\n use machine::*;\n use monomorphize;\n@@ -34,23 +38,20 @@ use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;\n use Disr;\n-use cleanup::CleanupScope;\n+use builder::Builder;\n \n use syntax_pos::DUMMY_SP;\n \n-pub fn trans_exchange_free_ty<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    ptr: MaybeSizedValue,\n-    content_ty: Ty<'tcx>\n-) {\n+pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) {\n+    let content_ty = ptr.ty.to_ty(bcx.tcx());\n     let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n     let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n     let callee = Callee::def(bcx.ccx, def_id, substs);\n \n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n \n     let llret = bcx.call(callee.reify(bcx.ccx),\n-        &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize], None);\n+        &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize], None);\n     fn_ty.apply_attrs_callsite(llret);\n }\n \n@@ -79,7 +80,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n     }\n     match t.sty {\n         ty::TyBox(typ) if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) => {\n-            scx.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n+            scx.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n                 let layout = t.layout(&infcx).unwrap();\n                 if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n                     // `Box<ZeroSizeType>` does not allocate.\n@@ -93,17 +94,17 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n     }\n }\n \n-fn drop_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, args: MaybeSizedValue, t: Ty<'tcx>) {\n-    call_drop_glue(bcx, args, t, false, None)\n+fn drop_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, args: LvalueRef<'tcx>) {\n+    call_drop_glue(bcx, args, false, None)\n }\n \n pub fn call_drop_glue<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    mut args: MaybeSizedValue,\n-    t: Ty<'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n+    mut args: LvalueRef<'tcx>,\n     skip_dtor: bool,\n     funclet: Option<&'a Funclet>,\n ) {\n+    let t = args.ty.to_ty(bcx.tcx());\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n     if bcx.ccx.shared().type_needs_drop(t) {\n@@ -116,11 +117,11 @@ pub fn call_drop_glue<'a, 'tcx>(\n         let glue = get_drop_glue_core(ccx, g);\n         let glue_type = get_drop_glue_type(ccx.shared(), t);\n         if glue_type != t {\n-            args.value = bcx.pointercast(args.value, type_of(ccx, glue_type).ptr_to());\n+            args.llval = bcx.pointercast(args.llval, type_of(ccx, glue_type).ptr_to());\n         }\n \n         // No drop-hint ==> call standard drop glue\n-        bcx.call(glue, &[args.value, args.meta][..1 + args.has_meta() as usize],\n+        bcx.call(glue, &[args.llval, args.llextra][..1 + args.has_extra() as usize],\n             funclet.map(|b| b.bundle()));\n     }\n }\n@@ -173,8 +174,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n     let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let mut bcx = fcx.get_entry_block();\n+    let mut bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n@@ -194,9 +194,9 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n \n     let value = get_param(llfn, 0);\n     let ptr = if ccx.shared().type_is_sized(t) {\n-        MaybeSizedValue::sized(value)\n+        LvalueRef::new_sized_ty(value, t)\n     } else {\n-        MaybeSizedValue::unsized_(value, get_param(llfn, 1))\n+        LvalueRef::new_unsized_ty(value, get_param(llfn, 1), t)\n     };\n \n     let skip_dtor = match g {\n@@ -211,23 +211,23 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n             let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llbox = bcx.load(get_dataptr(&bcx, ptr.value));\n-                let info = bcx.load(get_meta(&bcx, ptr.value));\n-                MaybeSizedValue::unsized_(llbox, info)\n+                let llbox = bcx.load(get_dataptr(&bcx, ptr.llval));\n+                let info = bcx.load(get_meta(&bcx, ptr.llval));\n+                LvalueRef::new_unsized_ty(llbox, info, content_ty)\n             } else {\n-                MaybeSizedValue::sized(bcx.load(ptr.value))\n+                LvalueRef::new_sized_ty(bcx.load(ptr.llval), content_ty)\n             };\n-            drop_ty(&bcx, ptr, content_ty);\n-            trans_exchange_free_ty(&bcx, ptr, content_ty);\n+            drop_ty(&bcx, ptr);\n+            trans_exchange_free_ty(&bcx, ptr);\n             bcx\n         }\n         ty::TyDynamic(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any.\n             assert!(!skip_dtor);\n-            let dtor = bcx.load(ptr.meta);\n-            bcx.call(dtor, &[ptr.value], None);\n+            let dtor = bcx.load(ptr.llextra);\n+            bcx.call(dtor, &[ptr.llval], None);\n             bcx\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n@@ -245,7 +245,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // Issue #23611: schedule cleanup of contents, re-inspecting the\n             // discriminant (if any) in case of variant swap in drop code.\n             let contents_scope = if !shallow_drop {\n-                bcx.fcx().schedule_drop_adt_contents(ptr, t)\n+                CleanupScope::schedule_drop_adt_contents(&bcx, ptr)\n             } else {\n                 CleanupScope::noop()\n             };\n@@ -262,9 +262,9 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n             let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n             let llret;\n-            let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+            let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];\n             if let Some(landing_pad) = contents_scope.landing_pad {\n-                let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+                let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n                 llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n                 bcx = normal_bcx;\n             } else {\n@@ -279,7 +279,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n         }\n         _ => {\n             if bcx.ccx.shared().type_needs_drop(t) {\n-                drop_structural_ty(bcx, ptr, t)\n+                drop_structural_ty(bcx, ptr)\n             } else {\n                 bcx\n             }\n@@ -288,8 +288,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     bcx.ret_void();\n }\n \n-pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                                       t: Ty<'tcx>, info: ValueRef)\n+pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n@@ -397,60 +396,64 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n }\n \n // Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n-                                ptr: MaybeSizedValue,\n-                                t: Ty<'tcx>)\n-                                -> BlockAndBuilder<'a, 'tcx> {\n-    fn iter_variant<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n-                              t: Ty<'tcx>,\n-                              av: adt::MaybeSizedValue,\n-                              variant: &'tcx ty::VariantDef,\n-                              substs: &Substs<'tcx>) {\n+fn drop_structural_ty<'a, 'tcx>(\n+    cx: Builder<'a, 'tcx>,\n+    mut ptr: LvalueRef<'tcx>\n+) -> Builder<'a, 'tcx> {\n+    fn iter_variant_fields<'a, 'tcx>(\n+        cx: &'a Builder<'a, 'tcx>,\n+        av: LvalueRef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: usize,\n+        substs: &'tcx Substs<'tcx>\n+    ) {\n+        let variant = &adt_def.variants[variant_index];\n         let tcx = cx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n-            let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n-            drop_ty(&cx, MaybeSizedValue::sized(field_ptr), arg);\n+            let field_ptr = av.trans_field_ptr(&cx, i);\n+            drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg));\n         }\n     }\n \n     let mut cx = cx;\n+    let t = ptr.ty.to_ty(cx.tcx());\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n-                drop_ty(&cx, MaybeSizedValue::sized(llupvar), upvar_ty);\n+                let llupvar = ptr.trans_field_ptr(&cx, i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty));\n             }\n         }\n         ty::TyArray(_, n) => {\n-            let base = get_dataptr(&cx, ptr.value);\n+            let base = get_dataptr(&cx, ptr.llval);\n             let len = C_uint(cx.ccx, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, ptr.value, unit_ty, ptr.meta,\n-                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n+            cx = tvec::slice_for_each(&cx, ptr.llval, unit_ty, ptr.llextra,\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n-                drop_ty(&cx, MaybeSizedValue::sized(llfld_a), *arg);\n+                let llfld_a = ptr.trans_field_ptr(&cx, i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg));\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n-                let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n-                for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                    let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr::from(discr), i);\n-                    let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n-                        MaybeSizedValue::sized(llfld_a)\n-                    } else {\n-                        MaybeSizedValue::unsized_(llfld_a, ptr.meta)\n-                    };\n-                    drop_ty(&cx, ptr, field_ty);\n+                for (i, field) in adt.variants[0].fields.iter().enumerate() {\n+                    let field_ty = monomorphize::field_ty(cx.tcx(), substs, field);\n+                    let mut field_ptr = ptr.clone();\n+                    field_ptr.llval = ptr.trans_field_ptr(&cx, i);\n+                    field_ptr.ty = LvalueTy::from_ty(field_ty);\n+                    if cx.ccx.shared().type_is_sized(field_ty) {\n+                        field_ptr.llextra = ptr::null_mut();\n+                    }\n+                    drop_ty(&cx, field_ptr);\n                 }\n             }\n             AdtKind::Union => {\n@@ -462,16 +465,29 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                 // NB: we must hit the discriminant first so that structural\n                 // comparison know not to proceed when the discriminants differ.\n \n-                match adt::trans_switch(&cx, t, ptr.value, false) {\n-                    (adt::BranchKind::Single, None) => {\n+                // Obtain a representation of the discriminant sufficient to translate\n+                // destructuring; this may or may not involve the actual discriminant.\n+                let l = cx.ccx.layout_of(t);\n+                match *l {\n+                    layout::Univariant { .. } |\n+                    layout::UntaggedUnion { .. } => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            iter_variant(&cx, t, ptr, &adt.variants[0], substs);\n+                            ptr.ty = LvalueTy::Downcast {\n+                                adt_def: adt,\n+                                substs: substs,\n+                                variant_index: 0,\n+                            };\n+                            iter_variant_fields(&cx, ptr, &adt, 0, substs);\n                         }\n                     }\n-                    (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n+                    layout::CEnum { .. } |\n+                    layout::General { .. } |\n+                    layout::RawNullablePointer { .. } |\n+                    layout::StructWrappedNullablePointer { .. } => {\n+                        let lldiscrim_a = adt::trans_get_discr(&cx, t, ptr.llval, None, false);\n                         let tcx = cx.tcx();\n-                        drop_ty(&cx, MaybeSizedValue::sized(lldiscrim_a), tcx.types.isize);\n+                        drop_ty(&cx, LvalueRef::new_sized_ty(lldiscrim_a, tcx.types.isize));\n \n                         // Create a fall-through basic block for the \"else\" case of\n                         // the switch instruction we're about to generate. Note that\n@@ -486,23 +502,28 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                         // from the outer function, and any other use case will only\n                         // call this for an already-valid enum in which case the `ret\n                         // void` will never be hit.\n-                        let ret_void_cx = cx.fcx().build_new_block(\"enum-iter-ret-void\");\n+                        let ret_void_cx = cx.build_sibling_block(\"enum-iter-ret-void\");\n                         ret_void_cx.ret_void();\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n-                        let next_cx = cx.fcx().build_new_block(\"enum-iter-next\");\n+                        let next_cx = cx.build_sibling_block(\"enum-iter-next\");\n \n-                        for variant in &adt.variants {\n+                        for (i, variant) in adt.variants.iter().enumerate() {\n                             let variant_cx_name = format!(\"enum-iter-variant-{}\",\n                                 &variant.disr_val.to_string());\n-                            let variant_cx = cx.fcx().build_new_block(&variant_cx_name);\n+                            let variant_cx = cx.build_sibling_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            iter_variant(&variant_cx, t, ptr, variant, substs);\n+                            ptr.ty = LvalueTy::Downcast {\n+                                adt_def: adt,\n+                                substs: substs,\n+                                variant_index: i,\n+                            };\n+                            iter_variant_fields(&variant_cx, ptr, &adt, i, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;\n                     }\n-                    _ => cx.ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n+                    _ => bug!(\"{} is not an enum.\", t),\n                 }\n             }\n         },"}, {"sha": "842a21e98db46f12686db159bd8d27cb9421afcd", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,6 +16,7 @@ use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType};\n use adt;\n+use mir::lvalue::LvalueRef;\n use base::*;\n use common::*;\n use declare;\n@@ -24,10 +25,10 @@ use type_of;\n use machine;\n use type_::Type;\n use rustc::ty::{self, Ty};\n-use Disr;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use builder::Builder;\n \n use rustc::session::Session;\n use syntax_pos::Span;\n@@ -87,14 +88,14 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs\n-pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n                                       fn_ty: &FnType,\n                                       llargs: &[ValueRef],\n                                       llresult: ValueRef,\n                                       span: Span) {\n     let ccx = bcx.ccx;\n-    let tcx = bcx.tcx();\n+    let tcx = ccx.tcx();\n \n     let (def_id, substs, fty) = match callee_ty.sty {\n         ty::TyFnDef(def_id, substs, ref fty) => (def_id, substs, fty),\n@@ -125,7 +126,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, llargs[0], llargs[1], llargs[2], llresult);\n+            try_intrinsic(bcx, ccx, llargs[0], llargs[1], llargs[2], llresult);\n             C_nil(ccx)\n         }\n         \"breakpoint\" => {\n@@ -290,8 +291,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             let val = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n                             let result = bcx.extract_value(val, 0);\n                             let overflow = bcx.zext(bcx.extract_value(val, 1), Type::bool(ccx));\n-                            bcx.store(result, bcx.struct_gep(llresult, 0));\n-                            bcx.store(overflow, bcx.struct_gep(llresult, 1));\n+                            bcx.store(result, bcx.struct_gep(llresult, 0), None);\n+                            bcx.store(overflow, bcx.struct_gep(llresult, 1), None);\n \n                             C_nil(bcx.ccx)\n                         },\n@@ -409,8 +410,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             failorder, weak);\n                         let result = bcx.extract_value(val, 0);\n                         let success = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx));\n-                        bcx.store(result, bcx.struct_gep(llresult, 0));\n-                        bcx.store(success, bcx.struct_gep(llresult, 1));\n+                        bcx.store(result, bcx.struct_gep(llresult, 0), None);\n+                        bcx.store(success, bcx.struct_gep(llresult, 1), None);\n                     } else {\n                         invalid_monomorphization(sty);\n                     }\n@@ -533,7 +534,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             // qux` to be converted into `foo, bar, baz, qux`, integer\n             // arguments to be truncated as needed and pointers to be\n             // cast.\n-            fn modify_as_needed<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+            fn modify_as_needed<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                           t: &intrinsics::Type,\n                                           arg_type: Ty<'tcx>,\n                                           llarg: ValueRef)\n@@ -548,12 +549,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                         // destructors, and the contents are SIMD\n                         // etc.\n                         assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n-                        let arg = adt::MaybeSizedValue::sized(llarg);\n-                        (0..contents.len())\n-                            .map(|i| {\n-                                bcx.load(adt::trans_field_ptr(bcx, arg_type, arg, Disr(0), i))\n-                            })\n-                            .collect()\n+                        let arg = LvalueRef::new_sized_ty(llarg, arg_type);\n+                        (0..contents.len()).map(|i| bcx.load(arg.trans_field_ptr(bcx, i))).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n                         let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n@@ -615,7 +612,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n                     for i in 0..elems.len() {\n                         let val = bcx.extract_value(val, i);\n-                        bcx.store(val, bcx.struct_gep(llresult, i));\n+                        bcx.store(val, bcx.struct_gep(llresult, i), None);\n                     }\n                     C_nil(ccx)\n                 }\n@@ -627,17 +624,14 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     if val_ty(llval) != Type::void(ccx) && machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n         if let Some(ty) = fn_ty.ret.cast {\n             let ptr = bcx.pointercast(llresult, ty.ptr_to());\n-            let store = bcx.store(llval, ptr);\n-            unsafe {\n-                llvm::LLVMSetAlignment(store, type_of::align_of(ccx, ret_ty));\n-            }\n+            bcx.store(llval, ptr, Some(type_of::align_of(ccx, ret_ty)));\n         } else {\n             store_ty(bcx, llval, llresult, ret_ty);\n         }\n     }\n }\n \n-fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             allow_overlap: bool,\n                             volatile: bool,\n                             tp_ty: Ty<'tcx>,\n@@ -673,7 +667,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n }\n \n fn memset_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: ValueRef,\n@@ -689,19 +683,20 @@ fn memset_intrinsic<'a, 'tcx>(\n }\n \n fn try_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n+    ccx: &CrateContext,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n     dest: ValueRef,\n ) {\n     if bcx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n-        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest);\n+        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, None);\n     } else if wants_msvc_seh(bcx.sess()) {\n-        trans_msvc_try(bcx, func, data, local_ptr, dest);\n+        trans_msvc_try(bcx, ccx, func, data, local_ptr, dest);\n     } else {\n-        trans_gnu_try(bcx, func, data, local_ptr, dest);\n+        trans_gnu_try(bcx, ccx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -712,24 +707,25 @@ fn try_intrinsic<'a, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+                            ccx: &CrateContext,\n                             func: ValueRef,\n                             data: ValueRef,\n                             local_ptr: ValueRef,\n                             dest: ValueRef) {\n-    let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n+    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         bcx.set_personality_fn(bcx.ccx.eh_personality());\n \n-        let normal = bcx.fcx().build_new_block(\"normal\");\n-        let catchswitch = bcx.fcx().build_new_block(\"catchswitch\");\n-        let catchpad = bcx.fcx().build_new_block(\"catchpad\");\n-        let caught = bcx.fcx().build_new_block(\"caught\");\n+        let normal = bcx.build_sibling_block(\"normal\");\n+        let catchswitch = bcx.build_sibling_block(\"catchswitch\");\n+        let catchpad = bcx.build_sibling_block(\"catchpad\");\n+        let caught = bcx.build_sibling_block(\"caught\");\n \n-        let func = llvm::get_param(bcx.fcx().llfn, 0);\n-        let data = llvm::get_param(bcx.fcx().llfn, 1);\n-        let local_ptr = llvm::get_param(bcx.fcx().llfn, 2);\n+        let func = llvm::get_param(bcx.llfn(), 0);\n+        let data = llvm::get_param(bcx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n \n         // We're generating an IR snippet that looks like:\n         //\n@@ -771,7 +767,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.fcx().alloca(i64p, \"slot\");\n+        let slot = bcx.alloca(i64p, \"slot\");\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n@@ -791,8 +787,8 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         let val1 = C_i32(ccx, 1);\n         let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]));\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n-        catchpad.store(arg1, local_ptr);\n-        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]));\n+        catchpad.store(arg1, local_ptr, None);\n+        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), None);\n         catchpad.catch_ret(tok, caught.llbb());\n \n         caught.ret(C_i32(ccx, 1));\n@@ -801,7 +797,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest);\n+    bcx.store(ret, dest, None);\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n@@ -815,12 +811,13 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+                           ccx: &CrateContext,\n                            func: ValueRef,\n                            data: ValueRef,\n                            local_ptr: ValueRef,\n                            dest: ValueRef) {\n-    let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n+    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         // Translates the shims described above:\n@@ -840,12 +837,12 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bcx.fcx().build_new_block(\"then\");\n-        let catch = bcx.fcx().build_new_block(\"catch\");\n+        let then = bcx.build_sibling_block(\"then\");\n+        let catch = bcx.build_sibling_block(\"catch\");\n \n-        let func = llvm::get_param(bcx.fcx().llfn, 0);\n-        let data = llvm::get_param(bcx.fcx().llfn, 1);\n-        let local_ptr = llvm::get_param(bcx.fcx().llfn, 2);\n+        let func = llvm::get_param(bcx.llfn(), 0);\n+        let data = llvm::get_param(bcx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n         bcx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(C_i32(ccx, 0));\n \n@@ -857,28 +854,27 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n                                     false);\n-        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.fcx().llfn);\n+        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.llfn());\n         catch.add_clause(vals, C_null(Type::i8p(ccx)));\n         let ptr = catch.extract_value(vals, 0);\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()));\n+        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), None);\n         catch.ret(C_i32(ccx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest);\n+    bcx.store(ret, dest, None);\n }\n \n // Helper function to give a Block to a closure to translate a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n-                    trans: &mut for<'b> FnMut(BlockAndBuilder<'b, 'tcx>))\n+                    trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let ccx = fcx.ccx;\n     let sig = ccx.tcx().mk_fn_sig(inputs.into_iter(), output, false);\n \n     let rust_fn_ty = ccx.tcx().mk_fn_ptr(ccx.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -887,19 +883,18 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     }));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let fcx = FunctionContext::new(ccx, llfn);\n-    trans(fcx.get_entry_block());\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n+    trans(bcx);\n     llfn\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                             trans: &mut for<'b> FnMut(BlockAndBuilder<'b, 'tcx>))\n+fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n-    let ccx = fcx.ccx;\n     if let Some(llfn) = ccx.rust_try_fn().get() {\n         return llfn;\n     }\n@@ -913,7 +908,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(tcx.mk_fn_sig(iter::once(i8p), tcx.mk_nil(), false)),\n     }));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n+    let rust_try = gen_fn(ccx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));\n     return rust_try\n }\n@@ -923,7 +918,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n }\n \n fn generic_simd_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n     llargs: &[ValueRef],"}, {"sha": "d8c0bde963e33b7c86821c39274c1789ba3a4de7", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -21,7 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(associated_consts)]\n #![feature(box_patterns)]"}, {"sha": "aecba2f57e52cd156d0324f80fbf9f6c275d325e", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -13,6 +13,7 @@ use llvm::{ValueRef, get_params};\n use rustc::traits;\n use callee::{Callee, CalleeData};\n use common::*;\n+use builder::Builder;\n use consts;\n use declare;\n use glue;\n@@ -27,7 +28,7 @@ use rustc::ty;\n const VTABLE_OFFSET: usize = 3;\n \n /// Extracts a method from a trait object's vtable, at the specified index.\n-pub fn get_virtual_method<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                     llvtable: ValueRef,\n                                     vtable_index: usize)\n                                     -> ValueRef {\n@@ -75,10 +76,9 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(llfn);\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(ccx, &[]);\n "}, {"sha": "7d4a1ab5ae70e1f7b991934c94d1e0dbf036f60a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 63, "deletions": 55, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -14,34 +14,37 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, layout};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n-use adt::{self, MaybeSizedValue};\n+use adt;\n use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, BlockAndBuilder, Funclet};\n+use builder::Builder;\n+use common::{self, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n use meth;\n-use type_of;\n+use type_of::{self, align_of};\n use glue;\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::symbol::Symbol;\n \n+use std::cmp;\n+\n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n-use super::lvalue::{LvalueRef};\n+use super::lvalue::LvalueRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock,\n         funclets: &IndexVec<mir::BasicBlock, Option<Funclet>>) {\n-        let mut bcx = self.build_block(bb);\n+        let mut bcx = self.get_builder(bb);\n         let data = &self.mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n@@ -55,7 +58,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n         let cleanup_bundle = funclet.map(|l| l.bundle());\n \n-        let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n+        let funclet_br = |this: &Self, bcx: Builder, bb: mir::BasicBlock| {\n             let lltarget = this.blocks[bb];\n             if let Some(cp) = cleanup_pad {\n                 match this.cleanup_kinds[bb] {\n@@ -82,7 +85,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                         debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                         let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = this.fcx.build_new_block(name);\n+                        let trampoline = this.new_block(name);\n                         trampoline.cleanup_ret(cp, Some(lltarget));\n                         trampoline.llbb()\n                     }\n@@ -206,8 +209,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.fcx().alloca(ret.original_ty, \"ret\");\n-                            self.store_operand(&bcx, llscratch, op);\n+                            let llscratch = bcx.alloca(ret.original_ty, \"ret\");\n+                            self.store_operand(&bcx, llscratch, op, None);\n                             llscratch\n                         }\n                         Ref(llval) => llval\n@@ -220,7 +223,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     load\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n-                    op.pack_if_pair(&bcx).immediate()\n+                    if let Ref(llval) = op.val {\n+                        base::load_ty(&bcx, llval, op.ty)\n+                    } else {\n+                        op.pack_if_pair(&bcx).immediate()\n+                    }\n                 };\n                 bcx.ret(llval);\n             }\n@@ -239,20 +246,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                let lvalue = self.trans_lvalue(&bcx, location);\n+                let mut lvalue = self.trans_lvalue(&bcx, location);\n                 let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n                 let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n-                let ptr = if bcx.ccx.shared().type_is_sized(ty) {\n-                    let value = if drop_ty != ty {\n-                        bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to())\n-                    } else {\n-                        lvalue.llval\n-                    };\n-                    MaybeSizedValue::sized(value)\n-                } else {\n-                    MaybeSizedValue::unsized_(lvalue.llval, lvalue.llextra)\n-                };\n-                let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+                if bcx.ccx.shared().type_is_sized(ty) && drop_ty != ty {\n+                    lvalue.llval = bcx.pointercast(\n+                        lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to());\n+                }\n+                let args = &[lvalue.llval, lvalue.llextra][..1 + lvalue.has_extra() as usize];\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(\n                         drop_fn,\n@@ -299,7 +300,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n-                let panic_block = self.fcx.build_new_block(\"panic\");\n+                let panic_block = self.new_block(\"panic\");\n                 if expected {\n                     bcx.cond_br(cond, lltarget, panic_block.llbb());\n                 } else {\n@@ -424,7 +425,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // The first argument is a thin destination pointer.\n                     let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n                     let val = self.trans_operand(&bcx, &args[1]);\n-                    self.store_operand(&bcx, llptr, val);\n+                    self.store_operand(&bcx, llptr, val, None);\n                     funclet_br(self, bcx, target);\n                     return;\n                 }\n@@ -582,15 +583,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n                     if let Some((_, target)) = *destination {\n-                        let ret_bcx = self.build_block(target);\n-                        ret_bcx.at_start(|ret_bcx| {\n-                            self.set_debug_loc(&ret_bcx, terminator.source_info);\n-                            let op = OperandRef {\n-                                val: Immediate(invokeret),\n-                                ty: sig.output(),\n-                            };\n-                            self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n-                        });\n+                        let ret_bcx = self.get_builder(target);\n+                        self.set_debug_loc(&ret_bcx, terminator.source_info);\n+                        let op = OperandRef {\n+                            val: Immediate(invokeret),\n+                            ty: sig.output(),\n+                        };\n+                        self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                     }\n                 } else {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n@@ -611,7 +610,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_argument(&mut self,\n-                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                      bcx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n@@ -656,8 +655,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.fcx().alloca(arg.original_ty, \"arg\");\n-                    self.store_operand(bcx, llscratch, op);\n+                    let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n+                    self.store_operand(bcx, llscratch, op, None);\n                     (llscratch, true)\n                 } else {\n                     (op.pack_if_pair(bcx).immediate(), false)\n@@ -687,7 +686,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_arguments_untupled(&mut self,\n-                                bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                bcx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n                                 fn_ty: &FnType,\n@@ -704,9 +703,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n             Ref(llval) => {\n-                let base = adt::MaybeSizedValue::sized(llval);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = adt::trans_field_ptr(bcx, tuple.ty, base, Disr(0), n);\n+                    let ptr = LvalueRef::new_sized_ty(llval, tuple.ty);\n+                    let ptr = ptr.trans_field_ptr(bcx, n);\n                     let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n                         Pair(lldata, llextra)\n@@ -763,13 +762,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     }\n \n-    fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>) -> ValueRef {\n+    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n         let ccx = bcx.ccx;\n         if let Some(slot) = self.llpersonalityslot {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.fcx().alloca(llretty, \"personalityslot\");\n+            let slot = bcx.alloca(llretty, \"personalityslot\");\n             self.llpersonalityslot = Some(slot);\n             Lifetime::Start.call(bcx, slot);\n             slot\n@@ -788,36 +787,42 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return self.blocks[target_bb];\n         }\n \n-        let target = self.build_block(target_bb);\n+        let target = self.get_builder(target_bb);\n \n-        let bcx = self.fcx.build_new_block(\"cleanup\");\n+        let bcx = self.new_block(\"cleanup\");\n         self.landing_pads[target_bb] = Some(bcx.llbb());\n \n         let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n+        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n-        bcx.store(llretval, slot);\n+        bcx.store(llretval, slot, None);\n         bcx.br(target.llbb());\n         bcx.llbb()\n     }\n \n     fn unreachable_block(&mut self) -> BasicBlockRef {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.fcx.build_new_block(\"unreachable\");\n+            let bl = self.new_block(\"unreachable\");\n             bl.unreachable();\n             self.unreachable_block = Some(bl.llbb());\n             bl.llbb()\n         })\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(self.blocks[bb], self.fcx)\n+    pub fn new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n+        Builder::new_block(self.ccx, self.llfn, name)\n+    }\n+\n+    pub fn get_builder(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n+        let builder = Builder::with_ccx(self.ccx);\n+        builder.position_at_end(self.blocks[bb]);\n+        builder\n     }\n \n-    fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n                         dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n@@ -834,14 +839,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return if fn_ret_ty.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = base::alloc_ty(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n                         llargs.push(tmp);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = base::alloc_ty(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n                         ReturnDest::DirectOperand(index)\n@@ -862,7 +867,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n     }\n \n-    fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    fn trans_transmute(&mut self, bcx: &Builder<'a, 'tcx>,\n                        src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);\n         if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n@@ -884,13 +889,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let llty = type_of::type_of(bcx.ccx, val.ty);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n-        self.store_operand(bcx, cast_ptr, val);\n+        let in_type = val.ty;\n+        let out_type = dst.ty.to_ty(bcx.tcx());;\n+        let llalign = cmp::min(align_of(bcx.ccx, in_type), align_of(bcx.ccx, out_type));\n+        self.store_operand(bcx, cast_ptr, val, Some(llalign));\n     }\n \n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n-                    bcx: &BlockAndBuilder<'a, 'tcx>,\n+                    bcx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest,\n                     ret_ty: ArgType,\n                     op: OperandRef<'tcx>) {\n@@ -906,7 +914,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n-                    let tmp = base::alloc_ty(bcx, op.ty, \"tmp_ret\");\n+                    let tmp = bcx.alloca_ty(op.ty, \"tmp_ret\");\n                     ret_ty.store(bcx, op.immediate(), tmp);\n                     self.trans_load(bcx, tmp, op.ty)\n                 } else {"}, {"sha": "9ac2bea3b82fbc146495f46a7b6a5ed89db221dd", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 163, "deletions": 16, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -18,16 +18,17 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, layout, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n-use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n+use builder::Builder;\n+use common::{self, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n-use common::{const_to_opt_u128};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n+use common::const_to_opt_u128;\n use consts;\n use monomorphize::{self, Instance};\n use type_of;\n@@ -100,7 +101,6 @@ impl<'tcx> Const<'tcx> {\n                 bug!(\"MIR must not use `{:?}` (which refers to a local ID)\", cv)\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n-            ConstVal::Dummy => bug!(),\n         };\n \n         assert!(!ty.has_erasable_regions());\n@@ -548,16 +548,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::AggregateKind::Adt(..) |\n                     mir::AggregateKind::Closure(..) |\n                     mir::AggregateKind::Tuple => {\n-                        let disr = match *kind {\n-                            mir::AggregateKind::Adt(adt_def, index, _, _) => {\n-                                Disr::from(adt_def.variants[index].disr_val)\n-                            }\n-                            _ => Disr(0)\n-                        };\n-                        Const::new(\n-                            adt::trans_const(self.ccx, dest_ty, disr, &fields),\n-                            dest_ty\n-                        )\n+                        Const::new(trans_const(self.ccx, dest_ty, kind, &fields), dest_ty)\n                     }\n                 }\n             }\n@@ -900,7 +891,7 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n-                          bcx: &BlockAndBuilder<'a, 'tcx>,\n+                          bcx: &Builder<'a, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n                           -> Const<'tcx>\n     {\n@@ -945,3 +936,159 @@ pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n     let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }\n+\n+/// Construct a constant value, suitable for initializing a\n+/// GlobalVariable, given a case and constant values for its fields.\n+/// Note that this may have a different LLVM type (and different\n+/// alignment!) from the representation's `type_of`, so it needs a\n+/// pointer cast before use.\n+///\n+/// The LLVM type system does not directly support unions, and only\n+/// pointers can be bitcast, so a constant (and, by extension, the\n+/// GlobalVariable initialized by it) will have a type that can vary\n+/// depending on which case of an enum it is.\n+///\n+/// To understand the alignment situation, consider `enum E { V64(u64),\n+/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n+/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n+/// i32, i32}`, which is 4-byte aligned.\n+///\n+/// Currently the returned value has the same size as the type, but\n+/// this could be changed in the future to avoid allocating unnecessary\n+/// space after values of shorter-than-maximum cases.\n+fn trans_const<'a, 'tcx>(\n+    ccx: &CrateContext<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    kind: &mir::AggregateKind,\n+    vals: &[ValueRef]\n+) -> ValueRef {\n+    let l = ccx.layout_of(t);\n+    let dl = &ccx.tcx().data_layout;\n+    let variant_index = match *kind {\n+        mir::AggregateKind::Adt(_, index, _, _) => index,\n+        _ => 0,\n+    };\n+    match *l {\n+        layout::CEnum { discr: d, min, max, .. } => {\n+            let discr = match *kind {\n+                mir::AggregateKind::Adt(adt_def, _, _, _) => {\n+                    Disr::from(adt_def.variants[variant_index].disr_val)\n+                },\n+                _ => Disr(0),\n+            };\n+            assert_eq!(vals.len(), 0);\n+            adt::assert_discr_in_range(Disr(min), Disr(max), discr);\n+            C_integral(Type::from_integer(ccx, d), discr.0, true)\n+        }\n+        layout::General { discr: d, ref variants, .. } => {\n+            let variant = &variants[variant_index];\n+            let lldiscr = C_integral(Type::from_integer(ccx, d), variant_index as u64, true);\n+            let mut vals_with_discr = vec![lldiscr];\n+            vals_with_discr.extend_from_slice(vals);\n+            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n+            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n+            if needed_padding > 0 {\n+                contents.push(padding(ccx, needed_padding));\n+            }\n+            C_struct(ccx, &contents[..], false)\n+        }\n+        layout::UntaggedUnion { ref variants, .. }=> {\n+            assert_eq!(variant_index, 0);\n+            let contents = build_const_union(ccx, variants, vals[0]);\n+            C_struct(ccx, &contents, variants.packed)\n+        }\n+        layout::Univariant { ref variant, .. } => {\n+            assert_eq!(variant_index, 0);\n+            let contents = build_const_struct(ccx, &variant, vals);\n+            C_struct(ccx, &contents[..], variant.packed)\n+        }\n+        layout::Vector { .. } => {\n+            C_vector(vals)\n+        }\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let nnty = adt::compute_fields(ccx, t, nndiscr as usize, false)[0];\n+            if variant_index as u64 == nndiscr {\n+                assert_eq!(vals.len(), 1);\n+                vals[0]\n+            } else {\n+                C_null(type_of::sizing_type_of(ccx, nnty))\n+            }\n+        }\n+        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+            if variant_index as u64 == nndiscr {\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n+            } else {\n+                let fields = adt::compute_fields(ccx, t, nndiscr as usize, false);\n+                let vals = fields.iter().map(|&ty| {\n+                    // Always use null even if it's not the `discrfield`th\n+                    // field; see #8506.\n+                    C_null(type_of::sizing_type_of(ccx, ty))\n+                }).collect::<Vec<ValueRef>>();\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n+            }\n+        }\n+        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n+    }\n+}\n+\n+/// Building structs is a little complicated, because we might need to\n+/// insert padding if a field's value is less aligned than its type.\n+///\n+/// Continuing the example from `trans_const`, a value of type `(u32,\n+/// E)` should have the `E` at offset 8, but if that field's\n+/// initializer is 4-byte aligned then simply translating the tuple as\n+/// a two-element struct will locate it at offset 4, and accesses to it\n+/// will read the wrong memory.\n+fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                st: &layout::Struct,\n+                                vals: &[ValueRef])\n+                                -> Vec<ValueRef> {\n+    assert_eq!(vals.len(), st.offsets.len());\n+\n+    if vals.len() == 0 {\n+        return Vec::new();\n+    }\n+\n+    // offset of current value\n+    let mut offset = 0;\n+    let mut cfields = Vec::new();\n+    cfields.reserve(st.offsets.len()*2);\n+\n+    let parts = st.field_index_by_increasing_offset().map(|i| {\n+        (&vals[i], st.offsets[i].bytes())\n+    });\n+    for (&val, target_offset) in parts {\n+        if offset < target_offset {\n+            cfields.push(padding(ccx, target_offset - offset));\n+            offset = target_offset;\n+        }\n+        assert!(!is_undef(val));\n+        cfields.push(val);\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n+    }\n+\n+    if offset < st.stride().bytes() {\n+        cfields.push(padding(ccx, st.stride().bytes() - offset));\n+    }\n+\n+    cfields\n+}\n+\n+fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               un: &layout::Union,\n+                               field_val: ValueRef)\n+                               -> Vec<ValueRef> {\n+    let mut cfields = vec![field_val];\n+\n+    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n+    let size = un.stride().bytes();\n+    if offset != size {\n+        cfields.push(padding(ccx, size - offset));\n+    }\n+\n+    cfields\n+}\n+\n+fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(ccx), size))\n+}"}, {"sha": "bd6e70639bba540e4396742fdd5187ea5fc0bedf", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 183, "deletions": 45, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -9,18 +9,20 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, layout, Ty, TypeFoldable};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n-use base;\n-use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n+use builder::Builder;\n+use common::{self, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n use type_of::type_of;\n use type_of;\n-use Disr;\n+use type_::Type;\n+use value::Value;\n+use glue;\n \n use std::ptr;\n \n@@ -39,22 +41,24 @@ pub struct LvalueRef<'tcx> {\n     pub ty: LvalueTy<'tcx>,\n }\n \n-impl<'tcx> LvalueRef<'tcx> {\n+impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n         LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n-    pub fn alloca<'a>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                        ty: Ty<'tcx>,\n-                        name: &str)\n-                        -> LvalueRef<'tcx>\n-    {\n-        assert!(!ty.has_erasable_regions());\n-        let lltemp = base::alloc_ty(bcx, ty, name);\n-        LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n+    pub fn new_sized_ty(llval: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef::new_sized(llval, LvalueTy::from_ty(ty))\n+    }\n+\n+    pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef {\n+            llval: llval,\n+            llextra: llextra,\n+            ty: LvalueTy::from_ty(ty),\n+        }\n     }\n \n-    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n             ty::TyArray(_, n) => common::C_uint(ccx, n),\n@@ -65,17 +69,170 @@ impl<'tcx> LvalueRef<'tcx> {\n             _ => bug!(\"unexpected type `{}` in LvalueRef::len\", ty)\n         }\n     }\n+\n+    pub fn has_extra(&self) -> bool {\n+        !self.llextra.is_null()\n+    }\n+\n+    fn struct_field_ptr(\n+        self,\n+        bcx: &Builder<'a, 'tcx>,\n+        st: &layout::Struct,\n+        fields: &Vec<Ty<'tcx>>,\n+        ix: usize,\n+        needs_cast: bool\n+    ) -> ValueRef {\n+        let fty = fields[ix];\n+        let ccx = bcx.ccx;\n+\n+        let ptr_val = if needs_cast {\n+            let fields = st.field_index_by_increasing_offset().map(|i| {\n+                type_of::in_memory_type_of(ccx, fields[i])\n+            }).collect::<Vec<_>>();\n+            let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n+            bcx.pointercast(self.llval, real_ty.ptr_to())\n+        } else {\n+            self.llval\n+        };\n+\n+        // Simple case - we can just GEP the field\n+        //   * First field - Always aligned properly\n+        //   * Packed struct - There is no alignment padding\n+        //   * Field is sized - pointer is properly aligned already\n+        if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n+            bcx.ccx.shared().type_is_sized(fty) {\n+                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+            }\n+\n+        // If the type of the last field is [T] or str, then we don't need to do\n+        // any adjusments\n+        match fty.sty {\n+            ty::TySlice(..) | ty::TyStr => {\n+                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+            }\n+            _ => ()\n+        }\n+\n+        // There's no metadata available, log the case and just do the GEP.\n+        if !self.has_extra() {\n+            debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+                ix, Value(ptr_val));\n+            return bcx.struct_gep(ptr_val, ix);\n+        }\n+\n+        // We need to get the pointer manually now.\n+        // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n+        // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n+        // because the field may have an arbitrary alignment in the LLVM representation\n+        // anyway.\n+        //\n+        // To demonstrate:\n+        //   struct Foo<T: ?Sized> {\n+        //      x: u16,\n+        //      y: T\n+        //   }\n+        //\n+        // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n+        // the `y` field has 16-bit alignment.\n+\n+        let meta = self.llextra;\n+\n+\n+        let offset = st.offsets[ix].bytes();\n+        let unaligned_offset = C_uint(bcx.ccx, offset);\n+\n+        // Get the alignment of the field\n+        let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n+\n+        // Bump the unaligned offset up to the appropriate alignment using the\n+        // following expression:\n+        //\n+        //   (unaligned offset + (align - 1)) & -align\n+\n+        // Calculate offset\n+        let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n+        let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n+        bcx.neg(align));\n+\n+        debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n+\n+        // Cast and adjust pointer\n+        let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n+        let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n+\n+        // Finally, cast back to the type expected\n+        let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n+        debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n+        bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n+    }\n+\n+    /// Access a field, at a point when the value's case is known.\n+    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> ValueRef {\n+        let discr = match self.ty {\n+            LvalueTy::Ty { .. } => 0,\n+            LvalueTy::Downcast { variant_index, .. } => variant_index,\n+        };\n+        let t = self.ty.to_ty(bcx.tcx());\n+        let l = bcx.ccx.layout_of(t);\n+        // Note: if this ever needs to generate conditionals (e.g., if we\n+        // decide to do some kind of cdr-coding-like non-unique repr\n+        // someday), it will need to return a possibly-new bcx as well.\n+        match *l {\n+            layout::Univariant { ref variant, .. } => {\n+                assert_eq!(discr, 0);\n+                self.struct_field_ptr(bcx, &variant,\n+                    &adt::compute_fields(bcx.ccx, t, 0, false), ix, false)\n+            }\n+            layout::Vector { count, .. } => {\n+                assert_eq!(discr, 0);\n+                assert!((ix as u64) < count);\n+                bcx.struct_gep(self.llval, ix)\n+            }\n+            layout::General { discr: d, ref variants, .. } => {\n+                let mut fields = adt::compute_fields(bcx.ccx, t, discr, false);\n+                fields.insert(0, d.to_ty(&bcx.tcx(), false));\n+                self.struct_field_ptr(bcx, &variants[discr], &fields, ix + 1, true)\n+            }\n+            layout::UntaggedUnion { .. } => {\n+                let fields = adt::compute_fields(bcx.ccx, t, 0, false);\n+                let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::RawNullablePointer { nndiscr, .. } |\n+            layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n+                let nullfields = adt::compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n+                // The unit-like case might have a nonzero number of unit-like fields.\n+                // (e.d., Result of Either with (), as one side.)\n+                let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n+                assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::RawNullablePointer { nndiscr, .. } => {\n+                let nnty = adt::compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n+                assert_eq!(ix, 0);\n+                assert_eq!(discr as u64, nndiscr);\n+                let ty = type_of::type_of(bcx.ccx, nnty);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+                assert_eq!(discr as u64, nndiscr);\n+                self.struct_field_ptr(bcx, &nonnull,\n+                    &adt::compute_fields(bcx.ccx, t, discr, false), ix, false)\n+            }\n+            _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n+        }\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_lvalue(&mut self,\n-                        bcx: &BlockAndBuilder<'a, 'tcx>,\n+                        bcx: &Builder<'a, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n                         -> LvalueRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n \n         let ccx = bcx.ccx;\n-        let tcx = bcx.tcx();\n+        let tcx = ccx.tcx();\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n             match self.locals[index] {\n@@ -134,26 +291,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n-                        let discr = match tr_base.ty {\n-                            LvalueTy::Ty { .. } => 0,\n-                            LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n-                        };\n-                        let discr = discr as u64;\n-                        let is_sized = self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx));\n-                        let base = if is_sized {\n-                            adt::MaybeSizedValue::sized(tr_base.llval)\n-                        } else {\n-                            adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n-                        };\n-                        let llprojected = adt::trans_field_ptr(bcx, base_ty, base, Disr(discr),\n-                            field.index());\n-                        let llextra = if is_sized {\n+                        let llextra = if self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx)) {\n                             ptr::null_mut()\n                         } else {\n                             tr_base.llextra\n                         };\n-                        (llprojected, llextra)\n+                        (tr_base.trans_field_ptr(bcx, field.index()), llextra)\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n@@ -214,7 +357,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     // Perform an action using the given Lvalue.\n     // If the Lvalue is an empty LocalRef::Operand, then a temporary stack slot\n     // is created first, then used as an operand to update the Lvalue.\n-    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &Builder<'a, 'tcx>,\n                                  lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n@@ -223,9 +366,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 LocalRef::Lvalue(lvalue) => f(self, lvalue),\n                 LocalRef::Operand(None) => {\n                     let lvalue_ty = self.monomorphized_lvalue_ty(lvalue);\n-                    let lvalue = LvalueRef::alloca(bcx,\n-                                                   lvalue_ty,\n-                                                   \"lvalue_temp\");\n+                    assert!(!lvalue_ty.has_erasable_regions());\n+                    let lltemp = bcx.alloca_ty(lvalue_ty, \"lvalue_temp\");\n+                    let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(lvalue_ty));\n                     let ret = f(self, lvalue);\n                     let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n@@ -254,18 +397,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     /// than we are.\n     ///\n     /// nmatsakis: is this still necessary? Not sure.\n-    fn prepare_index(&mut self,\n-                     bcx: &BlockAndBuilder<'a, 'tcx>,\n-                     llindex: ValueRef)\n-                     -> ValueRef\n-    {\n-        let ccx = bcx.ccx;\n+    fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n         let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, ccx.int_type());\n+        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.int_type());\n         if index_size < int_size {\n-            bcx.zext(llindex, ccx.int_type())\n+            bcx.zext(llindex, bcx.ccx.int_type())\n         } else if index_size > int_size {\n-            bcx.trunc(llindex, ccx.int_type())\n+            bcx.trunc(llindex, bcx.ccx.int_type())\n         } else {\n             llindex\n         }"}, {"sha": "eedd7956805b6a52fb7a43a074e27496ae387d7a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -19,7 +19,8 @@ use rustc::infer::TransNormalize;\n use rustc::ty::TypeFoldable;\n use session::config::FullDebugInfo;\n use base;\n-use common::{self, BlockAndBuilder, CrateContext, FunctionContext, C_null, Funclet};\n+use builder::Builder;\n+use common::{self, CrateContext, C_null, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::{self, Instance};\n use abi::FnType;\n@@ -37,7 +38,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::lvalue::{LvalueRef};\n+use self::lvalue::LvalueRef;\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -48,7 +49,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     debug_context: debuginfo::FunctionDebugContext,\n \n-    fcx: &'a common::FunctionContext<'a, 'tcx>,\n+    llfn: ValueRef,\n \n     ccx: &'a CrateContext<'a, 'tcx>,\n \n@@ -106,7 +107,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         monomorphize::apply_param_substs(self.ccx.shared(), self.param_substs, value)\n     }\n \n-    pub fn set_debug_loc(&mut self, bcx: &BlockAndBuilder, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {\n         let (scope, span) = self.debug_loc(source_info);\n         debuginfo::set_source_location(&self.debug_context, bcx, scope, span);\n     }\n@@ -198,7 +199,8 @@ impl<'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'a, 'tcx: 'a>(\n-    fcx: &'a FunctionContext<'a, 'tcx>,\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    llfn: ValueRef,\n     fn_ty: FnType,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n@@ -207,29 +209,29 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n ) {\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(fcx.ccx, instance, sig, abi, fcx.llfn, mir);\n-    let bcx = fcx.get_entry_block();\n+        debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfn, mir);\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK {\n-                fcx.new_block(\"start\")\n+                bcx.build_sibling_block(\"start\").llbb()\n             } else {\n-                fcx.new_block(&format!(\"{:?}\", bb))\n+                bcx.build_sibling_block(&format!(\"{:?}\", bb)).llbb()\n             }\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(fcx, mir, &debug_context);\n+    let scopes = debuginfo::create_mir_scopes(ccx, mir, &debug_context);\n \n     let mut mircx = MirContext {\n         mir: mir,\n-        fcx: fcx,\n+        llfn: llfn,\n         fn_ty: fn_ty,\n-        ccx: fcx.ccx,\n+        ccx: ccx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n@@ -266,7 +268,9 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n-                let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n+                assert!(!ty.has_erasable_regions());\n+                let lltemp = bcx.alloca_ty(ty, &name.as_str());\n+                let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty));\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(source_info);\n                     declare_local(&bcx, &mircx.debug_context, name, ty, scope,\n@@ -278,11 +282,13 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 // Temporary or return pointer\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n-                    let llretptr = llvm::get_param(fcx.llfn, 0);\n+                    let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n-                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty, &format!(\"{:?}\", local)))\n+                    assert!(!ty.has_erasable_regions());\n+                    let lltemp = bcx.alloca_ty(ty, &format!(\"{:?}\", local));\n+                    LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n@@ -312,9 +318,9 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let funclets: IndexVec<mir::BasicBlock, Option<Funclet>> =\n     mircx.cleanup_kinds.iter_enumerated().map(|(bb, cleanup_kind)| {\n         if let CleanupKind::Funclet = *cleanup_kind {\n-            let bcx = mircx.build_block(bb);\n+            let bcx = mircx.get_builder(bb);\n             bcx.set_personality_fn(mircx.ccx.eh_personality());\n-            if base::wants_msvc_seh(fcx.ccx.sess()) {\n+            if base::wants_msvc_seh(ccx.sess()) {\n                 return Some(Funclet::new(bcx.cleanup_pad(None, &[])));\n             }\n         }\n@@ -347,13 +353,12 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             mircx: &MirContext<'a, 'tcx>,\n                             scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                             lvalue_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = mircx.mir;\n-    let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n@@ -381,7 +386,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                 let dst = bcx.struct_gep(lltemp, i);\n                 let arg = &mircx.fn_ty.args[idx];\n@@ -428,7 +433,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             if arg.pad.is_some() {\n                 llarg_idx += 1;\n             }\n-            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             llarg\n         } else if !lvalue_locals.contains(local.index()) &&\n@@ -444,13 +449,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             if arg.pad.is_some() {\n                 llarg_idx += 1;\n             }\n-            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n-                let llmeta = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+                let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n                 llarg_idx += 1;\n                 OperandValue::Pair(llarg, llmeta)\n             } else {\n@@ -462,7 +467,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n-            let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n@@ -514,8 +519,8 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = bcx.fcx().alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n-                bcx.store(llval, alloc);\n+                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n+                bcx.store(llval, alloc, None);\n                 alloc\n             } else {\n                 llval\n@@ -573,7 +578,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n mod analyze;\n mod block;\n mod constant;\n-mod lvalue;\n+pub mod lvalue;\n mod operand;\n mod rvalue;\n mod statement;"}, {"sha": "28a247ee612a9078b6ba32322613439e40abb8b4", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -14,7 +14,8 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, BlockAndBuilder};\n+use common;\n+use builder::Builder;\n use value::Value;\n use type_of;\n use type_::Type;\n@@ -85,8 +86,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a Pair, we return an\n     /// Immediate aggregate with the two values.\n-    pub fn pack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n-                        -> OperandRef<'tcx> {\n+    pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n             // Reconstruct the immediate aggregate.\n             let llty = type_of::type_of(bcx.ccx, self.ty);\n@@ -107,8 +107,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a pair in an Immediate,\n     /// we return a Pair with the two halves.\n-    pub fn unpack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n-                          -> OperandRef<'tcx> {\n+    pub fn unpack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Immediate(llval) = self.val {\n             // Deconstruct the immediate aggregate.\n             if common::type_is_imm_pair(bcx.ccx, self.ty) {\n@@ -136,7 +135,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_load(&mut self,\n-                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                      bcx: &Builder<'a, 'tcx>,\n                       llval: ValueRef,\n                       ty: Ty<'tcx>)\n                       -> OperandRef<'tcx>\n@@ -165,7 +164,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_consume(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          lvalue: &mir::Lvalue<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -217,7 +216,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -242,23 +241,26 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn store_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          lldest: ValueRef,\n-                         operand: OperandRef<'tcx>) {\n-        debug!(\"store_operand: operand={:?}\", operand);\n+                         operand: OperandRef<'tcx>,\n+                         align: Option<u32>) {\n+        debug!(\"store_operand: operand={:?}, align={:?}\", operand, align);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n         if common::type_is_zero_size(bcx.ccx, operand.ty) {\n             return;\n         }\n         match operand.val {\n-            OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty),\n-            OperandValue::Immediate(s) => base::store_ty(bcx, s, lldest, operand.ty),\n+            OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty, align),\n+            OperandValue::Immediate(s) => {\n+                bcx.store(base::from_immediate(bcx, s), lldest, align);\n+            }\n             OperandValue::Pair(a, b) => {\n                 let a = base::from_immediate(bcx, a);\n                 let b = base::from_immediate(bcx, b);\n-                bcx.store(a, bcx.struct_gep(lldest, 0));\n-                bcx.store(b, bcx.struct_gep(lldest, 1));\n+                bcx.store(a, bcx.struct_gep(lldest, 0), align);\n+                bcx.store(b, bcx.struct_gep(lldest, 1), align);\n             }\n         }\n     }"}, {"sha": "1b97a8d010cfeafbe13f12ae03c000505beec03c", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -12,13 +12,15 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n+use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n \n use asm;\n use base;\n+use builder::Builder;\n use callee::Callee;\n-use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder};\n+use common::{self, val_ty, C_bool, C_null, C_uint};\n use common::{C_integral};\n use adt;\n use machine;\n@@ -35,10 +37,10 @@ use super::lvalue::{LvalueRef};\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n-                        bcx: BlockAndBuilder<'a, 'tcx>,\n+                        bcx: Builder<'a, 'tcx>,\n                         dest: LvalueRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> BlockAndBuilder<'a, 'tcx>\n+                        -> Builder<'a, 'tcx>\n     {\n         debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n                Value(dest.llval), rvalue);\n@@ -48,7 +50,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                let tr_operand = self.trans_operand(&bcx, operand);\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               self.store_operand(&bcx, dest.llval, tr_operand);\n+               self.store_operand(&bcx, dest.llval, tr_operand, None);\n                bcx\n            }\n \n@@ -59,7 +61,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(&bcx, dest.llval, temp);\n+                    self.store_operand(&bcx, dest.llval, temp, None);\n                     return bcx;\n                 }\n \n@@ -79,7 +81,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let lltemp = base::alloc_ty(&bcx, operand.ty, \"__unsize_temp\");\n+                        let lltemp = bcx.alloca_ty(operand.ty, \"__unsize_temp\");\n                         base::store_ty(&bcx, llval, lltemp, operand.ty);\n                         lltemp\n                     }\n@@ -95,25 +97,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n-                    self.store_operand(bcx, llslot, tr_elem);\n+                    self.store_operand(bcx, llslot, tr_elem, None);\n                 })\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n                         let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n                         let dest_ty = dest.ty.to_ty(bcx.tcx());\n                         adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                let val = adt::MaybeSizedValue::sized(dest.llval);\n+                                let mut val = LvalueRef::new_sized(dest.llval, dest.ty);\n                                 let field_index = active_field_index.unwrap_or(i);\n-                                let lldest_i = adt::trans_field_ptr(&bcx, dest_ty, val, disr,\n-                                    field_index);\n-                                self.store_operand(&bcx, lldest_i, op);\n+                                val.ty = LvalueTy::Downcast {\n+                                    adt_def: adt_def,\n+                                    substs: self.monomorphize(&substs),\n+                                    variant_index: disr.0 as usize,\n+                                };\n+                                let lldest_i = val.trans_field_ptr(&bcx, field_index);\n+                                self.store_operand(&bcx, lldest_i, op, None);\n                             }\n                         }\n                     },\n@@ -138,7 +144,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     i\n                                 };\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n-                                self.store_operand(&bcx, dest, op);\n+                                self.store_operand(&bcx, dest, op, None);\n                             }\n                         }\n                     }\n@@ -163,16 +169,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(&bcx, dest.llval, temp);\n+                self.store_operand(&bcx, dest.llval, temp, None);\n                 bcx\n             }\n         }\n     }\n \n     pub fn trans_rvalue_operand(&mut self,\n-                                bcx: BlockAndBuilder<'a, 'tcx>,\n+                                bcx: Builder<'a, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (BlockAndBuilder<'a, 'tcx>, OperandRef<'tcx>)\n+                                -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n@@ -254,37 +260,24 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                         let ll_t_in = type_of::immediate_type_of(bcx.ccx, operand.ty);\n                         let ll_t_out = type_of::immediate_type_of(bcx.ccx, cast_ty);\n-                        let (llval, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n-                            let l = bcx.ccx.layout_of(operand.ty);\n-                            let discr = match operand.val {\n-                                OperandValue::Immediate(llval) => llval,\n-                                OperandValue::Ref(llptr) => {\n-                                    adt::trans_get_discr(&bcx, operand.ty, llptr, None, true)\n-                                }\n-                                OperandValue::Pair(..) => bug!(\"Unexpected Pair operand\")\n-                            };\n-                            let (signed, min, max) = match l {\n-                                &Layout::CEnum { signed, min, max, .. } => {\n-                                    (signed, min, max)\n-                                }\n-                                _ => bug!(\"CEnum {:?} is not an enum\", operand)\n-                            };\n-\n+                        let llval = operand.immediate();\n+                        let l = bcx.ccx.layout_of(operand.ty);\n+                        let signed = if let Layout::CEnum { signed, min, max, .. } = *l {\n                             if max > min {\n                                 // We want `table[e as usize]` to not\n                                 // have bound checks, and this is the most\n                                 // convenient place to put the `assume`.\n \n                                 base::call_assume(&bcx, bcx.icmp(\n                                     llvm::IntULE,\n-                                    discr,\n-                                    C_integral(common::val_ty(discr), max, false)\n-                                ))\n+                                    llval,\n+                                    C_integral(common::val_ty(llval), max, false)\n+                                ));\n                             }\n \n-                            (discr, signed)\n+                            signed\n                         } else {\n-                            (operand.immediate(), operand.ty.is_signed())\n+                            operand.ty.is_signed()\n                         };\n \n                         let newval = match (r_t_in, r_t_out) {\n@@ -477,7 +470,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_scalar_binop(&mut self,\n-                              bcx: &BlockAndBuilder<'a, 'tcx>,\n+                              bcx: &Builder<'a, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n@@ -552,7 +545,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_fat_ptr_binop(&mut self,\n-                               bcx: &BlockAndBuilder<'a, 'tcx>,\n+                               bcx: &Builder<'a, 'tcx>,\n                                op: mir::BinOp,\n                                lhs_addr: ValueRef,\n                                lhs_extra: ValueRef,\n@@ -599,7 +592,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_scalar_checked_binop(&mut self,\n-                                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                      bcx: &Builder<'a, 'tcx>,\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -681,7 +674,7 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> ValueRef {\n+fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{TyInt, TyUint};"}, {"sha": "48fc9720e4b8317eb374fc1811499c0b048d8c62", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -11,7 +11,8 @@\n use rustc::mir;\n \n use base;\n-use common::{self, BlockAndBuilder};\n+use common;\n+use builder::Builder;\n \n use super::MirContext;\n use super::LocalRef;\n@@ -20,9 +21,9 @@ use super::super::disr::Disr;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n-                           bcx: BlockAndBuilder<'a, 'tcx>,\n+                           bcx: Builder<'a, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n-                           -> BlockAndBuilder<'a, 'tcx> {\n+                           -> Builder<'a, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n         self.set_debug_loc(&bcx, statement.source_info);\n@@ -77,10 +78,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_storage_liveness(&self,\n-                              bcx: BlockAndBuilder<'a, 'tcx>,\n+                              bcx: Builder<'a, 'tcx>,\n                               lvalue: &mir::Lvalue<'tcx>,\n                               intrinsic: base::Lifetime)\n-                              -> BlockAndBuilder<'a, 'tcx> {\n+                              -> Builder<'a, 'tcx> {\n         if let mir::Lvalue::Local(index) = *lvalue {\n             if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n                 intrinsic.call(&bcx, tr_lval.llval);"}, {"sha": "d1d167306c1fdb9fff02e4d06850415204b9bfae", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 16, "deletions": 59, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -53,8 +53,6 @@\n //! - One for \"stable\", that is non-generic, code\n //! - One for more \"volatile\" code, i.e. monomorphized instances of functions\n //!   defined in that module\n-//! - Code for monomorphized instances of functions from external crates gets\n-//!   placed into every codegen unit that uses that instance.\n //!\n //! In order to see why this heuristic makes sense, let's take a look at when a\n //! codegen unit can get invalidated:\n@@ -82,17 +80,6 @@\n //! side-effect of references a little by at least not touching the non-generic\n //! code of the module.\n //!\n-//! As another optimization, monomorphized functions from external crates get\n-//! some special handling. Since we assume that the definition of such a\n-//! function changes rather infrequently compared to local items, we can just\n-//! instantiate external functions in every codegen unit where it is referenced\n-//! -- without having to fear that doing this will cause a lot of unnecessary\n-//! re-compilations. If such a reference is added or removed, the codegen unit\n-//! has to be re-translated anyway.\n-//! (Note that this only makes sense if external crates actually don't change\n-//! frequently. For certain multi-crate projects this might not be a valid\n-//! assumption).\n-//!\n //! A Note on Inlining\n //! ------------------\n //! As briefly mentioned above, in order for LLVM to be able to inline a\n@@ -107,10 +94,9 @@\n //!   inlined, so it can distribute function instantiations accordingly. Since\n //!   there is no way of knowing for sure which functions LLVM will decide to\n //!   inline in the end, we apply a heuristic here: Only functions marked with\n-//!   #[inline] and (as stated above) functions from external crates are\n-//!   considered for inlining by the partitioner. The current implementation\n-//!   will not try to determine if a function is likely to be inlined by looking\n-//!   at the functions definition.\n+//!   #[inline] are considered for inlining by the partitioner. The current\n+//!   implementation will not try to determine if a function is likely to be\n+//!   inlined by looking at the functions definition.\n //!\n //! Note though that as a side-effect of creating a codegen units per\n //! source-level module, functions from the same module will be available for\n@@ -133,7 +119,7 @@ use std::sync::Arc;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use trans_item::TransItem;\n+use trans_item::{TransItem, InstantiationMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n@@ -326,13 +312,15 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let tcx = scx.tcx();\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n+    let is_incremental_build = tcx.sess.opts.incremental.is_some();\n \n     for trans_item in trans_items {\n-        let is_root = !trans_item.is_instantiated_only_on_demand(tcx);\n+        let is_root = trans_item.instantiation_mode(tcx) == InstantiationMode::GloballyShared;\n \n         if is_root {\n             let characteristic_def_id = characteristic_def_id_of_trans_item(scx, trans_item);\n-            let is_volatile = trans_item.is_generic_fn();\n+            let is_volatile = is_incremental_build &&\n+                              trans_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n@@ -350,25 +338,9 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                 Some(explicit_linkage) => explicit_linkage,\n                 None => {\n                     match trans_item {\n+                        TransItem::Fn(..) |\n                         TransItem::Static(..) => llvm::ExternalLinkage,\n                         TransItem::DropGlue(..) => unreachable!(),\n-                        // Is there any benefit to using ExternalLinkage?:\n-                        TransItem::Fn(ref instance) => {\n-                            if instance.substs.types().next().is_none() {\n-                                // This is a non-generic functions, we always\n-                                // make it visible externally on the chance that\n-                                // it might be used in another codegen unit.\n-                                // Later on base::internalize_symbols() will\n-                                // assign \"internal\" linkage to those symbols\n-                                // that are not referenced from other codegen\n-                                // units (and are not publicly visible).\n-                                llvm::ExternalLinkage\n-                            } else {\n-                                // In the current setup, generic functions cannot\n-                                // be roots.\n-                                unreachable!()\n-                            }\n-                        }\n                     }\n                 }\n             };\n@@ -448,29 +420,14 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n             if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n                 new_codegen_unit.items.insert(trans_item, *linkage);\n-            } else if initial_partitioning.roots.contains(&trans_item) {\n-                // This item will be instantiated in some other codegen unit,\n-                // so we just add it here with AvailableExternallyLinkage\n-                // FIXME(mw): I have not seen it happening yet but having\n-                //            available_externally here could potentially lead\n-                //            to the same problem with exception handling tables\n-                //            as in the case below.\n-                new_codegen_unit.items.insert(trans_item,\n-                                              llvm::AvailableExternallyLinkage);\n-            } else if trans_item.is_from_extern_crate() && !trans_item.is_generic_fn() {\n-                // FIXME(mw): It would be nice if we could mark these as\n-                // `AvailableExternallyLinkage`, since they should have\n-                // been instantiated in the extern crate. But this\n-                // sometimes leads to crashes on Windows because LLVM\n-                // does not handle exception handling table instantiation\n-                // reliably in that case.\n-                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             } else {\n-                // We can't be sure if this will also be instantiated\n-                // somewhere else, so we add an instance here with\n-                // InternalLinkage so we don't get any conflicts.\n-                new_codegen_unit.items.insert(trans_item,\n-                                              llvm::InternalLinkage);\n+                if initial_partitioning.roots.contains(&trans_item) {\n+                    bug!(\"GloballyShared trans-item inlined into other CGU: \\\n+                          {:?}\", trans_item);\n+                }\n+\n+                // This is a cgu-private copy\n+                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             }\n         }\n "}, {"sha": "816c34425437166e985b823fe2e75f7d05754d50", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -45,6 +45,18 @@ pub enum TransItem<'tcx> {\n     Static(NodeId)\n }\n \n+/// Describes how a translation item will be instantiated in object files.\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+pub enum InstantiationMode {\n+    /// There will be exactly one instance of the given TransItem. It will have\n+    /// external linkage so that it can be linked to from other codegen units.\n+    GloballyShared,\n+\n+    /// Each codegen unit containing a reference to the given TransItem will\n+    /// have its own private copy of the function (with internal linkage).\n+    LocalCopy,\n+}\n+\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n@@ -231,22 +243,21 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    /// True if the translation item should only be translated to LLVM IR if\n-    /// it is referenced somewhere (like inline functions, for example).\n-    pub fn is_instantiated_only_on_demand(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        if self.explicit_linkage(tcx).is_some() {\n-            return false;\n-        }\n-\n+    pub fn instantiation_mode(&self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                              -> InstantiationMode {\n         match *self {\n             TransItem::Fn(ref instance) => {\n-                !instance.def.is_local() ||\n-                instance.substs.types().next().is_some() ||\n-                common::is_closure(tcx, instance.def) ||\n-                attr::requests_inline(&tcx.get_attrs(instance.def)[..])\n+                if self.explicit_linkage(tcx).is_none() &&\n+                   (common::is_closure(tcx, instance.def) ||\n+                    attr::requests_inline(&tcx.get_attrs(instance.def)[..])) {\n+                    InstantiationMode::LocalCopy\n+                } else {\n+                    InstantiationMode::GloballyShared\n+                }\n             }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n+            TransItem::DropGlue(..) => InstantiationMode::LocalCopy,\n+            TransItem::Static(..) => InstantiationMode::GloballyShared,\n         }\n     }\n \n@@ -260,18 +271,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    /// Returns true if there has to be a local copy of this TransItem in every\n-    /// codegen unit that references it (as with inlined functions, for example)\n-    pub fn needs_local_copy(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        // Currently everything that is instantiated only on demand is done so\n-        // with \"internal\" linkage, so we need a copy to be present in every\n-        // codegen unit.\n-        // This is coincidental: We could also instantiate something only if it\n-        // is referenced (e.g. a regular, private function) but place it in its\n-        // own codegen unit with \"external\" linkage.\n-        self.is_instantiated_only_on_demand(tcx)\n-    }\n-\n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,"}, {"sha": "cbcbb02bdc89017ebb573ad6a9c06b57f2d94620", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -9,28 +9,29 @@\n // except according to those terms.\n \n use llvm;\n+use builder::Builder;\n use llvm::ValueRef;\n use common::*;\n use rustc::ty::Ty;\n \n pub fn slice_for_each<'a, 'tcx, F>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     data_ptr: ValueRef,\n     unit_ty: Ty<'tcx>,\n     len: ValueRef,\n     f: F\n-) -> BlockAndBuilder<'a, 'tcx> where F: FnOnce(&BlockAndBuilder<'a, 'tcx>, ValueRef) {\n+) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef) {\n     // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n     let zst = type_is_zero_size(bcx.ccx, unit_ty);\n-    let add = |bcx: &BlockAndBuilder, a, b| if zst {\n+    let add = |bcx: &Builder, a, b| if zst {\n         bcx.add(a, b)\n     } else {\n         bcx.inbounds_gep(a, &[b])\n     };\n \n-    let body_bcx = bcx.fcx().build_new_block(\"slice_loop_body\");\n-    let next_bcx = bcx.fcx().build_new_block(\"slice_loop_next\");\n-    let header_bcx = bcx.fcx().build_new_block(\"slice_loop_header\");\n+    let body_bcx = bcx.build_sibling_block(\"slice_loop_body\");\n+    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n+    let header_bcx = bcx.build_sibling_block(\"slice_loop_header\");\n \n     let start = if zst {\n         C_uint(bcx.ccx, 0usize)"}, {"sha": "bc984949fc69d0438432a85c38151a60c47dfa7b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1660,8 +1660,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n             hir::TyArray(ref ty, length) => {\n-                let e = &tcx.map.body(length).value;\n-                if let Ok(length) = eval_length(tcx.global_tcx(), e, \"array length\") {\n+                if let Ok(length) = eval_length(tcx.global_tcx(), length, \"array length\") {\n                     tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n                 } else {\n                     self.tcx().types.err"}, {"sha": "99c664cebeaea3af28a238ffdd1953e14a9f77bb", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -27,9 +27,17 @@ use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n+        self.check_pat_arg(pat, expected, false);\n+    }\n+\n+    /// The `is_arg` argument indicates whether this pattern is the\n+    /// *outermost* pattern in an argument (e.g., in `fn foo(&x:\n+    /// &u32)`, it is true for the `&x` pattern but not `x`). This is\n+    /// used to tailor error reporting.\n+    pub fn check_pat_arg(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>, is_arg: bool) {\n         let tcx = self.tcx;\n \n-        debug!(\"check_pat(pat={:?},expected={:?})\", pat, expected);\n+        debug!(\"check_pat(pat={:?},expected={:?},is_arg={})\", pat, expected, is_arg);\n \n         let ty = match pat.node {\n             PatKind::Wild => {\n@@ -202,6 +210,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // can, to avoid creating needless variables.  This\n                     // also helps with the bad interactions of the given\n                     // hack detailed in (*) below.\n+                    debug!(\"check_pat_arg: expected={:?}\", expected);\n                     let (rptr_ty, inner_ty) = match expected.sty {\n                         ty::TyRef(_, mt) if mt.mutbl == mutbl => {\n                             (expected, mt.ty)\n@@ -212,7 +221,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n                             let rptr_ty = tcx.mk_ref(region, mt);\n-                            self.demand_eqtype(pat.span, expected, rptr_ty);\n+                            debug!(\"check_pat_arg: demanding {:?} = {:?}\", expected, rptr_ty);\n+                            let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n+\n+                            // Look for a case like `fn foo(&foo: u32)` and suggest\n+                            // `fn foo(foo: &u32)`\n+                            if let Some(mut err) = err {\n+                                if is_arg {\n+                                    if let PatKind::Binding(..) = inner.node {\n+                                        if let Ok(snippet) = self.sess().codemap()\n+                                                                        .span_to_snippet(pat.span)\n+                                        {\n+                                            err.help(&format!(\"did you mean `{}: &{}`?\",\n+                                                              &snippet[1..],\n+                                                              expected));\n+                                        }\n+                                    }\n+                                }\n+                                err.emit();\n+                            }\n                             (rptr_ty, inner_ty)\n                         }\n                     };\n@@ -399,7 +426,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.check_pat(&p, discrim_ty);\n                 all_pats_diverge &= self.diverges.get();\n             }\n-            all_pats_diverge\n+            // As discussed with @eddyb, this is for disabling unreachable_code\n+            // warnings on patterns (they're now subsumed by unreachable_patterns\n+            // warnings).\n+            match all_pats_diverge {\n+                Diverges::Maybe => Diverges::Maybe,\n+                Diverges::Always | Diverges::WarnedAlways => Diverges::WarnedAlways,\n+            }\n         }).collect();\n \n         // Now typecheck the blocks."}, {"sha": "0551887e2e8a0d41aad7032a82e3e28f27f117f8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -99,10 +99,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                fn_ty.sig,\n                opt_kind);\n \n-        self.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n+        self.tables.borrow_mut().closure_tys.insert(expr.id, fn_ty);\n         match opt_kind {\n             Some(kind) => {\n-                self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind);\n+                self.tables.borrow_mut().closure_kinds.insert(expr.id, kind);\n             }\n             None => {}\n         }"}, {"sha": "3960dc9edbd2795edecbd0bd8f4fadbfeb0108b3", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -227,7 +227,7 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                                trait_param_env,\n                                                                normalize_cause.clone());\n \n-    tcx.infer_ctxt(None, Some(trait_param_env), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(trait_param_env, Reveal::NotSpecializable).enter(|infcx| {\n         let inh = Inherited::new(ccx, infcx);\n         let infcx = &inh.infcx;\n         let fulfillment_cx = &inh.fulfillment_cx;\n@@ -747,7 +747,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let tcx = ccx.tcx;\n-    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // The below is for the most part highly similar to the procedure"}, {"sha": "a77887cd221deb52e48b2e5f601365d01d00522c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -19,6 +19,7 @@ use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::ty::{self, AssociatedItem};\n+use errors::DiagnosticBuilder;\n \n use super::method::probe;\n \n@@ -38,20 +39,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        self.demand_eqtype_with_origin(&self.misc(sp), expected, actual);\n+        if let Some(mut err) = self.demand_eqtype_diag(sp, expected, actual) {\n+            err.emit();\n+        }\n+    }\n+\n+    pub fn demand_eqtype_diag(&self,\n+                             sp: Span,\n+                             expected: Ty<'tcx>,\n+                             actual: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n+        self.demand_eqtype_with_origin(&self.misc(sp), expected, actual)\n     }\n \n     pub fn demand_eqtype_with_origin(&self,\n                                      cause: &ObligationCause<'tcx>,\n                                      expected: Ty<'tcx>,\n-                                     actual: Ty<'tcx>)\n-    {\n+                                     actual: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n         match self.eq_types(false, cause, actual, expected) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n+                None\n             },\n             Err(e) => {\n-                self.report_mismatched_types(cause, expected, actual, e).emit();\n+                Some(self.report_mismatched_types(cause, expected, actual, e))\n             }\n         }\n     }\n@@ -71,15 +81,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n             if suggestions.len() > 0 {\n                 err.help(&format!(\"here are some functions which \\\n-                                   might fulfill your needs:\\n - {}\",\n-                                  self.get_best_match(&suggestions)));\n+                                   might fulfill your needs:\\n{}\",\n+                                  self.get_best_match(&suggestions).join(\"\\n\")));\n             };\n             err.emit();\n         }\n     }\n \n     fn format_method_suggestion(&self, method: &AssociatedItem) -> String {\n-        format!(\".{}({})\",\n+        format!(\"- .{}({})\",\n                 method.name,\n                 if self.has_no_input_arg(method) {\n                     \"\"\n@@ -88,15 +98,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 })\n     }\n \n-    fn display_suggested_methods(&self, methods: &[AssociatedItem]) -> String {\n+    fn display_suggested_methods(&self, methods: &[AssociatedItem]) -> Vec<String> {\n         methods.iter()\n                .take(5)\n                .map(|method| self.format_method_suggestion(&*method))\n                .collect::<Vec<String>>()\n-               .join(\"\\n - \")\n     }\n \n-    fn get_best_match(&self, methods: &[AssociatedItem]) -> String {\n+    fn get_best_match(&self, methods: &[AssociatedItem]) -> Vec<String> {\n         let no_argument_methods: Vec<_> =\n             methods.iter()\n                    .filter(|ref x| self.has_no_input_arg(&*x))"}, {"sha": "9cd54bd94c8172f8809c4c10d7eaff2a26aa736e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -81,7 +81,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    tcx.infer_ctxt(None, Some(impl_param_env), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(impl_param_env, Reveal::NotSpecializable).enter(|infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n "}, {"sha": "f331c561f0c40fcfdb86aa750f50aff366cf2b2d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -801,13 +801,19 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n-            let closure_def_id = match step.self_ty.sty {\n-                ty::TyClosure(a, _) => a,\n+            let closure_id = match step.self_ty.sty {\n+                ty::TyClosure(def_id, _) => {\n+                    if let Some(id) = self.tcx.map.as_local_node_id(def_id) {\n+                        id\n+                    } else {\n+                        continue;\n+                    }\n+                }\n                 _ => continue,\n             };\n \n             let closure_kinds = &self.tables.borrow().closure_kinds;\n-            let closure_kind = match closure_kinds.get(&closure_def_id) {\n+            let closure_kind = match closure_kinds.get(&closure_id) {\n                 Some(&k) => k,\n                 None => {\n                     return Err(MethodError::ClosureAmbiguity(trait_def_id));"}, {"sha": "0b316c5d37525261de55f0c47206aa7a09635163", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -105,7 +105,7 @@ use lint;\n use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n-use std::cell::{Cell, Ref, RefCell};\n+use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::mem::replace;\n use std::ops::{self, Deref};\n@@ -483,12 +483,11 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> CrateCtxt<'a, 'gcx> {\n     pub fn inherited(&'a self, id: ast::NodeId)\n                      -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        let tables = ty::Tables::empty();\n         let param_env = ParameterEnvironment::for_item(self.tcx, id);\n         InheritedBuilder {\n             ccx: self,\n-            infcx: self.tcx.infer_ctxt(Some(ty::Tables::empty()),\n-                                       Some(param_env),\n-                                       Reveal::NotSpecializable)\n+            infcx: self.tcx.infer_ctxt((tables, param_env), Reveal::NotSpecializable)\n         }\n     }\n }\n@@ -612,8 +611,7 @@ pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n             let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeckItemBody(def_id));\n \n             let param_env = ParameterEnvironment::for_item(ccx.tcx, item_id);\n-            ccx.tcx.infer_ctxt(None, Some(param_env),\n-                               Reveal::NotSpecializable).enter(|infcx| {\n+            ccx.tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 for obligation in obligations.iter().map(|o| o.to_obligation()) {\n                     fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n@@ -681,7 +679,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n         fcx.regionck_fn(fn_id, body);\n-        fcx.resolve_type_vars_in_body(body, fn_id);\n+        fcx.resolve_type_vars_in_body(body);\n     });\n }\n \n@@ -798,7 +796,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.register_old_wf_obligation(arg_ty, arg.pat.span, traits::MiscObligation);\n \n         // Check the pattern.\n-        fcx.check_pat(&arg.pat, arg_ty);\n+        fcx.check_pat_arg(&arg.pat, arg_ty, true);\n         fcx.write_ty(arg.id, arg_ty);\n     }\n \n@@ -1248,7 +1246,7 @@ fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n         fcx.select_all_obligations_or_error();\n \n         fcx.regionck_expr(body);\n-        fcx.resolve_type_vars_in_body(body, id);\n+        fcx.resolve_type_vars_in_body(body);\n     });\n }\n \n@@ -1871,17 +1869,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn item_substs(&self) -> Ref<NodeMap<ty::ItemSubsts<'tcx>>> {\n-        // NOTE: @jroesch this is hack that appears to be fixed on nightly, will monitor if\n-        // it changes when we upgrade the snapshot compiler\n-        fn project_item_susbts<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<ty::ItemSubsts<'tcx>> {\n-            &tables.item_substs\n-        }\n-\n-        Ref::map(self.tables.borrow(), project_item_susbts)\n-    }\n-\n     pub fn opt_node_ty_substs<F>(&self,\n                                  id: ast::NodeId,\n                                  f: F) where\n@@ -3552,19 +3539,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     hir::UnNot => {\n                         oprnd_t = self.structurally_resolved_type(oprnd.span,\n                                                                   oprnd_t);\n+                        let result = self.check_user_unop(\"!\", \"not\",\n+                                                          tcx.lang_items.not_trait(),\n+                                                          expr, &oprnd, oprnd_t, unop);\n+                        // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n-                            oprnd_t = self.check_user_unop(\"!\", \"not\",\n-                                                           tcx.lang_items.not_trait(),\n-                                                           expr, &oprnd, oprnd_t, unop);\n+                            oprnd_t = result;\n                         }\n                     }\n                     hir::UnNeg => {\n                         oprnd_t = self.structurally_resolved_type(oprnd.span,\n                                                                   oprnd_t);\n+                        let result = self.check_user_unop(\"-\", \"neg\",\n+                                                          tcx.lang_items.neg_trait(),\n+                                                          expr, &oprnd, oprnd_t, unop);\n+                        // If it's builtin, we can reuse the type, this helps inference.\n                         if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n-                            oprnd_t = self.check_user_unop(\"-\", \"neg\",\n-                                                           tcx.lang_items.neg_trait(),\n-                                                           expr, &oprnd, oprnd_t, unop);\n+                            oprnd_t = result;\n                         }\n                     }\n                 }\n@@ -3868,8 +3859,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.mk_array(unified, args.len())\n           }\n           hir::ExprRepeat(ref element, count) => {\n-            let count_expr = &tcx.map.body(count).value;\n-            let count = eval_length(self.tcx.global_tcx(), count_expr, \"repeat count\")\n+            let count = eval_length(self.tcx.global_tcx(), count, \"repeat count\")\n                   .unwrap_or(0);\n \n             let uty = match expected {\n@@ -4561,7 +4551,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Check provided lifetime parameters.\n         let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n         if lifetimes.len() > lifetime_defs.len() {\n-            let span = lifetimes[lifetime_defs.len()].span;\n             struct_span_err!(self.tcx.sess, span, E0088,\n                              \"too many lifetime parameters provided: \\\n                               expected {}, found {}\",\n@@ -4570,6 +4559,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .span_label(span, &format!(\"unexpected lifetime parameter{}\",\n                                            match lifetimes.len() { 1 => \"\", _ => \"s\" }))\n                 .emit();\n+        } else if lifetimes.len() > 0 && lifetimes.len() < lifetime_defs.len() {\n+            struct_span_err!(self.tcx.sess, span, E0090,\n+                             \"too few lifetime parameters provided: \\\n+                             expected {}, found {}\",\n+                             count(lifetime_defs.len()),\n+                             count(lifetimes.len()))\n+                .span_label(span, &format!(\"too few lifetime parameters\"))\n+                .emit();\n         }\n \n         // The case where there is not enough lifetime parameters is not checked,"}, {"sha": "95da5a97f6750588f9d1df52a7f8aa0e711bf585", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -106,8 +106,7 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n                      expr: &hir::Expr,\n                      capture_clause: hir::CaptureClause)\n     {\n-        let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n-        if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n+        if !self.fcx.tables.borrow().closure_kinds.contains_key(&expr.id) {\n             self.temp_closure_kinds.insert(expr.id, ty::ClosureKind::Fn);\n             debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n         }\n@@ -211,8 +210,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         // main table and process any deferred resolutions.\n         let closure_def_id = self.fcx.tcx.map.local_def_id(id);\n         if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n-            self.fcx.tables.borrow_mut().closure_kinds\n-                                        .insert(closure_def_id, kind);\n+            self.fcx.tables.borrow_mut().closure_kinds.insert(id, kind);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n             let mut deferred_call_resolutions ="}, {"sha": "4c124cdd60c0fbc34bdf3c2db05cd29425b6f036", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -505,7 +505,9 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n         let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n-        fcx.demand_eqtype_with_origin(&cause, rcvr_ty, self_arg_ty);\n+        if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, rcvr_ty, self_arg_ty) {\n+            err.emit();\n+        }\n     }\n \n     fn check_variances_for_type_defn(&self,"}, {"sha": "02ac7c196b5cb620945be4435ce98d2b04772a80", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -33,10 +33,12 @@ use rustc::hir;\n // Entry point\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_body(&self,\n-                                     body: &'gcx hir::Body,\n-                                     item_id: ast::NodeId) {\n+    pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) {\n         assert_eq!(self.writeback_errors.get(), false);\n+\n+        let item_id = self.tcx.map.body_owner(body.id());\n+        let item_def_id = self.tcx.map.local_def_id(item_id);\n+\n         let mut wbcx = WritebackCx::new(self);\n         for arg in &body.arguments {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n@@ -49,6 +51,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n+\n+        let tables = self.tcx.alloc_tables(wbcx.tables);\n+        self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n     }\n }\n \n@@ -63,6 +68,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n \n+    tables: ty::Tables<'gcx>,\n+\n     // Mapping from free regions of the function to the\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n@@ -74,6 +81,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>) -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let mut wbcx = WritebackCx {\n             fcx: fcx,\n+            tables: ty::Tables::empty(),\n             free_to_bound_regions: DefIdMap()\n         };\n \n@@ -113,18 +121,27 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n-    fn write_ty_to_tcx(&self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tcx({}, {:?})\", node_id,  ty);\n+    fn write_ty_to_tables(&mut self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tables({}, {:?})\", node_id,  ty);\n         assert!(!ty.needs_infer());\n-        self.tcx().tables.borrow_mut().node_types.insert(node_id, ty);\n+        self.tables.node_types.insert(node_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n     // as potentially overloaded. But then, during writeback, if\n     // we observe that something like `a+b` is (known to be)\n     // operating on scalars, we clear the overload.\n-    fn fix_scalar_binary_expr(&mut self, e: &hir::Expr) {\n+    fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n+            hir::ExprUnary(hir::UnNeg, ref inner) |\n+            hir::ExprUnary(hir::UnNot, ref inner)  => {\n+                let inner_ty = self.fcx.node_ty(inner.id);\n+                let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n+\n+                if inner_ty.is_scalar() {\n+                    self.fcx.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+                }\n+            }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n             hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.id);\n@@ -185,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        self.fix_scalar_binary_expr(e);\n+        self.fix_scalar_builtin_expr(e);\n \n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n@@ -219,11 +236,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n \n-        debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n-               self.tcx().map.node_to_pretty_string(p.id),\n-               p.id,\n-               self.tcx().tables().node_id_to_type(p.id));\n-\n         intravisit::walk_pat(self, p);\n     }\n \n@@ -234,13 +246,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n-        self.write_ty_to_tcx(l.id, var_ty);\n+        self.write_ty_to_tables(l.id, var_ty);\n         intravisit::walk_local(self, l);\n     }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn visit_upvar_borrow_map(&self) {\n+    fn visit_upvar_borrow_map(&mut self) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -258,11 +270,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             debug!(\"Upvar capture for {:?} resolved to {:?}\",\n                    upvar_id,\n                    new_upvar_capture);\n-            self.tcx()\n-                .tables\n-                .borrow_mut()\n-                .upvar_capture_map\n-                .insert(*upvar_id, new_upvar_capture);\n+            self.tables.upvar_capture_map.insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -271,13 +279,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n-            let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n-            self.tcx().tables.borrow_mut().closure_tys.insert(*def_id, closure_ty);\n+        for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n+            let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n+            let def_id = self.tcx().map.local_def_id(id);\n+            self.tcx().closure_tys.borrow_mut().insert(def_id, closure_ty);\n         }\n \n-        for (def_id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n-            self.tcx().tables.borrow_mut().closure_kinds.insert(*def_id, closure_kind);\n+        for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n+            let def_id = self.tcx().map.local_def_id(id);\n+            self.tcx().closure_kinds.borrow_mut().insert(def_id, closure_kind);\n         }\n     }\n \n@@ -330,10 +340,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n+    fn visit_node_id(&mut self, reason: ResolveReason, id: ast::NodeId) {\n         // Export associated path extensions.\n         if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&id) {\n-            self.tcx().tables.borrow_mut().type_relative_path_defs.insert(id, def);\n+            self.tables.type_relative_path_defs.insert(id, def);\n         }\n \n         // Resolve any borrowings for the node with id `id`\n@@ -342,7 +352,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         // Resolve the type of the node with id `id`\n         let n_ty = self.fcx.node_ty(id);\n         let n_ty = self.resolve(&n_ty, reason);\n-        self.write_ty_to_tcx(id, n_ty);\n+        self.write_ty_to_tables(id, n_ty);\n         debug!(\"Node {} has type {:?}\", id, n_ty);\n \n         // Resolve any substitutions\n@@ -351,12 +361,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             if !item_substs.is_noop() {\n                 debug!(\"write_substs_to_tcx({}, {:?})\", id, item_substs);\n                 assert!(!item_substs.substs.needs_infer());\n-                self.tcx().tables.borrow_mut().item_substs.insert(id, item_substs);\n+                self.tables.item_substs.insert(id, item_substs);\n             }\n         });\n     }\n \n-    fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n+    fn visit_adjustments(&mut self, reason: ResolveReason, id: ast::NodeId) {\n         let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&id);\n         match adjustments {\n             None => {\n@@ -399,13 +409,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     target: self.resolve(&adjustment.target, reason)\n                 };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n-                self.tcx().tables.borrow_mut().adjustments.insert(\n-                    id, resolved_adjustment);\n+                self.tables.adjustments.insert(id, resolved_adjustment);\n             }\n         }\n     }\n \n-    fn visit_method_map_entry(&self,\n+    fn visit_method_map_entry(&mut self,\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n@@ -427,25 +436,25 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n         //NB(jroesch): We need to match twice to avoid a double borrow which would cause an ICE\n         if let Some(method) = new_method {\n-            self.tcx().tables.borrow_mut().method_map.insert(method_call, method);\n+            self.tables.method_map.insert(method_call, method);\n         }\n     }\n \n-    fn visit_liberated_fn_sigs(&self) {\n+    fn visit_liberated_fn_sigs(&mut self) {\n         for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n             let fn_sig = self.resolve(fn_sig, ResolvingFnSig(node_id));\n-            self.tcx().tables.borrow_mut().liberated_fn_sigs.insert(node_id, fn_sig.clone());\n+            self.tables.liberated_fn_sigs.insert(node_id, fn_sig.clone());\n         }\n     }\n \n-    fn visit_fru_field_types(&self) {\n+    fn visit_fru_field_types(&mut self) {\n         for (&node_id, ftys) in self.fcx.tables.borrow().fru_field_types.iter() {\n             let ftys = self.resolve(ftys, ResolvingFieldTypes(node_id));\n-            self.tcx().tables.borrow_mut().fru_field_types.insert(node_id, ftys);\n+            self.tables.fru_field_types.insert(node_id, ftys);\n         }\n     }\n \n-    fn visit_deferred_obligations(&self, item_id: ast::NodeId) {\n+    fn visit_deferred_obligations(&mut self, item_id: ast::NodeId) {\n         let deferred_obligations = self.fcx.deferred_obligations.borrow();\n         let obligations: Vec<_> = deferred_obligations.iter().map(|obligation| {\n             let reason = ResolvingDeferredObligation(obligation.cause.span);\n@@ -487,7 +496,7 @@ enum ResolveReason {\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n-    ResolvingClosure(DefId),\n+    ResolvingClosure(ast::NodeId),\n     ResolvingFnSig(ast::NodeId),\n     ResolvingFieldTypes(ast::NodeId),\n     ResolvingAnonTy(DefId),\n@@ -504,12 +513,12 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingUpvar(upvar_id) => {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n+            ResolvingClosure(id) |\n             ResolvingFnSig(id) |\n             ResolvingFieldTypes(id) |\n             ResolvingTyNode(id) => {\n                 tcx.map.span(id)\n             }\n-            ResolvingClosure(did) |\n             ResolvingAnonTy(did) => {\n                 tcx.def_span(did)\n             }"}, {"sha": "57df0fb2cee938302af19b6001d80bcc84235eb8", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -0,0 +1,349 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Check properties that are required by built-in traits and set\n+//! up data structures required by type-checking/translation.\n+\n+use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::lang_items::UnsizeTraitLangItem;\n+\n+use rustc::traits::{self, ObligationCause, Reveal};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::ParameterEnvironment;\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::util::CopyImplementationError;\n+use rustc::infer;\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map as hir_map;\n+use rustc::hir::{self, ItemImpl};\n+\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    check_trait(tcx, tcx.lang_items.drop_trait(), visit_implementation_of_drop);\n+    check_trait(tcx, tcx.lang_items.copy_trait(), visit_implementation_of_copy);\n+    check_trait(\n+        tcx,\n+        tcx.lang_items.coerce_unsized_trait(),\n+        visit_implementation_of_coerce_unsized);\n+}\n+\n+fn check_trait<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            trait_def_id: Option<DefId>,\n+                            mut f: F)\n+    where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId, DefId)\n+{\n+    if let Some(trait_def_id) = trait_def_id {\n+        let mut impls = vec![];\n+        tcx.lookup_trait_def(trait_def_id).for_each_impl(tcx, |did| {\n+            impls.push(did);\n+        });\n+        impls.sort();\n+        for impl_def_id in impls {\n+            f(tcx, trait_def_id, impl_def_id);\n+        }\n+    }\n+}\n+\n+fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          _drop_did: DefId,\n+                                          impl_did: DefId) {\n+    let items = tcx.associated_item_def_ids(impl_did);\n+    if items.is_empty() {\n+        // We'll error out later. For now, just don't ICE.\n+        return;\n+    }\n+    let method_def_id = items[0];\n+\n+    let self_type = tcx.item_type(impl_did);\n+    match self_type.sty {\n+        ty::TyAdt(type_def, _) => {\n+            type_def.set_destructor(method_def_id);\n+        }\n+        _ => {\n+            // Destructors only work on nominal types.\n+            if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n+                match tcx.map.find(impl_node_id) {\n+                    Some(hir_map::NodeItem(item)) => {\n+                        let span = match item.node {\n+                            ItemImpl(.., ref ty, _) => ty.span,\n+                            _ => item.span,\n+                        };\n+                        struct_span_err!(tcx.sess,\n+                                         span,\n+                                         E0120,\n+                                         \"the Drop trait may only be implemented on \\\n+                                         structures\")\n+                            .span_label(span, &format!(\"implementing Drop requires a struct\"))\n+                            .emit();\n+                    }\n+                    _ => {\n+                        bug!(\"didn't find impl in ast map\");\n+                    }\n+                }\n+            } else {\n+                bug!(\"found external impl of Drop trait on \\\n+                      something other than a struct\");\n+            }\n+        }\n+    }\n+}\n+\n+fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          _copy_did: DefId,\n+                                          impl_did: DefId) {\n+    debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n+\n+    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+        n\n+    } else {\n+        debug!(\"visit_implementation_of_copy(): impl not in this \\\n+                crate\");\n+        return;\n+    };\n+\n+    let self_type = tcx.item_type(impl_did);\n+    debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n+           self_type);\n+\n+    let span = tcx.map.span(impl_node_id);\n+    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+    let self_type = self_type.subst(tcx, &param_env.free_substs);\n+    assert!(!self_type.has_escaping_regions());\n+\n+    debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n+           self_type);\n+\n+    match param_env.can_type_implement_copy(tcx, self_type, span) {\n+        Ok(()) => {}\n+        Err(CopyImplementationError::InfrigingField(field)) => {\n+            let item = tcx.map.expect_item(impl_node_id);\n+            let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n+                tr.path.span\n+            } else {\n+                span\n+            };\n+\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0204,\n+                             \"the trait `Copy` may not be implemented for this type\")\n+                .span_label(\n+                    tcx.def_span(field.did),\n+                    &\"this field does not implement `Copy`\")\n+                .emit()\n+        }\n+        Err(CopyImplementationError::NotAnAdt) => {\n+            let item = tcx.map.expect_item(impl_node_id);\n+            let span = if let ItemImpl(.., ref ty, _) = item.node {\n+                ty.span\n+            } else {\n+                span\n+            };\n+\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0206,\n+                             \"the trait `Copy` may not be implemented for this type\")\n+                .span_label(span, &format!(\"type is not a structure or enumeration\"))\n+                .emit();\n+        }\n+        Err(CopyImplementationError::HasDestructor) => {\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0184,\n+                             \"the trait `Copy` may not be implemented for this type; the \\\n+                              type has a destructor\")\n+                .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n+                .emit();\n+        }\n+    }\n+}\n+\n+fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                    coerce_unsized_trait: DefId,\n+                                                    impl_did: DefId) {\n+    debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\",\n+           impl_did);\n+\n+    let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+        Ok(id) => id,\n+        Err(err) => {\n+            tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+        }\n+    };\n+\n+    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+        n\n+    } else {\n+        debug!(\"visit_implementation_of_coerce_unsized(): impl not \\\n+                in this crate\");\n+        return;\n+    };\n+\n+    let source = tcx.item_type(impl_did);\n+    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let target = trait_ref.substs.type_at(1);\n+    debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n+           source,\n+           target);\n+\n+    let span = tcx.map.span(impl_node_id);\n+    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+    let source = source.subst(tcx, &param_env.free_substs);\n+    let target = target.subst(tcx, &param_env.free_substs);\n+    assert!(!source.has_escaping_regions());\n+\n+    debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\",\n+           source,\n+           target);\n+\n+    tcx.infer_ctxt(param_env, Reveal::ExactMatch).enter(|infcx| {\n+        let cause = ObligationCause::misc(span, impl_node_id);\n+        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n+                           mt_b: ty::TypeAndMut<'tcx>,\n+                           mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+            if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n+                infcx.report_mismatched_types(&cause,\n+                                             mk_ptr(mt_b.ty),\n+                                             target,\n+                                             ty::error::TypeError::Mutability)\n+                    .emit();\n+            }\n+            (mt_a.ty, mt_b.ty, unsize_trait, None)\n+        };\n+        let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+            (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n+\n+            (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n+                infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+            }\n+\n+            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+            (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+            }\n+\n+            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) if def_a.is_struct() &&\n+                                                                          def_b.is_struct() => {\n+                if def_a != def_b {\n+                    let source_path = tcx.item_path_str(def_a.did);\n+                    let target_path = tcx.item_path_str(def_b.did);\n+                    span_err!(tcx.sess,\n+                              span,\n+                              E0377,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures with the same \\\n+                               definition; expected {}, found {}\",\n+                              source_path,\n+                              target_path);\n+                    return;\n+                }\n+\n+                let fields = &def_a.struct_variant().fields;\n+                let diff_fields = fields.iter()\n+                    .enumerate()\n+                    .filter_map(|(i, f)| {\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                        if tcx.item_type(f.did).is_phantom_data() {\n+                            // Ignore PhantomData fields\n+                            return None;\n+                        }\n+\n+                        // Ignore fields that aren't significantly changed\n+                        if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n+                            if ok.obligations.is_empty() {\n+                                return None;\n+                            }\n+                        }\n+\n+                        // Collect up all fields that were significantly changed\n+                        // i.e. those that contain T in coerce_unsized T -> U\n+                        Some((i, a, b))\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if diff_fields.is_empty() {\n+                    span_err!(tcx.sess,\n+                              span,\n+                              E0374,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures with one field \\\n+                               being coerced, none found\");\n+                    return;\n+                } else if diff_fields.len() > 1 {\n+                    let item = tcx.map.expect_item(impl_node_id);\n+                    let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n+                        t.path.span\n+                    } else {\n+                        tcx.map.span(impl_node_id)\n+                    };\n+\n+                    let mut err = struct_span_err!(tcx.sess,\n+                                                   span,\n+                                                   E0375,\n+                                                   \"implementing the trait \\\n+                                                    `CoerceUnsized` requires multiple \\\n+                                                    coercions\");\n+                    err.note(\"`CoerceUnsized` may only be implemented for \\\n+                              a coercion between structures with one field being coerced\");\n+                    err.note(&format!(\"currently, {} fields need coercions: {}\",\n+                                      diff_fields.len(),\n+                                      diff_fields.iter()\n+                                          .map(|&(i, a, b)| {\n+                                              format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                          })\n+                                          .collect::<Vec<_>>()\n+                                          .join(\", \")));\n+                    err.span_label(span, &format!(\"requires multiple coercions\"));\n+                    err.emit();\n+                    return;\n+                }\n+\n+                let (i, a, b) = diff_fields[0];\n+                let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n+                (a, b, coerce_unsized_trait, Some(kind))\n+            }\n+\n+            _ => {\n+                span_err!(tcx.sess,\n+                          span,\n+                          E0376,\n+                          \"the trait `CoerceUnsized` may only be implemented \\\n+                           for a coercion between structures\");\n+                return;\n+            }\n+        };\n+\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+        // Register an obligation for `A: Trait<B>`.\n+        let cause = traits::ObligationCause::misc(span, impl_node_id);\n+        let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+\n+        // Check that all transitive obligations are satisfied.\n+        if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(&errors);\n+        }\n+\n+        // Finally, resolve all regions.\n+        let mut free_regions = FreeRegionMap::new();\n+        free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+            .caller_bounds);\n+        infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+\n+        if let Some(kind) = kind {\n+            tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+        }\n+    });\n+}"}, {"sha": "6cf752dd69fcadea7d82f05ab89999e0c817c87a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 18, "deletions": 384, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,45 +16,33 @@\n // mappings. That mapping code resides here.\n \n use hir::def_id::DefId;\n-use middle::lang_items::UnsizeTraitLangItem;\n-use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::traits::{self, ObligationCause, Reveal};\n-use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n-use rustc::ty::util::CopyImplementationError;\n-use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n-use rustc::infer::{self, InferCtxt};\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::map as hir_map;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n+mod builtin;\n mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    crate_context: &'a CrateCtxt<'a, 'gcx>,\n-    inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n+struct CoherenceChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-struct CoherenceCheckVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>,\n-}\n-\n-impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceChecker<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n-            self.cc.check_implementation(item)\n+            self.check_implementation(item)\n         }\n     }\n \n@@ -65,15 +53,15 @@ impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx,\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n             TyAdt(def, _) => Some(def.did),\n \n             TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n \n-            TyBox(_) => self.inference_context.tcx.lang_items.owned_box(),\n+            TyBox(_) => self.tcx.lang_items.owned_box(),\n \n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n             TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n@@ -89,36 +77,22 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check(&self) {\n+    fn check(&mut self) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        self.crate_context.tcx.visit_all_item_likes_in_krate(\n-            DepNode::CoherenceCheckImpl,\n-            &mut CoherenceCheckVisitor { cc: self });\n-\n-        // Populate the table of destructors. It might seem a bit strange to\n-        // do this here, but it's actually the most convenient place, since\n-        // the coherence tables contain the trait -> type mappings.\n-        self.populate_destructors();\n-\n-        // Check to make sure implementations of `Copy` are legal.\n-        self.check_implementations_of_copy();\n-\n-        // Check to make sure implementations of `CoerceUnsized` are legal\n-        // and collect the necessary information from them.\n-        self.check_implementations_of_coerce_unsized();\n+        self.tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, self);\n     }\n \n     fn check_implementation(&self, item: &Item) {\n-        let tcx = self.crate_context.tcx;\n+        let tcx = self.tcx;\n         let impl_did = tcx.map.local_def_id(item.id);\n         let self_type = tcx.item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n \n-        if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n                    item.name);\n@@ -129,9 +103,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             }\n \n-            enforce_trait_manually_implementable(self.crate_context.tcx,\n-                                                 item.span,\n-                                                 trait_ref.def_id);\n+            enforce_trait_manually_implementable(self.tcx, item.span, trait_ref.def_id);\n             self.add_trait_impl(trait_ref, impl_did);\n         } else {\n             // Skip inherent impls where the self type is an error\n@@ -150,348 +122,15 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n+        self.tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n     }\n \n-    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n+    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref,\n                impl_def_id);\n-        let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n-        trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n-    }\n-\n-    // Destructors\n-    //\n-\n-    fn populate_destructors(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let drop_trait = match tcx.lang_items.drop_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n-        let drop_trait = tcx.lookup_trait_def(drop_trait);\n-\n-        drop_trait.for_each_impl(tcx, |impl_did| {\n-            let items = tcx.associated_item_def_ids(impl_did);\n-            if items.is_empty() {\n-                // We'll error out later. For now, just don't ICE.\n-                return;\n-            }\n-            let method_def_id = items[0];\n-\n-            let self_type = tcx.item_type(impl_did);\n-            match self_type.sty {\n-                ty::TyAdt(type_def, _) => {\n-                    type_def.set_destructor(method_def_id);\n-                }\n-                _ => {\n-                    // Destructors only work on nominal types.\n-                    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n-                        match tcx.map.find(impl_node_id) {\n-                            Some(hir_map::NodeItem(item)) => {\n-                                let span = match item.node {\n-                                    ItemImpl(.., ref ty, _) => ty.span,\n-                                    _ => item.span,\n-                                };\n-                                struct_span_err!(tcx.sess,\n-                                                 span,\n-                                                 E0120,\n-                                                 \"the Drop trait may only be implemented on \\\n-                                                  structures\")\n-                                    .span_label(span,\n-                                                &format!(\"implementing Drop requires a struct\"))\n-                                    .emit();\n-                            }\n-                            _ => {\n-                                bug!(\"didn't find impl in ast map\");\n-                            }\n-                        }\n-                    } else {\n-                        bug!(\"found external impl of Drop trait on \\\n-                              something other than a struct\");\n-                    }\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Ensures that implementations of the built-in trait `Copy` are legal.\n-    fn check_implementations_of_copy(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let copy_trait = match tcx.lang_items.copy_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        tcx.populate_implementations_for_trait_if_necessary(copy_trait);\n-        let copy_trait = tcx.lookup_trait_def(copy_trait);\n-\n-        copy_trait.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_copy: impl_did={:?}\", impl_did);\n-\n-            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-                n\n-            } else {\n-                debug!(\"check_implementations_of_copy(): impl not in this \\\n-                        crate\");\n-                return;\n-            };\n-\n-            let self_type = tcx.item_type(impl_did);\n-            debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n-                   self_type);\n-\n-            let span = tcx.map.span(impl_node_id);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let self_type = self_type.subst(tcx, &param_env.free_substs);\n-            assert!(!self_type.has_escaping_regions());\n-\n-            debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n-                   self_type);\n-\n-            match param_env.can_type_implement_copy(tcx, self_type, span) {\n-                Ok(()) => {}\n-                Err(CopyImplementationError::InfrigingField(name)) => {\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0204,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n-                        .emit()\n-                }\n-                Err(CopyImplementationError::InfrigingVariant(name)) => {\n-                    let item = tcx.map.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n-                        tr.path.span\n-                    } else {\n-                        span\n-                    };\n-\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0205,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span,\n-                                    &format!(\"variant `{}` does not implement `Copy`\", name))\n-                        .emit()\n-                }\n-                Err(CopyImplementationError::NotAnAdt) => {\n-                    let item = tcx.map.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., ref ty, _) = item.node {\n-                        ty.span\n-                    } else {\n-                        span\n-                    };\n-\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0206,\n-                                     \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"type is not a structure or enumeration\"))\n-                        .emit();\n-                }\n-                Err(CopyImplementationError::HasDestructor) => {\n-                    struct_span_err!(tcx.sess,\n-                                     span,\n-                                     E0184,\n-                                     \"the trait `Copy` may not be implemented for this type; the \\\n-                                      type has a destructor\")\n-                        .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n-                        .emit();\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Process implementations of the built-in trait `CoerceUnsized`.\n-    fn check_implementations_of_coerce_unsized(&self) {\n-        let tcx = self.crate_context.tcx;\n-        let coerce_unsized_trait = match tcx.lang_items.coerce_unsized_trait() {\n-            Some(id) => id,\n-            None => return,\n-        };\n-        let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n-            Ok(id) => id,\n-            Err(err) => {\n-                tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n-            }\n-        };\n-\n-        let trait_def = tcx.lookup_trait_def(coerce_unsized_trait);\n-\n-        trait_def.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n-                   impl_did);\n-\n-            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-                n\n-            } else {\n-                debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n-                        in this crate\");\n-                return;\n-            };\n-\n-            let source = tcx.item_type(impl_did);\n-            let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n-            let target = trait_ref.substs.type_at(1);\n-            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n-                   source,\n-                   target);\n-\n-            let span = tcx.map.span(impl_node_id);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-            let source = source.subst(tcx, &param_env.free_substs);\n-            let target = target.subst(tcx, &param_env.free_substs);\n-            assert!(!source.has_escaping_regions());\n-\n-            debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n-                   source,\n-                   target);\n-\n-            tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n-                let cause = ObligationCause::misc(span, impl_node_id);\n-                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n-                                   mt_b: ty::TypeAndMut<'gcx>,\n-                                   mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n-                    if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                        infcx.report_mismatched_types(&cause,\n-                                                      mk_ptr(mt_b.ty),\n-                                                      target,\n-                                                      ty::error::TypeError::Mutability).emit();\n-                    }\n-                    (mt_a.ty, mt_b.ty, unsize_trait, None)\n-                };\n-                let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-                    (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n-\n-                    (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                        infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n-                    }\n-\n-                    (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n-                    (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                        check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n-                    }\n-\n-                    (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n-                        if def_a.is_struct() && def_b.is_struct() => {\n-                        if def_a != def_b {\n-                            let source_path = tcx.item_path_str(def_a.did);\n-                            let target_path = tcx.item_path_str(def_b.did);\n-                            span_err!(tcx.sess,\n-                                      span,\n-                                      E0377,\n-                                      \"the trait `CoerceUnsized` may only be implemented \\\n-                                       for a coercion between structures with the same \\\n-                                       definition; expected {}, found {}\",\n-                                      source_path,\n-                                      target_path);\n-                            return;\n-                        }\n-\n-                        let fields = &def_a.struct_variant().fields;\n-                        let diff_fields = fields.iter()\n-                            .enumerate()\n-                            .filter_map(|(i, f)| {\n-                                let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                                if tcx.item_type(f.did).is_phantom_data() {\n-                                    // Ignore PhantomData fields\n-                                    return None;\n-                                }\n-\n-                                // Ignore fields that aren't significantly changed\n-                                if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n-                                    if ok.obligations.is_empty() {\n-                                        return None;\n-                                    }\n-                                }\n-\n-                                // Collect up all fields that were significantly changed\n-                                // i.e. those that contain T in coerce_unsized T -> U\n-                                Some((i, a, b))\n-                            })\n-                            .collect::<Vec<_>>();\n-\n-                        if diff_fields.is_empty() {\n-                            span_err!(tcx.sess,\n-                                      span,\n-                                      E0374,\n-                                      \"the trait `CoerceUnsized` may only be implemented \\\n-                                       for a coercion between structures with one field \\\n-                                       being coerced, none found\");\n-                            return;\n-                        } else if diff_fields.len() > 1 {\n-                            let item = tcx.map.expect_item(impl_node_id);\n-                            let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n-                                t.path.span\n-                            } else {\n-                                tcx.map.span(impl_node_id)\n-                            };\n-\n-                            let mut err = struct_span_err!(tcx.sess,\n-                                                           span,\n-                                                           E0375,\n-                                                           \"implementing the trait \\\n-                                                            `CoerceUnsized` requires multiple \\\n-                                                            coercions\");\n-                            err.note(\"`CoerceUnsized` may only be implemented for \\\n-                                      a coercion between structures with one field being coerced\");\n-                            err.note(&format!(\"currently, {} fields need coercions: {}\",\n-                                              diff_fields.len(),\n-                                              diff_fields.iter()\n-                                                  .map(|&(i, a, b)| {\n-                                                      format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                                  })\n-                                                  .collect::<Vec<_>>()\n-                                                  .join(\", \")));\n-                            err.span_label(span, &format!(\"requires multiple coercions\"));\n-                            err.emit();\n-                            return;\n-                        }\n-\n-                        let (i, a, b) = diff_fields[0];\n-                        let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n-                        (a, b, coerce_unsized_trait, Some(kind))\n-                    }\n-\n-                    _ => {\n-                        span_err!(tcx.sess,\n-                                  span,\n-                                  E0376,\n-                                  \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures\");\n-                        return;\n-                    }\n-                };\n-\n-                let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-                // Register an obligation for `A: Trait<B>`.\n-                let cause = traits::ObligationCause::misc(span, impl_node_id);\n-                let predicate =\n-                    tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-\n-                // Check that all transitive obligations are satisfied.\n-                if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&errors);\n-                }\n-\n-                // Finally, resolve all regions.\n-                let mut free_regions = FreeRegionMap::new();\n-                free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n-                    .caller_bounds);\n-                infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n-\n-                if let Some(kind) = kind {\n-                    tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n-                }\n-            });\n-        });\n+        let trait_def = self.tcx.lookup_trait_def(impl_trait_ref.def_id);\n+        trait_def.record_local_impl(self.tcx, impl_def_id, impl_trait_ref);\n     }\n }\n \n@@ -524,14 +163,9 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    ccx.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n-        CoherenceChecker {\n-                crate_context: ccx,\n-                inference_context: infcx,\n-            }\n-            .check();\n-    });\n+    CoherenceChecker { tcx: ccx.tcx }.check();\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);\n     overlap::check(ccx.tcx);\n+    builtin::check(ccx.tcx);\n }"}, {"sha": "08293c1d874a8d7cb75cd5876ba91a963fc9fb5b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -87,7 +87,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n+                self.tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "f832bf8d86e939bdcd7689d0911e2979ff3ebbf6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -63,7 +63,7 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n-use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n+use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n@@ -1039,8 +1039,9 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     adt\n }\n \n-    fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n+    fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n                           -> Option<ty::Disr> {\n+        let e = &ccx.tcx.map.body(body).value;\n         debug!(\"disr expr, checking {}\", ccx.tcx.map.node_to_pretty_string(e.id));\n \n         let ty_hint = repr_ty.to_ty(ccx.tcx);\n@@ -1052,9 +1053,9 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         };\n \n         let hint = UncheckedExprHint(ty_hint);\n-        match eval_const_expr_partial(ccx.tcx, e, hint, None) {\n+        match ConstContext::new(ccx.tcx, body).eval(e, hint) {\n             Ok(ConstVal::Integral(i)) => {\n-                // FIXME: eval_const_expr_partial should return an error if the hint is wrong\n+                // FIXME: eval should return an error if the hint is wrong\n                 match (repr_ty, i) {\n                     (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n                     (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n@@ -1103,7 +1104,6 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let variants = def.variants.iter().map(|v| {\n         let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n         let disr = if let Some(e) = v.node.disr_expr {\n-            let e = &tcx.map.body(e).value;\n             evaluate_disr_expr(ccx, repr_type, e)\n         } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n             Some(disr)"}, {"sha": "1a971be64d81923d528313df3b01b0d892c7f251", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -2300,6 +2300,7 @@ This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n \n+/*\n E0205: r##\"\n An attempt to implement the `Copy` trait for an enum failed because one of the\n variants does not implement `Copy`. To fix this, you must implement `Copy` for\n@@ -2329,6 +2330,7 @@ enum Foo<'a> {\n This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n differs from the behavior for `&T`, which is always `Copy`).\n \"##,\n+*/\n \n E0206: r##\"\n You can only implement `Copy` for a struct or enum. Both of the following"}, {"sha": "6d30a85b582912a7f108a5908588a88333dc564b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -70,7 +70,7 @@ This API is completely unstable and subject to change.\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![allow(non_camel_case_types)]\n \n@@ -177,7 +177,7 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    ccx.tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n+    ccx.tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n         match infcx.eq_types(false, &cause, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations"}, {"sha": "93c0bd6d6d836fb646f64c781d02d05949126e29", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -14,7 +14,6 @@ arena = { path = \"../libarena\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_driver = { path = \"../librustc_driver\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "6a640e7b5ed80a0cccd23c31d6342a2717e70267", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1692,22 +1692,10 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n-            TyArray(ref ty, e) => {\n-                use rustc_const_math::{ConstInt, ConstUsize};\n-                use rustc_const_eval::eval_const_expr;\n-                use rustc::middle::const_val::ConstVal;\n-\n-                let e = &cx.tcx.map.body(e).value;\n-                let n = match eval_const_expr(cx.tcx, e) {\n-                    ConstVal::Integral(ConstInt::Usize(u)) => match u {\n-                        ConstUsize::Us16(u) => u.to_string(),\n-                        ConstUsize::Us32(u) => u.to_string(),\n-                        ConstUsize::Us64(u) => u.to_string(),\n-                    },\n-                    // after type checking this can't fail\n-                    _ => unreachable!(),\n-                };\n-                FixedVector(box ty.clean(cx), n)\n+            TyArray(ref ty, length) => {\n+                use rustc_const_eval::eval_length;\n+                let n = eval_length(cx.tcx, length, \"array length\").unwrap();\n+                FixedVector(box ty.clean(cx), n.to_string())\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(hir::QPath::Resolved(None, ref path)) => {\n@@ -2219,8 +2207,8 @@ impl Path {\n         }\n     }\n \n-    pub fn last_name(&self) -> String {\n-        self.segments.last().unwrap().name.clone()\n+    pub fn last_name(&self) -> &str {\n+        self.segments.last().unwrap().name.as_str()\n     }\n }\n "}, {"sha": "514eb6ea843defc4d24b501278b3118d568145ff", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -156,9 +156,15 @@ pub fn run_core(search_paths: SearchPaths,\n     let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n \n     let driver::ExpansionResult { defs, analysis, resolutions, mut hir_forest, .. } = {\n-        driver::phase_2_configure_and_expand(\n-            &sess, &cstore, krate, None, &name, None, resolve::MakeGlobMap::No, |_| Ok(()),\n-        ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n+        let result = driver::phase_2_configure_and_expand(&sess,\n+                                                          &cstore,\n+                                                          krate,\n+                                                          None,\n+                                                          &name,\n+                                                          None,\n+                                                          resolve::MakeGlobMap::No,\n+                                                          |_| Ok(()));\n+        abort_on_err(result, &sess)\n     };\n \n     let arena = DroplessArena::new();"}, {"sha": "716ad05401d03036a459da76f97ccdcc89ab4f3b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 183, "deletions": 164, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -433,7 +433,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n-                 print_all: bool) -> fmt::Result {\n+                 print_all: bool, use_absolute: bool) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n     let rel_root = match &*path.segments[0].name {\n         \"self\" => Some(\"./\".to_string()),\n@@ -467,7 +467,17 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n     if w.alternate() {\n         write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n     } else {\n-        write!(w, \"{}{}\", HRef::new(did, &last.name), last.params)?;\n+        let path = if use_absolute {\n+            match href(did) {\n+                Some((_, _, fqp)) => format!(\"{}::{}\",\n+                                             fqp[..fqp.len()-1].join(\"::\"),\n+                                             HRef::new(did, fqp.last().unwrap())),\n+                None => format!(\"{}\", HRef::new(did, &last.name)),\n+            }\n+        } else {\n+            format!(\"{}\", HRef::new(did, &last.name))\n+        };\n+        write!(w, \"{}{}\", path, last.params)?;\n     }\n     Ok(())\n }\n@@ -551,194 +561,201 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            clean::Generic(ref name) => {\n-                f.write_str(name)\n-            }\n-            clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n-                // Paths like T::Output and Self::Output should be rendered with all segments\n-                resolved_path(f, did, path, is_generic)?;\n-                tybounds(f, typarams)\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt::Result {\n+    match *t {\n+        clean::Generic(ref name) => {\n+            f.write_str(name)\n+        }\n+        clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n+            // Paths like T::Output and Self::Output should be rendered with all segments\n+            resolved_path(f, did, path, is_generic, use_absolute)?;\n+            tybounds(f, typarams)\n+        }\n+        clean::Infer => write!(f, \"_\"),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n+        clean::BareFunction(ref decl) => {\n+            if f.alternate() {\n+                write!(f, \"{}{}fn{:#}{:#}\",\n+                       UnsafetySpace(decl.unsafety),\n+                       AbiSpace(decl.abi),\n+                       decl.generics,\n+                       decl.decl)\n+            } else {\n+                write!(f, \"{}{}fn{}{}\",\n+                       UnsafetySpace(decl.unsafety),\n+                       AbiSpace(decl.abi),\n+                       decl.generics,\n+                       decl.decl)\n             }\n-            clean::Infer => write!(f, \"_\"),\n-            clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n-            clean::BareFunction(ref decl) => {\n-                if f.alternate() {\n-                    write!(f, \"{}{}fn{:#}{:#}\",\n-                           UnsafetySpace(decl.unsafety),\n-                           AbiSpace(decl.abi),\n-                           decl.generics,\n-                           decl.decl)\n-                } else {\n-                    write!(f, \"{}{}fn{}{}\",\n-                           UnsafetySpace(decl.unsafety),\n-                           AbiSpace(decl.abi),\n-                           decl.generics,\n-                           decl.decl)\n+        }\n+        clean::Tuple(ref typs) => {\n+            match &typs[..] {\n+                &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n+                &[ref one] => {\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    //carry f.alternate() into this display w/o branching manually\n+                    fmt::Display::fmt(one, f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n-            }\n-            clean::Tuple(ref typs) => {\n-                match &typs[..] {\n-                    &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n-                    &[ref one] => {\n-                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        //carry f.alternate() into this display w/o branching manually\n-                        fmt::Display::fmt(one, f)?;\n-                        primitive_link(f, PrimitiveType::Tuple, \",)\")\n-                    }\n-                    many => {\n-                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        fmt::Display::fmt(&CommaSep(&many), f)?;\n-                        primitive_link(f, PrimitiveType::Tuple, \")\")\n-                    }\n+                many => {\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    fmt::Display::fmt(&CommaSep(&many), f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n-            clean::Vector(ref t) => {\n-                primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n-                fmt::Display::fmt(t, f)?;\n-                primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n-            }\n-            clean::FixedVector(ref t, ref s) => {\n-                primitive_link(f, PrimitiveType::Array, \"[\")?;\n-                fmt::Display::fmt(t, f)?;\n-                if f.alternate() {\n-                    primitive_link(f, PrimitiveType::Array,\n-                                   &format!(\"; {}]\", s))\n-                } else {\n-                    primitive_link(f, PrimitiveType::Array,\n-                                   &format!(\"; {}]\", Escape(s)))\n-                }\n+        }\n+        clean::Vector(ref t) => {\n+            primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n+            fmt::Display::fmt(t, f)?;\n+            primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n+        }\n+        clean::FixedVector(ref t, ref s) => {\n+            primitive_link(f, PrimitiveType::Array, \"[\")?;\n+            fmt::Display::fmt(t, f)?;\n+            if f.alternate() {\n+                primitive_link(f, PrimitiveType::Array,\n+                               &format!(\"; {}]\", s))\n+            } else {\n+                primitive_link(f, PrimitiveType::Array,\n+                               &format!(\"; {}]\", Escape(s)))\n             }\n-            clean::Never => f.write_str(\"!\"),\n-            clean::RawPointer(m, ref t) => {\n-                match **t {\n-                    clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                        if f.alternate() {\n-                            primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                           &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n-                        } else {\n-                            primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                           &format!(\"*{}{}\", RawMutableSpace(m), t))\n-                        }\n-                    }\n-                    _ => {\n+        }\n+        clean::Never => f.write_str(\"!\"),\n+        clean::RawPointer(m, ref t) => {\n+            match **t {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n+                    if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}\", RawMutableSpace(m)))?;\n-                        fmt::Display::fmt(t, f)\n+                                       &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n+                    } else {\n+                        primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                       &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                 }\n+                _ => {\n+                    primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                   &format!(\"*{}\", RawMutableSpace(m)))?;\n+                    fmt::Display::fmt(t, f)\n+                }\n             }\n-            clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-                let lt = match *l {\n-                    Some(ref l) => format!(\"{} \", *l),\n-                    _ => \"\".to_string(),\n-                };\n-                let m = MutableSpace(mutability);\n-                match **ty {\n-                    clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n-                        match **bt {\n-                            clean::Generic(_) =>\n-                                if f.alternate() {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                        &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n-                                } else {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                        &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n-                                },\n-                            _ => {\n-                                if f.alternate() {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                                   &format!(\"&{}{}[\", lt, m))?;\n-                                    write!(f, \"{:#}\", **bt)?;\n-                                } else {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                                   &format!(\"&amp;{}{}[\", lt, m))?;\n-                                    write!(f, \"{}\", **bt)?;\n-                                }\n-                                primitive_link(f, PrimitiveType::Slice, \"]\")\n+        }\n+        clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n+            let lt = match *l {\n+                Some(ref l) => format!(\"{} \", *l),\n+                _ => \"\".to_string(),\n+            };\n+            let m = MutableSpace(mutability);\n+            match **ty {\n+                clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n+                    match **bt {\n+                        clean::Generic(_) =>\n+                            if f.alternate() {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                    &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n+                            } else {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                    &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n+                            },\n+                        _ => {\n+                            if f.alternate() {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&{}{}[\", lt, m))?;\n+                                write!(f, \"{:#}\", **bt)?;\n+                            } else {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&amp;{}{}[\", lt, m))?;\n+                                write!(f, \"{}\", **bt)?;\n                             }\n-                        }\n-                    }\n-                    _ => {\n-                        if f.alternate() {\n-                            write!(f, \"&{}{}{:#}\", lt, m, **ty)\n-                        } else {\n-                            write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n+                            primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n                     }\n                 }\n-            }\n-            clean::PolyTraitRef(ref bounds) => {\n-                for (i, bound) in bounds.iter().enumerate() {\n-                    if i != 0 {\n-                        write!(f, \" + \")?;\n-                    }\n+                _ => {\n                     if f.alternate() {\n-                        write!(f, \"{:#}\", *bound)?;\n+                        write!(f, \"&{}{}{:#}\", lt, m, **ty)\n                     } else {\n-                        write!(f, \"{}\", *bound)?;\n+                        write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n                     }\n                 }\n-                Ok(())\n             }\n-            clean::ImplTrait(ref bounds) => {\n-                write!(f, \"impl \")?;\n-                for (i, bound) in bounds.iter().enumerate() {\n-                    if i != 0 {\n-                        write!(f, \" + \")?;\n-                    }\n-                    if f.alternate() {\n-                        write!(f, \"{:#}\", *bound)?;\n-                    } else {\n-                        write!(f, \"{}\", *bound)?;\n-                    }\n+        }\n+        clean::PolyTraitRef(ref bounds) => {\n+            for (i, bound) in bounds.iter().enumerate() {\n+                if i != 0 {\n+                    write!(f, \" + \")?;\n                 }\n-                Ok(())\n-            }\n-            // It's pretty unsightly to look at `<A as B>::C` in output, and\n-            // we've got hyperlinking on our side, so try to avoid longer\n-            // notation as much as possible by making `C` a hyperlink to trait\n-            // `B` to disambiguate.\n-            //\n-            // FIXME: this is still a lossy conversion and there should probably\n-            //        be a better way of representing this in general? Most of\n-            //        the ugliness comes from inlining across crates where\n-            //        everything comes in as a fully resolved QPath (hard to\n-            //        look at).\n-            clean::QPath {\n-                ref name,\n-                ref self_type,\n-                trait_: box clean::ResolvedPath { did, ref typarams, .. },\n-            } => {\n                 if f.alternate() {\n-                    write!(f, \"{:#}::\", self_type)?;\n+                    write!(f, \"{:#}\", *bound)?;\n                 } else {\n-                    write!(f, \"{}::\", self_type)?;\n+                    write!(f, \"{}\", *bound)?;\n                 }\n-                let path = clean::Path::singleton(name.clone());\n-                resolved_path(f, did, &path, false)?;\n-\n-                // FIXME: `typarams` are not rendered, and this seems bad?\n-                drop(typarams);\n-                Ok(())\n             }\n-            clean::QPath { ref name, ref self_type, ref trait_ } => {\n+            Ok(())\n+        }\n+        clean::ImplTrait(ref bounds) => {\n+            write!(f, \"impl \")?;\n+            for (i, bound) in bounds.iter().enumerate() {\n+                if i != 0 {\n+                    write!(f, \" + \")?;\n+                }\n                 if f.alternate() {\n-                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                    write!(f, \"{:#}\", *bound)?;\n                 } else {\n-                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                    write!(f, \"{}\", *bound)?;\n                 }\n             }\n-            clean::Unique(..) => {\n-                panic!(\"should have been cleaned\")\n+            Ok(())\n+        }\n+        // It's pretty unsightly to look at `<A as B>::C` in output, and\n+        // we've got hyperlinking on our side, so try to avoid longer\n+        // notation as much as possible by making `C` a hyperlink to trait\n+        // `B` to disambiguate.\n+        //\n+        // FIXME: this is still a lossy conversion and there should probably\n+        //        be a better way of representing this in general? Most of\n+        //        the ugliness comes from inlining across crates where\n+        //        everything comes in as a fully resolved QPath (hard to\n+        //        look at).\n+        clean::QPath {\n+            ref name,\n+            ref self_type,\n+            trait_: box clean::ResolvedPath { did, ref typarams, .. },\n+        } => {\n+            if f.alternate() {\n+                write!(f, \"{:#}::\", self_type)?;\n+            } else {\n+                write!(f, \"{}::\", self_type)?;\n+            }\n+            let path = clean::Path::singleton(name.clone());\n+            resolved_path(f, did, &path, true, use_absolute)?;\n+\n+            // FIXME: `typarams` are not rendered, and this seems bad?\n+            drop(typarams);\n+            Ok(())\n+        }\n+        clean::QPath { ref name, ref self_type, ref trait_ } => {\n+            if f.alternate() {\n+                write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+            } else {\n+                write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n             }\n         }\n+        clean::Unique(..) => {\n+            panic!(\"should have been cleaned\")\n+        }\n+    }\n+}\n+\n+impl fmt::Display for clean::Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt_type(self, f, false)\n     }\n }\n \n-fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::Result {\n+fn fmt_impl(i: &clean::Impl,\n+            f: &mut fmt::Formatter,\n+            link_trait: bool,\n+            use_absolute: bool) -> fmt::Result {\n     let mut plain = String::new();\n \n     if f.alternate() {\n@@ -759,7 +776,7 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n             plain.push_str(&format!(\"{:#}\", ty));\n         } else {\n             match *ty {\n-                clean::ResolvedPath{ typarams: None, ref path, is_generic: false, .. } => {\n+                clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.params, f)?;\n@@ -772,7 +789,7 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n         plain.push_str(\" for \");\n     }\n \n-    fmt::Display::fmt(&i.for_, f)?;\n+    fmt_type(&i.for_, f, use_absolute)?;\n     plain.push_str(&format!(\"{:#}\", i.for_));\n \n     fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n@@ -781,13 +798,15 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n \n impl fmt::Display for clean::Impl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt_impl(self, f, true)\n+        fmt_impl(self, f, true, false)\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n-pub fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut fmt::Formatter) -> fmt::Result {\n-    fmt_impl(i, f, false)\n+pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n+                               f: &mut fmt::Formatter,\n+                               use_absolute: bool) -> fmt::Result {\n+    fmt_impl(i, f, false, use_absolute)\n }\n \n impl fmt::Display for clean::Arguments {\n@@ -978,7 +997,7 @@ impl fmt::Display for clean::Import {\n impl fmt::Display for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true),\n+            Some(did) => resolved_path(f, did, &self.path, true, false),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {"}, {"sha": "a031be8b3c2be598bd34fadcaf0fc62a3df96bae", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -218,9 +218,11 @@ impl<'a> Classifier<'a> {\n             token::Comment => Class::Comment,\n             token::DocComment(..) => Class::DocComment,\n \n-            // If this '&' token is directly adjacent to another token, assume\n-            // that it's the address-of operator instead of the and-operator.\n-            token::BinOp(token::And) if self.lexer.peek().sp.lo == tas.sp.hi => Class::RefKeyWord,\n+            // If this '&' or '*' token is followed by a non-whitespace token, assume that it's the\n+            // reference or dereference operator or a reference or pointer type, instead of the\n+            // bit-and or multiplication operator.\n+            token::BinOp(token::And) | token::BinOp(token::Star)\n+                if self.lexer.peek().tok != token::Whitespace => Class::RefKeyWord,\n \n             // Consider this as part of a macro invocation if there was a\n             // leading identifier."}, {"sha": "f2427008a7d45f830d9b8ac838740fae8633dcc9", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -49,6 +49,8 @@ pub struct Markdown<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n+/// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n+pub struct MarkdownHtml<'a>(pub &'a str);\n \n const DEF_OUNIT: libc::size_t = 64;\n const HOEDOWN_EXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 11;\n@@ -58,6 +60,7 @@ const HOEDOWN_EXT_AUTOLINK: libc::c_uint = 1 << 3;\n const HOEDOWN_EXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n const HOEDOWN_EXT_SUPERSCRIPT: libc::c_uint = 1 << 8;\n const HOEDOWN_EXT_FOOTNOTES: libc::c_uint = 1 << 2;\n+const HOEDOWN_HTML_ESCAPE: libc::c_uint = 1 << 1;\n \n const HOEDOWN_EXTENSIONS: libc::c_uint =\n     HOEDOWN_EXT_NO_INTRA_EMPHASIS | HOEDOWN_EXT_TABLES |\n@@ -220,7 +223,11 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n     RefCell::new(None)\n });\n \n-pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n+\n+pub fn render(w: &mut fmt::Formatter,\n+              s: &str,\n+              print_toc: bool,\n+              html_flags: libc::c_uint) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer, data: *const hoedown_renderer_data) {\n         unsafe {\n@@ -383,7 +390,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n-        let renderer = hoedown_html_renderer_new(0, 0);\n+        let renderer = hoedown_html_renderer_new(html_flags, 0);\n         let mut opaque = MyOpaque {\n             dfltblk: (*renderer).blockcode.unwrap(),\n             toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n@@ -553,14 +560,23 @@ impl<'a> fmt::Display for Markdown<'a> {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false)\n+        render(fmt, md, false, 0)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md, true)\n+        render(fmt, md, true, 0)\n+    }\n+}\n+\n+impl<'a> fmt::Display for MarkdownHtml<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let MarkdownHtml(md) = *self;\n+        // This is actually common enough to special-case\n+        if md.is_empty() { return Ok(()) }\n+        render(fmt, md, false, HOEDOWN_HTML_ESCAPE)\n     }\n }\n \n@@ -613,7 +629,7 @@ pub fn plain_summary_line(md: &str) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown};\n+    use super::{LangString, Markdown, MarkdownHtml};\n     use super::plain_summary_line;\n     use html::render::reset_ids;\n \n@@ -719,4 +735,15 @@ mod tests {\n         t(\"# top header\", \"top header\");\n         t(\"## header\", \"header\");\n     }\n+\n+    #[test]\n+    fn test_markdown_html_escape() {\n+        fn t(input: &str, expect: &str) {\n+            let output = format!(\"{}\", MarkdownHtml(input));\n+            assert_eq!(output, expect);\n+        }\n+\n+        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;&#39;a, T&gt;</code></p>\\n\");\n+        t(\"Struct<'a, T>\", \"<p>Struct&lt;&#39;a, T&gt;</p>\\n\");\n+    }\n }"}, {"sha": "e161f40b7295e4593ca0875ada4ee75e9f0c95f0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -71,7 +71,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown};\n+use html::markdown::{self, Markdown, MarkdownHtml};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -1866,13 +1866,15 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             } else {\n                 String::new()\n             };\n-            let text = format!(\"Deprecated{}{}\", since, Markdown(&deprecated_reason));\n+            let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&deprecated_reason));\n             stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n         };\n \n         if stab.level == stability::Unstable {\n-            let unstable_extra = if show_reason {\n-                match (!stab.feature.is_empty(), &cx.shared.issue_tracker_base_url, stab.issue) {\n+            if show_reason {\n+                let unstable_extra = match (!stab.feature.is_empty(),\n+                                            &cx.shared.issue_tracker_base_url,\n+                                            stab.issue) {\n                     (true, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<code>{}</code> <a href=\\\"{}{}\\\">#{}</a>)\",\n                                 Escape(&stab.feature), tracker_url, issue_no, issue_no),\n@@ -1882,17 +1884,22 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                     (true, ..) =>\n                         format!(\" (<code>{}</code>)\", Escape(&stab.feature)),\n                     _ => String::new(),\n+                };\n+                if stab.unstable_reason.is_empty() {\n+                    stability.push(format!(\"<div class='stab unstable'>\\\n+                                            <span class=microscope>\ud83d\udd2c</span> \\\n+                                            This is a nightly-only experimental API. {}</div>\",\n+                                   unstable_extra));\n+                } else {\n+                    let text = format!(\"<summary><span class=microscope>\ud83d\udd2c</span> \\\n+                                        This is a nightly-only experimental API. {}</summary>{}\",\n+                                       unstable_extra, MarkdownHtml(&stab.unstable_reason));\n+                    stability.push(format!(\"<div class='stab unstable'><details>{}</details></div>\",\n+                                   text));\n                 }\n             } else {\n-                String::new()\n-            };\n-            let unstable_reason = if show_reason && !stab.unstable_reason.is_empty() {\n-                format!(\": {}\", stab.unstable_reason)\n-            } else {\n-                String::new()\n-            };\n-            let text = format!(\"Unstable{}{}\", unstable_extra, Markdown(&unstable_reason));\n-            stability.push(format!(\"<div class='stab unstable'>{}</div>\", text))\n+                stability.push(format!(\"<div class='stab unstable'>Experimental</div>\"))\n+            }\n         };\n     } else if let Some(depr) = item.deprecation.as_ref() {\n         let note = if show_reason && !depr.note.is_empty() {\n@@ -1906,7 +1913,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             String::new()\n         };\n \n-        let text = format!(\"Deprecated{}{}\", since, Markdown(&note));\n+        let text = format!(\"Deprecated{}{}\", since, MarkdownHtml(&note));\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n \n@@ -2122,9 +2129,25 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         <ul class='item-list' id='implementors-list'>\n     \")?;\n     if let Some(implementors) = cache.implementors.get(&it.def_id) {\n-        for i in implementors {\n+        let mut implementor_count: FxHashMap<&str, usize> = FxHashMap();\n+        for implementor in implementors {\n+            if let clean::Type::ResolvedPath {ref path, ..} = implementor.impl_.for_ {\n+                *implementor_count.entry(path.last_name()).or_insert(0) += 1;\n+            }\n+        }\n+\n+        for implementor in implementors {\n             write!(w, \"<li><code>\")?;\n-            fmt_impl_for_trait_page(&i.impl_, w)?;\n+            // If there's already another implementor that has the same abbridged name, use the\n+            // full path, for example in `std::iter::ExactSizeIterator`\n+            let use_absolute = if let clean::Type::ResolvedPath {\n+                ref path, ..\n+            } = implementor.impl_.for_ {\n+                implementor_count[path.last_name()] > 1\n+            } else {\n+                false\n+            };\n+            fmt_impl_for_trait_page(&implementor.impl_, w, use_absolute)?;\n             writeln!(w, \"</code></li>\")?;\n         }\n     }"}, {"sha": "681d2354056f67b7257a71c933cd978f05decd29", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -535,6 +535,14 @@ body.blur > :not(#help) {\n \tdisplay: inline;\n }\n \n+.stab summary {\n+\tdisplay: list-item;\n+}\n+\n+.stab .microscope {\n+\tfont-size: 1.5em;\n+}\n+\n .module-item .stab {\n \tdisplay: inline;\n \tborder-width: 0;"}, {"sha": "503ef4c3183d2aa2ca543501b3bd6d329d54efa1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -16,7 +16,7 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -33,7 +33,6 @@ extern crate getopts;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_const_eval;\n-extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_trans;\n extern crate rustc_driver;"}, {"sha": "cfa09361ccec7861381daa18d6416e2dc237ed01", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -25,7 +25,7 @@ Core encoding and decoding interfaces.\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n #![feature(box_syntax)]\n #![feature(collections)]"}, {"sha": "a314717a8772b222524bd660ca7b8248c1adbf60", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1779,11 +1779,11 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, String> = HashMap::new();\n-    /// let s = \"hoho\".to_owned();\n+    /// let s = \"hoho\".to_string();\n     ///\n     /// map.entry(\"poneyland\").or_insert_with(|| s);\n     ///\n-    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {"}, {"sha": "1ab62130cd3ddecedce8d39dbc58c9ebe8a3fcef", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -1061,8 +1061,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n     }\n }\n \n-impl<K, V> Drop for RawTable<K, V> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n         if self.capacity == 0 {\n             return;"}, {"sha": "175fe30db661ce149445780742a63725765d757f", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -259,6 +259,15 @@ impl OsStr {\n     /// Yields a `&str` slice if the `OsStr` is valid Unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::OsStr;\n+    ///\n+    /// let os_str = OsStr::new(\"foo\");\n+    /// assert_eq!(os_str.to_str(), Some(\"foo\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n@@ -267,6 +276,20 @@ impl OsStr {\n     /// Converts an `OsStr` to a `Cow<str>`.\n     ///\n     /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Calling `to_string_lossy` on an `OsStr` with valid unicode:\n+    ///\n+    /// ```\n+    /// use std::ffi::OsStr;\n+    ///\n+    /// let os_str = OsStr::new(\"foo\");\n+    /// assert_eq!(os_str.to_string_lossy(), \"foo\");\n+    /// ```\n+    ///\n+    /// Had `os_str` contained invalid unicode, the `to_string_lossy` call might\n+    /// have returned `\"fo\ufffd\"`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()"}, {"sha": "434f522cc1ea63c4264762b6cf1919e5e6ec2201", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -388,12 +388,12 @@ impl Error {\n     /// impl MyError {\n     ///     fn new() -> MyError {\n     ///         MyError {\n-    ///             v: \"oh no!\".to_owned()\n+    ///             v: \"oh no!\".to_string()\n     ///         }\n     ///     }\n     ///\n     ///     fn change_message(&mut self, new_message: &str) {\n-    ///         self.v = new_message.to_owned();\n+    ///         self.v = new_message.to_string();\n     ///     }\n     /// }\n     ///"}, {"sha": "521b938acfb7ec82c5d36e12b9fb644856218dc4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -225,7 +225,7 @@\n \n // Turn warnings into errors, but only after stage0, where it can be useful for\n // code to emit warnings during language transitions\n-#![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(warnings)]\n \n // std may use features in a platform-specific way\n #![allow(unused_features)]\n@@ -250,13 +250,14 @@\n #![feature(const_fn)]\n #![feature(core_float)]\n #![feature(core_intrinsics)]\n-#![feature(dropck_parametricity)]\n+#![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(float_extras)]\n #![feature(float_from_str_radix)]\n #![feature(fn_traits)]\n #![feature(fnbox)]\n #![feature(fused)]\n+#![feature(generic_param_attrs)]\n #![feature(hashmap_hasher)]\n #![feature(heap_api)]\n #![feature(inclusive_range)]"}, {"sha": "52c6da581518c88209f2a50940534771b00aece5", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -112,7 +112,7 @@ macro_rules! print {\n /// # Examples\n ///\n /// ```\n-/// println!();\n+/// println!(); // prints just a newline\n /// println!(\"hello there!\");\n /// println!(\"format {} arguments\", \"some\");\n /// ```"}, {"sha": "f5348934310e88d03fc1ae538f0f4b042d319e7d", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -446,6 +446,20 @@ impl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n     }\n }\n \n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<SocketAddrV4> for SocketAddr {\n+    fn from(sock4: SocketAddrV4) -> SocketAddr {\n+        SocketAddr::V4(sock4)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<SocketAddrV6> for SocketAddr {\n+    fn from(sock6: SocketAddrV6) -> SocketAddr {\n+        SocketAddr::V6(sock6)\n+    }\n+}\n+\n impl<'a> IntoInner<(*const c::sockaddr, c::socklen_t)> for &'a SocketAddr {\n     fn into_inner(self) -> (*const c::sockaddr, c::socklen_t) {\n         match *self {"}, {"sha": "249f1c76680c1bcee335f71f6da66ec0ae3a96a3", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -524,6 +524,20 @@ impl fmt::Display for IpAddr {\n     }\n }\n \n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<Ipv4Addr> for IpAddr {\n+    fn from(ipv4: Ipv4Addr) -> IpAddr {\n+        IpAddr::V4(ipv4)\n+    }\n+}\n+\n+#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\n+impl From<Ipv6Addr> for IpAddr {\n+    fn from(ipv6: Ipv6Addr) -> IpAddr {\n+        IpAddr::V6(ipv6)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv4Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "cbc672c28bc6aa858f7a5b1c90f0f7aec8eafa91", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -52,7 +52,7 @@ pub struct TcpStream(net_imp::TcpStream);\n ///     // ...\n /// }\n ///\n-/// // accept connections and process them, spawning a new thread for each one\n+/// // accept connections and process them serially\n /// for stream in listener.incoming() {\n ///     match stream {\n ///         Ok(stream) => {\n@@ -613,44 +613,18 @@ impl TcpListener {\n         self.0.ttl()\n     }\n \n-    /// Sets the value for the `IPV6_V6ONLY` option on this socket.\n-    ///\n-    /// If this is set to `true` then the socket is restricted to sending and\n-    /// receiving IPv6 packets only. In this case two IPv4 and IPv6 applications\n-    /// can bind the same port at the same time.\n-    ///\n-    /// If this is set to `false` then the socket can be used to send and\n-    /// receive packets from an IPv4-mapped IPv6 address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::net::TcpListener;\n-    ///\n-    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n-    /// listener.set_only_v6(true).expect(\"Cannot set to IPv6\");\n-    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    #[rustc_deprecated(since = \"1.16.0\",\n+                       reason = \"this option can only be set before the socket is bound\")]\n+    #[allow(missing_docs)]\n     pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n         self.0.set_only_v6(only_v6)\n     }\n \n-    /// Gets the value of the `IPV6_V6ONLY` option for this socket.\n-    ///\n-    /// For more information about this option, see [`set_only_v6`][link].\n-    ///\n-    /// [link]: #method.set_only_v6\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::net::TcpListener;\n-    ///\n-    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n-    /// listener.set_only_v6(true).expect(\"Cannot set to IPv6\");\n-    /// assert_eq!(listener.only_v6().unwrap_or(false), true);\n-    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    #[rustc_deprecated(since = \"1.16.0\",\n+                       reason = \"this option can only be set before the socket is bound\")]\n+    #[allow(missing_docs)]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n     }\n@@ -1179,6 +1153,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg(unix)] // test doesn't work on Windows, see #31657\n     fn close_read_wakes_up() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));"}, {"sha": "a9a19aee5d18d6b7767defdb9922d9b8189b92c1", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -883,11 +883,23 @@ mod tests {\n \n     #[test]\n     fn set_nonblocking() {\n-        let addr = next_test_ip4();\n+        each_ip(&mut |addr, _| {\n+            let socket = t!(UdpSocket::bind(&addr));\n \n-        let stream = t!(UdpSocket::bind(&addr));\n+            t!(socket.set_nonblocking(true));\n+            t!(socket.set_nonblocking(false));\n+\n+            t!(socket.connect(addr));\n \n-        t!(stream.set_nonblocking(true));\n-        t!(stream.set_nonblocking(false));\n+            t!(socket.set_nonblocking(false));\n+            t!(socket.set_nonblocking(true));\n+\n+            let mut buf = [0];\n+            match socket.recv(&mut buf) {\n+                Ok(_) => panic!(\"expected error\"),\n+                Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+                Err(e) => panic!(\"unexpected error {}\", e),\n+            }\n+        })\n     }\n }"}, {"sha": "eb0a6cd74d7bc685a3dc8e864daaceb79f539707", "filename": "src/libstd/path.rs", "status": "modified", "additions": 106, "deletions": 27, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -10,20 +10,20 @@\n \n //! Cross-platform path manipulation.\n //!\n-//! This module provides two types, `PathBuf` and `Path` (akin to `String` and\n-//! `str`), for working with paths abstractly. These types are thin wrappers\n-//! around `OsString` and `OsStr` respectively, meaning that they work directly\n+//! This module provides two types, [`PathBuf`] and [`Path`][`Path`] (akin to [`String`]\n+//! and [`str`]), for working with paths abstractly. These types are thin wrappers\n+//! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n //! on strings according to the local platform's path syntax.\n //!\n //! ## Simple usage\n //!\n //! Path manipulation includes both parsing components from slices and building\n //! new owned paths.\n //!\n-//! To parse a path, you can create a `Path` slice from a `str`\n+//! To parse a path, you can create a [`Path`] slice from a [`str`]\n //! slice and start asking questions:\n //!\n-//! ```rust\n+//! ```\n //! use std::path::Path;\n //! use std::ffi::OsStr;\n //!\n@@ -39,9 +39,9 @@\n //! assert_eq!(extension, Some(OsStr::new(\"txt\")));\n //! ```\n //!\n-//! To build or modify paths, use `PathBuf`:\n+//! To build or modify paths, use [`PathBuf`]:\n //!\n-//! ```rust\n+//! ```\n //! use std::path::PathBuf;\n //!\n //! let mut path = PathBuf::from(\"c:\\\\\");\n@@ -103,6 +103,13 @@\n //! that `b` is a symbolic link (so its parent isn't `a`). Further\n //! normalization is possible to build on top of the components APIs,\n //! and will be included in this library in the near future.\n+//!\n+//! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n+//! [`Path`]: ../../std/path/struct.Path.html\n+//! [`String`]: ../../std/string/struct.String.html\n+//! [`str`]: ../../std/primitive.str.html\n+//! [`OsString`]: ../../std/ffi/struct.OsString.html\n+//! [`OsStr`]: ../../std/ffi/struct.OsStr.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -527,7 +534,9 @@ pub struct Components<'a> {\n     back: State,\n }\n \n-/// An iterator over the components of a path, as `OsStr` slices.\n+/// An iterator over the components of a path, as [`OsStr`] slices.\n+///\n+/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n@@ -1089,10 +1098,11 @@ impl PathBuf {\n \n     /// Updates [`self.file_name()`] to `file_name`.\n     ///\n-    /// If [`self.file_name()`] was `None`, this is equivalent to pushing\n+    /// If [`self.file_name()`] was [`None`], this is equivalent to pushing\n     /// `file_name`.\n     ///\n     /// [`self.file_name()`]: struct.PathBuf.html#method.file_name\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1124,11 +1134,12 @@ impl PathBuf {\n     ///\n     /// If [`self.file_name()`] is `None`, does nothing and returns `false`.\n     ///\n-    /// Otherwise, returns `true`; if [`self.extension()`] is `None`, the\n+    /// Otherwise, returns `true`; if [`self.extension()`] is [`None`], the\n     /// extension is added; otherwise it is replaced.\n     ///\n     /// [`self.file_name()`]: struct.PathBuf.html#method.file_name\n     /// [`self.extension()`]: struct.PathBuf.html#method.extension\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1356,8 +1367,10 @@ pub struct Path {\n     inner: OsStr,\n }\n \n-/// An error returned from the `Path::strip_prefix` method indicating that the\n+/// An error returned from the [`Path::strip_prefix`] method indicating that the\n /// prefix was not found in `self`.\n+///\n+/// [`Path::strip_prefix`]: struct.Path.html#method.strip_prefix\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n pub struct StripPrefixError(());\n@@ -1428,8 +1441,8 @@ impl Path {\n     /// ```\n     /// use std::path::Path;\n     ///\n-    /// let path_str = Path::new(\"foo.txt\").to_str();\n-    /// assert_eq!(path_str, Some(\"foo.txt\"));\n+    /// let path = Path::new(\"foo.txt\");\n+    /// assert_eq!(path.to_str(), Some(\"foo.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_str(&self) -> Option<&str> {\n@@ -1444,12 +1457,17 @@ impl Path {\n     ///\n     /// # Examples\n     ///\n+    /// Calling `to_string_lossy` on a `Path` with valid unicode:\n+    ///\n     /// ```\n     /// use std::path::Path;\n     ///\n-    /// let path_str = Path::new(\"foo.txt\").to_string_lossy();\n-    /// assert_eq!(path_str, \"foo.txt\");\n+    /// let path = Path::new(\"foo.txt\");\n+    /// assert_eq!(path.to_string_lossy(), \"foo.txt\");\n     /// ```\n+    ///\n+    /// Had `os_str` contained invalid unicode, the `to_string_lossy` call might\n+    /// have returned `\"fo\ufffd.txt\"`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()\n@@ -1490,7 +1508,8 @@ impl Path {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n-        self.has_root() && (cfg!(unix) || self.prefix().is_some())\n+        // FIXME: Remove target_os = \"redox\" and allow Redox prefixes\n+        self.has_root() && (cfg!(unix) || cfg!(target_os = \"redox\") || self.prefix().is_some())\n     }\n \n     /// A path is *relative* if it is not absolute.\n@@ -1534,7 +1553,9 @@ impl Path {\n \n     /// The path without its final component, if any.\n     ///\n-    /// Returns `None` if the path terminates in a root or prefix.\n+    /// Returns [`None`] if the path terminates in a root or prefix.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1565,7 +1586,9 @@ impl Path {\n \n     /// The final component of the path, if it is a normal file.\n     ///\n-    /// If the path terminates in `..`, `file_name` will return `None`.\n+    /// If the path terminates in `..`, `file_name` will return [`None`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1603,8 +1626,11 @@ impl Path {\n     ///\n     /// # Errors\n     ///\n-    /// If `base` is not a prefix of `self` (i.e. `starts_with`\n-    /// returns `false`), returns `Err`.\n+    /// If `base` is not a prefix of `self` (i.e. [`starts_with`]\n+    /// returns `false`), returns [`Err`].\n+    ///\n+    /// [`starts_with`]: #method.starts_with\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -1684,11 +1710,13 @@ impl Path {\n     ///\n     /// The stem is:\n     ///\n-    /// * None, if there is no file name;\n+    /// * [`None`], if there is no file name;\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1705,15 +1733,16 @@ impl Path {\n \n     /// Extracts the extension of [`self.file_name()`], if possible.\n     ///\n-    /// [`self.file_name()`]: struct.Path.html#method.file_name\n-    ///\n     /// The extension is:\n     ///\n-    /// * None, if there is no file name;\n-    /// * None, if there is no embedded `.`;\n-    /// * None, if the file name begins with `.` and has no other `.`s within;\n+    /// * [`None`], if there is no file name;\n+    /// * [`None`], if there is no embedded `.`;\n+    /// * [`None`], if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n     ///\n+    /// [`self.file_name()`]: struct.Path.html#method.file_name\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1872,7 +1901,6 @@ impl Path {\n         Display { path: self }\n     }\n \n-\n     /// Query the file system to get information about a file, directory, etc.\n     ///\n     /// This function will traverse symbolic links to query information about the\n@@ -1881,6 +1909,16 @@ impl Path {\n     /// This is an alias to [`fs::metadata`].\n     ///\n     /// [`fs::metadata`]: ../fs/fn.metadata.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/Minas/tirith\");\n+    /// let metadata = path.metadata().expect(\"metadata call failed\");\n+    /// println!(\"{:?}\", metadata.file_type());\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn metadata(&self) -> io::Result<fs::Metadata> {\n         fs::metadata(self)\n@@ -1891,6 +1929,16 @@ impl Path {\n     /// This is an alias to [`fs::symlink_metadata`].\n     ///\n     /// [`fs::symlink_metadata`]: ../fs/fn.symlink_metadata.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/Minas/tirith\");\n+    /// let metadata = path.symlink_metadata().expect(\"symlink_metadata call failed\");\n+    /// println!(\"{:?}\", metadata.file_type());\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {\n         fs::symlink_metadata(self)\n@@ -1902,6 +1950,15 @@ impl Path {\n     /// This is an alias to [`fs::canonicalize`].\n     ///\n     /// [`fs::canonicalize`]: ../fs/fn.canonicalize.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let path = Path::new(\"/foo/test/../test/bar.rs\");\n+    /// assert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn canonicalize(&self) -> io::Result<PathBuf> {\n         fs::canonicalize(self)\n@@ -1912,6 +1969,15 @@ impl Path {\n     /// This is an alias to [`fs::read_link`].\n     ///\n     /// [`fs::read_link`]: ../fs/fn.read_link.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/laputa/sky_castle.rs\");\n+    /// let path_link = path.read_link().expect(\"read_link call failed\");\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn read_link(&self) -> io::Result<PathBuf> {\n         fs::read_link(self)\n@@ -1927,6 +1993,19 @@ impl Path {\n     /// [`io::Result`]: ../io/type.Result.html\n     /// [`DirEntry`]: ../fs/struct.DirEntry.html\n     /// [`fs::read_dir`]: ../fs/fn.read_dir.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/laputa\");\n+    /// for entry in path.read_dir().expect(\"read_dir call failed\") {\n+    ///     if let Ok(entry) = entry {\n+    ///         println!(\"{:?}\", entry.path());\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn read_dir(&self) -> io::Result<fs::ReadDir> {\n         fs::read_dir(self)"}, {"sha": "ced0288766bb1e6408d49e6385bda0a04585e203", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -502,7 +502,7 @@ mod prim_str { }\n /// [`Hash`]: hash/trait.Hash.html\n ///\n /// Due to a temporary restriction in Rust's type system, these traits are only\n-/// implemented on tuples of arity 32 or less. In the future, this may change.\n+/// implemented on tuples of arity 12 or less. In the future, this may change.\n ///\n /// # Examples\n ///"}, {"sha": "aa76b79253582b66c45cac8c1da57ca1a50d085e", "filename": "src/libstd/process.rs", "status": "modified", "additions": 109, "deletions": 18, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -260,11 +260,18 @@ impl fmt::Debug for ChildStderr {\n /// ```\n /// use std::process::Command;\n ///\n-/// let output = Command::new(\"sh\")\n-///                      .arg(\"-c\")\n-///                      .arg(\"echo hello\")\n-///                      .output()\n-///                      .expect(\"failed to execute process\");\n+/// let output = if cfg!(target_os = \"windows\") {\n+///     Command::new(\"cmd\")\n+///             .args(&[\"/C\", \"echo hello\"])\n+///             .output()\n+///             .expect(\"failed to execute process\")\n+/// } else {\n+///     Command::new(\"sh\")\n+///             .arg(\"-c\")\n+///             .arg(\"echo hello\")\n+///             .output()\n+///             .expect(\"failed to execute process\")\n+/// };\n ///\n /// let hello = output.stdout;\n /// ```\n@@ -793,6 +800,48 @@ impl Child {\n         self.handle.wait().map(ExitStatus)\n     }\n \n+    /// Attempts to collect the exit status of the child if it has already\n+    /// exited.\n+    ///\n+    /// This function will not block the calling thread and will only advisorily\n+    /// check to see if the child process has exited or not. If the child has\n+    /// exited then on Unix the process id is reaped. This function is\n+    /// guaranteed to repeatedly return a successful exit status so long as the\n+    /// child has already exited.\n+    ///\n+    /// If the child has exited, then `Ok(status)` is returned. If the exit\n+    /// status is not available at this time then an error is returned with the\n+    /// error kind `WouldBlock`. If an error occurs, then that error is returned.\n+    ///\n+    /// Note that unlike `wait`, this function will not attempt to drop stdin.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// #![feature(process_try_wait)]\n+    ///\n+    /// use std::io;\n+    /// use std::process::Command;\n+    ///\n+    /// let mut child = Command::new(\"ls\").spawn().unwrap();\n+    ///\n+    /// match child.try_wait() {\n+    ///     Ok(status) => println!(\"exited with: {}\", status),\n+    ///     Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n+    ///         println!(\"status not ready yet, let's really wait\");\n+    ///         let res = child.wait();\n+    ///         println!(\"result: {:?}\", res);\n+    ///     }\n+    ///     Err(e) => println!(\"error attempting to wait: {}\", e),\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"process_try_wait\", issue = \"38903\")]\n+    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+        self.handle.try_wait().map(ExitStatus)\n+    }\n+\n     /// Simultaneously waits for the child to exit and collect all remaining\n     /// output on the stdout/stderr handles, returning an `Output`\n     /// instance.\n@@ -925,7 +974,11 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn smoke() {\n-        let p = Command::new(\"true\").spawn();\n+        let p = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"exit 0\"]).spawn()\n+        } else {\n+            Command::new(\"true\").spawn()\n+        };\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().unwrap().success());\n@@ -943,7 +996,11 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn exit_reported_right() {\n-        let p = Command::new(\"false\").spawn();\n+        let p = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn()\n+        } else {\n+            Command::new(\"false\").spawn()\n+        };\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().unwrap().code() == Some(1));\n@@ -982,9 +1039,15 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn stdout_works() {\n-        let mut cmd = Command::new(\"echo\");\n-        cmd.arg(\"foobar\").stdout(Stdio::piped());\n-        assert_eq!(run_output(cmd), \"foobar\\n\");\n+        if cfg!(target_os = \"windows\") {\n+            let mut cmd = Command::new(\"cmd\");\n+            cmd.args(&[\"/C\", \"echo foobar\"]).stdout(Stdio::piped());\n+            assert_eq!(run_output(cmd), \"foobar\\r\\n\");\n+        } else {\n+            let mut cmd = Command::new(\"echo\");\n+            cmd.arg(\"foobar\").stdout(Stdio::piped());\n+            assert_eq!(run_output(cmd), \"foobar\\n\");\n+        }\n     }\n \n     #[test]\n@@ -1044,10 +1107,18 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn test_process_status() {\n-        let mut status = Command::new(\"false\").status().unwrap();\n+        let mut status = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).status().unwrap()\n+        } else {\n+            Command::new(\"false\").status().unwrap()\n+        };\n         assert!(status.code() == Some(1));\n \n-        status = Command::new(\"true\").status().unwrap();\n+        status = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"exit 0\"]).status().unwrap()\n+        } else {\n+            Command::new(\"true\").status().unwrap()\n+        };\n         assert!(status.success());\n     }\n \n@@ -1063,7 +1134,11 @@ mod tests {\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn test_process_output_output() {\n         let Output {status, stdout, stderr}\n-             = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n+             = if cfg!(target_os = \"windows\") {\n+                 Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).output().unwrap()\n+             } else {\n+                 Command::new(\"echo\").arg(\"hello\").output().unwrap()\n+             };\n         let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n@@ -1075,7 +1150,11 @@ mod tests {\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn test_process_output_error() {\n         let Output {status, stdout, stderr}\n-             = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n+             = if cfg!(target_os = \"windows\") {\n+                 Command::new(\"cmd\").args(&[\"/C\", \"mkdir .\"]).output().unwrap()\n+             } else {\n+                 Command::new(\"mkdir\").arg(\".\").output().unwrap()\n+             };\n \n         assert!(status.code() == Some(1));\n         assert_eq!(stdout, Vec::new());\n@@ -1085,23 +1164,35 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn test_finish_once() {\n-        let mut prog = Command::new(\"false\").spawn().unwrap();\n+        let mut prog = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn().unwrap()\n+        } else {\n+            Command::new(\"false\").spawn().unwrap()\n+        };\n         assert!(prog.wait().unwrap().code() == Some(1));\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn test_finish_twice() {\n-        let mut prog = Command::new(\"false\").spawn().unwrap();\n+        let mut prog = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"exit 1\"]).spawn().unwrap()\n+        } else {\n+            Command::new(\"false\").spawn().unwrap()\n+        };\n         assert!(prog.wait().unwrap().code() == Some(1));\n         assert!(prog.wait().unwrap().code() == Some(1));\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     fn test_wait_with_output_once() {\n-        let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped())\n-            .spawn().unwrap();\n+        let prog = if cfg!(target_os = \"windows\") {\n+            Command::new(\"cmd\").args(&[\"/C\", \"echo hello\"]).stdout(Stdio::piped()).spawn().unwrap()\n+        } else {\n+            Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped()).spawn().unwrap()\n+        };\n+\n         let Output {status, stdout, stderr} = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(&stdout).unwrap();\n "}, {"sha": "2efddeb4610dd6211cb7ea06b5c2ae91073cde85", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 80, "deletions": 3, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -155,6 +155,14 @@ impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n \n impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Mutex;\n+    ///\n+    /// let mutex = Mutex::new(0);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         let mut m = Mutex {\n@@ -190,6 +198,21 @@ impl<T: ?Sized> Mutex<T> {\n     ///\n     /// This function might panic when called if the lock is already held by\n     /// the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex};\n+    /// use std::thread;\n+    ///\n+    /// let mutex = Arc::new(Mutex::new(0));\n+    /// let c_mutex = mutex.clone();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     *c_mutex.lock().unwrap() = 10;\n+    /// }).join().expect(\"thread::spawn failed\");\n+    /// assert_eq!(*mutex.lock().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe {\n@@ -211,6 +234,26 @@ impl<T: ?Sized> Mutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex};\n+    /// use std::thread;\n+    ///\n+    /// let mutex = Arc::new(Mutex::new(0));\n+    /// let c_mutex = mutex.clone();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     let mut lock = c_mutex.try_lock();\n+    ///     if let Ok(ref mut mutex) = lock {\n+    ///         **mutex = 10;\n+    ///     } else {\n+    ///         println!(\"try_lock failed\");\n+    ///     }\n+    /// }).join().expect(\"thread::spawn failed\");\n+    /// assert_eq!(*mutex.lock().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         unsafe {\n@@ -225,8 +268,24 @@ impl<T: ?Sized> Mutex<T> {\n     /// Determines whether the lock is poisoned.\n     ///\n     /// If another thread is active, the lock can still become poisoned at any\n-    /// time.  You should not trust a `false` value for program correctness\n+    /// time. You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex};\n+    /// use std::thread;\n+    ///\n+    /// let mutex = Arc::new(Mutex::new(0));\n+    /// let c_mutex = mutex.clone();\n+    ///\n+    /// let _ = thread::spawn(move || {\n+    ///     let _lock = c_mutex.lock().unwrap();\n+    ///     panic!(); // the mutex gets poisoned\n+    /// }).join();\n+    /// assert_eq!(mutex.is_poisoned(), true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n@@ -239,6 +298,15 @@ impl<T: ?Sized> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Mutex;\n+    ///\n+    /// let mutex = Mutex::new(0);\n+    /// assert_eq!(mutex.into_inner().unwrap(), 0);\n+    /// ```\n     #[stable(feature = \"mutex_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n@@ -270,6 +338,16 @@ impl<T: ?Sized> Mutex<T> {\n     ///\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return an error instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Mutex;\n+    ///\n+    /// let mut mutex = Mutex::new(0);\n+    /// *mutex.get_mut().unwrap() = 10;\n+    /// assert_eq!(*mutex.lock().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n@@ -280,8 +358,7 @@ impl<T: ?Sized> Mutex<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Drop for Mutex<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n         // this mutex (it's up to the user to arrange for a mutex to get"}, {"sha": "adbb98e4b1f4f664a99ab278c06a517639e091de", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -310,8 +310,7 @@ impl<T: ?Sized> RwLock<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Drop for RwLock<T> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] T: ?Sized> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         // IMPORTANT: This code needs to be kept in sync with `RwLock::into_inner`.\n         unsafe { self.inner.destroy() }"}, {"sha": "0291d7f0e927a7d3fc03c85b7f24b95dcafaa865", "filename": "src/libstd/sys/redox/net/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -15,7 +15,7 @@ use net::{Ipv4Addr, SocketAddr, SocketAddrV4};\n use str::FromStr;\n use string::{String, ToString};\n use sys::syscall::EINVAL;\n-use time;\n+use time::{self, Duration};\n use vec::{IntoIter, Vec};\n \n use self::dns::{Dns, DnsQuery};\n@@ -69,6 +69,8 @@ pub fn lookup_host(host: &str) -> Result<LookupHost> {\n         let my_ip = Ipv4Addr::new(ip[0], ip[1], ip[2], ip[3]);\n         let dns_ip = Ipv4Addr::new(dns[0], dns[1], dns[2], dns[3]);\n         let socket = UdpSocket::bind(&SocketAddr::V4(SocketAddrV4::new(my_ip, 0)))?;\n+        socket.set_read_timeout(Some(Duration::new(5, 0)))?;\n+        socket.set_write_timeout(Some(Duration::new(5, 0)))?;\n         socket.connect(&SocketAddr::V4(SocketAddrV4::new(dns_ip, 53)))?;\n         socket.send(&packet_data)?;\n "}, {"sha": "a3f202ccd97cbc492c2692c0692bb8e8448f7197", "filename": "src/libstd/sys/redox/net/tcp.rs", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Ftcp.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cmp;\n use io::{Error, ErrorKind, Result};\n+use mem;\n use net::{SocketAddr, Shutdown};\n use path::Path;\n use sys::fs::{File, OpenOptions};\n+use sys::syscall::TimeSpec;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n use vec::Vec;\n@@ -77,15 +80,30 @@ impl TcpStream {\n     }\n \n     pub fn ttl(&self) -> Result<u32> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::ttl not implemented\"))\n+        let mut ttl = [0];\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.read(&mut ttl)?;\n+        Ok(ttl[0] as u32)\n     }\n \n     pub fn read_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::read_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn write_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::write_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn set_nodelay(&self, _nodelay: bool) -> Result<()> {\n@@ -100,16 +118,36 @@ impl TcpStream {\n         Err(Error::new(ErrorKind::Other, \"TcpStream::set_only_v6 not implemented\"))\n     }\n \n-    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_ttl not implemented\"))\n-    }\n-\n-    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_read_timeout not implemented\"))\n-    }\n-\n-    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpStream::set_write_timeout not implemented\"))\n+    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.write(&[cmp::min(ttl, 255) as u8])?;\n+        Ok(())\n+    }\n+\n+    pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n     }\n }\n \n@@ -168,7 +206,10 @@ impl TcpListener {\n     }\n \n     pub fn ttl(&self) -> Result<u32> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::ttl not implemented\"))\n+        let mut ttl = [0];\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.read(&mut ttl)?;\n+        Ok(ttl[0] as u32)\n     }\n \n     pub fn set_nonblocking(&self, _nonblocking: bool) -> Result<()> {\n@@ -179,8 +220,10 @@ impl TcpListener {\n         Err(Error::new(ErrorKind::Other, \"TcpListener::set_only_v6 not implemented\"))\n     }\n \n-    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"TcpListener::set_ttl not implemented\"))\n+    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.write(&[cmp::min(ttl, 255) as u8])?;\n+        Ok(())\n     }\n }\n "}, {"sha": "36f0819d308849cb8c087919fe0f4b8ee4fa46d4", "filename": "src/libstd/sys/redox/net/udp.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fudp.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -9,10 +9,13 @@\n // except according to those terms.\n \n use cell::UnsafeCell;\n+use cmp;\n use io::{Error, ErrorKind, Result};\n+use mem;\n use net::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use path::Path;\n use sys::fs::{File, OpenOptions};\n+use sys::syscall::TimeSpec;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n \n@@ -109,15 +112,30 @@ impl UdpSocket {\n     }\n \n     pub fn ttl(&self) -> Result<u32> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::ttl not implemented\"))\n+        let mut ttl = [0];\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.read(&mut ttl)?;\n+        Ok(ttl[0] as u32)\n     }\n \n     pub fn read_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::read_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn write_timeout(&self) -> Result<Option<Duration>> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::write_timeout not implemented\"))\n+        let mut time = TimeSpec::default();\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if file.read(&mut time)? >= mem::size_of::<TimeSpec>() {\n+            Ok(Some(Duration::new(time.tv_sec as u64, time.tv_nsec as u32)))\n+        } else {\n+            Ok(None)\n+        }\n     }\n \n     pub fn set_broadcast(&self, _broadcast: bool) -> Result<()> {\n@@ -144,16 +162,36 @@ impl UdpSocket {\n         Err(Error::new(ErrorKind::Other, \"UdpSocket::set_only_v6 not implemented\"))\n     }\n \n-    pub fn set_ttl(&self, _ttl: u32) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_ttl not implemented\"))\n+    pub fn set_ttl(&self, ttl: u32) -> Result<()> {\n+        let file = self.0.dup(b\"ttl\")?;\n+        file.write(&[cmp::min(ttl, 255) as u8])?;\n+        Ok(())\n     }\n \n-    pub fn set_read_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_read_timeout not implemented\"))\n+    pub fn set_read_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"read_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n     }\n \n-    pub fn set_write_timeout(&self, _dur: Option<Duration>) -> Result<()> {\n-        Err(Error::new(ErrorKind::Other, \"UdpSocket::set_write_timeout not implemented\"))\n+    pub fn set_write_timeout(&self, duration_option: Option<Duration>) -> Result<()> {\n+        let file = self.0.dup(b\"write_timeout\")?;\n+        if let Some(duration) = duration_option {\n+            file.write(&TimeSpec {\n+                tv_sec: duration.as_secs() as i64,\n+                tv_nsec: duration.subsec_nanos() as i32\n+            })?;\n+        } else {\n+            file.write(&[])?;\n+        }\n+        Ok(())\n     }\n \n     pub fn join_multicast_v4(&self, _multiaddr: &Ipv4Addr, _interface: &Ipv4Addr) -> Result<()> {"}, {"sha": "a6b0ada72b8fb7ef17172df0e645e3964d858d79", "filename": "src/libstd/sys/redox/syscall/data.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fdata.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -84,3 +84,22 @@ pub struct TimeSpec {\n     pub tv_sec: i64,\n     pub tv_nsec: i32,\n }\n+\n+impl Deref for TimeSpec {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe {\n+            slice::from_raw_parts(self as *const TimeSpec as *const u8,\n+                                  mem::size_of::<TimeSpec>()) as &[u8]\n+        }\n+    }\n+}\n+\n+impl DerefMut for TimeSpec {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n+        unsafe {\n+            slice::from_raw_parts_mut(self as *mut TimeSpec as *mut u8,\n+                                      mem::size_of::<TimeSpec>()) as &mut [u8]\n+        }\n+    }\n+}"}, {"sha": "0dc1739c1a15aef50a5e7d956ddff298a7c56b85", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -237,6 +237,7 @@ impl Process {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n         }\n     }\n+\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         use sys::cvt_r;\n         if let Some(status) = self.status {\n@@ -247,4 +248,20 @@ impl Process {\n         self.status = Some(ExitStatus::new(status));\n         Ok(ExitStatus::new(status))\n     }\n+\n+    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0 as c_int;\n+        let pid = cvt(unsafe {\n+            libc::waitpid(self.pid, &mut status, libc::WNOHANG)\n+        })?;\n+        if pid == 0 {\n+            Err(io::Error::from_raw_os_error(libc::EWOULDBLOCK))\n+        } else {\n+            self.status = Some(ExitStatus::new(status));\n+            Ok(ExitStatus::new(status))\n+        }\n+    }\n }"}, {"sha": "dc7b2fc9a6bab90ab5f5e5288957287efa254850", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -265,6 +265,7 @@ pub const FILE_CURRENT: DWORD = 1;\n pub const FILE_END: DWORD = 2;\n \n pub const WAIT_OBJECT_0: DWORD = 0x00000000;\n+pub const WAIT_TIMEOUT: DWORD = 258;\n \n #[cfg(target_env = \"msvc\")]\n pub const MAX_SYM_NAME: usize = 2000;\n@@ -282,6 +283,7 @@ pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n \n pub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n+pub const PIPE_ACCESS_OUTBOUND: DWORD = 0x00000002;\n pub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n pub const FILE_FLAG_OVERLAPPED: DWORD = 0x40000000;\n pub const PIPE_WAIT: DWORD = 0x00000000;"}, {"sha": "8073473f7ff5b8c6144d938adae1ae887a37d35a", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db", "patch": "@@ -29,18 +29,43 @@ pub struct AnonPipe {\n     inner: Handle,\n }\n \n-pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+pub struct Pipes {\n+    pub ours: AnonPipe,\n+    pub theirs: AnonPipe,\n+}\n+\n+/// Although this looks similar to `anon_pipe` in the Unix module it's actually\n+/// subtly different. Here we'll return two pipes in the `Pipes` return value,\n+/// but one is intended for \"us\" where as the other is intended for \"someone\n+/// else\".\n+///\n+/// Currently the only use case for this function is pipes for stdio on\n+/// processes in the standard library, so \"ours\" is the one that'll stay in our\n+/// process whereas \"theirs\" will be inherited to a child.\n+///\n+/// The ours/theirs pipes are *not* specifically readable or writable. Each\n+/// one only supports a read or a write, but which is which depends on the\n+/// boolean flag given. If `ours_readable` is true then `ours` is readable where\n+/// `theirs` is writable. Conversely if `ours_readable` is false then `ours` is\n+/// writable where `theirs` is readable.\n+///\n+/// Also note that the `ours` pipe is always a handle opened up in overlapped\n+/// mode. This means that technically speaking it should only ever be used\n+/// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n+/// once at a time (which we do indeed guarantee).\n+pub fn anon_pipe(ours_readable: bool) -> io::Result<Pipes> {\n     // Note that we specifically do *not* use `CreatePipe` here because\n     // unfortunately the anonymous pipes returned do not support overlapped\n-    // operations.\n-    //\n-    // Instead, we create a \"hopefully unique\" name and create a named pipe\n-    // which has overlapped operations enabled.\n+    // operations. Instead, we create a \"hopefully unique\" name and create a\n+    // named pipe which has overlapped operations enabled.\n     //\n-    // Once we do this, we connect do it as usual via `CreateFileW`, and then we\n-    // return those reader/writer halves.\n+    // Once we do this, we connect do it as usual via `CreateFileW`, and then\n+    // we return those reader/writer halves. Note that the `ours` pipe return\n+    // value is always the named pipe, whereas `theirs` is just the normal file.\n+    // This should hopefully shield us from child processes which assume their\n+    // stdout is a named pipe, which would indeed be odd!\n     unsafe {\n-        let reader;\n+        let ours;\n         let mut name;\n         let mut tries = 0;\n         let mut reject_remote_clients_flag = c::PIPE_REJECT_REMOTE_CLIENTS;\n@@ -54,11 +79,16 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n                                   .encode_wide()\n                                   .chain(Some(0))\n                                   .collect::<Vec<_>>();\n+            let mut flags = c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n+                c::FILE_FLAG_OVERLAPPED;\n+            if ours_readable {\n+                flags |= c::PIPE_ACCESS_INBOUND;\n+            } else {\n+                flags |= c::PIPE_ACCESS_OUTBOUND;\n+            }\n \n             let handle = c::CreateNamedPipeW(wide_name.as_ptr(),\n-                                             c::PIPE_ACCESS_INBOUND |\n-                                             c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n-                                             c::FILE_FLAG_OVERLAPPED,\n+                                             flags,\n                                              c::PIPE_TYPE_BYTE |\n                                              c::PIPE_READMODE_BYTE |\n                                              c::PIPE_WAIT |\n@@ -101,21 +131,28 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n                 }\n                 return Err(err)\n             }\n-            reader = Handle::new(handle);\n+            ours = Handle::new(handle);\n             break\n         }\n \n-        // Connect to the named pipe we just created in write-only mode (also\n-        // overlapped for async I/O below).\n+        // Connect to the named pipe we just created. This handle is going to be\n+        // returned in `theirs`, so if `ours` is readable we want this to be\n+        // writable, otherwise if `ours` is writable we want this to be\n+        // readable.\n+        //\n+        // Additionally we don't enable overlapped mode on this because most\n+        // client processes aren't enabled to work with that.\n         let mut opts = OpenOptions::new();\n-        opts.write(true);\n-        opts.read(false);\n+        opts.write(ours_readable);\n+        opts.read(!ours_readable);\n         opts.share_mode(0);\n-        opts.attributes(c::FILE_FLAG_OVERLAPPED);\n-        let writer = File::open(Path::new(&name), &opts)?;\n-        let writer = AnonPipe { inner: writer.into_handle() };\n+        let theirs = File::open(Path::new(&name), &opts)?;\n+        let theirs = AnonPipe { inner: theirs.into_handle() };\n \n-        Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer.into_handle() }))\n+        Ok(Pipes {\n+            ours: AnonPipe { inner: ours },\n+            theirs: AnonPipe { inner: theirs.into_handle() },\n+        })\n     }\n }\n "}, {"sha": "d2ad81023e7feefcd7cb34da5684bc1c2c19e965", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "e4b8d457e2d29dcee1dd107fdc4706231b5ad413", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 115, "deletions": 14, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "f2c53efda173700e9e00e5c03151d4b66654aabf", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 150, "deletions": 49, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "d52d1549b5173ab27e0b99b1d2fea931e699d74a", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "7a5667b96a50c744fcb3a728fbf047ff783f7ba9", "filename": "src/libstd_unicode/tables.rs", "status": "modified", "additions": 45, "deletions": 208, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibstd_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftables.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "709de49fbaaf07ec0f06851aedc14ce51930268e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "099ca8f02d2b20cc63c307d04f859338fa5fd032", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "ea12a31770fc07ba93fd556197103d65658f1bec", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "688df96ffa32fcfde245a767a0aa69001b243acc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "201e8d69494ac06445a1961575729f25f34efd68", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "90cca3129dcf20e2494c87f694d600e21daf1499", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "10ca9da2112cb7358dfa9de568fc2c49a7bdbb5c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "00bf744507713af8832812248ff3383c8cd20afb", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "167fa78d7e07500fdd861d6d7b03caff5a4ac486", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "04100b3af001dd0c5c266d887ab6ad9fd1234e44", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "1f50ceb626c7c2018648d128011c70eef48b22b8", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "096f6dfd5d8d86cbae0dc18d3c8a640ec70d1c04", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "bdec86158a4ec4df9368b91fb2504ee1a2cdbc11", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "c93e2c054d24044dcf566583d26afc02038b2b43", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "92fdb45caaaeffbc4425c7370dc7cfff1cc69a74", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "370757c06091013b53892579cc0d24fc686b8afd", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "cfbc284de4dce59f6216add8b3c174dcb6dfe655", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 145, "deletions": 97, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "993fb703e51ddc79e095adc8baf4abe35e656db6", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "7fa2ce650fd6cea7d98459c612a85176047673a9", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "f2d9119a7d15697c4db85ed47af161cec86c2e9a", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "db36b50702a43efd090be185914bddd167dd9527", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}, {"sha": "70fc75c6970b7a23218fd245ab5cef7897b264bb", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cfb8b730a473814c2ae090c342abb95e53502db/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=9cfb8b730a473814c2ae090c342abb95e53502db"}]}