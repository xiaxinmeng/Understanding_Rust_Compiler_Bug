{"sha": "2d280a55a9820ab18b25b8080d30e6d0a864ec17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjgwYTU1YTk4MjBhYjE4YjI1YjgwODBkMzBlNmQwYTg2NGVjMTc=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-27T11:38:00Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-27T11:38:00Z"}, "message": "more LocalDefId cleanup", "tree": {"sha": "c046bf338b8a3b3535d5f92a85c65493e1ad84b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c046bf338b8a3b3535d5f92a85c65493e1ad84b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d280a55a9820ab18b25b8080d30e6d0a864ec17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d280a55a9820ab18b25b8080d30e6d0a864ec17", "html_url": "https://github.com/rust-lang/rust/commit/2d280a55a9820ab18b25b8080d30e6d0a864ec17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d280a55a9820ab18b25b8080d30e6d0a864ec17/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1875c797721a84b3a4cbb77d4e4bd0a367ff22c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1875c797721a84b3a4cbb77d4e4bd0a367ff22c3", "html_url": "https://github.com/rust-lang/rust/commit/1875c797721a84b3a4cbb77d4e4bd0a367ff22c3"}], "stats": {"total": 519, "additions": 259, "deletions": 260}, "files": [{"sha": "20617bb8bd8fc2aa84cfffef9be05b2960e0c3d3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=2d280a55a9820ab18b25b8080d30e6d0a864ec17", "patch": "@@ -28,30 +28,27 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         br: &ty::BoundRegion,\n     ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n-            let def_id = anon_reg.def_id;\n-            if let Some(def_id) = def_id.as_local() {\n-                let hir_id = self.tcx().hir().as_local_hir_id(def_id);\n-                let fndecl = match self.tcx().hir().get(hir_id) {\n-                    Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n-                    | Node::TraitItem(&hir::TraitItem {\n-                        kind: hir::TraitItemKind::Fn(ref m, ..),\n-                        ..\n-                    })\n-                    | Node::ImplItem(&hir::ImplItem {\n-                        kind: hir::ImplItemKind::Fn(ref m, ..),\n-                        ..\n-                    }) => &m.decl,\n-                    _ => return None,\n-                };\n+            let hir_id = self.tcx().hir().as_local_hir_id(anon_reg.def_id);\n+            let fndecl = match self.tcx().hir().get(hir_id) {\n+                Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n+                | Node::TraitItem(&hir::TraitItem {\n+                    kind: hir::TraitItemKind::Fn(ref m, ..),\n+                    ..\n+                })\n+                | Node::ImplItem(&hir::ImplItem {\n+                    kind: hir::ImplItemKind::Fn(ref m, ..), ..\n+                }) => &m.decl,\n+                _ => return None,\n+            };\n \n-                return fndecl\n-                    .inputs\n-                    .iter()\n-                    .find_map(|arg| self.find_component_for_bound_region(arg, br))\n-                    .map(|ty| (ty, &**fndecl));\n-            }\n+            fndecl\n+                .inputs\n+                .iter()\n+                .find_map(|arg| self.find_component_for_bound_region(arg, br))\n+                .map(|ty| (ty, &**fndecl))\n+        } else {\n+            None\n         }\n-        None\n     }\n \n     // This method creates a FindNestedTypeVisitor which returns the type corresponding"}, {"sha": "72deba990b0b5e5dc5dc6a629cfcede63cce94ab", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=2d280a55a9820ab18b25b8080d30e6d0a864ec17", "patch": "@@ -75,8 +75,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            let is_self_anon = self.is_self_anon(is_first, scope_def_id);\n-            if is_self_anon {\n+            if self.is_self_anon(is_first, scope_def_id) {\n                 return None;\n             }\n "}, {"sha": "b6e971feb0e5fdc4043f45411baa2264ea13cc19", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 196, "deletions": 199, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=2d280a55a9820ab18b25b8080d30e6d0a864ec17", "patch": "@@ -10,220 +10,217 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         debug!(\"try_report_static_impl_trait(error={:?})\", self.error);\n-        if let Some(ref error) = self.error {\n-            if let RegionResolutionError::SubSupConflict(\n-                _,\n-                var_origin,\n-                sub_origin,\n-                sub_r,\n-                sup_origin,\n-                sup_r,\n-            ) = error\n-            {\n-                debug!(\n-                    \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n-                    var_origin, sub_origin, sub_r, sup_origin, sup_r\n+        if let Some(RegionResolutionError::SubSupConflict(\n+            _,\n+            var_origin,\n+            ref sub_origin,\n+            sub_r,\n+            ref sup_origin,\n+            sup_r,\n+        )) = self.error\n+        {\n+            debug!(\n+                \"try_report_static_impl_trait(var={:?}, sub={:?} {:?} sup={:?} {:?})\",\n+                var_origin, sub_origin, sub_r, sup_origin, sup_r\n+            );\n+            let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n+            debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n+            let fn_returns = self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n+            if fn_returns.is_empty() {\n+                return None;\n+            }\n+            debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n+            if *sub_r == RegionKind::ReStatic {\n+                let sp = var_origin.span();\n+                let return_sp = sub_origin.span();\n+                let param_info = self.find_param_with_region(sup_r, sub_r)?;\n+                let (lifetime_name, lifetime) = if sup_r.has_name() {\n+                    (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                } else {\n+                    (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n+                };\n+                let mut err = struct_span_err!(\n+                    self.tcx().sess,\n+                    sp,\n+                    E0759,\n+                    \"cannot infer an appropriate lifetime\"\n                 );\n-                let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n-                let fn_returns =\n-                    self.tcx().return_type_impl_or_dyn_traits(anon_reg_sup.def_id.expect_local());\n-                if fn_returns.is_empty() {\n-                    return None;\n-                }\n-                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n-                if **sub_r == RegionKind::ReStatic {\n-                    let sp = var_origin.span();\n-                    let return_sp = sub_origin.span();\n-                    let param_info = self.find_param_with_region(sup_r, sub_r)?;\n-                    let (lifetime_name, lifetime) = if sup_r.has_name() {\n-                        (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n+                err.span_label(\n+                    param_info.param_ty_span,\n+                    &format!(\"this data with {}...\", lifetime),\n+                );\n+                debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+\n+                // We try to make the output have fewer overlapping spans if possible.\n+                if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+                    && sup_origin.span() != return_sp\n+                {\n+                    // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+\n+                    // Customize the spans and labels depending on their relative order so\n+                    // that split sentences flow correctly.\n+                    if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n+                        // Avoid the following:\n+                        //\n+                        // error: cannot infer an appropriate lifetime\n+                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                        //    |\n+                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                        //    |           ----                      ---------^-\n+                        //\n+                        // and instead show:\n+                        //\n+                        // error: cannot infer an appropriate lifetime\n+                        //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n+                        //    |\n+                        // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n+                        //    |           ----                               ^\n+                        err.span_label(\n+                            sup_origin.span(),\n+                            \"...is captured here, requiring it to live as long as `'static`\",\n+                        );\n                     } else {\n-                        (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-                    };\n-                    let mut err = struct_span_err!(\n-                        self.tcx().sess,\n-                        sp,\n-                        E0759,\n-                        \"cannot infer an appropriate lifetime\"\n-                    );\n+                        err.span_label(sup_origin.span(), \"...is captured here...\");\n+                        if return_sp < sup_origin.span() {\n+                            err.span_note(\n+                                return_sp,\n+                                \"...and is required to live as long as `'static` here\",\n+                            );\n+                        } else {\n+                            err.span_label(\n+                                return_sp,\n+                                \"...and is required to live as long as `'static` here\",\n+                            );\n+                        }\n+                    }\n+                } else {\n                     err.span_label(\n-                        param_info.param_ty_span,\n-                        &format!(\"this data with {}...\", lifetime),\n+                        return_sp,\n+                        \"...is captured and required to live as long as `'static` here\",\n                     );\n-                    debug!(\"try_report_static_impl_trait: param_info={:?}\", param_info);\n+                }\n \n-                    // We try to make the output have fewer overlapping spans if possible.\n-                    if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n-                        && sup_origin.span() != return_sp\n-                    {\n-                        // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+                // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                let consider = \"consider changing the\";\n+                let declare = \"to declare that the\";\n+                let arg = match param_info.param.pat.simple_ident() {\n+                    Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                    None => \"the argument\".to_string(),\n+                };\n+                let explicit =\n+                    format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+                let explicit_static =\n+                    format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+                let captures = format!(\"captures data from {}\", arg);\n+                let add_static_bound =\n+                    \"alternatively, add an explicit `'static` bound to this reference\";\n+                let plus_lt = format!(\" + {}\", lifetime_name);\n+                for fn_return in fn_returns {\n+                    if fn_return.span.desugaring_kind().is_some() {\n+                        // Skip `async` desugaring `impl Future`.\n+                        continue;\n+                    }\n+                    match fn_return.kind {\n+                        TyKind::OpaqueDef(item_id, _) => {\n+                            let item = self.tcx().hir().item(item_id.id);\n+                            let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n+                                opaque\n+                            } else {\n+                                err.emit();\n+                                return Some(ErrorReported);\n+                            };\n \n-                        // Customize the spans and labels depending on their relative order so\n-                        // that split sentences flow correctly.\n-                        if sup_origin.span().overlaps(return_sp) && sp == sup_origin.span() {\n-                            // Avoid the following:\n-                            //\n-                            // error: cannot infer an appropriate lifetime\n-                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                            //    |\n-                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                            //    |           ----                      ---------^-\n-                            //\n-                            // and instead show:\n-                            //\n-                            // error: cannot infer an appropriate lifetime\n-                            //   --> $DIR/must_outlive_least_region_or_bound.rs:18:50\n-                            //    |\n-                            // LL | fn foo(x: &i32) -> Box<dyn Debug> { Box::new(x) }\n-                            //    |           ----                               ^\n-                            err.span_label(\n-                                sup_origin.span(),\n-                                \"...is captured here, requiring it to live as long as `'static`\",\n-                            );\n-                        } else {\n-                            err.span_label(sup_origin.span(), \"...is captured here...\");\n-                            if return_sp < sup_origin.span() {\n-                                err.span_note(\n-                                    return_sp,\n-                                    \"...and is required to live as long as `'static` here\",\n+                            if let Some(span) = opaque\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericBound::Outlives(Lifetime {\n+                                        name: LifetimeName::Static,\n+                                        span,\n+                                        ..\n+                                    }) => Some(*span),\n+                                    _ => None,\n+                                })\n+                                .next()\n+                            {\n+                                err.span_suggestion_verbose(\n+                                    span,\n+                                    &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                                    lifetime_name.clone(),\n+                                    Applicability::MaybeIncorrect,\n                                 );\n+                                err.span_suggestion_verbose(\n+                                    param_info.param_ty_span,\n+                                    add_static_bound,\n+                                    param_info.param_ty.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else if let Some(_) = opaque\n+                                .bounds\n+                                .iter()\n+                                .filter_map(|arg| match arg {\n+                                    GenericBound::Outlives(Lifetime { name, span, .. })\n+                                        if name.ident().to_string() == lifetime_name =>\n+                                    {\n+                                        Some(*span)\n+                                    }\n+                                    _ => None,\n+                                })\n+                                .next()\n+                            {\n                             } else {\n-                                err.span_label(\n-                                    return_sp,\n-                                    \"...and is required to live as long as `'static` here\",\n+                                err.span_suggestion_verbose(\n+                                    fn_return.span.shrink_to_hi(),\n+                                    &format!(\n+                                        \"{declare} `impl Trait` {captures}, {explicit}\",\n+                                        declare = declare,\n+                                        captures = captures,\n+                                        explicit = explicit,\n+                                    ),\n+                                    plus_lt.clone(),\n+                                    Applicability::MaybeIncorrect,\n                                 );\n                             }\n                         }\n-                    } else {\n-                        err.span_label(\n-                            return_sp,\n-                            \"...is captured and required to live as long as `'static` here\",\n-                        );\n-                    }\n-\n-                    // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-                    let consider = \"consider changing the\";\n-                    let declare = \"to declare that the\";\n-                    let arg = match param_info.param.pat.simple_ident() {\n-                        Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n-                        None => \"the argument\".to_string(),\n-                    };\n-                    let explicit =\n-                        format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-                    let explicit_static =\n-                        format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n-                    let captures = format!(\"captures data from {}\", arg);\n-                    let add_static_bound =\n-                        \"alternatively, add an explicit `'static` bound to this reference\";\n-                    let plus_lt = format!(\" + {}\", lifetime_name);\n-                    for fn_return in fn_returns {\n-                        if fn_return.span.desugaring_kind().is_some() {\n-                            // Skip `async` desugaring `impl Future`.\n-                            continue;\n-                        }\n-                        match fn_return.kind {\n-                            TyKind::OpaqueDef(item_id, _) => {\n-                                let item = self.tcx().hir().item(item_id.id);\n-                                let opaque = if let ItemKind::OpaqueTy(opaque) = &item.kind {\n-                                    opaque\n-                                } else {\n-                                    err.emit();\n-                                    return Some(ErrorReported);\n-                                };\n-\n-                                if let Some(span) = opaque\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|arg| match arg {\n-                                        GenericBound::Outlives(Lifetime {\n-                                            name: LifetimeName::Static,\n-                                            span,\n-                                            ..\n-                                        }) => Some(*span),\n-                                        _ => None,\n-                                    })\n-                                    .next()\n-                                {\n-                                    err.span_suggestion_verbose(\n-                                        span,\n-                                        &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n-                                        lifetime_name.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    err.span_suggestion_verbose(\n-                                        param_info.param_ty_span,\n-                                        add_static_bound,\n-                                        param_info.param_ty.to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                } else if let Some(_) = opaque\n-                                    .bounds\n-                                    .iter()\n-                                    .filter_map(|arg| match arg {\n-                                        GenericBound::Outlives(Lifetime { name, span, .. })\n-                                            if name.ident().to_string() == lifetime_name =>\n-                                        {\n-                                            Some(*span)\n-                                        }\n-                                        _ => None,\n-                                    })\n-                                    .next()\n-                                {\n-                                } else {\n-                                    err.span_suggestion_verbose(\n-                                        fn_return.span.shrink_to_hi(),\n-                                        &format!(\n-                                            \"{declare} `impl Trait` {captures}, {explicit}\",\n-                                            declare = declare,\n-                                            captures = captures,\n-                                            explicit = explicit,\n-                                        ),\n-                                        plus_lt.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n+                        TyKind::TraitObject(_, lt) => match lt.name {\n+                            LifetimeName::ImplicitObjectLifetimeDefault => {\n+                                err.span_suggestion_verbose(\n+                                    fn_return.span.shrink_to_hi(),\n+                                    &format!(\n+                                        \"{declare} trait object {captures}, {explicit}\",\n+                                        declare = declare,\n+                                        captures = captures,\n+                                        explicit = explicit,\n+                                    ),\n+                                    plus_lt.clone(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            name if name.ident().to_string() != lifetime_name => {\n+                                // With this check we avoid suggesting redundant bounds. This\n+                                // would happen if there are nested impl/dyn traits and only\n+                                // one of them has the bound we'd suggest already there, like\n+                                // in `impl Foo<X = dyn Bar> + '_`.\n+                                err.span_suggestion_verbose(\n+                                    lt.span,\n+                                    &format!(\"{} trait object's {}\", consider, explicit_static),\n+                                    lifetime_name.clone(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                err.span_suggestion_verbose(\n+                                    param_info.param_ty_span,\n+                                    add_static_bound,\n+                                    param_info.param_ty.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n                             }\n-                            TyKind::TraitObject(_, lt) => match lt.name {\n-                                LifetimeName::ImplicitObjectLifetimeDefault => {\n-                                    err.span_suggestion_verbose(\n-                                        fn_return.span.shrink_to_hi(),\n-                                        &format!(\n-                                            \"{declare} trait object {captures}, {explicit}\",\n-                                            declare = declare,\n-                                            captures = captures,\n-                                            explicit = explicit,\n-                                        ),\n-                                        plus_lt.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                name if name.ident().to_string() != lifetime_name => {\n-                                    // With this check we avoid suggesting redundant bounds. This\n-                                    // would happen if there are nested impl/dyn traits and only\n-                                    // one of them has the bound we'd suggest already there, like\n-                                    // in `impl Foo<X = dyn Bar> + '_`.\n-                                    err.span_suggestion_verbose(\n-                                        lt.span,\n-                                        &format!(\"{} trait object's {}\", consider, explicit_static),\n-                                        lifetime_name.clone(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    err.span_suggestion_verbose(\n-                                        param_info.param_ty_span,\n-                                        add_static_bound,\n-                                        param_info.param_ty.to_string(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                _ => {}\n-                            },\n                             _ => {}\n-                        }\n+                        },\n+                        _ => {}\n                     }\n-                    err.emit();\n-                    return Some(ErrorReported);\n                 }\n+                err.emit();\n+                return Some(ErrorReported);\n             }\n         }\n         None"}, {"sha": "fa999abb1a86c46b672c88b81b49d1efc36f5fea", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=2d280a55a9820ab18b25b8080d30e6d0a864ec17", "patch": "@@ -3,7 +3,7 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::{self, DefIdTree, Region, Ty};\n use rustc_span::Span;\n \n@@ -92,7 +92,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // FIXME(#42703) - Need to handle certain cases here.\n     pub(super) fn is_return_type_anon(\n         &self,\n-        scope_def_id: DefId,\n+        scope_def_id: LocalDefId,\n         br: ty::BoundRegion,\n         decl: &hir::FnDecl<'_>,\n     ) -> Option<Span> {\n@@ -112,9 +112,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to\n     // enable E0621 for it.\n-    pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n+    pub(super) fn is_self_anon(&self, is_first: bool, scope_def_id: LocalDefId) -> bool {\n         is_first\n-            && self.tcx().opt_associated_item(scope_def_id).map(|i| i.fn_has_self_parameter)\n+            && self\n+                .tcx()\n+                .opt_associated_item(scope_def_id.to_def_id())\n+                .map(|i| i.fn_has_self_parameter)\n                 == Some(true)\n     }\n }"}, {"sha": "44c8c1f6fdba44ecaf1cf9af4197d86ebb2ae242", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=2d280a55a9820ab18b25b8080d30e6d0a864ec17", "patch": "@@ -873,8 +873,8 @@ impl<'tcx> CommonConsts<'tcx> {\n // conflict.\n #[derive(Debug)]\n pub struct FreeRegionInfo {\n-    // def id corresponding to FreeRegion\n-    pub def_id: DefId,\n+    // `LocalDefId` corresponding to FreeRegion\n+    pub def_id: LocalDefId,\n     // the bound region corresponding to FreeRegion\n     pub boundregion: ty::BoundRegion,\n     // checks if bound region is in Impl Item\n@@ -1412,14 +1412,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n     pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n-            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ref ebr) => {\n-                (self.parent(ebr.def_id).unwrap(), ty::BoundRegion::BrNamed(ebr.def_id, ebr.name))\n+            ty::ReFree(ref free_region) => {\n+                (free_region.scope.expect_local(), free_region.bound_region)\n             }\n+            ty::ReEarlyBound(ref ebr) => (\n+                self.parent(ebr.def_id).unwrap().expect_local(),\n+                ty::BoundRegion::BrNamed(ebr.def_id, ebr.name),\n+            ),\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope.expect_local());\n+        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope);\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1515,8 +1518,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Checks if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: DefId) -> bool {\n-        let container_id = self.associated_item(suitable_region_binding_scope).container.id();\n+    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: LocalDefId) -> bool {\n+        let container_id =\n+            self.associated_item(suitable_region_binding_scope.to_def_id()).container.id();\n         if self.impl_trait_ref(container_id).is_some() {\n             // For now, we do not try to target impls of traits. This is\n             // because this message is going to suggest that the user"}, {"sha": "99b9788c20b053b549c6b5eb918e2fc60ab27076", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=2d280a55a9820ab18b25b8080d30e6d0a864ec17", "patch": "@@ -579,11 +579,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n+            if let Some((&ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n                 .infcx\n                 .tcx\n                 .is_suitable_region(f)\n-                .map(|r| r.def_id.expect_local())\n+                .map(|r| r.def_id)\n                 .map(|id| self.infcx.tcx.return_type_impl_trait(id))\n                 .unwrap_or(None)\n             {\n@@ -592,7 +592,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 //\n                 // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n                 let has_static_predicate = {\n-                    let predicates_of = self.infcx.tcx.predicates_of(*did);\n+                    let predicates_of = self.infcx.tcx.predicates_of(did);\n                     let bounds = predicates_of.instantiate(self.infcx.tcx, substs);\n \n                     let mut found = false;\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = self.infcx.tcx.def_span(*did);\n+                    let span = self.infcx.tcx.def_span(did);\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestable_fr_name = if fr_name.was_named() {\n                             fr_name.to_string()"}, {"sha": "7b292ee71f99d22f49dbef2ad6e5f4256b0473e2", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d280a55a9820ab18b25b8080d30e6d0a864ec17/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=2d280a55a9820ab18b25b8080d30e6d0a864ec17", "patch": "@@ -232,8 +232,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     ) -> Self {\n         let tcx = infcx.tcx;\n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id);\n-        UniversalRegionsBuilder { infcx, mir_def_id: mir_def_id.to_def_id(), mir_hir_id, param_env }\n-            .build()\n+        UniversalRegionsBuilder { infcx, mir_def_id, mir_hir_id, param_env }.build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -389,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n@@ -418,15 +417,15 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let mut indices = self.compute_indices(fr_static, defining_ty);\n         debug!(\"build: indices={:?}\", indices);\n \n-        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = self.infcx.tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n \n         // If this is a closure or generator, then the late-bound regions from the enclosing\n         // function are actually external regions to us. For example, here, 'a is not local\n         // to the closure c (although it is local to the fn foo):\n         // fn foo<'a>() {\n         //     let c = || { let x: &'a u32 = ...; }\n         // }\n-        if self.mir_def_id != closure_base_def_id {\n+        if self.mir_def_id.to_def_id() != closure_base_def_id {\n             self.infcx.replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices)\n         }\n \n@@ -443,7 +442,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         );\n         // Converse of above, if this is a function then the late-bound regions declared on its\n         // signature are local to the fn.\n-        if self.mir_def_id == closure_base_def_id {\n+        if self.mir_def_id.to_def_id() == closure_base_def_id {\n             self.infcx\n                 .replace_late_bound_regions_with_nll_infer_vars(self.mir_def_id, &mut indices);\n         }\n@@ -508,14 +507,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     /// see `DefiningTy` for details.\n     fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n \n         match tcx.hir().body_owner_kind(self.mir_hir_id) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = if self.mir_def_id == closure_base_def_id {\n+                let defining_ty = if self.mir_def_id.to_def_id() == closure_base_def_id {\n                     tcx.type_of(closure_base_def_id)\n                 } else {\n-                    let tables = tcx.typeck_tables_of(self.mir_def_id.expect_local());\n+                    let tables = tcx.typeck_tables_of(self.mir_def_id);\n                     tables.node_type(self.mir_hir_id)\n                 };\n \n@@ -540,11 +539,11 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             BodyOwnerKind::Const | BodyOwnerKind::Static(..) => {\n-                assert_eq!(closure_base_def_id, self.mir_def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), closure_base_def_id);\n                 let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n                 let substs =\n                     self.infcx.replace_free_regions_with_nll_infer_vars(FR, &identity_substs);\n-                DefiningTy::Const(self.mir_def_id, substs)\n+                DefiningTy::Const(self.mir_def_id.to_def_id(), substs)\n             }\n         }\n     }\n@@ -559,7 +558,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, ref substs) | DefiningTy::Generator(_, ref substs, _) => {\n@@ -593,7 +592,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n@@ -617,7 +616,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let resume_ty = substs.as_generator().resume_ty();\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n@@ -635,7 +634,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::Const(def_id, _) => {\n                 // For a constant body, there are no inputs, and one\n                 // \"output\" (the type of the constant).\n-                assert_eq!(self.mir_def_id, def_id);\n+                assert_eq!(self.mir_def_id.to_def_id(), def_id);\n                 let ty = tcx.type_of(def_id);\n                 let ty = indices.fold_to_region_vids(tcx, &ty);\n                 ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n@@ -656,7 +655,7 @@ trait InferCtxtExt<'tcx> {\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        all_outlive_scope: DefId,\n+        all_outlive_scope: LocalDefId,\n         value: &ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n@@ -665,7 +664,7 @@ trait InferCtxtExt<'tcx> {\n \n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     );\n }\n@@ -685,7 +684,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NLLRegionVariableOrigin,\n-        all_outlive_scope: DefId,\n+        all_outlive_scope: LocalDefId,\n         value: &ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n@@ -699,7 +698,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope,\n+                scope: all_outlive_scope.to_def_id(),\n                 bound_region: br,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n@@ -724,11 +723,11 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// inputs vector.\n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n         debug!(\"replace_late_bound_regions_with_nll_infer_vars(mir_def_id={:?})\", mir_def_id);\n-        let closure_base_def_id = self.tcx.closure_base_def_id(mir_def_id);\n+        let closure_base_def_id = self.tcx.closure_base_def_id(mir_def_id.to_def_id());\n         for_each_late_bound_region_defined_on(self.tcx, closure_base_def_id, |r| {\n             debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n             if !indices.indices.contains_key(&r) {"}]}