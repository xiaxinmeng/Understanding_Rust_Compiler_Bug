{"sha": "f1836c453a34bf7904508146598568dc47dcffea", "node_id": "C_kwDOAAsO6NoAKGYxODM2YzQ1M2EzNGJmNzkwNDUwODE0NjU5ODU2OGRjNDdkY2ZmZWE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-01T12:09:33Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-04T11:58:29Z"}, "message": "update infer cost computation for types", "tree": {"sha": "05cfa1945253a1122c20551f8d711040e53ccd48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05cfa1945253a1122c20551f8d711040e53ccd48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1836c453a34bf7904508146598568dc47dcffea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1836c453a34bf7904508146598568dc47dcffea", "html_url": "https://github.com/rust-lang/rust/commit/f1836c453a34bf7904508146598568dc47dcffea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1836c453a34bf7904508146598568dc47dcffea/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ed08715b2f6b946089ccf967d18e70bb04ea39", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ed08715b2f6b946089ccf967d18e70bb04ea39", "html_url": "https://github.com/rust-lang/rust/commit/c2ed08715b2f6b946089ccf967d18e70bb04ea39"}], "stats": {"total": 138, "additions": 101, "deletions": 37}, "files": [{"sha": "f8ee006b9c89a8cad20b912a66e400a332ca92c2", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f1836c453a34bf7904508146598568dc47dcffea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1836c453a34bf7904508146598568dc47dcffea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=f1836c453a34bf7904508146598568dc47dcffea", "patch": "@@ -602,41 +602,58 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     /// Sources with a small cost are prefer and should result\n     /// in a clearer and idiomatic suggestion.\n     fn source_cost(&self, source: &InferSource<'tcx>) -> usize {\n-        let tcx = self.infcx.tcx;\n-\n-        fn arg_cost<'tcx>(arg: GenericArg<'tcx>) -> usize {\n-            match arg.unpack() {\n-                GenericArgKind::Lifetime(_) => 0, // erased\n-                GenericArgKind::Type(ty) => ty_cost(ty),\n-                GenericArgKind::Const(_) => 3, // some non-zero value\n-            }\n+        #[derive(Clone, Copy)]\n+        struct CostCtxt<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n         }\n-        fn ty_cost<'tcx>(ty: Ty<'tcx>) -> usize {\n-            match ty.kind() {\n-                ty::Closure(..) => 100,\n-                ty::FnDef(..) => 20,\n-                ty::FnPtr(..) => 10,\n-                ty::Infer(..) => 0,\n-                _ => 1,\n+        impl<'tcx> CostCtxt<'tcx> {\n+            fn arg_cost(self, arg: GenericArg<'tcx>) -> usize {\n+                match arg.unpack() {\n+                    GenericArgKind::Lifetime(_) => 0, // erased\n+                    GenericArgKind::Type(ty) => self.ty_cost(ty),\n+                    GenericArgKind::Const(_) => 3, // some non-zero value\n+                }\n+            }\n+            fn ty_cost(self, ty: Ty<'tcx>) -> usize {\n+                match ty.kind() {\n+                    ty::Closure(..) => 1000,\n+                    ty::FnDef(..) => 150,\n+                    ty::FnPtr(..) => 30,\n+                    ty::Adt(def, substs) => {\n+                        5 + self\n+                            .tcx\n+                            .generics_of(def.did())\n+                            .own_substs_no_defaults(self.tcx, substs)\n+                            .iter()\n+                            .map(|&arg| self.arg_cost(arg))\n+                            .sum::<usize>()\n+                    }\n+                    ty::Tuple(args) => 5 + args.iter().map(|arg| self.ty_cost(arg)).sum::<usize>(),\n+                    ty::Infer(..) => 0,\n+                    _ => 1,\n+                }\n             }\n         }\n \n         // The sources are listed in order of preference here.\n+        let tcx = self.infcx.tcx;\n+        let ctx = CostCtxt { tcx };\n         match source.kind {\n-            InferSourceKind::LetBinding { ty, .. } => ty_cost(ty),\n-            InferSourceKind::ClosureArg { ty, .. } => 5 + ty_cost(ty),\n+            InferSourceKind::LetBinding { ty, .. } => ctx.ty_cost(ty),\n+            InferSourceKind::ClosureArg { ty, .. } => ctx.ty_cost(ty),\n             InferSourceKind::GenericArg { def_id, generic_args, .. } => {\n                 let variant_cost = match tcx.def_kind(def_id) {\n-                    DefKind::Variant | DefKind::Ctor(CtorOf::Variant, _) => 15, // `None::<u32>` and friends are ugly.\n-                    _ => 12,\n+                    // `None::<u32>` and friends are ugly.\n+                    DefKind::Variant | DefKind::Ctor(CtorOf::Variant, _) => 15,\n+                    _ => 10,\n                 };\n-                variant_cost + generic_args.iter().map(|&arg| arg_cost(arg)).sum::<usize>()\n+                variant_cost + generic_args.iter().map(|&arg| ctx.arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::FullyQualifiedMethodCall { substs, .. } => {\n-                20 + substs.iter().map(|arg| arg_cost(arg)).sum::<usize>()\n+                20 + substs.iter().map(|arg| ctx.arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::ClosureReturn { ty, should_wrap_expr, .. } => {\n-                30 + ty_cost(ty) + if should_wrap_expr.is_some() { 10 } else { 0 }\n+                30 + ctx.ty_cost(ty) + if should_wrap_expr.is_some() { 10 } else { 0 }\n             }\n         }\n     }\n@@ -646,6 +663,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn update_infer_source(&mut self, new_source: InferSource<'tcx>) {\n         let cost = self.source_cost(&new_source) + self.attempt;\n+        debug!(?cost);\n         self.attempt += 1;\n         if cost < self.infer_source_cost {\n             self.infer_source_cost = cost;"}, {"sha": "e2ba5a9417138abf8a4de9ef6a6eea6b0ce38dbe", "filename": "src/test/ui/inference/need_type_info/channel.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs?ref=f1836c453a34bf7904508146598568dc47dcffea", "patch": "@@ -0,0 +1,19 @@\n+// Test that we suggest specifying the generic argument of `channel`\n+// instead of the return type of that function, which is a lot more\n+// complex.\n+use std::sync::mpsc::channel;\n+\n+fn no_tuple() {\n+    let _data =\n+        channel(); //~ ERROR type annotations needed\n+}\n+\n+fn tuple() {\n+    let (_sender, _receiver) =\n+        channel(); //~ ERROR type annotations needed\n+}\n+\n+fn main() {\n+    no_tuple();\n+    tuple();\n+}"}, {"sha": "e33ace0338d5040b8b360870082532aa02df23f7", "filename": "src/test/ui/inference/need_type_info/channel.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr?ref=f1836c453a34bf7904508146598568dc47dcffea", "patch": "@@ -0,0 +1,25 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/channel.rs:8:9\n+   |\n+LL |         channel();\n+   |         ^^^^^^^ cannot infer type of the type parameter `T` declared on the function `channel`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |         channel::<T>();\n+   |                +++++\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/channel.rs:13:9\n+   |\n+LL |         channel();\n+   |         ^^^^^^^ cannot infer type of the type parameter `T` declared on the function `channel`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |         channel::<T>();\n+   |                +++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "4be83457f7a8be46f232542df8f4eb392be9eeb6", "filename": "src/test/ui/issues/issue-25368.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs?ref=f1836c453a34bf7904508146598568dc47dcffea", "patch": "@@ -5,10 +5,10 @@ use std::marker::PhantomData;\n struct Foo<T> {foo: PhantomData<T>}\n \n fn main() {\n-    let (tx, rx) = //~ ERROR type annotations needed\n+    let (tx, rx) =\n         channel();\n-    // FIXME(#89862): Suggest adding a generic argument to `channel` instead\n     spawn(move || {\n         tx.send(Foo{ foo: PhantomData });\n+        //~^ ERROR type annotations needed\n     });\n }"}, {"sha": "e6ed3aac71032f1d646a4d6efa09785f6abb3934", "filename": "src/test/ui/issues/issue-25368.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr?ref=f1836c453a34bf7904508146598568dc47dcffea", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed for `(Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>)`\n-  --> $DIR/issue-25368.rs:8:9\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-25368.rs:11:27\n    |\n-LL |     let (tx, rx) =\n-   |         ^^^^^^^^\n+LL |         tx.send(Foo{ foo: PhantomData });\n+   |                           ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n    |\n-help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+help: consider specifying the generic argument\n    |\n-LL |     let (tx, rx): (Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>) =\n-   |                 +++++++++++++++++++++++++++++++++++++++++++++++++++++\n+LL |         tx.send(Foo{ foo: PhantomData::<T> });\n+   |                                      +++++\n \n error: aborting due to previous error\n "}, {"sha": "00f8a747c71228a506ce0a4c892ab2cc6a303263", "filename": "src/test/ui/type/type-check/cannot_infer_local_or_vec_in_tuples.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1836c453a34bf7904508146598568dc47dcffea/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr?ref=f1836c453a34bf7904508146598568dc47dcffea", "patch": "@@ -1,13 +1,15 @@\n-error[E0282]: type annotations needed for `(Vec<T>,)`\n-  --> $DIR/cannot_infer_local_or_vec_in_tuples.rs:2:9\n+error[E0282]: type annotations needed\n+  --> $DIR/cannot_infer_local_or_vec_in_tuples.rs:2:18\n    |\n LL |     let (x, ) = (vec![], );\n-   |         ^^^^^\n+   |                  ^^^^^^ cannot infer type of the type parameter `T` declared on the struct `Vec`\n    |\n-help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider specifying the generic argument\n+  --> $SRC_DIR/alloc/src/macros.rs:LL:COL\n    |\n-LL |     let (x, ): (Vec<T>,) = (vec![], );\n-   |              +++++++++++\n+LL |         $crate::__rust_force_expr!($crate::vec::Vec::<T>::new())\n+   |                                                    +++++\n \n error: aborting due to previous error\n "}]}