{"sha": "d409dbf98343fe69f8bd61e81b733c91c376217a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MDlkYmY5ODM0M2ZlNjlmOGJkNjFlODFiNzMzYzkxYzM3NjIxN2E=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2017-11-27T08:06:36Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2017-11-27T08:06:36Z"}, "message": "Add initialization info to `MoveData`\n\n* Used for new dataflow to track if a variable has every been initialized\n* Used for other dataflows that need to be updated for initializations", "tree": {"sha": "441d5ba90544993de0d983a1db8cea4d237fd3b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441d5ba90544993de0d983a1db8cea4d237fd3b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d409dbf98343fe69f8bd61e81b733c91c376217a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d409dbf98343fe69f8bd61e81b733c91c376217a", "html_url": "https://github.com/rust-lang/rust/commit/d409dbf98343fe69f8bd61e81b733c91c376217a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d409dbf98343fe69f8bd61e81b733c91c376217a/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "827cb0d61e22eb6d5c9c5e8e8d05b07108a9968b", "url": "https://api.github.com/repos/rust-lang/rust/commits/827cb0d61e22eb6d5c9c5e8e8d05b07108a9968b", "html_url": "https://github.com/rust-lang/rust/commit/827cb0d61e22eb6d5c9c5e8e8d05b07108a9968b"}], "stats": {"total": 512, "additions": 389, "deletions": 123}, "files": [{"sha": "57735807edbb09bfb0418477fa43bb675ebf7336", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -31,7 +31,7 @@ use dataflow::{do_dataflow};\n use dataflow::{MoveDataParamEnv};\n use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{MovingOutStatements};\n+use dataflow::{MovingOutStatements, EverInitializedLvals};\n use dataflow::{Borrows, BorrowData, BorrowIndex};\n use dataflow::move_paths::{MoveError, IllegalMoveOriginKind};\n use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult, MoveOutIndex};\n@@ -130,6 +130,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let flow_move_outs = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                                      MovingOutStatements::new(tcx, mir, &mdpe),\n                                      |bd, i| &bd.move_data().moves[i]);\n+    let flow_ever_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                     EverInitializedLvals::new(tcx, mir, &mdpe),\n+                                     |bd, i| &bd.move_data().inits[i]);\n \n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n@@ -143,7 +146,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let mut state = InProgress::new(flow_borrows,\n                                     flow_inits,\n                                     flow_uninits,\n-                                    flow_move_outs);\n+                                    flow_move_outs,\n+                                    flow_ever_inits);\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n }\n@@ -167,6 +171,7 @@ pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n     inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n     uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n     move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+    ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n }\n \n struct FlowInProgress<BD> where BD: BitDenotation {\n@@ -190,7 +195,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n                              |i| i.reset_to_entry_of(bb),\n                              |u| u.reset_to_entry_of(bb),\n-                             |m| m.reset_to_entry_of(bb));\n+                             |m| m.reset_to_entry_of(bb),\n+                             |e| e.reset_to_entry_of(bb));\n     }\n \n     fn reconstruct_statement_effect(&mut self,\n@@ -199,7 +205,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n                              |i| i.reconstruct_statement_effect(location),\n                              |u| u.reconstruct_statement_effect(location),\n-                             |m| m.reconstruct_statement_effect(location));\n+                             |m| m.reconstruct_statement_effect(location),\n+                             |e| e.reconstruct_statement_effect(location));\n     }\n \n     fn apply_local_effect(&mut self,\n@@ -208,7 +215,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         flow_state.each_flow(|b| b.apply_local_effect(),\n                              |i| i.apply_local_effect(),\n                              |u| u.apply_local_effect(),\n-                             |m| m.apply_local_effect());\n+                             |m| m.apply_local_effect(),\n+                             |e| e.apply_local_effect());\n     }\n \n     fn reconstruct_terminator_effect(&mut self,\n@@ -217,7 +225,8 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n                              |i| i.reconstruct_terminator_effect(location),\n                              |u| u.reconstruct_terminator_effect(location),\n-                             |m| m.reconstruct_terminator_effect(location));\n+                             |m| m.reconstruct_terminator_effect(location),\n+                             |e| e.reconstruct_terminator_effect(location));\n     }\n \n     fn visit_block_entry(&mut self,\n@@ -750,22 +759,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n-            if flow_state.inits.curr_state.contains(&mpi) {\n-                // may already be assigned before reaching this statement;\n-                // report error.\n-                // FIXME: Not ideal, it only finds the assignment that lexically comes first\n-                let assigned_lvalue = &move_data.move_paths[mpi].lvalue;\n-                let assignment_stmt = self.mir.basic_blocks().iter().filter_map(|bb| {\n-                    bb.statements.iter().find(|stmt| {\n-                        if let StatementKind::Assign(ref lv, _) = stmt.kind {\n-                            *lv == *assigned_lvalue\n-                        } else {\n-                            false\n-                        }\n-                    })\n-                }).next().unwrap();\n-                self.report_illegal_reassignment(\n-                    context, (lvalue, span), assignment_stmt.source_info.span);\n+            for ii in &move_data.init_path_map[mpi] {\n+                if flow_state.ever_inits.curr_state.contains(ii) {\n+                    let first_assign_span = self.move_data.inits[*ii].span;\n+                    self.report_illegal_reassignment(\n+                        context, (lvalue, span), first_assign_span);\n+                    break;\n+                }\n             }\n         }\n     }\n@@ -1852,30 +1852,35 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n     pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'gcx, 'tcx>>,\n                       inits: DataflowResults<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n                       uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-                      move_out: DataflowResults<MovingOutStatements<'b, 'gcx, 'tcx>>)\n+                      move_out: DataflowResults<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+                      ever_inits: DataflowResults<EverInitializedLvals<'b, 'gcx, 'tcx>>)\n                       -> Self {\n         InProgress {\n             borrows: FlowInProgress::new(borrows),\n             inits: FlowInProgress::new(inits),\n             uninits: FlowInProgress::new(uninits),\n-            move_outs: FlowInProgress::new(move_out)\n+            move_outs: FlowInProgress::new(move_out),\n+            ever_inits: FlowInProgress::new(ever_inits)\n         }\n     }\n \n-    fn each_flow<XB, XI, XU, XM>(&mut self,\n+    fn each_flow<XB, XI, XU, XM, XE>(&mut self,\n                                  mut xform_borrows: XB,\n                                  mut xform_inits: XI,\n                                  mut xform_uninits: XU,\n-                                 mut xform_move_outs: XM) where\n+                                 mut xform_move_outs: XM,\n+                                 mut xform_ever_inits: XE) where\n         XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n         XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n         XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n         XM: FnMut(&mut FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>),\n+        XE: FnMut(&mut FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>),\n     {\n         xform_borrows(&mut self.borrows);\n         xform_inits(&mut self.inits);\n         xform_uninits(&mut self.uninits);\n         xform_move_outs(&mut self.move_outs);\n+        xform_ever_inits(&mut self.ever_inits);\n     }\n \n     fn summary(&self) -> String {\n@@ -1932,6 +1937,17 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n                 &self.move_outs.base_results.operator().move_data().moves[mpi_move_out];\n             s.push_str(&format!(\"{:?}\", move_out));\n         });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"ever_init: [\");\n+        let mut saw_one = false;\n+        self.ever_inits.each_state_bit(|mpi_ever_init| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let ever_init =\n+                &self.ever_inits.base_results.operator().move_data().inits[mpi_ever_init];\n+            s.push_str(&format!(\"{:?}\", ever_init));\n+        });\n         s.push_str(\"]\");\n \n         return s;"}, {"sha": "92539321300d5a4f30f4ffcb502307db7edf0dd3", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -14,7 +14,7 @@ use util::elaborate_drops::DropFlagState;\n \n use super::{MoveDataParamEnv};\n use super::indexes::MovePathIndex;\n-use super::move_paths::{MoveData, LookupResult};\n+use super::move_paths::{MoveData, LookupResult, InitKind};\n \n pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n@@ -197,47 +197,40 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n                              |mpi| callback(mpi, DropFlagState::Absent))\n     }\n \n-    let block = &mir[loc.block];\n-    match block.statements.get(loc.statement_index) {\n-        Some(stmt) => match stmt.kind {\n-            mir::StatementKind::SetDiscriminant{ .. } => {\n-                span_bug!(stmt.source_info.span, \"SetDiscrimant should not exist during borrowck\");\n-            }\n-            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                match rvalue.initialization_state() {\n-                    mir::tcx::RvalueInitializationState::Shallow => {\n-                        debug!(\"drop_flag_effects: box assignment {:?}\", stmt);\n-                        if let LookupResult::Exact(mpi) = move_data.rev_lookup.find(lvalue) {\n-                            callback(mpi, DropFlagState::Present);\n-                        }\n-                    }\n-                    mir::tcx::RvalueInitializationState::Deep => {\n-                        debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n-                        on_lookup_result_bits(tcx, mir, move_data,\n-                                              move_data.rev_lookup.find(lvalue),\n-                                              |mpi| callback(mpi, DropFlagState::Present))\n-                    }\n-                }\n-            }\n-            mir::StatementKind::StorageLive(_) |\n-            mir::StatementKind::StorageDead(_) |\n-            mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n-            mir::StatementKind::Nop => {}\n-        },\n-        None => {\n-            debug!(\"drop_flag_effects: replace {:?}\", block.terminator());\n-            match block.terminator().kind {\n-                mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                    on_lookup_result_bits(tcx, mir, move_data,\n-                                          move_data.rev_lookup.find(location),\n-                                          |mpi| callback(mpi, DropFlagState::Present))\n-                }\n-                _ => {\n-                    // other terminators do not contain move-ins\n-                }\n+    debug!(\"drop_flag_effects: assignment for location({:?})\", loc);\n+\n+    for_location_inits(\n+        tcx,\n+        mir,\n+        move_data,\n+        loc,\n+        |mpi| callback(mpi, DropFlagState::Present)\n+    );\n+}\n+\n+pub(crate) fn for_location_inits<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    loc: Location,\n+    mut callback: F)\n+    where F: FnMut(MovePathIndex)\n+{\n+    for ii in &move_data.init_loc_map[loc] {\n+        let init = move_data.inits[*ii];\n+        match init.kind {\n+            InitKind::Deep => {\n+                let path = init.path;\n+\n+                on_all_children_bits(tcx, mir, move_data,\n+                                    path,\n+                                    &mut callback)\n+            },\n+            InitKind::Shallow => {\n+                let mpi = init.path;\n+                callback(mpi);\n             }\n+            InitKind::NonPanicPathOnly => (),\n         }\n     }\n }"}, {"sha": "f9f03023cc9f7635bd4ecd99d001cf2da0037688", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 168, "deletions": 54, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -22,13 +22,13 @@ use rustc_data_structures::indexed_vec::Idx;\n use super::MoveDataParamEnv;\n use util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n-use super::move_paths::LookupResult;\n+use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex, InitIndex};\n+use super::move_paths::{LookupResult, InitKind};\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n-use super::on_lookup_result_bits;\n+use super::{on_lookup_result_bits, for_location_inits};\n \n mod storage_liveness;\n \n@@ -242,6 +242,56 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n+/// `EverInitializedLvals` tracks all l-values that might have ever been\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function, without an intervening `Storage Dead`.\n+///\n+/// This dataflow is used to determine if an immutable local variable may\n+/// be assigned to.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // ever-init:\n+///                                            // {          }\n+///     let a = S; let b = S; let c; let d;    // {a, b      }\n+///\n+///     if pred {\n+///         drop(a);                           // {a, b,     }\n+///         b = S;                             // {a, b,     }\n+///\n+///     } else {\n+///         drop(b);                           // {a, b,      }\n+///         d = S;                             // {a, b,    d }\n+///\n+///     }                                      // {a, b,    d }\n+///\n+///     c = S;                                 // {a, b, c, d }\n+/// }\n+/// ```\n+pub struct EverInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedLvals<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n+               -> Self\n+    {\n+        EverInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n+}\n+\n+\n impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n@@ -454,7 +504,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n         let stmt = &mir[location.block].statements[location.statement_index];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n-        let rev_lookup = &move_data.rev_lookup;\n+        let bits_per_block = self.bits_per_block();\n \n         match stmt.kind {\n             // this analysis only tries to find moves explicitly\n@@ -474,72 +524,37 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let bits_per_block = self.bits_per_block();\n-        match stmt.kind {\n-            mir::StatementKind::SetDiscriminant { .. } => {\n-                span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n+        for_location_inits(tcx, mir, move_data, location,\n+            |mpi| for moi in &path_map[mpi] {\n+                assert!(moi.index() < bits_per_block);\n+                sets.kill_set.add(&moi);\n             }\n-            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                // assigning into this `lvalue` kills all\n-                // MoveOuts from it, and *also* all MoveOuts\n-                // for children and associated fragment sets.\n-                match rvalue.initialization_state() {\n-                    mir::tcx::RvalueInitializationState::Shallow => {\n-                        if let LookupResult::Exact(mpi) = rev_lookup.find(lvalue) {\n-                             for moi in &path_map[mpi] {\n-                                 assert!(moi.index() < bits_per_block);\n-                                 sets.kill_set.add(&moi);\n-                             }\n-                        }\n-                    }\n-                    mir::tcx::RvalueInitializationState::Deep => {\n-                        on_lookup_result_bits(tcx,\n-                                              mir,\n-                                              move_data,\n-                                              rev_lookup.find(lvalue),\n-                                              |mpi| for moi in &path_map[mpi] {\n-                                                  assert!(moi.index() < bits_per_block);\n-                                                  sets.kill_set.add(&moi);\n-                                              });\n-                    }\n-                }\n-            }\n-            mir::StatementKind::StorageLive(_) |\n-            mir::StatementKind::StorageDead(_) |\n-            mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n-            mir::StatementKind::Nop => {}\n-        }\n+        );\n     }\n \n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<MoveOutIndex>,\n                          location: Location)\n     {\n-        let (mir, move_data) = (self.mir, self.move_data());\n+        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n         let term = mir[location.block].terminator();\n         let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+\n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                term, location, &loc_map[location]);\n         let bits_per_block = self.bits_per_block();\n         for move_index in &loc_map[location] {\n             assert!(move_index.index() < bits_per_block);\n             zero_to_one(sets.gen_set.words_mut(), *move_index);\n         }\n-        match term.kind {\n-            mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                on_lookup_result_bits(self.tcx,\n-                                      mir,\n-                                      move_data,\n-                                      move_data.rev_lookup.find(location),\n-                                      |mpi| for moi in &move_data.path_map[mpi] {\n-                                          assert!(moi.index() < bits_per_block);\n-                                          sets.kill_set.add(&moi);\n-                                      });\n+\n+        for_location_inits(tcx, mir, move_data, location,\n+            |mpi| for moi in &path_map[mpi] {\n+                assert!(moi.index() < bits_per_block);\n+                sets.kill_set.add(&moi);\n             }\n-            _ => {}\n-        }\n+        );\n     }\n \n     fn propagate_call_return(&self,\n@@ -562,12 +577,97 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+    type Idx = InitIndex;\n+    fn name() -> &'static str { \"ever_init\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.move_data().inits.len()\n+    }\n+\n+    fn start_block_effect(&self, sets: &mut BlockSets<InitIndex>) {\n+        let bits_per_block = self.bits_per_block();\n+        for init_index in (0..self.mir.arg_count).map(InitIndex::new) {\n+            assert!(init_index.index() < bits_per_block);\n+            sets.gen_set.add(&init_index);\n+        }\n+    }\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<InitIndex>,\n+                        location: Location) {\n+        let (_, mir, move_data) = (self.tcx, self.mir, self.move_data());\n+        let stmt = &mir[location.block].statements[location.statement_index];\n+        let init_path_map = &move_data.init_path_map;\n+        let init_loc_map = &move_data.init_loc_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+        let bits_per_block = self.bits_per_block();\n+\n+        debug!(\"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n+               stmt, location, &init_loc_map[location]);\n+        for init_index in &init_loc_map[location] {\n+            assert!(init_index.index() < bits_per_block);\n+            sets.gen_set.add(init_index);\n+        }\n+\n+        match stmt.kind {\n+            mir::StatementKind::StorageDead(local) => {\n+                // End inits for StorageDead, so that an immutable variable can\n+                // be reinitialized on the next iteration of the loop.\n+                if let LookupResult::Exact(mpi) = rev_lookup.find(&mir::Lvalue::Local(local)) {\n+                    debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n+                        stmt, location, &init_path_map[mpi]);\n+                    for ii in &init_path_map[mpi] {\n+                        assert!(ii.index() < bits_per_block);\n+                        sets.kill_set.add(&ii);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut BlockSets<InitIndex>,\n+                         location: Location)\n+    {\n+        let (mir, move_data) = (self.mir, self.move_data());\n+        let term = mir[location.block].terminator();\n+        let init_loc_map = &move_data.init_loc_map;\n+        debug!(\"terminator {:?} at loc {:?} initializes move_indexes {:?}\",\n+               term, location, &init_loc_map[location]);\n+        let bits_per_block = self.bits_per_block();\n+        for init_index in &init_loc_map[location] {\n+            if move_data.inits[*init_index].kind != InitKind::NonPanicPathOnly {\n+                assert!(init_index.index() < bits_per_block);\n+                sets.gen_set.add(init_index);\n+            }\n+        }\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             in_out: &mut IdxSet<InitIndex>,\n+                             call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             _dest_lval: &mir::Lvalue) {\n+        let move_data = self.move_data();\n+        let bits_per_block = self.bits_per_block();\n+        let init_loc_map = &move_data.init_loc_map;\n+\n+        let call_loc = Location {\n+            block: call_bb,\n+            statement_index: self.mir[call_bb].statements.len(),\n+        };\n+        for init_index in &init_loc_map[call_loc] {\n+            assert!(init_index.index() < bits_per_block);\n+            in_out.add(init_index);\n+        }\n+    }\n+}\n+\n fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n     let retval = bitvec.set_bit(move_index.index());\n     assert!(retval);\n }\n \n-\n impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n@@ -596,6 +696,13 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // inits from both preds are in scope\n+    }\n+}\n+\n // The way that dataflow fixed point iteration works, you want to\n // start at bottom and work your way to a fixed point. Control-flow\n // merges will apply the `join` operator to each block entry's current\n@@ -633,3 +740,10 @@ impl<'a, 'gcx, 'tcx> DataflowOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n         false // bottom = no loans in scope by default\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> DataflowOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = no initialized variables by default\n+    }\n+}"}, {"sha": "711b8091ec8f4938893a98dad5c2f6584f35e965", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -27,6 +27,7 @@ use std::usize;\n pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n+pub use self::impls::EverInitializedLvals;\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n pub(crate) use self::drop_flag_effects::*;\n "}, {"sha": "af582b8cf66a18bcade67e4b28cd4aab537df73b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -22,7 +22,7 @@ use std::mem;\n use super::abs_domain::Lift;\n \n use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, MoveOut, MoveOutIndex};\n-use super::{MoveError};\n+use super::{MoveError, InitIndex, Init, LookupResult, InitKind};\n use super::IllegalMoveOriginKind::*;\n \n struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n@@ -40,6 +40,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n            -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n+        let mut init_path_map = IndexVec::new();\n \n         MoveDataBuilder {\n             mir,\n@@ -51,18 +52,28 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n                 loc_map: LocationMap::new(mir),\n                 rev_lookup: MovePathLookup {\n                     locals: mir.local_decls.indices().map(Lvalue::Local).map(|v| {\n-                        Self::new_move_path(&mut move_paths, &mut path_map, None, v)\n+                        Self::new_move_path(\n+                            &mut move_paths,\n+                            &mut path_map,\n+                            &mut init_path_map,\n+                            None,\n+                            v,\n+                        )\n                     }).collect(),\n                     projections: FxHashMap(),\n                 },\n                 move_paths,\n                 path_map,\n+                inits: IndexVec::new(),\n+                init_loc_map: LocationMap::new(mir),\n+                init_path_map,\n             }\n         }\n     }\n \n     fn new_move_path(move_paths: &mut IndexVec<MovePathIndex, MovePath<'tcx>>,\n                      path_map: &mut IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n+                     init_path_map: &mut IndexVec<MovePathIndex, Vec<InitIndex>>,\n                      parent: Option<MovePathIndex>,\n                      lvalue: Lvalue<'tcx>)\n                      -> MovePathIndex\n@@ -82,6 +93,10 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n \n         let path_map_ent = path_map.push(vec![]);\n         assert_eq!(path_map_ent, move_path);\n+\n+        let init_path_map_ent = init_path_map.push(vec![]);\n+        assert_eq!(init_path_map_ent, move_path);\n+\n         move_path\n     }\n }\n@@ -165,6 +180,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 let path = MoveDataBuilder::new_move_path(\n                     &mut self.builder.data.move_paths,\n                     &mut self.builder.data.path_map,\n+                    &mut self.builder.data.init_path_map,\n                     Some(base),\n                     lval.clone()\n                 );\n@@ -204,6 +220,8 @@ pub(super) fn gather_moves<'a, 'gcx, 'tcx>(mir: &Mir<'tcx>,\n                                                      (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n     let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n \n+    builder.gather_args();\n+\n     for (bb, block) in mir.basic_blocks().iter_enumerated() {\n         for (i, stmt) in block.statements.iter().enumerate() {\n             let source = Location { block: bb, statement_index: i };\n@@ -221,6 +239,22 @@ pub(super) fn gather_moves<'a, 'gcx, 'tcx>(mir: &Mir<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n+    fn gather_args(&mut self) {\n+        for arg in self.mir.args_iter() {\n+            let path = self.data.rev_lookup.locals[arg];\n+            let span = self.mir.local_decls[arg].source_info.span;\n+\n+            let init = self.data.inits.push(Init {\n+                path, span, kind: InitKind::Deep\n+            });\n+\n+            debug!(\"gather_args: adding init {:?} of {:?} for argument {:?}\",\n+                init, path, arg);\n+\n+            self.data.init_path_map[path].push(init);\n+        }\n+    }\n+\n     fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n         debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n         (Gatherer { builder: self, loc }).gather_statement(stmt);\n@@ -247,6 +281,9 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n                     self.create_move_path(&lval.clone().deref());\n+                    self.gather_init(lval, InitKind::Shallow);\n+                } else {\n+                    self.gather_init(lval, InitKind::Deep);\n                 }\n                 self.gather_rvalue(rval);\n             }\n@@ -329,6 +366,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 self.create_move_path(location);\n                 self.gather_operand(value);\n+                self.gather_init(location, InitKind::Deep);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n                 self.gather_operand(func);\n@@ -337,6 +375,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n                     self.create_move_path(destination);\n+                    self.gather_init(destination, InitKind::NonPanicPathOnly);\n                 }\n             }\n         }\n@@ -378,4 +417,22 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         self.builder.data.path_map[path].push(move_out);\n         self.builder.data.loc_map[self.loc].push(move_out);\n     }\n+\n+    fn gather_init(&mut self, lval: &Lvalue<'tcx>, kind: InitKind) {\n+        debug!(\"gather_init({:?}, {:?})\", self.loc, lval);\n+\n+        if let LookupResult::Exact(path) = self.builder.data.rev_lookup.find(lval) {\n+            let init = self.builder.data.inits.push(Init {\n+                span: self.builder.mir.source_info(self.loc).span,\n+                path,\n+                kind,\n+            });\n+\n+            debug!(\"gather_init({:?}, {:?}): adding init {:?} of {:?}\",\n+               self.loc, lval, init, path);\n+\n+            self.builder.data.init_path_map[path].push(init);\n+            self.builder.data.init_loc_map[self.loc].push(init);\n+        }\n+    }\n }"}, {"sha": "4703dd8a2afa6aa12106a5bd76769433421c45f5", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -60,12 +60,16 @@ pub(crate) mod indexes {\n     /// Index into MoveData.moves.\n     new_index!(MoveOutIndex, \"mo\");\n \n+    /// Index into MoveData.inits.\n+    new_index!(InitIndex, \"in\");\n+\n     /// Index into Borrows.locations\n     new_index!(BorrowIndex, \"bw\");\n }\n \n pub use self::indexes::MovePathIndex;\n pub use self::indexes::MoveOutIndex;\n+pub use self::indexes::InitIndex;\n \n impl MoveOutIndex {\n     pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n@@ -126,6 +130,11 @@ pub struct MoveData<'tcx> {\n     pub loc_map: LocationMap<Vec<MoveOutIndex>>,\n     pub path_map: IndexVec<MovePathIndex, Vec<MoveOutIndex>>,\n     pub rev_lookup: MovePathLookup<'tcx>,\n+    pub inits: IndexVec<InitIndex, Init>,\n+    /// Each Location `l` is mapped to the Inits that are effects\n+    /// of executing the code at `l`.\n+    pub init_loc_map: LocationMap<Vec<InitIndex>>,\n+    pub init_path_map: IndexVec<MovePathIndex, Vec<InitIndex>>,\n }\n \n pub trait HasMoveData<'tcx> {\n@@ -182,6 +191,34 @@ impl fmt::Debug for MoveOut {\n     }\n }\n \n+/// `Init` represents a point in a program that initializes some L-value;\n+#[derive(Copy, Clone)]\n+pub struct Init {\n+    /// path being initialized\n+    pub path: MovePathIndex,\n+    /// span of initialization\n+    pub span: Span,\n+    /// Extra information about this initialization\n+    pub kind: InitKind,\n+}\n+\n+/// Additional information about the initialization.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum InitKind {\n+    /// Deep init, even on panic\n+    Deep,\n+    /// Only does a shallow init\n+    Shallow,\n+    /// This doesn't initialize the variabe on panic (and a panic is possible).\n+    NonPanicPathOnly,\n+}\n+\n+impl fmt::Debug for Init {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}@{:?} ({:?})\", self.path, self.span, self.kind)\n+    }\n+}\n+\n /// Tables mapping from an l-value to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {"}, {"sha": "bc01088696da6bc8f4e43d90e9f1a20dd2dcd046", "filename": "src/test/compile-fail/borrowck/borrowck-storage-dead.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-storage-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-storage-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-storage-dead.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -16,6 +16,12 @@ fn ok() {\n     }\n }\n \n+fn also_ok() {\n+    loop {\n+        let _x = String::new();\n+    }\n+}\n+\n fn fail() {\n     loop {\n         let x: i32;\n@@ -26,5 +32,6 @@ fn fail() {\n \n fn main() {\n     ok();\n+    also_ok();\n     fail();\n }"}, {"sha": "af8f7dce60875bd9c96faaa9b2e6b6a9e56f21e4", "filename": "src/test/compile-fail/issue-45199.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Ftest%2Fcompile-fail%2Fissue-45199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d409dbf98343fe69f8bd61e81b733c91c376217a/src%2Ftest%2Fcompile-fail%2Fissue-45199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-45199.rs?ref=d409dbf98343fe69f8bd61e81b733c91c376217a", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Zborrowck=mir\n+\n+fn test_drop_replace() {\n+    let b: Box<isize>;\n+    b = Box::new(1);    //[ast]~ NOTE first assignment\n+                        //[mir]~^ NOTE first assignment\n+    b = Box::new(2);    //[ast]~ ERROR cannot assign twice to immutable variable\n+                        //[mir]~^ ERROR cannot assign twice to immutable variable `b`\n+                        //[ast]~| NOTE cannot assign twice to immutable\n+                        //[mir]~| NOTE cannot assign twice to immutable\n+}\n+\n+fn test_call() {\n+    let b = Box::new(1);    //[ast]~ NOTE first assignment\n+                            //[mir]~^ NOTE first assignment\n+    b = Box::new(2);        //[ast]~ ERROR cannot assign twice to immutable variable\n+                            //[mir]~^ ERROR cannot assign twice to immutable variable `b`\n+                            //[ast]~| NOTE cannot assign twice to immutable\n+                            //[mir]~| NOTE cannot assign twice to immutable\n+}\n+\n+fn test_args(b: Box<i32>) {  //[ast]~ NOTE first assignment\n+                                //[mir]~^ NOTE first assignment\n+    b = Box::new(2);            //[ast]~ ERROR cannot assign twice to immutable variable\n+                                //[mir]~^ ERROR cannot assign twice to immutable variable `b`\n+                                //[ast]~| NOTE cannot assign twice to immutable\n+                                //[mir]~| NOTE cannot assign twice to immutable\n+}\n+\n+fn main() {}"}]}