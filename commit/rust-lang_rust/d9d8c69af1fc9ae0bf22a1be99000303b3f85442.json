{"sha": "d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZDhjNjlhZjFmYzlhZTBiZjIyYTFiZTk5MDAwMzAzYjNmODU0NDI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-29T09:23:19Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-29T09:23:19Z"}, "message": "Split extract layout field of all CPlace variants into a sparate struct", "tree": {"sha": "f3c4747d265b630765df69f370d0a38b7cc067e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3c4747d265b630765df69f370d0a38b7cc067e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "html_url": "https://github.com/rust-lang/rust/commit/d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1018a34662e0b8d9dfa650ed0ee1dfd84242ac37", "url": "https://api.github.com/repos/rust-lang/rust/commits/1018a34662e0b8d9dfa650ed0ee1dfd84242ac37", "html_url": "https://github.com/rust-lang/rust/commit/1018a34662e0b8d9dfa650ed0ee1dfd84242ac37"}], "stats": {"total": 157, "additions": 91, "deletions": 66}, "files": [{"sha": "75b35b6fac5ab873c824c5f61cb622585c377b06", "filename": "src/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "patch": "@@ -399,8 +399,8 @@ fn local_place<'tcx>(\n                 fields: _,\n                 largest_niche: _,\n             } = details;\n-            match place {\n-                CPlace::Stack(stack_slot, _) => fx.add_entity_comment(\n+            match *place.inner() {\n+                CPlaceInner::Stack(stack_slot) => fx.add_entity_comment(\n                     stack_slot,\n                     format!(\n                         \"{:?}: {:?} size={} align={},{}\",\n@@ -411,7 +411,7 @@ fn local_place<'tcx>(\n                         align.pref.bytes(),\n                     ),\n                 ),\n-                CPlace::NoPlace(_) => fx.add_global_comment(format!(\n+                CPlaceInner::NoPlace => fx.add_global_comment(format!(\n                     \"zst    {:?}: {:?} size={} align={}, {}\",\n                     local,\n                     ty,"}, {"sha": "354513ac57b0e0807440fdae2f2ad91cbfe57e7e", "filename": "src/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "patch": "@@ -565,14 +565,15 @@ pub fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_ref(addr, dst_layout))\n         };\n         init, () {\n-            if ret.layout().abi == Abi::Uninhabited {\n+            let layout = ret.layout();\n+            if layout.abi == Abi::Uninhabited {\n                 crate::trap::trap_panic(fx, \"[panic] Called intrinsic::init for uninhabited type.\");\n                 return;\n             }\n \n-            match ret {\n-                CPlace::NoPlace(_layout) => {}\n-                CPlace::Var(var, layout) => {\n+            match *ret.inner() {\n+                CPlaceInner::NoPlace => {}\n+                CPlaceInner::Var(var) => {\n                     let clif_ty = fx.clif_type(layout.ty).unwrap();\n                     let val = match clif_ty {\n                         types::I8 | types::I16 | types::I32 | types::I64 => fx.bcx.ins().iconst(clif_ty, 0),\n@@ -596,13 +597,14 @@ pub fn codegen_intrinsic_call<'tcx>(\n             }\n         };\n         uninit, () {\n-            if ret.layout().abi == Abi::Uninhabited {\n+            let layout = ret.layout();\n+            if layout.abi == Abi::Uninhabited {\n                 crate::trap::trap_panic(fx, \"[panic] Called intrinsic::uninit for uninhabited type.\");\n                 return;\n             }\n-            match ret {\n-                CPlace::NoPlace(_layout) => {},\n-                CPlace::Var(var, layout) => {\n+            match *ret.inner() {\n+                CPlaceInner::NoPlace => {},\n+                CPlaceInner::Var(var) => {\n                     let clif_ty = fx.clif_type(layout.ty).unwrap();\n                     let val = match clif_ty {\n                         types::I8 | types::I16 | types::I32 | types::I64 => fx.bcx.ins().iconst(clif_ty, 42),\n@@ -618,7 +620,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n                     };\n                     fx.bcx.def_var(mir_var(var), val);\n                 }\n-                CPlace::Addr(_, _, _) | CPlace::Stack(_, _) => {\n+                CPlaceInner::Addr(_, _) | CPlaceInner::Stack(_) => {\n                     // Don't write to `ret`, as the destination memory is already uninitialized.\n                 }\n             }"}, {"sha": "d84a6e8199a5adc6258b1e50c162f8d276e9ccc5", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "patch": "@@ -102,7 +102,7 @@ mod prelude {\n     pub use crate::debuginfo::{DebugContext, FunctionDebugContext};\n     pub use crate::trap::*;\n     pub use crate::unimpl::{unimpl, with_unimpl_span};\n-    pub use crate::value_and_place::{CValue, CPlace};\n+    pub use crate::value_and_place::{CValue, CPlace, CPlaceInner};\n     pub use crate::{Caches, CodegenCx};\n \n     pub struct PrintOnPanic<F: Fn() -> String>(pub F);"}, {"sha": "b300db2ecfcd42b5c62fad0f9afc44cd8210925c", "filename": "src/value_and_place.rs", "status": "modified", "additions": 76, "deletions": 53, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d8c69af1fc9ae0bf22a1be99000303b3f85442/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=d9d8c69af1fc9ae0bf22a1be99000303b3f85442", "patch": "@@ -163,25 +163,33 @@ impl<'tcx> CValue<'tcx> {\n \n /// A place where you can write a value to or read a value from\n #[derive(Debug, Copy, Clone)]\n-pub enum CPlace<'tcx> {\n-    Var(Local, TyLayout<'tcx>),\n-    Addr(Value, Option<Value>, TyLayout<'tcx>),\n-    Stack(StackSlot, TyLayout<'tcx>),\n-    NoPlace(TyLayout<'tcx>),\n+pub struct CPlace<'tcx> {\n+    inner: CPlaceInner,\n+    layout: TyLayout<'tcx>,\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum CPlaceInner {\n+    Var(Local),\n+    Addr(Value, Option<Value>),\n+    Stack(StackSlot),\n+    NoPlace,\n }\n \n impl<'tcx> CPlace<'tcx> {\n     pub fn layout(&self) -> TyLayout<'tcx> {\n-        match *self {\n-            CPlace::Var(_, layout)\n-            | CPlace::Addr(_, _, layout)\n-            | CPlace::Stack(_, layout)\n-            | CPlace::NoPlace(layout) => layout,\n-        }\n+        self.layout\n+    }\n+\n+    pub fn inner(&self) -> &CPlaceInner {\n+        &self.inner\n     }\n \n     pub fn no_place(layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace::NoPlace(layout)\n+        CPlace{\n+            inner: CPlaceInner::NoPlace,\n+            layout\n+        }\n     }\n \n     pub fn new_stack_slot(\n@@ -191,15 +199,21 @@ impl<'tcx> CPlace<'tcx> {\n         let layout = fx.layout_of(ty);\n         assert!(!layout.is_unsized());\n         if layout.size.bytes() == 0 {\n-            return CPlace::NoPlace(layout);\n+            return CPlace {\n+                inner: CPlaceInner::NoPlace,\n+                layout,\n+            };\n         }\n \n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             size: layout.size.bytes() as u32,\n             offset: None,\n         });\n-        CPlace::Stack(stack_slot, layout)\n+        CPlace {\n+            inner: CPlaceInner::Stack(stack_slot),\n+            layout,\n+        }\n     }\n \n     pub fn new_var(\n@@ -209,29 +223,39 @@ impl<'tcx> CPlace<'tcx> {\n     ) -> CPlace<'tcx> {\n         fx.bcx\n             .declare_var(mir_var(local), fx.clif_type(layout.ty).unwrap());\n-        CPlace::Var(local, layout)\n+        CPlace {\n+            inner: CPlaceInner::Var(local),\n+            layout,\n+        }\n     }\n \n     pub fn for_addr(addr: Value, layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace::Addr(addr, None, layout)\n+        CPlace {\n+            inner: CPlaceInner::Addr(addr, None),\n+            layout,\n+        }\n     }\n \n     pub fn for_addr_with_extra(addr: Value, extra: Value, layout: TyLayout<'tcx>) -> CPlace<'tcx> {\n-        CPlace::Addr(addr, Some(extra), layout)\n+        CPlace {\n+            inner: CPlaceInner::Addr(addr, Some(extra)),\n+            layout,\n+        }\n     }\n \n     pub fn to_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> CValue<'tcx> {\n-        match self {\n-            CPlace::Var(var, layout) => CValue::by_val(fx.bcx.use_var(mir_var(var)), layout),\n-            CPlace::Addr(addr, extra, layout) => {\n+        let layout = self.layout();\n+        match self.inner {\n+            CPlaceInner::Var(var) => CValue::by_val(fx.bcx.use_var(mir_var(var)), layout),\n+            CPlaceInner::Addr(addr, extra) => {\n                 assert!(extra.is_none(), \"unsized values are not yet supported\");\n                 CValue::by_ref(addr, layout)\n             }\n-            CPlace::Stack(stack_slot, layout) => CValue::by_ref(\n+            CPlaceInner::Stack(stack_slot) => CValue::by_ref(\n                 fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n                 layout,\n             ),\n-            CPlace::NoPlace(layout) => CValue::by_ref(\n+            CPlaceInner::NoPlace => CValue::by_ref(\n                 fx.bcx\n                     .ins()\n                     .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n@@ -251,14 +275,14 @@ impl<'tcx> CPlace<'tcx> {\n         self,\n         fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n     ) -> (Value, Option<Value>) {\n-        match self {\n-            CPlace::Addr(addr, extra, _layout) => (addr, extra),\n-            CPlace::Stack(stack_slot, _layout) => (\n+        match self.inner {\n+            CPlaceInner::Addr(addr, extra) => (addr, extra),\n+            CPlaceInner::Stack(stack_slot) => (\n                 fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n                 None,\n             ),\n-            CPlace::NoPlace(_) => (fx.bcx.ins().iconst(fx.pointer_type, 45), None),\n-            CPlace::Var(_, _) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+            CPlaceInner::NoPlace => (fx.bcx.ins().iconst(fx.pointer_type, 45), None),\n+            CPlaceInner::Var(_) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n         }\n     }\n \n@@ -327,24 +351,24 @@ impl<'tcx> CPlace<'tcx> {\n \n         assert_assignable(fx, from_ty, to_ty);\n \n-        let (addr, dst_layout) = match self {\n-            CPlace::Var(var, _) => {\n+        let dst_layout = self.layout();\n+        let addr = match self.inner {\n+            CPlaceInner::Var(var) => {\n                 let data = from.load_scalar(fx);\n                 fx.bcx.def_var(mir_var(var), data);\n                 return;\n             }\n-            CPlace::Addr(addr, None, dst_layout) => (addr, dst_layout),\n-            CPlace::Stack(stack_slot, dst_layout) => (\n-                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n-                dst_layout,\n-            ),\n-            CPlace::NoPlace(layout) => {\n-                if layout.abi != Abi::Uninhabited {\n-                    assert_eq!(layout.size.bytes(), 0, \"{:?}\", layout);\n+            CPlaceInner::Addr(addr, None) => addr,\n+            CPlaceInner::Stack(stack_slot) => {\n+                fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0)\n+            }\n+            CPlaceInner::NoPlace => {\n+                if dst_layout.abi != Abi::Uninhabited {\n+                    assert_eq!(dst_layout.size.bytes(), 0, \"{:?}\", dst_layout);\n                 }\n                 return;\n             }\n-            CPlace::Addr(_, _, _) => bug!(\"Can't write value to unsized place {:?}\", self),\n+            CPlaceInner::Addr(_, Some(_)) => bug!(\"Can't write value to unsized place {:?}\", self),\n         };\n \n         match from.0 {\n@@ -395,13 +419,11 @@ impl<'tcx> CPlace<'tcx> {\n         let (base, extra) = self.to_addr_maybe_unsized(fx);\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n-        let extra = if field_layout.is_unsized() {\n-            assert!(extra.is_some());\n-            extra\n+        if field_layout.is_unsized() {\n+            CPlace::for_addr_with_extra(field_ptr, extra.unwrap(), field_layout)\n         } else {\n-            None\n-        };\n-        CPlace::Addr(field_ptr, extra, field_layout)\n+            CPlace::for_addr(field_ptr, field_layout)\n+        }\n     }\n \n     pub fn place_index(\n@@ -420,16 +442,16 @@ impl<'tcx> CPlace<'tcx> {\n             .ins()\n             .imul_imm(index, elem_layout.size.bytes() as i64);\n \n-        CPlace::Addr(fx.bcx.ins().iadd(addr, offset), None, elem_layout)\n+        CPlace::for_addr(fx.bcx.ins().iadd(addr, offset), elem_layout)\n     }\n \n     pub fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n         if !inner_layout.is_unsized() {\n-            CPlace::Addr(self.to_cvalue(fx).load_scalar(fx), None, inner_layout)\n+            CPlace::for_addr(self.to_cvalue(fx).load_scalar(fx), inner_layout)\n         } else {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n-            CPlace::Addr(addr, Some(extra), inner_layout)\n+            CPlace::for_addr_with_extra(addr, extra, inner_layout)\n         }\n     }\n \n@@ -446,14 +468,15 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n         assert!(!self.layout().is_unsized());\n-        match self {\n-            CPlace::Var(var, _) => CPlace::Var(var, layout),\n-            CPlace::Addr(addr, extra, _) => CPlace::Addr(addr, extra, layout),\n-            CPlace::Stack(stack_slot, _) => CPlace::Stack(stack_slot, layout),\n-            CPlace::NoPlace(_) => {\n+        match self.inner {\n+            CPlaceInner::NoPlace => {\n                 assert!(layout.size.bytes() == 0);\n-                CPlace::NoPlace(layout)\n             }\n+            _ => {}\n+        }\n+        CPlace {\n+            inner: self.inner,\n+            layout,\n         }\n     }\n "}]}