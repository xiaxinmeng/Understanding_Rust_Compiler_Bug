{"sha": "cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiOGRmN2E4ZTNjNTNmMTZkMjJmNzZkYTUwZTZlMmU0NzM0YmRmNjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-15T05:48:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-08-25T00:08:14Z"}, "message": "rustuv: Implement clone/close_accept\n\nThis commits implements {Tcp,Unix}Acceptor::{clone,close_accept} methods for\nall of librustuv.\n\nThis implementation rewrites much of Access, AccessTimeout, and AcceptTimeout to\nhave type parameter for shared state that all acceptors share (a shared queue of\nsockets). The incoming/outgoing channels have been removed as all timeouts and\nsuch are now managed on the event loop rather than concurrently.", "tree": {"sha": "9bf7319e45929e1d264f5e3ea9c2a2bf514e3451", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bf7319e45929e1d264f5e3ea9c2a2bf514e3451"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "html_url": "https://github.com/rust-lang/rust/commit/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "110168de2a7b529a7c4839ca1e19c4c42f68be12", "url": "https://api.github.com/repos/rust-lang/rust/commits/110168de2a7b529a7c4839ca1e19c4c42f68be12", "html_url": "https://github.com/rust-lang/rust/commit/110168de2a7b529a7c4839ca1e19c4c42f68be12"}], "stats": {"total": 463, "additions": 290, "deletions": 173}, "files": [{"sha": "290293cf086c17968b3a82396d20705c5f80db15", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "patch": "@@ -22,38 +22,40 @@ use std::cell::UnsafeCell;\n \n use homing::HomingMissile;\n \n-pub struct Access {\n-    inner: Arc<UnsafeCell<Inner>>,\n+pub struct Access<T> {\n+    inner: Arc<UnsafeCell<Inner<T>>>,\n }\n \n-pub struct Guard<'a> {\n-    access: &'a mut Access,\n+pub struct Guard<'a, T> {\n+    access: &'a mut Access<T>,\n     missile: Option<HomingMissile>,\n }\n \n-struct Inner {\n+struct Inner<T> {\n     queue: Vec<(BlockedTask, uint)>,\n     held: bool,\n     closed: bool,\n+    data: T,\n }\n \n-impl Access {\n-    pub fn new() -> Access {\n+impl<T: Send> Access<T> {\n+    pub fn new(data: T) -> Access<T> {\n         Access {\n             inner: Arc::new(UnsafeCell::new(Inner {\n                 queue: vec![],\n                 held: false,\n                 closed: false,\n+                data: data,\n             }))\n         }\n     }\n \n     pub fn grant<'a>(&'a mut self, token: uint,\n-                     missile: HomingMissile) -> Guard<'a> {\n+                     missile: HomingMissile) -> Guard<'a, T> {\n         // This unsafety is actually OK because the homing missile argument\n         // guarantees that we're on the same event loop as all the other objects\n         // attempting to get access granted.\n-        let inner: &mut Inner = unsafe { &mut *self.inner.get() };\n+        let inner = unsafe { &mut *self.inner.get() };\n \n         if inner.held {\n             let t: Box<Task> = Local::take();\n@@ -69,6 +71,15 @@ impl Access {\n         Guard { access: self, missile: Some(missile) }\n     }\n \n+    pub fn unsafe_get(&self) -> *mut T {\n+        unsafe { &mut (*self.inner.get()).data  as *mut _ }\n+    }\n+\n+    // Safe version which requires proof that you are on the home scheduler.\n+    pub fn get_mut<'a>(&'a mut self, _missile: &HomingMissile) -> &'a mut T {\n+        unsafe { &mut *self.unsafe_get() }\n+    }\n+\n     pub fn close(&self, _missile: &HomingMissile) {\n         // This unsafety is OK because with a homing missile we're guaranteed to\n         // be the only task looking at the `closed` flag (and are therefore\n@@ -82,35 +93,55 @@ impl Access {\n     // is only safe to invoke while on the home event loop, and there is no\n     // guarantee that this i being invoked on the home event loop.\n     pub unsafe fn dequeue(&mut self, token: uint) -> Option<BlockedTask> {\n-        let inner: &mut Inner = &mut *self.inner.get();\n+        let inner = &mut *self.inner.get();\n         match inner.queue.iter().position(|&(_, t)| t == token) {\n             Some(i) => Some(inner.queue.remove(i).unwrap().val0()),\n             None => None,\n         }\n     }\n+\n+    /// Test whether this access is closed, using a homing missile to prove\n+    /// that it's safe\n+    pub fn is_closed(&self, _missile: &HomingMissile) -> bool {\n+        unsafe { (*self.inner.get()).closed }\n+    }\n }\n \n-impl Clone for Access {\n-    fn clone(&self) -> Access {\n+impl<T: Send> Clone for Access<T> {\n+    fn clone(&self) -> Access<T> {\n         Access { inner: self.inner.clone() }\n     }\n }\n \n-impl<'a> Guard<'a> {\n+impl<'a, T: Send> Guard<'a, T> {\n     pub fn is_closed(&self) -> bool {\n         // See above for why this unsafety is ok, it just applies to the read\n         // instead of the write.\n         unsafe { (*self.access.inner.get()).closed }\n     }\n }\n \n+impl<'a, T: Send> Deref<T> for Guard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        // A guard represents exclusive access to a piece of data, so it's safe\n+        // to hand out shared and mutable references\n+        unsafe { &(*self.access.inner.get()).data }\n+    }\n+}\n+\n+impl<'a, T: Send> DerefMut<T> for Guard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut (*self.access.inner.get()).data }\n+    }\n+}\n+\n #[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n+impl<'a, T> Drop for Guard<'a, T> {\n     fn drop(&mut self) {\n         // This guard's homing missile is still armed, so we're guaranteed to be\n         // on the same I/O event loop, so this unsafety should be ok.\n         assert!(self.missile.is_some());\n-        let inner: &mut Inner = unsafe {\n+        let inner: &mut Inner<T> = unsafe {\n             mem::transmute(self.access.inner.get())\n         };\n \n@@ -133,7 +164,8 @@ impl<'a> Drop for Guard<'a> {\n     }\n }\n \n-impl Drop for Inner {\n+#[unsafe_destructor]\n+impl<T> Drop for Inner<T> {\n     fn drop(&mut self) {\n         assert!(!self.held);\n         assert_eq!(self.queue.len(), 0);"}, {"sha": "b13598402470575f84cde7e8d90a1fd8d1eda283", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 67, "deletions": 34, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "patch": "@@ -22,7 +22,7 @@ use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n             wait_until_woken_after, wakeup};\n-use timeout::{AccessTimeout, AcceptTimeout, ConnectCtx};\n+use timeout::{AccessTimeout, ConnectCtx, AcceptTimeout};\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -158,20 +158,20 @@ pub struct TcpWatcher {\n     // stream object, so we use these access guards in order to arbitrate among\n     // multiple concurrent reads and writes. Note that libuv *can* read and\n     // write simultaneously, it just can't read and read simultaneously.\n-    read_access: AccessTimeout,\n-    write_access: AccessTimeout,\n+    read_access: AccessTimeout<()>,\n+    write_access: AccessTimeout<()>,\n }\n \n pub struct TcpListener {\n     home: HomeHandle,\n-    handle: *mut uvll::uv_pipe_t,\n-    outgoing: Sender<Result<Box<rtio::RtioTcpStream + Send>, IoError>>,\n-    incoming: Receiver<Result<Box<rtio::RtioTcpStream + Send>, IoError>>,\n+    handle: *mut uvll::uv_tcp_t,\n }\n \n pub struct TcpAcceptor {\n-    listener: Box<TcpListener>,\n-    timeout: AcceptTimeout,\n+    home: HomeHandle,\n+    handle: *mut uvll::uv_tcp_t,\n+    access: AcceptTimeout<Box<rtio::RtioTcpStream + Send>>,\n+    refcount: Refcount,\n }\n \n // TCP watchers (clients/streams)\n@@ -192,8 +192,8 @@ impl TcpWatcher {\n             handle: handle,\n             stream: StreamWatcher::new(handle, true),\n             refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(),\n-            write_access: AccessTimeout::new(),\n+            read_access: AccessTimeout::new(()),\n+            write_access: AccessTimeout::new(()),\n         }\n     }\n \n@@ -291,7 +291,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         let task = {\n             let m = self.fire_homing_missile();\n             self.read_access.access.close(&m);\n-    self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n+            self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n         };\n         let _ = task.map(|t| t.reawaken());\n         Ok(())\n@@ -354,12 +354,9 @@ impl TcpListener {\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(io.uv_loop(), handle)\n         }, 0);\n-        let (tx, rx) = channel();\n         let l = box TcpListener {\n             home: io.make_handle(),\n             handle: handle,\n-            outgoing: tx,\n-            incoming: rx,\n         };\n         let mut storage = unsafe { mem::zeroed() };\n         let _len = addr_to_sockaddr(address, &mut storage);\n@@ -392,15 +389,19 @@ impl rtio::RtioSocket for TcpListener {\n impl rtio::RtioTcpListener for TcpListener {\n     fn listen(self: Box<TcpListener>)\n               -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n+        let _m = self.fire_homing_missile();\n+\n         // create the acceptor object from ourselves\n-        let mut acceptor = box TcpAcceptor {\n-            listener: self,\n-            timeout: AcceptTimeout::new(),\n-        };\n+        let acceptor = (box TcpAcceptor {\n+            handle: self.handle,\n+            home: self.home.clone(),\n+            access: AcceptTimeout::new(),\n+            refcount: Refcount::new(),\n+        }).install();\n+        self.handle = 0 as *mut _;\n \n-        let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n-        match unsafe { uvll::uv_listen(acceptor.listener.handle, 128, listen_cb) } {\n+        match unsafe { uvll::uv_listen(acceptor.handle, 128, listen_cb) } {\n             0 => Ok(acceptor as Box<rtio::RtioTcpAcceptor + Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n@@ -409,7 +410,7 @@ impl rtio::RtioTcpListener for TcpListener {\n \n extern fn listen_cb(server: *mut uvll::uv_stream_t, status: c_int) {\n     assert!(status != uvll::ECANCELED);\n-    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n+    let tcp: &mut TcpAcceptor = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n@@ -421,11 +422,15 @@ extern fn listen_cb(server: *mut uvll::uv_stream_t, status: c_int) {\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-    tcp.outgoing.send(msg);\n+\n+    // If we're running then we have exclusive access, so the unsafe_get() is ok\n+    unsafe { tcp.access.push(msg); }\n }\n \n impl Drop for TcpListener {\n     fn drop(&mut self) {\n+        if self.handle.is_null() { return }\n+\n         let _m = self.fire_homing_missile();\n         self.close();\n     }\n@@ -434,40 +439,68 @@ impl Drop for TcpListener {\n // TCP acceptors (bound servers)\n \n impl HomingIO for TcpAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { self.listener.home() }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n     fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.listener.handle)\n+        socket_name(Tcp, self.handle)\n     }\n }\n \n+impl UvHandle<uvll::uv_tcp_t> for TcpAcceptor {\n+    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.handle }\n+}\n+\n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> Result<Box<rtio::RtioTcpStream + Send>, IoError> {\n-        self.timeout.accept(&self.listener.incoming)\n+        let m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.access.accept(m, &loop_)\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 1)\n+            uvll::uv_tcp_simultaneous_accepts(self.handle, 1)\n         })\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 0)\n+            uvll::uv_tcp_simultaneous_accepts(self.handle, 0)\n         })\n     }\n \n     fn set_timeout(&mut self, ms: Option<u64>) {\n         let _m = self.fire_homing_missile();\n-        match ms {\n-            None => self.timeout.clear(),\n-            Some(ms) => self.timeout.set_timeout(ms, &mut *self.listener),\n+        let loop_ = self.uv_loop();\n+        self.access.set_timeout(ms, &loop_, &self.home);\n+    }\n+\n+    fn clone(&self) -> Box<rtio::RtioTcpAcceptor + Send> {\n+        box TcpAcceptor {\n+            refcount: self.refcount.clone(),\n+            home: self.home.clone(),\n+            handle: self.handle,\n+            access: self.access.clone(),\n+        } as Box<rtio::RtioTcpAcceptor + Send>\n+    }\n+\n+    fn close_accept(&mut self) -> Result<(), IoError> {\n+        let m = self.fire_homing_missile();\n+        self.access.close(m);\n+        Ok(())\n+    }\n+}\n+\n+impl Drop for TcpAcceptor {\n+    fn drop(&mut self) {\n+        let _m = self.fire_homing_missile();\n+        if self.refcount.decrement() {\n+            self.close();\n         }\n     }\n }\n@@ -482,8 +515,8 @@ pub struct UdpWatcher {\n \n     // See above for what these fields are\n     refcount: Refcount,\n-    read_access: AccessTimeout,\n-    write_access: AccessTimeout,\n+    read_access: AccessTimeout<()>,\n+    write_access: AccessTimeout<()>,\n \n     blocked_sender: Option<BlockedTask>,\n }\n@@ -507,8 +540,8 @@ impl UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n             home: io.make_handle(),\n             refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(),\n-            write_access: AccessTimeout::new(),\n+            read_access: AccessTimeout::new(()),\n+            write_access: AccessTimeout::new(()),\n             blocked_sender: None,\n         };\n         assert_eq!(unsafe {"}, {"sha": "aa89e5e5f034e24cdafaa8758760a03241e7796b", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 60, "deletions": 26, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "patch": "@@ -31,20 +31,20 @@ pub struct PipeWatcher {\n     refcount: Refcount,\n \n     // see comments in TcpWatcher for why these exist\n-    write_access: AccessTimeout,\n-    read_access: AccessTimeout,\n+    write_access: AccessTimeout<()>,\n+    read_access: AccessTimeout<()>,\n }\n \n pub struct PipeListener {\n     home: HomeHandle,\n     pipe: *mut uvll::uv_pipe_t,\n-    outgoing: Sender<IoResult<Box<rtio::RtioPipe + Send>>>,\n-    incoming: Receiver<IoResult<Box<rtio::RtioPipe + Send>>>,\n }\n \n pub struct PipeAcceptor {\n-    listener: Box<PipeListener>,\n-    timeout: AcceptTimeout,\n+    home: HomeHandle,\n+    handle: *mut uvll::uv_pipe_t,\n+    access: AcceptTimeout<Box<rtio::RtioPipe + Send>>,\n+    refcount: Refcount,\n }\n \n // PipeWatcher implementation and traits\n@@ -71,8 +71,8 @@ impl PipeWatcher {\n             home: home,\n             defused: false,\n             refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(),\n-            write_access: AccessTimeout::new(),\n+            read_access: AccessTimeout::new(()),\n+            write_access: AccessTimeout::new(()),\n         }\n     }\n \n@@ -233,12 +233,9 @@ impl PipeListener {\n                 // If successful, unwrap the PipeWatcher because we control how\n                 // we close the pipe differently. We can't rely on\n                 // StreamWatcher's default close method.\n-                let (tx, rx) = channel();\n                 let p = box PipeListener {\n                     home: io.make_handle(),\n                     pipe: pipe.unwrap(),\n-                    incoming: rx,\n-                    outgoing: tx,\n                 };\n                 Ok(p.install())\n             }\n@@ -250,15 +247,19 @@ impl PipeListener {\n impl rtio::RtioUnixListener for PipeListener {\n     fn listen(self: Box<PipeListener>)\n               -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+        let _m = self.fire_homing_missile();\n+\n         // create the acceptor object from ourselves\n-        let mut acceptor = box PipeAcceptor {\n-            listener: self,\n-            timeout: AcceptTimeout::new(),\n-        };\n+        let acceptor = (box PipeAcceptor {\n+            handle: self.pipe,\n+            home: self.home.clone(),\n+            access: AcceptTimeout::new(),\n+            refcount: Refcount::new(),\n+        }).install();\n+        self.pipe = 0 as *mut _;\n \n-        let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n-        match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n+        match unsafe { uvll::uv_listen(acceptor.handle, 128, listen_cb) } {\n             0 => Ok(acceptor as Box<rtio::RtioUnixAcceptor + Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n@@ -276,7 +277,7 @@ impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n extern fn listen_cb(server: *mut uvll::uv_stream_t, status: libc::c_int) {\n     assert!(status != uvll::ECANCELED);\n \n-    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };\n+    let pipe: &mut PipeAcceptor = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n@@ -288,11 +289,15 @@ extern fn listen_cb(server: *mut uvll::uv_stream_t, status: libc::c_int) {\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-    pipe.outgoing.send(msg);\n+\n+    // If we're running then we have exclusive access, so the unsafe_get() is ok\n+    unsafe { pipe.access.push(msg); }\n }\n \n impl Drop for PipeListener {\n     fn drop(&mut self) {\n+        if self.pipe.is_null() { return }\n+\n         let _m = self.fire_homing_missile();\n         self.close();\n     }\n@@ -302,19 +307,48 @@ impl Drop for PipeListener {\n \n impl rtio::RtioUnixAcceptor for PipeAcceptor {\n     fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        self.timeout.accept(&self.listener.incoming)\n+        let m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.access.accept(m, &loop_)\n     }\n \n-    fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        match timeout_ms {\n-            None => self.timeout.clear(),\n-            Some(ms) => self.timeout.set_timeout(ms, &mut *self.listener),\n-        }\n+    fn set_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.access.set_timeout(ms, &loop_, &self.home);\n+    }\n+\n+    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n+        box PipeAcceptor {\n+            refcount: self.refcount.clone(),\n+            home: self.home.clone(),\n+            handle: self.handle,\n+            access: self.access.clone(),\n+        } as Box<rtio::RtioUnixAcceptor + Send>\n+    }\n+\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        let m = self.fire_homing_missile();\n+        self.access.close(m);\n+        Ok(())\n     }\n }\n \n impl HomingIO for PipeAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.listener.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n+}\n+\n+impl UvHandle<uvll::uv_pipe_t> for PipeAcceptor {\n+    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.handle }\n+}\n+\n+impl Drop for PipeAcceptor {\n+    fn drop(&mut self) {\n+        let _m = self.fire_homing_missile();\n+        if self.refcount.decrement() {\n+            self.close();\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "32d7395241675ca02a03eae5a0f3ba34e5f3bf04", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 115, "deletions": 97, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=cb8df7a8e3c53f16d22f76da50e6e2e4734bdf62", "patch": "@@ -14,23 +14,23 @@ use std::rt::task::BlockedTask;\n use std::rt::rtio::IoResult;\n \n use access;\n-use homing::{HomeHandle, HomingMissile, HomingIO};\n+use homing::{HomeHandle, HomingMissile};\n use timer::TimerWatcher;\n use uvll;\n use uvio::UvIoFactory;\n use {Loop, UvError, uv_error_to_io_error, Request, wakeup};\n use {UvHandle, wait_until_woken_after};\n \n /// Management of a timeout when gaining access to a portion of a duplex stream.\n-pub struct AccessTimeout {\n+pub struct AccessTimeout<T> {\n     state: TimeoutState,\n     timer: Option<Box<TimerWatcher>>,\n-    pub access: access::Access,\n+    pub access: access::Access<T>,\n }\n \n-pub struct Guard<'a> {\n+pub struct Guard<'a, T> {\n     state: &'a mut TimeoutState,\n-    pub access: access::Guard<'a>,\n+    pub access: access::Guard<'a, T>,\n     pub can_timeout: bool,\n }\n \n@@ -49,17 +49,18 @@ enum ClientState {\n }\n \n struct TimerContext {\n-    timeout: *mut AccessTimeout,\n-    callback: fn(uint) -> Option<BlockedTask>,\n-    payload: uint,\n+    timeout: *mut AccessTimeout<()>,\n+    callback: fn(*mut AccessTimeout<()>, &TimerContext),\n+    user_unblock: fn(uint) -> Option<BlockedTask>,\n+    user_payload: uint,\n }\n \n-impl AccessTimeout {\n-    pub fn new() -> AccessTimeout {\n+impl<T: Send> AccessTimeout<T> {\n+    pub fn new(data: T) -> AccessTimeout<T> {\n         AccessTimeout {\n             state: NoTimeout,\n             timer: None,\n-            access: access::Access::new(),\n+            access: access::Access::new(data),\n         }\n     }\n \n@@ -68,7 +69,7 @@ impl AccessTimeout {\n     /// On success, Ok(Guard) is returned and access has been granted to the\n     /// stream. If a timeout occurs, then Err is returned with an appropriate\n     /// error.\n-    pub fn grant<'a>(&'a mut self, m: HomingMissile) -> IoResult<Guard<'a>> {\n+    pub fn grant<'a>(&'a mut self, m: HomingMissile) -> IoResult<Guard<'a, T>> {\n         // First, flag that we're attempting to acquire access. This will allow\n         // us to cancel the pending grant if we timeout out while waiting for a\n         // grant.\n@@ -94,6 +95,13 @@ impl AccessTimeout {\n         })\n     }\n \n+    pub fn timed_out(&self) -> bool {\n+        match self.state {\n+            TimedOut => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Sets the pending timeout to the value specified.\n     ///\n     /// The home/loop variables are used to construct a timer if one has not\n@@ -120,9 +128,10 @@ impl AccessTimeout {\n         if self.timer.is_none() {\n             let mut timer = box TimerWatcher::new_home(loop_, home.clone());\n             let mut cx = box TimerContext {\n-                timeout: self as *mut _,\n-                callback: cb,\n-                payload: data,\n+                timeout: self as *mut _ as *mut AccessTimeout<()>,\n+                callback: real_cb::<T>,\n+                user_unblock: cb,\n+                user_payload: data,\n             };\n             unsafe {\n                 timer.set_data(&mut *cx);\n@@ -135,8 +144,8 @@ impl AccessTimeout {\n         unsafe {\n             let cx = uvll::get_data_for_uv_handle(timer.handle);\n             let cx = cx as *mut TimerContext;\n-            (*cx).callback = cb;\n-            (*cx).payload = data;\n+            (*cx).user_unblock = cb;\n+            (*cx).user_payload = data;\n         }\n         timer.stop();\n         timer.start(timer_cb, ms, 0);\n@@ -146,7 +155,12 @@ impl AccessTimeout {\n             let cx: &TimerContext = unsafe {\n                 &*(uvll::get_data_for_uv_handle(timer) as *const TimerContext)\n             };\n-            let me = unsafe { &mut *cx.timeout };\n+            (cx.callback)(cx.timeout, cx);\n+        }\n+\n+        fn real_cb<T: Send>(timeout: *mut AccessTimeout<()>, cx: &TimerContext) {\n+            let timeout = timeout as *mut AccessTimeout<T>;\n+            let me = unsafe { &mut *timeout };\n \n             match mem::replace(&mut me.state, TimedOut) {\n                 TimedOut | NoTimeout => unreachable!(),\n@@ -158,7 +172,7 @@ impl AccessTimeout {\n                     }\n                 }\n                 TimeoutPending(RequestPending) => {\n-                    match (cx.callback)(cx.payload) {\n+                    match (cx.user_unblock)(cx.user_payload) {\n                         Some(task) => task.reawaken(),\n                         None => unreachable!(),\n                     }\n@@ -168,8 +182,8 @@ impl AccessTimeout {\n     }\n }\n \n-impl Clone for AccessTimeout {\n-    fn clone(&self) -> AccessTimeout {\n+impl<T: Send> Clone for AccessTimeout<T> {\n+    fn clone(&self) -> AccessTimeout<T> {\n         AccessTimeout {\n             access: self.access.clone(),\n             state: NoTimeout,\n@@ -179,7 +193,7 @@ impl Clone for AccessTimeout {\n }\n \n #[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n+impl<'a, T> Drop for Guard<'a, T> {\n     fn drop(&mut self) {\n         match *self.state {\n             TimeoutPending(NoWaiter) | TimeoutPending(AccessPending) =>\n@@ -193,7 +207,8 @@ impl<'a> Drop for Guard<'a> {\n     }\n }\n \n-impl Drop for AccessTimeout {\n+#[unsafe_destructor]\n+impl<T> Drop for AccessTimeout<T> {\n     fn drop(&mut self) {\n         match self.timer {\n             Some(ref timer) => unsafe {\n@@ -215,12 +230,6 @@ pub struct ConnectCtx {\n     pub timer: Option<Box<TimerWatcher>>,\n }\n \n-pub struct AcceptTimeout {\n-    timer: Option<TimerWatcher>,\n-    timeout_tx: Option<Sender<()>>,\n-    timeout_rx: Option<Receiver<()>>,\n-}\n-\n impl ConnectCtx {\n     pub fn connect<T>(\n         mut self, obj: T, timeout: Option<u64>, io: &mut UvIoFactory,\n@@ -306,88 +315,97 @@ impl ConnectCtx {\n     }\n }\n \n-impl AcceptTimeout {\n-    pub fn new() -> AcceptTimeout {\n-        AcceptTimeout { timer: None, timeout_tx: None, timeout_rx: None }\n-    }\n+pub struct AcceptTimeout<T> {\n+    access: AccessTimeout<AcceptorState<T>>,\n+}\n \n-    pub fn accept<T: Send>(&mut self, c: &Receiver<IoResult<T>>) -> IoResult<T> {\n-        match self.timeout_rx {\n-            None => c.recv(),\n-            Some(ref rx) => {\n-                use std::comm::Select;\n-\n-                // Poll the incoming channel first (don't rely on the order of\n-                // select just yet). If someone's pending then we should return\n-                // them immediately.\n-                match c.try_recv() {\n-                    Ok(data) => return data,\n-                    Err(..) => {}\n-                }\n+struct AcceptorState<T> {\n+    blocked_acceptor: Option<BlockedTask>,\n+    pending: Vec<IoResult<T>>,\n+}\n \n-                // Use select to figure out which channel gets ready first. We\n-                // do some custom handling of select to ensure that we never\n-                // actually drain the timeout channel (we'll keep seeing the\n-                // timeout message in the future).\n-                let s = Select::new();\n-                let mut timeout = s.handle(rx);\n-                let mut data = s.handle(c);\n-                unsafe {\n-                    timeout.add();\n-                    data.add();\n-                }\n-                if s.wait() == timeout.id() {\n-                    Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-                } else {\n-                    c.recv()\n-                }\n-            }\n+impl<T: Send> AcceptTimeout<T> {\n+    pub fn new() -> AcceptTimeout<T> {\n+        AcceptTimeout {\n+            access: AccessTimeout::new(AcceptorState {\n+                blocked_acceptor: None,\n+                pending: Vec::new(),\n+            })\n         }\n     }\n \n-    pub fn clear(&mut self) {\n-        match self.timeout_rx {\n-            Some(ref t) => { let _ = t.try_recv(); }\n-            None => {}\n+    pub fn accept(&mut self,\n+                  missile: HomingMissile,\n+                  loop_: &Loop) -> IoResult<T> {\n+        // If we've timed out but we're not closed yet, poll the state of the\n+        // queue to see if we can peel off a connection.\n+        if self.access.timed_out() && !self.access.access.is_closed(&missile) {\n+            let tmp = self.access.access.get_mut(&missile);\n+            return match tmp.pending.remove(0) {\n+                Some(msg) => msg,\n+                None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+            }\n         }\n-        match self.timer {\n-            Some(ref mut t) => t.stop(),\n+\n+        // Now that we're not polling, attempt to gain access and then peel off\n+        // a connection. If we have no pending connections, then we need to go\n+        // to sleep and wait for one.\n+        //\n+        // Note that if we're woken up for a pending connection then we're\n+        // guaranteed that the check above will not steal our connection due to\n+        // the single-threaded nature of the event loop.\n+        let mut guard = try!(self.access.grant(missile));\n+        if guard.access.is_closed() {\n+            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n+        }\n+\n+        match guard.access.pending.remove(0) {\n+            Some(msg) => return msg,\n             None => {}\n         }\n+\n+        wait_until_woken_after(&mut guard.access.blocked_acceptor, loop_, || {});\n+\n+        match guard.access.pending.remove(0) {\n+            _ if guard.access.is_closed() => {\n+                Err(uv_error_to_io_error(UvError(uvll::EOF)))\n+            }\n+            Some(msg) => msg,\n+            None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+        }\n     }\n \n-    pub fn set_timeout<U, T: UvHandle<U> + HomingIO>(\n-        &mut self, ms: u64, t: &mut T\n-    ) {\n-        // If we have a timeout, lazily initialize the timer which will be used\n-        // to fire when the timeout runs out.\n-        if self.timer.is_none() {\n-            let loop_ = Loop::wrap(unsafe {\n-                uvll::get_loop_for_uv_handle(t.uv_handle())\n-            });\n-            let mut timer = TimerWatcher::new_home(&loop_, t.home().clone());\n+    pub unsafe fn push(&mut self, t: IoResult<T>) {\n+        let state = self.access.access.unsafe_get();\n+        (*state).pending.push(t);\n+        let _ = (*state).blocked_acceptor.take().map(|t| t.reawaken());\n+    }\n+\n+    pub fn set_timeout(&mut self,\n+                       ms: Option<u64>,\n+                       loop_: &Loop,\n+                       home: &HomeHandle) {\n+        self.access.set_timeout(ms, home, loop_, cancel_accept::<T>,\n+                                self as *mut _ as uint);\n+\n+        fn cancel_accept<T: Send>(me: uint) -> Option<BlockedTask> {\n             unsafe {\n-                timer.set_data(self as *mut _);\n+                let me: &mut AcceptTimeout<T> = mem::transmute(me);\n+                (*me.access.access.unsafe_get()).blocked_acceptor.take()\n             }\n-            self.timer = Some(timer);\n         }\n+    }\n \n-        // Once we've got a timer, stop any previous timeout, reset it for the\n-        // current one, and install some new channels to send/receive data on\n-        let timer = self.timer.get_mut_ref();\n-        timer.stop();\n-        timer.start(timer_cb, ms, 0);\n-        let (tx, rx) = channel();\n-        self.timeout_tx = Some(tx);\n-        self.timeout_rx = Some(rx);\n+    pub fn close(&mut self, m: HomingMissile) {\n+        self.access.access.close(&m);\n+        let task = self.access.access.get_mut(&m).blocked_acceptor.take();\n+        drop(m);\n+        let _ = task.map(|t| t.reawaken());\n+    }\n+}\n \n-        extern fn timer_cb(timer: *mut uvll::uv_timer_t) {\n-            let acceptor: &mut AcceptTimeout = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(timer) as *mut AcceptTimeout)\n-            };\n-            // This send can never fail because if this timer is active then the\n-            // receiving channel is guaranteed to be alive\n-            acceptor.timeout_tx.get_ref().send(());\n-        }\n+impl<T: Send> Clone for AcceptTimeout<T> {\n+    fn clone(&self) -> AcceptTimeout<T> {\n+        AcceptTimeout { access: self.access.clone() }\n     }\n }"}]}