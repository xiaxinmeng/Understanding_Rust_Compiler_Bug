{"sha": "428abb3d97bbecb90f29e6238dfbedfcf67df2b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyOGFiYjNkOTdiYmVjYjkwZjI5ZTYyMzhkZmJlZGZjZjY3ZGYyYjY=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-01-07T20:00:03Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-01-07T22:22:01Z"}, "message": "fmt: simplify parse_fmt_string", "tree": {"sha": "d6bb24e0a09e43543b772e334e4d6369f8e7efe2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6bb24e0a09e43543b772e334e4d6369f8e7efe2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/428abb3d97bbecb90f29e6238dfbedfcf67df2b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/428abb3d97bbecb90f29e6238dfbedfcf67df2b6", "html_url": "https://github.com/rust-lang/rust/commit/428abb3d97bbecb90f29e6238dfbedfcf67df2b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/428abb3d97bbecb90f29e6238dfbedfcf67df2b6/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e5a4166d5bf0ebad622535a6619e12014fc6470", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e5a4166d5bf0ebad622535a6619e12014fc6470", "html_url": "https://github.com/rust-lang/rust/commit/9e5a4166d5bf0ebad622535a6619e12014fc6470"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "d69015cbfc4eaecf9642daeae6ec7500ae548c18", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/428abb3d97bbecb90f29e6238dfbedfcf67df2b6/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/428abb3d97bbecb90f29e6238dfbedfcf67df2b6/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=428abb3d97bbecb90f29e6238dfbedfcf67df2b6", "patch": "@@ -154,39 +154,41 @@ pub mod ct {\n     pub type ErrorFn = fn@(&str) -> ! ;\n \n     pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n-        let mut pieces: ~[Piece] = ~[];\n-        let lim = str::len(s);\n-        let mut buf = ~\"\";\n-        fn flush_buf(buf: ~str, pieces: &mut ~[Piece]) -> ~str {\n-            if buf.len() > 0 {\n-                let piece = PieceString(move buf);\n-                pieces.push(move piece);\n+        fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n+            if to > from {\n+                ps.push(PieceString(s.slice(from, to)));\n             }\n-            return ~\"\";\n         }\n+\n+        let lim = s.len();\n+        let mut h = 0;\n         let mut i = 0;\n+        let mut pieces = ~[];\n+\n         while i < lim {\n-            let size = str::utf8_char_width(s[i]);\n-            let curr = str::slice(s, i, i+size);\n-            if curr == ~\"%\" {\n+            if s[i] == '%' as u8 {\n                 i += 1;\n+\n                 if i >= lim {\n                     err(~\"unterminated conversion at end of string\");\n-                }\n-                let curr2 = str::slice(s, i, i+1);\n-                if curr2 == ~\"%\" {\n-                    buf += curr2;\n+                } else if s[i] == '%' as u8 {\n+                    push_slice(&mut pieces, s, h, i);\n                     i += 1;\n                 } else {\n-                    buf = flush_buf(move buf, &mut pieces);\n-                    let rs = parse_conversion(s, i, lim, err);\n-                    pieces.push(copy rs.val);\n-                    i = rs.next;\n+                    push_slice(&mut pieces, s, h, i - 1);\n+                    let Parsed {val, next} = parse_conversion(s, i, lim, err);\n+                    pieces.push(val);\n+                    i = next;\n                 }\n-            } else { buf += curr; i += size; }\n+\n+                h = i;\n+            } else {\n+                i += str::utf8_char_width(s[i]);\n+            }\n         }\n-        flush_buf(move buf, &mut pieces);\n-        move pieces\n+\n+        push_slice(&mut pieces, s, h, i);\n+        pieces\n     }\n     pub fn peek_num(s: &str, i: uint, lim: uint) ->\n        Option<Parsed<uint>> {"}]}