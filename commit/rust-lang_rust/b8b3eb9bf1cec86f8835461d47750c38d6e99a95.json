{"sha": "b8b3eb9bf1cec86f8835461d47750c38d6e99a95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YjNlYjliZjFjZWM4NmY4ODM1NDYxZDQ3NzUwYzM4ZDZlOTlhOTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-09-16T14:09:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-16T14:09:58Z"}, "message": "Merge pull request #1229 from Manishearth/loops\n\nFix #1188", "tree": {"sha": "b437c90dab8e2a6f0a3944fe03d63c9e3213ac28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b437c90dab8e2a6f0a3944fe03d63c9e3213ac28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b3eb9bf1cec86f8835461d47750c38d6e99a95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b3eb9bf1cec86f8835461d47750c38d6e99a95", "html_url": "https://github.com/rust-lang/rust/commit/b8b3eb9bf1cec86f8835461d47750c38d6e99a95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b3eb9bf1cec86f8835461d47750c38d6e99a95/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "766217f9ac49640371d3095b0c7c6390d3e63407", "url": "https://api.github.com/repos/rust-lang/rust/commits/766217f9ac49640371d3095b0c7c6390d3e63407", "html_url": "https://github.com/rust-lang/rust/commit/766217f9ac49640371d3095b0c7c6390d3e63407"}, {"sha": "c8986b46765cedc1bb67bed2c8d4f66f8c6bebe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8986b46765cedc1bb67bed2c8d4f66f8c6bebe9", "html_url": "https://github.com/rust-lang/rust/commit/c8986b46765cedc1bb67bed2c8d4f66f8c6bebe9"}], "stats": {"total": 73, "additions": 69, "deletions": 4}, "files": [{"sha": "66ae404221b55788f1ced9298adff58be507f1ea", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8b3eb9bf1cec86f8835461d47750c38d6e99a95/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b3eb9bf1cec86f8835461d47750c38d6e99a95/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=b8b3eb9bf1cec86f8835461d47750c38d6e99a95", "patch": "@@ -14,9 +14,9 @@ use std::collections::HashMap;\n use syntax::ast;\n use utils::sugg;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, higher,\n-            walk_ptrs_ty};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg,\n+            in_external_macro, is_refutable, span_help_and_lint, is_integer_literal,\n+            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty};\n use utils::paths;\n \n /// **What it does:** Checks for looping over the range of `0..len` of some\n@@ -354,6 +354,7 @@ impl LateLintPass for Pass {\n                     if method_name.node.as_str() == \"next\" &&\n                        match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n                        lhs_constructor.name.as_str() == \"Some\" &&\n+                       !is_refutable(cx, &pat_args[0]) &&\n                        !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n                         let loop_var = snippet(cx, pat_args[0].span, \"_\");"}, {"sha": "2a86d0af380883f6a60431b1c85a5c4f48fe6828", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b8b3eb9bf1cec86f8835461d47750c38d6e99a95/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b3eb9bf1cec86f8835461d47750c38d6e99a95/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b8b3eb9bf1cec86f8835461d47750c38d6e99a95", "patch": "@@ -721,7 +721,43 @@ pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n     }\n }\n \n-pub fn is_copy<'a, 'ctx>(cx: &LateContext<'a, 'ctx>, ty: ty::Ty<'ctx>, env: NodeId) -> bool {\n+pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: NodeId) -> bool {\n     let env = ty::ParameterEnvironment::for_item(cx.tcx, env);\n     !ty.subst(cx.tcx, env.free_substs).moves_by_default(cx.tcx.global_tcx(), &env, DUMMY_SP)\n }\n+\n+/// Return whether a pattern is refutable.\n+pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n+    fn is_enum_variant(cx: &LateContext, did: NodeId) -> bool {\n+        matches!(cx.tcx.def_map.borrow().get(&did).map(|d| d.full_def()), Some(def::Def::Variant(..)))\n+    }\n+\n+    fn are_refutable<'a, I: Iterator<Item=&'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n+        i.any(|pat| is_refutable(cx, pat))\n+    }\n+\n+    match pat.node {\n+        PatKind::Binding(..) | PatKind::Wild => false,\n+        PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n+        PatKind::Lit(..) | PatKind::Range(..) => true,\n+        PatKind::Path(..) => is_enum_variant(cx, pat.id),\n+        PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n+        PatKind::Struct(_, ref fields, _) => {\n+            if is_enum_variant(cx, pat.id) {\n+                true\n+            } else {\n+                are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n+            }\n+        }\n+        PatKind::TupleStruct(_, ref pats, _) => {\n+            if is_enum_variant(cx, pat.id) {\n+                true\n+            } else {\n+                are_refutable(cx, pats.iter().map(|pat| &**pat))\n+            }\n+        }\n+        PatKind::Vec(ref head, ref middle, ref tail) => {\n+            are_refutable(cx, head.iter().chain(middle).chain(tail.iter()).map(|pat| &**pat))\n+        }\n+    }\n+}"}, {"sha": "7b0fb43575eeadd097dbfefe5ae3b8ad6908032c", "filename": "tests/compile-fail/while_loop.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b8b3eb9bf1cec86f8835461d47750c38d6e99a95/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b3eb9bf1cec86f8835461d47750c38d6e99a95/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=b8b3eb9bf1cec86f8835461d47750c38d6e99a95", "patch": "@@ -165,3 +165,31 @@ fn issue1017() {\n         }\n     }\n }\n+\n+// Issue #1188\n+fn refutable() {\n+    let a = [42, 1337];\n+    let mut b = a.iter();\n+\n+    // consume all the 42s\n+    while let Some(&42) = b.next() {\n+    }\n+\n+    let a = [(1, 2, 3)];\n+    let mut b = a.iter();\n+\n+    while let Some(&(1, 2, 3)) = b.next() {\n+    }\n+\n+    let a = [Some(42)];\n+    let mut b = a.iter();\n+\n+    while let Some(&None) = b.next() {\n+    }\n+\n+    /* This gives \u201crefutable pattern in `for` loop binding: `&_` not covered\u201d\n+    for &42 in b {}\n+    for &(1, 2, 3) in b {}\n+    for &Option::None in b.next() {}\n+    // */\n+}"}]}