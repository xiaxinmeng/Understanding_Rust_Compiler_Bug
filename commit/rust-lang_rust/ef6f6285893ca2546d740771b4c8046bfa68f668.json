{"sha": "ef6f6285893ca2546d740771b4c8046bfa68f668", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNmY2Mjg1ODkzY2EyNTQ2ZDc0MDc3MWI0YzgwNDZiZmE2OGY2Njg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-18T07:05:20Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-18T07:05:20Z"}, "message": "Refactor view_path to parse (but not yet process) export globs, unify code paths.", "tree": {"sha": "78c00965b1b06d7920ab4a64097bbf9c8b635b78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78c00965b1b06d7920ab4a64097bbf9c8b635b78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef6f6285893ca2546d740771b4c8046bfa68f668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef6f6285893ca2546d740771b4c8046bfa68f668", "html_url": "https://github.com/rust-lang/rust/commit/ef6f6285893ca2546d740771b4c8046bfa68f668", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef6f6285893ca2546d740771b4c8046bfa68f668/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f708968549b346611e8172b02612f3c32ca4feb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f708968549b346611e8172b02612f3c32ca4feb", "html_url": "https://github.com/rust-lang/rust/commit/6f708968549b346611e8172b02612f3c32ca4feb"}], "stats": {"total": 824, "additions": 423, "deletions": 401}, "files": [{"sha": "b21967721c55034f63f80b4e0fa5ea529c030eac", "filename": "src/comp/front/core_inject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcore_inject.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -31,7 +31,8 @@ fn inject_libcore_ref(sess: session,\n     let n2 = sess.next_node_id();\n \n     let vi1 = spanned(ast::view_item_use(\"core\", [], n1));\n-    let vi2 = spanned(ast::view_item_import_glob(@[\"core\"], n2));\n+    let vp = spanned(ast::view_path_glob(@[\"core\"], n2));\n+    let vi2 = spanned(ast::view_item_import([vp]));\n \n     let vis = [vi1, vi2] + crate.node.module.view_items;\n "}, {"sha": "fca60dc3be7e8102e6fc771bd877506e3666d6ee", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 253, "deletions": 185, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -100,8 +100,8 @@ enum mod_index_entry {\n \n type mod_index = hashmap<ident, list<mod_index_entry>>;\n \n-// A tuple of an imported def and the import stmt that brung it\n-type glob_imp_def = {def: def, item: @ast::view_item};\n+// A tuple of an imported def and the view_path from its originating import\n+type glob_imp_def = {def: def, path: @ast::view_path};\n \n type indexed_mod = {\n     m: option<ast::_mod>,\n@@ -200,43 +200,53 @@ fn create_env(sess: session, amap: ast_map::map) -> @env {\n       sess: sess}\n }\n \n+fn iter_import_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n+    alt vi.node {\n+      ast::view_item_import(vps) {\n+        for vp in vps {\n+            f(vp);\n+        }\n+      }\n+      _ {}\n+    }\n+}\n+\n+fn iter_export_paths(vi: ast::view_item, f: fn(vp: @ast::view_path)) {\n+    alt vi.node {\n+      ast::view_item_export(vps) {\n+        for vp in vps {\n+            f(vp);\n+        }\n+      }\n+      _ {}\n+    }\n+}\n+\n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n fn map_crate(e: @env, c: @ast::crate) {\n-    // First, find all the modules, and index the names that they contain\n-    let v_map_mod =\n-        @{visit_view_item: bind index_vi(e, _, _, _),\n-          visit_item: bind index_i(e, _, _, _),\n-          visit_block: visit_block_with_scope\n-          with *visit::default_visitor::<scopes>()};\n-    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_map_mod));\n \n-    // Register the top-level mod\n-    e.mod_map.insert(ast::crate_node_id,\n-                     @{m: some(c.node.module),\n-                       index: index_mod(c.node.module),\n-                       mutable glob_imports: [],\n-                       glob_imported_names: new_str_hash(),\n-                       path: \"\"});\n     fn index_vi(e: @env, i: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n-        alt i.node {\n-          ast::view_item_import(name, ids, id) {\n-            e.imports.insert(id, todo(id, name, ids, i.span, sc));\n-          }\n-          ast::view_item_import_from(mod_path, idents, id) {\n-            for ident in idents {\n-                e.imports.insert(ident.node.id,\n-                                 todo(ident.node.id, ident.node.name,\n-                                      @(*mod_path + [ident.node.name]),\n-                                      ident.span, sc));\n+        iter_import_paths(*i) { |vp|\n+            alt vp.node {\n+              ast::view_path_simple(name, path, id) {\n+                e.imports.insert(id, todo(id, name, path, vp.span, sc));\n+              }\n+              ast::view_path_glob(path, id) {\n+                e.imports.insert(id, is_glob(path, sc, vp.span));\n+              }\n+              ast::view_path_list(mod_path, idents, _) {\n+                for ident in idents {\n+                    let t = todo(ident.node.id, ident.node.name,\n+                                 @(*mod_path + [ident.node.name]),\n+                                 ident.span, sc);\n+                    e.imports.insert(ident.node.id, t);\n+                }\n+              }\n             }\n-          }\n-          ast::view_item_import_glob(pth, id) {\n-            e.imports.insert(id, is_glob(pth, sc, i.span));\n-          }\n-          _ { }\n         }\n     }\n+\n     fn path_from_scope(sc: scopes, n: str) -> str {\n         let path = n + \"::\";\n         list::iter(sc) {|s|\n@@ -247,6 +257,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n         }\n         path\n     }\n+\n     fn index_i(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         visit_item_with_scope(e, i, sc, v);\n         alt i.node {\n@@ -270,28 +281,23 @@ fn map_crate(e: @env, c: @ast::crate) {\n         }\n     }\n \n-    // Next, assemble the links for globbed imports.\n-    let v_link_glob =\n-        @{visit_view_item: bind link_glob(e, _, _, _),\n-          visit_block: visit_block_with_scope,\n-          visit_item: bind visit_item_with_scope(e, _, _, _)\n-          with *visit::default_visitor::<scopes>()};\n-    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_link_glob));\n     fn link_glob(e: @env, vi: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n-        alt vi.node {\n-          //if it really is a glob import, that is\n-          ast::view_item_import_glob(path, _) {\n-              alt follow_import(*e, sc, *path, vi.span) {\n-                 some(imp) {\n-                    let glob = {def: imp, item: vi};\n+        iter_import_paths(*vi) { |vp|\n+            //if it really is a glob import, that is\n+            alt vp.node {\n+              ast::view_path_glob(path, _) {\n+                alt follow_import(*e, sc, *path, vp.span) {\n+                  some(imp) {\n+                    let glob = {def: imp, path: vp};\n                     check list::is_not_empty(sc);\n                     alt list::head(sc) {\n                       scope_item(i) {\n                         e.mod_map.get(i.id).glob_imports += [glob];\n                       }\n                       scope_block(b, _, _) {\n                         let globs = alt e.block_map.find(b.node.id) {\n-                                some(globs) { globs + [glob] } none { [glob] }\n+                          some(globs) { globs + [glob] }\n+                          none { [glob] }\n                         };\n                         e.block_map.insert(b.node.id, globs);\n                       }\n@@ -300,15 +306,41 @@ fn map_crate(e: @env, c: @ast::crate) {\n                             += [glob];\n                       }\n                       _ { e.sess.span_bug(vi.span, \"Unexpected scope in a \\\n-                           glob import\"); }\n-                      }\n+                                                    glob import\"); }\n+                    }\n+                  }\n+                  _ { }\n                 }\n-                _ { }\n-             }\n-          }\n-          _ { }\n+              }\n+              _ { }\n+            }\n         }\n     }\n+\n+    // First, find all the modules, and index the names that they contain\n+    let v_map_mod =\n+        @{visit_view_item: bind index_vi(e, _, _, _),\n+          visit_item: bind index_i(e, _, _, _),\n+          visit_block: visit_block_with_scope\n+          with *visit::default_visitor::<scopes>()};\n+    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_map_mod));\n+\n+    // Register the top-level mod\n+    e.mod_map.insert(ast::crate_node_id,\n+                     @{m: some(c.node.module),\n+                       index: index_mod(c.node.module),\n+                       mutable glob_imports: [],\n+                       glob_imported_names: new_str_hash(),\n+                       path: \"\"});\n+\n+    // Next, assemble the links for globbed imports.\n+    let v_link_glob =\n+        @{visit_view_item: bind link_glob(e, _, _, _),\n+          visit_block: visit_block_with_scope,\n+          visit_item: bind visit_item_with_scope(e, _, _, _)\n+          with *visit::default_visitor::<scopes>()};\n+    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_link_glob));\n+\n }\n \n fn resolve_imports(e: env) {\n@@ -674,18 +706,20 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n         fn lst(my_id: node_id, vis: [@view_item]) -> [node_id] {\n             let imports = [], found = false;\n             for vi in vis {\n-                alt vi.node {\n-                  view_item_import(_, _, id) | view_item_import_glob(_, id) {\n-                    if id == my_id { found = true; }\n-                    if found { imports += [id]; }\n-                  }\n-                  view_item_import_from(_, ids, _) {\n-                    for id in ids {\n-                        if id.node.id == my_id { found = true; }\n-                        if found { imports += [id.node.id]; }\n+                iter_import_paths(*vi) {|vp|\n+                    alt vp.node {\n+                      view_path_simple(_, _, id)\n+                      | view_path_glob(_, id) {\n+                        if id == my_id { found = true; }\n+                        if found { imports += [id]; }\n+                      }\n+                      view_path_list(_, ids, _) {\n+                        for id in ids {\n+                            if id.node.id == my_id { found = true; }\n+                            if found { imports += [id.node.id]; }\n+                        }\n+                      }\n                     }\n-                  }\n-                  _ {}\n                 }\n             }\n             imports\n@@ -1177,25 +1211,38 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n     }\n     for vi in b.view_items {\n         alt vi.node {\n-          ast::view_item_import(ident, _, id) {\n-            if name == ident { ret lookup_import(e, local_def(id), ns); }\n-          }\n-          ast::view_item_import_from(mod_path, idents, id) {\n-            for ident in idents {\n-                if name == ident.node.name {\n-                    ret lookup_import(e, local_def(ident.node.id), ns);\n+\n+          ast::view_item_import(vps) {\n+            for vp in vps {\n+                alt vp.node {\n+                  ast::view_path_simple(ident, _, id) {\n+                    if name == ident {\n+                        ret lookup_import(e, local_def(id), ns);\n+                    }\n+                  }\n+\n+                  ast::view_path_list(path, idents, _) {\n+                    for ident in idents {\n+                        if name == ident.node.name {\n+                            let def = local_def(ident.node.id);\n+                            ret lookup_import(e, def, ns);\n+                        }\n+                    }\n+                  }\n+\n+                  ast::view_path_glob(_, _) {\n+                    alt e.block_map.find(b.id) {\n+                      some(globs) {\n+                        let found = lookup_in_globs(e, globs, sp, name,\n+                                                    ns, inside);\n+                        if found != none { ret found; }\n+                      }\n+                      _ {}\n+                    }\n+                  }\n                 }\n             }\n           }\n-          ast::view_item_import_glob(_, _) {\n-            alt e.block_map.find(b.id) {\n-              some(globs) {\n-                let found = lookup_in_globs(e, globs, sp, name, ns, inside);\n-                if found != none { ret found; }\n-              }\n-              _ {}\n-            }\n-          }\n           _ { e.sess.span_bug(vi.span, \"Unexpected view_item in block\"); }\n         }\n     }\n@@ -1363,16 +1410,18 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n                    ns: namespace, dr: dir) -> option<def> {\n     fn lookup_in_mod_(e: env, def: glob_imp_def, sp: span, name: ident,\n                       ns: namespace, dr: dir) -> option<glob_imp_def> {\n-        alt def.item.node {\n-          ast::view_item_import_glob(_, id) {\n+        alt def.path.node {\n+\n+          ast::view_path_glob(_, id) {\n             if vec::contains(e.ignored_imports, id) { ret none; }\n           }\n+\n           _ {\n             e.sess.span_bug(sp, \"lookup_in_globs: not a glob\");\n           }\n         }\n         alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n-          some(d) { option::some({def: d, item: def.item}) }\n+          some(d) { option::some({def: d, path: def.path}) }\n           none { none }\n         }\n     }\n@@ -1385,7 +1434,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n         ret some(matches[0].def);\n     } else {\n         for match: glob_imp_def in matches {\n-            let sp = match.item.span;\n+            let sp = match.path.span;\n             e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n         }\n         e.sess.span_fatal(sp, \"'\" + id + \"' is glob-imported from\" +\n@@ -1476,28 +1525,41 @@ fn add_to_index(index: hashmap<ident, list<mod_index_entry>>, id: ident,\n     }\n }\n \n-fn index_mod(md: ast::_mod) -> mod_index {\n-    let index = new_str_hash::<list<mod_index_entry>>();\n-    for it: @ast::view_item in md.view_items {\n-        alt it.node {\n+fn index_view_items(view_items: [@ast::view_item],\n+                    index: hashmap<ident, list<mod_index_entry>>) {\n+    for vi in view_items {\n+        alt vi.node {\n           ast::view_item_use(ident, _, id) {\n-           add_to_index(index, ident, mie_view_item(ident, id, it.span));\n+           add_to_index(index, ident, mie_view_item(ident, id, vi.span));\n           }\n-          ast::view_item_import(ident, _, id) {\n-            add_to_index(index, ident, mie_import_ident(id, it.span));\n-          }\n-          ast::view_item_import_from(_, idents, _) {\n-            for ident in idents {\n-                add_to_index(index, ident.node.name,\n-                             mie_import_ident(ident.node.id, ident.span));\n-            }\n-          }\n-          //globbed imports have to be resolved lazily.\n-          ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {}\n-          // exports: ignore\n           _ {}\n         }\n+\n+        iter_import_paths(*vi) {|vp|\n+            alt vp.node {\n+              ast::view_path_simple(ident, _, id) {\n+                add_to_index(index, ident, mie_import_ident(id, vp.span));\n+              }\n+              ast::view_path_list(_, idents, _) {\n+                for ident in idents {\n+                    add_to_index(index, ident.node.name,\n+                                 mie_import_ident(ident.node.id,\n+                                                  ident.span));\n+                }\n+              }\n+\n+              // globbed imports have to be resolved lazily.\n+              ast::view_path_glob(_, _) {}\n+            }\n+        }\n     }\n+}\n+\n+fn index_mod(md: ast::_mod) -> mod_index {\n+    let index = new_str_hash::<list<mod_index_entry>>();\n+\n+    index_view_items(md.view_items, index);\n+\n     for it: @ast::item in md.items {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n@@ -1537,27 +1599,12 @@ fn index_mod(md: ast::_mod) -> mod_index {\n     ret index;\n }\n \n+\n fn index_nmod(md: ast::native_mod) -> mod_index {\n     let index = new_str_hash::<list<mod_index_entry>>();\n-    for it: @ast::view_item in md.view_items {\n-        alt it.node {\n-          ast::view_item_use(ident, _, id) {\n-            add_to_index(index, ident, mie_view_item(ident, id,\n-                                                     it.span));\n-          }\n-          ast::view_item_import(ident, _, id) {\n-            add_to_index(index, ident, mie_import_ident(id, it.span));\n-          }\n-          ast::view_item_import_from(_, idents, _) {\n-            for ident in idents {\n-                add_to_index(index, ident.node.name,\n-                             mie_import_ident(ident.node.id, ident.span));\n-            }\n-          }\n-          ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) { }\n-          _ { /* tag exports */ }\n-        }\n-    }\n+\n+    index_view_items(md.view_items, index);\n+\n     for it: @ast::native_item in md.items {\n         add_to_index(index, it.ident, mie_native_item(it));\n     }\n@@ -1912,55 +1959,72 @@ fn check_exports(e: @env) {\n       }\n     }\n \n+    fn check_export_enum_list(e: @env, val: @indexed_mod,\n+                              span: codemap::span, id: ast::ident,\n+                              ids: [ast::path_list_ident]) {\n+        if vec::len(ids) == 0u {\n+            let _ = check_enum_ok(e, span, id, val);\n+        } else {\n+            let parent_id = check_enum_ok(e, span, id, val);\n+            for variant_id in ids {\n+                alt val.index.find(variant_id.node.name) {\n+                  some(ms) {\n+                    list::iter(ms) {|m|\n+                        alt m {\n+                          mie_enum_variant(_, _, actual_parent_id, _) {\n+                            if actual_parent_id != parent_id {\n+                                let msg = #fmt(\"variant %s \\\n+                                                doesn't belong to enum %s\",\n+                                               variant_id.node.name,\n+                                               id);\n+                                e.sess.span_err(span, msg);\n+                            }\n+                          }\n+                          _ {\n+                            e.sess.span_err(span,\n+                                            #fmt(\"%s is not a variant\",\n+                                                 variant_id.node.name));\n+                          }\n+                        }\n+                    }\n+                  }\n+                  _ {\n+                    e.sess.span_err(span,\n+                                    #fmt(\"%s is not a variant\",\n+                                         variant_id.node.name));\n+                  }\n+                }\n+            }\n+        }\n+    }\n+\n     e.mod_map.values {|val|\n         alt val.m {\n           some(m) {\n             for vi in m.view_items {\n-                alt vi.node {\n-                  ast::view_item_export(idents, _) {\n-                    for ident in idents {\n+                iter_export_paths(*vi) { |vp|\n+                    alt vp.node {\n+                      ast::view_path_simple(ident, _, _) {\n                         check_export(e, ident, val, vi);\n-                    }\n-                  }\n-                  ast::view_item_export_enum_none(id, _) {\n-                      let _ = check_enum_ok(e, vi.span, id, val);\n-                  }\n-                  ast::view_item_export_enum_some(id, ids, _) {\n-                      // Check that it's an enum and all the given variants\n-                      // belong to it\n-                      let parent_id = check_enum_ok(e, vi.span, id, val);\n-                      for variant_id in ids {\n-                         alt val.index.find(variant_id.node.name) {\n-                            some(ms) {\n-                                list::iter(ms) {|m|\n-                                   alt m {\n-                                     mie_enum_variant(_, _, actual_parent_id,\n-                                                     _) {\n-                                       if actual_parent_id != parent_id {\n-                                          e.sess.span_err(vi.span,\n-                                           #fmt(\"variant %s \\\n-                                           doesn't belong to enum %s\",\n-                                                variant_id.node.name,\n-                                                id));\n-                                       }\n-                                     }\n-                                     _ { e.sess.span_err(vi.span,\n-                                         #fmt(\"%s is not a \\\n-                                         variant\", variant_id.node.name));  }\n-                                       }}\n-                            }\n-                            _ { e.sess.span_err(vi.span, #fmt(\"%s is not a\\\n-                                         variant\", variant_id.node.name));  }\n                       }\n-                     }\n-                  }\n-                  _ { }\n+                      ast::view_path_list(path, ids, _) {\n+                        let id = if vec::len(*path) == 1u {\n+                            path[0]\n+                        } else {\n+                            e.sess.span_fatal(vp.span,\n+                                            #fmt(\"bad export name-list\"))\n+                        };\n+                        check_export_enum_list(e, val, vp.span, id, ids);\n+                      }\n+                      _ {}\n+                    }\n                 }\n             }\n           }\n           none { }\n         }\n-    }}\n+    }\n+}\n \n // Impl resolution\n \n@@ -1993,43 +2057,47 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n           _ {}\n         }\n     }\n-    alt vi.node {\n-      ast::view_item_import(name, pt, id) {\n-        let found = [];\n-        if vec::len(*pt) == 1u {\n-            option::may(sc) {|sc|\n-                list::iter(sc) {|level|\n-                    if vec::len(found) > 0u { ret; }\n-                    for imp in *level {\n-                        if imp.ident == pt[0] {\n-                            found += [@{ident: name with *imp}];\n+\n+    iter_import_paths(*vi) { |vp|\n+        alt vp.node {\n+          ast::view_path_simple(name, pt, id) {\n+            let found = [];\n+            if vec::len(*pt) == 1u {\n+                option::may(sc) {|sc|\n+                    list::iter(sc) {|level|\n+                        if vec::len(found) > 0u { ret; }\n+                        for imp in *level {\n+                            if imp.ident == pt[0] {\n+                                found += [@{ident: name with *imp}];\n+                            }\n                         }\n+                        if vec::len(found) > 0u { impls += found; }\n                     }\n-                    if vec::len(found) > 0u { impls += found; }\n+                }\n+            } else {\n+                lookup_imported_impls(e, id) {|is|\n+                    for i in *is { impls += [@{ident: name with *i}]; }\n                 }\n             }\n-        } else {\n-            lookup_imported_impls(e, id) {|is|\n-                for i in *is { impls += [@{ident: name with *i}]; }\n+          }\n+\n+          ast::view_path_list(base, names, _) {\n+            for nm in names {\n+                lookup_imported_impls(e, nm.node.id) {|is| impls += *is; }\n             }\n-        }\n-      }\n-      ast::view_item_import_from(base, names, _) {\n-        for nm in names {\n-            lookup_imported_impls(e, nm.node.id) {|is| impls += *is; }\n-        }\n-      }\n-      ast::view_item_import_glob(ids, id) {\n-        alt check e.imports.get(id) {\n-          is_glob(path, sc, sp) {\n-            alt follow_import(e, sc, *path, sp) {\n-              some(def) { find_impls_in_mod(e, def, impls, none); }\n-              _ {}\n+          }\n+\n+          ast::view_path_glob(ids, id) {\n+            alt check e.imports.get(id) {\n+              is_glob(path, sc, sp) {\n+                alt follow_import(e, sc, *path, sp) {\n+                  some(def) { find_impls_in_mod(e, def, impls, none); }\n+                  _ {}\n+                }\n+              }\n             }\n           }\n         }\n-      }\n-      _ {}\n     }\n }\n "}, {"sha": "a76b6f9919fb31e00679ca7777028057a0aec3a2", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -441,26 +441,36 @@ type variant_ = {name: ident, attrs: [attribute], args: [variant_arg],\n \n type variant = spanned<variant_>;\n \n-type view_item = spanned<view_item_>;\n \n // FIXME: May want to just use path here, which would allow things like\n // 'import ::foo'\n type simple_path = [ident];\n \n-type import_ident_ = {name: ident, id: node_id};\n+type path_list_ident_ = {name: ident, id: node_id};\n+type path_list_ident = spanned<path_list_ident_>;\n+\n+type view_path = spanned<view_path_>;\n+enum view_path_ {\n+\n+    // quux = foo::bar::baz\n+    //\n+    // or just\n+    //\n+    // foo::bar::baz  (with 'baz =' implicitly on the left)\n+    view_path_simple(ident, @simple_path, node_id),\n \n-type import_ident = spanned<import_ident_>;\n+    // foo::bar::*\n+    view_path_glob(@simple_path, node_id),\n \n+    // foo::bar::{a,b,c}\n+    view_path_list(@simple_path, [path_list_ident], node_id)\n+}\n+\n+type view_item = spanned<view_item_>;\n enum view_item_ {\n     view_item_use(ident, [@meta_item], node_id),\n-    view_item_import(ident, @simple_path, node_id),\n-    view_item_import_glob(@simple_path, node_id),\n-    view_item_import_from(@simple_path, [import_ident], node_id),\n-    view_item_export([ident], node_id),\n-    // export foo::{}\n-    view_item_export_enum_none(ident, node_id),\n-    // export foo::{bar, baz, blat}\n-    view_item_export_enum_some(ident, [import_ident], node_id)\n+    view_item_import([@view_path]),\n+    view_item_export([@view_path])\n }\n \n // Meta-data associated with an item"}, {"sha": "09242f40c4217030ae45579e6672e8f1b8f24e41", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -116,56 +116,63 @@ fn float_ty_to_str(t: float_ty) -> str {\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {\n-    let nonlocal = true;\n+    let local = false;\n     let parent_enum : option<ident> = none;\n     for it: @item in m.items {\n-        if it.ident == i { nonlocal = false; }\n+        if it.ident == i { local = true; }\n         alt it.node {\n           item_enum(variants, _) {\n             for v: variant in variants {\n                 if v.node.name == i {\n-                   nonlocal = false;\n+                   local = true;\n                    parent_enum = some(it.ident);\n                 }\n             }\n           }\n           _ { }\n         }\n-        if !nonlocal { break; }\n+        if local { break; }\n     }\n-    let count = 0u;\n+    let has_explicit_exports = false;\n     for vi: @view_item in m.view_items {\n         alt vi.node {\n-          view_item_export(ids, _) {\n-              // If any of ids is a enum, we want to consider\n-              // all the variants to be exported\n-            for id in ids {\n-                if str::eq(i, id) { ret true; }\n-                alt parent_enum {\n-                    some(parent_enum_id) {\n-                        if str::eq(id, parent_enum_id) { ret true; }\n+          view_item_export(vps) {\n+            has_explicit_exports = true;\n+            for vp in vps {\n+                alt vp.node {\n+                  ast::view_path_simple(id, _, _) {\n+                    if id == i { ret true; }\n+                    alt parent_enum {\n+                      some(parent_enum_id) {\n+                        if id == parent_enum_id { ret true; }\n+                      }\n+                      _ {}\n                     }\n-                    _ { }\n-                 }\n+                  }\n+\n+                  ast::view_path_list(path, ids, _) {\n+                    if vec::len(*path) == 1u {\n+                        if i == path[0] { ret true; }\n+                        for id in ids {\n+                            if id.node.name == i { ret true; }\n+                        }\n+                    } else {\n+                        fail \"export of path-qualified list\";\n+                    }\n+                  }\n+\n+                  // FIXME: glob-exports aren't supported yet.\n+                  _ {}\n+                }\n             }\n-            count += 1u;\n-          }\n-          view_item_export_enum_none(id, _) {\n-              if str::eq(i, id) { ret true; }\n-              count += 1u;\n-          }\n-          view_item_export_enum_some(id, ids, _) {\n-              if str::eq(i, id) { ret true; }\n-              for id in ids { if str::eq(i, id.node.name) { ret true; } }\n-              count += 1u;\n           }\n-          _ {/* fall through */ }\n+          _ {}\n         }\n     }\n     // If there are no declared exports then\n     // everything not imported is exported\n-    // even if it's nonlocal (since it's explicit)\n-    ret count == 0u && !nonlocal;\n+    // even if it's local (since it's explicit)\n+    ret !has_explicit_exports && local;\n }\n \n pure fn is_call_expr(e: @expr) -> bool {"}, {"sha": "eb34fb4b89d43057df9947f70e0ad2e8de95dcf4", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 64, "deletions": 119, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -202,7 +202,7 @@ fn parse_ident(p: parser) -> ast::ident {\n     }\n }\n \n-fn parse_import_ident(p: parser) -> ast::import_ident {\n+fn parse_path_list_ident(p: parser) -> ast::path_list_ident {\n     let lo = p.span.lo;\n     let ident = parse_ident(p);\n     let hi = p.span.hi;\n@@ -2421,139 +2421,80 @@ fn parse_use(p: parser) -> ast::view_item_ {\n     ret ast::view_item_use(ident, metadata, p.get_id());\n }\n \n-fn parse_rest_import_name(p: parser, first: ast::ident,\n-                          def_ident: option<ast::ident>) ->\n-   ast::view_item_ {\n-    let identifiers: [ast::ident] = [first];\n-    let glob: bool = false;\n-    let from_idents = option::none::<[ast::import_ident]>;\n-    while true {\n-        alt p.token {\n-          token::SEMI { break; }\n-          token::MOD_SEP {\n-            if glob { p.fatal(\"cannot path into a glob\"); }\n-            if option::is_some(from_idents) {\n-                p.fatal(\"cannot path into import list\");\n-            }\n+fn parse_view_path(p: parser) -> @ast::view_path {\n+    let lo = p.span.lo;\n+    let first_ident = parse_ident(p);\n+    let path = [first_ident];\n+    #debug(\"parsed view_path: %s\", first_ident);\n+    alt p.token {\n+      token::EQ {\n+        // x = foo::bar\n+        p.bump();\n+        path = [parse_ident(p)];\n+        while p.token == token::MOD_SEP {\n             p.bump();\n-          }\n-          _ { p.fatal(\"expecting '::' or ';'\"); }\n+            let id = parse_ident(p);\n+            path += [id];\n         }\n-        alt p.token {\n-          token::IDENT(_, _) { identifiers += [parse_ident(p)]; }\n-\n-\n-\n-\n+        let hi = p.span.hi;\n+        ret @spanned(lo, hi,\n+                     ast::view_path_simple(first_ident,\n+                                           @path, p.get_id()));\n+      }\n \n-          //the lexer can't tell the different kinds of stars apart ) :\n-          token::BINOP(token::STAR) {\n-            glob = true;\n+      token::MOD_SEP {\n+        // foo::bar or foo::{a,b,c} or foo::*\n+        while p.token == token::MOD_SEP {\n             p.bump();\n-          }\n \n+            alt p.token {\n \n+              token::IDENT(i, _) {\n+                p.bump();\n+                path += [p.get_str(i)];\n+              }\n \n+              // foo::bar::{a,b,c}\n+              token::LBRACE {\n+                let idents =\n+                    parse_seq(token::LBRACE, token::RBRACE,\n+                              seq_sep(token::COMMA),\n+                              parse_path_list_ident, p).node;\n+                let hi = p.span.hi;\n+                ret @spanned(lo, hi,\n+                             ast::view_path_list(@path, idents,\n+                                                 p.get_id()));\n+              }\n \n+              // foo::bar::*\n+              token::BINOP(token::STAR) {\n+                p.bump();\n+                let hi = p.span.hi;\n+                ret @spanned(lo, hi,\n+                             ast::view_path_glob(@path,\n+                                                 p.get_id()));\n+              }\n \n-          token::LBRACE {\n-            let from_idents_ =\n-                parse_seq(token::LBRACE, token::RBRACE, seq_sep(token::COMMA),\n-                          parse_import_ident, p).node;\n-            if vec::is_empty(from_idents_) {\n-                p.fatal(\"at least one import is required\");\n+              _ { break; }\n             }\n-            from_idents = some(from_idents_);\n-          }\n-\n-\n-\n-\n-\n-          _ {\n-            p.fatal(\"expecting an identifier, or '*'\");\n-          }\n-        }\n-    }\n-    alt def_ident {\n-      some(i) {\n-        if glob { p.fatal(\"globbed imports can't be renamed\"); }\n-        if option::is_some(from_idents) {\n-            p.fatal(\"can't rename import list\");\n-        }\n-        ret ast::view_item_import(i, @identifiers, p.get_id());\n-      }\n-      _ {\n-        if glob {\n-            ret ast::view_item_import_glob(@identifiers, p.get_id());\n-        } else if option::is_some(from_idents) {\n-            ret ast::view_item_import_from(@identifiers,\n-                                           option::get(from_idents),\n-                                           p.get_id());\n-        } else {\n-            let len = vec::len(identifiers);\n-            ret ast::view_item_import(identifiers[len - 1u], @identifiers,\n-                                      p.get_id());\n         }\n       }\n+      _ { }\n     }\n+    let hi = p.span.hi;\n+    let last = path[vec::len(path) - 1u];\n+    ret @spanned(lo, hi,\n+                 ast::view_path_simple(last, @path,\n+                                       p.get_id()));\n }\n \n-fn parse_full_import_name(p: parser, def_ident: ast::ident) ->\n-   ast::view_item_ {\n-    alt p.token {\n-      token::IDENT(i, _) {\n+fn parse_view_paths(p: parser) -> [@ast::view_path] {\n+    let vp = [parse_view_path(p)];\n+    while p.token == token::COMMA {\n         p.bump();\n-        ret parse_rest_import_name(p, p.get_str(i), some(def_ident));\n-      }\n-      _ { p.fatal(\"expecting an identifier\"); }\n-    }\n-}\n-\n-fn parse_import(p: parser) -> ast::view_item_ {\n-    alt p.token {\n-      token::IDENT(i, _) {\n-        p.bump();\n-        alt p.token {\n-          token::EQ {\n-            p.bump();\n-            ret parse_full_import_name(p, p.get_str(i));\n-          }\n-          _ { ret parse_rest_import_name(p, p.get_str(i), none); }\n-        }\n-      }\n-      _ { p.fatal(\"expecting an identifier\"); }\n-    }\n-}\n-\n-fn parse_enum_export(p:parser, tyname:ast::ident) -> ast::view_item_ {\n-    let enumnames:[ast::import_ident] =\n-        parse_seq(token::LBRACE, token::RBRACE,\n-             seq_sep(token::COMMA), {|p| parse_import_ident(p) }, p).node;\n-    let id = p.get_id();\n-    if vec::is_empty(enumnames) {\n-       ret ast::view_item_export_enum_none(tyname, id);\n-    }\n-    else {\n-       ret ast::view_item_export_enum_some(tyname, enumnames, id);\n-    }\n-}\n-\n-fn parse_export(p: parser) -> ast::view_item_ {\n-    let first = parse_ident(p);\n-    alt p.token {\n-       token::MOD_SEP {\n-           p.bump();\n-           ret parse_enum_export(p, first);\n-       }\n-       t {\n-           if t == token::COMMA { p.bump(); }\n-           let ids =\n-               parse_seq_to_before_end(token::SEMI, seq_sep(token::COMMA),\n-                                       parse_ident, p);\n-           ret ast::view_item_export(vec::concat([[first], ids]), p.get_id());\n-       }\n+        vp += [parse_view_path(p)];\n     }\n+    ret vp;\n }\n \n fn parse_view_item(p: parser) -> @ast::view_item {\n@@ -2562,8 +2503,12 @@ fn parse_view_item(p: parser) -> @ast::view_item {\n         if eat_word(p, \"use\") {\n             parse_use(p)\n         } else if eat_word(p, \"import\") {\n-            parse_import(p)\n-        } else if eat_word(p, \"export\") { parse_export(p) } else { fail };\n+            ast::view_item_import(parse_view_paths(p))\n+        } else if eat_word(p, \"export\") {\n+            ast::view_item_export(parse_view_paths(p))\n+        } else {\n+            fail\n+    };\n     let hi = p.span.lo;\n     expect(p, token::SEMI);\n     ret @spanned(lo, hi, the_item);"}, {"sha": "3d0e8a579dcc90ea42ed751d836782c67420a5b8", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -1333,6 +1333,44 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     end(s);\n }\n \n+fn print_simple_path(s: ps, path: ast::simple_path) {\n+    let first = true;\n+    for id in path {\n+        if first { first = false; } else { word(s.s, \"::\"); }\n+        word(s.s, id);\n+    }\n+}\n+\n+fn print_view_path(s: ps, &&vp: @ast::view_path) {\n+    alt vp.node {\n+      ast::view_path_simple(ident, path, _) {\n+        if path[vec::len(*path)-1u] != ident {\n+            word_space(s, ident);\n+            word_space(s, \"=\");\n+        }\n+        print_simple_path(s, *path);\n+      }\n+\n+      ast::view_path_glob(path, _) {\n+        print_simple_path(s, *path);\n+        word(s.s, \"::*\");\n+      }\n+\n+      ast::view_path_list(path, idents, _) {\n+        print_simple_path(s, *path);\n+        word(s.s, \"::{\");\n+        commasep(s, inconsistent, idents) {|s, w|\n+            word(s.s, w.node.name)\n+        }\n+        word(s.s, \"}\");\n+      }\n+    }\n+}\n+\n+fn print_view_paths(s: ps, vps: [@ast::view_path]) {\n+    commasep(s, inconsistent, vps, print_view_path);\n+}\n+\n fn print_view_item(s: ps, item: @ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n@@ -1346,59 +1384,20 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n             pclose(s);\n         }\n       }\n-      ast::view_item_import(id, ids, _) {\n-        head(s, \"import\");\n-        if !str::eq(id, ids[vec::len(*ids) - 1u]) {\n-            word_space(s, id);\n-            word_space(s, \"=\");\n-        }\n-        let first = true;\n-        for elt: ast::ident in *ids {\n-            if first { first = false; } else { word(s.s, \"::\"); }\n-            word(s.s, elt);\n-        }\n-      }\n-      ast::view_item_import_from(mod_path, idents, _) {\n-        head(s, \"import\");\n-        for elt: ast::ident in *mod_path { word(s.s, elt); word(s.s, \"::\"); }\n-        word(s.s, \"{\");\n-        commasep(s, inconsistent, idents,\n-                 fn@(s: ps, w: ast::import_ident) { word(s.s, w.node.name) });\n-        word(s.s, \"}\");\n-      }\n-      ast::view_item_import_glob(ids, _) {\n+\n+      ast::view_item_import(vps) {\n         head(s, \"import\");\n-        let first = true;\n-        for elt: ast::ident in *ids {\n-            if first { first = false; } else { word(s.s, \"::\"); }\n-            word(s.s, elt);\n-        }\n-        word(s.s, \"::*\");\n+        print_view_paths(s, vps);\n       }\n-      ast::view_item_export(ids, _) {\n+\n+      ast::view_item_export(vps) {\n         head(s, \"export\");\n-        commasep(s, inconsistent, ids,\n-                 fn@(s: ps, &&w: ast::ident) { word(s.s, w) });\n-      }\n-      ast::view_item_export_enum_none(id, _) {\n-          head(s, \"export\");\n-          word(s.s, id);\n-          word(s.s, \"::{}\");\n-      }\n-      ast::view_item_export_enum_some(id, ids, _) {\n-          head(s, \"export\");\n-          word(s.s, id);\n-          word(s.s, \"::{\");\n-          commasep(s, inconsistent, ids, fn@(s:ps, &&w: ast::import_ident) {\n-                  word(s.s, w.node.name) });\n-          word(s.s, \"}\");\n+        print_view_paths(s, vps);\n       }\n     }\n     word(s.s, \";\");\n     end(s); // end inner head-block\n-\n     end(s); // end outer head-block\n-\n }\n \n "}, {"sha": "d80aa4f7ade441d0c4f9641f9bec1511c9f5bc49", "filename": "src/test/compile-fail/import-from-none.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f708968549b346611e8172b02612f3c32ca4feb/src%2Ftest%2Fcompile-fail%2Fimport-from-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f708968549b346611e8172b02612f3c32ca4feb/src%2Ftest%2Fcompile-fail%2Fimport-from-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-none.rs?ref=6f708968549b346611e8172b02612f3c32ca4feb", "patch": "@@ -1,8 +0,0 @@\n-// error-pattern:at least one import is required\n-import spam::{};\n-\n-mod spam {\n-}\n-\n-fn main() {\n-}\n\\ No newline at end of file"}, {"sha": "b8accfd0eb9cac31abd41affafc9372ecc2cbbb2", "filename": "src/test/compile-fail/import-from-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-from-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-from-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-path.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern:cannot path into import list\n+// error-pattern:expecting\n import foo::{bar}::baz\n\\ No newline at end of file"}, {"sha": "54a789cf902c00d80d06aa4777911110172429ed", "filename": "src/test/compile-fail/import-from-rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-from-rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-from-rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-rename.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:can't rename import list\n+// error-pattern:expecting\n \n import baz = foo::{bar};\n "}, {"sha": "6204cc246c6b5183eb7bbae850429c9ab2afd7eb", "filename": "src/test/compile-fail/import-glob-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-glob-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-glob-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-path.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern:cannot path into a glob\n+// error-pattern:expecting\n import foo::*::bar\n\\ No newline at end of file"}, {"sha": "9d08a0dad11871e12d6e69ac7567d59543aad8ae", "filename": "src/test/compile-fail/import-glob-rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-glob-rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef6f6285893ca2546d740771b4c8046bfa68f668/src%2Ftest%2Fcompile-fail%2Fimport-glob-rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-rename.rs?ref=ef6f6285893ca2546d740771b4c8046bfa68f668", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:globbed imports can't be renamed\n+// error-pattern:expecting\n \n import baz = foo::*;\n "}]}