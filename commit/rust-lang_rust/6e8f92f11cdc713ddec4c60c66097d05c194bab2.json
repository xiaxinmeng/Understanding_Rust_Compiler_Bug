{"sha": "6e8f92f11cdc713ddec4c60c66097d05c194bab2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOGY5MmYxMWNkYzcxM2RkZWM0YzYwYzY2MDk3ZDA1YzE5NGJhYjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-07T18:38:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-07T18:38:27Z"}, "message": "Auto merge of #36981 - alexcrichton:catch-unwind-for-tests, r=sfackler\n\nstd: Minor cleanup to libtest\n\n* Don't spawn two threads for all tests, just one now that `catch_unwind` is\n  stable.\n* Remove usage of the unstable `box` keyword\n* Remove usage of the unstable `FnBox` trait", "tree": {"sha": "37a5d6f3f0904f4f34ddaafb4beaacd55b1e589e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37a5d6f3f0904f4f34ddaafb4beaacd55b1e589e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e8f92f11cdc713ddec4c60c66097d05c194bab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e8f92f11cdc713ddec4c60c66097d05c194bab2", "html_url": "https://github.com/rust-lang/rust/commit/6e8f92f11cdc713ddec4c60c66097d05c194bab2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e8f92f11cdc713ddec4c60c66097d05c194bab2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca76c7e0148f87876dbf8ad1f7dd13fb9f268481", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca76c7e0148f87876dbf8ad1f7dd13fb9f268481", "html_url": "https://github.com/rust-lang/rust/commit/ca76c7e0148f87876dbf8ad1f7dd13fb9f268481"}, {"sha": "0714024c991bc6a02017fa0b7747aee67877d53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0714024c991bc6a02017fa0b7747aee67877d53f", "html_url": "https://github.com/rust-lang/rust/commit/0714024c991bc6a02017fa0b7747aee67877d53f"}], "stats": {"total": 134, "additions": 67, "deletions": 67}, "files": [{"sha": "15fdb0341cbbacd10d0ca06b4a54b267e9d6e1b9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8f92f11cdc713ddec4c60c66097d05c194bab2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8f92f11cdc713ddec4c60c66097d05c194bab2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6e8f92f11cdc713ddec4c60c66097d05c194bab2", "patch": "@@ -443,7 +443,7 @@ impl Collector {\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n             },\n-            testfn: testing::DynTestFn(box move|| {\n+            testfn: testing::DynTestFn(box move |()| {\n                 runtest(&test,\n                         &cratename,\n                         cfgs,"}, {"sha": "bb42351d3b7c8064def20b552b7a3edd8cbfc219", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6e8f92f11cdc713ddec4c60c66097d05c194bab2/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8f92f11cdc713ddec4c60c66097d05c194bab2/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6e8f92f11cdc713ddec4c60c66097d05c194bab2", "patch": "@@ -34,8 +34,6 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(asm)]\n-#![feature(box_syntax)]\n-#![feature(fnbox)]\n #![feature(libc)]\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n@@ -56,8 +54,7 @@ use self::TestEvent::*;\n use self::NamePadding::*;\n use self::OutputLocation::*;\n \n-use std::boxed::FnBox;\n-\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::any::Any;\n use std::cmp;\n use std::collections::BTreeMap;\n@@ -135,6 +132,16 @@ pub trait TDynBenchFn: Send {\n     fn run(&self, harness: &mut Bencher);\n }\n \n+pub trait FnBox<T>: Send + 'static {\n+    fn call_box(self: Box<Self>, t: T);\n+}\n+\n+impl<T, F: FnOnce(T) + Send + 'static> FnBox<T> for F {\n+    fn call_box(self: Box<F>, t: T) {\n+        (*self)(t)\n+    }\n+}\n+\n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function panics then the test fails. We\n // may need to come up with a more clever definition of test in order\n@@ -143,8 +150,8 @@ pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n     StaticMetricFn(fn(&mut MetricMap)),\n-    DynTestFn(Box<FnBox() + Send>),\n-    DynMetricFn(Box<FnBox(&mut MetricMap) + Send>),\n+    DynTestFn(Box<FnBox<()>>),\n+    DynMetricFn(Box<for<'a> FnBox<&'a mut MetricMap>>),\n     DynBenchFn(Box<TDynBenchFn + 'static>),\n }\n \n@@ -1137,23 +1144,25 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n \n pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     // convert benchmarks to tests, if we're not benchmarking them\n-    tests.into_iter()\n-         .map(|x| {\n-             let testfn = match x.testfn {\n-                 DynBenchFn(bench) => {\n-                     DynTestFn(Box::new(move || bench::run_once(|b| bench.run(b))))\n-                 }\n-                 StaticBenchFn(benchfn) => {\n-                     DynTestFn(Box::new(move || bench::run_once(|b| benchfn(b))))\n-                 }\n-                 f => f,\n-             };\n-             TestDescAndFn {\n-                 desc: x.desc,\n-                 testfn: testfn,\n-             }\n-         })\n-         .collect()\n+    tests.into_iter().map(|x| {\n+        let testfn = match x.testfn {\n+            DynBenchFn(bench) => {\n+                DynTestFn(Box::new(move |()| {\n+                    bench::run_once(|b| bench.run(b))\n+                }))\n+            }\n+            StaticBenchFn(benchfn) => {\n+                DynTestFn(Box::new(move |()| {\n+                    bench::run_once(|b| benchfn(b))\n+                }))\n+            }\n+            f => f,\n+        };\n+        TestDescAndFn {\n+            desc: x.desc,\n+            testfn: testfn,\n+        }\n+    }).collect()\n }\n \n pub fn run_test(opts: &TestOpts,\n@@ -1171,7 +1180,7 @@ pub fn run_test(opts: &TestOpts,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n-                      testfn: Box<FnBox() + Send>) {\n+                      testfn: Box<FnBox<()>>) {\n         struct Sink(Arc<Mutex<Vec<u8>>>);\n         impl Write for Sink {\n             fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n@@ -1182,48 +1191,23 @@ pub fn run_test(opts: &TestOpts,\n             }\n         }\n \n-        // If the platform is single-threaded we're just going to run\n-        // the test synchronously, regardless of the concurrency\n-        // level.\n-        let supports_threads = !cfg!(target_os = \"emscripten\");\n-\n         // Buffer for capturing standard I/O\n         let data = Arc::new(Mutex::new(Vec::new()));\n         let data2 = data.clone();\n \n-        if supports_threads {\n-            thread::spawn(move || {\n-                let cfg = thread::Builder::new().name(match desc.name {\n-                    DynTestName(ref name) => name.clone(),\n-                    StaticTestName(name) => name.to_owned(),\n-                });\n-\n-                let result_guard = cfg.spawn(move || {\n-                    if !nocapture {\n-                        io::set_print(Some(box Sink(data2.clone())));\n-                        io::set_panic(Some(box Sink(data2)));\n-                    }\n-                    testfn()\n-                })\n-                    .unwrap();\n-                let test_result = calc_result(&desc, result_guard.join());\n-                let stdout = data.lock().unwrap().to_vec();\n-                monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n-            });\n-        } else {\n+        let name = desc.name.clone();\n+        let runtest = move || {\n             let oldio = if !nocapture {\n                 Some((\n-                    io::set_print(Some(box Sink(data2.clone()))),\n-                    io::set_panic(Some(box Sink(data2)))\n+                    io::set_print(Some(Box::new(Sink(data2.clone())))),\n+                    io::set_panic(Some(Box::new(Sink(data2))))\n                 ))\n             } else {\n                 None\n             };\n \n-            use std::panic::{catch_unwind, AssertUnwindSafe};\n-\n             let result = catch_unwind(AssertUnwindSafe(|| {\n-                testfn()\n+                testfn.call_box(())\n             }));\n \n             if let Some((printio, panicio)) = oldio {\n@@ -1234,6 +1218,21 @@ pub fn run_test(opts: &TestOpts,\n             let test_result = calc_result(&desc, result);\n             let stdout = data.lock().unwrap().to_vec();\n             monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n+        };\n+\n+\n+        // If the platform is single-threaded we're just going to run\n+        // the test synchronously, regardless of the concurrency\n+        // level.\n+        let supports_threads = !cfg!(target_os = \"emscripten\");\n+        if supports_threads {\n+            let cfg = thread::Builder::new().name(match name {\n+                DynTestName(ref name) => name.clone(),\n+                StaticTestName(name) => name.to_owned(),\n+            });\n+            cfg.spawn(runtest).unwrap();\n+        } else {\n+            runtest();\n         }\n     }\n \n@@ -1250,7 +1249,7 @@ pub fn run_test(opts: &TestOpts,\n         }\n         DynMetricFn(f) => {\n             let mut mm = MetricMap::new();\n-            f.call_box((&mut mm,));\n+            f.call_box(&mut mm);\n             monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n             return;\n         }\n@@ -1261,7 +1260,8 @@ pub fn run_test(opts: &TestOpts,\n             return;\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, f),\n-        StaticTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(f)),\n+        StaticTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture,\n+                                          Box::new(move |()| f())),\n     }\n }\n \n@@ -1496,7 +1496,7 @@ mod tests {\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n             },\n-            testfn: DynTestFn(Box::new(move || f())),\n+            testfn: DynTestFn(Box::new(move |()| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1513,7 +1513,7 @@ mod tests {\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n             },\n-            testfn: DynTestFn(Box::new(move || f())),\n+            testfn: DynTestFn(Box::new(move |()| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1532,7 +1532,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes,\n             },\n-            testfn: DynTestFn(Box::new(move || f())),\n+            testfn: DynTestFn(Box::new(move |()| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1551,7 +1551,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n             },\n-            testfn: DynTestFn(Box::new(move || f())),\n+            testfn: DynTestFn(Box::new(move |()| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1570,7 +1570,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::YesWithMessage(\"foobar\"),\n             },\n-            testfn: DynTestFn(Box::new(move || f())),\n+            testfn: DynTestFn(Box::new(move |()| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1587,7 +1587,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes,\n             },\n-            testfn: DynTestFn(Box::new(move || f())),\n+            testfn: DynTestFn(Box::new(move |()| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1620,15 +1620,15 @@ mod tests {\n                                  ignore: true,\n                                  should_panic: ShouldPanic::No,\n                              },\n-                             testfn: DynTestFn(Box::new(move || {})),\n+                             testfn: DynTestFn(Box::new(move |()| {})),\n                          },\n                          TestDescAndFn {\n                              desc: TestDesc {\n                                  name: StaticTestName(\"2\"),\n                                  ignore: false,\n                                  should_panic: ShouldPanic::No,\n                              },\n-                             testfn: DynTestFn(Box::new(move || {})),\n+                             testfn: DynTestFn(Box::new(move |()| {})),\n                          }];\n         let filtered = filter_tests(&opts, tests);\n \n@@ -1661,7 +1661,7 @@ mod tests {\n                         ignore: false,\n                         should_panic: ShouldPanic::No,\n                     },\n-                    testfn: DynTestFn(Box::new(testfn)),\n+                    testfn: DynTestFn(Box::new(move |()| testfn())),\n                 };\n                 tests.push(test);\n             }"}, {"sha": "b81258bd6d70289c0cbae86b44ebf3caac203a8c", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e8f92f11cdc713ddec4c60c66097d05c194bab2/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e8f92f11cdc713ddec4c60c66097d05c194bab2/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=6e8f92f11cdc713ddec4c60c66097d05c194bab2", "patch": "@@ -464,7 +464,7 @@ pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName\n pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn {\n     let config = config.clone();\n     let testpaths = testpaths.clone();\n-    test::DynTestFn(Box::new(move || {\n+    test::DynTestFn(Box::new(move |()| {\n         runtest::run(config, &testpaths)\n     }))\n }"}]}