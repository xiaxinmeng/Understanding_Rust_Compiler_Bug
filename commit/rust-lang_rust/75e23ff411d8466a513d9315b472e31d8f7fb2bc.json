{"sha": "75e23ff411d8466a513d9315b472e31d8f7fb2bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZTIzZmY0MTFkODQ2NmE1MTNkOTMxNWI0NzJlMzFkOGY3ZmIyYmM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T09:11:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-28T09:11:04Z"}, "message": "Rollup merge of #62550 - Centril:rest-patterns, r=petrochenkov\n\nImplement RFC 2707 + Parser recovery for range patterns\n\nImplement https://github.com/rust-lang/rfcs/pull/2707.\n\n- Add a new basic syntactic pattern form `ast::PatKind::Rest` (parsed as `..` or `DOTDOT`) and simplify `ast::PatKind::{Slice, Tuple, TupleStruct}` as a result.\n\n- Lower `ast::PatKind::Rest` in combination with the aforementioned `PatKind` variants as well as `PatKind::Ident`. The HIR remains unchanged for now (may be advisable to make slight adjustments later).\n\n- Refactor `parser.rs` wrt. parsing sequences and lists of things in the process.\n\n- Add parser recovery for range patterns of form `X..`, `X..=`, `X...`, `..Y`, `..=Y`, and `...Y`.\n   This should make it easy to actually support these patterns semantically later if we so desire.\n\ncc https://github.com/rust-lang/rust/issues/62254\n\nr? @petrochenkov", "tree": {"sha": "3b93fc4df7148b5c22c0a0e036282c1a10092b2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b93fc4df7148b5c22c0a0e036282c1a10092b2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75e23ff411d8466a513d9315b472e31d8f7fb2bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdPWapCRBK7hj4Ov3rIwAAdHIIAJ6Cg+O3ereaXD/YkcdSR0Jc\naMhCA+i+bCweLsLxIuT2I6dUlNqYmLbER0ITih2dNithWfLzxtNk/qVLDM7kfvrU\nlG+LeHXiGX7uafCDg6G48BZmVBwJ0bpWl7rSQwXg/GbMOTgG79IuLtZpWRaGx4/O\nU2DgK6VT5bq5dlgWpcB4hU3vdryQrt3PTnN907NyHD3LGSlPjqh2vKZLxY01Klhy\neT93YeB+pQYbSt7FBADogpi1cLYxoThzTizjsZUMBS5vwPDu10i1B+SWvpoZgEM/\nkfS1YlcM9k33hsh0LnaKUzEHi9ozjJrytmfN3UJllcScvPptCMqKO3kKSjwqEHY=\n=ebau\n-----END PGP SIGNATURE-----\n", "payload": "tree 3b93fc4df7148b5c22c0a0e036282c1a10092b2a\nparent 9a239ef4ded03d155c72b68b5a2dd7aff013e141\nparent d33696fcb413e6768443626e78c5c4f23e413fc2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564305064 +0200\ncommitter GitHub <noreply@github.com> 1564305064 +0200\n\nRollup merge of #62550 - Centril:rest-patterns, r=petrochenkov\n\nImplement RFC 2707 + Parser recovery for range patterns\n\nImplement https://github.com/rust-lang/rfcs/pull/2707.\n\n- Add a new basic syntactic pattern form `ast::PatKind::Rest` (parsed as `..` or `DOTDOT`) and simplify `ast::PatKind::{Slice, Tuple, TupleStruct}` as a result.\n\n- Lower `ast::PatKind::Rest` in combination with the aforementioned `PatKind` variants as well as `PatKind::Ident`. The HIR remains unchanged for now (may be advisable to make slight adjustments later).\n\n- Refactor `parser.rs` wrt. parsing sequences and lists of things in the process.\n\n- Add parser recovery for range patterns of form `X..`, `X..=`, `X...`, `..Y`, `..=Y`, and `...Y`.\n   This should make it easy to actually support these patterns semantically later if we so desire.\n\ncc https://github.com/rust-lang/rust/issues/62254\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75e23ff411d8466a513d9315b472e31d8f7fb2bc", "html_url": "https://github.com/rust-lang/rust/commit/75e23ff411d8466a513d9315b472e31d8f7fb2bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75e23ff411d8466a513d9315b472e31d8f7fb2bc/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a239ef4ded03d155c72b68b5a2dd7aff013e141", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a239ef4ded03d155c72b68b5a2dd7aff013e141", "html_url": "https://github.com/rust-lang/rust/commit/9a239ef4ded03d155c72b68b5a2dd7aff013e141"}, {"sha": "d33696fcb413e6768443626e78c5c4f23e413fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33696fcb413e6768443626e78c5c4f23e413fc2", "html_url": "https://github.com/rust-lang/rust/commit/d33696fcb413e6768443626e78c5c4f23e413fc2"}], "stats": {"total": 2221, "additions": 1546, "deletions": 675}, "files": [{"sha": "cdb74495884a8e6e8d027992e147814ed44946ee", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -17,7 +17,7 @@ matched against that pattern. For example:\n fn is_symmetric(list: &[u32]) -> bool {\n     match list {\n         &[] | &[_] => true,\n-        &[x, ref inside.., y] if x == y => is_symmetric(inside),\n+        &[x, ref inside @ .., y] if x == y => is_symmetric(inside),\n         &[..] => false,\n     }\n }"}, {"sha": "7121f87d79d9567356fc091d97fbcbe4c007be9d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 161, "deletions": 39, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -58,6 +58,7 @@ use std::mem;\n use smallvec::SmallVec;\n use syntax::attr;\n use syntax::ast;\n+use syntax::ptr::P as AstP;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::ExpnId;\n@@ -467,7 +468,7 @@ impl<'a> LoweringContext<'a> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n                 match p.node {\n                     // Doesn't generate a HIR node\n-                    PatKind::Paren(..) => {},\n+                    PatKind::Paren(..) | PatKind::Rest => {},\n                     _ => {\n                         if let Some(owner) = self.hir_id_owner {\n                             self.lctx.lower_node_id_with_owner(p.id, owner);\n@@ -1156,7 +1157,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         capture_clause: CaptureBy,\n         closure_node_id: NodeId,\n-        ret_ty: Option<syntax::ptr::P<Ty>>,\n+        ret_ty: Option<AstP<Ty>>,\n         span: Span,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n@@ -4171,45 +4172,20 @@ impl<'a> LoweringContext<'a> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n-                    // `None` can occur in body-less function signatures\n-                    res @ None | res @ Some(Res::Local(_)) => {\n-                        let canonical_id = match res {\n-                            Some(Res::Local(id)) => id,\n-                            _ => p.id,\n-                        };\n-\n-                        hir::PatKind::Binding(\n-                            self.lower_binding_mode(binding_mode),\n-                            self.lower_node_id(canonical_id),\n-                            ident,\n-                            sub.as_ref().map(|x| self.lower_pat(x)),\n-                        )\n-                    }\n-                    Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n-                        None,\n-                        P(hir::Path {\n-                            span: ident.span,\n-                            res: self.lower_res(res),\n-                            segments: hir_vec![hir::PathSegment::from_ident(ident)],\n-                        }),\n-                    )),\n-                }\n+                let lower_sub = |this: &mut Self| sub.as_ref().map(|x| this.lower_pat(x));\n+                self.lower_pat_ident(p, binding_mode, ident, lower_sub)\n             }\n             PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n-            PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n+            PatKind::TupleStruct(ref path, ref pats) => {\n                 let qpath = self.lower_qpath(\n                     p.id,\n                     &None,\n                     path,\n                     ParamMode::Optional,\n                     ImplTraitContext::disallowed(),\n                 );\n-                hir::PatKind::TupleStruct(\n-                    qpath,\n-                    pats.iter().map(|x| self.lower_pat(x)).collect(),\n-                    ddpos,\n-                )\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                hir::PatKind::TupleStruct(qpath, pats, ddpos)\n             }\n             PatKind::Path(ref qself, ref path) => {\n                 let qpath = self.lower_qpath(\n@@ -4246,8 +4222,9 @@ impl<'a> LoweringContext<'a> {\n                     .collect();\n                 hir::PatKind::Struct(qpath, fs, etc)\n             }\n-            PatKind::Tuple(ref elts, ddpos) => {\n-                hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+            PatKind::Tuple(ref pats) => {\n+                let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                hir::PatKind::Tuple(pats, ddpos)\n             }\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n             PatKind::Ref(ref inner, mutbl) => {\n@@ -4258,22 +4235,167 @@ impl<'a> LoweringContext<'a> {\n                 P(self.lower_expr(e2)),\n                 self.lower_range_end(end),\n             ),\n-            PatKind::Slice(ref before, ref slice, ref after) => hir::PatKind::Slice(\n-                before.iter().map(|x| self.lower_pat(x)).collect(),\n-                slice.as_ref().map(|x| self.lower_pat(x)),\n-                after.iter().map(|x| self.lower_pat(x)).collect(),\n-            ),\n+            PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n+            PatKind::Rest => {\n+                // If we reach here the `..` pattern is not semantically allowed.\n+                self.ban_illegal_rest_pat(p.span)\n+            }\n             PatKind::Paren(ref inner) => return self.lower_pat(inner),\n             PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n+        self.pat_with_node_id_of(p, node)\n+    }\n+\n+    fn lower_pat_tuple(\n+        &mut self,\n+        pats: &[AstP<Pat>],\n+        ctx: &str,\n+    ) -> (HirVec<P<hir::Pat>>, Option<usize>) {\n+        let mut elems = Vec::with_capacity(pats.len());\n+        let mut rest = None;\n+\n+        let mut iter = pats.iter().enumerate();\n+        while let Some((idx, pat)) = iter.next() {\n+            // Interpret the first `..` pattern as a subtuple pattern.\n+            if pat.is_rest() {\n+                rest = Some((idx, pat.span));\n+                break;\n+            }\n+            // It was not a subslice pattern so lower it normally.\n+            elems.push(self.lower_pat(pat));\n+        }\n+\n+        while let Some((_, pat)) = iter.next() {\n+            // There was a previous subtuple pattern; make sure we don't allow more.\n+            if pat.is_rest() {\n+                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n+            } else {\n+                elems.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        (elems.into(), rest.map(|(ddpos, _)| ddpos))\n+    }\n+\n+    fn lower_pat_slice(&mut self, pats: &[AstP<Pat>]) -> hir::PatKind {\n+        let mut before = Vec::new();\n+        let mut after = Vec::new();\n+        let mut slice = None;\n+        let mut prev_rest_span = None;\n+\n+        let mut iter = pats.iter();\n+        while let Some(pat) = iter.next() {\n+            // Interpret the first `((ref mut?)? x @)? ..` pattern as a subslice pattern.\n+            match pat.node {\n+                PatKind::Rest => {\n+                    prev_rest_span = Some(pat.span);\n+                    slice = Some(self.pat_wild_with_node_id_of(pat));\n+                    break;\n+                },\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    prev_rest_span = Some(sub.span);\n+                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n+                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n+                    slice = Some(self.pat_with_node_id_of(pat, node));\n+                    break;\n+                },\n+                _ => {}\n+            }\n+\n+            // It was not a subslice pattern so lower it normally.\n+            before.push(self.lower_pat(pat));\n+        }\n+\n+        while let Some(pat) = iter.next() {\n+            // There was a previous subslice pattern; make sure we don't allow more.\n+            let rest_span = match pat.node {\n+                PatKind::Rest => Some(pat.span),\n+                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n+                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n+                    after.push(self.pat_wild_with_node_id_of(pat));\n+                    Some(sub.span)\n+                },\n+                _ => None,\n+            };\n+            if let Some(rest_span) = rest_span {\n+                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n+            } else {\n+                after.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        hir::PatKind::Slice(before.into(), slice, after.into())\n+    }\n+\n+    fn lower_pat_ident(\n+        &mut self,\n+        p: &Pat,\n+        binding_mode: &BindingMode,\n+        ident: Ident,\n+        lower_sub: impl FnOnce(&mut Self) -> Option<P<hir::Pat>>,\n+    ) -> hir::PatKind {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+            // `None` can occur in body-less function signatures\n+            res @ None | res @ Some(Res::Local(_)) => {\n+                let canonical_id = match res {\n+                    Some(Res::Local(id)) => id,\n+                    _ => p.id,\n+                };\n+\n+                hir::PatKind::Binding(\n+                    self.lower_binding_mode(binding_mode),\n+                    self.lower_node_id(canonical_id),\n+                    ident,\n+                    lower_sub(self),\n+                )\n+            }\n+            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                P(hir::Path {\n+                    span: ident.span,\n+                    res: self.lower_res(res),\n+                    segments: hir_vec![hir::PathSegment::from_ident(ident)],\n+                }),\n+            )),\n+        }\n+    }\n+\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> P<hir::Pat> {\n+        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n+    }\n+\n+    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n+    fn pat_with_node_id_of(&mut self, p: &Pat, node: hir::PatKind) -> P<hir::Pat> {\n         P(hir::Pat {\n             hir_id: self.lower_node_id(p.id),\n             node,\n             span: p.span,\n         })\n     }\n \n+    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n+    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+        self.diagnostic()\n+            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n+            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n+            .span_label(prev_sp, \"previously used here\")\n+            .emit();\n+    }\n+\n+    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n+    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind {\n+        self.diagnostic()\n+            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n+            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n+            .emit();\n+\n+        // We're not in a list context so `..` can be reasonably treated\n+        // as `_` because it should always be valid and roughly matches the\n+        // intent of `..` (notice that the rest of a single slot is that slot).\n+        hir::PatKind::Wild\n+    }\n+\n     fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n         match *e {\n             RangeEnd::Included(_) => hir::RangeEnd::Included,"}, {"sha": "f759ec7f219d12d68ec5b8cb80d79548111b7937", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -162,7 +162,7 @@ pub enum PatternKind<'tcx> {\n \n     /// Matches against a slice, checking the length and extracting elements.\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n-    /// e.g., `&[ref xs..]`.\n+    /// e.g., `&[ref xs @ ..]`.\n     Slice {\n         prefix: Vec<Pattern<'tcx>>,\n         slice: Option<Pattern<'tcx>>,"}, {"sha": "7ad37e65f7178a324dbafa825289f18d16aeb052", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -287,7 +287,7 @@ impl<'a> AstValidator<'a> {\n     // ```\n     fn check_expr_within_pat(&self, expr: &Expr, allow_paths: bool) {\n         match expr.node {\n-            ExprKind::Lit(..) => {}\n+            ExprKind::Lit(..) | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner)\n                 if match inner.node { ExprKind::Lit(_) => true, _ => false } => {}"}, {"sha": "80fcb45d0b9bc0157347b90a80c8c745120767d5", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -105,20 +105,34 @@ impl TargetDataLayout {\n         let mut dl = TargetDataLayout::default();\n         let mut i128_align_src = 64;\n         for spec in target.data_layout.split('-') {\n-            match spec.split(':').collect::<Vec<_>>()[..] {\n+            let spec_parts = spec.split(':').collect::<Vec<_>>();\n+\n+            match &*spec_parts {\n                 [\"e\"] => dl.endian = Endian::Little,\n                 [\"E\"] => dl.endian = Endian::Big,\n                 [p] if p.starts_with(\"P\") => {\n                     dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n                 }\n-                [\"a\", ref a..] => dl.aggregate_align = align(a, \"a\")?,\n-                [\"f32\", ref a..] => dl.f32_align = align(a, \"f32\")?,\n-                [\"f64\", ref a..] => dl.f64_align = align(a, \"f64\")?,\n-                [p @ \"p\", s, ref a..] | [p @ \"p0\", s, ref a..] => {\n+                // FIXME: Ping cfg(bootstrap) -- Use `ref a @ ..` with new bootstrap compiler.\n+                [\"a\", ..] => {\n+                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                    dl.aggregate_align = align(a, \"a\")?\n+                }\n+                [\"f32\", ..] => {\n+                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                    dl.f32_align = align(a, \"f32\")?\n+                }\n+                [\"f64\", ..] => {\n+                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n+                    dl.f64_align = align(a, \"f64\")?\n+                }\n+                [p @ \"p\", s, ..] | [p @ \"p0\", s, ..] => {\n+                    let a = &spec_parts[2..]; // FIXME inline into pattern.\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n                 }\n-                [s, ref a..] if s.starts_with(\"i\") => {\n+                [s, ..] if s.starts_with(\"i\") => {\n+                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n                     let bits = match s[1..].parse::<u64>() {\n                         Ok(bits) => bits,\n                         Err(_) => {\n@@ -142,7 +156,8 @@ impl TargetDataLayout {\n                         dl.i128_align = a;\n                     }\n                 }\n-                [s, ref a..] if s.starts_with(\"v\") => {\n+                [s, ..] if s.starts_with(\"v\") => {\n+                    let a = &spec_parts[1..]; // FIXME inline into pattern.\n                     let v_size = size(&s[1..], \"v\")?;\n                     let a = align(a, s)?;\n                     if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {"}, {"sha": "defa6fe4ce15e7f31c5e9ad2f5aff48b1b337bc7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -196,7 +196,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let rhs_ty = self.check_expr(end);\n \n                 // Check that both end-points are of numeric or char type.\n-                let numeric_or_char = |ty: Ty<'_>| ty.is_numeric() || ty.is_char();\n+                let numeric_or_char = |ty: Ty<'_>| {\n+                    ty.is_numeric()\n+                    || ty.is_char()\n+                    || ty.references_error()\n+                };\n                 let lhs_compat = numeric_or_char(lhs_ty);\n                 let rhs_compat = numeric_or_char(rhs_ty);\n "}, {"sha": "66c726b2485d17ae825445d83b7d1b42db6a25a1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1818,7 +1818,9 @@ fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, d\n     );\n     let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n     err.span_label(sp, &msg);\n-    if let &[ref start.., ref end] = &variant_spans[..] {\n+    if let &[.., ref end] = &variant_spans[..] {\n+        // FIXME: Ping cfg(bootstrap) -- Use `ref start @ ..` with new bootstrap compiler.\n+        let start = &variant_spans[..variant_spans.len() - 1];\n         for variant_span in start {\n             err.span_label(*variant_span, \"\");\n         }"}, {"sha": "b4c856921198eedcf9a912695ffbfba6efacb8cb", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -3497,8 +3497,8 @@ Example of erroneous code:\n \n let r = &[1, 2];\n match r {\n-    &[a, b, c, rest..] => { // error: pattern requires at least 3\n-                            //        elements but array has 2\n+    &[a, b, c, rest @ ..] => { // error: pattern requires at least 3\n+                               //        elements but array has 2\n         println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n     }\n }\n@@ -3512,7 +3512,7 @@ requires. You can match an arbitrary number of remaining elements with `..`:\n \n let r = &[1, 2, 3, 4, 5];\n match r {\n-    &[a, b, c, rest..] => { // ok!\n+    &[a, b, c, rest @ ..] => { // ok!\n         // prints `a=1, b=2, c=3 rest=[4, 5]`\n         println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n     }"}, {"sha": "a7453f4f9dac2b8d389c4134bce1b5bdf5ae67f5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -519,21 +519,28 @@ impl fmt::Debug for Pat {\n }\n \n impl Pat {\n+    /// Attempt reparsing the pattern as a type.\n+    /// This is intended for use by diagnostics.\n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n         let node = match &self.node {\n+            // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n+            // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n             PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) => {\n                 TyKind::Path(None, Path::from_ident(*ident))\n             }\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             PatKind::Mac(mac) => TyKind::Mac(mac.clone()),\n+            // `&mut? P` can be reinterpreted as `&mut? T` where `T` is `P` reparsed as a type.\n             PatKind::Ref(pat, mutbl) => pat\n                 .to_ty()\n                 .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n-            PatKind::Slice(pats, None, _) if pats.len() == 1 => {\n-                pats[0].to_ty().map(TyKind::Slice)?\n-            }\n-            PatKind::Tuple(pats, None) => {\n+            // A slice/array pattern `[P]` can be reparsed as `[T]`, an unsized array,\n+            // when `P` can be reparsed as a type `T`.\n+            PatKind::Slice(pats) if pats.len() == 1 => pats[0].to_ty().map(TyKind::Slice)?,\n+            // A tuple pattern `(P0, .., Pn)` can be reparsed as `(T0, .., Tn)`\n+            // assuming `T0` to `Tn` are all syntactically valid as types.\n+            PatKind::Tuple(pats) => {\n                 let mut tys = Vec::with_capacity(pats.len());\n                 // FIXME(#48994) - could just be collected into an Option<Vec>\n                 for pat in pats {\n@@ -559,26 +566,30 @@ impl Pat {\n             return false;\n         }\n \n-        match self.node {\n-            PatKind::Ident(_, _, Some(ref p)) => p.walk(it),\n-            PatKind::Struct(_, ref fields, _) => fields.iter().all(|field| field.node.pat.walk(it)),\n-            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n+        match &self.node {\n+            PatKind::Ident(_, _, Some(p)) => p.walk(it),\n+            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.node.pat.walk(it)),\n+            PatKind::TupleStruct(_, s) | PatKind::Tuple(s) | PatKind::Slice(s) => {\n                 s.iter().all(|p| p.walk(it))\n             }\n-            PatKind::Box(ref s) | PatKind::Ref(ref s, _) | PatKind::Paren(ref s) => s.walk(it),\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n-                before.iter().all(|p| p.walk(it))\n-                    && slice.iter().all(|p| p.walk(it))\n-                    && after.iter().all(|p| p.walk(it))\n-            }\n+            PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n             PatKind::Wild\n+            | PatKind::Rest\n             | PatKind::Lit(_)\n             | PatKind::Range(..)\n             | PatKind::Ident(..)\n             | PatKind::Path(..)\n             | PatKind::Mac(_) => true,\n         }\n     }\n+\n+    /// Is this a `..` pattern?\n+    pub fn is_rest(&self) -> bool {\n+        match self.node {\n+            PatKind::Rest => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// A single field in a struct pattern\n@@ -630,9 +641,7 @@ pub enum PatKind {\n     Struct(Path, Vec<Spanned<FieldPat>>, /* recovered */ bool),\n \n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n-    /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// `0 <= position <= subpats.len()`.\n-    TupleStruct(Path, Vec<P<Pat>>, Option<usize>),\n+    TupleStruct(Path, Vec<P<Pat>>),\n \n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n@@ -641,9 +650,7 @@ pub enum PatKind {\n     Path(Option<QSelf>, Path),\n \n     /// A tuple pattern (`(a, b)`).\n-    /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// `0 <= position <= subpats.len()`.\n-    Tuple(Vec<P<Pat>>, Option<usize>),\n+    Tuple(Vec<P<Pat>>),\n \n     /// A `box` pattern.\n     Box(P<Pat>),\n@@ -657,9 +664,22 @@ pub enum PatKind {\n     /// A range pattern (e.g., `1...2`, `1..=2` or `1..2`).\n     Range(P<Expr>, P<Expr>, Spanned<RangeEnd>),\n \n-    /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n-    Slice(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    /// A slice pattern `[a, b, c]`.\n+    Slice(Vec<P<Pat>>),\n+\n+    /// A rest pattern `..`.\n+    ///\n+    /// Syntactically it is valid anywhere.\n+    ///\n+    /// Semantically however, it only has meaning immediately inside:\n+    /// - a slice pattern: `[a, .., b]`,\n+    /// - a binding pattern immediately inside a slice pattern: `[a, r @ ..]`,\n+    /// - a tuple pattern: `(a, .., b)`,\n+    /// - a tuple struct/variant pattern: `$path(a, .., b)`.\n+    ///\n+    /// In all of these cases, an additional restriction applies,\n+    /// only one rest pattern may occur in the pattern sequences.\n+    Rest,\n \n     /// Parentheses in patterns used for grouping (i.e., `(PAT)`).\n     Paren(P<Pat>),"}, {"sha": "528b27d6153df2f2e8c655e046f8e937b55f73f6", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -840,14 +840,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n     fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n                         subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        self.pat(span, PatKind::TupleStruct(path, subpats, None))\n+        self.pat(span, PatKind::TupleStruct(path, subpats))\n     }\n     fn pat_struct(&self, span: Span, path: ast::Path,\n                   field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Struct(path, field_pats, false))\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        self.pat(span, PatKind::Tuple(pats, None))\n+        self.pat(span, PatKind::Tuple(pats))\n     }\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "384474b08f6ee28a33c46bc66b2179693f258de5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -2151,11 +2151,23 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n-        match pattern.node {\n-            PatKind::Slice(_, Some(ref subslice), _) => {\n-                gate_feature_post!(&self, slice_patterns,\n-                                   subslice.span,\n-                                   \"syntax for subslices in slice patterns is not yet stabilized\");\n+        match &pattern.node {\n+            PatKind::Slice(pats) => {\n+                for pat in &*pats {\n+                    let span = pat.span;\n+                    let inner_pat = match &pat.node {\n+                        PatKind::Ident(.., Some(pat)) => pat,\n+                        _ => pat,\n+                    };\n+                    if inner_pat.is_rest() {\n+                        gate_feature_post!(\n+                            &self,\n+                            slice_patterns,\n+                            span,\n+                            \"subslice patterns are unstable\"\n+                        );\n+                    }\n+                }\n             }\n             PatKind::Box(..) => {\n                 gate_feature_post!(&self, box_patterns,"}, {"sha": "86525406718b6993ea4acb47dcfbade5dcfeb6bc", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1020,15 +1020,15 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n     let Pat { id, node, span } = pat.deref_mut();\n     vis.visit_id(id);\n     match node {\n-        PatKind::Wild => {}\n+        PatKind::Wild | PatKind::Rest => {}\n         PatKind::Ident(_binding_mode, ident, sub) => {\n             vis.visit_ident(ident);\n             visit_opt(sub, |sub| vis.visit_pat(sub));\n         }\n         PatKind::Lit(e) => vis.visit_expr(e),\n-        PatKind::TupleStruct(path, pats, _ddpos) => {\n+        PatKind::TupleStruct(path, elems) => {\n             vis.visit_path(path);\n-            visit_vec(pats, |pat| vis.visit_pat(pat));\n+            visit_vec(elems, |elem| vis.visit_pat(elem));\n         }\n         PatKind::Path(qself, path) => {\n             vis.visit_qself(qself);\n@@ -1043,19 +1043,15 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n                 vis.visit_span(span);\n             };\n         }\n-        PatKind::Tuple(elts, _ddpos) => visit_vec(elts, |elt| vis.visit_pat(elt)),\n+        PatKind::Tuple(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Box(inner) => vis.visit_pat(inner),\n         PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n         PatKind::Range(e1, e2, Spanned { span: _, node: _ }) => {\n             vis.visit_expr(e1);\n             vis.visit_expr(e2);\n             vis.visit_span(span);\n         }\n-        PatKind::Slice(before, slice, after) => {\n-            visit_vec(before, |pat| vis.visit_pat(pat));\n-            visit_opt(slice, |slice| vis.visit_pat(slice));\n-            visit_vec(after, |pat| vis.visit_pat(pat));\n-        }\n+        PatKind::Slice(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::Mac(mac) => vis.visit_mac(mac),\n     }"}, {"sha": "8f8ed4111808da3a5d1424b772e2f9636f74f8ab", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 235, "deletions": 290, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -890,14 +890,13 @@ impl<'a> Parser<'a> {\n     /// Parses a sequence, including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_end<T, F>(&mut self,\n-                                  ket: &TokenKind,\n-                                  sep: SeqSep,\n-                                  f: F)\n-                                  -> PResult<'a, Vec<T>> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n-    {\n-        let (val, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n+    pub fn parse_seq_to_end<T>(\n+        &mut self,\n+        ket: &TokenKind,\n+        sep: SeqSep,\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+    ) -> PResult<'a, Vec<T>> {\n+        let (val, _, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n         if !recovered {\n             self.bump();\n         }\n@@ -907,39 +906,39 @@ impl<'a> Parser<'a> {\n     /// Parses a sequence, not including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_before_end<T, F>(\n+    pub fn parse_seq_to_before_end<T>(\n         &mut self,\n         ket: &TokenKind,\n         sep: SeqSep,\n-        f: F,\n-    ) -> PResult<'a, (Vec<T>, bool)>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>\n-    {\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    ) -> PResult<'a, (Vec<T>, bool, bool)> {\n         self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n     }\n \n-    crate fn parse_seq_to_before_tokens<T, F>(\n+    fn expect_any_with_type(&mut self, kets: &[&TokenKind], expect: TokenExpectType) -> bool {\n+        kets.iter().any(|k| {\n+            match expect {\n+                TokenExpectType::Expect => self.check(k),\n+                TokenExpectType::NoExpect => self.token == **k,\n+            }\n+        })\n+    }\n+\n+    crate fn parse_seq_to_before_tokens<T>(\n         &mut self,\n         kets: &[&TokenKind],\n         sep: SeqSep,\n         expect: TokenExpectType,\n-        mut f: F,\n-    ) -> PResult<'a, (Vec<T>, bool /* recovered */)>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>\n-    {\n+        mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    ) -> PResult<'a, (Vec<T>, bool /* trailing */, bool /* recovered */)> {\n         let mut first = true;\n         let mut recovered = false;\n+        let mut trailing = false;\n         let mut v = vec![];\n-        while !kets.iter().any(|k| {\n-                match expect {\n-                    TokenExpectType::Expect => self.check(k),\n-                    TokenExpectType::NoExpect => self.token == **k,\n-                }\n-            }) {\n-            match self.token.kind {\n-                token::CloseDelim(..) | token::Eof => break,\n-                _ => {}\n-            };\n+        while !self.expect_any_with_type(kets, expect) {\n+            if let token::CloseDelim(..) | token::Eof = self.token.kind {\n+                break\n+            }\n             if let Some(ref t) = sep.sep {\n                 if first {\n                     first = false;\n@@ -973,40 +972,54 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n             }\n-            if sep.trailing_sep_allowed && kets.iter().any(|k| {\n-                match expect {\n-                    TokenExpectType::Expect => self.check(k),\n-                    TokenExpectType::NoExpect => self.token == **k,\n-                }\n-            }) {\n+            if sep.trailing_sep_allowed && self.expect_any_with_type(kets, expect) {\n+                trailing = true;\n                 break;\n             }\n \n             let t = f(self)?;\n             v.push(t);\n         }\n \n-        Ok((v, recovered))\n+        Ok((v, trailing, recovered))\n     }\n \n     /// Parses a sequence, including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    fn parse_unspanned_seq<T, F>(\n+    fn parse_unspanned_seq<T>(\n         &mut self,\n         bra: &TokenKind,\n         ket: &TokenKind,\n         sep: SeqSep,\n-        f: F,\n-    ) -> PResult<'a, Vec<T>> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n-    {\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    ) -> PResult<'a, (Vec<T>, bool)> {\n         self.expect(bra)?;\n-        let (result, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n+        let (result, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n         if !recovered {\n             self.eat(ket);\n         }\n-        Ok(result)\n+        Ok((result, trailing))\n+    }\n+\n+    fn parse_delim_comma_seq<T>(\n+        &mut self,\n+        delim: DelimToken,\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    ) -> PResult<'a, (Vec<T>, bool)> {\n+        self.parse_unspanned_seq(\n+            &token::OpenDelim(delim),\n+            &token::CloseDelim(delim),\n+            SeqSep::trailing_allowed(token::Comma),\n+            f,\n+        )\n+    }\n+\n+    fn parse_paren_comma_seq<T>(\n+        &mut self,\n+        f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n+    ) -> PResult<'a, (Vec<T>, bool)> {\n+        self.parse_delim_comma_seq(token::Paren, f)\n     }\n \n     /// Advance the parser by one token\n@@ -1804,15 +1817,7 @@ impl<'a> Parser<'a> {\n                 AngleBracketedArgs { args, constraints, span }.into()\n             } else {\n                 // `(T, U) -> R`\n-                self.bump(); // `(`\n-                let (inputs, recovered) = self.parse_seq_to_before_tokens(\n-                    &[&token::CloseDelim(token::Paren)],\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    TokenExpectType::Expect,\n-                    |p| p.parse_ty())?;\n-                if !recovered {\n-                    self.bump(); // `)`\n-                }\n+                let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n                 let span = lo.to(self.prev_span);\n                 let output = if self.eat(&token::RArrow) {\n                     Some(self.parse_ty_common(false, false, false)?)\n@@ -2516,12 +2521,7 @@ impl<'a> Parser<'a> {\n         Ok(match self.token.kind {\n             token::OpenDelim(token::Paren) => {\n                 // Method call `expr.f()`\n-                let mut args = self.parse_unspanned_seq(\n-                    &token::OpenDelim(token::Paren),\n-                    &token::CloseDelim(token::Paren),\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    |p| Ok(p.parse_expr()?)\n-                )?;\n+                let mut args = self.parse_paren_expr_seq()?;\n                 args.insert(0, self_arg);\n \n                 let span = lo.to(self.prev_span);\n@@ -2606,12 +2606,7 @@ impl<'a> Parser<'a> {\n             match self.token.kind {\n                 // expr(...)\n                 token::OpenDelim(token::Paren) => {\n-                    let seq = self.parse_unspanned_seq(\n-                        &token::OpenDelim(token::Paren),\n-                        &token::CloseDelim(token::Paren),\n-                        SeqSep::trailing_allowed(token::Comma),\n-                        |p| Ok(p.parse_expr()?)\n-                    ).map(|es| {\n+                    let seq = self.parse_paren_expr_seq().map(|es| {\n                         let nd = self.mk_call(e, es);\n                         let hi = self.prev_span;\n                         self.mk_expr(lo.to(hi), nd, ThinVec::new())\n@@ -2635,6 +2630,10 @@ impl<'a> Parser<'a> {\n         return Ok(e);\n     }\n \n+    fn parse_paren_expr_seq(&mut self) -> PResult<'a, Vec<P<Expr>>> {\n+        self.parse_paren_comma_seq(|p| p.parse_expr()).map(|(r, _)| r)\n+    }\n+\n     crate fn process_potential_macro_variable(&mut self) {\n         self.token = match self.token.kind {\n             token::Dollar if self.token.span.ctxt() != SyntaxContext::empty() &&\n@@ -3536,122 +3535,6 @@ impl<'a> Parser<'a> {\n         };\n     }\n \n-    // Parses a parenthesized list of patterns like\n-    // `()`, `(p)`, `(p,)`, `(p, q)`, or `(p, .., q)`. Returns:\n-    // - a vector of the patterns that were parsed\n-    // - an option indicating the index of the `..` element\n-    // - a boolean indicating whether a trailing comma was present.\n-    // Trailing commas are significant because (p) and (p,) are different patterns.\n-    fn parse_parenthesized_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-        let result = match self.parse_pat_list() {\n-            Ok(result) => result,\n-            Err(mut err) => { // recover from parse error in tuple pattern list\n-                err.emit();\n-                self.consume_block(token::Paren);\n-                return Ok((vec![], Some(0), false));\n-            }\n-        };\n-        self.expect(&token::CloseDelim(token::Paren))?;\n-        Ok(result)\n-    }\n-\n-    fn parse_pat_list(&mut self) -> PResult<'a, (Vec<P<Pat>>, Option<usize>, bool)> {\n-        let mut fields = Vec::new();\n-        let mut ddpos = None;\n-        let mut prev_dd_sp = None;\n-        let mut trailing_comma = false;\n-        loop {\n-            if self.eat(&token::DotDot) {\n-                if ddpos.is_none() {\n-                    ddpos = Some(fields.len());\n-                    prev_dd_sp = Some(self.prev_span);\n-                } else {\n-                    // Emit a friendly error, ignore `..` and continue parsing\n-                    let mut err = self.struct_span_err(\n-                        self.prev_span,\n-                        \"`..` can only be used once per tuple or tuple struct pattern\",\n-                    );\n-                    err.span_label(self.prev_span, \"can only be used once per pattern\");\n-                    if let Some(sp) = prev_dd_sp {\n-                        err.span_label(sp, \"previously present here\");\n-                    }\n-                    err.emit();\n-                }\n-            } else if !self.check(&token::CloseDelim(token::Paren)) {\n-                fields.push(self.parse_pat(None)?);\n-            } else {\n-                break\n-            }\n-\n-            trailing_comma = self.eat(&token::Comma);\n-            if !trailing_comma {\n-                break\n-            }\n-        }\n-\n-        if ddpos == Some(fields.len()) && trailing_comma {\n-            // `..` needs to be followed by `)` or `, pat`, `..,)` is disallowed.\n-            let msg = \"trailing comma is not permitted after `..`\";\n-            self.struct_span_err(self.prev_span, msg)\n-                .span_label(self.prev_span, msg)\n-                .emit();\n-        }\n-\n-        Ok((fields, ddpos, trailing_comma))\n-    }\n-\n-    fn parse_pat_vec_elements(\n-        &mut self,\n-    ) -> PResult<'a, (Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>)> {\n-        let mut before = Vec::new();\n-        let mut slice = None;\n-        let mut after = Vec::new();\n-        let mut first = true;\n-        let mut before_slice = true;\n-\n-        while self.token != token::CloseDelim(token::Bracket) {\n-            if first {\n-                first = false;\n-            } else {\n-                self.expect(&token::Comma)?;\n-\n-                if self.token == token::CloseDelim(token::Bracket)\n-                        && (before_slice || !after.is_empty()) {\n-                    break\n-                }\n-            }\n-\n-            if before_slice {\n-                if self.eat(&token::DotDot) {\n-\n-                    if self.check(&token::Comma) ||\n-                            self.check(&token::CloseDelim(token::Bracket)) {\n-                        slice = Some(P(Pat {\n-                            id: ast::DUMMY_NODE_ID,\n-                            node: PatKind::Wild,\n-                            span: self.prev_span,\n-                        }));\n-                        before_slice = false;\n-                    }\n-                    continue\n-                }\n-            }\n-\n-            let subpat = self.parse_pat(None)?;\n-            if before_slice && self.eat(&token::DotDot) {\n-                slice = Some(subpat);\n-                before_slice = false;\n-            } else if before_slice {\n-                before.push(subpat);\n-            } else {\n-                after.push(subpat);\n-            }\n-        }\n-\n-        Ok((before, slice, after))\n-    }\n-\n     fn parse_pat_field(\n         &mut self,\n         lo: Span,\n@@ -3847,20 +3730,34 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    // helper function to decide whether to parse as ident binding or to try to do\n-    // something more complex like range patterns\n+    /// Is the current token suitable as the start of a range patterns end?\n+    fn is_pat_range_end_start(&self) -> bool {\n+        self.token.is_path_start() // e.g. `MY_CONST`;\n+            || self.token == token::Dot // e.g. `.5` for recovery;\n+            || self.token.can_begin_literal_or_bool() // e.g. `42`.\n+    }\n+\n+    // Helper function to decide whether to parse as ident binding\n+    // or to try to do something more complex like range patterns.\n     fn parse_as_ident(&mut self) -> bool {\n         self.look_ahead(1, |t| match t.kind {\n             token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n-            token::DotDotDot | token::DotDotEq | token::ModSep | token::Not => Some(false),\n-            // ensure slice patterns [a, b.., c] and [a, b, c..] don't go into the\n-            // range pattern branch\n-            token::DotDot => None,\n-            _ => Some(true),\n-        }).unwrap_or_else(|| self.look_ahead(2, |t| match t.kind {\n-            token::Comma | token::CloseDelim(token::Bracket) => true,\n-            _ => false,\n-        }))\n+            token::DotDotDot | token::DotDotEq | token::DotDot |\n+            token::ModSep | token::Not => false,\n+            _ => true,\n+        })\n+    }\n+\n+    /// Parse and throw away a parentesized comma separated\n+    /// sequence of patterns until `)` is reached.\n+    fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n+        while !self.check(&token::CloseDelim(token::Paren)) {\n+            self.parse_pat(None)?;\n+            if !self.eat(&token::Comma) {\n+                return Ok(())\n+            }\n+        }\n+        Ok(())\n     }\n \n     /// A wrapper around `parse_pat` with some special error handling for the\n@@ -3876,7 +3773,7 @@ impl<'a> Parser<'a> {\n             // later.\n             let comma_span = self.token.span;\n             self.bump();\n-            if let Err(mut err) = self.parse_pat_list() {\n+            if let Err(mut err) = self.skip_pat_list() {\n                 // We didn't expect this to work anyway; we just wanted\n                 // to advance to the end of the comma-sequence so we know\n                 // the span to suggest parenthesizing\n@@ -3908,6 +3805,53 @@ impl<'a> Parser<'a> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n+    /// Parse a range-to pattern, e.g. `..X` and `..=X` for recovery.\n+    fn parse_pat_range_to(&mut self, re: RangeEnd, form: &str) -> PResult<'a, PatKind> {\n+        let lo = self.prev_span;\n+        let end = self.parse_pat_range_end()?;\n+        let range_span = lo.to(end.span);\n+        let begin = self.mk_expr(range_span, ExprKind::Err, ThinVec::new());\n+\n+        self.diagnostic()\n+            .struct_span_err(range_span, &format!(\"`{}X` range patterns are not supported\", form))\n+            .span_suggestion(\n+                range_span,\n+                \"try using the minimum value for the type\",\n+                format!(\"MIN{}{}\", form, pprust::expr_to_string(&end)),\n+                Applicability::HasPlaceholders,\n+            )\n+            .emit();\n+\n+        Ok(PatKind::Range(begin, end, respan(lo, re)))\n+    }\n+\n+    /// Parse the end of a `X..Y`, `X..=Y`, or `X...Y` range pattern  or recover\n+    /// if that end is missing treating it as `X..`, `X..=`, or `X...` respectively.\n+    fn parse_pat_range_end_opt(&mut self, begin: &Expr, form: &str) -> PResult<'a, P<Expr>> {\n+        if self.is_pat_range_end_start() {\n+            // Parsing e.g. `X..=Y`.\n+            self.parse_pat_range_end()\n+        } else {\n+            // Parsing e.g. `X..`.\n+            let range_span = begin.span.to(self.prev_span);\n+\n+            self.diagnostic()\n+                .struct_span_err(\n+                    range_span,\n+                    &format!(\"`X{}` range patterns are not supported\", form),\n+                )\n+                .span_suggestion(\n+                    range_span,\n+                    \"try using the maximum value for the type\",\n+                    format!(\"{}{}MAX\", pprust::expr_to_string(&begin), form),\n+                    Applicability::HasPlaceholders,\n+                )\n+                .emit();\n+\n+            Ok(self.mk_expr(range_span, ExprKind::Err, ThinVec::new()))\n+        }\n+    }\n+\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n@@ -3934,20 +3878,41 @@ impl<'a> Parser<'a> {\n                 pat = PatKind::Ref(subpat, mutbl);\n             }\n             token::OpenDelim(token::Paren) => {\n-                // Parse (pat,pat,pat,...) as tuple pattern\n-                let (fields, ddpos, trailing_comma) = self.parse_parenthesized_pat_list()?;\n-                pat = if fields.len() == 1 && ddpos.is_none() && !trailing_comma {\n+                // Parse a tuple or parenthesis pattern.\n+                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+\n+                // Here, `(pat,)` is a tuple pattern.\n+                // For backward compatibility, `(..)` is a tuple pattern as well.\n+                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n                     PatKind::Paren(fields.into_iter().nth(0).unwrap())\n                 } else {\n-                    PatKind::Tuple(fields, ddpos)\n+                    PatKind::Tuple(fields)\n                 };\n             }\n             token::OpenDelim(token::Bracket) => {\n-                // Parse [pat,pat,...] as slice pattern\n+                // Parse `[pat, pat,...]` as a slice pattern.\n+                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n+                pat = PatKind::Slice(slice);\n+            }\n+            token::DotDot => {\n+                self.bump();\n+                pat = if self.is_pat_range_end_start() {\n+                    // Parse `..42` for recovery.\n+                    self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n+                } else {\n+                    // A rest pattern `..`.\n+                    PatKind::Rest\n+                };\n+            }\n+            token::DotDotEq => {\n+                // Parse `..=42` for recovery.\n                 self.bump();\n-                let (before, slice, after) = self.parse_pat_vec_elements()?;\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n-                pat = PatKind::Slice(before, slice, after);\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+            }\n+            token::DotDotDot => {\n+                // Parse `...42` for recovery.\n+                self.bump();\n+                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n             }\n             // At this point, token != &, &&, (, [\n             _ => if self.eat_keyword(kw::Underscore) {\n@@ -4004,10 +3969,10 @@ impl<'a> Parser<'a> {\n                         pat = PatKind::Mac(mac);\n                     }\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n-                        let end_kind = match self.token.kind {\n-                            token::DotDot => RangeEnd::Excluded,\n-                            token::DotDotDot => RangeEnd::Included(RangeSyntax::DotDotDot),\n-                            token::DotDotEq => RangeEnd::Included(RangeSyntax::DotDotEq),\n+                        let (end_kind, form) = match self.token.kind {\n+                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n+                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n                             _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n                                          (checked above)\"),\n                         };\n@@ -4016,9 +3981,8 @@ impl<'a> Parser<'a> {\n                         let span = lo.to(self.prev_span);\n                         let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n-                        let end = self.parse_pat_range_end()?;\n-                        let op = Spanned { span: op_span, node: end_kind };\n-                        pat = PatKind::Range(begin, end, op);\n+                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n                     }\n                     token::OpenDelim(token::Brace) => {\n                         if qself.is_some() {\n@@ -4045,8 +4009,8 @@ impl<'a> Parser<'a> {\n                             return Err(err);\n                         }\n                         // Parse tuple struct or enum pattern\n-                        let (fields, ddpos, _) = self.parse_parenthesized_pat_list()?;\n-                        pat = PatKind::TupleStruct(path, fields, ddpos)\n+                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+                        pat = PatKind::TupleStruct(path, fields)\n                     }\n                     _ => pat = PatKind::Path(qself, path),\n                 }\n@@ -4057,19 +4021,18 @@ impl<'a> Parser<'a> {\n                         let op_span = self.token.span;\n                         if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n                                 self.check(&token::DotDotDot) {\n-                            let end_kind = if self.eat(&token::DotDotDot) {\n-                                RangeEnd::Included(RangeSyntax::DotDotDot)\n+                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n+                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n                             } else if self.eat(&token::DotDotEq) {\n-                                RangeEnd::Included(RangeSyntax::DotDotEq)\n+                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n                             } else if self.eat(&token::DotDot) {\n-                                RangeEnd::Excluded\n+                                (RangeEnd::Excluded, \"..\")\n                             } else {\n                                 panic!(\"impossible case: we already matched \\\n                                         on a range-operator token\")\n                             };\n-                            let end = self.parse_pat_range_end()?;\n-                            let op = Spanned { span: op_span, node: end_kind };\n-                            pat = PatKind::Range(begin, end, op);\n+                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n+                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n                         } else {\n                             pat = PatKind::Lit(begin);\n                         }\n@@ -5359,59 +5322,48 @@ impl<'a> Parser<'a> {\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_c_variadic: bool)\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-\n         let sp = self.token.span;\n         let mut c_variadic = false;\n-        let (args, recovered): (Vec<Option<Arg>>, bool) =\n-            self.parse_seq_to_before_end(\n-                &token::CloseDelim(token::Paren),\n-                SeqSep::trailing_allowed(token::Comma),\n-                |p| {\n-                    let do_not_enforce_named_arguments_for_c_variadic =\n-                        |token: &token::Token| -> bool {\n-                            if token == &token::DotDotDot {\n-                                false\n-                            } else {\n-                                named_args\n-                            }\n-                        };\n-                    match p.parse_arg_general(\n-                        false,\n-                        allow_c_variadic,\n-                        do_not_enforce_named_arguments_for_c_variadic\n-                    ) {\n-                        Ok(arg) => {\n-                            if let TyKind::CVarArgs = arg.ty.node {\n-                                c_variadic = true;\n-                                if p.token != token::CloseDelim(token::Paren) {\n-                                    let span = p.token.span;\n-                                    p.span_err(span,\n-                                        \"`...` must be the last argument of a C-variadic function\");\n-                                    Ok(None)\n-                                } else {\n-                                    Ok(Some(arg))\n-                                }\n-                            } else {\n-                                Ok(Some(arg))\n-                            }\n-                        },\n-                        Err(mut e) => {\n-                            e.emit();\n-                            let lo = p.prev_span;\n-                            // Skip every token until next possible arg or end.\n-                            p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n-                            // Create a placeholder argument for proper arg count (issue #34264).\n-                            let span = lo.to(p.prev_span);\n-                            Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n+        let (args, _): (Vec<Option<Arg>>, _) = self.parse_paren_comma_seq(|p| {\n+            let do_not_enforce_named_arguments_for_c_variadic =\n+                |token: &token::Token| -> bool {\n+                    if token == &token::DotDotDot {\n+                        false\n+                    } else {\n+                        named_args\n+                    }\n+                };\n+            match p.parse_arg_general(\n+                false,\n+                allow_c_variadic,\n+                do_not_enforce_named_arguments_for_c_variadic\n+            ) {\n+                Ok(arg) => {\n+                    if let TyKind::CVarArgs = arg.ty.node {\n+                        c_variadic = true;\n+                        if p.token != token::CloseDelim(token::Paren) {\n+                            let span = p.token.span;\n+                            p.span_err(span,\n+                                \"`...` must be the last argument of a C-variadic function\");\n+                            Ok(None)\n+                        } else {\n+                            Ok(Some(arg))\n                         }\n+                    } else {\n+                        Ok(Some(arg))\n                     }\n+                },\n+                Err(mut e) => {\n+                    e.emit();\n+                    let lo = p.prev_span;\n+                    // Skip every token until next possible arg or end.\n+                    p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                    // Create a placeholder argument for proper arg count (issue #34264).\n+                    let span = lo.to(p.prev_span);\n+                    Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n                 }\n-            )?;\n-\n-        if !recovered {\n-            self.eat(&token::CloseDelim(token::Paren));\n-        }\n+            }\n+        })?;\n \n         let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n@@ -5573,7 +5525,7 @@ impl<'a> Parser<'a> {\n                 (vec![self_arg], false)\n             } else if self.eat(&token::Comma) {\n                 let mut fn_inputs = vec![self_arg];\n-                let (mut input, recovered) = self.parse_seq_to_before_end(\n+                let (mut input, _, recovered) = self.parse_seq_to_before_end(\n                     &token::CloseDelim(token::Paren), sep, parse_arg_fn)?;\n                 fn_inputs.append(&mut input);\n                 (fn_inputs, recovered)\n@@ -5584,7 +5536,9 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         } else {\n-            self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)?\n+            let (input, _, recovered) =\n+                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)?;\n+            (input, recovered)\n         };\n \n         if !recovered {\n@@ -6185,26 +6139,20 @@ impl<'a> Parser<'a> {\n     fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<StructField>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n         // Unit like structs are handled in parse_item_struct function\n-        let fields = self.parse_unspanned_seq(\n-            &token::OpenDelim(token::Paren),\n-            &token::CloseDelim(token::Paren),\n-            SeqSep::trailing_allowed(token::Comma),\n-            |p| {\n-                let attrs = p.parse_outer_attributes()?;\n-                let lo = p.token.span;\n-                let vis = p.parse_visibility(true)?;\n-                let ty = p.parse_ty()?;\n-                Ok(StructField {\n-                    span: lo.to(ty.span),\n-                    vis,\n-                    ident: None,\n-                    id: ast::DUMMY_NODE_ID,\n-                    ty,\n-                    attrs,\n-                })\n-            })?;\n-\n-        Ok(fields)\n+        self.parse_paren_comma_seq(|p| {\n+            let attrs = p.parse_outer_attributes()?;\n+            let lo = p.token.span;\n+            let vis = p.parse_visibility(true)?;\n+            let ty = p.parse_ty()?;\n+            Ok(StructField {\n+                span: lo.to(ty.span),\n+                vis,\n+                ident: None,\n+                id: ast::DUMMY_NODE_ID,\n+                ty,\n+                attrs,\n+            })\n+        }).map(|(r, _)| r)\n     }\n \n     /// Parses a structure field declaration.\n@@ -7786,11 +7734,8 @@ impl<'a> Parser<'a> {\n     /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n     /// ```\n     fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n-        self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n-                                 &token::CloseDelim(token::Brace),\n-                                 SeqSep::trailing_allowed(token::Comma), |this| {\n-            Ok((this.parse_use_tree()?, ast::DUMMY_NODE_ID))\n-        })\n+        self.parse_delim_comma_seq(token::Brace, |p| Ok((p.parse_use_tree()?, ast::DUMMY_NODE_ID)))\n+            .map(|(r, _)| r)\n     }\n \n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {"}, {"sha": "c7be0b123023d501b86cb8665163af4ca724f5d6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 47, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -2368,22 +2368,10 @@ impl<'a> State<'a> {\n                     self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n+            PatKind::TupleStruct(ref path, ref elts) => {\n                 self.print_path(path, true, 0);\n                 self.popen();\n-                if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n-                    if ddpos != 0 {\n-                        self.word_space(\",\");\n-                    }\n-                    self.s.word(\"..\");\n-                    if ddpos != elts.len() {\n-                        self.s.word(\",\");\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p));\n-                    }\n-                } else {\n-                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n-                }\n+                self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n             PatKind::Path(None, ref path) => {\n@@ -2415,23 +2403,11 @@ impl<'a> State<'a> {\n                 self.s.space();\n                 self.s.word(\"}\");\n             }\n-            PatKind::Tuple(ref elts, ddpos) => {\n+            PatKind::Tuple(ref elts) => {\n                 self.popen();\n-                if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n-                    if ddpos != 0 {\n-                        self.word_space(\",\");\n-                    }\n-                    self.s.word(\"..\");\n-                    if ddpos != elts.len() {\n-                        self.s.word(\",\");\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p));\n-                    }\n-                } else {\n-                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n-                    if elts.len() == 1 {\n-                        self.s.word(\",\");\n-                    }\n+                self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n+                if elts.len() == 1 {\n+                    self.s.word(\",\");\n                 }\n                 self.pclose();\n             }\n@@ -2457,26 +2433,12 @@ impl<'a> State<'a> {\n                 }\n                 self.print_expr(end);\n             }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+            PatKind::Slice(ref elts) => {\n                 self.s.word(\"[\");\n-                self.commasep(Inconsistent,\n-                                   &before[..],\n-                                   |s, p| s.print_pat(p));\n-                if let Some(ref p) = *slice {\n-                    if !before.is_empty() { self.word_space(\",\"); }\n-                    if let PatKind::Wild = p.node {\n-                        // Print nothing\n-                    } else {\n-                        self.print_pat(p);\n-                    }\n-                    self.s.word(\"..\");\n-                    if !after.is_empty() { self.word_space(\",\"); }\n-                }\n-                self.commasep(Inconsistent,\n-                                   &after[..],\n-                                   |s, p| s.print_pat(p));\n+                self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 self.s.word(\"]\");\n             }\n+            PatKind::Rest => self.s.word(\"..\"),\n             PatKind::Paren(ref inner) => {\n                 self.popen();\n                 self.print_pat(inner);"}, {"sha": "ff6440fb9dceb659a2077617e6d25b8e45ec586c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -428,9 +428,9 @@ pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(visitor: &mut V,\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref children, _) => {\n+        PatKind::TupleStruct(ref path, ref elems) => {\n             visitor.visit_path(path, pattern.id);\n-            walk_list!(visitor, visit_pat, children);\n+            walk_list!(visitor, visit_pat, elems);\n         }\n         PatKind::Path(ref opt_qself, ref path) => {\n             if let Some(ref qself) = *opt_qself {\n@@ -446,8 +446,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatKind::Tuple(ref tuple_elements, _) => {\n-            walk_list!(visitor, visit_pat, tuple_elements);\n+        PatKind::Tuple(ref elems) => {\n+            walk_list!(visitor, visit_pat, elems);\n         }\n         PatKind::Box(ref subpattern) |\n         PatKind::Ref(ref subpattern, _) |\n@@ -463,11 +463,9 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             visitor.visit_expr(lower_bound);\n             visitor.visit_expr(upper_bound);\n         }\n-        PatKind::Wild => (),\n-        PatKind::Slice(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n-            walk_list!(visitor, visit_pat, prepatterns);\n-            walk_list!(visitor, visit_pat, slice_pattern);\n-            walk_list!(visitor, visit_pat, postpatterns);\n+        PatKind::Wild | PatKind::Rest => {},\n+        PatKind::Slice(ref elems) => {\n+            walk_list!(visitor, visit_pat, elems);\n         }\n         PatKind::Mac(ref mac) => visitor.visit_mac(mac),\n     }"}, {"sha": "c249154c71e23b19e08de5cc599ece1a267d3c6d", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -8,7 +8,7 @@ fn move_out_from_end() {\n \n fn move_out_by_subslice() {\n     let a = [box 1, box 2];\n-    let [_y..] = a;\n+    let [_y @ ..] = a;\n }\n \n fn main() {"}, {"sha": "f416160db242247af496b9fcec2a33b7e61fc6a5", "filename": "src/test/ui/array-slice-vec/vec-matching-fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fold.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -11,7 +11,7 @@ fn foldl<T, U, F>(values: &[T],\n     U: Clone+Debug, T:Debug,\n     F: FnMut(U, &T) -> U,\n {    match values {\n-        &[ref head, ref tail..] =>\n+        &[ref head, ref tail @ ..] =>\n             foldl(tail, function(initial, head), function),\n         &[] => {\n             // FIXME: call guards\n@@ -28,7 +28,7 @@ fn foldr<T, U, F>(values: &[T],\n     F: FnMut(&T, U) -> U,\n {\n     match values {\n-        &[ref head.., ref tail] =>\n+        &[ref head @ .., ref tail] =>\n             foldr(head, function(tail, initial), function),\n         &[] => {\n             // FIXME: call guards"}, {"sha": "f0602c328b071af010092e6b513c8970b72ede24", "filename": "src/test/ui/array-slice-vec/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -8,7 +8,7 @@ pub fn main() {\n     let x: &[isize] = &[1, 2, 3, 4, 5];\n     if !x.is_empty() {\n         let el = match x {\n-            &[1, ref tail..] => &tail[0],\n+            &[1, ref tail @ ..] => &tail[0],\n             _ => unreachable!()\n         };\n         println!(\"{}\", *el);"}, {"sha": "49c736bd72847377503b7942da89fa5e126d0986", "filename": "src/test/ui/array-slice-vec/vec-matching.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -14,23 +14,23 @@ fn a() {\n fn b() {\n     let x = [1, 2, 3];\n     match x {\n-        [a, b, c..] => {\n+        [a, b, c @ ..] => {\n             assert_eq!(a, 1);\n             assert_eq!(b, 2);\n             let expected: &[_] = &[3];\n             assert_eq!(c, expected);\n         }\n     }\n     match x {\n-        [a.., b, c] => {\n+        [a @ .., b, c] => {\n             let expected: &[_] = &[1];\n             assert_eq!(a, expected);\n             assert_eq!(b, 2);\n             assert_eq!(c, 3);\n         }\n     }\n     match x {\n-        [a, b.., c] => {\n+        [a, b @ .., c] => {\n             assert_eq!(a, 1);\n             let expected: &[_] = &[2];\n             assert_eq!(b, expected);\n@@ -50,7 +50,7 @@ fn b() {\n fn b_slice() {\n     let x : &[_] = &[1, 2, 3];\n     match x {\n-        &[a, b, ref c..] => {\n+        &[a, b, ref c @ ..] => {\n             assert_eq!(a, 1);\n             assert_eq!(b, 2);\n             let expected: &[_] = &[3];\n@@ -59,7 +59,7 @@ fn b_slice() {\n         _ => unreachable!()\n     }\n     match x {\n-        &[ref a.., b, c] => {\n+        &[ref a @ .., b, c] => {\n             let expected: &[_] = &[1];\n             assert_eq!(a, expected);\n             assert_eq!(b, 2);\n@@ -68,7 +68,7 @@ fn b_slice() {\n         _ => unreachable!()\n     }\n     match x {\n-        &[a, ref b.., c] => {\n+        &[a, ref b @ .., c] => {\n             assert_eq!(a, 1);\n             let expected: &[_] = &[2];\n             assert_eq!(b, expected);\n@@ -134,26 +134,11 @@ fn e() {\n     assert_eq!(c, 1);\n }\n \n-fn f() {\n-    let x = &[1, 2, 3, 4, 5];\n-    let [a, [b, [c, ..].., d].., e] = *x;\n-    assert_eq!((a, b, c, d, e), (1, 2, 3, 4, 5));\n-\n-    let x: &[isize] = x;\n-    let (a, b, c, d, e) = match *x {\n-        [a, [b, [c, ..].., d].., e] => (a, b, c, d, e),\n-        _ => unimplemented!()\n-    };\n-\n-    assert_eq!((a, b, c, d, e), (1, 2, 3, 4, 5));\n-}\n-\n pub fn main() {\n     a();\n     b();\n     b_slice();\n     c();\n     d();\n     e();\n-    f();\n }"}, {"sha": "3c7b160dcc54038a9e218761b84e6c3c86184cac", "filename": "src/test/ui/array-slice-vec/vec-tail-matching.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-tail-matching.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -13,14 +13,14 @@ pub fn main() {\n         Foo { string: \"baz\" }\n     ];\n     match x {\n-        [ref first, ref tail..] => {\n+        [ref first, ref tail @ ..] => {\n             assert_eq!(first.string, \"foo\");\n             assert_eq!(tail.len(), 2);\n             assert_eq!(tail[0].string, \"bar\");\n             assert_eq!(tail[1].string, \"baz\");\n \n             match *(tail as &[_]) {\n-                [Foo { .. }, _, Foo { .. }, ref _tail..] => {\n+                [Foo { .. }, _, Foo { .. }, ref _tail @ ..] => {\n                     unreachable!();\n                 }\n                 [Foo { string: ref a }, Foo { string: ref b }] => {"}, {"sha": "20a6fd83faa327fa9a6e63d86f7798abbc1337d7", "filename": "src/test/ui/associated-path-shl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fassociated-path-shl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fassociated-path-shl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-path-shl.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -5,6 +5,5 @@ fn main() {\n     let _ = <<A>::B>::C; //~ ERROR cannot find type `A` in this scope\n     let <<A>::B>::C; //~ ERROR cannot find type `A` in this scope\n     let 0 ..= <<A>::B>::C; //~ ERROR cannot find type `A` in this scope\n-                           //~^ ERROR only char and numeric types are allowed in range patterns\n     <<A>::B>::C; //~ ERROR cannot find type `A` in this scope\n }"}, {"sha": "71ee93f4835fbc92c10e1a7184ee600e34f45e49", "filename": "src/test/ui/associated-path-shl.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fassociated-path-shl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fassociated-path-shl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-path-shl.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -23,21 +23,11 @@ LL |     let 0 ..= <<A>::B>::C;\n    |                 ^ not found in this scope\n \n error[E0412]: cannot find type `A` in this scope\n-  --> $DIR/associated-path-shl.rs:9:7\n+  --> $DIR/associated-path-shl.rs:8:7\n    |\n LL |     <<A>::B>::C;\n    |       ^ not found in this scope\n \n-error[E0029]: only char and numeric types are allowed in range patterns\n-  --> $DIR/associated-path-shl.rs:7:15\n-   |\n-LL |     let 0 ..= <<A>::B>::C;\n-   |               ^^^^^^^^^^^ ranges require char or numeric types\n-   |\n-   = note: start type: {integer}\n-   = note: end type: [type error]\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0029, E0412.\n-For more information about an error, try `rustc --explain E0029`.\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "ac733ef6e9c862c7b96628fefb8ad34ecc26072c", "filename": "src/test/ui/binding/irrefutable-slice-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fbinding%2Firrefutable-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fbinding%2Firrefutable-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Firrefutable-slice-patterns.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -4,7 +4,7 @@\n #![feature(slice_patterns)]\n \n fn foo(s: &[i32]) -> &[i32] {\n-    let &[ref xs..] = s;\n+    let &[ref xs @ ..] = s;\n     xs\n }\n "}, {"sha": "5326fa612a87bed365fa28a763af3d040a1f3391", "filename": "src/test/ui/binding/zero_sized_subslice_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fbinding%2Fzero_sized_subslice_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fbinding%2Fzero_sized_subslice_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fzero_sized_subslice_match.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -7,6 +7,6 @@ fn main() {\n     // The subslice used to go out of bounds for zero-sized array items, check that this doesn't\n     // happen anymore\n     match x {\n-        [_, ref y..] => assert_eq!(&x[1] as *const (), &y[0] as *const ())\n+        [_, ref y @ ..] => assert_eq!(&x[1] as *const (), &y[0] as *const ())\n     }\n }"}, {"sha": "20f05353d4633c8f39301f697220c99eadbafeba", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.nll.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -192,8 +192,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n LL |         match v {\n-LL |             &[x..] => println!(\"{:?}\", x),\n-   |               ^ use of borrowed `v`\n+LL |             &[x @ ..] => println!(\"{:?}\", x),\n+   |               ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -204,8 +204,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n-LL |             &[_, x..] => println!(\"{:?}\", x),\n-   |                  ^ use of borrowed `v`\n+LL |             &[_, x @ ..] => println!(\"{:?}\", x),\n+   |                  ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -216,8 +216,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n-LL |             &[x.., _] => println!(\"{:?}\", x),\n-   |               ^ use of borrowed `v`\n+LL |             &[x @ .., _] => println!(\"{:?}\", x),\n+   |               ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -228,8 +228,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n-LL |             &[_, x.., _] => println!(\"{:?}\", x),\n-   |                  ^ use of borrowed `v`\n+LL |             &[_, x @ .., _] => println!(\"{:?}\", x),\n+   |                  ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here"}, {"sha": "c27d9519dc7986f640221273ad467e330e80a21b", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -140,22 +140,22 @@ fn main() {\n         let mut v = &[1, 2, 3, 4, 5];\n         let x = &mut v;\n         match v {\n-            &[x..] => println!(\"{:?}\", x),\n+            &[x @ ..] => println!(\"{:?}\", x),\n                 //~^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }\n         match v {\n-            &[_, x..] => println!(\"{:?}\", x),\n+            &[_, x @ ..] => println!(\"{:?}\", x),\n                 //~^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }\n         match v {\n-            &[x.., _] => println!(\"{:?}\", x),\n+            &[x @ .., _] => println!(\"{:?}\", x),\n                 //~^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }\n         match v {\n-            &[_, x.., _] => println!(\"{:?}\", x),\n+            &[_, x @ .., _] => println!(\"{:?}\", x),\n                 //~^ ERROR cannot use `v[..]` because it was mutably borrowed\n             _ => panic!(\"other case\"),\n         }"}, {"sha": "38d847a90ff958b36a864912746323552b9776a8", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -192,8 +192,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n LL |         match v {\n-LL |             &[x..] => println!(\"{:?}\", x),\n-   |               ^ use of borrowed `v`\n+LL |             &[x @ ..] => println!(\"{:?}\", x),\n+   |               ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -204,8 +204,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n-LL |             &[_, x..] => println!(\"{:?}\", x),\n-   |                  ^ use of borrowed `v`\n+LL |             &[_, x @ ..] => println!(\"{:?}\", x),\n+   |                  ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -216,8 +216,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n-LL |             &[x.., _] => println!(\"{:?}\", x),\n-   |               ^ use of borrowed `v`\n+LL |             &[x @ .., _] => println!(\"{:?}\", x),\n+   |               ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -228,8 +228,8 @@ error[E0503]: cannot use `v[..]` because it was mutably borrowed\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n-LL |             &[_, x.., _] => println!(\"{:?}\", x),\n-   |                  ^ use of borrowed `v`\n+LL |             &[_, x @ .., _] => println!(\"{:?}\", x),\n+   |                  ^^^^^^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here"}, {"sha": "ee6abf407a30490afd7acb14ef766ca885a8bb4c", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -10,7 +10,7 @@ fn move_out_from_begin_and_end() {\n fn move_out_by_const_index_and_subslice() {\n     let a = [box 1, box 2];\n     let [_x, _] = a;\n-    let [_y..] = a; //~ ERROR [E0382]\n+    let [_y @ ..] = a; //~ ERROR [E0382]\n }\n \n fn main() {}"}, {"sha": "b34c03e6deff8d54151abb621335e6e47706339e", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -13,8 +13,8 @@ error[E0382]: use of moved value: `a[..]`\n    |\n LL |     let [_x, _] = a;\n    |          -- value moved here\n-LL |     let [_y..] = a;\n-   |          ^^ value used here after move\n+LL |     let [_y @ ..] = a;\n+   |          ^^^^^^^ value used here after move\n    |\n    = note: move occurs because `a[..]` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n "}, {"sha": "fa9a3c217db77ec0eefc88d5128f6e1fcaa2f271", "filename": "src/test/ui/borrowck/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     ];\n     let x: &[Foo] = &x;\n     match *x {\n-        [_, ref tail..] => {\n+        [_, ref tail @ ..] => {\n             match tail {\n             //~^ ERROR cannot move out of type `[Foo]`\n                 &[Foo { string: a },"}, {"sha": "048813b2b93e6fd6970eabe2df65509f36217369", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-rpass.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -5,7 +5,7 @@\n \n fn mut_head_tail<'a, A>(v: &'a mut [A]) -> Option<(&'a mut A, &'a mut [A])> {\n     match *v {\n-        [ref mut head, ref mut tail..] => {\n+        [ref mut head, ref mut tail @ ..] => {\n             Some((head, tail))\n         }\n         [] => None"}, {"sha": "a6b54f9537ddcf5409240dcc08558a6372682eca", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -70,7 +70,7 @@ fn const_index_mixed(s: &mut [i32]) {\n \n fn const_index_and_subslice_ok(s: &mut [i32]) {\n     if let [ref first, ref second, ..] = *s {\n-        if let [_, _, ref mut tail..] = *s {\n+        if let [_, _, ref mut tail @ ..] = *s {\n             nop(&[first, second]);\n             nop_subslice(tail);\n         }\n@@ -79,7 +79,7 @@ fn const_index_and_subslice_ok(s: &mut [i32]) {\n \n fn const_index_and_subslice_err(s: &mut [i32]) {\n     if let [ref first, ref second, ..] = *s {\n-        if let [_, ref mut tail..] = *s { //~ERROR\n+        if let [_, ref mut tail @ ..] = *s { //~ERROR\n             nop(&[first, second]);\n             nop_subslice(tail);\n         }\n@@ -88,7 +88,7 @@ fn const_index_and_subslice_err(s: &mut [i32]) {\n \n fn const_index_and_subslice_from_end_ok(s: &mut [i32]) {\n     if let [.., ref second, ref first] = *s {\n-        if let [ref mut tail.., _, _] = *s {\n+        if let [ref mut tail @ .., _, _] = *s {\n             nop(&[first, second]);\n             nop_subslice(tail);\n         }\n@@ -97,16 +97,16 @@ fn const_index_and_subslice_from_end_ok(s: &mut [i32]) {\n \n fn const_index_and_subslice_from_end_err(s: &mut [i32]) {\n     if let [.., ref second, ref first] = *s {\n-        if let [ref mut tail.., _] = *s { //~ERROR\n+        if let [ref mut tail @ .., _] = *s { //~ERROR\n             nop(&[first, second]);\n             nop_subslice(tail);\n         }\n     }\n }\n \n fn subslices(s: &mut [i32]) {\n-    if let [_, _, _, ref s1..] = *s {\n-        if let [ref mut s2.., _, _, _] = *s { //~ERROR\n+    if let [_, _, _, ref s1 @ ..] = *s {\n+        if let [ref mut s2 @ .., _, _, _] = *s { //~ERROR\n             nop_subslice(s1);\n             nop_subslice(s2);\n         }"}, {"sha": "2c019f446118208c962f48831809934022a7aa7e", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -89,8 +89,8 @@ error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as im\n    |\n LL |     if let [ref first, ref second, ..] = *s {\n    |                        ---------- immutable borrow occurs here\n-LL |         if let [_, ref mut tail..] = *s {\n-   |                    ^^^^^^^^^^^^ mutable borrow occurs here\n+LL |         if let [_, ref mut tail @ ..] = *s {\n+   |                    ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n@@ -99,18 +99,18 @@ error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as im\n    |\n LL |     if let [.., ref second, ref first] = *s {\n    |                 ---------- immutable borrow occurs here\n-LL |         if let [ref mut tail.., _] = *s {\n-   |                 ^^^^^^^^^^^^ mutable borrow occurs here\n+LL |         if let [ref mut tail @ .., _] = *s {\n+   |                 ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-slice-pattern-element-loan.rs:109:17\n    |\n-LL |     if let [_, _, _, ref s1..] = *s {\n-   |                      ------ immutable borrow occurs here\n-LL |         if let [ref mut s2.., _, _, _] = *s {\n-   |                 ^^^^^^^^^^ mutable borrow occurs here\n+LL |     if let [_, _, _, ref s1 @ ..] = *s {\n+   |                      ----------- immutable borrow occurs here\n+LL |         if let [ref mut s2 @ .., _, _, _] = *s {\n+   |                 ^^^^^^^^^^^^^^^ mutable borrow occurs here\n LL |             nop_subslice(s1);\n    |                          -- immutable borrow later used here\n "}, {"sha": "53a9bcef74a22beb410ed391a74f3b13a5fbd117", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -4,7 +4,7 @@ fn a<'a>() -> &'a [isize] {\n     let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec;\n     let tail = match vec {\n-        &[_, ref tail..] => tail,\n+        &[_, ref tail @ ..] => tail,\n         _ => panic!(\"a\")\n     };\n     tail //~ ERROR cannot return value referencing local variable `vec`\n@@ -14,7 +14,7 @@ fn b<'a>() -> &'a [isize] {\n     let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec;\n     let init = match vec {\n-        &[ref init.., _] => init,\n+        &[ref init @ .., _] => init,\n         _ => panic!(\"b\")\n     };\n     init //~ ERROR cannot return value referencing local variable `vec`\n@@ -24,7 +24,7 @@ fn c<'a>() -> &'a [isize] {\n     let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec;\n     let slice = match vec {\n-        &[_, ref slice.., _] => slice,\n+        &[_, ref slice @ .., _] => slice,\n         _ => panic!(\"c\")\n     };\n     slice //~ ERROR cannot return value referencing local variable `vec`"}, {"sha": "dd9023f6d9f791846a404f09068cfd0e9d152fa2", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -4,7 +4,7 @@ fn a() {\n     let mut v = vec![1, 2, 3];\n     let vb: &mut [isize] = &mut v;\n     match vb {\n-        &mut [_a, ref tail..] => {\n+        &mut [_a, ref tail @ ..] => {\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}"}, {"sha": "420223009a45b2f0c5624e1ef178921ae4058f96", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -5,7 +5,7 @@\n fn main() {\n     let mut a = [1, 2, 3, 4];\n     let t = match a {\n-        [1, 2, ref tail..] => tail,\n+        [1, 2, ref tail @ ..] => tail,\n         _ => unreachable!()\n     };\n     println!(\"t[0]: {}\", t[0]);"}, {"sha": "9f8e6fe3b6898dcdbae751c069093f151aee5c94", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-move-tail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,8 @@\n error[E0506]: cannot assign to `a[_]` because it is borrowed\n   --> $DIR/borrowck-vec-pattern-move-tail.rs:12:5\n    |\n-LL |         [1, 2, ref tail..] => tail,\n-   |                -------- borrow of `a[_]` occurs here\n+LL |         [1, 2, ref tail @ ..] => tail,\n+   |                ------------- borrow of `a[_]` occurs here\n ...\n LL |     a[2] = 0;\n    |     ^^^^^^^^ assignment to borrowed `a[_]` occurs here"}, {"sha": "a215305f684dd6aa16efafb0acca652a70a1f5f9", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -19,7 +19,7 @@ fn b() {\n     let mut vec = vec![box 1, box 2, box 3];\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        &mut [ref _b..] => {\n+        &mut [ref _b @ ..] => {\n         //~^ borrow of `vec[_]` occurs here\n             vec[0] = box 4; //~ ERROR cannot assign\n             //~^ NOTE assignment to borrowed `vec[_]` occurs here"}, {"sha": "f54a3a4072cd215eaa0acea43a7cefd7e0211ec9", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -13,8 +13,8 @@ LL |             _a.use_ref();\n error[E0506]: cannot assign to `vec[_]` because it is borrowed\n   --> $DIR/borrowck-vec-pattern-nesting.rs:24:13\n    |\n-LL |         &mut [ref _b..] => {\n-   |               ------ borrow of `vec[_]` occurs here\n+LL |         &mut [ref _b @ ..] => {\n+   |               ----------- borrow of `vec[_]` occurs here\n LL |\n LL |             vec[0] = box 4;\n    |             ^^^^^^ assignment to borrowed `vec[_]` occurs here"}, {"sha": "c35be2f6be62c02f48a9569aa9d02a7085346122", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -4,7 +4,7 @@ fn a<'a>() -> &'a isize {\n     let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec;\n     let tail = match vec {\n-        &[_a, ref tail..] => &tail[0],\n+        &[_a, ref tail @ ..] => &tail[0],\n         _ => panic!(\"foo\")\n     };\n     tail //~ ERROR cannot return value referencing local variable `vec`"}, {"sha": "f3f5c382275fe760bd06901237eb2a77810c3f33", "filename": "src/test/ui/drop/dynamic-drop-async.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop-async.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -217,7 +217,7 @@ async fn subslice_pattern_from_end_with_drop(a: Rc<Allocator>, arg: bool, arg2:\n     if arg {\n         let [.., _x, _] = arr;\n     } else {\n-        let [_, _y..] = arr;\n+        let [_, _y @ ..] = arr;\n     }\n     a.alloc().await;\n }\n@@ -226,7 +226,7 @@ async fn subslice_pattern_reassign(a: Rc<Allocator>) {\n     let mut ar = [a.alloc().await, a.alloc().await, a.alloc().await];\n     let [_, _, _x] = ar;\n     ar = [a.alloc().await, a.alloc().await, a.alloc().await];\n-    let [_, _y..] = ar;\n+    let [_, _y @ ..] = ar;\n     a.alloc().await;\n }\n "}, {"sha": "8516bc3d96424cb452adb6ccd7051d11d21728b0", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -237,7 +237,7 @@ fn subslice_pattern_from_end(a: &Allocator, arg: bool) {\n     if arg {\n         let[.., _x, _] = a;\n     } else {\n-        let[_, _y..] = a;\n+        let[_, _y @ ..] = a;\n     }\n }\n \n@@ -251,7 +251,7 @@ fn subslice_pattern_from_end_with_drop(a: &Allocator, arg: bool, arg2: bool) {\n     if arg {\n         let[.., _x, _] = a;\n     } else {\n-        let[_, _y..] = a;\n+        let[_, _y @ ..] = a;\n     }\n }\n \n@@ -266,7 +266,7 @@ fn subslice_pattern_reassign(a: &Allocator) {\n     let mut ar = [a.alloc(), a.alloc(), a.alloc()];\n     let[_, _, _x] = ar;\n     ar = [a.alloc(), a.alloc(), a.alloc()];\n-    let[_, _y..] = ar;\n+    let[_, _y @ ..] = ar;\n }\n \n fn panic_after_return(a: &Allocator) -> Ptr<'_> {"}, {"sha": "17d03b14fc6e176487c59800b2d0db61de867108", "filename": "src/test/ui/error-codes/E0528.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ferror-codes%2FE0528.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ferror-codes%2FE0528.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0528.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -3,7 +3,7 @@\n fn main() {\n     let r = &[1, 2];\n     match r {\n-        &[a, b, c, rest..] => {\n+        &[a, b, c, rest @ ..] => {\n         //~^ ERROR E0528\n         }\n     }"}, {"sha": "0f566091145bffaf32458f923677a520690719ea", "filename": "src/test/ui/error-codes/E0528.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ferror-codes%2FE0528.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ferror-codes%2FE0528.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0528.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,8 @@\n error[E0528]: pattern requires at least 3 elements but array has 2\n   --> $DIR/E0528.rs:6:10\n    |\n-LL |         &[a, b, c, rest..] => {\n-   |          ^^^^^^^^^^^^^^^^^ pattern cannot match array of 2 elements\n+LL |         &[a, b, c, rest @ ..] => {\n+   |          ^^^^^^^^^^^^^^^^^^^^ pattern cannot match array of 2 elements\n \n error: aborting due to previous error\n "}, {"sha": "d97b693f520983dbc86e9779b2e933a935075926", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -2,7 +2,9 @@\n \n fn main() {\n     match [5..4, 99..105, 43..44] {\n-        [_, 99.., _] => {}, //~ ERROR unexpected token: `,`\n+        [_, 99.., _] => {},\n+        //~^ ERROR `X..` range patterns are not supported\n+        //~| ERROR mismatched types\n         _ => {},\n     }\n }"}, {"sha": "4ecd8515ee164e28016b8131bba4813e4003e660", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,20 @@\n-error: unexpected token: `,`\n-  --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:17\n+error: `X..` range patterns are not supported\n+  --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:13\n    |\n LL |         [_, 99.., _] => {},\n-   |                 ^\n+   |             ^^^^ help: try using the maximum value for the type: `99..MAX`\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:13\n+   |\n+LL |     match [5..4, 99..105, 43..44] {\n+   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+LL |         [_, 99.., _] => {},\n+   |             ^^^^ expected struct `std::ops::Range`, found integer\n+   |\n+   = note: expected type `std::ops::Range<{integer}>`\n+              found type `{integer}`\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "09f459c9862ee03c01008388429b7c8fbae335c7", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -2,7 +2,10 @@\n \n fn main() {\n     match [5..4, 99..105, 43..44] {\n-        [_, 99..] => {}, //~ ERROR unexpected token: `]`\n+        [_, 99..] => {},\n+        //~^ ERROR `X..` range patterns are not supported\n+        //~| ERROR pattern requires 2 elements but array has 3\n+        //~| ERROR mismatched types\n         _ => {},\n     }\n }"}, {"sha": "922d26923158b8580834d6704cc0f3fc26aba190", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.stderr", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,27 @@\n-error: unexpected token: `]`\n-  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:17\n+error: `X..` range patterns are not supported\n+  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:13\n    |\n LL |         [_, 99..] => {},\n-   |                 ^\n+   |             ^^^^ help: try using the maximum value for the type: `99..MAX`\n \n-error: aborting due to previous error\n+error[E0527]: pattern requires 2 elements but array has 3\n+  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:9\n+   |\n+LL |         [_, 99..] => {},\n+   |         ^^^^^^^^^ expected 3 elements\n+\n+error[E0308]: mismatched types\n+  --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:13\n+   |\n+LL |     match [5..4, 99..105, 43..44] {\n+   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+LL |         [_, 99..] => {},\n+   |             ^^^^ expected struct `std::ops::Range`, found integer\n+   |\n+   = note: expected type `std::ops::Range<{integer}>`\n+              found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0308, E0527.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "95e58b1d48c88cae40440c04b97fc35638e9b074", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision3.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -2,7 +2,10 @@\n \n fn main() {\n     match [5..4, 99..105, 43..44] {\n-        [..9, 99..100, _] => {}, //~ ERROR expected one of `,` or `]`, found `9`\n+        [..9, 99..100, _] => {},\n+        //~^ ERROR `..X` range patterns are not supported\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n         _ => {},\n     }\n }"}, {"sha": "8907b875f8e116d4440a6bb988e6ee69acf5e088", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision3.stderr", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,31 @@\n-error: expected one of `,` or `]`, found `9`\n-  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:12\n+error: `..X` range patterns are not supported\n+  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:10\n    |\n LL |         [..9, 99..100, _] => {},\n-   |            ^ expected one of `,` or `]` here\n+   |          ^^^ help: try using the minimum value for the type: `MIN..9`\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:10\n+   |\n+LL |     match [5..4, 99..105, 43..44] {\n+   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+LL |         [..9, 99..100, _] => {},\n+   |          ^^^ expected struct `std::ops::Range`, found integer\n+   |\n+   = note: expected type `std::ops::Range<{integer}>`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:15\n+   |\n+LL |     match [5..4, 99..105, 43..44] {\n+   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+LL |         [..9, 99..100, _] => {},\n+   |               ^^^^^^^ expected struct `std::ops::Range`, found integer\n+   |\n+   = note: expected type `std::ops::Range<{integer}>`\n+              found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f2a1b135b69cbaab06ce2aeb5e549f4b720b9fca", "filename": "src/test/ui/feature-gates/feature-gate-slice-patterns.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-slice-patterns.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -3,15 +3,15 @@\n fn main() {\n     let x = [1, 2, 3, 4, 5];\n     match x {\n-        [1, 2, ..] => {} //~ ERROR syntax for subslices in slice patterns is not yet stabilized\n-        [1, .., 5] => {} //~ ERROR syntax for subslices in slice patterns is not yet stabilized\n-        [.., 4, 5] => {} //~ ERROR syntax for subslices in slice patterns is not yet stabilized\n+        [1, 2, ..] => {} //~ ERROR subslice patterns are unstable\n+        [1, .., 5] => {} //~ ERROR subslice patterns are unstable\n+        [.., 4, 5] => {} //~ ERROR subslice patterns are unstable\n     }\n \n     let x = [ 1, 2, 3, 4, 5 ];\n     match x {\n-        [ xs.., 4, 5 ] => {} //~ ERROR syntax for subslices in slice patterns is not yet stabilized\n-        [ 1, xs.., 5 ] => {} //~ ERROR syntax for subslices in slice patterns is not yet stabilized\n-        [ 1, 2, xs.. ] => {} //~ ERROR syntax for subslices in slice patterns is not yet stabilized\n+        [ xs @ .., 4, 5 ] => {} //~ ERROR subslice patterns are unstable\n+        [ 1, xs @ .., 5 ] => {} //~ ERROR subslice patterns are unstable\n+        [ 1, 2, xs @ .. ] => {} //~ ERROR subslice patterns are unstable\n     }\n }"}, {"sha": "d4946a42b8f3dcc307b9daf569468384de8028c5", "filename": "src/test/ui/feature-gates/feature-gate-slice-patterns.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-slice-patterns.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: syntax for subslices in slice patterns is not yet stabilized\n+error[E0658]: subslice patterns are unstable\n   --> $DIR/feature-gate-slice-patterns.rs:6:16\n    |\n LL |         [1, 2, ..] => {}\n@@ -7,7 +7,7 @@ LL |         [1, 2, ..] => {}\n    = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n \n-error[E0658]: syntax for subslices in slice patterns is not yet stabilized\n+error[E0658]: subslice patterns are unstable\n   --> $DIR/feature-gate-slice-patterns.rs:7:13\n    |\n LL |         [1, .., 5] => {}\n@@ -16,7 +16,7 @@ LL |         [1, .., 5] => {}\n    = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n \n-error[E0658]: syntax for subslices in slice patterns is not yet stabilized\n+error[E0658]: subslice patterns are unstable\n   --> $DIR/feature-gate-slice-patterns.rs:8:10\n    |\n LL |         [.., 4, 5] => {}\n@@ -25,29 +25,29 @@ LL |         [.., 4, 5] => {}\n    = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n \n-error[E0658]: syntax for subslices in slice patterns is not yet stabilized\n+error[E0658]: subslice patterns are unstable\n   --> $DIR/feature-gate-slice-patterns.rs:13:11\n    |\n-LL |         [ xs.., 4, 5 ] => {}\n-   |           ^^\n+LL |         [ xs @ .., 4, 5 ] => {}\n+   |           ^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n \n-error[E0658]: syntax for subslices in slice patterns is not yet stabilized\n+error[E0658]: subslice patterns are unstable\n   --> $DIR/feature-gate-slice-patterns.rs:14:14\n    |\n-LL |         [ 1, xs.., 5 ] => {}\n-   |              ^^\n+LL |         [ 1, xs @ .., 5 ] => {}\n+   |              ^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n \n-error[E0658]: syntax for subslices in slice patterns is not yet stabilized\n+error[E0658]: subslice patterns are unstable\n   --> $DIR/feature-gate-slice-patterns.rs:15:17\n    |\n-LL |         [ 1, 2, xs.. ] => {}\n-   |                 ^^\n+LL |         [ 1, 2, xs @ .. ] => {}\n+   |                 ^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable"}, {"sha": "086613180746362a414dbb7abb33dc348402311c", "filename": "src/test/ui/issues/issue-12369.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-12369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-12369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12369.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     let v: isize = match &*sl {\n         &[] => 0,\n         &[a,b,c] => 3,\n-        &[a, ref rest..] => a,\n-        &[10,a, ref rest..] => 10 //~ ERROR: unreachable pattern\n+        &[a, ref rest @ ..] => a,\n+        &[10,a, ref rest @ ..] => 10 //~ ERROR: unreachable pattern\n     };\n }"}, {"sha": "f27425e28c61d3d9b12af0af8aea6658c8c2ce89", "filename": "src/test/ui/issues/issue-12369.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-12369.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-12369.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12369.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,8 @@\n error: unreachable pattern\n   --> $DIR/issue-12369.rs:10:9\n    |\n-LL |         &[10,a, ref rest..] => 10\n-   |         ^^^^^^^^^^^^^^^^^^^\n+LL |         &[10,a, ref rest @ ..] => 10\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/issue-12369.rs:2:9"}, {"sha": "b11b1cda38ae127d39b64c94f873227064444b9c", "filename": "src/test/ui/issues/issue-15080.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15080.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -7,11 +7,11 @@ fn main() {\n     let mut result = vec![];\n     loop {\n         x = match *x {\n-            [1, n, 3, ref rest..] => {\n+            [1, n, 3, ref rest @ ..] => {\n                 result.push(n);\n                 rest\n             }\n-            [n, ref rest..] => {\n+            [n, ref rest @ ..] => {\n                 result.push(n);\n                 rest\n             }"}, {"sha": "ee977541137db66e351a7a3e7f004873d0e6d8c1", "filename": "src/test/ui/issues/issue-15104.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-15104.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-15104.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15104.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -9,6 +9,6 @@ fn count_members(v: &[usize]) -> usize {\n     match *v {\n         []         => 0,\n         [_]        => 1,\n-        [_, ref xs..] => 1 + count_members(xs)\n+        [_, ref xs @ ..] => 1 + count_members(xs)\n     }\n }"}, {"sha": "fefa3f2f8730465b7bcb9916a2a96c9adca23041", "filename": "src/test/ui/issues/issue-17877.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-17877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-17877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17877.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -7,8 +7,8 @@ fn main() {\n     }, 42_usize);\n \n     assert_eq!(match [0u8; 1024] {\n-        [1, _..] => 0_usize,\n-        [0, _..] => 1_usize,\n+        [1, ..] => 0_usize,\n+        [0, ..] => 1_usize,\n         _ => 2_usize\n     }, 1_usize);\n }"}, {"sha": "11f47b6d02a73f12e11f11a4de968e33285c4416", "filename": "src/test/ui/issues/issue-26158.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fissues%2Fissue-26158.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fissues%2Fissue-26158.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26158.rs?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,6 +0,0 @@\n-#![feature(slice_patterns)]\n-\n-fn main() {\n-    let x: &[u32] = &[];\n-    let &[[ref _a, ref _b..]..] = x; //~ ERROR refutable pattern\n-}"}, {"sha": "3a4dd79e8105365441a64a1126f6f9de7572b295", "filename": "src/test/ui/issues/issue-26158.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fissues%2Fissue-26158.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fissues%2Fissue-26158.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26158.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,9 +0,0 @@\n-error[E0005]: refutable pattern in local binding: `&[]` not covered\n-  --> $DIR/issue-26158.rs:5:9\n-   |\n-LL |     let &[[ref _a, ref _b..]..] = x;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ pattern `&[]` not covered\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0005`."}, {"sha": "31b3aba6bc20422b27433e05eec5d5eb2b3cc020", "filename": "src/test/ui/issues/issue-37598.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-37598.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-37598.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37598.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,11 +1,10 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n-#![allow(dead_code)]\n+// check-pass\n #![feature(slice_patterns)]\n \n fn check(list: &[u8]) {\n     match list {\n         &[] => {},\n-        &[_u1, _u2, ref _next..] => {},\n+        &[_u1, _u2, ref _next @ ..] => {},\n         &[_u1] => {},\n     }\n }"}, {"sha": "5b70bd6e5ff54923a8ed319fc23d84966d305138", "filename": "src/test/ui/issues/issue-7784.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fissues%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7784.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     assert_eq!(d, \"baz\");\n \n     let out = bar(\"baz\", \"foo\");\n-    let [a, xs.., d] = out;\n+    let [a, xs @ .., d] = out;\n     assert_eq!(a, \"baz\");\n     assert_eq!(xs, [\"foo\", \"foo\"]);\n     assert_eq!(d, \"baz\");"}, {"sha": "a0ef92743ac5a775517d94c1a5ba277078da5f61", "filename": "src/test/ui/match/match-vec-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -19,10 +19,10 @@ fn main() {\n     match [0, 1, 2] {\n         [0] => {}, //~ ERROR pattern requires\n \n-        [0, 1, x..] => {\n+        [0, 1, x @ ..] => {\n             let a: [_; 1] = x;\n         }\n-        [0, 1, 2, 3, x..] => {} //~ ERROR pattern requires\n+        [0, 1, 2, 3, x @ ..] => {} //~ ERROR pattern requires\n     };\n \n     match does_not_exist { //~ ERROR cannot find value `does_not_exist` in this scope"}, {"sha": "2f1bbb7621659c6641661486201b0c0f61f6890e", "filename": "src/test/ui/match/match-vec-mismatch.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-mismatch.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -19,8 +19,8 @@ LL |         [0] => {},\n error[E0528]: pattern requires at least 4 elements but array has 3\n   --> $DIR/match-vec-mismatch.rs:25:9\n    |\n-LL |         [0, 1, 2, 3, x..] => {}\n-   |         ^^^^^^^^^^^^^^^^^ pattern cannot match array of 3 elements\n+LL |         [0, 1, 2, 3, x @ ..] => {}\n+   |         ^^^^^^^^^^^^^^^^^^^^ pattern cannot match array of 3 elements\n \n error[E0282]: type annotations needed\n   --> $DIR/match-vec-mismatch.rs:36:9"}, {"sha": "78810525bad0f76b4653d3ab4abbf5df382c9f85", "filename": "src/test/ui/match/match-vec-unreachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-vec-unreachable.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     let x: Vec<char> = vec!['a', 'b', 'c'];\n     let x: &[char] = &x;\n     match *x {\n-        ['a', 'b', 'c', ref _tail..] => {}\n+        ['a', 'b', 'c', ref _tail @ ..] => {}\n         ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern\n         _ => {}\n     }"}, {"sha": "8cc5f4042cccb1f4ab94b7fef19a7d9b0c1dd9b4", "filename": "src/test/ui/non-exhaustive/non-exhaustive-match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-match.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -32,14 +32,14 @@ fn main() {\n     let vec = vec![Some(42), None, Some(21)];\n     let vec: &[Option<isize>] = &vec;\n     match *vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n-        [Some(..), None, ref tail..] => {}\n-        [Some(..), Some(..), ref tail..] => {}\n+        [Some(..), None, ref tail @ ..] => {}\n+        [Some(..), Some(..), ref tail @ ..] => {}\n         [None] => {}\n     }\n     let vec = vec![1];\n     let vec: &[isize] = &vec;\n     match *vec {\n-        [_, ref tail..] => (),\n+        [_, ref tail @ ..] => (),\n         [] => ()\n     }\n     let vec = vec![0.5f32];\n@@ -53,10 +53,10 @@ fn main() {\n     let vec = vec![Some(42), None, Some(21)];\n     let vec: &[Option<isize>] = &vec;\n     match *vec {\n-        [Some(..), None, ref tail..] => {}\n-        [Some(..), Some(..), ref tail..] => {}\n-        [None, None, ref tail..] => {}\n-        [None, Some(..), ref tail..] => {}\n+        [Some(..), None, ref tail @ ..] => {}\n+        [Some(..), Some(..), ref tail @ ..] => {}\n+        [None, None, ref tail @ ..] => {}\n+        [None, Some(..), ref tail @ ..] => {}\n         [Some(_)] => {}\n         [None] => {}\n         [] => {}"}, {"sha": "4ca1cbcebccf51a94b249e9f5d6dc30535b11137", "filename": "src/test/ui/non-exhaustive/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-exhaustive%2Fnon-exhaustive-pattern-witness.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -77,7 +77,7 @@ fn vectors_with_nested_enums() {\n         [Enum::Second(true), Enum::First] => (),\n         [Enum::Second(true), Enum::Second(true)] => (),\n         [Enum::Second(false), _] => (),\n-        [_, _, ref tail.., _] => ()\n+        [_, _, ref tail @ .., _] => ()\n     }\n }\n "}, {"sha": "00f4374b256d20a115f312bb480cdc6ea5a773d7", "filename": "src/test/ui/parser/match-vec-invalid.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fmatch-vec-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fmatch-vec-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmatch-vec-invalid.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,7 +1,13 @@\n fn main() {\n-    let a = Vec::new();\n+    let a: &[u8] = &[];\n     match a {\n-        [1, tail.., tail..] => {}, //~ ERROR: expected one of `,` or `@`, found `..`\n+        [1, tail @ .., tail @ ..] => {},\n+        //~^ ERROR identifier `tail` is bound more than once in the same pattern\n+        //~| ERROR subslice patterns are unstable\n+        //~| ERROR subslice patterns are unstable\n+        //~| ERROR `..` can only be used once per slice pattern\n         _ => ()\n     }\n }\n+\n+const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "0956ac21b7f1e4abecf968a5a21b62a681f5c7dd", "filename": "src/test/ui/parser/match-vec-invalid.stderr", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fmatch-vec-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fmatch-vec-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmatch-vec-invalid.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,45 @@\n-error: expected one of `,` or `@`, found `..`\n-  --> $DIR/match-vec-invalid.rs:4:25\n+error[E0416]: identifier `tail` is bound more than once in the same pattern\n+  --> $DIR/match-vec-invalid.rs:4:24\n    |\n-LL |         [1, tail.., tail..] => {},\n-   |                         ^^ expected one of `,` or `@` here\n+LL |         [1, tail @ .., tail @ ..] => {},\n+   |                        ^^^^ used in a pattern more than once\n \n-error: aborting due to previous error\n+error[E0658]: subslice patterns are unstable\n+  --> $DIR/match-vec-invalid.rs:4:13\n+   |\n+LL |         [1, tail @ .., tail @ ..] => {},\n+   |             ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n+   = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n+\n+error[E0658]: subslice patterns are unstable\n+  --> $DIR/match-vec-invalid.rs:4:24\n+   |\n+LL |         [1, tail @ .., tail @ ..] => {},\n+   |                        ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n+   = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/match-vec-invalid.rs:4:31\n+   |\n+LL |         [1, tail @ .., tail @ ..] => {},\n+   |                    --         ^^ can only be used once per slice pattern\n+   |                    |\n+   |                    previously used here\n+\n+error[E0308]: mismatched types\n+  --> $DIR/match-vec-invalid.rs:13:30\n+   |\n+LL | const RECOVERY_WITNESS: () = 0;\n+   |                              ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 5 previous errors\n \n+Some errors have detailed explanations: E0308, E0416, E0658.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "7b9721830993efc2fc1a70f9b299ea86c39bc2cc", "filename": "src/test/ui/parser/pat-lt-bracket-6.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,3 +1,9 @@\n fn main() {\n+    struct Test(&'static u8, [u8; 0]);\n+    let x = Test(&0, []);\n+\n     let Test(&desc[..]) = x; //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n+    //~^ ERROR subslice patterns are unstable\n }\n+\n+const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "201465b2c850c87f13720db143d85e6419b78dc4", "filename": "src/test/ui/parser/pat-lt-bracket-6.stderr", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,28 @@\n error: expected one of `)`, `,`, or `@`, found `[`\n-  --> $DIR/pat-lt-bracket-6.rs:2:19\n+  --> $DIR/pat-lt-bracket-6.rs:5:19\n    |\n LL |     let Test(&desc[..]) = x;\n    |                   ^ expected one of `)`, `,`, or `@` here\n \n-error: aborting due to previous error\n+error[E0658]: subslice patterns are unstable\n+  --> $DIR/pat-lt-bracket-6.rs:5:20\n+   |\n+LL |     let Test(&desc[..]) = x;\n+   |                    ^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/62254\n+   = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-lt-bracket-6.rs:9:30\n+   |\n+LL | const RECOVERY_WITNESS: () = 0;\n+   |                              ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0308, E0658.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "020fdb845e8b5fd4ca73f041532fb0d6cb4dbe3d", "filename": "src/test/ui/parser/pat-lt-bracket-7.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,3 +1,8 @@\n fn main() {\n-    for thing(x[]) in foo {} //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n+    struct Thing(u8, [u8; 0]);\n+    let foo = core::iter::empty();\n+\n+    for Thing(x[]) in foo {} //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n }\n+\n+const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "17557efa49e803e70c1369448fc0a183d3c3aaf6", "filename": "src/test/ui/parser/pat-lt-bracket-7.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,18 @@\n error: expected one of `)`, `,`, or `@`, found `[`\n-  --> $DIR/pat-lt-bracket-7.rs:2:16\n+  --> $DIR/pat-lt-bracket-7.rs:5:16\n    |\n-LL |     for thing(x[]) in foo {}\n+LL |     for Thing(x[]) in foo {}\n    |                ^ expected one of `)`, `,`, or `@` here\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/pat-lt-bracket-7.rs:8:30\n+   |\n+LL | const RECOVERY_WITNESS: () = 0;\n+   |                              ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "a8f3debd3d6341a9997272379d24f41ac6ec3b12", "filename": "src/test/ui/parser/pat-tuple-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-2.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,6 +1,7 @@\n+// check-pass\n+\n fn main() {\n     match (0, 1, 2) {\n         (pat, ..,) => {}\n-        //~^ ERROR trailing comma is not permitted after `..`\n     }\n }"}, {"sha": "c3a5c39a8e32ac8e5953d180c76324a8037f30f0", "filename": "src/test/ui/parser/pat-tuple-2.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a239ef4ded03d155c72b68b5a2dd7aff013e141/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-2.stderr?ref=9a239ef4ded03d155c72b68b5a2dd7aff013e141", "patch": "@@ -1,8 +0,0 @@\n-error: trailing comma is not permitted after `..`\n-  --> $DIR/pat-tuple-2.rs:3:17\n-   |\n-LL |         (pat, ..,) => {}\n-   |                 ^ trailing comma is not permitted after `..`\n-\n-error: aborting due to previous error\n-"}, {"sha": "1486ab231aab4f084fc404433339616c803179c5", "filename": "src/test/ui/parser/pat-tuple-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-3.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     match (0, 1, 2) {\n         (.., pat, ..) => {}\n-        //~^ ERROR `..` can only be used once per tuple or tuple struct pattern\n+        //~^ ERROR `..` can only be used once per tuple pattern\n     }\n }"}, {"sha": "9ac0611c5c933230c2d8b82ab9e149babeca997c", "filename": "src/test/ui/parser/pat-tuple-3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-3.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,10 +1,10 @@\n-error: `..` can only be used once per tuple or tuple struct pattern\n+error: `..` can only be used once per tuple pattern\n   --> $DIR/pat-tuple-3.rs:3:19\n    |\n LL |         (.., pat, ..) => {}\n-   |          --       ^^ can only be used once per pattern\n+   |          --       ^^ can only be used once per tuple pattern\n    |          |\n-   |          previously present here\n+   |          previously used here\n \n error: aborting due to previous error\n "}, {"sha": "2f03160430a22fa4df6befd3495e0f3a5cab158a", "filename": "src/test/ui/parser/pat-tuple-4.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,5 +1,11 @@\n fn main() {\n+    const PAT: u8 = 0;\n+\n     match 0 {\n-        (.. pat) => {} //~ ERROR expected one of `)` or `,`, found `pat`\n+        (.. PAT) => {}\n+        //~^ ERROR `..X` range patterns are not supported\n+        //~| ERROR exclusive range pattern syntax is experimental\n     }\n }\n+\n+const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "af3ecce1846497d485d7ad5bf0671d593b79cc9e", "filename": "src/test/ui/parser/pat-tuple-4.stderr", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-4.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,28 @@\n-error: expected one of `)` or `,`, found `pat`\n-  --> $DIR/pat-tuple-4.rs:3:13\n+error: `..X` range patterns are not supported\n+  --> $DIR/pat-tuple-4.rs:5:10\n    |\n-LL |         (.. pat) => {}\n-   |             ^^^ expected one of `)` or `,` here\n+LL |         (.. PAT) => {}\n+   |          ^^^^^^ help: try using the minimum value for the type: `MIN..PAT`\n \n-error: aborting due to previous error\n+error[E0658]: exclusive range pattern syntax is experimental\n+  --> $DIR/pat-tuple-4.rs:5:10\n+   |\n+LL |         (.. PAT) => {}\n+   |          ^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n+   = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-tuple-4.rs:11:30\n+   |\n+LL | const RECOVERY_WITNESS: () = 0;\n+   |                              ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0308, E0658.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "5334ef93bb3bd1e6c8be8505893dd3bb1065d7fd", "filename": "src/test/ui/parser/pat-tuple-5.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,5 +1,10 @@\n fn main() {\n+    const PAT: u8 = 0;\n+\n     match (0, 1) {\n-        (pat ..) => {} //~ ERROR unexpected token: `)`\n+        (PAT ..) => {}\n+        //~^ ERROR `X..` range patterns are not supported\n+        //~| ERROR exclusive range pattern syntax is experimental\n+        //~| ERROR mismatched types\n     }\n }"}, {"sha": "09ebdc29a21613cbe0dc25278324d6678f593d2d", "filename": "src/test/ui/parser/pat-tuple-5.stderr", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,8 +1,30 @@\n-error: unexpected token: `)`\n-  --> $DIR/pat-tuple-5.rs:3:16\n+error: `X..` range patterns are not supported\n+  --> $DIR/pat-tuple-5.rs:5:10\n    |\n-LL |         (pat ..) => {}\n-   |                ^\n+LL |         (PAT ..) => {}\n+   |          ^^^^^^ help: try using the maximum value for the type: `PAT..MAX`\n \n-error: aborting due to previous error\n+error[E0658]: exclusive range pattern syntax is experimental\n+  --> $DIR/pat-tuple-5.rs:5:10\n+   |\n+LL |         (PAT ..) => {}\n+   |          ^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/37854\n+   = help: add `#![feature(exclusive_range_pattern)]` to the crate attributes to enable\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-tuple-5.rs:5:10\n+   |\n+LL |     match (0, 1) {\n+   |           ------ this match expression has type `({integer}, {integer})`\n+LL |         (PAT ..) => {}\n+   |          ^^^^^^ expected tuple, found u8\n+   |\n+   = note: expected type `({integer}, {integer})`\n+              found type `u8`\n+\n+error: aborting due to 3 previous errors\n \n+Some errors have detailed explanations: E0308, E0658.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "c66652ff4fa01ef73cc0e5200e0d875894a0407a", "filename": "src/test/ui/parser/recover-range-pats.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -0,0 +1,123 @@\n+// Here we test all kinds of range patterns in terms of parsing / recovery.\n+// We want to ensure that:\n+// 1. Things parse as they should.\n+// 2. Or at least we have parser recovery if they don't.\n+\n+#![feature(exclusive_range_pattern)]\n+#![deny(ellipsis_inclusive_range_patterns)]\n+\n+fn main() {}\n+\n+const X: u8 = 0;\n+const Y: u8 = 3;\n+\n+fn exclusive_from_to() {\n+    if let 0..3 = 0 {} // OK.\n+    if let 0..Y = 0 {} // OK.\n+    if let X..3 = 0 {} // OK.\n+    if let X..Y = 0 {} // OK.\n+    if let true..Y = 0 {} //~ ERROR only char and numeric types\n+    if let X..true = 0 {} //~ ERROR only char and numeric types\n+    if let .0..Y = 0 {} //~ ERROR mismatched types\n+    //~^ ERROR float literals must have an integer part\n+    if let X.. .0 = 0 {} //~ ERROR mismatched types\n+    //~^ ERROR float literals must have an integer part\n+}\n+\n+fn inclusive_from_to() {\n+    if let 0..=3 = 0 {} // OK.\n+    if let 0..=Y = 0 {} // OK.\n+    if let X..=3 = 0 {} // OK.\n+    if let X..=Y = 0 {} // OK.\n+    if let true..=Y = 0 {} //~ ERROR only char and numeric types\n+    if let X..=true = 0 {} //~ ERROR only char and numeric types\n+    if let .0..=Y = 0 {} //~ ERROR mismatched types\n+    //~^ ERROR float literals must have an integer part\n+    if let X..=.0 = 0 {} //~ ERROR mismatched types\n+    //~^ ERROR float literals must have an integer part\n+}\n+\n+fn inclusive2_from_to() {\n+    if let 0...3 = 0 {} //~ ERROR `...` range patterns are deprecated\n+    if let 0...Y = 0 {} //~ ERROR `...` range patterns are deprecated\n+    if let X...3 = 0 {} //~ ERROR `...` range patterns are deprecated\n+    if let X...Y = 0 {} //~ ERROR `...` range patterns are deprecated\n+    if let true...Y = 0 {} //~ ERROR only char and numeric types\n+    //~^ ERROR `...` range patterns are deprecated\n+    if let X...true = 0 {} //~ ERROR only char and numeric types\n+    //~^ ERROR `...` range patterns are deprecated\n+    if let .0...Y = 0 {} //~ ERROR mismatched types\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR `...` range patterns are deprecated\n+    if let X... .0 = 0 {} //~ ERROR mismatched types\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR `...` range patterns are deprecated\n+}\n+\n+fn exclusive_from() {\n+    if let 0.. = 0 {} //~ ERROR `X..` range patterns are not supported\n+    if let X.. = 0 {} //~ ERROR `X..` range patterns are not supported\n+    if let true.. = 0 {} //~ ERROR `X..` range patterns are not supported\n+    //~^ ERROR only char and numeric types\n+    if let .0.. = 0 {} //~ ERROR `X..` range patterns are not supported\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR mismatched types\n+}\n+\n+fn inclusive_from() {\n+    if let 0..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n+    if let X..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n+    if let true..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n+    //~| ERROR only char and numeric types\n+    if let .0..= = 0 {} //~ ERROR `X..=` range patterns are not supported\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR mismatched types\n+}\n+\n+fn inclusive2_from() {\n+    if let 0... = 0 {} //~ ERROR `X...` range patterns are not supported\n+    //~^ ERROR `...` range patterns are deprecated\n+    if let X... = 0 {} //~ ERROR `X...` range patterns are not supported\n+    //~^ ERROR `...` range patterns are deprecated\n+    if let true... = 0 {} //~ ERROR `X...` range patterns are not supported\n+    //~^ ERROR `...` range patterns are deprecated\n+    //~| ERROR only char and numeric types\n+    if let .0... = 0 {} //~ ERROR `X...` range patterns are not supported\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR `...` range patterns are deprecated\n+    //~| ERROR mismatched types\n+}\n+\n+fn exclusive_to() {\n+    if let ..0 = 0 {} //~ ERROR `..X` range patterns are not supported\n+    if let ..Y = 0 {} //~ ERROR `..X` range patterns are not supported\n+    if let ..true = 0 {} //~ ERROR `..X` range patterns are not supported\n+    //~| ERROR only char and numeric types\n+    if let .. .0 = 0 {} //~ ERROR `..X` range patterns are not supported\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR mismatched types\n+}\n+\n+fn inclusive_to() {\n+    if let ..=3 = 0 {} //~ ERROR `..=X` range patterns are not supported\n+    if let ..=Y = 0 {} //~ ERROR `..=X` range patterns are not supported\n+    if let ..=true = 0 {} //~ ERROR `..=X` range patterns are not supported\n+    //~| ERROR only char and numeric types\n+    if let ..=.0 = 0 {} //~ ERROR `..=X` range patterns are not supported\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR mismatched types\n+}\n+\n+fn inclusive2_to() {\n+    if let ...3 = 0 {} //~ ERROR `...X` range patterns are not supported\n+    //~^ ERROR `...` range patterns are deprecated\n+    if let ...Y = 0 {} //~ ERROR `...X` range patterns are not supported\n+    //~^ ERROR `...` range patterns are deprecated\n+    if let ...true = 0 {} //~ ERROR `...X` range patterns are not supported\n+    //~^ ERROR `...` range patterns are deprecated\n+    //~| ERROR only char and numeric types\n+    if let ....3 = 0 {} //~ ERROR `...X` range patterns are not supported\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR `...` range patterns are deprecated\n+    //~| ERROR mismatched types\n+}"}, {"sha": "c50d5e6eb61537d83d3b25ec74343774dce304dd", "filename": "src/test/ui/parser/recover-range-pats.stderr", "status": "added", "additions": 538, "deletions": 0, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -0,0 +1,538 @@\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:21:12\n+   |\n+LL |     if let .0..Y = 0 {}\n+   |            ^^ help: must have an integer part: `0.0`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:23:16\n+   |\n+LL |     if let X.. .0 = 0 {}\n+   |                ^^ help: must have an integer part: `0.0`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:34:12\n+   |\n+LL |     if let .0..=Y = 0 {}\n+   |            ^^ help: must have an integer part: `0.0`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:36:16\n+   |\n+LL |     if let X..=.0 = 0 {}\n+   |                ^^ help: must have an integer part: `0.0`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:49:12\n+   |\n+LL |     if let .0...Y = 0 {}\n+   |            ^^ help: must have an integer part: `0.0`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:52:17\n+   |\n+LL |     if let X... .0 = 0 {}\n+   |                 ^^ help: must have an integer part: `0.0`\n+\n+error: `X..` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:58:12\n+   |\n+LL |     if let 0.. = 0 {}\n+   |            ^^^ help: try using the maximum value for the type: `0..MAX`\n+\n+error: `X..` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:59:12\n+   |\n+LL |     if let X.. = 0 {}\n+   |            ^^^ help: try using the maximum value for the type: `X..MAX`\n+\n+error: `X..` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:60:12\n+   |\n+LL |     if let true.. = 0 {}\n+   |            ^^^^^^ help: try using the maximum value for the type: `true..MAX`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:62:12\n+   |\n+LL |     if let .0.. = 0 {}\n+   |            ^^ help: must have an integer part: `0.0`\n+\n+error: `X..` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:62:12\n+   |\n+LL |     if let .0.. = 0 {}\n+   |            ^^^^ help: try using the maximum value for the type: `0.0..MAX`\n+\n+error: `X..=` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:68:12\n+   |\n+LL |     if let 0..= = 0 {}\n+   |            ^^^^ help: try using the maximum value for the type: `0..=MAX`\n+\n+error: `X..=` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:69:12\n+   |\n+LL |     if let X..= = 0 {}\n+   |            ^^^^ help: try using the maximum value for the type: `X..=MAX`\n+\n+error: `X..=` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:70:12\n+   |\n+LL |     if let true..= = 0 {}\n+   |            ^^^^^^^ help: try using the maximum value for the type: `true..=MAX`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:72:12\n+   |\n+LL |     if let .0..= = 0 {}\n+   |            ^^ help: must have an integer part: `0.0`\n+\n+error: `X..=` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:72:12\n+   |\n+LL |     if let .0..= = 0 {}\n+   |            ^^^^^ help: try using the maximum value for the type: `0.0..=MAX`\n+\n+error: `X...` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:78:12\n+   |\n+LL |     if let 0... = 0 {}\n+   |            ^^^^ help: try using the maximum value for the type: `0...MAX`\n+\n+error: `X...` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:80:12\n+   |\n+LL |     if let X... = 0 {}\n+   |            ^^^^ help: try using the maximum value for the type: `X...MAX`\n+\n+error: `X...` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:82:12\n+   |\n+LL |     if let true... = 0 {}\n+   |            ^^^^^^^ help: try using the maximum value for the type: `true...MAX`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:85:12\n+   |\n+LL |     if let .0... = 0 {}\n+   |            ^^ help: must have an integer part: `0.0`\n+\n+error: `X...` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:85:12\n+   |\n+LL |     if let .0... = 0 {}\n+   |            ^^^^^ help: try using the maximum value for the type: `0.0...MAX`\n+\n+error: `..X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:92:12\n+   |\n+LL |     if let ..0 = 0 {}\n+   |            ^^^ help: try using the minimum value for the type: `MIN..0`\n+\n+error: `..X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:93:12\n+   |\n+LL |     if let ..Y = 0 {}\n+   |            ^^^ help: try using the minimum value for the type: `MIN..Y`\n+\n+error: `..X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:94:12\n+   |\n+LL |     if let ..true = 0 {}\n+   |            ^^^^^^ help: try using the minimum value for the type: `MIN..true`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:96:15\n+   |\n+LL |     if let .. .0 = 0 {}\n+   |               ^^ help: must have an integer part: `0.0`\n+\n+error: `..X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:96:12\n+   |\n+LL |     if let .. .0 = 0 {}\n+   |            ^^^^^ help: try using the minimum value for the type: `MIN..0.0`\n+\n+error: `..=X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:102:12\n+   |\n+LL |     if let ..=3 = 0 {}\n+   |            ^^^^ help: try using the minimum value for the type: `MIN..=3`\n+\n+error: `..=X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:103:12\n+   |\n+LL |     if let ..=Y = 0 {}\n+   |            ^^^^ help: try using the minimum value for the type: `MIN..=Y`\n+\n+error: `..=X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:104:12\n+   |\n+LL |     if let ..=true = 0 {}\n+   |            ^^^^^^^ help: try using the minimum value for the type: `MIN..=true`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:106:15\n+   |\n+LL |     if let ..=.0 = 0 {}\n+   |               ^^ help: must have an integer part: `0.0`\n+\n+error: `..=X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:106:12\n+   |\n+LL |     if let ..=.0 = 0 {}\n+   |            ^^^^^ help: try using the minimum value for the type: `MIN..=0.0`\n+\n+error: `...X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:112:12\n+   |\n+LL |     if let ...3 = 0 {}\n+   |            ^^^^ help: try using the minimum value for the type: `MIN...3`\n+\n+error: `...X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:114:12\n+   |\n+LL |     if let ...Y = 0 {}\n+   |            ^^^^ help: try using the minimum value for the type: `MIN...Y`\n+\n+error: `...X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:116:12\n+   |\n+LL |     if let ...true = 0 {}\n+   |            ^^^^^^^ help: try using the minimum value for the type: `MIN...true`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-range-pats.rs:119:15\n+   |\n+LL |     if let ....3 = 0 {}\n+   |               ^^ help: must have an integer part: `0.3`\n+\n+error: `...X` range patterns are not supported\n+  --> $DIR/recover-range-pats.rs:119:12\n+   |\n+LL |     if let ....3 = 0 {}\n+   |            ^^^^^ help: try using the minimum value for the type: `MIN...0.3`\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:41:13\n+   |\n+LL |     if let 0...3 = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+   |\n+note: lint level defined here\n+  --> $DIR/recover-range-pats.rs:7:9\n+   |\n+LL | #![deny(ellipsis_inclusive_range_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:42:13\n+   |\n+LL |     if let 0...Y = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:43:13\n+   |\n+LL |     if let X...3 = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:44:13\n+   |\n+LL |     if let X...Y = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:45:16\n+   |\n+LL |     if let true...Y = 0 {}\n+   |                ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:47:13\n+   |\n+LL |     if let X...true = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:49:14\n+   |\n+LL |     if let .0...Y = 0 {}\n+   |              ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:52:13\n+   |\n+LL |     if let X... .0 = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:78:13\n+   |\n+LL |     if let 0... = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:80:13\n+   |\n+LL |     if let X... = 0 {}\n+   |             ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:82:16\n+   |\n+LL |     if let true... = 0 {}\n+   |                ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:85:14\n+   |\n+LL |     if let .0... = 0 {}\n+   |              ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:112:12\n+   |\n+LL |     if let ...3 = 0 {}\n+   |            ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:114:12\n+   |\n+LL |     if let ...Y = 0 {}\n+   |            ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:116:12\n+   |\n+LL |     if let ...true = 0 {}\n+   |            ^^^ help: use `..=` for an inclusive range\n+\n+error: `...` range patterns are deprecated\n+  --> $DIR/recover-range-pats.rs:119:12\n+   |\n+LL |     if let ....3 = 0 {}\n+   |            ^^^ help: use `..=` for an inclusive range\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:19:12\n+   |\n+LL |     if let true..Y = 0 {}\n+   |            ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: bool\n+   = note: end type: u8\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:20:15\n+   |\n+LL |     if let X..true = 0 {}\n+   |               ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: u8\n+   = note: end type: bool\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:21:12\n+   |\n+LL |     if let .0..Y = 0 {}\n+   |            ^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:23:12\n+   |\n+LL |     if let X.. .0 = 0 {}\n+   |            ^^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `u8`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:32:12\n+   |\n+LL |     if let true..=Y = 0 {}\n+   |            ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: bool\n+   = note: end type: u8\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:33:16\n+   |\n+LL |     if let X..=true = 0 {}\n+   |                ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: u8\n+   = note: end type: bool\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:34:12\n+   |\n+LL |     if let .0..=Y = 0 {}\n+   |            ^^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:36:12\n+   |\n+LL |     if let X..=.0 = 0 {}\n+   |            ^^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `u8`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:45:12\n+   |\n+LL |     if let true...Y = 0 {}\n+   |            ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: bool\n+   = note: end type: u8\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:47:16\n+   |\n+LL |     if let X...true = 0 {}\n+   |                ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: u8\n+   = note: end type: bool\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:49:12\n+   |\n+LL |     if let .0...Y = 0 {}\n+   |            ^^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:52:12\n+   |\n+LL |     if let X... .0 = 0 {}\n+   |            ^^^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `u8`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:60:12\n+   |\n+LL |     if let true.. = 0 {}\n+   |            ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: bool\n+   = note: end type: [type error]\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:62:12\n+   |\n+LL |     if let .0.. = 0 {}\n+   |            ^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:70:12\n+   |\n+LL |     if let true..= = 0 {}\n+   |            ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: bool\n+   = note: end type: [type error]\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:72:12\n+   |\n+LL |     if let .0..= = 0 {}\n+   |            ^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:82:12\n+   |\n+LL |     if let true... = 0 {}\n+   |            ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: bool\n+   = note: end type: [type error]\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:85:12\n+   |\n+LL |     if let .0... = 0 {}\n+   |            ^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:94:14\n+   |\n+LL |     if let ..true = 0 {}\n+   |              ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: [type error]\n+   = note: end type: bool\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:96:12\n+   |\n+LL |     if let .. .0 = 0 {}\n+   |            ^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:104:15\n+   |\n+LL |     if let ..=true = 0 {}\n+   |               ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: [type error]\n+   = note: end type: bool\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:106:12\n+   |\n+LL |     if let ..=.0 = 0 {}\n+   |            ^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error[E0029]: only char and numeric types are allowed in range patterns\n+  --> $DIR/recover-range-pats.rs:116:15\n+   |\n+LL |     if let ...true = 0 {}\n+   |               ^^^^ ranges require char or numeric types\n+   |\n+   = note: start type: [type error]\n+   = note: end type: bool\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-range-pats.rs:119:12\n+   |\n+LL |     if let ....3 = 0 {}\n+   |            ^^^^^ expected integer, found floating-point number\n+   |\n+   = note: expected type `{integer}`\n+              found type `{float}`\n+\n+error: aborting due to 76 previous errors\n+\n+Some errors have detailed explanations: E0029, E0308.\n+For more information about an error, try `rustc --explain E0029`."}, {"sha": "7fded752d675e2c005ca6719fa588b94b9d3c84b", "filename": "src/test/ui/parser/recover-tuple-pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,12 +1,12 @@\n+// NOTE: This doesn't recover anymore.\n+\n fn main() {\n     let x = (1, 2, 3, 4);\n     match x {\n         (1, .., 4) => {}\n         (1, .=., 4) => { let _: usize = \"\"; }\n         //~^ ERROR expected pattern, found `.`\n-        //~| ERROR mismatched types\n         (.=., 4) => {}\n-        //~^ ERROR expected pattern, found `.`\n         (1, 2, 3, 4) => {}\n     }\n }"}, {"sha": "93a6a66a63082ca3d2b99950e00447fd3c5f1ef0", "filename": "src/test/ui/parser/recover-tuple-pat.stderr", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-tuple-pat.stderr?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -1,24 +1,8 @@\n error: expected pattern, found `.`\n-  --> $DIR/recover-tuple-pat.rs:5:13\n+  --> $DIR/recover-tuple-pat.rs:7:13\n    |\n LL |         (1, .=., 4) => { let _: usize = \"\"; }\n    |             ^ expected pattern\n \n-error: expected pattern, found `.`\n-  --> $DIR/recover-tuple-pat.rs:8:10\n-   |\n-LL |         (.=., 4) => {}\n-   |          ^ expected pattern\n-\n-error[E0308]: mismatched types\n-  --> $DIR/recover-tuple-pat.rs:5:41\n-   |\n-LL |         (1, .=., 4) => { let _: usize = \"\"; }\n-   |                                         ^^ expected usize, found reference\n-   |\n-   = note: expected type `usize`\n-              found type `&'static str`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "1484b8c4a1f13e6f519ce65dee4914826b5925bf", "filename": "src/test/ui/rfc-2005-default-binding-mode/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fslice.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -4,6 +4,6 @@ pub fn main() {\n     let sl: &[u8] = b\"foo\";\n \n     match sl { //~ ERROR non-exhaustive patterns\n-        [first, remainder..] => {},\n+        [first, remainder @ ..] => {},\n     };\n }"}, {"sha": "38b0941aad0a6060a1aea3ee7eb6ab2b68695478", "filename": "src/test/ui/rfcs/rfc-2005-default-binding-mode/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Fslice.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -5,7 +5,7 @@ fn slice_pat() {\n     let sl: &[u8] = b\"foo\";\n \n     match sl {\n-        [first, remainder..] => {\n+        [first, remainder @ ..] => {\n             let _: &u8 = first;\n             assert_eq!(first, &b'f');\n             assert_eq!(remainder, b\"oo\");"}, {"sha": "929c35a9e1122cbac1f1bac170fa9dff0d19d7cd", "filename": "src/test/ui/trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ftrailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e23ff411d8466a513d9315b472e31d8f7fb2bc/src%2Ftest%2Fui%2Ftrailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrailing-comma.rs?ref=75e23ff411d8466a513d9315b472e31d8f7fb2bc", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n     let (_, _,) = (1, 1,);\n     let [_, _,] = [1, 1,];\n     let [_, _, .., _,] = [1, 1, 1, 1,];\n-    let [_, _, _.., _,] = [1, 1, 1, 1,];\n+    let [_, _, _, ..,] = [1, 1, 1, 1,];\n \n     let x: Foo<isize,> = Foo::<isize,>(1);\n "}]}