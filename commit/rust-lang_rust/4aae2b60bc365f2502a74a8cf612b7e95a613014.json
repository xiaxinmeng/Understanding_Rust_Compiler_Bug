{"sha": "4aae2b60bc365f2502a74a8cf612b7e95a613014", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYWUyYjYwYmMzNjVmMjUwMmE3NGE4Y2Y2MTJiN2U5NWE2MTMwMTQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2016-08-11T11:41:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-11T11:41:32Z"}, "message": "Merge pull request #1158 from scurest/evalorder\n\nAdd lint for reads and writes that depend on evaluation order", "tree": {"sha": "c6971703c886a2f83ac4e53d55b935e25b6cd682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6971703c886a2f83ac4e53d55b935e25b6cd682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4aae2b60bc365f2502a74a8cf612b7e95a613014", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4aae2b60bc365f2502a74a8cf612b7e95a613014", "html_url": "https://github.com/rust-lang/rust/commit/4aae2b60bc365f2502a74a8cf612b7e95a613014", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4aae2b60bc365f2502a74a8cf612b7e95a613014/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce3be22021aa2aba6b9b5aa7247b8fe14e21aca8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3be22021aa2aba6b9b5aa7247b8fe14e21aca8", "html_url": "https://github.com/rust-lang/rust/commit/ce3be22021aa2aba6b9b5aa7247b8fe14e21aca8"}, {"sha": "b0a96def09237932d02f6ffa5013ea6f5673e314", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a96def09237932d02f6ffa5013ea6f5673e314", "html_url": "https://github.com/rust-lang/rust/commit/b0a96def09237932d02f6ffa5013ea6f5673e314"}], "stats": {"total": 307, "additions": 306, "deletions": 1}, "files": [{"sha": "40cf282a069df26756b15d2be5ebaedaa3149408", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4aae2b60bc365f2502a74a8cf612b7e95a613014/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4aae2b60bc365f2502a74a8cf612b7e95a613014/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4aae2b60bc365f2502a74a8cf612b7e95a613014", "patch": "@@ -170,6 +170,7 @@ All notable changes to this project will be documented in this file.\n [`enum_glob_use`]: https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use\n [`enum_variant_names`]: https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names\n [`eq_op`]: https://github.com/Manishearth/rust-clippy/wiki#eq_op\n+[`eval_order_dependence`]: https://github.com/Manishearth/rust-clippy/wiki#eval_order_dependence\n [`expl_impl_clone_on_copy`]: https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy\n [`explicit_counter_loop`]: https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop\n [`explicit_iter_loop`]: https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop"}, {"sha": "4e6f864fec3dc02929f13b70f3cb29c61e189e48", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aae2b60bc365f2502a74a8cf612b7e95a613014/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4aae2b60bc365f2502a74a8cf612b7e95a613014/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4aae2b60bc365f2502a74a8cf612b7e95a613014", "patch": "@@ -17,7 +17,7 @@ Table of contents:\n \n ## Lints\n \n-There are 162 lints included in this crate:\n+There are 163 lints included in this crate:\n \n name                                                                                                                 | default | triggers on\n ---------------------------------------------------------------------------------------------------------------------|---------|----------------------------------------------------------------------------------------------------------------------------------\n@@ -57,6 +57,7 @@ name\n [enum_glob_use](https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use)                                       | allow   | use items that import all variants of an enum\n [enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names)                             | warn    | enums where all variants share a prefix/postfix\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                       | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+[eval_order_dependence](https://github.com/Manishearth/rust-clippy/wiki#eval_order_dependence)                       | warn    | whether a variable read occurs before a write depends on sub-expression evaluation order\n [expl_impl_clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy)                   | warn    | implementing `Clone` explicitly on `Copy` types\n [explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)                       | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n [explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                             | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do"}, {"sha": "4465d31bff577172e9fdea68330a3030d024f41f", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/4aae2b60bc365f2502a74a8cf612b7e95a613014/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae2b60bc365f2502a74a8cf612b7e95a613014/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=4aae2b60bc365f2502a74a8cf612b7e95a613014", "patch": "@@ -0,0 +1,250 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::*;\n+use rustc::lint::*;\n+use utils::{get_parent_expr, span_note_and_lint};\n+\n+/// **What it does:** Checks for a read and a write to the same variable where\n+/// whether the read occurs before or after the write depends on the evaluation\n+/// order of sub-expressions.\n+///\n+/// **Why is this bad?** It is often confusing to read. In addition, the\n+/// sub-expression evaluation order for Rust is not well documented.\n+///\n+/// **Known problems:** Code which intentionally depends on the evaluation\n+/// order, or which is correct for any evaluation order.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let mut x = 0;\n+/// let a = {x = 1; 1} + x;\n+/// // Unclear whether a is 1 or 2.\n+/// ```\n+declare_lint! {\n+    pub EVAL_ORDER_DEPENDENCE,\n+    Warn,\n+    \"whether a variable read occurs before a write depends on sub-expression evaluation order\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct EvalOrderDependence;\n+\n+impl LintPass for EvalOrderDependence {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(EVAL_ORDER_DEPENDENCE)\n+    }\n+}\n+\n+impl LateLintPass for EvalOrderDependence {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        // Find a write to a local variable.\n+        match expr.node {\n+            ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => {\n+                if let ExprPath(None, ref path) = lhs.node {\n+                    if path.segments.len() == 1 {\n+                        let var = cx.tcx.expect_def(lhs.id).def_id();\n+                        let mut visitor = ReadVisitor {\n+                            cx: cx,\n+                            var: var,\n+                            write_expr: expr,\n+                            last_expr: expr,\n+                        };\n+                        check_for_unsequenced_reads(&mut visitor);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+/// Walks up the AST from the the given write expression (`vis.write_expr`)\n+/// looking for reads to the same variable that are unsequenced relative to the\n+/// write.\n+///\n+/// This means reads for which there is a common ancestor between the read and\n+/// the write such that\n+///\n+/// * evaluating the ancestor necessarily evaluates both the read and the write\n+///   (for example, `&x` and `|| x = 1` don't necessarily evaluate `x`), and\n+///\n+/// * which one is evaluated first depends on the order of sub-expression\n+///   evaluation. Blocks, `if`s, loops, `match`es, and the short-circuiting\n+///   logical operators are considered to have a defined evaluation order.\n+///\n+/// When such a read is found, the lint is triggered.\n+fn check_for_unsequenced_reads(vis: &mut ReadVisitor) {\n+    let map = &vis.cx.tcx.map;\n+    let mut cur_id = vis.write_expr.id;\n+    loop {\n+        let parent_id = map.get_parent_node(cur_id);\n+        if parent_id == cur_id {\n+            break;\n+        }\n+        let parent_node = match map.find(parent_id) {\n+            Some(parent) => parent,\n+            None => break,\n+        };\n+\n+        let stop_early = match parent_node {\n+            map::Node::NodeExpr(expr) => check_expr(vis, expr),\n+            map::Node::NodeStmt(stmt) => check_stmt(vis, stmt),\n+            map::Node::NodeItem(_) => {\n+                // We reached the top of the function, stop.\n+                break;\n+            },\n+            _ => { StopEarly::KeepGoing }\n+        };\n+        match stop_early {\n+            StopEarly::Stop => break,\n+            StopEarly::KeepGoing => {},\n+        }\n+\n+        cur_id = parent_id;\n+    }\n+}\n+\n+/// Whether to stop early for the loop in `check_for_unsequenced_reads`. (If\n+/// `check_expr` weren't an independent function, this would be unnecessary and\n+/// we could just use `break`).\n+enum StopEarly {\n+    KeepGoing,\n+    Stop,\n+}\n+\n+fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEarly {\n+    if expr.id == vis.last_expr.id {\n+        return StopEarly::KeepGoing;\n+    }\n+\n+    match expr.node {\n+        ExprVec(_) |\n+        ExprTup(_) |\n+        ExprMethodCall(_, _, _) |\n+        ExprCall(_, _) |\n+        ExprAssign(_, _) |\n+        ExprIndex(_, _) |\n+        ExprRepeat(_, _) |\n+        ExprStruct(_, _, _) => {\n+            walk_expr(vis, expr);\n+        }\n+        ExprBinary(op, _, _) |\n+        ExprAssignOp(op, _, _) => {\n+            if op.node == BiAnd || op.node == BiOr {\n+                // x && y and x || y always evaluate x first, so these are\n+                // strictly sequenced.\n+            } else {\n+                walk_expr(vis, expr);\n+            }\n+        }\n+        ExprClosure(_, _, _, _) => {\n+            // Either\n+            //\n+            // * `var` is defined in the closure body, in which case we've\n+            //   reached the top of the enclosing function and can stop, or\n+            //\n+            // * `var` is captured by the closure, in which case, because\n+            //   evaluating a closure does not evaluate its body, we don't\n+            //   necessarily have a write, so we need to stop to avoid\n+            //   generating false positives.\n+            //\n+            // This is also the only place we need to stop early (grrr).\n+            return StopEarly::Stop;\n+        }\n+        // All other expressions either have only one child or strictly\n+        // sequence the evaluation order of their sub-expressions.\n+        _ => {}\n+    }\n+\n+    vis.last_expr = expr;\n+\n+    StopEarly::KeepGoing\n+}\n+\n+fn check_stmt<'v, 't>(vis: &mut ReadVisitor<'v, 't>, stmt: &'v Stmt) -> StopEarly {\n+    match stmt.node {\n+        StmtExpr(ref expr, _) |\n+        StmtSemi(ref expr, _) => check_expr(vis, expr),\n+        StmtDecl(ref decl, _) => {\n+            // If the declaration is of a local variable, check its initializer\n+            // expression if it has one. Otherwise, keep going.\n+            let local = match decl.node {\n+                DeclLocal(ref local) => Some(local),\n+                _ => None,\n+            };\n+            local.and_then(|local| local.init.as_ref())\n+                .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr))\n+        }\n+    }\n+}\n+\n+/// A visitor that looks for reads from a variable.\n+struct ReadVisitor<'v, 't: 'v> {\n+    cx: &'v LateContext<'v, 't>,\n+    /// The id of the variable we're looking for.\n+    var: DefId,\n+    /// The expressions where the write to the variable occurred (for reporting\n+    /// in the lint).\n+    write_expr: &'v Expr,\n+    /// The last (highest in the AST) expression we've checked, so we know not\n+    /// to recheck it.\n+    last_expr: &'v Expr,\n+}\n+\n+impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if expr.id == self.last_expr.id {\n+            return;\n+        }\n+\n+        match expr.node {\n+            ExprPath(None, ref path) => {\n+                if path.segments.len() == 1 && self.cx.tcx.expect_def(expr.id).def_id() == self.var {\n+                    if is_in_assignment_position(self.cx, expr) {\n+                        // This is a write, not a read.\n+                    } else {\n+                        span_note_and_lint(\n+                            self.cx,\n+                            EVAL_ORDER_DEPENDENCE,\n+                            expr.span,\n+                            \"unsequenced read of a variable\",\n+                            self.write_expr.span,\n+                            \"whether read occurs before this write depends on evaluation order\"\n+                        );\n+                    }\n+                }\n+            }\n+            // We're about to descend a closure. Since we don't know when (or\n+            // if) the closure will be evaluated, any reads in it might not\n+            // occur here (or ever). Like above, bail to avoid false positives.\n+            ExprClosure(_, _, _, _) |\n+\n+            // We want to avoid a false positive when a variable name occurs\n+            // only to have its address taken, so we stop here. Technically,\n+            // this misses some weird cases, eg.\n+            //\n+            // ```rust\n+            // let mut x = 0;\n+            // let a = foo(&{x = 1; x}, x);\n+            // ```\n+            //\n+            // TODO: fix this\n+            ExprAddrOf(_, _) => {\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+}\n+\n+/// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n+fn is_in_assignment_position(cx: &LateContext, expr: &Expr) -> bool {\n+    if let Some(parent) = get_parent_expr(cx, expr) {\n+        if let ExprAssign(ref lhs, _) = parent.node {\n+            return lhs.id == expr.id;\n+        }\n+    }\n+    false\n+}"}, {"sha": "260b5c1ba57f4f366444f45a9f501bb8fa48171b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aae2b60bc365f2502a74a8cf612b7e95a613014/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae2b60bc365f2502a74a8cf612b7e95a613014/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4aae2b60bc365f2502a74a8cf612b7e95a613014", "patch": "@@ -78,6 +78,7 @@ pub mod enum_variants;\n pub mod eq_op;\n pub mod escape;\n pub mod eta_reduction;\n+pub mod eval_order_dependence;\n pub mod format;\n pub mod formatting;\n pub mod functions;\n@@ -256,6 +257,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box arithmetic::Arithmetic::default());\n     reg.register_late_lint_pass(box assign_ops::AssignOps);\n     reg.register_late_lint_pass(box let_if_seq::LetIfSeq);\n+    reg.register_late_lint_pass(box eval_order_dependence::EvalOrderDependence);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -325,6 +327,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         eq_op::EQ_OP,\n         escape::BOXED_LOCAL,\n         eta_reduction::REDUNDANT_CLOSURE,\n+        eval_order_dependence::EVAL_ORDER_DEPENDENCE,\n         format::USELESS_FORMAT,\n         formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n         formatting::SUSPICIOUS_ELSE_FORMATTING,"}, {"sha": "0b2605d01bd58f8ce218e98d8d044e5963e505ca", "filename": "tests/compile-fail/eval_order_dependence.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4aae2b60bc365f2502a74a8cf612b7e95a613014/tests%2Fcompile-fail%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae2b60bc365f2502a74a8cf612b7e95a613014/tests%2Fcompile-fail%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feval_order_dependence.rs?ref=4aae2b60bc365f2502a74a8cf612b7e95a613014", "patch": "@@ -0,0 +1,50 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(eval_order_dependence)]\n+#[allow(unused_assignments, unused_variables, many_single_char_names, no_effect, dead_code, blacklisted_name)]\n+fn main() {\n+    let mut x = 0;\n+    let a = { x = 1; 1 } + x;\n+                        //~^ ERROR unsequenced read\n+\n+    // Example from iss#277\n+    x += { x = 20; 2 }; //~ERROR unsequenced read\n+\n+    // Does it work in weird places?\n+    // ...in the base for a struct expression?\n+    struct Foo { a: i32, b: i32 };\n+    let base = Foo { a: 4, b: 5 };\n+    let foo = Foo { a: x, .. { x = 6; base } };\n+                    //~^ ERROR unsequenced read\n+    // ...inside a closure?\n+    let closure = || {\n+        let mut x = 0;\n+        x += { x = 20; 2 }; //~ERROR unsequenced read\n+    };\n+    // ...not across a closure?\n+    let mut y = 0;\n+    let b = (y, || { y = 1 });\n+\n+    // && and || evaluate left-to-right.\n+    let a = { x = 1; true } && (x == 3);\n+    let a = { x = 1; true } || (x == 3);\n+\n+    // Make sure we don't get confused by alpha conversion.\n+    let a = { let mut x = 1; x = 2; 1 } + x;\n+\n+    // No warning if we don't read the variable...\n+    x = { x = 20; 2 };\n+    // ...if the assignment is in a closure...\n+    let b = { || { x = 1; }; 1 } + x;\n+    // ... or the access is under an address.\n+    let b = ({ let p = &x; 1 }, { x = 1; x });\n+\n+    // Limitation: l-values other than simple variables don't trigger\n+    // the warning.\n+    let mut tup = (0, 0);\n+    let c = { tup.0 = 1; 1 } + tup.0;\n+    // Limitation: you can get away with a read under address-of.\n+    let mut z = 0;\n+    let b = (&{ z = x; x }, { x = 3; x });\n+}"}]}