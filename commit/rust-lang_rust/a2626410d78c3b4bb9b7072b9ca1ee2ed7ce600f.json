{"sha": "a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjI2NDEwZDc4YzNiNGJiOWI3MDcyYjljYTFlZTJlZDdjZTYwMGY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-15T04:34:52Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-20T11:46:06Z"}, "message": "Refactor `MetaItemKind` to use `Name`s instead of `InternedString`s.", "tree": {"sha": "61e0f8af79f0924bedcdccdbdf9d0699cde9beab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61e0f8af79f0924bedcdccdbdf9d0699cde9beab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "html_url": "https://github.com/rust-lang/rust/commit/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff4994235aa27b911422c8b4241c5d8f3d112d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4994235aa27b911422c8b4241c5d8f3d112d65", "html_url": "https://github.com/rust-lang/rust/commit/ff4994235aa27b911422c8b4241c5d8f3d112d65"}], "stats": {"total": 393, "additions": 187, "deletions": 206}, "files": [{"sha": "abc35634d15f456e21372a311f77bff177392a6e", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -64,7 +64,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                 None => continue,\n             };\n \n-            let (message, label) = match &*name {\n+            let (message, label) = match &*name.as_str() {\n                 \"C\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Struct &&\n@@ -120,7 +120,7 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n-        let name: &str = &attr.name();\n+        let name: &str = &attr.name().as_str();\n         match name {\n             \"inline\" => self.check_inline(attr, target),\n             \"repr\" => self.check_repr(attr, target),"}, {"sha": "4a082944010b2838fb73d12cc26d84f9d7bea0eb", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -40,7 +40,6 @@ use std::default::Default as StdDefault;\n use std::mem;\n use std::fmt;\n use syntax::attr;\n-use syntax::parse::token::InternedString;\n use syntax::ast;\n use syntax_pos::{MultiSpan, Span};\n use errors::{self, Diagnostic, DiagnosticBuilder};\n@@ -384,8 +383,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n /// attributes. Writing this as an iterator is an enormous mess.\n // See also the hir version just below.\n-pub fn gather_attrs(attrs: &[ast::Attribute])\n-                    -> Vec<Result<(InternedString, Level, Span), Span>> {\n+pub fn gather_attrs(attrs: &[ast::Attribute]) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n     for attr in attrs {\n         let r = gather_attr(attr);\n@@ -394,11 +392,10 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n     out\n }\n \n-pub fn gather_attr(attr: &ast::Attribute)\n-                   -> Vec<Result<(InternedString, Level, Span), Span>> {\n+pub fn gather_attr(attr: &ast::Attribute) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n \n-    let level = match Level::from_str(&attr.name()) {\n+    let level = match Level::from_str(&attr.name().as_str()) {\n         None => return out,\n         Some(lvl) => lvl,\n     };\n@@ -414,9 +411,7 @@ pub fn gather_attr(attr: &ast::Attribute)\n     };\n \n     for li in metas {\n-        out.push(li.word().map_or(Err(li.span), |word| {\n-            Ok((word.name().clone(), level, word.span))\n-        }));\n+        out.push(li.word().map_or(Err(li.span), |word| Ok((word.name(), level, word.span))));\n     }\n \n     out\n@@ -629,10 +624,10 @@ pub trait LintContext: Sized {\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints().find_lint(&lint_name, &self.sess(), Some(span)) {\n+                    match self.lints().find_lint(&lint_name.as_str(), &self.sess(), Some(span)) {\n                         Ok(lint_id) => vec![(lint_id, level, span)],\n                         Err(FindLintError::NotFound) => {\n-                            match self.lints().lint_groups.get(&lint_name[..]) {\n+                            match self.lints().lint_groups.get(&*lint_name.as_str()) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n@@ -1193,8 +1188,7 @@ fn check_lint_name_attribute(cx: &LateContext, attr: &ast::Attribute) {\n                 continue;\n             }\n             Ok((lint_name, _, span)) => {\n-                match check_lint_name(&cx.lints,\n-                                      &lint_name[..]) {\n+                match check_lint_name(&cx.lints, &lint_name.as_str()) {\n                     CheckLintNameResult::Ok => (),\n                     CheckLintNameResult::Warning(ref msg) => {\n                         cx.span_lint(builtin::RENAMED_AND_REMOVED_LINTS,"}, {"sha": "09c1bd0dd126c921dca66c958af55381a6626c58", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -309,8 +309,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n     for attr in lint::gather_attrs(attrs) {\n         match attr {\n-            Ok((ref name, lint::Allow, _))\n-                if &name[..] == dead_code => return true,\n+            Ok((name, lint::Allow, _)) if name == &*dead_code => return true,\n             _ => (),\n         }\n     }"}, {"sha": "1502811baee25d0d48a5ac74b045c442a83b7c47", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -26,7 +26,7 @@ use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n use syntax::attr;\n-use syntax::parse;\n+use syntax::parse::{self, token};\n use syntax::parse::token::InternedString;\n use syntax::feature_gate::UnstableFeatures;\n \n@@ -947,41 +947,40 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n \n     let mk = attr::mk_name_value_item_str;\n     let mut ret = vec![ // Target bindings.\n-        mk(InternedString::new(\"target_os\"), intern(os)),\n-        mk(InternedString::new(\"target_family\"), fam.clone()),\n-        mk(InternedString::new(\"target_arch\"), intern(arch)),\n-        mk(InternedString::new(\"target_endian\"), intern(end)),\n-        mk(InternedString::new(\"target_pointer_width\"), intern(wordsz)),\n-        mk(InternedString::new(\"target_env\"), intern(env)),\n-        mk(InternedString::new(\"target_vendor\"), intern(vendor)),\n+        mk(token::intern(\"target_os\"), intern(os)),\n+        mk(token::intern(\"target_family\"), fam.clone()),\n+        mk(token::intern(\"target_arch\"), intern(arch)),\n+        mk(token::intern(\"target_endian\"), intern(end)),\n+        mk(token::intern(\"target_pointer_width\"), intern(wordsz)),\n+        mk(token::intern(\"target_env\"), intern(env)),\n+        mk(token::intern(\"target_vendor\"), intern(vendor)),\n     ];\n     match &fam[..] {\n-        \"windows\" | \"unix\" => ret.push(attr::mk_word_item(fam)),\n+        \"windows\" | \"unix\" => ret.push(attr::mk_word_item(token::intern(&fam))),\n         _ => (),\n     }\n     if sess.target.target.options.has_elf_tls {\n-        ret.push(attr::mk_word_item(InternedString::new(\"target_thread_local\")));\n+        ret.push(attr::mk_word_item(token::intern(\"target_thread_local\")));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i <= max_atomic_width {\n             let s = i.to_string();\n-            ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(&s)));\n+            ret.push(mk(token::intern(\"target_has_atomic\"), intern(&s)));\n             if &s == wordsz {\n-                ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(\"ptr\")));\n+                ret.push(mk(token::intern(\"target_has_atomic\"), intern(\"ptr\")));\n             }\n         }\n     }\n     if sess.opts.debug_assertions {\n-        ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n+        ret.push(attr::mk_word_item(token::intern(\"debug_assertions\")));\n     }\n     if sess.opts.crate_types.contains(&CrateTypeProcMacro) {\n-        ret.push(attr::mk_word_item(InternedString::new(\"proc_macro\")));\n+        ret.push(attr::mk_word_item(token::intern(\"proc_macro\")));\n     }\n     return ret;\n }\n \n-pub fn append_configuration(cfg: &mut ast::CrateConfig,\n-                            name: InternedString) {\n+pub fn append_configuration(cfg: &mut ast::CrateConfig, name: ast::Name) {\n     if !cfg.iter().any(|mi| mi.name() == name) {\n         cfg.push(attr::mk_word_item(name))\n     }\n@@ -995,7 +994,7 @@ pub fn build_configuration(sess: &Session,\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg\n     if sess.opts.test {\n-        append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n+        append_configuration(&mut user_cfg, token::intern(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n     v.extend_from_slice(&default_cfg[..]);"}, {"sha": "436b44d8b03b91a2b1e5f6d6a4a51106eb21fd8f", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -13,8 +13,7 @@ use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n use rustc_trans::back::write::create_target_machine;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token::intern_and_get_ident as intern;\n+use syntax::parse::token::{self, intern_and_get_ident as intern};\n use libc::c_char;\n \n // WARNING: the features must be known to LLVM or the feature\n@@ -41,11 +40,11 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n         _ => &[],\n     };\n \n-    let tf = InternedString::new(\"target_feature\");\n+    let tf = token::intern(\"target_feature\");\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len() - 1])))\n+            cfg.push(attr::mk_name_value_item_str(tf, intern(&feat[..feat.len() - 1])))\n         }\n     }\n "}, {"sha": "87e6b2befdc3281fcbbb9359c11bf499d4eaccfd", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -57,7 +57,6 @@ use std::env;\n use std::fs::File;\n use std::io::Write;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use {ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n \n@@ -97,7 +96,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n type Sources = Vec<(Span, DefId, DepNode<DefId>)>;\n-type Targets = Vec<(Span, InternedString, ast::NodeId, DepNode<DefId>)>;\n+type Targets = Vec<(Span, ast::Name, ast::NodeId, DepNode<DefId>)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -106,7 +105,7 @@ struct IfThisChanged<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n-    fn argument(&self, attr: &ast::Attribute) -> Option<InternedString> {\n+    fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.word() {\n@@ -127,8 +126,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => DepNode::Hir(def_id),\n-                    Some(ref n) => {\n-                        match DepNode::from_label_string(&n[..], def_id) {\n+                    Some(n) => {\n+                        match DepNode::from_label_string(&n.as_str(), def_id) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -142,8 +141,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n             } else if attr.check_name(ATTR_THEN_THIS_WOULD_NEED) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    Some(ref n) => {\n-                        match DepNode::from_label_string(&n[..], def_id) {\n+                    Some(n) => {\n+                        match DepNode::from_label_string(&n.as_str(), def_id) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -159,7 +158,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                     }\n                 };\n                 self.then_this_would_need.push((attr.span,\n-                                                dep_node_interned.clone().unwrap(),\n+                                                dep_node_interned.unwrap(),\n                                                 node_id,\n                                                 dep_node));\n             }"}, {"sha": "55dd222b0db5e5d8abbcd8a888a940c3d6ab24e6", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -875,16 +875,19 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         // ignoring span information, it doesn't matter here\n         self.hash_discriminant(&meta_item.node);\n         match meta_item.node {\n-            ast::MetaItemKind::Word(ref s) => {\n+            ast::MetaItemKind::Word(s) => {\n+                let s = &*s.as_str();\n                 s.len().hash(self.st);\n                 s.hash(self.st);\n             }\n-            ast::MetaItemKind::NameValue(ref s, ref lit) => {\n+            ast::MetaItemKind::NameValue(s, ref lit) => {\n+                let s = &*s.as_str();\n                 s.len().hash(self.st);\n                 s.hash(self.st);\n                 lit.node.hash(self.st);\n             }\n-            ast::MetaItemKind::List(ref s, ref items) => {\n+            ast::MetaItemKind::List(s, ref items) => {\n+                let s = &*s.as_str();\n                 s.len().hash(self.st);\n                 s.hash(self.st);\n                 // Sort subitems so the hash does not depend on their order\n@@ -916,7 +919,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         for i in indices {\n             let attr = &attributes[i];\n             if !attr.is_sugared_doc &&\n-               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name()) {\n+               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name().as_str()) {\n                 SawAttribute(attr.style).hash(self.st);\n                 self.hash_meta_item(&*attr.value);\n             }"}, {"sha": "3bf7cc0f74c75f0acd9a42c8bef2f6c4c174cbec", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -772,9 +772,9 @@ impl LintPass for DeprecatedAttr {\n \n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n-        let name = &*attr.name();\n+        let name = attr.name();\n         for &&(n, _, ref g) in &self.depr_attrs {\n-            if n == name {\n+            if name == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link),\n                                              ref name,\n                                              ref reason,"}, {"sha": "5ff131b06848e88420a1be863797a10e20db497c", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -274,7 +274,7 @@ impl LateLintPass for UnusedAttributes {\n             // Has a plugin registered this attribute as one which must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| &*attr.name() == x && AttributeType::CrateLevel == t)\n+                .find(|&&(ref x, t)| attr.name() == &**x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n                 let msg = match attr.style {"}, {"sha": "525b8f8227b0896d3076a0b5b823b82270d15e4c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -37,7 +37,7 @@ use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::parse::token::{InternedString, intern};\n+use syntax::parse::token::{self, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n@@ -582,11 +582,11 @@ impl<'a> CrateLoader<'a> {\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream,\n                                       attributes: &[&'static str]) {\n-                let attrs = attributes.iter().map(|s| InternedString::new(s)).collect();\n+                let attrs = attributes.iter().cloned().map(token::intern).collect();\n                 let derive = SyntaxExtension::CustomDerive(\n                     Box::new(CustomDerive::new(expand, attrs))\n                 );\n-                self.0.push((intern(trait_name), Rc::new(derive)));\n+                self.0.push((token::intern(trait_name), Rc::new(derive)));\n             }\n         }\n "}, {"sha": "1bfc445fca98d72ca4f7c8f03a92b63dda875fc1", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -69,9 +69,9 @@ pub fn load_plugins(sess: &Session,\n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n                 match plugin.name() {\n-                    Some(ref name) if !plugin.is_value_str() => {\n+                    Some(name) if !plugin.is_value_str() => {\n                         let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                        loader.load_plugin(plugin.span, name, args.unwrap_or_default());\n+                        loader.load_plugin(plugin.span, &name.as_str(), args.unwrap_or_default());\n                     },\n                     _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }"}, {"sha": "8a973ab4d954b267e6a380e6cdc058e2fc5fb051", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -31,7 +31,6 @@ use std::rc::Rc;\n \n use syntax::ast::Name;\n use syntax::attr;\n-use syntax::parse::token;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n@@ -632,7 +631,7 @@ impl<'b> Resolver<'b> {\n                 match attr.meta_item_list() {\n                     Some(names) => for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.imports.push((token::intern(&word.name()), attr.span()));\n+                            imports.imports.push((word.name(), attr.span()));\n                         } else {\n                             span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n                         }\n@@ -646,7 +645,7 @@ impl<'b> Resolver<'b> {\n                 if let Some(names) = attr.meta_item_list() {\n                     for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.reexports.push((token::intern(&word.name()), attr.span()));\n+                            imports.reexports.push((word.name(), attr.span()));\n                         } else {\n                             bad_macro_reexport(self, attr.span());\n                         }"}, {"sha": "1a8116872be436ec303b5cc6e3773bba62c5b6ed", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -27,7 +27,6 @@ use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::fold::Folder;\n-use syntax::parse::token::intern;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n@@ -207,8 +206,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n-            let name = intern(&attrs[i].name());\n-            match self.builtin_macros.get(&name).cloned() {\n+            match self.builtin_macros.get(&attrs[i].name()).cloned() {\n                 Some(binding) => match *self.get_macro(binding) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))"}, {"sha": "e5589b04108e7e965d7a9a63a03cae172c7fb93e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -54,7 +54,7 @@ use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n-use syntax::parse::token::{self, keywords, InternedString};\n+use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n@@ -728,7 +728,7 @@ impl Visitor for PathCollector {\n }\n \n fn docs_for_attrs(attrs: &[Attribute]) -> String {\n-    let doc = InternedString::new(\"doc\");\n+    let doc = token::intern(\"doc\");\n     let mut result = String::new();\n \n     for attr in attrs {"}, {"sha": "8de843fdcb8c4057898169738ac712b459f111de", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -75,6 +75,12 @@ impl Decodable for Name {\n     }\n }\n \n+impl<'a> ::std::cmp::PartialEq<&'a str> for Name {\n+    fn eq(&self, other: &&str) -> bool {\n+        *self.as_str() == **other\n+    }\n+}\n+\n impl Ident {\n     pub const fn with_empty_ctxt(name: Name) -> Ident {\n         Ident { name: name, ctxt: SyntaxContext::empty() }\n@@ -518,15 +524,15 @@ pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n     /// E.g. `test` as in `#[test]`\n-    Word(InternedString),\n+    Word(Name),\n     /// List meta item.\n     ///\n     /// E.g. `derive(..)` as in `#[derive(..)]`\n-    List(InternedString, Vec<NestedMetaItem>),\n+    List(Name, Vec<NestedMetaItem>),\n     /// Name value meta item.\n     ///\n     /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n-    NameValue(InternedString, Lit),\n+    NameValue(Name, Lit),\n }\n \n // can't be derived because the MetaItemKind::List requires an unordered comparison"}, {"sha": "220ecf52ae06b083ad499fc5cf72fa6cdbb26949", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -15,7 +15,7 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute};\n+use ast::{AttrId, Attribute, Name};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n use codemap::{respan, spanned, dummy_spanned, mk_sp};\n@@ -37,8 +37,8 @@ thread_local! {\n }\n \n enum AttrError {\n-    MultipleItem(InternedString),\n-    UnknownMetaItem(InternedString),\n+    MultipleItem(Name),\n+    UnknownMetaItem(Name),\n     MissingSince,\n     MissingFeature,\n     MultipleStabilityLevels,\n@@ -134,7 +134,7 @@ impl NestedMetaItem {\n \n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n-    pub fn name(&self) -> Option<InternedString> {\n+    pub fn name(&self) -> Option<Name> {\n         self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n     }\n \n@@ -186,14 +186,14 @@ impl NestedMetaItem {\n \n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n-        let matches = name == &self.name()[..];\n+        let matches = self.name() == name;\n         if matches {\n             mark_used(self);\n         }\n         matches\n     }\n \n-    pub fn name(&self) -> InternedString { self.meta().name() }\n+    pub fn name(&self) -> Name { self.meta().name() }\n \n     pub fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n@@ -218,11 +218,11 @@ impl Attribute {\n }\n \n impl MetaItem {\n-    pub fn name(&self) -> InternedString {\n+    pub fn name(&self) -> Name {\n         match self.node {\n-            MetaItemKind::Word(ref n) => (*n).clone(),\n-            MetaItemKind::NameValue(ref n, _) => (*n).clone(),\n-            MetaItemKind::List(ref n, _) => (*n).clone(),\n+            MetaItemKind::Word(n) => n,\n+            MetaItemKind::NameValue(n, _) => n,\n+            MetaItemKind::List(n, _) => n,\n         }\n     }\n \n@@ -255,7 +255,7 @@ impl MetaItem {\n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        name == &self.name()[..]\n+        self.name() == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -282,7 +282,7 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                InternedString::new(\"doc\"),\n+                token::intern(\"doc\"),\n                 token::intern_and_get_ident(&strip_doc_comment_decoration(\n                         &comment)));\n             if self.style == ast::AttrStyle::Outer {\n@@ -298,40 +298,36 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> P<MetaItem> {\n+pub fn mk_name_value_item_str(name: Name, value: InternedString) -> P<MetaItem> {\n     let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n     mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n-                          -> P<MetaItem> {\n+pub fn mk_name_value_item(name: Name, value: ast::Lit) -> P<MetaItem> {\n     mk_spanned_name_value_item(DUMMY_SP, name, value)\n }\n \n-pub fn mk_list_item(name: InternedString, items: Vec<NestedMetaItem>) -> P<MetaItem> {\n+pub fn mk_list_item(name: Name, items: Vec<NestedMetaItem>) -> P<MetaItem> {\n     mk_spanned_list_item(DUMMY_SP, name, items)\n }\n \n-pub fn mk_list_word_item(name: InternedString) -> ast::NestedMetaItem {\n+pub fn mk_list_word_item(name: Name) -> ast::NestedMetaItem {\n     dummy_spanned(NestedMetaItemKind::MetaItem(mk_spanned_word_item(DUMMY_SP, name)))\n }\n \n-pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n+pub fn mk_word_item(name: Name) -> P<MetaItem> {\n     mk_spanned_word_item(DUMMY_SP, name)\n }\n \n-pub fn mk_spanned_name_value_item(sp: Span, name: InternedString, value: ast::Lit)\n-                          -> P<MetaItem> {\n+pub fn mk_spanned_name_value_item(sp: Span, name: Name, value: ast::Lit) -> P<MetaItem> {\n     P(respan(sp, MetaItemKind::NameValue(name, value)))\n }\n \n-pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<NestedMetaItem>)\n-                            -> P<MetaItem> {\n+pub fn mk_spanned_list_item(sp: Span, name: Name, items: Vec<NestedMetaItem>) -> P<MetaItem> {\n     P(respan(sp, MetaItemKind::List(name, items)))\n }\n \n-pub fn mk_spanned_word_item(sp: Span, name: InternedString) -> P<MetaItem> {\n+pub fn mk_spanned_word_item(sp: Span, name: Name) -> P<MetaItem> {\n     P(respan(sp, MetaItemKind::Word(name)))\n }\n \n@@ -398,7 +394,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos, hi: By\n     Attribute {\n         id: id,\n         style: style,\n-        value: P(spanned(lo, hi, MetaItemKind::NameValue(InternedString::new(\"doc\"), lit))),\n+        value: P(spanned(lo, hi, MetaItemKind::NameValue(token::intern(\"doc\"), lit))),\n         is_sugared_doc: true,\n         span: mk_sp(lo, hi),\n     }\n@@ -490,11 +486,11 @@ pub enum InlineAttr {\n pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia,attr| {\n         match attr.value.node {\n-            MetaItemKind::Word(ref n) if n == \"inline\" => {\n+            MetaItemKind::Word(n) if n == \"inline\" => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n             }\n-            MetaItemKind::List(ref n, ref items) if n == \"inline\" => {\n+            MetaItemKind::List(n, ref items) if n == \"inline\" => {\n                 mark_used(attr);\n                 if items.len() != 1 {\n                     diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n@@ -537,7 +533,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &pred[..] {\n+            match &*pred.as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     cfg_matches(mi.meta_item().unwrap(), sess, features)\n                 }),\n@@ -611,7 +607,6 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n \n     'outer: for attr in attrs_iter {\n         let tag = attr.name();\n-        let tag = &*tag;\n         if tag != \"rustc_deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n@@ -633,7 +628,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             };\n \n-            match tag {\n+            match &*tag.as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -645,7 +640,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut reason = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 _ => {\n@@ -688,7 +683,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n@@ -743,7 +738,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n@@ -839,7 +834,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.name() {\n+                    match &*mi.name().as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n@@ -897,7 +892,7 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n     match attr.value.node {\n-        ast::MetaItemKind::List(ref s, ref items) if s == \"repr\" => {\n+        ast::MetaItemKind::List(s, ref items) if s == \"repr\" => {\n             mark_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n@@ -906,7 +901,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                 }\n \n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.name();\n+                    let word = &*mi.name().as_str();\n                     let hint = match word {\n                         // Can't use \"extern\" because it's not a lexical identifier.\n                         \"C\" => Some(ReprExtern),"}, {"sha": "75e931351717c87a25aed93968dc55d45ccf4802", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -277,18 +277,18 @@ pub trait AstBuilder {\n \n     fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem>;\n+    fn meta_word(&self, sp: Span, w: ast::Name) -> P<ast::MetaItem>;\n \n-    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem;\n+    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem;\n \n     fn meta_list(&self,\n                  sp: Span,\n-                 name: InternedString,\n+                 name: ast::Name,\n                  mis: Vec<ast::NestedMetaItem> )\n                  -> P<ast::MetaItem>;\n     fn meta_name_value(&self,\n                        sp: Span,\n-                       name: InternedString,\n+                       name: ast::Name,\n                        value: ast::LitKind)\n                        -> P<ast::MetaItem>;\n \n@@ -1150,20 +1150,20 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         attr::mk_spanned_attr_outer(sp, attr::mk_attr_id(), mi)\n     }\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n+    fn meta_word(&self, sp: Span, w: ast::Name) -> P<ast::MetaItem> {\n         attr::mk_spanned_word_item(sp, w)\n     }\n \n-    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem {\n+    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n         respan(sp, ast::NestedMetaItemKind::MetaItem(attr::mk_spanned_word_item(sp, w)))\n     }\n \n-    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<ast::NestedMetaItem>)\n+    fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n                  -> P<ast::MetaItem> {\n         attr::mk_spanned_list_item(sp, name, mis)\n     }\n \n-    fn meta_name_value(&self, sp: Span, name: InternedString, value: ast::LitKind)\n+    fn meta_name_value(&self, sp: Span, name: ast::Name, value: ast::LitKind)\n                        -> P<ast::MetaItem> {\n         attr::mk_spanned_name_value_item(sp, name, respan(sp, value))\n     }"}, {"sha": "a2d42e1459208cb8baa68a23100e309e1cb59640", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -23,7 +23,7 @@ use fold;\n use fold::*;\n use parse::{ParseSess, PResult, lexer};\n use parse::parser::Parser;\n-use parse::token::{self, intern, keywords};\n+use parse::token::{self, keywords};\n use print::pprust;\n use ptr::P;\n use std_inject;\n@@ -246,7 +246,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.cx.resolver.resolve_macro(scope, &mac.node.path, force)\n                 }\n                 InvocationKind::Attr { ref attr, .. } => {\n-                    let ident = ast::Ident::with_empty_ctxt(intern(&*attr.name()));\n+                    let ident = ast::Ident::with_empty_ctxt(attr.name());\n                     let path = ast::Path::from_ident(attr.span, ident);\n                     self.cx.resolver.resolve_macro(scope, &path, force)\n                 }\n@@ -341,7 +341,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        let name = intern(&attr.name());\n+        let name = attr.name();\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {"}, {"sha": "b002378601a80dccc058c264d55065daf7c15df8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -757,7 +757,7 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.name();\n+        let name = &*cfg.name().as_str();\n         GATED_CFGS.iter()\n                   .position(|info| info.0 == name)\n                   .map(|idx| {\n@@ -804,7 +804,7 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = &*attr.name();\n+        let name = &*attr.name().as_str();\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if n == name {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n@@ -1351,7 +1351,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n             Some(list) => {\n                 for mi in list {\n                     let name = if let Some(word) = mi.word() {\n-                        word.name()\n+                        word.name().as_str()\n                     } else {\n                         span_err!(span_handler, mi.span, E0556,\n                                   \"malformed feature, expected just one word\");"}, {"sha": "c72c4646a236f57f8259b5b355cb767e3f6142a9", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -227,22 +227,21 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         let ident = self.parse_ident()?;\n-        let name = self.id_to_interned_str(ident);\n         match self.token {\n             token::Eq => {\n                 self.bump();\n                 let lit = self.parse_unsuffixed_lit()?;\n                 let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n+                Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(ident.name, lit))))\n             }\n             token::OpenDelim(token::Paren) => {\n                 let inner_items = self.parse_meta_seq()?;\n                 let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::List(name, inner_items))))\n+                Ok(P(spanned(lo, hi, ast::MetaItemKind::List(ident.name, inner_items))))\n             }\n             _ => {\n                 let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::Word(name))))\n+                Ok(P(spanned(lo, hi, ast::MetaItemKind::Word(ident.name))))\n             }\n         }\n     }"}, {"sha": "c86302f4e2596b3bfc7832bf1ea9aed93f6da2be", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -19,7 +19,7 @@ use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n use errors;\n-use parse::token::{self, keywords, BinOpToken, Token, InternedString};\n+use parse::token::{self, keywords, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n@@ -119,14 +119,13 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_list_word_item(InternedString::new(\"prelude_import\"));\n-        let list = attr::mk_list_item(InternedString::new(\"feature\"),\n-                                      vec![prelude_import_meta]);\n+        let prelude_import_meta = attr::mk_list_word_item(token::intern(\"prelude_import\"));\n+        let list = attr::mk_list_item(token::intern(\"feature\"), vec![prelude_import_meta]);\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), list);\n         try!(s.print_attribute(&fake_attr));\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(InternedString::new(\"no_std\"));\n+        let no_std_meta = attr::mk_word_item(token::intern(\"no_std\"));\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), no_std_meta);\n         try!(s.print_attribute(&fake_attr));\n     }\n@@ -779,15 +778,15 @@ pub trait PrintState<'a> {\n         try!(self.ibox(INDENT_UNIT));\n         match item.node {\n             ast::MetaItemKind::Word(ref name) => {\n-                try!(word(self.writer(), &name));\n+                try!(word(self.writer(), &name.as_str()));\n             }\n             ast::MetaItemKind::NameValue(ref name, ref value) => {\n-                try!(self.word_space(&name[..]));\n+                try!(self.word_space(&name.as_str()));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n             ast::MetaItemKind::List(ref name, ref items) => {\n-                try!(word(self.writer(), &name));\n+                try!(word(self.writer(), &name.as_str()));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                               &items[..],"}, {"sha": "8cc0e01b24e52c0c1da397f7cc9d7d2c0ac0c7ae", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -12,7 +12,7 @@ use ast;\n use attr;\n use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n-use parse::token::{intern, InternedString, keywords};\n+use parse::token::{intern, keywords};\n use parse::{token, ParseSess};\n use ptr::P;\n \n@@ -57,7 +57,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n \n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(attr::mk_attr_id(),\n-                                        attr::mk_word_item(InternedString::new(\"macro_use\")))],\n+                                        attr::mk_word_item(token::intern(\"macro_use\")))],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::ExternCrate(Some(crate_name)),\n         ident: token::str_to_ident(name),\n@@ -70,7 +70,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,\n             value: P(ast::MetaItem {\n-                node: ast::MetaItemKind::Word(token::intern_and_get_ident(\"prelude_import\")),\n+                node: ast::MetaItemKind::Word(token::intern(\"prelude_import\")),\n                 span: span,\n             }),\n             id: attr::mk_attr_id(),"}, {"sha": "194bd4a90855e61138d56ca1facf7042d4a94262", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -191,8 +191,8 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n-                    let allow_str = InternedString::new(\"allow\");\n-                    let dead_code_str = InternedString::new(\"dead_code\");\n+                    let allow_str = token::intern(\"allow\");\n+                    let dead_code_str = token::intern(\"dead_code\");\n                     let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n                     let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n                     let allow_dead_code = attr::mk_attr_outer(attr::mk_attr_id(),\n@@ -229,8 +229,8 @@ fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident\n     // Generate imports with `#[allow(private_in_public)]` to work around issue #36768.\n     let allow_private_in_public = cx.ext_cx.attribute(DUMMY_SP, cx.ext_cx.meta_list(\n         DUMMY_SP,\n-        InternedString::new(\"allow\"),\n-        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, InternedString::new(\"private_in_public\"))],\n+        token::intern(\"allow\"),\n+        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, token::intern(\"private_in_public\"))],\n     ));\n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n@@ -496,7 +496,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n                                        vec![tests_ident_expr]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n     // #![main]\n-    let main_meta = ecx.meta_word(sp, token::intern_and_get_ident(\"main\"));\n+    let main_meta = ecx.meta_word(sp, token::intern(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));"}, {"sha": "c2a166e0819b5bc2cb34f38592a24f0279b99411", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -15,7 +15,7 @@ use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{keywords, InternedString};\n+use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -74,7 +74,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, token::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "a1be573551eb0863586e7c0ffc9d28ce3ced5932", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -14,7 +14,7 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -23,9 +23,9 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n-    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n+    let inline = cx.meta_word(span, token::intern(\"inline\"));\n+    let hidden = cx.meta_list_item_word(span, token::intern(\"hidden\"));\n+    let doc = cx.meta_list(span, token::intern(\"doc\"), vec![hidden]);\n     let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "85d29f5e21394b756e6d175347b9244112cf85de", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -14,7 +14,7 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -23,7 +23,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            mitem: &MetaItem,\n                            item: &Annotatable,\n                            push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, token::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "1b6ccfd012cd20d6f60e4cef6869d44da8a9aab5", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -14,7 +14,7 @@ use deriving::generic::ty::*;\n use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -64,7 +64,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n \n     macro_rules! md {\n         ($name:expr, $f:ident) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let inline = cx.meta_word(span, token::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,"}, {"sha": "7d76722ee97d688767aadb20f926035aaabea691", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -16,7 +16,7 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -27,7 +27,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    push: &mut FnMut(Annotatable)) {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let inline = cx.meta_word(span, token::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,\n@@ -51,7 +51,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                     vec![Box::new(ordering_ty)],\n                                     true));\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, token::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n \n     let partial_cmp_def = MethodDef {"}, {"sha": "1076a6a6d63a5bef4e90c8816dc9304af46c4b8d", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -17,10 +17,9 @@ use syntax::attr::{mark_used, mark_known};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::fold::Folder;\n-use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n \n-struct MarkAttrs<'a>(&'a [InternedString]);\n+struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n@@ -33,13 +32,11 @@ impl<'a> Visitor for MarkAttrs<'a> {\n \n pub struct CustomDerive {\n     inner: fn(TokenStream) -> TokenStream,\n-    attrs: Vec<InternedString>,\n+    attrs: Vec<ast::Name>,\n }\n \n impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream,\n-               attrs: Vec<InternedString>)\n-               -> CustomDerive {\n+    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> CustomDerive {\n         CustomDerive { inner: inner, attrs: attrs }\n     }\n }"}, {"sha": "0b97213394b4d960f3a7bcf9bb7d5573bfa94d3f", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -14,7 +14,7 @@ use deriving::generic::ty::*;\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -23,7 +23,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                mitem: &MetaItem,\n                                item: &Annotatable,\n                                push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, token::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "b245e399f1cdc89617254ccf04b87737177daab1", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -198,7 +198,7 @@ use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, dummy_spanned, respan};\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{InternedString, keywords};\n+use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n use syntax_pos::{DUMMY_SP, Span};\n use errors::Handler;\n@@ -442,7 +442,7 @@ impl<'a> TraitDef<'a> {\n                 attrs.extend(item.attrs\n                     .iter()\n                     .filter(|a| {\n-                        match &a.name()[..] {\n+                        match &*a.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n                             _ => false,\n                         }\n@@ -639,15 +639,15 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(self.span,\n                                 cx.meta_word(self.span,\n-                                             InternedString::new(\"automatically_derived\")));\n+                                             token::intern(\"automatically_derived\")));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let unused_qual = cx.attribute(self.span,\n-                                       cx.meta_list(self.span,\n-                                                    InternedString::new(\"allow\"),\n-                                                    vec![cx.meta_list_item_word(self.span,\n-                                           InternedString::new(\"unused_qualifications\"))]));\n+        let unused_qual = {\n+            let word = cx.meta_list_item_word(self.span, token::intern(\"unused_qualifications\"));\n+            cx.attribute(self.span, cx.meta_list(self.span, token::intern(\"allow\"), vec![word]))\n+        };\n+\n         let mut a = vec![attr, unused_qual];\n         a.extend(self.attributes.iter().cloned());\n "}, {"sha": "32dcdcfd1107e84cd640afa67d96df251461a729", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -16,7 +16,7 @@ use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate::{self, emit_feature_err};\n-use syntax::parse::token::{intern, intern_and_get_ident};\n+use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -80,7 +80,7 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n         expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(intern(attr_name)),\n+                format: codemap::MacroAttribute(token::intern(attr_name)),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n             },\n@@ -105,9 +105,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         }\n     };\n \n+    let derive = token::intern(\"derive\");\n     let mut derive_attrs = Vec::new();\n     item = item.map_attrs(|attrs| {\n-        let partition = attrs.into_iter().partition(|attr| &attr.name() == \"derive\");\n+        let partition = attrs.into_iter().partition(|attr| attr.name() == derive);\n         derive_attrs = partition.0;\n         partition.1\n     });\n@@ -158,9 +159,8 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         let tword = titem.word().unwrap();\n         let tname = tword.name();\n \n-        if is_builtin_trait(&tname) || {\n-            let derive_mode =\n-                ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(intern(&tname)));\n+        if is_builtin_trait(tname) || {\n+            let derive_mode = ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(tname));\n             cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n                 if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n             }).unwrap_or(false)\n@@ -176,7 +176,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                            feature_gate::EXPLAIN_CUSTOM_DERIVE);\n         } else {\n             cx.span_warn(titem.span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n+            let name = token::intern(&format!(\"derive_{}\", tname));\n             let mitem = cx.meta_word(titem.span, name);\n             new_attributes.push(cx.attribute(mitem.span, mitem));\n         }\n@@ -186,9 +186,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         item = item.map(|mut i| {\n             i.attrs.extend(new_attributes);\n             if traits.len() > 0 {\n-                let list = cx.meta_list(mitem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        traits);\n+                let list = cx.meta_list(mitem.span, derive, traits);\n                 i.attrs.push(cx.attribute(mitem.span, list));\n             }\n             i\n@@ -217,7 +215,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     let macros_11_derive = traits.iter()\n                                  .cloned()\n                                  .enumerate()\n-                                 .filter(|&(_, ref name)| !is_builtin_trait(&name.name().unwrap()))\n+                                 .filter(|&(_, ref name)| !is_builtin_trait(name.name().unwrap()))\n                                  .next();\n     if let Some((i, titem)) = macros_11_derive {\n         if !cx.ecfg.features.unwrap().proc_macro {\n@@ -226,24 +224,20 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n             emit_feature_err(cx.parse_sess, \"proc_macro\", titem.span, issue, msg);\n         }\n \n-        let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n+        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n         let path = ast::Path::from_ident(titem.span, tname);\n         let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n \n         traits.remove(i);\n         if traits.len() > 0 {\n             item = item.map(|mut i| {\n-                let list = cx.meta_list(mitem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        traits);\n+                let list = cx.meta_list(mitem.span, derive, traits);\n                 i.attrs.push(cx.attribute(mitem.span, list));\n                 i\n             });\n         }\n         let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n-        let mitem = cx.meta_list(titem.span,\n-                                 intern_and_get_ident(\"derive\"),\n-                                 vec![titem]);\n+        let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n         let item = Annotatable::Item(item);\n         if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n             return ext.expand(cx, mitem.span, &mitem, item);\n@@ -257,9 +251,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n     // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n     // `#[structural_match]` attribute.\n-    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"PartialEq\") &&\n-       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Eq\") {\n-        let structural_match = intern_and_get_ident(\"structural_match\");\n+    let (partial_eq, eq) = (token::intern(\"PartialEq\"), token::intern(\"Eq\"));\n+    if traits.iter().any(|t| t.name() == Some(partial_eq)) &&\n+       traits.iter().any(|t| t.name() == Some(eq)) {\n+        let structural_match = token::intern(\"structural_match\");\n         let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n         let meta = cx.meta_word(span, structural_match);\n         item = item.map(|mut i| {\n@@ -272,9 +267,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     // the same as the copy implementation.\n     //\n     // Add a marker attribute here picked up during #[derive(Clone)]\n-    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"Clone\") &&\n-       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Copy\") {\n-        let marker = intern_and_get_ident(\"rustc_copy_clone_marker\");\n+    let (copy, clone) = (token::intern(\"Copy\"), token::intern(\"Clone\"));\n+    if traits.iter().any(|t| t.name() == Some(clone)) &&\n+       traits.iter().any(|t| t.name() == Some(copy)) {\n+        let marker = token::intern(\"rustc_copy_clone_marker\");\n         let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n         let meta = cx.meta_word(span, marker);\n         item = item.map(|mut i| {\n@@ -286,14 +282,14 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     let mut items = Vec::new();\n     for titem in traits.iter() {\n         let tname = titem.word().unwrap().name();\n-        let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n+        let name = token::intern(&format!(\"derive({})\", tname));\n         let mitem = cx.meta_word(titem.span, name);\n \n         let span = Span {\n             expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n                 call_site: titem.span,\n                 callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                    format: codemap::MacroAttribute(token::intern(&format!(\"derive({})\", tname))),\n                     span: Some(titem.span),\n                     allow_internal_unstable: true,\n                 },\n@@ -302,7 +298,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         };\n \n         let my_item = Annotatable::Item(item);\n-        expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n+        expand_builtin(&tname.as_str(), cx, span, &mitem, &my_item, &mut |a| {\n             items.push(a);\n         });\n         item = my_item.expect_item();\n@@ -314,8 +310,8 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n-        pub fn is_builtin_trait(name: &str) -> bool {\n-            match name {\n+        pub fn is_builtin_trait(name: ast::Name) -> bool {\n+            match &*name.as_str() {\n                 $( $name )|+ => true,\n                 _ => false,\n             }\n@@ -412,7 +408,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     span.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: span,\n         callee: codemap::NameAndSpan {\n-            format: codemap::MacroAttribute(intern(\"derive\")),\n+            format: codemap::MacroAttribute(token::intern(\"derive\")),\n             span: Some(span),\n             allow_internal_unstable: true,\n         },"}, {"sha": "1165eb46bf011466e1336893ad9aaed053287595", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=a2626410d78c3b4bb9b7072b9ca1ee2ed7ce600f", "patch": "@@ -17,7 +17,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::parse::ParseSess;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::parse::token;\n use syntax::feature_gate::Features;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n@@ -27,10 +27,10 @@ use syntax::visit::{self, Visitor};\n use deriving;\n \n struct CustomDerive {\n-    trait_name: InternedString,\n+    trait_name: ast::Name,\n     function_name: Ident,\n     span: Span,\n-    attrs: Vec<InternedString>,\n+    attrs: Vec<ast::Name>,\n }\n \n struct CollectCustomDerives<'a> {\n@@ -183,7 +183,7 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n             self.handler.span_err(trait_attr.span(), \"must only be one word\");\n         }\n \n-        if deriving::is_builtin_trait(&trait_name) {\n+        if deriving::is_builtin_trait(trait_name) {\n             self.handler.span_err(trait_attr.span(),\n                                   \"cannot override a built-in #[derive] mode\");\n         }\n@@ -290,10 +290,10 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let register_custom_derive = token::str_to_ident(\"register_custom_derive\");\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n-        let trait_name = cx.expr_str(cd.span, cd.trait_name.clone());\n+        let trait_name = cx.expr_str(cd.span, cd.trait_name.as_str());\n         let attrs = cx.expr_vec_slice(\n             span,\n-            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.clone())).collect::<Vec<_>>()\n+            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.as_str())).collect::<Vec<_>>()\n         );\n         (path, trait_name, attrs)\n     }).map(|(path, trait_name, attrs)| {\n@@ -316,8 +316,7 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                           cx.ty(span, ast::TyKind::Tup(Vec::new())),\n                           cx.block(span, stmts));\n \n-    let derive_registrar = token::intern_and_get_ident(\"rustc_derive_registrar\");\n-    let derive_registrar = cx.meta_word(span, derive_registrar);\n+    let derive_registrar = cx.meta_word(span, token::intern(\"rustc_derive_registrar\"));\n     let derive_registrar = cx.attribute(span, derive_registrar);\n     let func = func.map(|mut i| {\n         i.attrs.push(derive_registrar);"}]}