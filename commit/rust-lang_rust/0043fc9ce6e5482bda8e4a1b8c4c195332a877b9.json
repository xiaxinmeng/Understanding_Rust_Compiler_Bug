{"sha": "0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNDNmYzljZTZlNTQ4MmJkYThlNGExYjhjNGMxOTUzMzJhODc3Yjk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-22T18:34:06Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-22T18:52:31Z"}, "message": "Get rid of `doctree::Impl`", "tree": {"sha": "87040b1aa577da6dfaf494d5d9f34c6d24122703", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87040b1aa577da6dfaf494d5d9f34c6d24122703"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "html_url": "https://github.com/rust-lang/rust/commit/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e280ae862c735a0bc74b7f4f479459eefb9f9b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/e280ae862c735a0bc74b7f4f479459eefb9f9b65", "html_url": "https://github.com/rust-lang/rust/commit/e280ae862c735a0bc74b7f4f479459eefb9f9b65"}], "stats": {"total": 184, "additions": 60, "deletions": 124}, "files": [{"sha": "e76ca1022a943f147af72b19564c5ec5232a33d4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "patch": "@@ -234,9 +234,8 @@ impl Clean<Item> for doctree::Module<'_> {\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n-        items.extend(self.items.iter().map(|x| x.clean(cx)));\n+        items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n-        items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n         items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n \n@@ -1922,8 +1921,8 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     }\n }\n \n-impl Clean<Item> for (&hir::Item<'_>, Option<Ident>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         use hir::ItemKind;\n \n         let (item, renamed) = self;\n@@ -1977,10 +1976,11 @@ impl Clean<Item> for (&hir::Item<'_>, Option<Ident>) {\n                 fields: variant_data.fields().clean(cx),\n                 fields_stripped: false,\n             }),\n+            ItemKind::Impl { .. } => return clean_impl(item, cx),\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n+        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n     }\n }\n \n@@ -2005,57 +2005,53 @@ impl Clean<ImplPolarity> for ty::ImplPolarity {\n     }\n }\n \n-impl Clean<Vec<Item>> for doctree::Impl<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        let mut ret = Vec::new();\n-        let trait_ = self.trait_.clean(cx);\n-        let items = self.items.iter().map(|ii| ii.clean(cx)).collect::<Vec<_>>();\n-        let def_id = cx.tcx.hir().local_def_id(self.id);\n-\n-        // If this impl block is an implementation of the Deref trait, then we\n-        // need to try inlining the target's inherent impl blocks as well.\n-        if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n-            build_deref_target_impls(cx, &items, &mut ret);\n+fn clean_impl(impl_: &hir::Item<'_>, cx: &DocContext<'_>) -> Vec<Item> {\n+    let mut ret = Vec::new();\n+    let (trait_, items, for_, unsafety, generics) = match &impl_.kind {\n+        hir::ItemKind::Impl { of_trait, items, self_ty, unsafety, generics, .. } => {\n+            (of_trait, items, self_ty, *unsafety, generics)\n         }\n-\n-        let provided: FxHashSet<String> = trait_\n-            .def_id()\n-            .map(|did| {\n-                cx.tcx.provided_trait_methods(did).map(|meth| meth.ident.to_string()).collect()\n-            })\n-            .unwrap_or_default();\n-\n-        let for_ = self.for_.clean(cx);\n-        let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n-            DefKind::TyAlias => Some(cx.tcx.type_of(did).clean(cx)),\n-            _ => None,\n+        _ => unreachable!(),\n+    };\n+    let trait_ = trait_.clean(cx);\n+    let items = items.iter().map(|ii| cx.tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n+    let def_id = cx.tcx.hir().local_def_id(impl_.hir_id);\n+\n+    // If this impl block is an implementation of the Deref trait, then we\n+    // need to try inlining the target's inherent impl blocks as well.\n+    if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+        build_deref_target_impls(cx, &items, &mut ret);\n+    }\n+\n+    let provided: FxHashSet<String> = trait_\n+        .def_id()\n+        .map(|did| cx.tcx.provided_trait_methods(did).map(|meth| meth.ident.to_string()).collect())\n+        .unwrap_or_default();\n+\n+    let for_ = for_.clean(cx);\n+    let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n+        DefKind::TyAlias => Some(cx.tcx.type_of(did).clean(cx)),\n+        _ => None,\n+    });\n+    let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| {\n+        let kind = ImplItem(Impl {\n+            unsafety,\n+            generics: generics.clean(cx),\n+            provided_trait_methods: provided.clone(),\n+            trait_,\n+            for_,\n+            items,\n+            polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n+            synthetic: false,\n+            blanket_impl: None,\n         });\n-        let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| Item {\n-            name: None,\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: def_id.to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: ImplItem(Impl {\n-                unsafety: self.unsafety,\n-                generics: self.generics.clean(cx),\n-                provided_trait_methods: provided.clone(),\n-                trait_,\n-                for_,\n-                items,\n-                polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n-                synthetic: false,\n-                blanket_impl: None,\n-            }),\n-        };\n-        if let Some(type_alias) = type_alias {\n-            ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n-        }\n-        ret.push(make_item(trait_, for_, items));\n-        ret\n+        Item::from_hir_id_and_parts(impl_.hir_id, None, kind, cx)\n+    };\n+    if let Some(type_alias) = type_alias {\n+        ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n     }\n+    ret.push(make_item(trait_, for_, items));\n+    ret\n }\n \n impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {"}, {"sha": "b7cc0f1945911bf909c08e09ceda54b2ba034fe2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "patch": "@@ -1,4 +1,3 @@\n-use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_driver::abort_on_err;\n@@ -156,21 +155,6 @@ impl<'tcx> DocContext<'tcx> {\n             def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n         }\n     }\n-\n-    crate fn stability(&self, id: HirId) -> Option<attr::Stability> {\n-        self.tcx\n-            .hir()\n-            .opt_local_def_id(id)\n-            .and_then(|def_id| self.tcx.lookup_stability(def_id.to_def_id()))\n-            .cloned()\n-    }\n-\n-    crate fn deprecation(&self, id: HirId) -> Option<attr::Deprecation> {\n-        self.tcx\n-            .hir()\n-            .opt_local_def_id(id)\n-            .and_then(|def_id| self.tcx.lookup_deprecation(def_id.to_def_id()))\n-    }\n }\n \n /// Creates a new diagnostic `Handler` that can be used to emit warnings and errors."}, {"sha": "4d2fe04123bc2489c982d8d4da0c2af3ac5f2052", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "patch": "@@ -23,7 +23,6 @@ crate struct Module<'hir> {\n     // (item, renamed)\n     crate items: Vec<(&'hir hir::Item<'hir>, Option<Ident>)>,\n     crate traits: Vec<Trait<'hir>>,\n-    crate impls: Vec<Impl<'hir>>,\n     crate foreigns: Vec<ForeignItem<'hir>>,\n     crate macros: Vec<Macro>,\n     crate proc_macros: Vec<ProcMacro>,\n@@ -44,7 +43,6 @@ impl Module<'hir> {\n             mods: Vec::new(),\n             items: Vec::new(),\n             traits: Vec::new(),\n-            impls: Vec::new(),\n             foreigns: Vec::new(),\n             macros: Vec::new(),\n             proc_macros: Vec::new(),\n@@ -89,22 +87,6 @@ crate struct Trait<'hir> {\n     crate id: hir::HirId,\n }\n \n-#[derive(Debug)]\n-crate struct Impl<'hir> {\n-    crate unsafety: hir::Unsafety,\n-    crate polarity: hir::ImplPolarity,\n-    crate defaultness: hir::Defaultness,\n-    crate constness: hir::Constness,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate trait_: &'hir Option<hir::TraitRef<'hir>>,\n-    crate for_: &'hir hir::Ty<'hir>,\n-    crate items: Vec<&'hir hir::ImplItem<'hir>>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate id: hir::HirId,\n-}\n-\n crate struct ForeignItem<'hir> {\n     crate id: hir::HirId,\n     crate name: Symbol,"}, {"sha": "37050a57ca0173c6c0b0b756ce4fc0b68a34f680", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "patch": "@@ -401,37 +401,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.traits.push(t);\n             }\n-            hir::ItemKind::Impl {\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                constness,\n-                defaultness_span: _,\n-                ref generics,\n-                ref of_trait,\n-                self_ty,\n-                ref items,\n-            } => {\n+            hir::ItemKind::Impl { ref of_trait, .. } => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && of_trait.is_none() {\n-                    let items =\n-                        items.iter().map(|item| self.cx.tcx.hir().impl_item(item.id)).collect();\n-                    let i = Impl {\n-                        unsafety,\n-                        polarity,\n-                        defaultness,\n-                        constness,\n-                        generics,\n-                        trait_: of_trait,\n-                        for_: self_ty,\n-                        items,\n-                        attrs: &item.attrs,\n-                        id: item.hir_id,\n-                        span: item.span,\n-                        vis: &item.vis,\n-                    };\n-                    om.impls.push(i);\n+                    om.items.push((item, None));\n                 }\n             }\n         }"}, {"sha": "be98cac94ece71e522fd97a923b02b48e12c238f", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0043fc9ce6e5482bda8e4a1b8c4c195332a877b9/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=0043fc9ce6e5482bda8e4a1b8c4c195332a877b9", "patch": "@@ -106,6 +106,15 @@ LL | /// [S!]\n    |      this link resolves to the struct `S`, which is not in the macro namespace\n    |      help: to link to the struct, prefix with `struct@`: `struct@S`\n \n+error: unresolved link to `S::h`\n+  --> $DIR/intra-link-errors.rs:78:6\n+   |\n+LL | /// [type@S::h]\n+   |      ^^^^^^^^^\n+   |      |\n+   |      this link resolves to the associated function `h`, which is not in the type namespace\n+   |      help: to link to the associated function, add parentheses: `S::h()`\n+\n error: unresolved link to `T::g`\n   --> $DIR/intra-link-errors.rs:86:6\n    |\n@@ -121,15 +130,6 @@ error: unresolved link to `T::h`\n LL | /// [T::h!]\n    |      ^^^^^ the trait `T` has no macro named `h`\n \n-error: unresolved link to `S::h`\n-  --> $DIR/intra-link-errors.rs:78:6\n-   |\n-LL | /// [type@S::h]\n-   |      ^^^^^^^^^\n-   |      |\n-   |      this link resolves to the associated function `h`, which is not in the type namespace\n-   |      help: to link to the associated function, add parentheses: `S::h()`\n-\n error: unresolved link to `m`\n   --> $DIR/intra-link-errors.rs:98:6\n    |"}]}