{"sha": "6423548818e7dd6940a95889641fbd327749ebd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MjM1NDg4MThlN2RkNjk0MGE5NTg4OTY0MWZiZDMyNzc0OWViZDQ=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-14T07:22:52Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-14T19:37:54Z"}, "message": "Fix a bunch of failure cases in terminfo\n\nReplace all potentially-failing operations with Err returns and add\ntests.\n\nRemove the Char parameter type; characters are represented as Numbers.\n\nFix integer constants to work properly when there are multiple constants\nin the same capability string.\n\nTweak loop to use iterators instead of indexing into cap.", "tree": {"sha": "7f3b6fee2507014342e5de14af78919d9066a128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f3b6fee2507014342e5de14af78919d9066a128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6423548818e7dd6940a95889641fbd327749ebd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6423548818e7dd6940a95889641fbd327749ebd4", "html_url": "https://github.com/rust-lang/rust/commit/6423548818e7dd6940a95889641fbd327749ebd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6423548818e7dd6940a95889641fbd327749ebd4/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e990239a3ae9bafc22e1fa363110ec125dc0be09", "url": "https://api.github.com/repos/rust-lang/rust/commits/e990239a3ae9bafc22e1fa363110ec125dc0be09", "html_url": "https://github.com/rust-lang/rust/commit/e990239a3ae9bafc22e1fa363110ec125dc0be09"}], "stats": {"total": 245, "additions": 161, "deletions": 84}, "files": [{"sha": "ace6ad3ebb0fa1eb69b5f8daf02c867c859dece3", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 161, "deletions": 84, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/6423548818e7dd6940a95889641fbd327749ebd4/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423548818e7dd6940a95889641fbd327749ebd4/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=6423548818e7dd6940a95889641fbd327749ebd4", "patch": "@@ -31,7 +31,6 @@ enum States {\n /// Types of parameters a capability can use\n pub enum Param {\n     String(~str),\n-    Char(char),\n     Number(int)\n }\n \n@@ -64,13 +63,10 @@ impl Variables {\n pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     -> Result<~[u8], ~str> {\n     let mut state = Nothing;\n-    let mut i = 0;\n \n     // expanded cap will only rarely be larger than the cap itself\n     let mut output = vec::with_capacity(cap.len());\n \n-    let mut cur;\n-\n     let mut stack: ~[Param] = ~[];\n \n     let mut intstate = ~[];\n@@ -81,92 +77,123 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         *dst = src;\n     }\n \n-    while i < cap.len() {\n-        cur = cap[i] as char;\n+    for cap.iter().transform(|&x| x).advance |c| {\n+        let cur = c as char;\n         let mut old_state = state;\n         match state {\n             Nothing => {\n                 if cur == '%' {\n                     state = Percent;\n                 } else {\n-                    output.push(cap[i]);\n+                    output.push(c);\n                 }\n             },\n             Percent => {\n                 match cur {\n-                    '%' => { output.push(cap[i]); state = Nothing },\n-                    'c' => match stack.pop() {\n-                        Char(c) => output.push(c as u8),\n-                        _       => return Err(~\"a non-char was used with %c\")\n-                    },\n-                    's' => match stack.pop() {\n-                        String(s) => output.push_all(s.as_bytes()),\n-                        _         => return Err(~\"a non-str was used with %s\")\n-                    },\n-                    'd' => match stack.pop() {\n-                        Number(x) => {\n-                            let s = x.to_str();\n-                            output.push_all(s.as_bytes())\n+                    '%' => { output.push(c); state = Nothing },\n+                    'c' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            // if c is 0, use 0200 (128) for ncurses compatibility\n+                            Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n+                            _       => return Err(~\"a non-char was used with %c\")\n                         }\n-                        _         => return Err(~\"a non-number was used with %d\")\n-                    },\n+                    } else { return Err(~\"stack is empty\") },\n+                    's' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => output.push_all(s.as_bytes()),\n+                            _         => return Err(~\"a non-str was used with %s\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'd' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => {\n+                                let s = x.to_str();\n+                                output.push_all(s.as_bytes())\n+                            }\n+                            _         => return Err(~\"a non-number was used with %d\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant,\n-                    'l' => match stack.pop() {\n-                        String(s) => stack.push(Number(s.len() as int)),\n-                        _         => return Err(~\"a non-str was used with %l\")\n-                    },\n-                    '+' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x + y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with +\")\n-                    },\n-                    '-' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x - y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with -\")\n-                    },\n-                    '*' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x * y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with *\")\n-                    },\n-                    '/' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x / y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with /\")\n-                    },\n-                    'm' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x % y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with %\")\n-                    },\n-                    '&' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x & y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with &\")\n-                    },\n-                    '|' => match (stack.pop(), stack.pop()) {\n-                        (Number(x), Number(y)) => stack.push(Number(x | y)),\n-                        (_, _) => return Err(~\"non-numbers on stack with |\")\n-                    },\n-                    'A' => match (stack.pop(), stack.pop()) {\n-                        (Number(0), Number(_)) => stack.push(Number(0)),\n-                        (Number(_), Number(0)) => stack.push(Number(0)),\n-                        (Number(_), Number(_)) => stack.push(Number(1)),\n-                        _ => return Err(~\"non-numbers on stack with logical and\")\n-                    },\n-                    'O' => match (stack.pop(), stack.pop()) {\n-                        (Number(0), Number(0)) => stack.push(Number(0)),\n-                        (Number(_), Number(_)) => stack.push(Number(1)),\n-                        _ => return Err(~\"non-numbers on stack with logical or\")\n-                    },\n-                    '!' => match stack.pop() {\n-                        Number(0) => stack.push(Number(1)),\n-                        Number(_) => stack.push(Number(0)),\n-                        _ => return Err(~\"non-number on stack with logical not\")\n-                    },\n-                    '~' => match stack.pop() {\n-                        Number(x) => stack.push(Number(!x)),\n-                        _         => return Err(~\"non-number on stack with %~\")\n-                    },\n+                    'l' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            String(s) => stack.push(Number(s.len() as int)),\n+                            _         => return Err(~\"a non-str was used with %l\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '+' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(x), Number(y)) => stack.push(Number(x + y)),\n+                            (_, _) => return Err(~\"non-numbers on stack with +\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '-' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(x), Number(y)) => stack.push(Number(x - y)),\n+                            (_, _) => return Err(~\"non-numbers on stack with -\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '*' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(x), Number(y)) => stack.push(Number(x * y)),\n+                            (_, _) => return Err(~\"non-numbers on stack with *\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '/' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(x), Number(y)) => stack.push(Number(x / y)),\n+                            (_, _) => return Err(~\"non-numbers on stack with /\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'm' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(x), Number(y)) => stack.push(Number(x % y)),\n+                            (_, _) => return Err(~\"non-numbers on stack with %\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '&' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(x), Number(y)) => stack.push(Number(x & y)),\n+                            (_, _) => return Err(~\"non-numbers on stack with &\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '|' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(x), Number(y)) => stack.push(Number(x | y)),\n+                            (_, _) => return Err(~\"non-numbers on stack with |\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'A' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(_)) => stack.push(Number(0)),\n+                            (Number(_), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical and\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'O' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(0), Number(0)) => stack.push(Number(0)),\n+                            (Number(_), Number(_)) => stack.push(Number(1)),\n+                            _ => return Err(~\"non-numbers on stack with logical or\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '!' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => stack.push(Number(1)),\n+                            Number(_) => stack.push(Number(0)),\n+                            _ => return Err(~\"non-number on stack with logical not\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '~' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(x) => stack.push(Number(!x)),\n+                            _         => return Err(~\"non-number on stack with %~\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n                     'i' => match (copy mparams[0], copy mparams[1]) {\n                         (Number(ref mut x), Number(ref mut y)) => {\n                             *x += 1;\n@@ -180,15 +207,22 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             PushParam => {\n                 // params are 1-indexed\n-                stack.push(copy mparams[char::to_digit(cur, 10).expect(\"bad param number\") - 1]);\n+                stack.push(copy mparams[match char::to_digit(cur, 10) {\n+                    Some(d) => d - 1,\n+                    None => return Err(~\"bad param number\")\n+                }]);\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n-                    let idx = (cur as u8) - ('A' as u8);\n-                    vars.sta[idx] = stack.pop();\n+                    if stack.len() > 0 {\n+                        let idx = (cur as u8) - ('A' as u8);\n+                        vars.sta[idx] = stack.pop();\n+                    } else { return Err(~\"stack is empty\") }\n                 } else if cur >= 'a' && cur <= 'z' {\n-                    let idx = (cur as u8) - ('a' as u8);\n-                    vars.dyn[idx] = stack.pop();\n+                    if stack.len() > 0 {\n+                        let idx = (cur as u8) - ('a' as u8);\n+                        vars.dyn[idx] = stack.pop();\n+                    } else { return Err(~\"stack is empty\") }\n                 } else {\n                     return Err(~\"bad variable name in %P\");\n                 }\n@@ -205,7 +239,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 }\n             },\n             CharConstant => {\n-                stack.push(Char(cur));\n+                stack.push(Number(c as int));\n                 state = CharClose;\n             },\n             CharClose => {\n@@ -215,28 +249,71 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             IntConstant => {\n                 if cur == '}' {\n-                    stack.push(Number(int::parse_bytes(intstate, 10).expect(\"bad int constant\")));\n+                    stack.push(match int::parse_bytes(intstate, 10) {\n+                        Some(n) => Number(n),\n+                        None => return Err(~\"bad int constant\")\n+                    });\n+                    intstate.clear();\n                     state = Nothing;\n+                } else {\n+                    intstate.push(cur as u8);\n+                    old_state = Nothing;\n                 }\n-                intstate.push(cur as u8);\n-                old_state = Nothing;\n             }\n             _ => return Err(~\"unimplemented state\")\n         }\n         if state == old_state {\n             state = Nothing;\n         }\n-        i += 1;\n     }\n     Ok(output)\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n+\n     #[test]\n     fn test_basic_setabf() {\n         let s = bytes!(\"\\\\E[48;5;%p1%dm\");\n         assert_eq!(expand(s, [Number(1)], &mut Variables::new()).unwrap(), bytes!(\"\\\\E[48;5;1m\").to_owned());\n     }\n+\n+    #[test]\n+    fn test_multiple_int_constants() {\n+        assert_eq!(expand(bytes!(\"%{1}%{2}%d%d\"), [], &mut Variables::new()).unwrap(), bytes!(\"21\").to_owned());\n+    }\n+\n+    #[test]\n+    fn test_param_stack_failure_conditions() {\n+        let mut varstruct = Variables::new();\n+        let vars = &mut varstruct;\n+        let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n+        for caps.iter().advance |cap| {\n+            let res = expand(cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Op %s succeeded incorrectly with 0 stack entries\", *cap);\n+            let p = if *cap == \"%s\" || *cap == \"%l\" { String(~\"foo\") } else { Number(97) };\n+            let res = expand((bytes!(\"%p1\")).to_owned() + cap.as_bytes(), [p], vars);\n+            assert!(res.is_ok(),\n+                    \"Op %s failed with 1 stack entry: %s\", *cap, res.unwrap_err());\n+        }\n+        let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n+        for caps.iter().advance |cap| {\n+            let res = expand(cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Binop %s succeeded incorrectly with 0 stack entries\", *cap);\n+            let res = expand((bytes!(\"%{1}\")).to_owned() + cap.as_bytes(), [], vars);\n+            assert!(res.is_err(),\n+                    \"Binop %s succeeded incorrectly with 1 stack entry\", *cap);\n+            let res = expand((bytes!(\"%{1}%{2}\")).to_owned() + cap.as_bytes(), [], vars);\n+            assert!(res.is_ok(),\n+                    \"Binop %s failed with 2 stack entries: %s\", *cap, res.unwrap_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_push_bad_param() {\n+        assert!(expand(bytes!(\"%pa\"), [], &mut Variables::new()).is_err());\n+    }\n }"}]}