{"sha": "823c15215e65c9701504902ffbd80c576232942e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyM2MxNTIxNWU2NWM5NzAxNTA0OTAyZmZiZDgwYzU3NjIzMjk0MmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-03T20:54:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-03T20:54:42Z"}, "message": "Merge #2743\n\n2743: Switch ast declaration from ron to a macro r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c5b14d55dc4bd6788ac06ea83460a8d3a6266876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5b14d55dc4bd6788ac06ea83460a8d3a6266876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/823c15215e65c9701504902ffbd80c576232942e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeD6oTCRBK7hj4Ov3rIwAAdHIIAD+ncygqtRuVrKGoTdPpzLRM\nffL21jdoGHXfmUXfQMEYOs5wGIFvXM9vq2/6F8bA5Dd75j4YjrXkUEs7zlJSH819\nVmwG9enfcpkS5QlOZ4hfl+qeZk2OnAOygjwQMjctYKSHqFLCtvdNPXDJfi8Zjdlb\ncCjfVNAmZRxd4RinJfUWmD3+qqdLWdKUHUGqGdnHEa4jCuF04IjUyXBlEUCJ//DW\nvmE1psYnBRkhswJ21Fz7zeHUifuPz5yxD/Hf+u/UjImqhMxi902gkjsAGZ5SYNtS\nbxuJV+MZYP9xraB711jyY/w3HKGiwY7Bkx9RsLfnGDbN70Uh6tccIrJzKY9pntE=\n=XY45\n-----END PGP SIGNATURE-----\n", "payload": "tree c5b14d55dc4bd6788ac06ea83460a8d3a6266876\nparent cb160f2a3457a4c1e9ae0d0a9abd4e807af0c29a\nparent 084bd304f304e674fc3d5b132daf8a9f975064c9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1578084882 +0000\ncommitter GitHub <noreply@github.com> 1578084882 +0000\n\nMerge #2743\n\n2743: Switch ast declaration from ron to a macro r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/823c15215e65c9701504902ffbd80c576232942e", "html_url": "https://github.com/rust-lang/rust/commit/823c15215e65c9701504902ffbd80c576232942e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/823c15215e65c9701504902ffbd80c576232942e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb160f2a3457a4c1e9ae0d0a9abd4e807af0c29a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb160f2a3457a4c1e9ae0d0a9abd4e807af0c29a", "html_url": "https://github.com/rust-lang/rust/commit/cb160f2a3457a4c1e9ae0d0a9abd4e807af0c29a"}, {"sha": "084bd304f304e674fc3d5b132daf8a9f975064c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/084bd304f304e674fc3d5b132daf8a9f975064c9", "html_url": "https://github.com/rust-lang/rust/commit/084bd304f304e674fc3d5b132daf8a9f975064c9"}], "stats": {"total": 4938, "additions": 2378, "deletions": 2560}, "files": [{"sha": "9187a913bd5f7ee332ea0c8f32dd52438ac480cd", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -57,14 +57,6 @@ dependencies = [\n  \"libc 0.2.66 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"base64\"\n-version = \"0.10.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"base64\"\n version = \"0.11.0\"\n@@ -1398,16 +1390,6 @@ dependencies = [\n  \"winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"ron\"\n-version = \"0.5.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"rowan\"\n version = \"0.8.2\"\n@@ -1772,8 +1754,6 @@ dependencies = [\n  \"pico-args 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.104 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1794,7 +1774,6 @@ dependencies = [\n \"checksum autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n \"checksum backtrace 0.3.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"924c76597f0d9ca25d762c25a4d369d51267536465dc5064bdf0eb073ed477ea\"\n \"checksum backtrace-sys 0.1.32 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d6575f128516de27e3ce99689419835fce9643a9b215a14d2b5b685be018491\"\n-\"checksum base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e\"\n \"checksum base64 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b41b7ea54a0c9d92199de89e20e58d49f02f8e699814ef3fdf266f6f748d15c7\"\n \"checksum bit-set 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e84c238982c4b1e1ee668d136c510c67a13465279c0cb367ea6baf6310620a80\"\n \"checksum bit-vec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f59bbe95d4e52a6398ec21238d31577f2b28a9d86807f06ca59d191d8440d0bb\"\n@@ -1915,7 +1894,6 @@ dependencies = [\n \"checksum regex-syntax 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11a7e20d1cce64ef2fed88b66d347f88bd9babb82845b2b858f3edbf59a4f716\"\n \"checksum relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bedde000f40f2921ce439ea165c9c53fd629bfa115140c72e22aceacb4a21954\"\n \"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n-\"checksum ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2ece421e0c4129b90e4a35b6f625e472e96c552136f5093a2f4fa2bbb75a62d5\"\n \"checksum rowan 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3eb10a10a48f0f809a217bcf074b85a03dcf79831bae80e7f1a043d0897463e2\"\n \"checksum rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\""}, {"sha": "262c545e4c87be1dc398b579268acdffc0feb3d2", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -61,46 +61,46 @@ pub enum SyntaxKind {\n     SHR,\n     SHLEQ,\n     SHREQ,\n+    AS_KW,\n     ASYNC_KW,\n-    USE_KW,\n-    FN_KW,\n-    STRUCT_KW,\n-    ENUM_KW,\n-    TRAIT_KW,\n-    IMPL_KW,\n+    AWAIT_KW,\n+    BOX_KW,\n+    BREAK_KW,\n+    CONST_KW,\n+    CONTINUE_KW,\n+    CRATE_KW,\n     DYN_KW,\n-    TRUE_KW,\n-    FALSE_KW,\n-    AS_KW,\n+    ELSE_KW,\n+    ENUM_KW,\n     EXTERN_KW,\n-    CRATE_KW,\n-    MOD_KW,\n-    PUB_KW,\n-    SELF_KW,\n-    SUPER_KW,\n-    IN_KW,\n-    WHERE_KW,\n+    FALSE_KW,\n+    FN_KW,\n     FOR_KW,\n-    LOOP_KW,\n-    WHILE_KW,\n-    CONTINUE_KW,\n-    BREAK_KW,\n     IF_KW,\n-    ELSE_KW,\n+    IMPL_KW,\n+    IN_KW,\n+    LET_KW,\n+    LOOP_KW,\n+    MACRO_KW,\n     MATCH_KW,\n-    CONST_KW,\n-    STATIC_KW,\n+    MOD_KW,\n+    MOVE_KW,\n     MUT_KW,\n-    UNSAFE_KW,\n-    TYPE_KW,\n+    PUB_KW,\n     REF_KW,\n-    LET_KW,\n-    MOVE_KW,\n     RETURN_KW,\n+    SELF_KW,\n+    STATIC_KW,\n+    STRUCT_KW,\n+    SUPER_KW,\n+    TRAIT_KW,\n+    TRUE_KW,\n     TRY_KW,\n-    BOX_KW,\n-    AWAIT_KW,\n-    MACRO_KW,\n+    TYPE_KW,\n+    UNSAFE_KW,\n+    USE_KW,\n+    WHERE_KW,\n+    WHILE_KW,\n     AUTO_KW,\n     DEFAULT_KW,\n     EXISTENTIAL_KW,\n@@ -249,12 +249,12 @@ use self::SyntaxKind::*;\n impl SyntaxKind {\n     pub fn is_keyword(self) -> bool {\n         match self {\n-            ASYNC_KW | USE_KW | FN_KW | STRUCT_KW | ENUM_KW | TRAIT_KW | IMPL_KW | DYN_KW\n-            | TRUE_KW | FALSE_KW | AS_KW | EXTERN_KW | CRATE_KW | MOD_KW | PUB_KW | SELF_KW\n-            | SUPER_KW | IN_KW | WHERE_KW | FOR_KW | LOOP_KW | WHILE_KW | CONTINUE_KW\n-            | BREAK_KW | IF_KW | ELSE_KW | MATCH_KW | CONST_KW | STATIC_KW | MUT_KW | UNSAFE_KW\n-            | TYPE_KW | REF_KW | LET_KW | MOVE_KW | RETURN_KW | TRY_KW | BOX_KW | AWAIT_KW\n-            | MACRO_KW | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW => true,\n+            AS_KW | ASYNC_KW | AWAIT_KW | BOX_KW | BREAK_KW | CONST_KW | CONTINUE_KW | CRATE_KW\n+            | DYN_KW | ELSE_KW | ENUM_KW | EXTERN_KW | FALSE_KW | FN_KW | FOR_KW | IF_KW\n+            | IMPL_KW | IN_KW | LET_KW | LOOP_KW | MACRO_KW | MATCH_KW | MOD_KW | MOVE_KW\n+            | MUT_KW | PUB_KW | REF_KW | RETURN_KW | SELF_KW | STATIC_KW | STRUCT_KW | SUPER_KW\n+            | TRAIT_KW | TRUE_KW | TRY_KW | TYPE_KW | UNSAFE_KW | USE_KW | WHERE_KW | WHILE_KW\n+            | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW => true,\n             _ => false,\n         }\n     }\n@@ -278,46 +278,46 @@ impl SyntaxKind {\n     }\n     pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {\n         let kw = match ident {\n+            \"as\" => AS_KW,\n             \"async\" => ASYNC_KW,\n-            \"use\" => USE_KW,\n-            \"fn\" => FN_KW,\n-            \"struct\" => STRUCT_KW,\n-            \"enum\" => ENUM_KW,\n-            \"trait\" => TRAIT_KW,\n-            \"impl\" => IMPL_KW,\n+            \"await\" => AWAIT_KW,\n+            \"box\" => BOX_KW,\n+            \"break\" => BREAK_KW,\n+            \"const\" => CONST_KW,\n+            \"continue\" => CONTINUE_KW,\n+            \"crate\" => CRATE_KW,\n             \"dyn\" => DYN_KW,\n-            \"true\" => TRUE_KW,\n-            \"false\" => FALSE_KW,\n-            \"as\" => AS_KW,\n+            \"else\" => ELSE_KW,\n+            \"enum\" => ENUM_KW,\n             \"extern\" => EXTERN_KW,\n-            \"crate\" => CRATE_KW,\n-            \"mod\" => MOD_KW,\n-            \"pub\" => PUB_KW,\n-            \"self\" => SELF_KW,\n-            \"super\" => SUPER_KW,\n-            \"in\" => IN_KW,\n-            \"where\" => WHERE_KW,\n+            \"false\" => FALSE_KW,\n+            \"fn\" => FN_KW,\n             \"for\" => FOR_KW,\n-            \"loop\" => LOOP_KW,\n-            \"while\" => WHILE_KW,\n-            \"continue\" => CONTINUE_KW,\n-            \"break\" => BREAK_KW,\n             \"if\" => IF_KW,\n-            \"else\" => ELSE_KW,\n+            \"impl\" => IMPL_KW,\n+            \"in\" => IN_KW,\n+            \"let\" => LET_KW,\n+            \"loop\" => LOOP_KW,\n+            \"macro\" => MACRO_KW,\n             \"match\" => MATCH_KW,\n-            \"const\" => CONST_KW,\n-            \"static\" => STATIC_KW,\n+            \"mod\" => MOD_KW,\n+            \"move\" => MOVE_KW,\n             \"mut\" => MUT_KW,\n-            \"unsafe\" => UNSAFE_KW,\n-            \"type\" => TYPE_KW,\n+            \"pub\" => PUB_KW,\n             \"ref\" => REF_KW,\n-            \"let\" => LET_KW,\n-            \"move\" => MOVE_KW,\n             \"return\" => RETURN_KW,\n+            \"self\" => SELF_KW,\n+            \"static\" => STATIC_KW,\n+            \"struct\" => STRUCT_KW,\n+            \"super\" => SUPER_KW,\n+            \"trait\" => TRAIT_KW,\n+            \"true\" => TRUE_KW,\n             \"try\" => TRY_KW,\n-            \"box\" => BOX_KW,\n-            \"await\" => AWAIT_KW,\n-            \"macro\" => MACRO_KW,\n+            \"type\" => TYPE_KW,\n+            \"unsafe\" => UNSAFE_KW,\n+            \"use\" => USE_KW,\n+            \"where\" => WHERE_KW,\n+            \"while\" => WHILE_KW,\n             _ => return None,\n         };\n         Some(kw)\n@@ -515,125 +515,125 @@ macro_rules! T {\n     ( >>= ) => {\n         $crate::SyntaxKind::SHREQ\n     };\n+    ( as ) => {\n+        $crate::SyntaxKind::AS_KW\n+    };\n     ( async ) => {\n         $crate::SyntaxKind::ASYNC_KW\n     };\n-    ( use ) => {\n-        $crate::SyntaxKind::USE_KW\n+    ( await ) => {\n+        $crate::SyntaxKind::AWAIT_KW\n     };\n-    ( fn ) => {\n-        $crate::SyntaxKind::FN_KW\n+    ( box ) => {\n+        $crate::SyntaxKind::BOX_KW\n     };\n-    ( struct ) => {\n-        $crate::SyntaxKind::STRUCT_KW\n+    ( break ) => {\n+        $crate::SyntaxKind::BREAK_KW\n     };\n-    ( enum ) => {\n-        $crate::SyntaxKind::ENUM_KW\n+    ( const ) => {\n+        $crate::SyntaxKind::CONST_KW\n     };\n-    ( trait ) => {\n-        $crate::SyntaxKind::TRAIT_KW\n+    ( continue ) => {\n+        $crate::SyntaxKind::CONTINUE_KW\n     };\n-    ( impl ) => {\n-        $crate::SyntaxKind::IMPL_KW\n+    ( crate ) => {\n+        $crate::SyntaxKind::CRATE_KW\n     };\n     ( dyn ) => {\n         $crate::SyntaxKind::DYN_KW\n     };\n-    ( true ) => {\n-        $crate::SyntaxKind::TRUE_KW\n-    };\n-    ( false ) => {\n-        $crate::SyntaxKind::FALSE_KW\n+    ( else ) => {\n+        $crate::SyntaxKind::ELSE_KW\n     };\n-    ( as ) => {\n-        $crate::SyntaxKind::AS_KW\n+    ( enum ) => {\n+        $crate::SyntaxKind::ENUM_KW\n     };\n     ( extern ) => {\n         $crate::SyntaxKind::EXTERN_KW\n     };\n-    ( crate ) => {\n-        $crate::SyntaxKind::CRATE_KW\n+    ( false ) => {\n+        $crate::SyntaxKind::FALSE_KW\n     };\n-    ( mod ) => {\n-        $crate::SyntaxKind::MOD_KW\n+    ( fn ) => {\n+        $crate::SyntaxKind::FN_KW\n     };\n-    ( pub ) => {\n-        $crate::SyntaxKind::PUB_KW\n+    ( for ) => {\n+        $crate::SyntaxKind::FOR_KW\n     };\n-    ( self ) => {\n-        $crate::SyntaxKind::SELF_KW\n+    ( if ) => {\n+        $crate::SyntaxKind::IF_KW\n     };\n-    ( super ) => {\n-        $crate::SyntaxKind::SUPER_KW\n+    ( impl ) => {\n+        $crate::SyntaxKind::IMPL_KW\n     };\n     ( in ) => {\n         $crate::SyntaxKind::IN_KW\n     };\n-    ( where ) => {\n-        $crate::SyntaxKind::WHERE_KW\n-    };\n-    ( for ) => {\n-        $crate::SyntaxKind::FOR_KW\n+    ( let ) => {\n+        $crate::SyntaxKind::LET_KW\n     };\n     ( loop ) => {\n         $crate::SyntaxKind::LOOP_KW\n     };\n-    ( while ) => {\n-        $crate::SyntaxKind::WHILE_KW\n-    };\n-    ( continue ) => {\n-        $crate::SyntaxKind::CONTINUE_KW\n-    };\n-    ( break ) => {\n-        $crate::SyntaxKind::BREAK_KW\n-    };\n-    ( if ) => {\n-        $crate::SyntaxKind::IF_KW\n-    };\n-    ( else ) => {\n-        $crate::SyntaxKind::ELSE_KW\n+    ( macro ) => {\n+        $crate::SyntaxKind::MACRO_KW\n     };\n     ( match ) => {\n         $crate::SyntaxKind::MATCH_KW\n     };\n-    ( const ) => {\n-        $crate::SyntaxKind::CONST_KW\n+    ( mod ) => {\n+        $crate::SyntaxKind::MOD_KW\n     };\n-    ( static ) => {\n-        $crate::SyntaxKind::STATIC_KW\n+    ( move ) => {\n+        $crate::SyntaxKind::MOVE_KW\n     };\n     ( mut ) => {\n         $crate::SyntaxKind::MUT_KW\n     };\n-    ( unsafe ) => {\n-        $crate::SyntaxKind::UNSAFE_KW\n-    };\n-    ( type ) => {\n-        $crate::SyntaxKind::TYPE_KW\n+    ( pub ) => {\n+        $crate::SyntaxKind::PUB_KW\n     };\n     ( ref ) => {\n         $crate::SyntaxKind::REF_KW\n     };\n-    ( let ) => {\n-        $crate::SyntaxKind::LET_KW\n-    };\n-    ( move ) => {\n-        $crate::SyntaxKind::MOVE_KW\n-    };\n     ( return ) => {\n         $crate::SyntaxKind::RETURN_KW\n     };\n+    ( self ) => {\n+        $crate::SyntaxKind::SELF_KW\n+    };\n+    ( static ) => {\n+        $crate::SyntaxKind::STATIC_KW\n+    };\n+    ( struct ) => {\n+        $crate::SyntaxKind::STRUCT_KW\n+    };\n+    ( super ) => {\n+        $crate::SyntaxKind::SUPER_KW\n+    };\n+    ( trait ) => {\n+        $crate::SyntaxKind::TRAIT_KW\n+    };\n+    ( true ) => {\n+        $crate::SyntaxKind::TRUE_KW\n+    };\n     ( try ) => {\n         $crate::SyntaxKind::TRY_KW\n     };\n-    ( box ) => {\n-        $crate::SyntaxKind::BOX_KW\n+    ( type ) => {\n+        $crate::SyntaxKind::TYPE_KW\n     };\n-    ( await ) => {\n-        $crate::SyntaxKind::AWAIT_KW\n+    ( unsafe ) => {\n+        $crate::SyntaxKind::UNSAFE_KW\n     };\n-    ( macro ) => {\n-        $crate::SyntaxKind::MACRO_KW\n+    ( use ) => {\n+        $crate::SyntaxKind::USE_KW\n+    };\n+    ( where ) => {\n+        $crate::SyntaxKind::WHERE_KW\n+    };\n+    ( while ) => {\n+        $crate::SyntaxKind::WHILE_KW\n     };\n     ( auto ) => {\n         $crate::SyntaxKind::AUTO_KW"}, {"sha": "2eb4b14d20b8ff9bc0cfcc64e8596a6762bbe8bb", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1526, "deletions": 1534, "changes": 3060, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=823c15215e65c9701504902ffbd80c576232942e"}, {"sha": "47446a878c21fab736b38b15ac068a10a7e95c7c", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 0, "deletions": 730, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -1,736 +1,6 @@\n // Stores definitions which must be used in multiple places\n // See `cargo xtask codegen` (defined in xtasks/src/main.rs)\n Grammar(\n-    punct: [\n-        (\";\", \"SEMI\"),\n-        (\",\", \"COMMA\"),\n-        (\"(\", \"L_PAREN\"),\n-        (\")\", \"R_PAREN\"),\n-        (\"{\", \"L_CURLY\"),\n-        (\"}\", \"R_CURLY\"),\n-        (\"[\", \"L_BRACK\"),\n-        (\"]\", \"R_BRACK\"),\n-        (\"<\", \"L_ANGLE\"),\n-        (\">\", \"R_ANGLE\"),\n-        (\"@\", \"AT\"),\n-        (\"#\", \"POUND\"),\n-        (\"~\", \"TILDE\"),\n-        (\"?\", \"QUESTION\"),\n-        (\"$\", \"DOLLAR\"),\n-        (\"&\", \"AMP\"),\n-        (\"|\", \"PIPE\"),\n-        (\"+\", \"PLUS\"),\n-        (\"*\", \"STAR\"),\n-        (\"/\", \"SLASH\"),\n-        (\"^\", \"CARET\"),\n-        (\"%\", \"PERCENT\"),\n-        (\"_\", \"UNDERSCORE\"),\n-        (\".\", \"DOT\"),\n-        (\"..\", \"DOTDOT\"),\n-        (\"...\", \"DOTDOTDOT\"),\n-        (\"..=\", \"DOTDOTEQ\"),\n-        (\":\", \"COLON\"),\n-        (\"::\", \"COLONCOLON\"),\n-        (\"=\", \"EQ\"),\n-        (\"==\", \"EQEQ\"),\n-        (\"=>\", \"FAT_ARROW\"),\n-        (\"!\", \"EXCL\"),\n-        (\"!=\", \"NEQ\"),\n-        (\"-\", \"MINUS\"),\n-        (\"->\", \"THIN_ARROW\"),\n-        (\"<=\", \"LTEQ\"),\n-        (\">=\", \"GTEQ\"),\n-        (\"+=\", \"PLUSEQ\"),\n-        (\"-=\", \"MINUSEQ\"),\n-        (\"|=\", \"PIPEEQ\"),\n-        (\"&=\", \"AMPEQ\"),\n-        (\"^=\", \"CARETEQ\"),\n-        (\"/=\", \"SLASHEQ\"),\n-        (\"*=\", \"STAREQ\"),\n-        (\"%=\", \"PERCENTEQ\"),\n-        (\"&&\", \"AMPAMP\"),\n-        (\"||\", \"PIPEPIPE\"),\n-        (\"<<\", \"SHL\"),\n-        (\">>\", \"SHR\"),\n-        (\"<<=\", \"SHLEQ\"),\n-        (\">>=\", \"SHREQ\"),\n-    ],\n-    keywords: [\n-        \"async\",\n-        \"use\",\n-        \"fn\",\n-        \"struct\",\n-        \"enum\",\n-        \"trait\",\n-        \"impl\",\n-        \"dyn\",\n-        \"true\",\n-        \"false\",\n-        \"as\",\n-        \"extern\",\n-        \"crate\",\n-        \"mod\",\n-        \"pub\",\n-        \"self\",\n-        \"super\",\n-        \"in\",\n-        \"where\",\n-        \"for\",\n-        \"loop\",\n-        \"while\",\n-        \"continue\",\n-        \"break\",\n-        \"if\",\n-        \"else\",\n-        \"match\",\n-        \"const\",\n-        \"static\",\n-        \"mut\",\n-        \"unsafe\",\n-        \"type\",\n-        \"ref\",\n-        \"let\",\n-        \"move\",\n-        \"return\",\n-        \"try\",\n-        \"box\",\n-        \"await\",\n-        \"macro\"\n-    ],\n-    contextual_keywords: [\n-        \"auto\",\n-        \"default\",\n-        \"existential\",\n-        \"union\",\n-    ],\n-    literals: [\n-        \"INT_NUMBER\",\n-        \"FLOAT_NUMBER\",\n-        \"CHAR\",\n-        \"BYTE\",\n-        \"STRING\",\n-        \"RAW_STRING\",\n-        \"BYTE_STRING\",\n-        \"RAW_BYTE_STRING\",\n-    ],\n-    tokens: [\n-        \"ERROR\",\n-        \"IDENT\",\n-        \"WHITESPACE\",\n-        \"LIFETIME\",\n-        \"COMMENT\",\n-        \"SHEBANG\",\n-        \"L_DOLLAR\",\n-        \"R_DOLLAR\",\n-    ],\n-    nodes: [\n-        \"SOURCE_FILE\",\n-\n-        \"STRUCT_DEF\",\n-        \"UNION_DEF\",\n-        \"ENUM_DEF\",\n-        \"FN_DEF\",\n-        \"RET_TYPE\",\n-        \"EXTERN_CRATE_ITEM\",\n-        \"MODULE\",\n-        \"USE_ITEM\",\n-        \"STATIC_DEF\",\n-        \"CONST_DEF\",\n-        \"TRAIT_DEF\",\n-        \"IMPL_BLOCK\",\n-        \"TYPE_ALIAS_DEF\",\n-        \"MACRO_CALL\",\n-        \"TOKEN_TREE\",\n-        \"MACRO_DEF\",\n-\n-        \"PAREN_TYPE\",\n-        \"TUPLE_TYPE\",\n-        \"NEVER_TYPE\",\n-        \"PATH_TYPE\",\n-        \"POINTER_TYPE\",\n-        \"ARRAY_TYPE\",\n-        \"SLICE_TYPE\",\n-        \"REFERENCE_TYPE\",\n-        \"PLACEHOLDER_TYPE\",\n-        \"FN_POINTER_TYPE\",\n-        \"FOR_TYPE\",\n-        \"IMPL_TRAIT_TYPE\",\n-        \"DYN_TRAIT_TYPE\",\n-\n-        \"REF_PAT\",\n-        \"BOX_PAT\",\n-        \"BIND_PAT\",\n-        \"PLACEHOLDER_PAT\",\n-        \"DOT_DOT_PAT\",\n-        \"PATH_PAT\",\n-        \"RECORD_PAT\",\n-        \"RECORD_FIELD_PAT_LIST\",\n-        \"RECORD_FIELD_PAT\",\n-        \"TUPLE_STRUCT_PAT\",\n-        \"TUPLE_PAT\",\n-        \"SLICE_PAT\",\n-        \"RANGE_PAT\",\n-        \"LITERAL_PAT\",\n-\n-        // atoms\n-        \"TUPLE_EXPR\",\n-        \"ARRAY_EXPR\",\n-        \"PAREN_EXPR\",\n-        \"PATH_EXPR\",\n-        \"LAMBDA_EXPR\",\n-        \"IF_EXPR\",\n-        \"WHILE_EXPR\",\n-        \"CONDITION\",\n-        \"LOOP_EXPR\",\n-        \"FOR_EXPR\",\n-        \"CONTINUE_EXPR\",\n-        \"BREAK_EXPR\",\n-        \"LABEL\",\n-        \"BLOCK_EXPR\",\n-        \"RETURN_EXPR\",\n-        \"MATCH_EXPR\",\n-        \"MATCH_ARM_LIST\",\n-        \"MATCH_ARM\",\n-        \"MATCH_GUARD\",\n-        \"RECORD_LIT\",\n-        \"RECORD_FIELD_LIST\",\n-        \"RECORD_FIELD\",\n-        \"TRY_BLOCK_EXPR\",\n-        \"BOX_EXPR\",\n-\n-        // postfix\n-        \"CALL_EXPR\",\n-        \"INDEX_EXPR\",\n-        \"METHOD_CALL_EXPR\",\n-        \"FIELD_EXPR\",\n-        \"AWAIT_EXPR\",\n-        \"TRY_EXPR\",\n-        \"CAST_EXPR\",\n-\n-        // unary\n-        \"REF_EXPR\",\n-        \"PREFIX_EXPR\",\n-\n-        \"RANGE_EXPR\", // just weird\n-        \"BIN_EXPR\",\n-\n-        \"BLOCK\",\n-        \"EXTERN_BLOCK\",\n-        \"EXTERN_ITEM_LIST\",\n-        \"ENUM_VARIANT\",\n-        \"RECORD_FIELD_DEF_LIST\",\n-        \"RECORD_FIELD_DEF\",\n-        \"TUPLE_FIELD_DEF_LIST\",\n-        \"TUPLE_FIELD_DEF\",\n-        \"ENUM_VARIANT_LIST\",\n-        \"ITEM_LIST\",\n-        \"ATTR\",\n-        \"META_ITEM\", // not an item actually\n-        \"USE_TREE\",\n-        \"USE_TREE_LIST\",\n-        \"PATH\",\n-        \"PATH_SEGMENT\",\n-        \"LITERAL\",\n-        \"ALIAS\",\n-        \"VISIBILITY\",\n-        \"WHERE_CLAUSE\",\n-        \"WHERE_PRED\",\n-        \"ABI\",\n-        \"NAME\",\n-        \"NAME_REF\",\n-\n-        \"LET_STMT\",\n-        \"EXPR_STMT\",\n-\n-        \"TYPE_PARAM_LIST\",\n-        \"LIFETIME_PARAM\",\n-        \"TYPE_PARAM\",\n-        \"CONST_PARAM\",\n-        \"TYPE_ARG_LIST\",\n-        \"LIFETIME_ARG\",\n-        \"TYPE_ARG\",\n-        \"ASSOC_TYPE_ARG\",\n-\n-        \"PARAM_LIST\",\n-        \"PARAM\",\n-        \"SELF_PARAM\",\n-        \"ARG_LIST\",\n-        \"TYPE_BOUND\",\n-        \"TYPE_BOUND_LIST\",\n-\n-        // macro related\n-        \"MACRO_ITEMS\",\n-        \"MACRO_STMTS\",\n-    ],\n     ast: {\n-        \"SourceFile\": (\n-            traits: [ \"ModuleItemOwner\", \"FnDefOwner\" ],\n-            collections: [\n-                (\"modules\", \"Module\"),\n-            ]\n-        ),\n-        \"FnDef\": (\n-            traits: [\n-                \"VisibilityOwner\",\n-                \"NameOwner\",\n-                \"TypeParamsOwner\",\n-                \"AttrsOwner\",\n-                \"DocCommentsOwner\"\n-            ],\n-            options: [ \"ParamList\", [\"body\", \"BlockExpr\"], \"RetType\" ],\n-        ),\n-        \"RetType\": (options: [\"TypeRef\"]),\n-        \"StructDef\": (\n-            traits: [\n-                \"VisibilityOwner\",\n-                \"NameOwner\",\n-                \"TypeParamsOwner\",\n-                \"AttrsOwner\",\n-                \"DocCommentsOwner\"\n-            ]\n-        ),\n-        \"UnionDef\": (\n-            traits: [\n-                \"VisibilityOwner\",\n-                \"NameOwner\",\n-                \"TypeParamsOwner\",\n-                \"AttrsOwner\",\n-                \"DocCommentsOwner\"\n-            ],\n-            options: [\"RecordFieldDefList\"],\n-        ),\n-        \"RecordFieldDefList\": (collections: [(\"fields\", \"RecordFieldDef\")]),\n-        \"RecordFieldDef\": (\n-            traits: [\n-                \"VisibilityOwner\",\n-                \"NameOwner\",\n-                \"AttrsOwner\",\n-                \"DocCommentsOwner\",\n-                \"TypeAscriptionOwner\"\n-            ]\n-        ),\n-        \"TupleFieldDefList\": (collections: [(\"fields\", \"TupleFieldDef\")]),\n-        \"TupleFieldDef\": ( traits: [\"VisibilityOwner\", \"AttrsOwner\"], options: [\"TypeRef\"]),\n-        \"EnumDef\": ( traits: [\n-            \"VisibilityOwner\",\n-            \"NameOwner\",\n-            \"TypeParamsOwner\",\n-            \"AttrsOwner\",\n-            \"DocCommentsOwner\"\n-        ], options: [[\"variant_list\", \"EnumVariantList\"]] ),\n-        \"EnumVariantList\": ( collections: [(\"variants\", \"EnumVariant\")] ),\n-        \"EnumVariant\": ( traits: [\"NameOwner\", \"DocCommentsOwner\", \"AttrsOwner\"], options: [\"Expr\"] ),\n-        \"TraitDef\": (\n-            traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\", \"TypeParamsOwner\", \"TypeBoundsOwner\"],\n-            options: [\"ItemList\"]\n-        ),\n-        \"Module\": (\n-            traits: [\"VisibilityOwner\", \"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\" ],\n-            options: [ \"ItemList\" ]\n-        ),\n-        \"ItemList\": (\n-            collections: [(\"impl_items\", \"ImplItem\")],\n-            traits: [ \"FnDefOwner\", \"ModuleItemOwner\" ],\n-        ),\n-        \"ConstDef\": (\n-            traits: [\n-                \"VisibilityOwner\",\n-                \"NameOwner\",\n-                \"TypeParamsOwner\",\n-                \"AttrsOwner\",\n-                \"DocCommentsOwner\",\n-                \"TypeAscriptionOwner\",\n-            ],\n-            options: [ [\"body\",\"Expr\"]],\n-        ),\n-        \"StaticDef\": (\n-            traits: [\n-                \"VisibilityOwner\",\n-                \"NameOwner\",\n-                \"TypeParamsOwner\",\n-                \"AttrsOwner\",\n-                \"DocCommentsOwner\",\n-                \"TypeAscriptionOwner\",\n-            ],\n-            options: [ [\"body\",\"Expr\"]],\n-        ),\n-        \"TypeAliasDef\": (\n-            traits: [\n-                \"VisibilityOwner\",\n-                \"NameOwner\",\n-                \"TypeParamsOwner\",\n-                \"AttrsOwner\",\n-                \"DocCommentsOwner\",\n-                \"TypeBoundsOwner\",\n-            ],\n-            options: [\"TypeRef\"]\n-        ),\n-        \"ImplBlock\": (options: [\"ItemList\"], traits: [\"TypeParamsOwner\", \"AttrsOwner\"]),\n-\n-        \"ParenType\": (options: [\"TypeRef\"]),\n-        \"TupleType\": ( collections: [(\"fields\", \"TypeRef\")] ),\n-        \"NeverType\": (),\n-        \"PathType\": (options: [\"Path\"]),\n-        \"PointerType\": (options: [\"TypeRef\"]),\n-        \"ArrayType\": ( options: [\"TypeRef\", \"Expr\"] ),\n-        \"SliceType\": ( options: [\"TypeRef\"] ),\n-        \"ReferenceType\": (options: [\"TypeRef\"]),\n-        \"PlaceholderType\": (),\n-        \"FnPointerType\": (options: [\"ParamList\", \"RetType\"]),\n-        \"ForType\": (options: [\"TypeRef\"]),\n-        \"ImplTraitType\": (\n-            traits: [\"TypeBoundsOwner\"],\n-        ),\n-        \"DynTraitType\": (\n-            traits: [\"TypeBoundsOwner\"],\n-        ),\n-\n-        \"TypeRef\": ( enum: [\n-            \"ParenType\",\n-            \"TupleType\",\n-            \"NeverType\",\n-            \"PathType\",\n-            \"PointerType\",\n-            \"ArrayType\",\n-            \"SliceType\",\n-            \"ReferenceType\",\n-            \"PlaceholderType\",\n-            \"FnPointerType\",\n-            \"ForType\",\n-            \"ImplTraitType\",\n-            \"DynTraitType\",\n-        ]),\n-\n-        \"NominalDef\": (\n-            enum: [\"StructDef\", \"EnumDef\", \"UnionDef\"],\n-            traits: [\n-                \"NameOwner\",\n-                \"TypeParamsOwner\",\n-                \"AttrsOwner\"\n-            ],\n-        ),\n-        \"ModuleItem\": (\n-            enum: [\"StructDef\", \"UnionDef\", \"EnumDef\", \"FnDef\", \"TraitDef\", \"TypeAliasDef\", \"ImplBlock\",\n-                   \"UseItem\", \"ExternCrateItem\", \"ConstDef\", \"StaticDef\", \"Module\" ],\n-            traits: [\"AttrsOwner\", \"VisibilityOwner\"],\n-        ),\n-        \"ImplItem\": (\n-            enum: [\"FnDef\", \"TypeAliasDef\", \"ConstDef\"],\n-            traits: [\"AttrsOwner\"]\n-        ),\n-\n-        \"TupleExpr\": (\n-            collections: [(\"exprs\", \"Expr\")]\n-        ),\n-        \"ArrayExpr\": (\n-            collections: [(\"exprs\", \"Expr\")]\n-        ),\n-        \"ParenExpr\": (options: [\"Expr\"]),\n-        \"PathExpr\": (options: [\"Path\"]),\n-        \"LambdaExpr\": (\n-            options: [\n-                \"ParamList\", \"RetType\",\n-                [\"body\", \"Expr\"],\n-            ]\n-        ),\n-        \"IfExpr\": (\n-            options: [ \"Condition\" ]\n-        ),\n-        \"LoopExpr\": (\n-            traits: [\"LoopBodyOwner\"],\n-        ),\n-        \"TryBlockExpr\": (\n-            options: [[\"body\", \"BlockExpr\"]],\n-        ),\n-        \"ForExpr\": (\n-            traits: [\"LoopBodyOwner\"],\n-            options: [\n-                \"Pat\",\n-                [\"iterable\", \"Expr\"],\n-            ]\n-        ),\n-        \"WhileExpr\": (\n-            traits: [\"LoopBodyOwner\"],\n-            options: [ \"Condition\" ]\n-        ),\n-        \"ContinueExpr\": (),\n-        \"BreakExpr\": (options: [\"Expr\"]),\n-        \"Label\": (),\n-        \"BlockExpr\": (\n-            options: [ \"Block\" ]\n-        ),\n-        \"ReturnExpr\": (options: [\"Expr\"]),\n-        \"MatchExpr\": (\n-            options: [ \"Expr\", \"MatchArmList\" ],\n-        ),\n-        \"MatchArmList\": (\n-            collections: [ (\"arms\", \"MatchArm\") ],\n-            traits: [ \"AttrsOwner\" ]\n-        ),\n-        \"MatchArm\": (\n-            options: [\n-                [ \"guard\", \"MatchGuard\" ],\n-                \"Expr\",\n-            ],\n-            collections: [ (\"pats\", \"Pat\") ],\n-            traits: [ \"AttrsOwner\" ]\n-        ),\n-        \"MatchGuard\": (options: [\"Expr\"]),\n-        \"RecordLit\": (options: [\"Path\", \"RecordFieldList\"]),\n-        \"RecordFieldList\": (\n-            collections: [ (\"fields\", \"RecordField\") ],\n-            options: [[\"spread\", \"Expr\"]]\n-        ),\n-        \"RecordField\": (options: [\"NameRef\", \"Expr\"]),\n-        \"CallExpr\": (\n-            traits: [\"ArgListOwner\"],\n-            options: [ \"Expr\" ],\n-        ),\n-        \"MethodCallExpr\": (\n-            traits: [\"ArgListOwner\"],\n-            options: [ \"Expr\", \"NameRef\", \"TypeArgList\" ],\n-        ),\n-        \"IndexExpr\": (),\n-        \"FieldExpr\": (options: [\"Expr\", \"NameRef\"]),\n-        \"AwaitExpr\": (options: [\"Expr\"]),\n-        \"TryExpr\": (options: [\"Expr\"]),\n-        \"CastExpr\": (options: [\"Expr\", \"TypeRef\"]),\n-        \"RefExpr\": (options: [\"Expr\"]),\n-        \"PrefixExpr\": (options: [\"Expr\"]),\n-        \"BoxExpr\": (options: [\"Expr\"]),\n-        \"RangeExpr\": (),\n-        \"BinExpr\": (),\n-\n-        \"Literal\": (),\n-\n-        \"Expr\": (\n-            enum: [\n-                \"TupleExpr\",\n-                \"ArrayExpr\",\n-                \"ParenExpr\",\n-                \"PathExpr\",\n-                \"LambdaExpr\",\n-                \"IfExpr\",\n-                \"LoopExpr\",\n-                \"ForExpr\",\n-                \"WhileExpr\",\n-                \"ContinueExpr\",\n-                \"BreakExpr\",\n-                \"Label\",\n-                \"BlockExpr\",\n-                \"ReturnExpr\",\n-                \"MatchExpr\",\n-                \"RecordLit\",\n-                \"CallExpr\",\n-                \"IndexExpr\",\n-                \"MethodCallExpr\",\n-                \"FieldExpr\",\n-                \"AwaitExpr\",\n-                \"TryExpr\",\n-                \"TryBlockExpr\",\n-                \"CastExpr\",\n-                \"RefExpr\",\n-                \"PrefixExpr\",\n-                \"RangeExpr\",\n-                \"BinExpr\",\n-                \"Literal\",\n-                \"MacroCall\",\n-                \"BoxExpr\",\n-            ],\n-        ),\n-\n-        \"RefPat\": ( options: [ \"Pat\" ]),\n-        \"BoxPat\": ( options: [ \"Pat\" ]),\n-        \"BindPat\": (\n-            options: [ \"Pat\" ],\n-            traits: [\"NameOwner\"]\n-        ),\n-        \"PlaceholderPat\": (),\n-        \"DotDotPat\": (),\n-        \"PathPat\": ( options: [ \"Path\" ] ),\n-        \"RecordPat\": ( options: [\"RecordFieldPatList\", \"Path\"] ),\n-        \"RecordFieldPatList\": (\n-            collections: [\n-                (\"record_field_pats\", \"RecordFieldPat\"),\n-                (\"bind_pats\", \"BindPat\"),\n-            ]\n-        ),\n-        \"RecordFieldPat\": (\n-            traits: [\"NameOwner\"],\n-            options: [\"Pat\"]\n-        ),\n-        \"TupleStructPat\": (\n-            options: [\"Path\"],\n-            collections: [(\"args\", \"Pat\")],\n-        ),\n-        \"TuplePat\": ( collections: [(\"args\", \"Pat\")] ),\n-        \"SlicePat\": (),\n-        \"RangePat\": (),\n-        \"LiteralPat\": (options: [\"Literal\"]),\n-\n-        \"Pat\": (\n-            enum: [\n-                \"RefPat\",\n-                \"BoxPat\",\n-                \"BindPat\",\n-                \"PlaceholderPat\",\n-                \"DotDotPat\",\n-                \"PathPat\",\n-                \"RecordPat\",\n-                \"TupleStructPat\",\n-                \"TuplePat\",\n-                \"SlicePat\",\n-                \"RangePat\",\n-                \"LiteralPat\",\n-            ],\n-        ),\n-\n-        \"Visibility\": (),\n-        \"Name\": (),\n-        \"NameRef\": (),\n-        \"MacroCall\": (\n-            traits: [ \"NameOwner\", \"AttrsOwner\",\"DocCommentsOwner\" ],\n-            options: [ \"TokenTree\", \"Path\" ],\n-        ),\n-        \"AttrInput\": ( enum: [ \"Literal\", \"TokenTree\" ] ),\n-        \"Attr\": ( options: [ \"Path\", [ \"input\", \"AttrInput\" ] ] ),\n-        \"TokenTree\": (),\n-        \"TypeParamList\": (\n-            collections: [\n-                (\"type_params\", \"TypeParam\" ),\n-                (\"lifetime_params\", \"LifetimeParam\" ),\n-            ]\n-        ),\n-        \"TypeParam\": (\n-            options: [(\"default_type\", \"TypeRef\")],\n-            traits: [\"NameOwner\", \"AttrsOwner\", \"TypeBoundsOwner\"],\n-        ),\n-        \"ConstParam\": (\n-            options: [(\"default_val\", \"Expr\")],\n-            traits: [\"NameOwner\", \"AttrsOwner\", \"TypeAscriptionOwner\"],\n-        ),\n-        \"LifetimeParam\": (\n-            traits: [\"AttrsOwner\"],\n-        ),\n-        \"TypeBound\": (\n-            options: [\n-                \"TypeRef\",\n-            ]\n-        ),\n-        \"TypeBoundList\": (\n-            collections: [\n-                (\"bounds\", \"TypeBound\"),\n-            ]\n-        ),\n-        \"WherePred\": (\n-            options: [\n-                \"TypeRef\",\n-            ],\n-            traits: [\n-                \"TypeBoundsOwner\",\n-            ],\n-        ),\n-        \"WhereClause\": (\n-            collections: [\n-                (\"predicates\", \"WherePred\"),\n-            ],\n-        ),\n-        \"ExprStmt\": (\n-            options: [ [\"expr\", \"Expr\"] ]\n-        ),\n-        \"LetStmt\": (\n-            options: [\n-                [\"pat\", \"Pat\"],\n-                [\"initializer\", \"Expr\"],\n-            ],\n-            traits: [\n-                \"TypeAscriptionOwner\",\n-            ]\n-        ),\n-        \"Condition\": (\n-            options: [ \"Pat\", \"Expr\" ]\n-        ),\n-        \"Stmt\": (\n-            enum: [\"ExprStmt\", \"LetStmt\"],\n-        ),\n-        \"Block\": (\n-            options: [ \"Expr\" ],\n-            collections: [\n-                (\"statements\", \"Stmt\"),\n-            ],\n-            traits: [\n-                \"AttrsOwner\",\n-                \"ModuleItemOwner\",\n-            ]\n-        ),\n-        \"ParamList\": (\n-            options: [ \"SelfParam\" ],\n-            collections: [\n-                (\"params\", \"Param\"),\n-            ]\n-        ),\n-        \"SelfParam\": (\n-            traits: [\n-                \"TypeAscriptionOwner\",\n-                \"AttrsOwner\",\n-            ]\n-        ),\n-        \"Param\": (\n-            options: [ \"Pat\" ],\n-            traits: [\n-                \"TypeAscriptionOwner\",\n-                \"AttrsOwner\",\n-            ]\n-        ),\n-        \"UseItem\": (\n-            traits: [\"AttrsOwner\", \"VisibilityOwner\"],\n-            options: [ \"UseTree\" ],\n-        ),\n-        \"UseTree\": (\n-            options: [ \"Path\", \"UseTreeList\", \"Alias\" ]\n-        ),\n-        \"Alias\": (\n-            traits: [\"NameOwner\"],\n-        ),\n-        \"UseTreeList\": (\n-            collections: [(\"use_trees\", \"UseTree\")]\n-        ),\n-        \"ExternCrateItem\": (\n-            traits: [\"AttrsOwner\", \"VisibilityOwner\"],\n-            options: [\"NameRef\", \"Alias\"],\n-        ),\n-        \"ArgList\": (\n-            collections: [\n-                (\"args\", \"Expr\"),\n-            ]\n-        ),\n-        \"Path\": (\n-            options: [\n-                [\"segment\", \"PathSegment\"],\n-                [\"qualifier\", \"Path\"],\n-            ]\n-        ),\n-        \"PathSegment\": (\n-            options: [ \"NameRef\", \"TypeArgList\", \"ParamList\", \"RetType\", \"PathType\" ]\n-        ),\n-        \"TypeArgList\": (collections: [\n-            (\"type_args\", \"TypeArg\"),\n-            (\"lifetime_args\", \"LifetimeArg\"),\n-            (\"assoc_type_args\", \"AssocTypeArg\"),\n-        ]),\n-        \"TypeArg\": (options: [\"TypeRef\"]),\n-        \"AssocTypeArg\": (options: [\"NameRef\", \"TypeRef\"]),\n-        \"LifetimeArg\": (),\n-\n-        \"MacroItems\": (\n-            traits: [ \"ModuleItemOwner\", \"FnDefOwner\" ],\n-        ),\n-\n-        \"MacroStmts\" : (\n-            options: [ \"Expr\" ],\n-            collections: [\n-                (\"statements\", \"Stmt\"),\n-            ],\n-        )\n     },\n )"}, {"sha": "72dd5e5812bb3fde86b2cf6e83e4624dfe89ac52", "filename": "xtask/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/xtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/xtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2FCargo.toml?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -13,6 +13,4 @@ walkdir = \"2.1.3\"\n pico-args = \"0.3.0\"\n quote = \"1.0.2\"\n proc-macro2 = \"1.0.1\"\n-ron = \"0.5.1\"\n-serde = { version = \"1.0.0\", features = [\"derive\"] }\n anyhow = \"1.0.19\""}, {"sha": "d494a4a383217219ec68f43a3d627df8a21014d7", "filename": "xtask/src/ast_src.rs", "status": "added", "additions": 618, "deletions": 0, "changes": 618, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -0,0 +1,618 @@\n+pub(crate) struct KindsSrc<'a> {\n+    pub(crate) punct: &'a [(&'a str, &'a str)],\n+    pub(crate) keywords: &'a [&'a str],\n+    pub(crate) contextual_keywords: &'a [&'a str],\n+    pub(crate) literals: &'a [&'a str],\n+    pub(crate) tokens: &'a [&'a str],\n+    pub(crate) nodes: &'a [&'a str],\n+}\n+\n+pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n+    punct: &[\n+        (\";\", \"SEMI\"),\n+        (\",\", \"COMMA\"),\n+        (\"(\", \"L_PAREN\"),\n+        (\")\", \"R_PAREN\"),\n+        (\"{\", \"L_CURLY\"),\n+        (\"}\", \"R_CURLY\"),\n+        (\"[\", \"L_BRACK\"),\n+        (\"]\", \"R_BRACK\"),\n+        (\"<\", \"L_ANGLE\"),\n+        (\">\", \"R_ANGLE\"),\n+        (\"@\", \"AT\"),\n+        (\"#\", \"POUND\"),\n+        (\"~\", \"TILDE\"),\n+        (\"?\", \"QUESTION\"),\n+        (\"$\", \"DOLLAR\"),\n+        (\"&\", \"AMP\"),\n+        (\"|\", \"PIPE\"),\n+        (\"+\", \"PLUS\"),\n+        (\"*\", \"STAR\"),\n+        (\"/\", \"SLASH\"),\n+        (\"^\", \"CARET\"),\n+        (\"%\", \"PERCENT\"),\n+        (\"_\", \"UNDERSCORE\"),\n+        (\".\", \"DOT\"),\n+        (\"..\", \"DOTDOT\"),\n+        (\"...\", \"DOTDOTDOT\"),\n+        (\"..=\", \"DOTDOTEQ\"),\n+        (\":\", \"COLON\"),\n+        (\"::\", \"COLONCOLON\"),\n+        (\"=\", \"EQ\"),\n+        (\"==\", \"EQEQ\"),\n+        (\"=>\", \"FAT_ARROW\"),\n+        (\"!\", \"EXCL\"),\n+        (\"!=\", \"NEQ\"),\n+        (\"-\", \"MINUS\"),\n+        (\"->\", \"THIN_ARROW\"),\n+        (\"<=\", \"LTEQ\"),\n+        (\">=\", \"GTEQ\"),\n+        (\"+=\", \"PLUSEQ\"),\n+        (\"-=\", \"MINUSEQ\"),\n+        (\"|=\", \"PIPEEQ\"),\n+        (\"&=\", \"AMPEQ\"),\n+        (\"^=\", \"CARETEQ\"),\n+        (\"/=\", \"SLASHEQ\"),\n+        (\"*=\", \"STAREQ\"),\n+        (\"%=\", \"PERCENTEQ\"),\n+        (\"&&\", \"AMPAMP\"),\n+        (\"||\", \"PIPEPIPE\"),\n+        (\"<<\", \"SHL\"),\n+        (\">>\", \"SHR\"),\n+        (\"<<=\", \"SHLEQ\"),\n+        (\">>=\", \"SHREQ\"),\n+    ],\n+    keywords: &[\n+        \"as\", \"async\", \"await\", \"box\", \"break\", \"const\", \"continue\", \"crate\", \"dyn\", \"else\",\n+        \"enum\", \"extern\", \"false\", \"fn\", \"for\", \"if\", \"impl\", \"in\", \"let\", \"loop\", \"macro\",\n+        \"match\", \"mod\", \"move\", \"mut\", \"pub\", \"ref\", \"return\", \"self\", \"static\", \"struct\", \"super\",\n+        \"trait\", \"true\", \"try\", \"type\", \"unsafe\", \"use\", \"where\", \"while\",\n+    ],\n+    contextual_keywords: &[\"auto\", \"default\", \"existential\", \"union\"],\n+    literals: &[\n+        \"INT_NUMBER\",\n+        \"FLOAT_NUMBER\",\n+        \"CHAR\",\n+        \"BYTE\",\n+        \"STRING\",\n+        \"RAW_STRING\",\n+        \"BYTE_STRING\",\n+        \"RAW_BYTE_STRING\",\n+    ],\n+    tokens: &[\n+        \"ERROR\",\n+        \"IDENT\",\n+        \"WHITESPACE\",\n+        \"LIFETIME\",\n+        \"COMMENT\",\n+        \"SHEBANG\",\n+        \"L_DOLLAR\",\n+        \"R_DOLLAR\",\n+    ],\n+    nodes: &[\n+        \"SOURCE_FILE\",\n+        \"STRUCT_DEF\",\n+        \"UNION_DEF\",\n+        \"ENUM_DEF\",\n+        \"FN_DEF\",\n+        \"RET_TYPE\",\n+        \"EXTERN_CRATE_ITEM\",\n+        \"MODULE\",\n+        \"USE_ITEM\",\n+        \"STATIC_DEF\",\n+        \"CONST_DEF\",\n+        \"TRAIT_DEF\",\n+        \"IMPL_BLOCK\",\n+        \"TYPE_ALIAS_DEF\",\n+        \"MACRO_CALL\",\n+        \"TOKEN_TREE\",\n+        \"MACRO_DEF\",\n+        \"PAREN_TYPE\",\n+        \"TUPLE_TYPE\",\n+        \"NEVER_TYPE\",\n+        \"PATH_TYPE\",\n+        \"POINTER_TYPE\",\n+        \"ARRAY_TYPE\",\n+        \"SLICE_TYPE\",\n+        \"REFERENCE_TYPE\",\n+        \"PLACEHOLDER_TYPE\",\n+        \"FN_POINTER_TYPE\",\n+        \"FOR_TYPE\",\n+        \"IMPL_TRAIT_TYPE\",\n+        \"DYN_TRAIT_TYPE\",\n+        \"REF_PAT\",\n+        \"BOX_PAT\",\n+        \"BIND_PAT\",\n+        \"PLACEHOLDER_PAT\",\n+        \"DOT_DOT_PAT\",\n+        \"PATH_PAT\",\n+        \"RECORD_PAT\",\n+        \"RECORD_FIELD_PAT_LIST\",\n+        \"RECORD_FIELD_PAT\",\n+        \"TUPLE_STRUCT_PAT\",\n+        \"TUPLE_PAT\",\n+        \"SLICE_PAT\",\n+        \"RANGE_PAT\",\n+        \"LITERAL_PAT\",\n+        // atoms\n+        \"TUPLE_EXPR\",\n+        \"ARRAY_EXPR\",\n+        \"PAREN_EXPR\",\n+        \"PATH_EXPR\",\n+        \"LAMBDA_EXPR\",\n+        \"IF_EXPR\",\n+        \"WHILE_EXPR\",\n+        \"CONDITION\",\n+        \"LOOP_EXPR\",\n+        \"FOR_EXPR\",\n+        \"CONTINUE_EXPR\",\n+        \"BREAK_EXPR\",\n+        \"LABEL\",\n+        \"BLOCK_EXPR\",\n+        \"RETURN_EXPR\",\n+        \"MATCH_EXPR\",\n+        \"MATCH_ARM_LIST\",\n+        \"MATCH_ARM\",\n+        \"MATCH_GUARD\",\n+        \"RECORD_LIT\",\n+        \"RECORD_FIELD_LIST\",\n+        \"RECORD_FIELD\",\n+        \"TRY_BLOCK_EXPR\",\n+        \"BOX_EXPR\",\n+        // postfix\n+        \"CALL_EXPR\",\n+        \"INDEX_EXPR\",\n+        \"METHOD_CALL_EXPR\",\n+        \"FIELD_EXPR\",\n+        \"AWAIT_EXPR\",\n+        \"TRY_EXPR\",\n+        \"CAST_EXPR\",\n+        // unary\n+        \"REF_EXPR\",\n+        \"PREFIX_EXPR\",\n+        \"RANGE_EXPR\", // just weird\n+        \"BIN_EXPR\",\n+        \"BLOCK\",\n+        \"EXTERN_BLOCK\",\n+        \"EXTERN_ITEM_LIST\",\n+        \"ENUM_VARIANT\",\n+        \"RECORD_FIELD_DEF_LIST\",\n+        \"RECORD_FIELD_DEF\",\n+        \"TUPLE_FIELD_DEF_LIST\",\n+        \"TUPLE_FIELD_DEF\",\n+        \"ENUM_VARIANT_LIST\",\n+        \"ITEM_LIST\",\n+        \"ATTR\",\n+        \"META_ITEM\", // not an item actually\n+        \"USE_TREE\",\n+        \"USE_TREE_LIST\",\n+        \"PATH\",\n+        \"PATH_SEGMENT\",\n+        \"LITERAL\",\n+        \"ALIAS\",\n+        \"VISIBILITY\",\n+        \"WHERE_CLAUSE\",\n+        \"WHERE_PRED\",\n+        \"ABI\",\n+        \"NAME\",\n+        \"NAME_REF\",\n+        \"LET_STMT\",\n+        \"EXPR_STMT\",\n+        \"TYPE_PARAM_LIST\",\n+        \"LIFETIME_PARAM\",\n+        \"TYPE_PARAM\",\n+        \"CONST_PARAM\",\n+        \"TYPE_ARG_LIST\",\n+        \"LIFETIME_ARG\",\n+        \"TYPE_ARG\",\n+        \"ASSOC_TYPE_ARG\",\n+        \"PARAM_LIST\",\n+        \"PARAM\",\n+        \"SELF_PARAM\",\n+        \"ARG_LIST\",\n+        \"TYPE_BOUND\",\n+        \"TYPE_BOUND_LIST\",\n+        // macro related\n+        \"MACRO_ITEMS\",\n+        \"MACRO_STMTS\",\n+    ],\n+};\n+\n+pub(crate) struct AstSrc<'a> {\n+    pub(crate) nodes: &'a [AstNodeSrc<'a>],\n+    pub(crate) enums: &'a [AstEnumSrc<'a>],\n+}\n+\n+pub(crate) struct AstNodeSrc<'a> {\n+    pub(crate) name: &'a str,\n+    pub(crate) traits: &'a [&'a str],\n+    pub(crate) fields: &'a [(&'a str, FieldSrc<&'a str>)],\n+}\n+\n+pub(crate) enum FieldSrc<T> {\n+    Shorthand,\n+    Optional(T),\n+    Many(T),\n+}\n+\n+pub(crate) struct AstEnumSrc<'a> {\n+    pub(crate) name: &'a str,\n+    pub(crate) traits: &'a [&'a str],\n+    pub(crate) variants: &'a [&'a str],\n+}\n+\n+macro_rules! ast_nodes {\n+    ($(\n+        struct $name:ident$(: $($trait:ident),*)? {\n+            $($field_name:ident $(: $ty:tt)?),*$(,)?\n+        }\n+    )*) => {\n+        [$(\n+            AstNodeSrc {\n+                name: stringify!($name),\n+                traits: &[$($(stringify!($trait)),*)?],\n+                fields: &[$(\n+                    (stringify!($field_name), field_ty!($field_name $($ty)?))\n+                ),*],\n+\n+            }\n+        ),*]\n+    };\n+}\n+\n+macro_rules! field_ty {\n+    ($field_name:ident) => {\n+        FieldSrc::Shorthand\n+    };\n+    ($field_name:ident [$ty:ident]) => {\n+        FieldSrc::Many(stringify!($ty))\n+    };\n+    ($field_name:ident $ty:ident) => {\n+        FieldSrc::Optional(stringify!($ty))\n+    };\n+}\n+\n+macro_rules! ast_enums {\n+    ($(\n+        enum $name:ident $(: $($trait:ident),*)? {\n+            $($variant:ident),*$(,)?\n+        }\n+    )*) => {\n+        [$(\n+            AstEnumSrc {\n+                name: stringify!($name),\n+                traits: &[$($(stringify!($trait)),*)?],\n+                variants: &[$(stringify!($variant)),*],\n+\n+            }\n+        ),*]\n+    };\n+}\n+\n+pub(crate) const AST_SRC: AstSrc = AstSrc {\n+    nodes: &ast_nodes! {\n+        struct SourceFile: ModuleItemOwner, FnDefOwner {\n+            modules: [Module],\n+        }\n+\n+        struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n+            ParamList,\n+            RetType,\n+            body: BlockExpr,\n+        }\n+\n+        struct RetType { TypeRef }\n+\n+        struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+        }\n+\n+        struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            RecordFieldDefList,\n+        }\n+\n+        struct RecordFieldDefList { fields: [RecordFieldDef] }\n+        struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n+\n+        struct TupleFieldDefList { fields: [TupleFieldDef] }\n+        struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n+            TypeRef,\n+        }\n+\n+        struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            variant_list: EnumVariantList,\n+        }\n+        struct EnumVariantList {\n+            variants: [EnumVariant],\n+        }\n+        struct EnumVariant: NameOwner, DocCommentsOwner, AttrsOwner {\n+            Expr\n+        }\n+\n+        struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n+            ItemList,\n+        }\n+\n+        struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n+            ItemList,\n+        }\n+\n+        struct ItemList: FnDefOwner, ModuleItemOwner {\n+            impl_items: [ImplItem],\n+        }\n+\n+        struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            body: Expr,\n+        }\n+\n+        struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            body: Expr,\n+        }\n+\n+        struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n+            TypeRef,\n+        }\n+\n+        struct ImplBlock: TypeParamsOwner, AttrsOwner {\n+            ItemList,\n+        }\n+\n+        struct ParenType { TypeRef }\n+        struct TupleType { fields: [TypeRef] }\n+        struct NeverType { }\n+        struct PathType { Path }\n+        struct PointerType { TypeRef }\n+        struct ArrayType { TypeRef, Expr }\n+        struct SliceType { TypeRef }\n+        struct ReferenceType { TypeRef }\n+        struct PlaceholderType {  }\n+        struct FnPointerType { ParamList, RetType }\n+        struct ForType { TypeRef }\n+        struct ImplTraitType: TypeBoundsOwner {}\n+        struct DynTraitType: TypeBoundsOwner {}\n+\n+        struct TupleExpr { exprs: [Expr] }\n+        struct ArrayExpr { exprs: [Expr] }\n+        struct ParenExpr { Expr }\n+        struct PathExpr  { Path }\n+        struct LambdaExpr {\n+            ParamList,\n+            RetType,\n+            body: Expr,\n+        }\n+        struct IfExpr { Condition }\n+        struct LoopExpr: LoopBodyOwner { }\n+        struct TryBlockExpr { body: BlockExpr }\n+        struct ForExpr: LoopBodyOwner {\n+            Pat,\n+            iterable: Expr,\n+        }\n+        struct WhileExpr: LoopBodyOwner { Condition }\n+        struct ContinueExpr {}\n+        struct BreakExpr { Expr }\n+        struct Label {}\n+        struct BlockExpr { Block  }\n+        struct ReturnExpr { Expr }\n+        struct CallExpr: ArgListOwner { Expr }\n+        struct MethodCallExpr: ArgListOwner {\n+            Expr, NameRef, TypeArgList,\n+        }\n+        struct IndexExpr {}\n+        struct FieldExpr { Expr, NameRef }\n+        struct AwaitExpr { Expr }\n+        struct TryExpr { Expr }\n+        struct CastExpr { Expr, TypeRef }\n+        struct RefExpr { Expr }\n+        struct PrefixExpr { Expr }\n+        struct BoxExpr { Expr }\n+        struct RangeExpr {}\n+        struct BinExpr {}\n+        struct Literal {}\n+\n+        struct MatchExpr { Expr, MatchArmList }\n+        struct MatchArmList: AttrsOwner { arms: [MatchArm] }\n+        struct MatchArm: AttrsOwner {\n+            pats: [Pat],\n+            guard: MatchGuard,\n+            Expr,\n+         }\n+        struct MatchGuard { Expr }\n+\n+        struct RecordLit { Path, RecordFieldList }\n+        struct RecordFieldList {\n+            fields: [RecordField],\n+            spread: Expr,\n+         }\n+        struct RecordField { NameRef, Expr }\n+\n+        struct RefPat { Pat }\n+        struct BoxPat { Pat }\n+        struct BindPat: NameOwner { Pat }\n+        struct PlaceholderPat { }\n+        struct DotDotPat { }\n+        struct PathPat {  Path }\n+        struct SlicePat {}\n+        struct RangePat {}\n+        struct LiteralPat { Literal }\n+\n+        struct RecordPat { RecordFieldPatList, Path }\n+        struct RecordFieldPatList {\n+            record_field_pats: [RecordFieldPat],\n+            bind_pats: [BindPat],\n+        }\n+        struct RecordFieldPat: NameOwner { Pat }\n+\n+        struct TupleStructPat { Path, args: [Pat] }\n+        struct TuplePat { args: [Pat] }\n+\n+        struct Visibility {}\n+        struct Name {}\n+        struct NameRef {}\n+\n+        struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n+            TokenTree, Path\n+        }\n+        struct Attr { Path, input: AttrInput }\n+        struct TokenTree {}\n+        struct TypeParamList {\n+            type_params: [TypeParam],\n+            lifetime_params: [LifetimeParam],\n+        }\n+        struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n+            default_type: TypeRef,\n+        }\n+        struct ConstParam: NameOwner, AttrsOwner, TypeAscriptionOwner {\n+            default_val: Expr,\n+        }\n+        struct LifetimeParam: AttrsOwner { }\n+        struct TypeBound { TypeRef}\n+        struct TypeBoundList { bounds: [TypeBound] }\n+        struct WherePred: TypeBoundsOwner { TypeRef }\n+        struct WhereClause { predicates: [WherePred] }\n+        struct ExprStmt { Expr }\n+        struct LetStmt: TypeAscriptionOwner {\n+            Pat,\n+            initializer: Expr,\n+        }\n+        struct Condition { Pat, Expr }\n+        struct Block: AttrsOwner, ModuleItemOwner {\n+            statements: [Stmt],\n+            Expr,\n+        }\n+        struct ParamList {\n+            SelfParam,\n+            params: [Param],\n+        }\n+        struct SelfParam: TypeAscriptionOwner, AttrsOwner { }\n+        struct Param: TypeAscriptionOwner, AttrsOwner {\n+            Pat,\n+        }\n+        struct UseItem: AttrsOwner, VisibilityOwner {\n+            UseTree,\n+        }\n+        struct UseTree {\n+            Path, UseTreeList, Alias\n+        }\n+        struct Alias: NameOwner { }\n+        struct UseTreeList { use_trees: [UseTree] }\n+        struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n+            NameRef, Alias,\n+        }\n+        struct ArgList {\n+            args: [Expr],\n+        }\n+        struct Path {\n+            segment: PathSegment,\n+            qualifier: Path,\n+        }\n+        struct PathSegment {\n+            NameRef, TypeArgList, ParamList, RetType, PathType,\n+        }\n+        struct TypeArgList {\n+            type_args: [TypeArg],\n+            lifetime_args: [LifetimeArg],\n+            assoc_type_args: [AssocTypeArg],\n+        }\n+        struct TypeArg { TypeRef }\n+        struct AssocTypeArg { NameRef, TypeRef }\n+        struct LifetimeArg {}\n+\n+        struct MacroItems: ModuleItemOwner, FnDefOwner { }\n+\n+        struct MacroStmts {\n+            statements: [Stmt],\n+            Expr,\n+        }\n+    },\n+    enums: &ast_enums! {\n+        enum NominalDef: NameOwner, TypeParamsOwner, AttrsOwner {\n+            StructDef, EnumDef, UnionDef,\n+        }\n+\n+        enum TypeRef {\n+            ParenType,\n+            TupleType,\n+            NeverType,\n+            PathType,\n+            PointerType,\n+            ArrayType,\n+            SliceType,\n+            ReferenceType,\n+            PlaceholderType,\n+            FnPointerType,\n+            ForType,\n+            ImplTraitType,\n+            DynTraitType,\n+        }\n+\n+        enum ModuleItem: AttrsOwner, VisibilityOwner {\n+            StructDef,\n+            UnionDef,\n+            EnumDef,\n+            FnDef,\n+            TraitDef,\n+            TypeAliasDef,\n+            ImplBlock,\n+            UseItem,\n+            ExternCrateItem,\n+            ConstDef,\n+            StaticDef,\n+            Module,\n+        }\n+\n+        enum ImplItem: AttrsOwner {\n+            FnDef, TypeAliasDef, ConstDef,\n+        }\n+\n+        enum Expr {\n+            TupleExpr,\n+            ArrayExpr,\n+            ParenExpr,\n+            PathExpr,\n+            LambdaExpr,\n+            IfExpr,\n+            LoopExpr,\n+            ForExpr,\n+            WhileExpr,\n+            ContinueExpr,\n+            BreakExpr,\n+            Label,\n+            BlockExpr,\n+            ReturnExpr,\n+            MatchExpr,\n+            RecordLit,\n+            CallExpr,\n+            IndexExpr,\n+            MethodCallExpr,\n+            FieldExpr,\n+            AwaitExpr,\n+            TryExpr,\n+            TryBlockExpr,\n+            CastExpr,\n+            RefExpr,\n+            PrefixExpr,\n+            RangeExpr,\n+            BinExpr,\n+            Literal,\n+            MacroCall,\n+            BoxExpr,\n+        }\n+\n+        enum Pat {\n+            RefPat,\n+            BoxPat,\n+            BindPat,\n+            PlaceholderPat,\n+            DotDotPat,\n+            PathPat,\n+            RecordPat,\n+            TupleStructPat,\n+            TuplePat,\n+            SlicePat,\n+            RangePat,\n+            LiteralPat,\n+        }\n+\n+        enum AttrInput { Literal, TokenTree }\n+        enum Stmt { ExprStmt, LetStmt }\n+    },\n+};"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "xtask/src/boilerplate_gen.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cb160f2a3457a4c1e9ae0d0a9abd4e807af0c29a/xtask%2Fsrc%2Fboilerplate_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb160f2a3457a4c1e9ae0d0a9abd4e807af0c29a/xtask%2Fsrc%2Fboilerplate_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fboilerplate_gen.rs?ref=cb160f2a3457a4c1e9ae0d0a9abd4e807af0c29a"}, {"sha": "158cfc2d680c228eea94413af708798cf9c7fedb", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -24,7 +24,6 @@ pub use self::{\n     gen_syntax::generate_syntax,\n };\n \n-pub const GRAMMAR: &str = \"crates/ra_syntax/src/grammar.ron\";\n const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";\n const OK_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/ok\";\n const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/err\";"}, {"sha": "0f50ca569330e6b90363efad93c507ff828d545e", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 98, "deletions": 136, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -3,149 +3,142 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n-use std::{collections::BTreeMap, fs};\n-\n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n-use ron;\n-use serde::Deserialize;\n \n use crate::{\n+    ast_src::{AstSrc, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n     codegen::{self, update, Mode},\n     project_root, Result,\n };\n \n pub fn generate_syntax(mode: Mode) -> Result<()> {\n-    let grammar = project_root().join(codegen::GRAMMAR);\n-    let grammar: Grammar = {\n-        let text = fs::read_to_string(grammar)?;\n-        ron::de::from_str(&text)?\n-    };\n-\n     let syntax_kinds_file = project_root().join(codegen::SYNTAX_KINDS);\n-    let syntax_kinds = generate_syntax_kinds(&grammar)?;\n+    let syntax_kinds = generate_syntax_kinds(KINDS_SRC)?;\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n     let ast_file = project_root().join(codegen::AST);\n-    let ast = generate_ast(&grammar)?;\n+    let ast = generate_ast(AST_SRC)?;\n     update(ast_file.as_path(), &ast, mode)?;\n \n     Ok(())\n }\n \n-fn generate_ast(grammar: &Grammar) -> Result<String> {\n-    let nodes = grammar.ast.iter().map(|(name, ast_node)| {\n-        let variants =\n-            ast_node.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n-        let name = format_ident!(\"{}\", name);\n-\n-        let adt = if variants.is_empty() {\n-            let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n-            quote! {\n-                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-                pub struct #name {\n-                    pub(crate) syntax: SyntaxNode,\n-                }\n+fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n+    let nodes = grammar.nodes.iter().map(|node| {\n+        let name = format_ident!(\"{}\", node.name);\n+        let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n+        let traits = node.traits.iter().map(|trait_name| {\n+            let trait_name = format_ident!(\"{}\", trait_name);\n+            quote!(impl ast::#trait_name for #name {})\n+        });\n \n-                impl AstNode for #name {\n-                    fn can_cast(kind: SyntaxKind) -> bool {\n-                        match kind {\n-                            #kind => true,\n-                            _ => false,\n+        let methods = node.fields.iter().map(|(name, field)| {\n+            let method_name = match field {\n+                FieldSrc::Shorthand => format_ident!(\"{}\", to_lower_snake_case(&name)),\n+                _ => format_ident!(\"{}\", name),\n+            };\n+            let ty = match field {\n+                FieldSrc::Optional(ty) | FieldSrc::Many(ty) => ty,\n+                FieldSrc::Shorthand => name,\n+            };\n+            let ty = format_ident!(\"{}\", ty);\n+\n+            match field {\n+                FieldSrc::Many(_) => {\n+                    quote! {\n+                        pub fn #method_name(&self) -> AstChildren<#ty> {\n+                            AstChildren::new(&self.syntax)\n                         }\n                     }\n-                    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                }\n+                FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n+                    quote! {\n+                        pub fn #method_name(&self) -> Option<#ty> {\n+                            AstChildren::new(&self.syntax).next()\n+                        }\n                     }\n-                    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n                 }\n             }\n-        } else {\n-            let kinds = variants\n-                .iter()\n-                .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n-                .collect::<Vec<_>>();\n-\n-            quote! {\n-                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-                pub enum #name {\n-                    #(#variants(#variants),)*\n-                }\n+        });\n \n-                #(\n-                impl From<#variants> for #name {\n-                    fn from(node: #variants) -> #name {\n-                        #name::#variants(node)\n-                    }\n-                }\n-                )*\n+        quote! {\n+            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+            pub struct #name {\n+                pub(crate) syntax: SyntaxNode,\n+            }\n \n-                impl AstNode for #name {\n-                    fn can_cast(kind: SyntaxKind) -> bool {\n-                        match kind {\n-                            #(#kinds)|* => true,\n-                            _ => false,\n-                        }\n-                    }\n-                    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-                        let res = match syntax.kind() {\n-                            #(\n-                            #kinds => #name::#variants(#variants { syntax }),\n-                            )*\n-                            _ => return None,\n-                        };\n-                        Some(res)\n-                    }\n-                    fn syntax(&self) -> &SyntaxNode {\n-                        match self {\n-                            #(\n-                            #name::#variants(it) => &it.syntax,\n-                            )*\n-                        }\n+            impl AstNode for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #kind => true,\n+                        _ => false,\n                     }\n                 }\n+                fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                }\n+                fn syntax(&self) -> &SyntaxNode { &self.syntax }\n             }\n-        };\n+            #(#traits)*\n+\n+            impl #name {\n+                #(#methods)*\n+            }\n+        }\n+    });\n \n-        let traits = ast_node.traits.iter().map(|trait_name| {\n+    let enums = grammar.enums.iter().map(|en| {\n+        let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n+        let name = format_ident!(\"{}\", en.name);\n+        let kinds = variants\n+            .iter()\n+            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n+            .collect::<Vec<_>>();\n+        let traits = en.traits.iter().map(|trait_name| {\n             let trait_name = format_ident!(\"{}\", trait_name);\n             quote!(impl ast::#trait_name for #name {})\n         });\n \n-        let collections = ast_node.collections.iter().map(|(name, kind)| {\n-            let method_name = format_ident!(\"{}\", name);\n-            let kind = format_ident!(\"{}\", kind);\n-            quote! {\n-                pub fn #method_name(&self) -> AstChildren<#kind> {\n-                    AstChildren::new(&self.syntax)\n-                }\n+        quote! {\n+            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+            pub enum #name {\n+                #(#variants(#variants),)*\n             }\n-        });\n \n-        let options = ast_node.options.iter().map(|attr| {\n-            let method_name = match attr {\n-                Attr::Type(t) => format_ident!(\"{}\", to_lower_snake_case(&t)),\n-                Attr::NameType(n, _) => format_ident!(\"{}\", n),\n-            };\n-            let ty = match attr {\n-                Attr::Type(t) | Attr::NameType(_, t) => format_ident!(\"{}\", t),\n-            };\n-            quote! {\n-                pub fn #method_name(&self) -> Option<#ty> {\n-                    AstChildren::new(&self.syntax).next()\n+            #(\n+            impl From<#variants> for #name {\n+                fn from(node: #variants) -> #name {\n+                    #name::#variants(node)\n                 }\n             }\n-        });\n-\n-        quote! {\n-            #adt\n-\n-            #(#traits)*\n+            )*\n \n-            impl #name {\n-                #(#collections)*\n-                #(#options)*\n+            impl AstNode for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #(#kinds)|* => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                    let res = match syntax.kind() {\n+                        #(\n+                        #kinds => #name::#variants(#variants { syntax }),\n+                        )*\n+                        _ => return None,\n+                    };\n+                    Some(res)\n+                }\n+                fn syntax(&self) -> &SyntaxNode {\n+                    match self {\n+                        #(\n+                        #name::#variants(it) => &it.syntax,\n+                        )*\n+                    }\n+                }\n             }\n+            #(#traits)*\n         }\n     });\n \n@@ -156,13 +149,14 @@ fn generate_ast(grammar: &Grammar) -> Result<String> {\n         };\n \n         #(#nodes)*\n+        #(#enums)*\n     };\n \n     let pretty = codegen::reformat(ast)?;\n     Ok(pretty)\n }\n \n-fn generate_syntax_kinds(grammar: &Grammar) -> Result<String> {\n+fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> Result<String> {\n     let (single_byte_tokens_values, single_byte_tokens): (Vec<_>, Vec<_>) = grammar\n         .punct\n         .iter()\n@@ -274,38 +268,6 @@ fn generate_syntax_kinds(grammar: &Grammar) -> Result<String> {\n     codegen::reformat(ast)\n }\n \n-#[derive(Deserialize, Debug)]\n-struct Grammar {\n-    punct: Vec<(String, String)>,\n-    keywords: Vec<String>,\n-    contextual_keywords: Vec<String>,\n-    literals: Vec<String>,\n-    tokens: Vec<String>,\n-    nodes: Vec<String>,\n-    ast: BTreeMap<String, AstNode>,\n-}\n-\n-#[derive(Deserialize, Debug)]\n-struct AstNode {\n-    #[serde(default)]\n-    #[serde(rename = \"enum\")]\n-    variants: Vec<String>,\n-\n-    #[serde(default)]\n-    traits: Vec<String>,\n-    #[serde(default)]\n-    collections: Vec<(String, String)>,\n-    #[serde(default)]\n-    options: Vec<Attr>,\n-}\n-\n-#[derive(Deserialize, Debug)]\n-#[serde(untagged)]\n-enum Attr {\n-    Type(String),\n-    NameType(String, String),\n-}\n-\n fn to_upper_snake_case(s: &str) -> String {\n     let mut buf = String::with_capacity(s.len());\n     let mut prev_is_upper = None;"}, {"sha": "51a868dee97ee56afd8c3fd1b77432aab5ea1846", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/823c15215e65c9701504902ffbd80c576232942e/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=823c15215e65c9701504902ffbd80c576232942e", "patch": "@@ -1,6 +1,7 @@\n //! FIXME: write short doc here\n \n pub mod codegen;\n+mod ast_src;\n \n use anyhow::Context;\n pub use anyhow::Result;"}]}