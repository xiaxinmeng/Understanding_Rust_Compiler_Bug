{"sha": "67cb5ec29f0e1adb55f945a8acea20c47f586c56", "node_id": "C_kwDOAAsO6NoAKDY3Y2I1ZWMyOWYwZTFhZGI1NWY5NDVhOGFjZWEyMGM0N2Y1ODZjNTY", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T18:31:36Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-03T23:09:49Z"}, "message": "Move `TryErr` into `Matches` lint pass", "tree": {"sha": "e4270d57af397abecf15a26f233c60a28b3d2a85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4270d57af397abecf15a26f233c60a28b3d2a85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67cb5ec29f0e1adb55f945a8acea20c47f586c56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67cb5ec29f0e1adb55f945a8acea20c47f586c56", "html_url": "https://github.com/rust-lang/rust/commit/67cb5ec29f0e1adb55f945a8acea20c47f586c56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67cb5ec29f0e1adb55f945a8acea20c47f586c56/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbc7753fb2b5e1af5c00f3c1e246cfd594611c75", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc7753fb2b5e1af5c00f3c1e246cfd594611c75", "html_url": "https://github.com/rust-lang/rust/commit/dbc7753fb2b5e1af5c00f3c1e246cfd594611c75"}], "stats": {"total": 378, "additions": 188, "deletions": 190}, "files": [{"sha": "c8cebca89d5872a882cc9265405e1f7c5e4edfc8", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=67cb5ec29f0e1adb55f945a8acea20c47f586c56", "patch": "@@ -279,6 +279,7 @@ store.register_lints(&[\n     matches::SIGNIFICANT_DROP_IN_SCRUTINEE,\n     matches::SINGLE_MATCH,\n     matches::SINGLE_MATCH_ELSE,\n+    matches::TRY_ERR,\n     matches::WILDCARD_ENUM_MATCH_ARM,\n     matches::WILDCARD_IN_OR_PATTERNS,\n     mem_forget::MEM_FORGET,\n@@ -521,7 +522,6 @@ store.register_lints(&[\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,\n     transmuting_null::TRANSMUTING_NULL,\n-    try_err::TRY_ERR,\n     types::BORROWED_BOX,\n     types::BOX_COLLECTION,\n     types::LINKEDLIST,"}, {"sha": "942a53459fd921e9c405f72ac9b14aade8b4dd67", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=67cb5ec29f0e1adb55f945a8acea20c47f586c56", "patch": "@@ -30,6 +30,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n     LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n     LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n+    LintId::of(matches::TRY_ERR),\n     LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n     LintId::of(mem_forget::MEM_FORGET),\n     LintId::of(methods::CLONE_ON_REF_PTR),\n@@ -67,7 +68,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(strings::STRING_SLICE),\n     LintId::of(strings::STRING_TO_STRING),\n     LintId::of(strings::STR_TO_STRING),\n-    LintId::of(try_err::TRY_ERR),\n     LintId::of(types::RC_BUFFER),\n     LintId::of(types::RC_MUTEX),\n     LintId::of(undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS),"}, {"sha": "d9941d75f787a0510620a439aae45838f64a3a23", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=67cb5ec29f0e1adb55f945a8acea20c47f586c56", "patch": "@@ -385,7 +385,6 @@ mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n-mod try_err;\n mod types;\n mod undocumented_unsafe_blocks;\n mod unicode;\n@@ -700,7 +699,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_late_pass(move || Box::new(pass_by_ref_or_value));\n     store.register_late_pass(|| Box::new(ref_option_ref::RefOptionRef));\n-    store.register_late_pass(|| Box::new(try_err::TryErr));\n     store.register_late_pass(|| Box::new(bytecount::ByteCount));\n     store.register_late_pass(|| Box::new(infinite_iter::InfiniteIter));\n     store.register_late_pass(|| Box::new(inline_fn_without_body::InlineFnWithoutBody));"}, {"sha": "fee7471f17d05f4127574723135792513437786e", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=67cb5ec29f0e1adb55f945a8acea20c47f586c56", "patch": "@@ -27,6 +27,7 @@ mod redundant_pattern_match;\n mod rest_pat_in_fully_bound_struct;\n mod significant_drop_in_scrutinee;\n mod single_match;\n+mod try_err;\n mod wild_in_or_pats;\n \n declare_clippy_lint! {\n@@ -825,6 +826,41 @@ declare_clippy_lint! {\n     \"warns when a temporary of a type with a drop with a significant side-effect might have a surprising lifetime\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `Err(x)?`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `?` operator is designed to allow calls that\n+    /// can fail to be easily chained. For example, `foo()?.bar()` or\n+    /// `foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\n+    /// always return), it is more clear to write `return Err(x)`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn foo(fail: bool) -> Result<i32, String> {\n+    ///     if fail {\n+    ///       Err(\"failed\")?;\n+    ///     }\n+    ///     Ok(0)\n+    /// }\n+    /// ```\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// fn foo(fail: bool) -> Result<i32, String> {\n+    ///     if fail {\n+    ///       return Err(\"failed\".into());\n+    ///     }\n+    ///     Ok(0)\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.38.0\"]\n+    pub TRY_ERR,\n+    restriction,\n+    \"return errors explicitly rather than hiding them behind a `?`\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -864,6 +900,7 @@ impl_lint_pass!(Matches => [\n     MATCH_ON_VEC_ITEMS,\n     MATCH_STR_CASE_MISMATCH,\n     SIGNIFICANT_DROP_IN_SCRUTINEE,\n+    TRY_ERR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -888,6 +925,10 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 wild_in_or_pats::check(cx, arms);\n             }\n \n+            if source == MatchSource::TryDesugar {\n+                try_err::check(cx, expr, ex);\n+            }\n+\n             if !from_expansion && !contains_cfg_arm(cx, expr, ex, arms) {\n                 if source == MatchSource::Normal {\n                     if !(meets_msrv(self.msrv, msrvs::MATCHES_MACRO)"}, {"sha": "0491a0679f37abc89393aec264321c296316b721", "filename": "clippy_lints/src/matches/try_err.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cb5ec29f0e1adb55f945a8acea20c47f586c56/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs?ref=67cb5ec29f0e1adb55f945a8acea20c47f586c56", "patch": "@@ -0,0 +1,145 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::ResultErr;\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::{hygiene, sym};\n+\n+use super::TRY_ERR;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, scrutinee: &'tcx Expr<'_>) {\n+    // Looks for a structure like this:\n+    // match ::std::ops::Try::into_result(Err(5)) {\n+    //     ::std::result::Result::Err(err) =>\n+    //         #[allow(unreachable_code)]\n+    //         return ::std::ops::Try::from_error(::std::convert::From::from(err)),\n+    //     ::std::result::Result::Ok(val) =>\n+    //         #[allow(unreachable_code)]\n+    //         val,\n+    // };\n+    if_chain! {\n+        if let ExprKind::Call(match_fun, try_args) = scrutinee.kind;\n+        if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n+        if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n+        if let Some(try_arg) = try_args.get(0);\n+        if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n+        if let Some(err_arg) = err_args.get(0);\n+        if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n+        if is_lang_ctor(cx, err_fun_path, ResultErr);\n+        if let Some(return_ty) = find_return_type(cx, &expr.kind);\n+        then {\n+            let prefix;\n+            let suffix;\n+            let err_ty;\n+\n+            if let Some(ty) = result_error_type(cx, return_ty) {\n+                prefix = \"Err(\";\n+                suffix = \")\";\n+                err_ty = ty;\n+            } else if let Some(ty) = poll_result_error_type(cx, return_ty) {\n+                prefix = \"Poll::Ready(Err(\";\n+                suffix = \"))\";\n+                err_ty = ty;\n+            } else if let Some(ty) = poll_option_result_error_type(cx, return_ty) {\n+                prefix = \"Poll::Ready(Some(Err(\";\n+                suffix = \")))\";\n+                err_ty = ty;\n+            } else {\n+                return;\n+            };\n+\n+            let expr_err_ty = cx.typeck_results().expr_ty(err_arg);\n+            let span = hygiene::walk_chain(err_arg.span, try_arg.span.ctxt());\n+            let mut applicability = Applicability::MachineApplicable;\n+            let origin_snippet = snippet_with_applicability(cx, span, \"_\", &mut applicability);\n+            let ret_prefix = if get_parent_expr(cx, expr).map_or(false, |e| matches!(e.kind, ExprKind::Ret(_))) {\n+                \"\" // already returns\n+            } else {\n+                \"return \"\n+            };\n+            let suggestion = if err_ty == expr_err_ty {\n+                format!(\"{}{}{}{}\", ret_prefix, prefix, origin_snippet, suffix)\n+            } else {\n+                format!(\"{}{}{}.into(){}\", ret_prefix, prefix, origin_snippet, suffix)\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                TRY_ERR,\n+                expr.span,\n+                \"returning an `Err(_)` with the `?` operator\",\n+                \"try this\",\n+                suggestion,\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+/// Finds function return type by examining return expressions in match arms.\n+fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n+    if let ExprKind::Match(_, arms, MatchSource::TryDesugar) = expr {\n+        for arm in arms.iter() {\n+            if let ExprKind::Ret(Some(ret)) = arm.body.kind {\n+                return Some(cx.typeck_results().expr_ty(ret));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+/// Extracts the error type from Result<T, E>.\n+fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(_, subst) = ty.kind();\n+        if is_type_diagnostic_item(cx, ty, sym::Result);\n+        then {\n+            Some(subst.type_at(1))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extracts the error type from Poll<Result<T, E>>.\n+fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(def, subst) = ty.kind();\n+        if match_def_path(cx, def.did(), &paths::POLL);\n+        let ready_ty = subst.type_at(0);\n+\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n+        if cx.tcx.is_diagnostic_item(sym::Result, ready_def.did());\n+        then {\n+            Some(ready_subst.type_at(1))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extracts the error type from Poll<Option<Result<T, E>>>.\n+fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(def, subst) = ty.kind();\n+        if match_def_path(cx, def.did(), &paths::POLL);\n+        let ready_ty = subst.type_at(0);\n+\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n+        if cx.tcx.is_diagnostic_item(sym::Option, ready_def.did());\n+        let some_ty = ready_subst.type_at(0);\n+\n+        if let ty::Adt(some_def, some_subst) = some_ty.kind();\n+        if cx.tcx.is_diagnostic_item(sym::Result, some_def.did());\n+        then {\n+            Some(some_subst.type_at(1))\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "e108f7be12e6a69c7835db14c506239fdc9e33fa", "filename": "clippy_lints/src/try_err.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/dbc7753fb2b5e1af5c00f3c1e246cfd594611c75/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc7753fb2b5e1af5c00f3c1e246cfd594611c75/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=dbc7753fb2b5e1af5c00f3c1e246cfd594611c75", "patch": "@@ -1,186 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::ResultErr;\n-use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{hygiene, sym};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usages of `Err(x)?`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The `?` operator is designed to allow calls that\n-    /// can fail to be easily chained. For example, `foo()?.bar()` or\n-    /// `foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\n-    /// always return), it is more clear to write `return Err(x)`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn foo(fail: bool) -> Result<i32, String> {\n-    ///     if fail {\n-    ///       Err(\"failed\")?;\n-    ///     }\n-    ///     Ok(0)\n-    /// }\n-    /// ```\n-    /// Could be written:\n-    ///\n-    /// ```rust\n-    /// fn foo(fail: bool) -> Result<i32, String> {\n-    ///     if fail {\n-    ///       return Err(\"failed\".into());\n-    ///     }\n-    ///     Ok(0)\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.38.0\"]\n-    pub TRY_ERR,\n-    restriction,\n-    \"return errors explicitly rather than hiding them behind a `?`\"\n-}\n-\n-declare_lint_pass!(TryErr => [TRY_ERR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TryErr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        // Looks for a structure like this:\n-        // match ::std::ops::Try::into_result(Err(5)) {\n-        //     ::std::result::Result::Err(err) =>\n-        //         #[allow(unreachable_code)]\n-        //         return ::std::ops::Try::from_error(::std::convert::From::from(err)),\n-        //     ::std::result::Result::Ok(val) =>\n-        //         #[allow(unreachable_code)]\n-        //         val,\n-        // };\n-        if_chain! {\n-            if !in_external_macro(cx.tcx.sess, expr.span);\n-            if let ExprKind::Match(match_arg, _, MatchSource::TryDesugar) = expr.kind;\n-            if let ExprKind::Call(match_fun, try_args) = match_arg.kind;\n-            if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n-            if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n-            if let Some(try_arg) = try_args.get(0);\n-            if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n-            if let Some(err_arg) = err_args.get(0);\n-            if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-            if is_lang_ctor(cx, err_fun_path, ResultErr);\n-            if let Some(return_ty) = find_return_type(cx, &expr.kind);\n-            then {\n-                let prefix;\n-                let suffix;\n-                let err_ty;\n-\n-                if let Some(ty) = result_error_type(cx, return_ty) {\n-                    prefix = \"Err(\";\n-                    suffix = \")\";\n-                    err_ty = ty;\n-                } else if let Some(ty) = poll_result_error_type(cx, return_ty) {\n-                    prefix = \"Poll::Ready(Err(\";\n-                    suffix = \"))\";\n-                    err_ty = ty;\n-                } else if let Some(ty) = poll_option_result_error_type(cx, return_ty) {\n-                    prefix = \"Poll::Ready(Some(Err(\";\n-                    suffix = \")))\";\n-                    err_ty = ty;\n-                } else {\n-                    return;\n-                };\n-\n-                let expr_err_ty = cx.typeck_results().expr_ty(err_arg);\n-                let span = hygiene::walk_chain(err_arg.span, try_arg.span.ctxt());\n-                let mut applicability = Applicability::MachineApplicable;\n-                let origin_snippet = snippet_with_applicability(cx, span, \"_\", &mut applicability);\n-                let ret_prefix = if get_parent_expr(cx, expr).map_or(false, |e| matches!(e.kind, ExprKind::Ret(_))) {\n-                    \"\" // already returns\n-                } else {\n-                    \"return \"\n-                };\n-                let suggestion = if err_ty == expr_err_ty {\n-                    format!(\"{}{}{}{}\", ret_prefix, prefix, origin_snippet, suffix)\n-                } else {\n-                    format!(\"{}{}{}.into(){}\", ret_prefix, prefix, origin_snippet, suffix)\n-                };\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    TRY_ERR,\n-                    expr.span,\n-                    \"returning an `Err(_)` with the `?` operator\",\n-                    \"try this\",\n-                    suggestion,\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Finds function return type by examining return expressions in match arms.\n-fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n-    if let ExprKind::Match(_, arms, MatchSource::TryDesugar) = expr {\n-        for arm in arms.iter() {\n-            if let ExprKind::Ret(Some(ret)) = arm.body.kind {\n-                return Some(cx.typeck_results().expr_ty(ret));\n-            }\n-        }\n-    }\n-    None\n-}\n-\n-/// Extracts the error type from Result<T, E>.\n-fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    if_chain! {\n-        if let ty::Adt(_, subst) = ty.kind();\n-        if is_type_diagnostic_item(cx, ty, sym::Result);\n-        then {\n-            Some(subst.type_at(1))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Extracts the error type from Poll<Result<T, E>>.\n-fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did(), &paths::POLL);\n-        let ready_ty = subst.type_at(0);\n-\n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Result, ready_def.did());\n-        then {\n-            Some(ready_subst.type_at(1))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Extracts the error type from Poll<Option<Result<T, E>>>.\n-fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did(), &paths::POLL);\n-        let ready_ty = subst.type_at(0);\n-\n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Option, ready_def.did());\n-        let some_ty = ready_subst.type_at(0);\n-\n-        if let ty::Adt(some_def, some_subst) = some_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Result, some_def.did());\n-        then {\n-            Some(some_subst.type_at(1))\n-        } else {\n-            None\n-        }\n-    }\n-}"}]}