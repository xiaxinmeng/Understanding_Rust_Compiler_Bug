{"sha": "94bec9070223606632d6112b38670ea1c72763f4", "node_id": "C_kwDOAAsO6NoAKDk0YmVjOTA3MDIyMzYwNjYzMmQ2MTEyYjM4NjcwZWExYzcyNzYzZjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-30T01:08:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-30T01:08:56Z"}, "message": "Auto merge of #91244 - dtolnay:lossy, r=Mark-Simulacrum\n\nEliminate bunch of copies of error codepath from Utf8LossyChunksIter\n\nUsing a macro to stamp out 7 identical copies of the nontrivial slicing logic to exit this loop didn't seem like a necessary use of a macro. The early return case can be handled by `break` without practically any changes to the logic inside the loop.\n\nAll this code is from early 2014 (#12062&mdash;nearly 8 years ago; pre-1.0) so it's possible there were compiler limitations that forced the macro way at the time.\n\nConfirmed that `x.py bench library/alloc --stage 0 --test-args from_utf8_lossy` is unaffected on my machine.", "tree": {"sha": "996e062d8e0e9a785e990411f7af96fba715893b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/996e062d8e0e9a785e990411f7af96fba715893b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94bec9070223606632d6112b38670ea1c72763f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94bec9070223606632d6112b38670ea1c72763f4", "html_url": "https://github.com/rust-lang/rust/commit/94bec9070223606632d6112b38670ea1c72763f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94bec9070223606632d6112b38670ea1c72763f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6db0a0e9a4a2f55b1a85954e114ada0b45c32e45", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db0a0e9a4a2f55b1a85954e114ada0b45c32e45", "html_url": "https://github.com/rust-lang/rust/commit/6db0a0e9a4a2f55b1a85954e114ada0b45c32e45"}, {"sha": "c6810a569f52feff03a36fb496780410b2912783", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6810a569f52feff03a36fb496780410b2912783", "html_url": "https://github.com/rust-lang/rust/commit/c6810a569f52feff03a36fb496780410b2912783"}], "stats": {"total": 75, "additions": 37, "deletions": 38}, "files": [{"sha": "32bd22846e7dd4c7749e231c2b5692efe124aa85", "filename": "library/core/src/str/lossy.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/94bec9070223606632d6112b38670ea1c72763f4/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bec9070223606632d6112b38670ea1c72763f4/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs?ref=94bec9070223606632d6112b38670ea1c72763f4", "patch": "@@ -61,36 +61,26 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         }\n \n         let mut i = 0;\n+        let mut valid_up_to = 0;\n         while i < self.source.len() {\n-            let i_ = i;\n-\n-            // SAFETY: `i` starts at `0`, is less than `self.source.len()`, and\n-            // only increases, so `0 <= i < self.source.len()`.\n+            // SAFETY: `i < self.source.len()` per previous line.\n+            // For some reason the following are both significantly slower:\n+            // while let Some(&byte) = self.source.get(i) {\n+            // while let Some(byte) = self.source.get(i).copied() {\n             let byte = unsafe { *self.source.get_unchecked(i) };\n             i += 1;\n \n             if byte < 128 {\n+                // This could be a `1 => ...` case in the match below, but for\n+                // the common case of all-ASCII inputs, we bypass loading the\n+                // sizeable UTF8_CHAR_WIDTH table into cache.\n             } else {\n                 let w = utf8_char_width(byte);\n \n-                macro_rules! error {\n-                    () => {{\n-                        // SAFETY: We have checked up to `i` that source is valid UTF-8.\n-                        unsafe {\n-                            let r = Utf8LossyChunk {\n-                                valid: from_utf8_unchecked(&self.source[0..i_]),\n-                                broken: &self.source[i_..i],\n-                            };\n-                            self.source = &self.source[i..];\n-                            return Some(r);\n-                        }\n-                    }};\n-                }\n-\n                 match w {\n                     2 => {\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                     }\n@@ -100,13 +90,11 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n                             (0xE1..=0xEC, 0x80..=0xBF) => (),\n                             (0xED, 0x80..=0x9F) => (),\n                             (0xEE..=0xEF, 0x80..=0xBF) => (),\n-                            _ => {\n-                                error!();\n-                            }\n+                            _ => break,\n                         }\n                         i += 1;\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                     }\n@@ -115,34 +103,45 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n                             (0xF0, 0x90..=0xBF) => (),\n                             (0xF1..=0xF3, 0x80..=0xBF) => (),\n                             (0xF4, 0x80..=0x8F) => (),\n-                            _ => {\n-                                error!();\n-                            }\n+                            _ => break,\n                         }\n                         i += 1;\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                     }\n-                    _ => {\n-                        error!();\n-                    }\n+                    _ => break,\n                 }\n             }\n+\n+            valid_up_to = i;\n         }\n \n-        let r = Utf8LossyChunk {\n-            // SAFETY: We have checked that the entire source is valid UTF-8.\n-            valid: unsafe { from_utf8_unchecked(self.source) },\n-            broken: &[],\n-        };\n-        self.source = &[];\n-        Some(r)\n+        // SAFETY: `i <= self.source.len()` because it is only ever incremented\n+        // via `i += 1` and in between every single one of those increments, `i`\n+        // is compared against `self.source.len()`. That happens either\n+        // literally by `i < self.source.len()` in the while-loop's condition,\n+        // or indirectly by `safe_get(self.source, i) & 192 != TAG_CONT_U8`. The\n+        // loop is terminated as soon as the latest `i += 1` has made `i` no\n+        // longer less than `self.source.len()`, which means it'll be at most\n+        // equal to `self.source.len()`.\n+        let (inspected, remaining) = unsafe { self.source.split_at_unchecked(i) };\n+        self.source = remaining;\n+\n+        // SAFETY: `valid_up_to <= i` because it is only ever assigned via\n+        // `valid_up_to = i` and `i` only increases.\n+        let (valid, broken) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n+\n+        Some(Utf8LossyChunk {\n+            // SAFETY: All bytes up to `valid_up_to` are valid UTF-8.\n+            valid: unsafe { from_utf8_unchecked(valid) },\n+            broken,\n+        })\n     }\n }\n "}]}