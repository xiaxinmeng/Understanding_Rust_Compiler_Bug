{"sha": "1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMDVmZDg4ZGYyYjg3YzY4MmYyZTk4ZTMwYmE5ZTJkOGQ0NGQ2NTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-12T16:28:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:30Z"}, "message": "Centralize on using `Binder` to introduce new binding levels, rather than having FnSig carry an implicit binding level.  This means that we be more typesafe in general, since things that instantiate bound regions can drop the Binder to reflect that.", "tree": {"sha": "7a62c03a1501ff3be48f7ba038dc66b14d91e282", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a62c03a1501ff3be48f7ba038dc66b14d91e282"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "html_url": "https://github.com/rust-lang/rust/commit/1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed4952ef392952dc4a7d0241386daf575dea5d6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed4952ef392952dc4a7d0241386daf575dea5d6e", "html_url": "https://github.com/rust-lang/rust/commit/ed4952ef392952dc4a7d0241386daf575dea5d6e"}], "stats": {"total": 1007, "additions": 462, "deletions": 545}, "files": [{"sha": "0625c50d6721f4910b7482f83c7fbcdf2174052b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -429,7 +429,7 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-        Rc::new(ty::bind(doc_trait_ref(tp, tcx, cdata)))\n+        Rc::new(ty::Binder(doc_trait_ref(tp, tcx, cdata)))\n     })\n }\n \n@@ -704,7 +704,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n         let name = item_name(&*intr, item);\n         let (ctor_ty, arg_tys, arg_names) = match ctor_ty.sty {\n             ty::ty_bare_fn(ref f) =>\n-                (Some(ctor_ty), f.sig.inputs.clone(), None),\n+                (Some(ctor_ty), f.sig.0.inputs.clone(), None),\n             _ => { // Nullary or struct enum variant.\n                 let mut arg_names = Vec::new();\n                 let arg_tys = get_struct_fields(intr.clone(), cdata, did.node)"}, {"sha": "f3d700f013d815bfb0960f142c651082dad90cb1", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -414,7 +414,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let trait_ref = ty::bind(parse_trait_ref(st, |x,y| conv(x,y)));\n+        let trait_ref = ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)));\n         let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, trait_ref, bounds);\n@@ -603,7 +603,7 @@ fn parse_bare_fn_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n     }\n }\n \n-fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::FnSig<'tcx> {\n+fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::PolyFnSig<'tcx> {\n     assert_eq!(next(st), '[');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n@@ -622,9 +622,9 @@ fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::FnSig<'\n         }\n         _ => ty::FnConverging(parse_ty(st, |x,y| conv(x,y)))\n     };\n-    ty::FnSig {inputs: inputs,\n-               output: output,\n-               variadic: variadic}\n+    ty::Binder(ty::FnSig {inputs: inputs,\n+                        output: output,\n+                        variadic: variadic})\n }\n \n // Rust metadata parsing\n@@ -669,7 +669,7 @@ pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n                                 -> ty::Predicate<'tcx>\n {\n     match next(st) {\n-        't' => ty::Predicate::Trait(Rc::new(ty::bind(parse_trait_ref(st, conv)))),\n+        't' => ty::Predicate::Trait(Rc::new(ty::Binder(parse_trait_ref(st, conv)))),\n         'e' => ty::Predicate::Equate(parse_ty(st, |x,y| conv(x,y)),\n                                      parse_ty(st, |x,y| conv(x,y))),\n         'r' => ty::Predicate::RegionOutlives(parse_region(st, |x,y| conv(x,y)),\n@@ -764,7 +764,7 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n             }\n             'I' => {\n                 param_bounds.trait_bounds.push(\n-                    Rc::new(ty::bind(parse_trait_ref(st, |x,y| conv(x,y)))));\n+                    Rc::new(ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)))));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "c6218e6fe94782bdd87cbbc80a79583993e12fac", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -251,7 +251,7 @@ fn enc_sty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n         ty::ty_trait(box ty::TyTrait { ref principal,\n                                        ref bounds }) => {\n             mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, &principal.value);\n+            enc_trait_ref(w, cx, &principal.0);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -351,18 +351,18 @@ pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n }\n \n fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n-                        fsig: &ty::FnSig<'tcx>) {\n+                        fsig: &ty::PolyFnSig<'tcx>) {\n     mywrite!(w, \"[\");\n-    for ty in fsig.inputs.iter() {\n+    for ty in fsig.0.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n     mywrite!(w, \"]\");\n-    if fsig.variadic {\n+    if fsig.0.variadic {\n         mywrite!(w, \"V\");\n     } else {\n         mywrite!(w, \"N\");\n     }\n-    match fsig.output {\n+    match fsig.0.output {\n         ty::FnConverging(result_type) => {\n             enc_ty(w, cx, result_type);\n         }\n@@ -401,7 +401,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n \n     for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, &tp.value);\n+        enc_trait_ref(w, cx, &tp.0);\n     }\n \n     mywrite!(w, \".\");\n@@ -425,7 +425,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n             mywrite!(w, \"t\");\n-            enc_trait_ref(w, cx, &trait_ref.value);\n+            enc_trait_ref(w, cx, &trait_ref.0);\n         }\n         ty::Predicate::Equate(a, b) => {\n             mywrite!(w, \"e\");"}, {"sha": "0021533a2bbe6f914e69388e57ccbad943083346", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -887,7 +887,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n                         this.emit_struct(\"MethodParam\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &p.trait_ref.value))\n+                                Ok(this.emit_trait_ref(ecx, &p.trait_ref.0))\n                             }));\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(p.method_num)\n@@ -901,7 +901,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n                         this.emit_struct(\"MethodObject\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &o.trait_ref.value))\n+                                Ok(this.emit_trait_ref(ecx, &o.trait_ref.0))\n                             }));\n                             try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n                                 Ok(this.emit_def_id(o.object_trait_id))\n@@ -1113,7 +1113,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n                         this.emit_enum_variant_arg(0, |this| {\n                             try!(this.emit_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &principal.value))\n+                                Ok(this.emit_trait_ref(ecx, &principal.0))\n                             }));\n                             this.emit_struct_field(\"bounds\", 1, |this| {\n                                 Ok(this.emit_existential_bounds(ecx, b))\n@@ -1277,7 +1277,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_trait_ref(ecx, &trait_ref.value);\n+                rbml_w.emit_trait_ref(ecx, &trait_ref.0);\n             })\n         })\n     }\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n     fn read_poly_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> Rc<ty::PolyTraitRef<'tcx>> {\n-        Rc::new(ty::bind(self.read_opaque(|this, doc| {\n+        Rc::new(ty::Binder(self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,\n                 dcx.cdata.cnum,"}, {"sha": "8b0df4e69cd8e61c91643c0501956ecaa0f7dc8b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -265,7 +265,7 @@ impl OverloadedCallType {\n             }\n             Some(ref trait_ref) => (*trait_ref).clone(),\n         };\n-        OverloadedCallType::from_trait_id(tcx, trait_ref.value.def_id)\n+        OverloadedCallType::from_trait_id(tcx, trait_ref.def_id())\n     }\n \n     fn from_unboxed_closure(tcx: &ty::ctxt, closure_did: ast::DefId)"}, {"sha": "5c0d4b4841ee385377969dfb3db65c0ddb7be444", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -60,7 +60,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_vec(..) => Some(VecSimplifiedType),\n         ty::ty_ptr(_) => Some(PtrSimplifiedType),\n         ty::ty_trait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal.value.def_id))\n+            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n         }\n         ty::ty_struct(def_id, _) => {\n             Some(StructSimplifiedType(def_id))\n@@ -83,10 +83,10 @@ pub fn simplify_type(tcx: &ty::ctxt,\n             Some(TupleSimplifiedType(tys.len()))\n         }\n         ty::ty_closure(ref f) => {\n-            Some(FunctionSimplifiedType(f.sig.inputs.len()))\n+            Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::ty_bare_fn(ref f) => {\n-            Some(FunctionSimplifiedType(f.sig.inputs.len()))\n+            Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::ty_param(_) => {\n             if can_simplify_params {"}, {"sha": "82ddbcee5a72e50a44a5f5cd010e9119e42e8ef6", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -195,7 +195,7 @@ pub trait Combine<'tcx> {\n                    b: &ty::BareFnTy<'tcx>) -> cres<'tcx, ty::BareFnTy<'tcx>> {\n         let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n         let abi = try!(self.abi(a.abi, b.abi));\n-        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n+        let sig = try!(self.binders(&a.sig, &b.sig));\n         Ok(ty::BareFnTy {unsafety: unsafety,\n                          abi: abi,\n                          sig: sig})\n@@ -222,7 +222,7 @@ pub trait Combine<'tcx> {\n         let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n         let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n         let bounds = try!(self.existential_bounds(a.bounds, b.bounds));\n-        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n+        let sig = try!(self.binders(&a.sig, &b.sig));\n         let abi = try!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n             unsafety: unsafety,\n@@ -234,7 +234,43 @@ pub trait Combine<'tcx> {\n         })\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>>;\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>> {\n+        if a.variadic != b.variadic {\n+            return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n+        }\n+\n+        let inputs = try!(argvecs(self,\n+                                  a.inputs.as_slice(),\n+                                  b.inputs.as_slice()));\n+\n+        let output = try!(match (a.output, b.output) {\n+            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+                Ok(ty::FnConverging(try!(self.tys(a_ty, b_ty)))),\n+            (ty::FnDiverging, ty::FnDiverging) =>\n+                Ok(ty::FnDiverging),\n+            (a, b) =>\n+                Err(ty::terr_convergence_mismatch(\n+                    expected_found(self, a != ty::FnDiverging, b != ty::FnDiverging))),\n+        });\n+\n+        return Ok(ty::FnSig {inputs: inputs,\n+                             output: output,\n+                             variadic: a.variadic});\n+\n+\n+        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n+                                           a_args: &[Ty<'tcx>],\n+                                           b_args: &[Ty<'tcx>])\n+                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n+        {\n+            if a_args.len() == b_args.len() {\n+                a_args.iter().zip(b_args.iter())\n+                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n+            } else {\n+                Err(ty::terr_arg_count)\n+            }\n+        }\n+    }\n \n     fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.contratys(a, b).and_then(|t| Ok(t))\n@@ -312,14 +348,36 @@ pub trait Combine<'tcx> {\n         }\n     }\n \n-    fn poly_trait_refs(&self,\n-                       a: &ty::PolyTraitRef<'tcx>,\n-                       b: &ty::PolyTraitRef<'tcx>)\n-                       -> cres<'tcx, ty::PolyTraitRef<'tcx>>;\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>;\n     // this must be overridden to do correctly, so as to account for higher-ranked\n     // behavior\n }\n \n+pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n+}\n+\n+impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &ty::TraitRef<'tcx>,\n+                                b: &ty::TraitRef<'tcx>)\n+                                -> cres<'tcx, ty::TraitRef<'tcx>>\n+    {\n+        combiner.trait_refs(a, b)\n+    }\n+}\n+\n+impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &ty::FnSig<'tcx>,\n+                                b: &ty::FnSig<'tcx>)\n+                                -> cres<'tcx, ty::FnSig<'tcx>>\n+    {\n+        combiner.fn_sigs(a, b)\n+    }\n+}\n+\n #[deriving(Clone)]\n pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -424,7 +482,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_)) => {\n           debug!(\"Trying to match traits {} and {}\", a, b);\n-          let principal = try!(this.poly_trait_refs(&a_.principal, &b_.principal));\n+          let principal = try!(this.binders(&a_.principal, &b_.principal));\n           let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx, principal, bounds))\n       }"}, {"sha": "2a4d20f4dd3799ccdbe7b0fac6dad97333e92d4c", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -133,17 +133,10 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>>\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n     {\n-        try!(self.sub().fn_sigs(a, b));\n-        self.sub().fn_sigs(b, a)\n-    }\n-\n-    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n-                       -> cres<'tcx, ty::PolyTraitRef<'tcx>>\n-    {\n-        try!(self.sub().poly_trait_refs(a, b));\n-        self.sub().poly_trait_refs(b, a)\n+        try!(self.sub().binders(a, b));\n+        self.sub().binders(b, a)\n     }\n }"}, {"sha": "d1253e0b6976bbfb79328be4dc97de5766ecf271", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -1653,7 +1653,7 @@ impl<'tcx> Resolvable<'tcx> for Rc<ty::PolyTraitRef<'tcx>> {\n         Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&self.value)\n+        ty::trait_ref_contains_error(&self.0)\n     }\n }\n "}, {"sha": "434be32fe5fa70162c642c910e716ca9c7acf0e5", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -121,13 +121,9 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n-        self.higher_ranked_glb(a, b)\n-    }\n-\n-    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n-                       -> cres<'tcx, ty::PolyTraitRef<'tcx>> {\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n         self.higher_ranked_glb(a, b)\n     }\n }"}, {"sha": "dcc365fad18eebf75b3b6ec9b75d5b85f4068105", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 33, "deletions": 106, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -11,29 +11,24 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{combine, CombinedSnapshot, cres, InferCtxt, HigherRankedType};\n-use super::combine::Combine;\n+use super::{CombinedSnapshot, cres, InferCtxt, HigherRankedType};\n+use super::combine::{Combine, Combineable};\n \n-use middle::ty::{mod, Ty, replace_late_bound_regions};\n-use middle::ty_fold::{mod, HigherRankedFoldable, TypeFoldable};\n+use middle::ty::{mod, Binder};\n+use middle::ty_fold::{mod, TypeFoldable};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n-use util::ppaux::{bound_region_to_string, Repr};\n-\n-pub trait HigherRankedCombineable<'tcx>: HigherRankedFoldable<'tcx> +\n-                                         TypeFoldable<'tcx> + Repr<'tcx> {\n-    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n-}\n+use util::ppaux::Repr;\n \n pub trait HigherRankedRelations<'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>;\n+    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>;\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>;\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>;\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>;\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>;\n }\n \n trait InferCtxtExt<'tcx> {\n@@ -47,8 +42,9 @@ trait InferCtxtExt<'tcx> {\n impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     where C : Combine<'tcx>\n {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>\n+    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                            -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>\n     {\n         debug!(\"higher_ranked_sub(a={}, b={})\",\n                a.repr(self.tcx()), b.repr(self.tcx()));\n@@ -74,13 +70,14 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n             // Second, we instantiate each bound region in the supertype with a\n             // fresh concrete region.\n-            let (b_prime, skol_map) = skolemize_regions(self.infcx(), b, snapshot);\n+            let (b_prime, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(b, snapshot);\n \n             debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n             debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n \n             // Compare types now that bound regions have been replaced.\n-            let result = try!(HigherRankedCombineable::super_combine(self, &a_prime, &b_prime));\n+            let result = try!(Combineable::combine(self, &a_prime, &b_prime));\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n@@ -102,12 +99,12 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             debug!(\"higher_ranked_sub: OK result={}\",\n                    result.repr(self.tcx()));\n \n-            Ok(result)\n+            Ok(ty::Binder(result))\n         });\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>\n     {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -123,7 +120,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n             // Collect constraints.\n             let result0 =\n-                try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx().resolve_type_vars_if_possible(&result0);\n             debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n@@ -143,7 +140,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                    b.repr(self.tcx()),\n                    result1.repr(self.tcx()));\n \n-            Ok(result1)\n+            Ok(ty::Binder(result1))\n         });\n \n         fn generalize_region(infcx: &InferCtxt,\n@@ -196,8 +193,8 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>\n     {\n         debug!(\"{}.higher_ranked_glb({}, {})\",\n                self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n@@ -217,7 +214,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n             // Collect constraints.\n             let result0 =\n-                try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n             let result0 =\n                 self.infcx().resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n@@ -239,7 +236,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                    b.repr(self.tcx()),\n                    result1.repr(self.tcx()));\n \n-            Ok(result1)\n+            Ok(ty::Binder(result1))\n         });\n \n         fn generalize_region(infcx: &InferCtxt,\n@@ -334,59 +331,6 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     }\n }\n \n-impl<'tcx> HigherRankedCombineable<'tcx> for ty::FnSig<'tcx> {\n-    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-                                      -> cres<'tcx, ty::FnSig<'tcx>>\n-    {\n-        if a.variadic != b.variadic {\n-            return Err(ty::terr_variadic_mismatch(\n-                combine::expected_found(combiner, a.variadic, b.variadic)));\n-        }\n-\n-        let inputs = try!(argvecs(combiner,\n-                                  a.inputs.as_slice(),\n-                                  b.inputs.as_slice()));\n-\n-        let output = try!(match (a.output, b.output) {\n-            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(try!(combiner.tys(a_ty, b_ty)))),\n-            (ty::FnDiverging, ty::FnDiverging) =>\n-                Ok(ty::FnDiverging),\n-            (a, b) =>\n-                Err(ty::terr_convergence_mismatch(\n-                    combine::expected_found(combiner, a != ty::FnDiverging, b != ty::FnDiverging))),\n-        });\n-\n-        return Ok(ty::FnSig {inputs: inputs,\n-                             output: output,\n-                             variadic: a.variadic});\n-\n-\n-        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n-                                           a_args: &[Ty<'tcx>],\n-                                           b_args: &[Ty<'tcx>])\n-                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n-        {\n-            if a_args.len() == b_args.len() {\n-                a_args.iter().zip(b_args.iter())\n-                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n-            } else {\n-                Err(ty::terr_arg_count)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> HigherRankedCombineable<'tcx> for ty::PolyTraitRef<'tcx> {\n-    fn super_combine<C:Combine<'tcx>>(combiner: &C,\n-                                      a: &ty::PolyTraitRef<'tcx>,\n-                                      b: &ty::PolyTraitRef<'tcx>)\n-                                      -> cres<'tcx, ty::PolyTraitRef<'tcx>>\n-    {\n-        Ok(ty::bind(try!(combiner.trait_refs(&a.value, &b.value))))\n-    }\n-}\n-\n fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n                                    map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n                                    -> Vec<ty::RegionVid> {\n@@ -407,11 +351,14 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>, value: &T, mut fldr: F) -> T where\n-    T: HigherRankedFoldable<'tcx>,\n-    F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n+fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n+                               unbound_value: &T,\n+                               mut fldr: F)\n+                               -> T\n+    where T : Combineable<'tcx>,\n+          F : FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n+    unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -508,26 +455,6 @@ impl<'a,'tcx> InferCtxtExt<'tcx> for InferCtxt<'a,'tcx> {\n     }\n }\n \n-fn skolemize_regions<'a,'tcx,HR>(infcx: &InferCtxt<'a,'tcx>,\n-                                 value: &HR,\n-                                 snapshot: &CombinedSnapshot)\n-                                 -> (HR, FnvHashMap<ty::BoundRegion,ty::Region>)\n-    where HR : HigherRankedFoldable<'tcx>\n-{\n-    replace_late_bound_regions(infcx.tcx, value, |br, _| {\n-        let skol =\n-            infcx.region_vars.new_skolemized(\n-                br,\n-                &snapshot.region_vars_snapshot);\n-\n-        debug!(\"Bound region {} skolemized to {}\",\n-               bound_region_to_string(infcx.tcx, \"\", false, br),\n-               skol);\n-\n-        skol\n-    })\n-}\n-\n fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                        skol_map: &FnvHashMap<ty::BoundRegion,ty::Region>,\n                        snapshot: &CombinedSnapshot)"}, {"sha": "f4909b2889163c73217538da16a65489c0375da9", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -113,17 +113,13 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n-        self.higher_ranked_lub(a, b)\n-    }\n-\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n-                       -> cres<'tcx, ty::PolyTraitRef<'tcx>> {\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n         self.higher_ranked_lub(a, b)\n     }\n }"}, {"sha": "edd5c8b854e1fa73abb7f679748ef9dae242f763", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -26,7 +26,7 @@ use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty::replace_late_bound_regions;\n use middle::ty::{mod, Ty};\n-use middle::ty_fold::{HigherRankedFoldable, TypeFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use std::cell::{RefCell};\n use std::rc::Rc;\n use syntax::ast;\n@@ -35,7 +35,7 @@ use syntax::codemap::Span;\n use util::common::indent;\n use util::nodemap::FnvHashMap;\n use util::ppaux::{ty_to_string};\n-use util::ppaux::{trait_ref_to_string, Repr};\n+use util::ppaux::{Repr, UserString};\n \n use self::coercion::Coerce;\n use self::combine::{Combine, CombineFields};\n@@ -699,26 +699,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 values: TraitRefs(expected_found(a_is_expected,\n                                                  a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).poly_trait_refs(&*a, &*b).to_ures()\n+            self.sub(a_is_expected, trace).binders(&*a, &*b).to_ures()\n         })\n     }\n \n-    pub fn skolemize_bound_regions<T>(&self,\n-                                      value: &ty::Binder<T>,\n-                                      snapshot: &CombinedSnapshot)\n-                                      -> (T, SkolemizationMap)\n-        where T : TypeFoldable<'tcx>\n+    pub fn skolemize_late_bound_regions<T>(&self,\n+                                           value: &ty::Binder<T>,\n+                                           snapshot: &CombinedSnapshot)\n+                                           -> (T, SkolemizationMap)\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n-        let (result_binder, map) = replace_late_bound_regions(self.tcx, value, |br, _| {\n+        let (result, map) = replace_late_bound_regions(self.tcx, value, |br, _| {\n             self.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n         });\n \n         debug!(\"skolemize_bound_regions(value={}, result={}, map={})\",\n                value.repr(self.tcx),\n-               result_binder.value.repr(self.tcx),\n+               result.repr(self.tcx),\n                map.repr(self.tcx));\n \n-        (result_binder.value, map)\n+        (result, map)\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef<'tcx>>) -> String {\n         let t = self.resolve_type_vars_if_possible(&**t);\n-        trait_ref_to_string(self.tcx, &t)\n+        t.user_string(self.tcx)\n     }\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n@@ -982,9 +982,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: &T)\n+        value: &ty::Binder<T>)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : HigherRankedFoldable<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n         ty::replace_late_bound_regions(\n             self.tcx,"}, {"sha": "2b8adfb7c1eeb880d1d48663d93c74d23646fa81", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -155,13 +155,9 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n-        self.higher_ranked_sub(a, b)\n-    }\n-\n-    fn poly_trait_refs(&self, a: &ty::PolyTraitRef<'tcx>, b: &ty::PolyTraitRef<'tcx>)\n-                       -> cres<'tcx, ty::PolyTraitRef<'tcx>> {\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n         self.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "ea19111ce3d670f08125320dea1786588396a9d6", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -124,8 +124,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                     let typ = ty::node_id_to_type(self.tcx, expr.id);\n                     match typ.sty {\n                         ty_bare_fn(ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                            if let ty::FnConverging(to) = bare_fn_ty.sig.output {\n-                                let from = bare_fn_ty.sig.inputs[0];\n+                            if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n+                                let from = bare_fn_ty.sig.0.inputs[0];\n                                 self.check_transmute(expr.span, from, to, expr.id);\n                             }\n                         }"}, {"sha": "4df655882b1551dc71442c1c6ddf6725e3cc9ff9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -1534,6 +1534,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     .unwrap()\n                     .closure_type\n                     .sig\n+                    .0\n                     .output,\n             _ => ty::ty_fn_ret(fn_ty)\n         }"}, {"sha": "67e9d2fee58f48a516e59100381176f536a4d8a6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -257,8 +257,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 };\n                 let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n-                    !is_local(tr.value.def_id) ||\n-                     self.exported_items.contains(&tr.value.def_id.node)\n+                    !is_local(tr.def_id()) ||\n+                     self.exported_items.contains(&tr.def_id().node)\n                 });\n \n                 if public_ty || public_trait {\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {}\", id);\n-                                    self.def_privacy(t.value.def_id)\n+                                    self.def_privacy(t.def_id())\n                                 }\n                                 None => {\n                                     debug!(\"privacy - found a method {}\",\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             match ty::impl_trait_ref(self.tcx, id) {\n                                 Some(t) => {\n                                     debug!(\"privacy - impl of trait {}\", id);\n-                                    self.def_privacy(t.value.def_id)\n+                                    self.def_privacy(t.def_id())\n                                 }\n                                 None => {\n                                     debug!(\"privacy - found a typedef {}\","}, {"sha": "3b759b042f2acd83b671bee6189052b7c3344f60", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -18,6 +18,7 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::ty::{mod, Ty};\n use middle::infer::{mod, InferCtxt};\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use util::ppaux::Repr;\n@@ -42,13 +43,14 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     let impl1_trait_ref =\n         infcx.replace_late_bound_regions_with_fresh_var(DUMMY_SP,\n                                                         infer::FnCall,\n-                                                        &impl1_trait_ref).0;\n+                                                        &*impl1_trait_ref).0;\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n-    let obligation = Obligation::new(ObligationCause::dummy(), impl1_trait_ref);\n+    let obligation = Obligation::new(ObligationCause::dummy(),\n+                                     Rc::new(ty::Binder(impl1_trait_ref)));\n     debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n@@ -65,15 +67,15 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n     debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n \n     // If the trait is local to the crate, ok.\n-    if trait_ref.value.def_id.krate == ast::LOCAL_CRATE {\n+    if trait_ref.def_id().krate == ast::LOCAL_CRATE {\n         debug!(\"trait {} is local to current crate\",\n-               trait_ref.value.def_id.repr(tcx));\n+               trait_ref.def_id().repr(tcx));\n         return true;\n     }\n \n     // Otherwise, at least one of the input types must be local to the\n     // crate.\n-    trait_ref.value.input_types().iter().any(|&t| ty_is_local(tcx, t))\n+    trait_ref.0.input_types().iter().any(|&t| ty_is_local(tcx, t))\n }\n \n pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -143,7 +145,7 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_trait(ref tt) => {\n-            tt.principal.value.def_id.krate == ast::LOCAL_CRATE\n+            tt.principal.def_id().krate == ast::LOCAL_CRATE\n         }\n \n         // Type parameters may be bound to types that are not local to"}, {"sha": "e0a40901ee8517d8bac0aca9db79154f91375232", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -347,13 +347,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // This suffices to allow chains like `FnMut` implemented in\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n-        let input_types = stack.fresh_trait_ref.value.input_types();\n+        let input_types = stack.fresh_trait_ref.0.input_types();\n         let unbound_input_types = input_types.iter().any(|&t| ty::type_is_fresh(t));\n         if\n             unbound_input_types &&\n              (self.intercrate ||\n               stack.iter().skip(1).any(\n-                  |prev| stack.fresh_trait_ref.value.def_id == prev.fresh_trait_ref.value.def_id))\n+                  |prev| stack.fresh_trait_ref.def_id() == prev.fresh_trait_ref.def_id()))\n         {\n             debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.fresh_trait_ref.repr(self.tcx()));\n@@ -591,7 +591,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if\n-            cache_fresh_trait_ref.value.input_types().iter().any(\n+            cache_fresh_trait_ref.0.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -604,7 +604,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // See the discussion in doc.rs for more details.\n         if\n             !self.param_env.caller_bounds.is_empty() &&\n-            cache_fresh_trait_ref.value.input_types().iter().any(\n+            cache_fresh_trait_ref.0.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -648,7 +648,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.value.def_id) {\n+        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id()) {\n             Some(ty::BoundCopy) => {\n                 debug!(\"obligation self ty is {}\",\n                        obligation.self_ty().repr(self.tcx()));\n@@ -731,7 +731,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            candidates: &mut CandidateSet<'tcx>)\n                                            -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.trait_ref.value.def_id) {\n+        let kind = match self.fn_family_trait_kind(obligation.trait_ref.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -779,7 +779,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // We provide a `Fn` impl for fn pointers. There is no need to provide\n         // the other traits (e.g. `FnMut`) since those are provided by blanket\n         // impls.\n-        if Some(obligation.trait_ref.value.def_id) != self.tcx().lang_items.fn_trait() {\n+        if Some(obligation.trait_ref.def_id()) != self.tcx().lang_items.fn_trait() {\n             return Ok(());\n         }\n \n@@ -793,11 +793,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n-                sig: ty::FnSig {\n+                sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n                     output: ty::FnConverging(_),\n                     variadic: false\n-                }\n+                })\n             }) => {\n                 candidates.vec.push(FnPointerCandidate);\n             }\n@@ -814,7 +814,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut CandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let all_impls = self.all_impls(obligation.trait_ref.value.def_id);\n+        let all_impls = self.all_impls(obligation.trait_ref.def_id());\n         for &impl_def_id in all_impls.iter() {\n             self.infcx.probe(|| {\n                 match self.match_impl(impl_def_id, obligation) {\n@@ -1083,7 +1083,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // bounds are required and thus we must fulfill.\n                             let tmp_tr = data.principal_trait_ref_with_self_ty(ty::mk_err());\n                             for tr in util::supertraits(self.tcx(), tmp_tr) {\n-                                let td = ty::lookup_trait_def(self.tcx(), tr.value.def_id);\n+                                let td = ty::lookup_trait_def(self.tcx(), tr.def_id());\n \n                                 if td.bounds.builtin_bounds.contains(&bound) {\n                                     return Ok(If(Vec::new()))\n@@ -1519,15 +1519,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        let arguments_tuple = ty::mk_tup(self.tcx(), sig.inputs.to_vec());\n-        let output_type = sig.output.unwrap();\n+        let arguments_tuple = ty::mk_tup(self.tcx(), sig.0.inputs.to_vec());\n+        let output_type = sig.0.output.unwrap();\n         let substs =\n             Substs::new_trait(\n                 vec![arguments_tuple, output_type],\n                 vec![],\n                 vec![],\n                 self_ty);\n-        let trait_ref = Rc::new(ty::bind(ty::TraitRef {\n+        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n             def_id: obligation.trait_ref.def_id(),\n             substs: substs,\n         }));\n@@ -1562,15 +1562,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let closure_sig = &closure_type.sig;\n-        let arguments_tuple = closure_sig.inputs[0];\n+        let arguments_tuple = closure_sig.0.inputs[0];\n         let substs =\n             Substs::new_trait(\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n-                     closure_sig.output.unwrap().subst(self.tcx(), substs)],\n+                     closure_sig.0.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n                 vec![],\n                 obligation.self_ty());\n-        let trait_ref = Rc::new(ty::bind(ty::TraitRef {\n+        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n             def_id: obligation.trait_ref.def_id(),\n             substs: substs,\n         }));"}, {"sha": "27824ba5c6e77b13b6b0043615692e924927462b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -274,7 +274,7 @@ pub fn poly_trait_ref_for_builtin_bound<'tcx>(\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Ok(Rc::new(ty::bind(ty::TraitRef {\n+            Ok(Rc::new(ty::Binder(ty::TraitRef {\n                 def_id: def_id,\n                 substs: Substs::empty().with_self_ty(param_ty)\n             })))"}, {"sha": "a24992e89e35dc632aa7bc7a9c3fd2887d536a6e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 61, "deletions": 79, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -60,7 +60,7 @@ use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n use middle::traits::ObligationCause;\n use middle::traits;\n use middle::ty;\n-use middle::ty_fold::{mod, TypeFoldable, TypeFolder, HigherRankedFoldable};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n@@ -908,7 +908,7 @@ pub fn type_escapes_depth(ty: Ty, depth: uint) -> bool {\n pub struct BareFnTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub abi: abi::Abi,\n-    pub sig: FnSig<'tcx>,\n+    pub sig: PolyFnSig<'tcx>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -917,7 +917,7 @@ pub struct ClosureTy<'tcx> {\n     pub onceness: ast::Onceness,\n     pub store: TraitStore,\n     pub bounds: ExistentialBounds,\n-    pub sig: FnSig<'tcx>,\n+    pub sig: PolyFnSig<'tcx>,\n     pub abi: abi::Abi,\n }\n \n@@ -944,17 +944,15 @@ impl<'tcx> Copy for FnOutput<'tcx> {}\n /// - `inputs` is the list of arguments and their modes.\n /// - `output` is the return type.\n /// - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n-///\n-/// Note that a `FnSig` introduces a level of region binding, to\n-/// account for late-bound parameters that appear in the types of the\n-/// fn's arguments or the fn's return type.\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n     pub output: FnOutput<'tcx>,\n     pub variadic: bool\n }\n \n+pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n+\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n@@ -1318,9 +1316,9 @@ impl<'tcx> TyTrait<'tcx> {\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n     pub fn principal_trait_ref_with_self_ty(&self, self_ty: Ty<'tcx>) -> Rc<ty::PolyTraitRef<'tcx>> {\n-        Rc::new(ty::bind(ty::TraitRef {\n-            def_id: self.principal.value.def_id,\n-            substs: self.principal.value.substs.with_self_ty(self_ty),\n+        Rc::new(ty::Binder(ty::TraitRef {\n+            def_id: self.principal.def_id(),\n+            substs: self.principal.substs().with_self_ty(self_ty),\n         }))\n     }\n }\n@@ -1350,19 +1348,19 @@ pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.value.self_ty()\n+        self.0.self_ty()\n     }\n \n     pub fn def_id(&self) -> ast::DefId {\n-        self.value.def_id\n+        self.0.def_id\n     }\n \n     pub fn substs(&self) -> &Substs<'tcx> {\n-        &self.value.substs\n+        &self.0.substs\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n-        self.value.input_types()\n+        self.0.input_types()\n     }\n }\n \n@@ -1373,13 +1371,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n /// by the binder supplied to it; but a type is not a binder, so you\n /// must introduce an artificial one).\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct Binder<T> {\n-    pub value: T\n-}\n-\n-pub fn bind<T>(value: T) -> Binder<T> {\n-    Binder { value: value }\n-}\n+pub struct Binder<T>(pub T);\n \n #[deriving(Clone, PartialEq)]\n pub enum IntVarValue {\n@@ -2237,12 +2229,12 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_fn_sig(&mut self, fn_sig: &FnSig) {\n+    fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(fn_sig.inputs[]);\n+        computation.add_tys(fn_sig.0.inputs[]);\n \n-        if let ty::FnConverging(output) = fn_sig.output {\n+        if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n         }\n \n@@ -2385,11 +2377,11 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n                BareFnTy {\n                    unsafety: ast::Unsafety::Normal,\n                    abi: abi::Rust,\n-                   sig: FnSig {\n+                   sig: ty::Binder(FnSig {\n                     inputs: input_args,\n                     output: ty::FnConverging(output),\n                     variadic: false\n-                   }\n+                   })\n                 })\n }\n \n@@ -2481,14 +2473,14 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n         }\n         ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n         ty_bare_fn(ref ft) => {\n-            for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.output {\n+            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+            if let ty::FnConverging(output) = ft.sig.0.output {\n                 maybe_walk_ty(output, f);\n             }\n         }\n         ty_closure(ref ft) => {\n-            for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.output {\n+            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+            if let ty::FnConverging(output) = ft.sig.0.output {\n                 maybe_walk_ty(output, f);\n             }\n         }\n@@ -3857,15 +3849,15 @@ pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts\n \n pub fn fn_is_variadic(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.variadic,\n-        ty_closure(ref f) => f.sig.variadic,\n+        ty_bare_fn(ref f) => f.sig.0.variadic,\n+        ty_closure(ref f) => f.sig.0.variadic,\n         ref s => {\n             panic!(\"fn_is_variadic() called on non-fn type: {}\", s)\n         }\n     }\n }\n \n-pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx FnSig<'tcx> {\n+pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n     match fty.sty {\n         ty_bare_fn(ref f) => &f.sig,\n         ty_closure(ref f) => &f.sig,\n@@ -3886,7 +3878,7 @@ pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n \n // Type accessors for substructures of types\n pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> &'tcx [Ty<'tcx>] {\n-    ty_fn_sig(fty).inputs.as_slice()\n+    ty_fn_sig(fty).0.inputs.as_slice()\n }\n \n pub fn ty_closure_store(fty: Ty) -> TraitStore {\n@@ -3905,8 +3897,8 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n \n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.output,\n-        ty_closure(ref f) => f.sig.output,\n+        ty_bare_fn(ref f) => f.sig.0.output,\n+        ty_closure(ref f) => f.sig.0.output,\n         ref s => {\n             panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n         }\n@@ -4801,7 +4793,7 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                 &Some(ref t) => {\n                                     let trait_ref =\n                                         (*ty::node_id_to_trait_ref(cx, t.ref_id)).clone();\n-                                    Some(Rc::new(ty::bind(trait_ref)))\n+                                    Some(Rc::new(ty::Binder(trait_ref)))\n                                 }\n                                 &None => None\n                             }\n@@ -5180,7 +5172,7 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n         trait_def.bounds.trait_bounds\n         .iter()\n         .map(|bound_trait_ref| {\n-            ty::bind(\n+            ty::Binder(\n                 ty::TraitRef::new(bound_trait_ref.def_id(),\n                                   bound_trait_ref.substs().subst(tcx, trait_ref.substs())))\n         })\n@@ -5515,18 +5507,6 @@ pub fn normalize_ty<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n             subst::Substs { regions: subst::ErasedRegions,\n                             types: substs.types.fold_with(self) }\n         }\n-\n-        fn fold_fn_sig(&mut self,\n-                       sig: &ty::FnSig<'tcx>)\n-                       -> ty::FnSig<'tcx> {\n-            // The binder-id is only relevant to bound regions, which\n-            // are erased at trans time.\n-            ty::FnSig {\n-                inputs: sig.inputs.fold_with(self),\n-                output: sig.output.fold_with(self),\n-                variadic: sig.variadic,\n-            }\n-        }\n     }\n }\n \n@@ -5602,7 +5582,7 @@ pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n \n     let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n         let substs = principal.substs().with_self_ty(open_ty);\n-        vec!(Rc::new(ty::bind(ty::TraitRef::new(principal.def_id(), substs))))\n+        vec!(Rc::new(ty::Binder(ty::TraitRef::new(principal.def_id(), substs))))\n     });\n \n     let param_bounds = ty::ParamBounds {\n@@ -5856,12 +5836,12 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n \n /// Creates a hash of the type `Ty` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n+pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n     helper(tcx, ty, svh, &mut state);\n     return state.result();\n \n-    fn helper(tcx: &ctxt, ty: Ty, svh: &Svh, state: &mut sip::SipState) {\n+    fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh, state: &mut sip::SipState) {\n         macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n         macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n \n@@ -5894,7 +5874,7 @@ pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n         let mt = |state: &mut sip::SipState, mt: mt| {\n             mt.mutbl.hash(state);\n         };\n-        let fn_sig = |state: &mut sip::SipState, sig: &FnSig| {\n+        let fn_sig = |state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n             let sig = anonymize_late_bound_regions(tcx, sig);\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n@@ -5974,7 +5954,7 @@ pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n                     hash!(bounds);\n \n                     let principal = anonymize_late_bound_regions(tcx, principal);\n-                    for subty in principal.substs().types.iter() {\n+                    for subty in principal.substs.types.iter() {\n                         helper(tcx, *subty, svh, state);\n                     }\n \n@@ -6065,7 +6045,7 @@ pub fn construct_parameter_environment<'tcx>(\n     //\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n-    let bounds = liberate_late_bound_regions(tcx, free_id_scope, &bind(bounds)).value;\n+    let bounds = liberate_late_bound_regions(tcx, free_id_scope, &ty::Binder(bounds));\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n@@ -6321,12 +6301,12 @@ impl<'tcx> AutoDerefRef<'tcx> {\n \n /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n /// `scope_id`.\n-pub fn liberate_late_bound_regions<'tcx, HR>(\n+pub fn liberate_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     scope: region::CodeExtent,\n-    value: &HR)\n-    -> HR\n-    where HR : HigherRankedFoldable<'tcx>\n+    value: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     replace_late_bound_regions(\n         tcx, value,\n@@ -6335,11 +6315,11 @@ pub fn liberate_late_bound_regions<'tcx, HR>(\n \n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n-pub fn erase_late_bound_regions<'tcx, HR>(\n+pub fn erase_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n-    value: &HR)\n-    -> HR\n-    where HR : HigherRankedFoldable<'tcx>\n+    value: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n }\n@@ -6352,8 +6332,12 @@ pub fn erase_late_bound_regions<'tcx, HR>(\n /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n /// structurally identical.  For example, `for<'a, 'b> fn(&'a int, &'b int)` and\n /// `for<'a, 'b> fn(&'b int, &'a int)` will become identical after anonymization.\n-pub fn anonymize_late_bound_regions<'tcx, HR>(tcx: &ctxt<'tcx>, sig: &HR) -> HR\n-                                              where HR: HigherRankedFoldable<'tcx> {\n+pub fn anonymize_late_bound_regions<'tcx, T>(\n+    tcx: &ctxt<'tcx>,\n+    sig: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>,\n+{\n     let mut counter = 0;\n     replace_late_bound_regions(tcx, sig, |_, db| {\n         counter += 1;\n@@ -6362,15 +6346,15 @@ pub fn anonymize_late_bound_regions<'tcx, HR>(tcx: &ctxt<'tcx>, sig: &HR) -> HR\n }\n \n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n-pub fn replace_late_bound_regions<'tcx, HR, F>(\n+pub fn replace_late_bound_regions<'tcx, T, F>(\n     tcx: &ty::ctxt<'tcx>,\n-    value: &HR,\n+    binder: &Binder<T>,\n     mut mapf: F)\n--> (HR, FnvHashMap<ty::BoundRegion, ty::Region>) where\n-    HR : HigherRankedFoldable<'tcx>,\n-    F: FnMut(BoundRegion, DebruijnIndex) -> ty::Region,\n+    -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>,\n+          F : FnMut(BoundRegion, DebruijnIndex) -> ty::Region,\n {\n-    debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n+    debug!(\"replace_late_bound_regions({})\", binder.repr(tcx));\n \n     let mut map = FnvHashMap::new();\n     let value = {\n@@ -6389,11 +6373,9 @@ pub fn replace_late_bound_regions<'tcx, HR, F>(\n             }\n         });\n \n-        // Note: use `fold_contents` not `fold_with`. If we used\n-        // `fold_with`, it would consider the late-bound regions bound\n-        // by `value` to be bound, but we want to consider them as\n-        // `free`.\n-        value.fold_contents(&mut f)\n+        // Note: fold the field `0`, not the binder, so that late-bound\n+        // regions bound by `binder` are considered free.\n+        binder.0.fold_with(&mut f)\n     };\n     debug!(\"resulting map: {} value: {}\", map, value.repr(tcx));\n     (value, map)\n@@ -6600,13 +6582,13 @@ impl<'tcx> RegionEscape for TraitRef<'tcx> {\n \n impl<'tcx,T:RegionEscape> RegionEscape for Binder<T> {\n     fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n-        self.value.has_regions_escaping_depth(depth + 1)\n+        self.0.has_regions_escaping_depth(depth + 1)\n     }\n }\n \n impl<T:RegionEscape> Binder<T> {\n     pub fn has_bound_regions(&self) -> bool {\n-        self.value.has_regions_escaping_depth(0)\n+        self.0.has_regions_escaping_depth(0)\n     }\n }\n "}, {"sha": "6d6dc1d426ad6b40a4f3a11d0e02c18c0dee6ded", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -93,8 +93,8 @@ pub trait TypeFolder<'tcx> {\n     }\n \n     fn fold_fn_sig(&mut self,\n-                sig: &ty::FnSig<'tcx>)\n-                -> ty::FnSig<'tcx> {\n+                   sig: &ty::FnSig<'tcx>)\n+                   -> ty::FnSig<'tcx> {\n         super_fold_fn_sig(self, sig)\n     }\n \n@@ -183,7 +183,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.enter_region_binder();\n-        let result = ty::bind(self.value.fold_with(folder));\n+        let result = ty::Binder(self.0.fold_with(folder));\n         folder.exit_region_binder();\n         result\n     }\n@@ -532,16 +532,6 @@ pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                     sig: &ty::FnSig<'tcx>)\n                                                     -> ty::FnSig<'tcx>\n-{\n-    this.enter_region_binder();\n-    let result = super_fold_fn_sig_contents(this, sig);\n-    this.exit_region_binder();\n-    result\n-}\n-\n-pub fn super_fold_fn_sig_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                             sig: &ty::FnSig<'tcx>)\n-                                                             -> ty::FnSig<'tcx>\n {\n     ty::FnSig { inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n@@ -696,34 +686,6 @@ pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Higher-ranked things\n-\n-/// Designates a \"binder\" for late-bound regions.\n-pub trait HigherRankedFoldable<'tcx>: Repr<'tcx> {\n-    /// Folds the contents of `self`, ignoring the region binder created\n-    /// by `self`.\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n-}\n-\n-impl<'tcx> HigherRankedFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n-        super_fold_fn_sig_contents(folder, self)\n-    }\n-}\n-\n-impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>> HigherRankedFoldable<'tcx> for ty::Binder<T> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n-        ty::bind(self.value.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T:HigherRankedFoldable<'tcx>> HigherRankedFoldable<'tcx> for Rc<T> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n-        Rc::new((**self).fold_contents(folder))\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n@@ -754,10 +716,6 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n /// regions (aka \"lifetimes\") that are bound within a type are not\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n-///\n-/// (The distinction between \"free\" and \"bound\" is represented by\n-/// keeping track of each `FnSig` in the lexical context of the\n-/// current position of the fold.)\n pub struct RegionFolder<'a, 'tcx: 'a, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n     tcx: &'a ty::ctxt<'tcx>,\n     current_depth: uint,"}, {"sha": "134006bef0b75f088399230813365741e6038750", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -23,7 +23,10 @@ use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n+use middle::ty_fold::TypeFoldable;\n \n+use std::collections::HashMap;\n+use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -40,7 +43,7 @@ pub trait Repr<'tcx> for Sized? {\n }\n \n /// Produces a string suitable for showing to the user.\n-pub trait UserString<'tcx> {\n+pub trait UserString<'tcx> : Repr<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n@@ -248,21 +251,12 @@ pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn fn_sig_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::FnSig<'tcx>) -> String {\n-    format!(\"fn{} -> {}\", typ.inputs.repr(cx), typ.output.repr(cx))\n-}\n-\n-pub fn trait_ref_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                                 trait_ref: &ty::TraitRef<'tcx>) -> String {\n-    trait_ref.user_string(cx).to_string()\n-}\n-\n pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n                                unsafety: ast::Unsafety,\n                                abi: abi::Abi,\n                                ident: Option<ast::Ident>,\n-                               sig: &ty::FnSig<'tcx>)\n+                               sig: &ty::PolyFnSig<'tcx>)\n                                -> String {\n         let mut s = String::new();\n         match unsafety {\n@@ -336,15 +330,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                                 s: &mut String,\n                                 bra: char,\n                                 ket: char,\n-                                sig: &ty::FnSig<'tcx>,\n+                                sig: &ty::PolyFnSig<'tcx>,\n                                 bounds: &str) {\n         s.push(bra);\n-        let strs = sig.inputs\n+        let strs = sig.0.inputs\n             .iter()\n             .map(|a| ty_to_string(cx, *a))\n             .collect::<Vec<_>>();\n         s.push_str(strs.connect(\", \").as_slice());\n-        if sig.variadic {\n+        if sig.0.variadic {\n             s.push_str(\", ...\");\n         }\n         s.push(ket);\n@@ -354,7 +348,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             s.push_str(bounds);\n         }\n \n-        match sig.output {\n+        match sig.0.output {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n@@ -1013,7 +1007,7 @@ impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        fn_sig_to_string(tcx, self)\n+        format!(\"fn{} -> {}\", self.inputs.repr(tcx), self.output.repr(tcx))\n     }\n }\n \n@@ -1156,15 +1150,17 @@ impl<'tcx> UserString<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::PolyTraitRef<'tcx> {\n+impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n+    where T : UserString<'tcx> + TypeFoldable<'tcx>\n+{\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         // Replace any anonymous late-bound regions with named\n         // variants, using gensym'd identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n         let mut names = Vec::new();\n-        let (trait_ref, _) = ty::replace_late_bound_regions(tcx, self, |br, debruijn| {\n+        let (unbound_value, _) = ty::replace_late_bound_regions(tcx, self, |br, debruijn| {\n             ty::ReLateBound(debruijn, match br {\n                 ty::BrNamed(_, name) => {\n                     names.push(token::get_name(name));\n@@ -1181,11 +1177,11 @@ impl<'tcx> UserString<'tcx> for ty::PolyTraitRef<'tcx> {\n         });\n         let names: Vec<_> = names.iter().map(|s| s.get()).collect();\n \n-        let trait_ref_str = trait_ref.value.user_string(tcx);\n+        let value_str = unbound_value.user_string(tcx);\n         if names.len() == 0 {\n-            trait_ref_str\n+            value_str\n         } else {\n-            format!(\"for<{}> {}\", names.connect(\",\"), trait_ref_str)\n+            format!(\"for<{}> {}\", names.connect(\",\"), value_str)\n         }\n     }\n }\n@@ -1337,6 +1333,20 @@ impl<'tcx, A:Repr<'tcx>, B:Repr<'tcx>> Repr<'tcx> for (A,B) {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Binder({})\", self.value.repr(tcx))\n+        format!(\"Binder({})\", self.0.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx, S, H, K, V> Repr<'tcx> for HashMap<K,V,H>\n+    where K : Hash<S> + Eq + Repr<'tcx>,\n+          V : Repr<'tcx>,\n+          H : Hasher<S>\n+{\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"HashMap({})\",\n+                self.iter()\n+                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n+                    .collect::<Vec<String>>()\n+                    .connect(\", \"))\n     }\n }"}, {"sha": "b2c661cc58aa40ef035d6b9412bb892858e1ce60", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -275,11 +275,11 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             onceness: ast::Many,\n             store: ty::RegionTraitStore(region_bound, ast::MutMutable),\n             bounds: ty::region_existential_bound(region_bound),\n-            sig: ty::FnSig {\n+            sig: ty::Binder(ty::FnSig {\n                 inputs: input_tys.to_vec(),\n                 output: ty::FnConverging(output_ty),\n                 variadic: false,\n-            },\n+            }),\n             abi: abi::Rust,\n         })\n     }"}, {"sha": "b947b1746fcab26b35dfd012cac62ac8ca3595d9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -282,19 +282,19 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let (inputs, output, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(ref f) => {\n-            (f.sig.inputs.clone(), f.sig.output, f.abi, None)\n+            (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n         }\n         ty::ty_closure(ref f) => {\n-            (f.sig.inputs.clone(), f.sig.output, f.abi, Some(Type::i8p(ccx)))\n+            (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, Some(Type::i8p(ccx)))\n         }\n         ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let unboxed_closure = &(*unboxed_closures)[closure_did];\n             let function_type = unboxed_closure.closure_type.clone();\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n-            (function_type.sig.inputs.iter().map(|t| t.subst(ccx.tcx(), substs)).collect(),\n-             function_type.sig.output.subst(ccx.tcx(), substs),\n+            (function_type.sig.0.inputs.iter().map(|t| t.subst(ccx.tcx(), substs)).collect(),\n+             function_type.sig.0.output.subst(ccx.tcx(), substs),\n              RustCall,\n              Some(llenvironment_type))\n         }\n@@ -1998,7 +1998,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.output.unwrap(),\n+        ty::ty_bare_fn(ref bft) => bft.sig.0.output.unwrap(),\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n@@ -2070,7 +2070,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.output,\n+        ty::ty_bare_fn(ref bft) => bft.sig.0.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n@@ -2439,31 +2439,31 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     // at either 1 or 2 depending on whether there's an env slot or not\n     let mut first_arg_offset = if has_env { 2 } else { 1 };\n     let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.output;\n+    let ret_ty = fn_sig.0.output;\n \n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n         ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n-            match fn_sig.inputs[0].sty {\n+            match fn_sig.0.inputs[0].sty {\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n         ty::ty_bare_fn(_) if abi == RustCall => {\n-            let mut inputs = vec![fn_sig.inputs[0]];\n+            let mut inputs = vec![fn_sig.0.inputs[0]];\n \n-            match fn_sig.inputs[1].sty {\n+            match fn_sig.0.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in.as_slice());\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n-        _ => fn_sig.inputs.clone()\n+        _ => fn_sig.0.inputs.clone()\n     };\n \n     if let ty::FnConverging(ret_ty) = ret_ty {"}, {"sha": "192b0d6342100e08c79950675a08db8847ecc3d6", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -280,9 +280,9 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         match bare_fn_ty.sty {\n             ty::ty_bare_fn(ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                           abi: synabi::Rust,\n-                                          sig: ty::FnSig { inputs: ref input_tys,\n-                                                           output: output_ty,\n-                                                           variadic: false }}) =>\n+                                          sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n+                                                                      output: output_ty,\n+                                                                      variadic: false })}) =>\n             {\n                 (input_tys, output_ty)\n             }\n@@ -296,12 +296,12 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n                                      ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                                     abi: synabi::RustCall,\n-                                                    sig: ty::FnSig {\n+                                                    sig: ty::Binder(ty::FnSig {\n                                                         inputs: vec![bare_fn_ty_ref,\n                                                                      tuple_input_ty],\n                                                         output: output_ty,\n                                                         variadic: false\n-                                                    }});\n+                                                    })});\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n \n     //\n@@ -421,12 +421,12 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n             let impl_or_trait_item = ty::impl_or_trait_item(tcx, source_id);\n             match impl_or_trait_item {\n                 ty::MethodTraitItem(method) => {\n-                    let trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n-                    let trait_ref = ty::erase_late_bound_regions(tcx, &trait_ref);\n+                    let poly_trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n+                    let trait_ref = ty::erase_late_bound_regions(tcx, &*poly_trait_ref);\n \n                     // Compute the first substitution\n                     let first_subst =\n-                        ty::make_substs_for_receiver_types(tcx, &trait_ref.value, &*method)\n+                        ty::make_substs_for_receiver_types(tcx, &trait_ref, &*method)\n                         .erase_regions();\n \n                     // And compose them\n@@ -435,7 +435,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n                     debug!(\"trans_fn_with_vtables - default method: \\\n                             substs = {}, trait_subst = {}, \\\n                             first_subst = {}, new_subst = {}\",\n-                           substs.repr(tcx), trait_ref.substs().repr(tcx),\n+                           substs.repr(tcx), trait_ref.substs.repr(tcx),\n                            first_subst.repr(tcx), new_substs.repr(tcx));\n \n                     (true, source_id, new_substs)\n@@ -657,8 +657,8 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n-        ty::ty_closure(ref f) => (f.abi, f.sig.output),\n+        ty::ty_bare_fn(ref f) => (f.abi, f.sig.0.output),\n+        ty::ty_closure(ref f) => (f.abi, f.sig.0.output),\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n "}, {"sha": "af3daf224e3265afb21e5dc3d440d80189dce8bc", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -658,9 +658,9 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, true, f.sig.output,\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, true, f.sig.0.output,\n                           &empty_param_substs, None, &arena);\n-    let bcx = init_function(&fcx, true, f.sig.output);\n+    let bcx = init_function(&fcx, true, f.sig.0.output);\n \n     let args = create_datums_for_fn_args(&fcx,\n                                          ty::ty_fn_args(closure_ty)\n@@ -676,7 +676,7 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llargs.extend(args.iter().map(|arg| arg.val));\n \n     let retval = Call(bcx, fn_ptr, llargs.as_slice(), None);\n-    match f.sig.output {\n+    match f.sig.0.output {\n         ty::FnConverging(output_type) => {\n             if return_type_is_void(ccx, output_type) || fcx.llretslotptr.get().is_some() {\n                 RetVoid(bcx);"}, {"sha": "96c39b5796ec4ccb7a0f5b010d85350d1195d13d", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -442,7 +442,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 unique_type_id.push_str(\" fn(\");\n \n-                for &parameter_type in sig.inputs.iter() {\n+                for &parameter_type in sig.0.inputs.iter() {\n                     let parameter_type_id =\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n@@ -451,12 +451,12 @@ impl<'tcx> TypeMap<'tcx> {\n                     unique_type_id.push(',');\n                 }\n \n-                if sig.variadic {\n+                if sig.0.variadic {\n                     unique_type_id.push_str(\"...\");\n                 }\n \n                 unique_type_id.push_str(\")->\");\n-                match sig.output {\n+                match sig.0.output {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -575,7 +575,7 @@ impl<'tcx> TypeMap<'tcx> {\n             }\n         };\n \n-        for &parameter_type in sig.inputs.iter() {\n+        for &parameter_type in sig.0.inputs.iter() {\n             let parameter_type_id =\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n@@ -584,13 +584,13 @@ impl<'tcx> TypeMap<'tcx> {\n             unique_type_id.push(',');\n         }\n \n-        if sig.variadic {\n+        if sig.0.variadic {\n             unique_type_id.push_str(\"...\");\n         }\n \n         unique_type_id.push_str(\"|->\");\n \n-        match sig.output {\n+        match sig.0.output {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -2787,13 +2787,13 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       unique_type_id: UniqueTypeId,\n-                                      signature: &ty::FnSig<'tcx>,\n+                                      signature: &ty::PolyFnSig<'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult {\n-    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n+    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.0.inputs.len() + 1);\n \n     // return type\n-    signature_metadata.push(match signature.output {\n+    signature_metadata.push(match signature.0.output {\n         ty::FnConverging(ret_ty) => match ret_ty.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n@@ -2802,7 +2802,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     });\n \n     // regular arguments\n-    for &argument_type in signature.inputs.iter() {\n+    for &argument_type in signature.0.inputs.iter() {\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n@@ -3781,17 +3781,17 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            if sig.inputs.len() > 0 {\n-                for &parameter_type in sig.inputs.iter() {\n+            if sig.0.inputs.len() > 0 {\n+                for &parameter_type in sig.0.inputs.iter() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n                 output.pop();\n             }\n \n-            if sig.variadic {\n-                if sig.inputs.len() > 0 {\n+            if sig.0.variadic {\n+                if sig.0.inputs.len() > 0 {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");\n@@ -3800,7 +3800,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(')');\n \n-            match sig.output {\n+            match sig.0.output {\n                 ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");\n@@ -3841,17 +3841,17 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             };\n \n-            if sig.inputs.len() > 0 {\n-                for &parameter_type in sig.inputs.iter() {\n+            if sig.0.inputs.len() > 0 {\n+                for &parameter_type in sig.0.inputs.iter() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n                 output.pop();\n             }\n \n-            if sig.variadic {\n-                if sig.inputs.len() > 0 {\n+            if sig.0.variadic {\n+                if sig.0.inputs.len() > 0 {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");\n@@ -3860,7 +3860,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(param_list_closing_char);\n \n-            match sig.output {\n+            match sig.0.output {\n                 ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");"}, {"sha": "db44e0ce27197c9a99be286d0625e2f8e381947f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -318,8 +318,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n                 let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n                 let trait_ref =\n-                    Rc::new(ty::bind(ty::TraitRef { def_id: principal.def_id(),\n-                                                    substs: substs }));\n+                    Rc::new(ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs }));\n                 let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n                 let box_ty = mk_ty(unadjusted_ty);\n                 PointerCast(bcx,"}, {"sha": "d07203199305097d3cf85d48fc7afe301543bb5d", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -22,7 +22,6 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n-use middle::ty::FnSig;\n use middle::ty::{mod, Ty};\n use middle::subst::{Subst, Substs};\n use std::cmp;\n@@ -41,7 +40,7 @@ use util::ppaux::Repr;\n \n struct ForeignTypes<'tcx> {\n     /// Rust signature of the function\n-    fn_sig: ty::FnSig<'tcx>,\n+    fn_sig: ty::PolyFnSig<'tcx>,\n \n     /// Adapter object for handling native ABI rules (trust me, you\n     /// don't want to know)\n@@ -179,7 +178,7 @@ pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Make sure the calling convention is right for variadic functions\n     // (should've been caught if not in typeck)\n-    if tys.fn_sig.variadic {\n+    if tys.fn_sig.0.variadic {\n         assert!(cc == llvm::CCallConv);\n     }\n \n@@ -386,7 +385,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n-            match fn_sig.output {\n+            match fn_sig.0.output {\n                 ty::FnConverging(result_ty) => {\n                     base::store_ty(bcx, llforeign_retval, llretptr, result_ty)\n                 }\n@@ -632,7 +631,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         };\n \n         // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr = match tys.fn_sig.output {\n+        let rust_uses_outptr = match tys.fn_sig.0.output {\n             ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n             ty::FnDiverging => false\n         };\n@@ -665,7 +664,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             return_ty={}\",\n                            ccx.tn().val_to_string(slot),\n                            ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.output.repr(tcx));\n+                           tys.fn_sig.0.output.repr(tcx));\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -680,8 +679,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n-        for i in range(0, tys.fn_sig.inputs.len()) {\n-            let rust_ty = tys.fn_sig.inputs[i];\n+        for i in range(0, tys.fn_sig.0.inputs.len()) {\n+            let rust_ty = tys.fn_sig.0.inputs[i];\n             let llrust_ty = tys.llsig.llarg_tys[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n             let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n@@ -826,10 +825,10 @@ pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n /// because foreign functions just plain ignore modes. They also don't pass aggregate values by\n /// pointer like we do.\n fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               fn_sig: &ty::FnSig<'tcx>, arg_tys: &[Ty<'tcx>])\n+                               fn_sig: &ty::PolyFnSig<'tcx>, arg_tys: &[Ty<'tcx>])\n                                -> LlvmSignature {\n     let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n-    let (llret_ty, ret_def) = match fn_sig.output {\n+    let (llret_ty, ret_def) = match fn_sig.0.output {\n         ty::FnConverging(ret_ty) =>\n             (type_of::arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n         ty::FnDiverging =>\n@@ -853,7 +852,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n+    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        llsig.llarg_tys.as_slice(),\n                                        llsig.llret_ty,\n@@ -913,7 +912,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n         llargument_tys.push(llarg_ty);\n     }\n \n-    if tys.fn_sig.variadic {\n+    if tys.fn_sig.0.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n         Type::func(llargument_tys.as_slice(), &llreturn_ty)"}, {"sha": "dea095ecaf594c558a39ad752f86d928e8265a69", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -227,8 +227,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n     let self_ty = match fty.sty {\n         ty::ty_bare_fn(ref f) => {\n-            assert!(f.sig.inputs.len() == 1);\n-            f.sig.inputs[0]\n+            assert!(f.sig.0.inputs.len() == 1);\n+            f.sig.0.inputs[0]\n         }\n         _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n                                     bcx.ty_to_string(fty)).as_slice())"}, {"sha": "a6f7c849f4d95ab8e390a7d00573bfda08225a1e", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -150,7 +150,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n \n     let ret_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => f.sig.output,\n+        ty::ty_bare_fn(ref f) => f.sig.0.output,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);"}, {"sha": "a8f7323b4ae03c64927a5251c272aaeaa27167bd", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -239,8 +239,8 @@ pub fn trans_static_method_callee(bcx: Block,\n                                              rcvr_assoc,\n                                              Vec::new()));\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n-    let trait_ref = Rc::new(ty::bind(ty::TraitRef { def_id: trait_id,\n-                                                    substs: trait_substs }));\n+    let trait_ref = Rc::new(ty::Binder(ty::TraitRef { def_id: trait_id,\n+                                                      substs: trait_substs }));\n     let vtbl = fulfill_obligation(bcx.ccx(),\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -480,8 +480,8 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::ty_bare_fn(ref f) if f.abi == Rust || f.abi == RustCall => {\n             type_of_rust_fn(ccx,\n                             Some(Type::i8p(ccx)),\n-                            f.sig.inputs.slice_from(1),\n-                            f.sig.output,\n+                            f.sig.0.inputs.slice_from(1),\n+                            f.sig.0.output,\n                             f.abi)\n         }\n         _ => {"}, {"sha": "aa6fd7f0b39417d1ec74bf32554b4d7f88579a40", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -146,16 +146,16 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n         ty::ty_closure(ref f) => {\n             type_of_rust_fn(cx,\n                             Some(Type::i8p(cx)),\n-                            f.sig.inputs.as_slice(),\n-                            f.sig.output,\n+                            f.sig.0.inputs.as_slice(),\n+                            f.sig.0.output,\n                             f.abi)\n         }\n         ty::ty_bare_fn(ref f) => {\n             if f.abi == abi::Rust || f.abi == abi::RustCall {\n                 type_of_rust_fn(cx,\n                                 None,\n-                                f.sig.inputs.as_slice(),\n-                                f.sig.output,\n+                                f.sig.0.inputs.as_slice(),\n+                                f.sig.0.output,\n                                 f.abi)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)"}, {"sha": "d6438c4062e3219b273ffe8328dae0b39501cd44", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -535,7 +535,7 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n {\n     let trait_ref = instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, allow_eq);\n     let trait_ref = (*trait_ref).clone();\n-    Rc::new(ty::bind(trait_ref)) // Ugh.\n+    Rc::new(ty::Binder(trait_ref)) // Ugh.\n }\n \n /// Instantiates the path for the given trait reference, assuming that it's\n@@ -778,12 +778,12 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n         ast::TyPath(ref path, id) => {\n             match this.tcx().def_map.borrow().get(&id) {\n                 Some(&def::DefTrait(trait_def_id)) => {\n-                    return Ok(ty::bind(ast_path_to_trait_ref(this,\n-                                                             rscope,\n-                                                             trait_def_id,\n-                                                             None,\n-                                                             path,\n-                                                             AllowEqConstraints::Allow)));\n+                    return Ok(ty::Binder(ast_path_to_trait_ref(this,\n+                                                               rscope,\n+                                                               trait_def_id,\n+                                                               None,\n+                                                               path,\n+                                                               AllowEqConstraints::Allow)));\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -993,12 +993,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefTrait(trait_def_id) => {\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n-                        let result = ty::bind(ast_path_to_trait_ref(this,\n-                                                                    rscope,\n-                                                                    trait_def_id,\n-                                                                    None,\n-                                                                    path,\n-                                                                    AllowEqConstraints::Allow));\n+                        let result = ty::Binder(ast_path_to_trait_ref(this,\n+                                                                      rscope,\n+                                                                      trait_def_id,\n+                                                                      None,\n+                                                                      path,\n+                                                                      AllowEqConstraints::Allow));\n                         trait_ref_to_object_type(this, rscope, path.span, result, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n@@ -1050,7 +1050,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                 let ty_param_defs = tcx.ty_param_defs.borrow();\n                                 let tp_def = &(*ty_param_defs)[did.node];\n                                 let assoc_tys = tp_def.bounds.trait_bounds.iter()\n-                                    .filter_map(|b| find_assoc_ty(this, &b.value, assoc_ident))\n+                                    .filter_map(|b| find_assoc_ty(this, &b.0, assoc_ident))\n                                     .collect();\n                                 (assoc_tys, token::get_name(tp_def.name).to_string())\n                             }\n@@ -1278,11 +1278,11 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     (ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n-        sig: ty::FnSig {\n+        sig: ty::Binder(ty::FnSig {\n             inputs: self_and_input_tys,\n             output: output_ty,\n             variadic: decl.variadic\n-        }\n+        }),\n     }, explicit_self_category_result)\n }\n \n@@ -1420,9 +1420,9 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n         store: store,\n         bounds: bounds,\n         abi: abi,\n-        sig: ty::FnSig {inputs: input_tys,\n-                        output: output_ty,\n-                        variadic: decl.variadic}\n+        sig: ty::Binder(ty::FnSig {inputs: input_tys,\n+                                   output: output_ty,\n+                                   variadic: decl.variadic}),\n     }\n }\n "}, {"sha": "2ade3040d6cff52e4b8382ce47c447b09bca0da8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -129,7 +129,7 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     // Tuple up the arguments and insert the resulting function type into\n     // the `unboxed_closures` table.\n-    fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n+    fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n     debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n            expr_def_id.repr(fcx.tcx()),"}, {"sha": "8ac58736f54b496a94f07a397b4e43158d2fa6a0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -16,9 +16,9 @@ use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n                  MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n+use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n-use middle::ty_fold::HigherRankedFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n@@ -114,7 +114,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), ty::BareFnTy {\n-            sig: method_sig,\n+            sig: ty::Binder(method_sig),\n             unsafety: pick.method_ty.fty.unsafety,\n             abi: pick.method_ty.fty.abi.clone(),\n         });\n@@ -272,7 +272,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  &trait_def.generics,\n                                                                  self.infcx().next_ty_var());\n \n-                let trait_ref = Rc::new(ty::bind(ty::TraitRef::new(trait_def_id, substs.clone())));\n+                let trait_ref =\n+                    Rc::new(ty::Binder(ty::TraitRef::new(trait_def_id, substs.clone())));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num });\n                 (substs, origin)\n@@ -388,9 +389,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // The binder level here corresponds to the impl.\n         let (all_substs, (method_sig, method_generics)) =\n             self.replace_late_bound_regions_with_fresh_var(\n-                &ty::bind((all_substs,\n-                           (pick.method_ty.fty.sig.clone(),\n-                            pick.method_ty.generics.clone())))).value;\n+                &ty::Binder((all_substs,\n+                             (pick.method_ty.fty.sig.clone(),\n+                              pick.method_ty.generics.clone()))));\n \n         debug!(\"late-bound lifetimes from impl instantiated, \\\n                 all_substs={} method_sig={} method_generics={}\",\n@@ -481,7 +482,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             _ => return,\n         };\n \n-        match sig.inputs[0].sty {\n+        match sig.0.inputs[0].sty {\n             ty::ty_rptr(_, ty::mt {\n                 ty: _,\n                 mutbl: ast::MutMutable,\n@@ -654,8 +655,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     target_trait_def_id.repr(self.tcx()))[]);\n     }\n \n-    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable<'tcx>\n+    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n         self.infcx().replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0"}, {"sha": "451058e5e21a0b1d73ac363ccbad93041cde3600", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -166,7 +166,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Construct a trait-reference `self_ty : Trait<input_tys>`\n     let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n-    let trait_ref = Rc::new(ty::bind(ty::TraitRef::new(trait_def_id, substs)));\n+    let trait_ref = Rc::new(ty::Binder(ty::TraitRef::new(trait_def_id, substs)));\n \n     // Construct an obligation\n     let obligation = traits::Obligation::misc(span,\n@@ -204,7 +204,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                                                        &fn_sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-        sig: fn_sig,\n+        sig: ty::Binder(fn_sig),\n         unsafety: bare_fn_ty.unsafety,\n         abi: bare_fn_ty.abi.clone(),\n     });"}, {"sha": "fc1aa59c4deb3c4851cec7ce73f840fb1cf5e2b6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -20,7 +20,7 @@ use middle::subst::Subst;\n use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::{MethodObject};\n-use middle::ty_fold::HigherRankedFoldable;\n+use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n use syntax::ast;\n@@ -308,8 +308,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             let vtable_index =\n                 get_method_index(tcx, &*new_trait_ref, trait_ref.clone(), method_num);\n \n-            let xform_self_ty =\n-                this.xform_self_ty(&m, new_trait_ref.substs());\n+            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -772,7 +771,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     // Erase any late-bound regions bound in the impl\n                     // which appear in the bounds.\n-                    let impl_bounds = self.erase_late_bound_regions(&ty::bind(impl_bounds)).value;\n+                    let impl_bounds = self.erase_late_bound_regions(&ty::Binder(impl_bounds));\n \n                     // Convert the bounds into obligations.\n                     let obligations =\n@@ -874,9 +873,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn xform_self_ty(&self,\n                      method: &Rc<ty::Method<'tcx>>,\n                      substs: &subst::Substs<'tcx>)\n-                     -> Ty<'tcx> {\n+                     -> Ty<'tcx>\n+    {\n         debug!(\"xform_self_ty(self_ty={}, substs={})\",\n-               method.fty.sig.inputs[0].repr(self.tcx()),\n+               method.fty.sig.0.inputs[0].repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n         // It is possible for type parameters or early-bound lifetimes\n@@ -909,15 +909,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         // Replace early-bound regions and types.\n-        let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n+        let xform_self_ty = method.fty.sig.0.inputs[0].subst(self.tcx(), substs);\n \n         // Replace late-bound regions bound in the impl or\n-        // where-clause (2 levels of binding).\n-        let xform_self_ty =\n-            self.erase_late_bound_regions(&ty::bind(ty::bind(xform_self_ty))).value.value;\n-\n-        // Replace late-bound regions bound in the method (1 level of binding).\n-        self.erase_late_bound_regions(&ty::bind(xform_self_ty)).value\n+        // where-clause (2 levels of binding) and method (1 level of binding).\n+        self.erase_late_bound_regions(\n+            &self.erase_late_bound_regions(\n+                &ty::Binder(ty::Binder(xform_self_ty))))\n     }\n \n     fn impl_substs(&self,\n@@ -955,8 +953,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///    region got replaced with the same variable, which requires a bit more coordination\n     ///    and/or tracking the substitution and\n     ///    so forth.\n-    fn erase_late_bound_regions<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable<'tcx>\n+    fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n         ty::erase_late_bound_regions(self.tcx(), value)\n     }"}, {"sha": "18f009fe6c479f56ddfe169bc7bf16c93f3978fd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -506,7 +506,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       unsafety: ast::Unsafety,\n                       unsafety_id: ast::NodeId,\n-                      fn_sig: &ty::FnSig<'tcx>,\n+                      fn_sig: &ty::PolyFnSig<'tcx>,\n                       decl: &ast::FnDecl,\n                       fn_id: ast::NodeId,\n                       body: &ast::Block,\n@@ -723,7 +723,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let body_id = method.pe_body().id;\n     let fty = liberate_late_bound_regions(\n-        ccx.tcx, CodeExtent::from_node_id(body_id), &ty::bind(fty)).value;\n+        ccx.tcx, CodeExtent::from_node_id(body_id), &ty::Binder(fty));\n     debug!(\"fty (liberated): {}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n@@ -924,7 +924,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let infcx = infer::new_infer_ctxt(tcx);\n \n-    let trait_to_impl_substs = impl_trait_ref.substs();\n+    let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n@@ -975,15 +975,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return;\n     }\n \n-    if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n+    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n         span_err!(tcx.sess, impl_m_span, E0050,\n             \"method `{}` has {} parameter{} \\\n              but the declaration in trait `{}` has {}\",\n             token::get_name(trait_m.name),\n-            impl_m.fty.sig.inputs.len(),\n-            if impl_m.fty.sig.inputs.len() == 1 {\"\"} else {\"s\"},\n+            impl_m.fty.sig.0.inputs.len(),\n+            if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n             ty::item_path_str(tcx, trait_m.def_id),\n-            trait_m.fty.sig.inputs.len());\n+            trait_m.fty.sig.0.inputs.len());\n         return;\n     }\n \n@@ -1085,7 +1085,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // `Bound<&'a T>`, the lifetime `'a` will be late-bound with a\n     // depth of 3 (it is nested within 3 binders: the impl, method,\n     // and trait-ref itself). So when we do the liberation, we have\n-    // two introduce two `ty::bind` scopes, one for the impl and one\n+    // two introduce two `ty::Binder` scopes, one for the impl and one\n     // the method.\n     //\n     // The only late-bounded regions that can possibly appear here are\n@@ -1103,7 +1103,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n              liberate_late_bound_regions(\n                  tcx,\n                  impl_m_body_scope,\n-                 &ty::bind(ty::bind(impl_param_def.bounds.clone()))).value.value);\n+                 &ty::Binder(ty::Binder(impl_param_def.bounds.clone()))).0);\n     for (i, (trait_param_bounds, impl_param_bounds)) in\n         trait_bounds.zip(impl_bounds).enumerate()\n     {\n@@ -1169,7 +1169,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n     let impl_fty = liberate_late_bound_regions(\n-        tcx, impl_m_body_scope, &ty::bind(impl_fty)).value;\n+        tcx, impl_m_body_scope, &ty::Binder(impl_fty));\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n@@ -1289,7 +1289,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             // impl, and the method.\n             let impl_bounds =\n                 ty::liberate_late_bound_regions(\n-                    tcx, impl_m_body_scope, &ty::bind(ty::bind(impl_bounds))).value.value;\n+                    tcx, impl_m_body_scope, &ty::Binder(ty::Binder(impl_bounds))).0;\n \n             debug!(\"check_region_bounds_on_impl_method: \\\n                    trait_param={} \\\n@@ -2546,13 +2546,13 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 check_argument_types(fcx,\n                                      sp,\n-                                     fty.sig.inputs.slice_from(1),\n+                                     fty.sig.0.inputs.slice_from(1),\n                                      callee_expr,\n                                      args_no_rcvr,\n                                      autoref_args,\n-                                     fty.sig.variadic,\n+                                     fty.sig.0.variadic,\n                                      tuple_arguments);\n-                fty.sig.output\n+                fty.sig.0.output\n             }\n             _ => {\n                 fcx.tcx().sess.span_bug(callee_expr.span,\n@@ -2966,11 +2966,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // This is the \"default\" function signature, used in case of error.\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n-        let error_fn_sig = FnSig {\n+        let error_fn_sig = ty::Binder(FnSig {\n             inputs: err_args(args.len()),\n             output: ty::FnConverging(ty::mk_err()),\n             variadic: false\n-        };\n+        });\n \n         let fn_sig = match *fn_sty {\n             ty::ty_bare_fn(ty::BareFnTy {ref sig, ..}) |\n@@ -5070,7 +5070,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.infcx().replace_late_bound_regions_with_fresh_var(\n             span,\n             infer::FnCall,\n-            &ty::bind((polytype.ty, bounds))).0.value;\n+            &ty::Binder((polytype.ty, bounds))).0;\n \n     debug!(\"after late-bounds have been replaced: ty_late_bound={}\", ty_late_bound.repr(fcx.tcx()));\n     debug!(\"after late-bounds have been replaced: bounds={}\", bounds.repr(fcx.tcx()));\n@@ -5686,11 +5686,11 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         unsafety: ast::Unsafety::Unsafe,\n         abi: abi::RustIntrinsic,\n-        sig: FnSig {\n+        sig: ty::Binder(FnSig {\n             inputs: inputs,\n             output: output,\n             variadic: false,\n-        }\n+        }),\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);"}, {"sha": "33c015a9a081cba3cf9895cbc97f531cb14bd7d6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -1181,7 +1181,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n-                let self_ty = fn_sig.inputs[0];\n+                let self_ty = fn_sig.0.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n@@ -1198,7 +1198,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 // Specialized version of constrain_call.\n                 type_must_outlive(rcx, infer::CallRcvr(deref_expr.span),\n                                   self_ty, r_deref_expr);\n-                match fn_sig.output {\n+                match fn_sig.0.output {\n                     ty::FnConverging(return_type) => {\n                         type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n                                           return_type, r_deref_expr);"}, {"sha": "ff91093ab5f7224f372aafa8ffc38324afe3af8b", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -207,12 +207,12 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         };\n         let ref sig = method.fty.sig;\n-        for &input_ty in sig.inputs[1..].iter() {\n+        for &input_ty in sig.0.inputs[1..].iter() {\n             if let Some(msg) = check_for_self_ty(input_ty) {\n                 msgs.push(msg);\n             }\n         }\n-        if let ty::FnConverging(result_type) = sig.output {\n+        if let ty::FnConverging(result_type) = sig.0.output {\n             if let Some(msg) = check_for_self_ty(result_type) {\n                 msgs.push(msg);\n             }"}, {"sha": "a90422cd309745a51c48d8a592288900ed0b9ff9", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -170,8 +170,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // liberated.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n             let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n-            let self_ty = liberate_late_bound_regions(\n-                fcx.tcx(), item_scope, &ty::bind(self_ty)).value;\n+            let self_ty = liberate_late_bound_regions(fcx.tcx(), item_scope, &ty::Binder(self_ty));\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n@@ -186,7 +185,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // There are special rules that apply to drop.\n             if\n-                fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id()) &&\n+                fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id) &&\n                 !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\")\n             {\n                 match self_ty.sty {\n@@ -200,7 +199,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             }\n \n-            if fcx.tcx().lang_items.copy_trait() == Some(trait_ref.def_id()) {\n+            if fcx.tcx().lang_items.copy_trait() == Some(trait_ref.def_id) {\n                 // This is checked in coherence.\n                 return\n             }\n@@ -219,10 +218,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 traits::ObligationCause::new(\n                     item.span,\n                     fcx.body_id,\n-                    traits::ItemObligation(trait_ref.def_id()));\n+                    traits::ItemObligation(trait_ref.def_id));\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n-            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &trait_ref);\n+            let poly_trait_ref = ty::Binder(trait_ref);\n+            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &poly_trait_ref);\n             for predicate in predicates.into_iter() {\n                 fcx.register_predicate(traits::Obligation::new(cause, predicate));\n             }\n@@ -264,18 +264,18 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     ///\n     /// Note that it does not (currently, at least) check that `A : Copy` (that check is delegated\n     /// to the point where impl `A : Trait<B>` is implemented).\n-    pub fn check_trait_ref(&mut self, trait_ref: &ty::PolyTraitRef<'tcx>) {\n-        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id());\n+    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n+        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n \n-        let bounds = trait_def.generics.to_bounds(self.tcx(), trait_ref.substs());\n+        let bounds = trait_def.generics.to_bounds(self.tcx(), &trait_ref.substs);\n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 self.span,\n                 self.fcx.body_id,\n-                traits::ItemObligation(trait_ref.def_id())),\n+                traits::ItemObligation(trait_ref.def_id)),\n             &bounds);\n \n-        for &ty in trait_ref.substs().types.iter() {\n+        for &ty in trait_ref.substs.types.iter() {\n             self.check_traits_in_ty(ty);\n         }\n     }"}, {"sha": "e79eac90508e9f0ee3f2292e1cb85520dd4a691b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -477,7 +477,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let self_type =\n                 ty::liberate_late_bound_regions(tcx,\n                                                 item_scope,\n-                                                &ty::bind(self_type)).value;\n+                                                &ty::Binder(self_type));\n \n             debug!(\"can_type_implement_copy(self_type={})\",\n                    self_type.repr(tcx));"}, {"sha": "e4d93123a269169f05bd5c2613db0c5e0255ad02", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -1638,8 +1638,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_id = trait_id;\n \n     let self_trait_ref =\n-        Rc::new(ty::bind(ty::TraitRef { def_id: local_def(trait_id),\n-                                        substs: (*substs).clone() }));\n+        Rc::new(ty::Binder(ty::TraitRef { def_id: local_def(trait_id),\n+                                          substs: (*substs).clone() }));\n \n     let def = ty::TypeParameterDef {\n         space: subst::SelfSpace,\n@@ -2155,9 +2155,9 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty::BareFnTy {\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,\n-            sig: ty::FnSig {inputs: input_tys,\n-                            output: output,\n-                            variadic: decl.variadic}\n+            sig: ty::Binder(ty::FnSig {inputs: input_tys,\n+                                       output: output,\n+                                       variadic: decl.variadic}),\n         });\n     let pty = Polytype {\n         generics: ty_generics_for_fn_or_method,\n@@ -2209,16 +2209,16 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         assert!(!ty::type_escapes_depth(required_type, 1));\n         let required_type_free =\n             ty::liberate_late_bound_regions(\n-                crate_context.tcx, body_scope, &ty::bind(required_type)).value;\n+                crate_context.tcx, body_scope, &ty::Binder(required_type));\n \n         // The \"base type\" comes from the impl. It may have late-bound\n         // regions from the impl or the method.\n-        let base_type_free = // liberate impl regions:\n-            ty::liberate_late_bound_regions(\n-                crate_context.tcx, body_scope, &ty::bind(ty::bind(base_type))).value.value;\n-        let base_type_free = // liberate method regions:\n-            ty::liberate_late_bound_regions(\n-                crate_context.tcx, body_scope, &ty::bind(base_type_free)).value;\n+        let base_type_free =\n+            ty::liberate_late_bound_regions( // liberate impl regions:\n+                crate_context.tcx, body_scope,\n+                &ty::liberate_late_bound_regions( // liberate method regions:\n+                    crate_context.tcx, body_scope,\n+                    &ty::Binder(ty::Binder(base_type))));\n \n         debug!(\"required_type={} required_type_free={} \\\n                 base_type={} base_type_free={}\","}, {"sha": "5fc2466674ebe61dc9ba1bd5c51a7cf2364b1b6c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -228,11 +228,11 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n-                sig: ty::FnSig {\n+                sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(ty::mk_nil(tcx)),\n                     variadic: false\n-                }\n+                })\n             });\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n@@ -276,14 +276,14 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n-                sig: ty::FnSig {\n+                sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n                     ),\n                     output: ty::FnConverging(ty::mk_int()),\n                     variadic: false\n-                }\n+                }),\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,"}, {"sha": "67478e0bfa77eadab2d48057af08363b8a69f06b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -878,13 +878,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                sig: &ty::FnSig<'tcx>,\n+                                sig: &ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n-        for &input in sig.inputs.iter() {\n+        for &input in sig.0.inputs.iter() {\n             self.add_constraints_from_ty(input, contra);\n         }\n-        if let ty::FnConverging(result_type) = sig.output {\n+        if let ty::FnConverging(result_type) = sig.0.output {\n             self.add_constraints_from_ty(result_type, variance);\n         }\n     }"}, {"sha": "661d6ec241ade42319c3342065ef803954c6dfcc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1205fd88df2b87c682f2e98e30ba9e2d8d44d656/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1205fd88df2b87c682f2e98e30ba9e2d8d44d656", "patch": "@@ -577,7 +577,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n \n impl<'tcx> Clean<TyParamBound> for ty::PolyTraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        self.value.clean(cx)\n+        self.0.clean(cx)\n     }\n }\n \n@@ -919,7 +919,7 @@ impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig<'tcx>) {\n+impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n@@ -931,10 +931,10 @@ impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig<'tcx>) {\n             let _ = names.next();\n         }\n         FnDecl {\n-            output: Return(sig.output.clean(cx)),\n+            output: Return(sig.0.output.clean(cx)),\n             attrs: Vec::new(),\n             inputs: Arguments {\n-                values: sig.inputs.iter().map(|t| {\n+                values: sig.0.inputs.iter().map(|t| {\n                     Argument {\n                         type_: t.clean(cx),\n                         id: 0,\n@@ -1088,22 +1088,22 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(cx),\n                                                self.fty.sig.clone()),\n             s => {\n-                let sig = ty::FnSig {\n-                    inputs: self.fty.sig.inputs[1..].to_vec(),\n-                    ..self.fty.sig.clone()\n-                };\n+                let sig = ty::Binder(ty::FnSig {\n+                    inputs: self.fty.sig.0.inputs[1..].to_vec(),\n+                    ..self.fty.sig.0.clone()\n+                });\n                 let s = match s {\n                     ty::ByValueExplicitSelfCategory => SelfValue,\n                     ty::ByReferenceExplicitSelfCategory(..) => {\n-                        match self.fty.sig.inputs[0].sty {\n+                        match self.fty.sig.0.inputs[0].sty {\n                             ty::ty_rptr(r, mt) => {\n                                 SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n                             }\n                             _ => unreachable!(),\n                         }\n                     }\n                     ty::ByBoxExplicitSelfCategory => {\n-                        SelfExplicit(self.fty.sig.inputs[0].clean(cx))\n+                        SelfExplicit(self.fty.sig.0.inputs[0].clean(cx))\n                     }\n                     ty::StaticExplicitSelfCategory => unreachable!(),\n                 };\n@@ -1398,7 +1398,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n             ty::ty_trait(box ty::TyTrait {\n-                principal: ty::Binder { value: ty::TraitRef { def_id: did, ref substs } },\n+                principal: ty::Binder(ty::TraitRef { def_id: did, ref substs }),\n                 .. }) =>\n             {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);"}]}