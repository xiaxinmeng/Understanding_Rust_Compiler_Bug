{"sha": "d6ede9192d520ffda332e337418b00d357082dd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZWRlOTE5MmQ1MjBmZmRhMzMyZTMzNzQxOGIwMGQzNTcwODJkZDY=", "commit": {"author": {"name": "Lucas Molas", "email": "schomatis@gmail.com", "date": "2019-02-15T04:04:16Z"}, "committer": {"name": "Lucas Molas", "email": "schomatis@gmail.com", "date": "2019-02-16T00:40:24Z"}, "message": "nll: remove `NllLivenessMap` and `LiveVar`\n\nExtract the `compute` logic (now renamed `compute_live_locals`) from\n`NllLivenessMap` to the `liveness` module. Remove the unused structures.", "tree": {"sha": "a7b7725032e60fa5066e3d535f2e10a0005f5ef4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7b7725032e60fa5066e3d535f2e10a0005f5ef4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6ede9192d520ffda332e337418b00d357082dd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ede9192d520ffda332e337418b00d357082dd6", "html_url": "https://github.com/rust-lang/rust/commit/d6ede9192d520ffda332e337418b00d357082dd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6ede9192d520ffda332e337418b00d357082dd6/comments", "author": {"login": "schomatis", "id": 10407385, "node_id": "MDQ6VXNlcjEwNDA3Mzg1", "avatar_url": "https://avatars.githubusercontent.com/u/10407385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/schomatis", "html_url": "https://github.com/schomatis", "followers_url": "https://api.github.com/users/schomatis/followers", "following_url": "https://api.github.com/users/schomatis/following{/other_user}", "gists_url": "https://api.github.com/users/schomatis/gists{/gist_id}", "starred_url": "https://api.github.com/users/schomatis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/schomatis/subscriptions", "organizations_url": "https://api.github.com/users/schomatis/orgs", "repos_url": "https://api.github.com/users/schomatis/repos", "events_url": "https://api.github.com/users/schomatis/events{/privacy}", "received_events_url": "https://api.github.com/users/schomatis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "schomatis", "id": 10407385, "node_id": "MDQ6VXNlcjEwNDA3Mzg1", "avatar_url": "https://avatars.githubusercontent.com/u/10407385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/schomatis", "html_url": "https://github.com/schomatis", "followers_url": "https://api.github.com/users/schomatis/followers", "following_url": "https://api.github.com/users/schomatis/following{/other_user}", "gists_url": "https://api.github.com/users/schomatis/gists{/gist_id}", "starred_url": "https://api.github.com/users/schomatis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/schomatis/subscriptions", "organizations_url": "https://api.github.com/users/schomatis/orgs", "repos_url": "https://api.github.com/users/schomatis/repos", "events_url": "https://api.github.com/users/schomatis/events{/privacy}", "received_events_url": "https://api.github.com/users/schomatis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ae4e0501bdf9e6d6be06757b08f92e3553848c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae4e0501bdf9e6d6be06757b08f92e3553848c6", "html_url": "https://github.com/rust-lang/rust/commit/4ae4e0501bdf9e6d6be06757b08f92e3553848c6"}], "stats": {"total": 188, "additions": 71, "deletions": 117}, "files": [{"sha": "2d3800dd1dda86d28f87e2a8d312e39825ab71e6", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6ede9192d520ffda332e337418b00d357082dd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ede9192d520ffda332e337418b00d357082dd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=d6ede9192d520ffda332e337418b00d357082dd6", "patch": "@@ -2,7 +2,6 @@ use crate::borrow_check::borrow_set::BorrowSet;\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n use crate::borrow_check::nll::facts::AllFactsExt;\n use crate::borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n-use crate::borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;"}, {"sha": "b9f9d83161b79649a7cb9b9a885b104c69113006", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4ae4e0501bdf9e6d6be06757b08f92e3553848c6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae4e0501bdf9e6d6be06757b08f92e3553848c6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=4ae4e0501bdf9e6d6be06757b08f92e3553848c6", "patch": "@@ -1,94 +0,0 @@\n-//! For the NLL computation, we need to compute liveness, but only for those\n-//! local variables whose types contain regions. The others are not of interest\n-//! to us. This file defines a new index type (LiveVar) that indexes into\n-//! a list of \"variables whose type contain regions\". It also defines a map from\n-//! Local to LiveVar and vice versa -- this map can be given to the\n-//! liveness code so that it only operates over variables with regions in their\n-//! types, instead of all variables.\n-\n-use crate::borrow_check::nll::ToRegionVid;\n-use crate::borrow_check::nll::facts::{AllFacts, AllFactsExt};\n-use crate::util::liveness::LiveVariableMap;\n-use rustc::mir::{Local, Mir};\n-use rustc::ty::{RegionVid, TyCtxt};\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-\n-/// Map between Local and LiveVar indices: the purpose of this\n-/// map is to define the subset of local variables for which we need\n-/// to do a liveness computation. We only need to compute whether a\n-/// variable `X` is live if that variable contains some region `R` in\n-/// its type where `R` is not known to outlive a free region (i.e.,\n-/// where `R` may be valid for just a subset of the fn body).\n-crate struct NllLivenessMap {\n-    /// For each local variable, contains `Some(i)` if liveness is\n-    /// needed for this variable.\n-    pub from_local: IndexVec<Local, Option<LiveVar>>,\n-\n-    /// For each `LiveVar`, maps back to the original `Local` index.\n-    pub to_local: IndexVec<LiveVar, Local>,\n-}\n-\n-impl LiveVariableMap for NllLivenessMap {\n-    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n-        self.from_local[local]\n-    }\n-\n-    type LiveVar = LiveVar;\n-\n-    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n-        self.to_local[local]\n-    }\n-\n-    fn num_variables(&self) -> usize {\n-        self.to_local.len()\n-    }\n-}\n-\n-impl NllLivenessMap {\n-    crate fn compute(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        free_regions: &FxHashSet<RegionVid>,\n-        mir: &Mir<'tcx>,\n-    ) -> Self {\n-        let mut to_local = IndexVec::default();\n-        let facts_enabled = AllFacts::enabled(tcx);\n-        let from_local: IndexVec<Local, Option<_>> = mir.local_decls\n-            .iter_enumerated()\n-            .map(|(local, local_decl)| {\n-                if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n-                    free_regions.contains(&r.to_region_vid())\n-                }) && !facts_enabled {\n-                    // If all the regions in the type are free regions\n-                    // (or there are no regions), then we don't need\n-                    // to track liveness for this variable.\n-                    None\n-                } else {\n-                    Some(to_local.push(local))\n-                }\n-            })\n-            .collect();\n-\n-        debug!(\"{} total variables\", mir.local_decls.len());\n-        debug!(\"{} variables need liveness\", to_local.len());\n-        debug!(\"{} regions outlive free regions\", free_regions.len());\n-\n-        Self {\n-            from_local,\n-            to_local,\n-        }\n-    }\n-\n-    /// Returns `true` if there are no local variables that need liveness computation.\n-    crate fn is_empty(&self) -> bool {\n-        self.to_local.is_empty()\n-    }\n-}\n-\n-/// Index given to each local variable for which we need to\n-/// compute liveness information. For many locals, we are able to\n-/// skip liveness information: for example, those variables whose\n-/// types contain no regions.\n-newtype_index! {\n-    pub struct LiveVar { .. }\n-}"}, {"sha": "960e75048fa1614d112fb2ec9d1a5da4862b320b", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d6ede9192d520ffda332e337418b00d357082dd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ede9192d520ffda332e337418b00d357082dd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=d6ede9192d520ffda332e337418b00d357082dd6", "patch": "@@ -1,19 +1,19 @@\n use crate::borrow_check::location::LocationTable;\n-use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::borrow_check::nll::constraints::ConstraintSet;\n-use crate::borrow_check::nll::NllLivenessMap;\n+use crate::borrow_check::nll::facts::{AllFacts, AllFactsExt};\n+use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n use crate::borrow_check::nll::universal_regions::UniversalRegions;\n+use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n-use crate::dataflow::MaybeInitializedPlaces;\n use crate::dataflow::FlowAtLocation;\n-use rustc::mir::Mir;\n-use rustc::ty::RegionVid;\n+use crate::dataflow::MaybeInitializedPlaces;\n+use rustc::mir::{Local, Mir};\n+use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n \n use super::TypeChecker;\n \n-crate mod liveness_map;\n mod local_use_map;\n mod trace;\n \n@@ -34,16 +34,71 @@ pub(super) fn generate<'gcx, 'tcx>(\n     location_table: &LocationTable,\n ) {\n     debug!(\"liveness::generate\");\n-    let free_regions = {\n-        let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n-        regions_that_outlive_free_regions(\n-            typeck.infcx.num_region_vars(),\n-            &borrowck_context.universal_regions,\n-            &borrowck_context.constraints.outlives_constraints,\n-        )\n+\n+    let live_locals: Vec<Local> = if AllFacts::enabled(typeck.tcx()) {\n+        // If \"dump facts from NLL analysis\" was requested perform\n+        // the liveness analysis for all `Local`s. This case opens\n+        // the possibility of the variables being analyzed in `trace`\n+        // to be *any* `Local`, not just the \"live\" ones, so we can't\n+        // make any assumptions past this point as to the characteristics\n+        // of the `live_locals`.\n+        // FIXME: Review \"live\" terminology past this point, we should\n+        // not be naming the `Local`s as live.\n+        mir.local_decls.indices().collect()\n+    } else {\n+        let free_regions = {\n+            let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n+            regions_that_outlive_free_regions(\n+                typeck.infcx.num_region_vars(),\n+                &borrowck_context.universal_regions,\n+                &borrowck_context.constraints.outlives_constraints,\n+            )\n+        };\n+        compute_live_locals(typeck.tcx(), &free_regions, mir)\n     };\n-    let liveness_map = NllLivenessMap::compute(typeck.tcx(), &free_regions, mir);\n-    trace::trace(typeck, mir, elements, flow_inits, move_data, &liveness_map, location_table);\n+\n+    if !live_locals.is_empty() {\n+        trace::trace(\n+            typeck,\n+            mir,\n+            elements,\n+            flow_inits,\n+            move_data,\n+            live_locals,\n+            location_table,\n+        );\n+    }\n+}\n+\n+// The purpose of `compute_live_locals` is to define the subset of `Local`\n+// variables for which we need to do a liveness computation. We only need\n+// to compute whether a variable `X` is live if that variable contains\n+// some region `R` in its type where `R` is not known to outlive a free\n+// region (i.e., where `R` may be valid for just a subset of the fn body).\n+fn compute_live_locals(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    free_regions: &FxHashSet<RegionVid>,\n+    mir: &Mir<'tcx>,\n+) -> Vec<Local> {\n+    let live_locals: Vec<Local> = mir\n+        .local_decls\n+        .iter_enumerated()\n+        .filter_map(|(local, local_decl)| {\n+            if tcx.all_free_regions_meet(&local_decl.ty, |r| {\n+                free_regions.contains(&r.to_region_vid())\n+            }) {\n+                None\n+            } else {\n+                Some(local)\n+            }\n+        })\n+        .collect();\n+\n+    debug!(\"{} total variables\", mir.local_decls.len());\n+    debug!(\"{} variables need liveness\", live_locals.len());\n+    debug!(\"{} regions outlive free regions\", free_regions.len());\n+\n+    live_locals\n }\n \n /// Computes all regions that are (currently) known to outlive free"}, {"sha": "f0df7070e6b5ab41799f5d965dd014ab0849b719", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6ede9192d520ffda332e337418b00d357082dd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ede9192d520ffda332e337418b00d357082dd6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=d6ede9192d520ffda332e337418b00d357082dd6", "patch": "@@ -1,6 +1,5 @@\n use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n-use crate::borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use crate::borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n use crate::borrow_check::nll::type_check::NormalizeLocation;\n use crate::borrow_check::nll::type_check::TypeChecker;\n@@ -37,16 +36,11 @@ pub(super) fn trace(\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-    liveness_map: &NllLivenessMap,\n+    live_locals: Vec<Local>,\n     location_table: &LocationTable,\n ) {\n     debug!(\"trace()\");\n \n-    if liveness_map.is_empty() {\n-        return;\n-    }\n-\n-    let live_locals: Vec<Local> = liveness_map.to_local.clone().into_iter().collect();\n     let local_use_map = &LocalUseMap::build(&live_locals, elements, mir);\n \n     let cx = LivenessContext {"}]}