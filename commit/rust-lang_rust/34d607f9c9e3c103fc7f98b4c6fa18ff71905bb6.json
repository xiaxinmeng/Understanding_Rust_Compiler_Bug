{"sha": "34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZDYwN2Y5YzllM2MxMDNmYzdmOThiNGM2ZmExOGZmNzE5MDViYjY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-04-25T03:14:52Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-08-26T00:37:45Z"}, "message": "Use the slice repr for ~[T]", "tree": {"sha": "c8a1575043d5aeb5b8d4eff05d8ff3eda87781ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8a1575043d5aeb5b8d4eff05d8ff3eda87781ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "html_url": "https://github.com/rust-lang/rust/commit/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fb2dfaa200f2cb32e77c54ae8a5e0f4823b65c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb2dfaa200f2cb32e77c54ae8a5e0f4823b65c8", "html_url": "https://github.com/rust-lang/rust/commit/5fb2dfaa200f2cb32e77c54ae8a5e0f4823b65c8"}], "stats": {"total": 511, "additions": 247, "deletions": 264}, "files": [{"sha": "bd8e18d1f3c1b59cf3eb2238bf49681e6c3ceaa4", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -92,6 +92,8 @@ use core::iter::{range_step, MultiplicativeIterator};\n \n use MutableSeq;\n use vec::Vec;\n+#[cfg(not(stage0))]\n+use raw::Slice;\n \n pub use core::slice::{Chunks, Slice, ImmutableSlice, ImmutablePartialEqSlice};\n pub use core::slice::{ImmutableOrdSlice, MutableSlice, Items, MutItems};\n@@ -282,6 +284,64 @@ pub trait CloneableVector<T> {\n \n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n+    #[cfg(not(stage0))]\n+    fn to_owned(&self) -> ~[T] {\n+        use num::CheckedMul;\n+        use option::Expect;\n+\n+        let len = self.len();\n+\n+        if len == 0 {\n+            unsafe {\n+                let slice: Slice<T> = Slice{data: 0 as *T, len: 0};\n+                mem::transmute(slice)\n+            }\n+        } else {\n+            let unit_size = mem::size_of::<T>();\n+            let data_size = if unit_size == 0 {\n+                len\n+            } else {\n+                let data_size = len.checked_mul(&unit_size);\n+                data_size.expect(\"overflow in from_iter()\")\n+            };\n+\n+            unsafe {\n+                // this should pass the real required alignment\n+                let ret = allocate(data_size, 8) as *mut T;\n+\n+                if unit_size > 0 {\n+                    // Be careful with the following loop. We want it to be optimized\n+                    // to a memcpy (or something similarly fast) when T is Copy. LLVM\n+                    // is easily confused, so any extra operations during the loop can\n+                    // prevent this optimization.\n+                    let mut i = 0;\n+                    let p = &mut (*ret) as *mut _ as *mut T;\n+                    try_finally(\n+                        &mut i, (),\n+                        |i, ()| while *i < len {\n+                            mem::move_val_init(\n+                                &mut(*p.offset(*i as int)),\n+                                self.unsafe_ref(*i).clone());\n+                            *i += 1;\n+                        },\n+                        |i| if *i < len {\n+                            // we must be failing, clean up after ourselves\n+                            for j in range(0, *i as int) {\n+                                ptr::read(&*p.offset(j));\n+                            }\n+                            // FIXME: #13994 (should pass align and size here)\n+                            deallocate(ret as *mut u8, 0, 8);\n+                        });\n+                }\n+                let slice: Slice<T> = Slice{data: ret as *T, len: len};\n+                mem::transmute(slice)\n+            }\n+        }\n+    }\n+\n+    /// Returns a copy of `v`.\n+    // NOTE: remove after snapshot\n+    #[cfg(stage0)]\n     #[inline]\n     fn to_vec(&self) -> Vec<T> { Vec::from_slice(*self) }\n "}, {"sha": "f0c39766ebb300548b5d5798d8c331d5e7f777c1", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -174,7 +174,7 @@ pub unsafe fn overwrite<T>(dst: *mut T, src: T) {\n \n /// Deprecated, use `overwrite` instead\n #[inline]\n-#[deprecated = \"use ptr::write\"]\n+#[deprecated = \"this function has been renamed to overwrite()\"]\n pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n     ptr::write(dst, src)\n }"}, {"sha": "57f8f8d6692f03ceecdc628f5760f9ea8960dea3", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -305,8 +305,7 @@ impl Case {\n \n                 // Box<T> could either be a thin or fat pointer depending on T\n                 ty::ty_uniq(t) => match ty::get(t).sty {\n-                    // Box<[T]>/Box<str> might be FatPointer in a post DST world\n-                    ty::ty_vec(_, None) | ty::ty_str => continue,\n+                    ty::ty_vec(_, None) | return Some(FatPointer(i, slice_elt_base)),\n \n                     // Box<Trait> is a pair of pointers: the actual object and a vtable\n                     ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n@@ -326,7 +325,6 @@ impl Case {\n \n                 // Anything else is not a pointer\n                 _ => continue\n-\n             }\n         }\n "}, {"sha": "7c2f251bd168525aefe016628d3841dbb9a0bae6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -195,6 +195,16 @@ pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n                                                llvm::NoReturnAttribute as uint64_t)\n             }\n         }\n+        // `~` pointer return values never alias because ownership is transferred\n+        ty::ty_uniq(t)\n+            => match ty::get(t).sty {\n+                ty::ty_vec(_, None) | ty::ty_str | ty::ty_trait(..) => {}\n+                _ => unsafe {\n+                    llvm::LLVMAddReturnAttribute(llfn,\n+                                                 lib::llvm::NoAliasAttribute as c_uint,\n+                                                 lib::llvm::NoReturnAttribute as uint64_t);\n+                }\n+            },\n         _ => {}\n     }\n \n@@ -364,20 +374,19 @@ fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n // a given type, but with a potentially dynamic size.\n \n pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n-                          ptr_ty: ty::t,\n+                          llty_ptr: Type,\n+                          info_ty: ty::t,\n                           size: ValueRef,\n                           align: ValueRef)\n                           -> Result<'a> {\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n-    let ccx = bcx.ccx();\n \n     // Allocate space:\n     let r = callee::trans_lang_call(bcx,\n-        require_alloc_fn(bcx, ptr_ty, ExchangeMallocFnLangItem),\n+        require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n         [size, align],\n         None);\n \n-    let llty_ptr = type_of::type_of(ccx, ptr_ty);\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n@@ -731,8 +740,8 @@ pub fn iter_structural_ty<'r,\n           }\n       }\n       ty::ty_vec(_, Some(n)) => {\n+        let (base, len) = tvec::get_fixed_base_and_len(cx, av, n);\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n-        let (base, len) = tvec::get_fixed_base_and_byte_len(cx, av, unit_ty, n);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n       ty::ty_tup(ref args) => {"}, {"sha": "db674b4028f24b43efadc7216ccc79feef3002d2", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -2718,81 +2718,6 @@ fn fixed_vec_metadata(cx: &CrateContext,\n     return MetadataCreationResult::new(metadata, false);\n }\n \n-fn heap_vec_metadata(cx: &CrateContext,\n-                     vec_pointer_type: ty::t,\n-                     element_type: ty::t,\n-                     unique_type_id: UniqueTypeId,\n-                     span: Span)\n-                  -> MetadataCreationResult {\n-    let element_type_metadata = type_metadata(cx, element_type, span);\n-    let element_llvm_type = type_of::type_of(cx, element_type);\n-    let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n-\n-    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n-\n-    let vecbox_llvm_type = Type::vec(cx, &element_llvm_type);\n-    let vec_pointer_type_name = compute_debuginfo_type_name(cx,\n-                                                            vec_pointer_type,\n-                                                            true);\n-    let vec_pointer_type_name = vec_pointer_type_name.as_slice();\n-\n-    let member_llvm_types = vecbox_llvm_type.field_types();\n-\n-    let int_type_metadata = type_metadata(cx, ty::mk_int(), span);\n-    let array_type_metadata = unsafe {\n-        llvm::LLVMDIBuilderCreateArrayType(\n-            DIB(cx),\n-            bytes_to_bits(element_size),\n-            bytes_to_bits(element_align),\n-            element_type_metadata,\n-            create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n-    };\n-\n-    let member_descriptions = [\n-        MemberDescription {\n-            name: \"fill\".to_string(),\n-            llvm_type: *member_llvm_types.get(0),\n-            type_metadata: int_type_metadata,\n-            offset: ComputedMemberOffset,\n-        },\n-        MemberDescription {\n-            name: \"alloc\".to_string(),\n-            llvm_type: *member_llvm_types.get(1),\n-            type_metadata: int_type_metadata,\n-            offset: ComputedMemberOffset,\n-        },\n-        MemberDescription {\n-            name: \"elements\".to_string(),\n-            llvm_type: *member_llvm_types.get(2),\n-            type_metadata: array_type_metadata,\n-            offset: ComputedMemberOffset,\n-        }\n-    ];\n-\n-    assert!(member_descriptions.len() == member_llvm_types.len());\n-\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n-\n-    let vec_box_unique_id = debug_context(cx).type_map\n-                                             .borrow_mut()\n-                                             .get_unique_type_id_of_heap_vec_box(cx,\n-                                                                                 element_type);\n-\n-    let vecbox_metadata = composite_type_metadata(cx,\n-                                                  vecbox_llvm_type,\n-                                                  vec_pointer_type_name,\n-                                                  vec_box_unique_id,\n-                                                  member_descriptions,\n-                                                  UNKNOWN_SCOPE_METADATA,\n-                                                  file_metadata,\n-                                                  span);\n-\n-    MetadataCreationResult::new(pointer_type_metadata(cx,\n-                                                      vec_pointer_type,\n-                                                      vecbox_metadata), false)\n-}\n-\n fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n@@ -2995,11 +2920,13 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_uniq(pointee_type) => {\n             match ty::get(pointee_type).sty {\n                 ty::ty_vec(ref mt, None) => {\n-                    heap_vec_metadata(cx, pointee_type, mt.ty, unique_type_id, usage_site_span)\n+                    let vec_metadata = vec_slice_metadata(cx, t, mt.ty, usage_site_span);\n+                    pointer_type_metadata(cx, t, vec_metadata)\n                 }\n                 ty::ty_str => {\n                     let i8_t = ty::mk_i8();\n-                    heap_vec_metadata(cx, pointee_type, i8_t, unique_type_id, usage_site_span)\n+                    let vec_metadata = vec_slice_metadata(cx, t, i8_t, usage_site_span);\n+                    pointer_type_metadata(cx, t, vec_metadata)\n                 }\n                 ty::ty_trait(..) => {\n                     MetadataCreationResult::new("}, {"sha": "ead90dbe36b2c54f10c34fac09450f1b6f9cb93a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -395,8 +395,8 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprField(ref base, ident, _) => {\n             trans_rec_field(bcx, &**base, ident.node)\n         }\n-        ast::ExprIndex(ref base, ref idx) => {\n-            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n+        ast::ExprIndex(base, idx) => {\n+            trans_index(bcx, expr.span, &**base, &**idx, MethodCall::expr(expr.id))\n         }\n         ast::ExprVstore(ref contents, ast::ExprVstoreUniq) => {\n             fcx.push_ast_cleanup_scope(contents.id);\n@@ -465,7 +465,7 @@ fn trans_rec_field<'a>(bcx: &'a Block<'a>,\n }\n \n fn trans_index<'a>(bcx: &'a Block<'a>,\n-                   index_expr: &ast::Expr,\n+                   sp: codemap::Span,\n                    base: &ast::Expr,\n                    idx: &ast::Expr,\n                    method_call: MethodCall)\n@@ -1256,10 +1256,8 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n     let align = C_uint(bcx.ccx(), llalign_of_min(bcx.ccx(), llty) as uint);\n-    // We need to a make a pointer type because box_ty is ty_bot\n-    // if content_ty is, e.g. box fail!().\n-    let real_box_ty = ty::mk_uniq(bcx.tcx(), contents_ty);\n-    let Result { bcx, val } = malloc_raw_dyn(bcx, real_box_ty, size, align);\n+    let llty_ptr = llty.ptr_to();\n+    let Result { bcx, val } = malloc_raw_dyn(bcx, llty_ptr, box_ty, size, align);\n     // Unique boxes do not allocate for zero-size types. The standard library\n     // may assume that `free` is never called on the pointer returned for\n     // `Box<ZeroSizeType>`."}, {"sha": "8faf27d1aa4159dfc08b97f3f2b054416501bc0c", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -51,7 +51,7 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n         Some(expr::Ignore)).bcx\n }\n \n-fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n+pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef, size: u64,\n                                align: u64) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     let ccx = cx.ccx();\n@@ -120,8 +120,8 @@ pub fn drop_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n                -> &'a Block<'a> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"drop_ty\");\n-    let ccx = bcx.ccx();\n     if ty::type_needs_drop(bcx.tcx(), t) {\n+        let ccx = bcx.ccx();\n         let glue = get_drop_glue(ccx, t);\n         let glue_type = get_drop_glue_type(ccx, t);\n         let ptr = if glue_type != t {\n@@ -277,23 +277,11 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n         ty::ty_uniq(content_ty) => {\n             match ty::get(content_ty).sty {\n                 ty::ty_vec(mt, None) => {\n-                    let llbox = Load(bcx, v0);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, mt.ty);\n-                        // FIXME: #13994: the old `Box<[T]>` will not support sized deallocation\n-                        trans_exchange_free(bcx, llbox, 0, 8)\n-                    })\n+                    tvec::make_drop_glue_unboxed(bcx, v0, mt.ty)\n                 }\n                 ty::ty_str => {\n-                    let llbox = Load(bcx, v0);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n-                        let bcx = tvec::make_drop_glue_unboxed(bcx, llbox, unit_ty);\n-                        // FIXME: #13994: the old `Box<str>` will not support sized deallocation\n-                        trans_exchange_free(bcx, llbox, 0, 8)\n-                    })\n+                    let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+                    tvec::make_drop_glue_unboxed(bcx, v0, unit_ty)\n                 }\n                 ty::ty_trait(..) => {\n                     let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);"}, {"sha": "fcc1b8278768501a0a37b75898f4ab737f0f302c", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -164,6 +164,10 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               });\n               self.visit(\"box\", extra.as_slice())\n           }\n+          ty::ty_ptr(ref mt) => {\n+              let extra = self.c_mt(mt);\n+              self.visit(\"ptr\", extra.as_slice())\n+          }\n           ty::ty_uniq(typ) => {\n               match ty::get(typ).sty {\n                   ty::ty_vec(ref mt, None) => {\n@@ -188,17 +192,12 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                   }\n               }\n           }\n-          ty::ty_ptr(ref mt) => {\n-              let extra = self.c_mt(mt);\n-              self.visit(\"ptr\", extra.as_slice())\n-          }\n           ty::ty_rptr(_, ref mt) => {\n               match ty::get(mt.ty).sty {\n                   ty::ty_vec(ref mt, None) => {\n-                      let (name, extra) = (\"slice\".to_string(), Vec::new());\n+                      let extra = Vec::new();\n                       let extra = extra.append(self.c_mt(mt).as_slice());\n-                      self.visit(format!(\"evec_{}\", name).as_slice(),\n-                                 extra.as_slice())\n+                      self.visit(\"evec_slice\", extra.as_slice())\n                   }\n                   ty::ty_str => self.visit(\"estr_slice\", &[]),\n                   ty::ty_trait(..) => {"}, {"sha": "7b8537b15c55506c768041a59334fa0b51486501", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 76, "deletions": 109, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -17,15 +17,14 @@ use middle::lang_items::StrDupUniqFnLangItem;\n use middle::trans::base::*;\n use middle::trans::base;\n use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n use middle::trans::expr::{Dest, Ignore, SaveIn};\n use middle::trans::expr;\n use middle::trans::glue;\n-use middle::trans::machine::{llsize_of, nonzero_llsize_of, llsize_of_alloc};\n+use middle::trans::machine::{nonzero_llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n@@ -34,14 +33,14 @@ use util::ppaux::ty_to_string;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-pub fn get_fill(bcx: &Block, vptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::get_fill\");\n-    Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n+fn get_len(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+    let _icx = push_ctxt(\"tvec::get_lenl\");\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::slice_elt_len]))\n }\n \n-pub fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n+fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::get_dataptr\");\n-    GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n+    Load(bcx, GEPi(bcx, vptr, [0u, abi::slice_elt_base]))\n }\n \n pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n@@ -56,13 +55,21 @@ pub fn make_drop_glue_unboxed<'a>(\n                               vptr: ValueRef,\n                               unit_ty: ty::t)\n                               -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n-    let tcx = bcx.tcx();\n-    if ty::type_needs_drop(tcx, unit_ty) {\n-        let fill = get_fill(bcx, vptr);\n+    let not_null = IsNotNull(bcx, vptr);\n+    with_cond(bcx, not_null, |bcx| {\n+        let tcx = bcx.tcx();\n+        let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n+\n+        let len = get_len(bcx, vptr);\n         let dataptr = get_dataptr(bcx, vptr);\n-        iter_vec_raw(bcx, dataptr, unit_ty, fill, glue::drop_ty)\n-    } else { bcx }\n+        let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n+            iter_vec_raw(bcx, dataptr, unit_ty, len, glue::drop_ty)\n+        } else {\n+            bcx\n+        };\n+\n+        glue::trans_exchange_free(bcx, dataptr, 0, 8)\n+    })\n }\n \n pub struct VecTypes {\n@@ -112,12 +119,11 @@ pub fn trans_fixed_vstore<'a>(\n     };\n }\n \n-pub fn trans_slice_vstore<'a>(\n-                          bcx: &'a Block<'a>,\n-                          vstore_expr: &ast::Expr,\n-                          content_expr: &ast::Expr,\n-                          dest: expr::Dest)\n-                          -> &'a Block<'a> {\n+pub fn trans_slice_vstore<'a>(bcx: &'a Block<'a>,\n+                              vstore_expr: &ast::Expr,\n+                              content_expr: &ast::Expr,\n+                              dest: expr::Dest)\n+                              -> &'a Block<'a> {\n     /*!\n      * &[...] allocates memory on the stack and writes the values into it,\n      * returning a slice (pair of ptr, len).  &\"...\" is similar except that\n@@ -150,17 +156,16 @@ pub fn trans_slice_vstore<'a>(\n     // Handle the &[...] case:\n     let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n-    debug!(\"vt={}, count={:?}\", vt.to_string(ccx), count);\n-\n+    debug!(\"    vt={}, count={:?}\", vt.to_str(ccx), count);\n     let llcount = C_uint(ccx, count);\n-    let llfixed;\n-    if count == 0 {\n+\n+    let llfixed = if count == 0 {\n         // Just create a zero-sized alloca to preserve\n         // the non-null invariant of the inner slice ptr\n-        llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+        base::arrayalloca(bcx, vt.llunit_ty, llcount)\n     } else {\n         // Make a fixed-length backing array and allocate it on the stack.\n-        llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n+        let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n \n         // Arrange for the backing array to be cleaned up.\n         let fixed_ty = ty::mk_vec(bcx.tcx(),\n@@ -176,7 +181,9 @@ pub fn trans_slice_vstore<'a>(\n         // Generate the content into the backing array.\n         bcx = write_content(bcx, &vt, vstore_expr,\n                             content_expr, SaveIn(llfixed));\n-    }\n+\n+        llfixed\n+    };\n \n     // Finally, create the slice pair itself.\n     match dest {\n@@ -198,7 +205,7 @@ pub fn trans_lit_str<'a>(\n                      -> &'a Block<'a> {\n     /*!\n      * Literal strings translate to slices into static memory.  This is\n-     * different from trans_slice_vstore() above because it does need to copy\n+     * different from trans_slice_vstore() above because it doesn't need to copy\n      * the content anywhere.\n      */\n \n@@ -214,17 +221,14 @@ pub fn trans_lit_str<'a>(\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p(bcx.ccx()).to_ref());\n-                Store(bcx, llcstr,\n-                      GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-                Store(bcx, llbytes,\n-                      GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+                Store(bcx, llcstr, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n+                Store(bcx, llbytes, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n                 bcx\n             }\n         }\n     }\n }\n \n-\n pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n                              vstore_expr: &ast::Expr,\n                              content_expr: &ast::Expr)\n@@ -238,74 +242,47 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n-    // Handle \"\".to_string().\n-    match content_expr.node {\n-        ast::ExprLit(lit) => {\n-            match lit.node {\n-                ast::LitStr(ref s, _) => {\n-                    let llptrval = C_cstr(ccx, (*s).clone(), false);\n-                    let llptrval = PointerCast(bcx, llptrval, Type::i8p(ccx));\n-                    let llsizeval = C_uint(ccx, s.get().len());\n-                    let typ = ty::mk_uniq(bcx.tcx(), ty::mk_str(bcx.tcx()));\n-                    let lldestval = rvalue_scratch_datum(bcx,\n-                                                         typ,\n-                                                         \"\");\n-                    let alloc_fn = langcall(bcx,\n-                                            Some(lit.span),\n-                                            \"\",\n-                                            StrDupUniqFnLangItem);\n-                    let bcx = callee::trans_lang_call(\n-                        bcx,\n-                        alloc_fn,\n-                        [ llptrval, llsizeval ],\n-                        Some(expr::SaveIn(lldestval.val))).bcx;\n-                    return DatumBlock::new(bcx, lldestval).to_expr_datumblock();\n-                }\n-                _ => {}\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    let vec_ty = node_id_type(bcx, vstore_expr.id);\n-    let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n+    let vt = vec_types_from_expr(bcx, vstore_expr);\n     let count = elements_required(bcx, content_expr);\n+    debug!(\"    vt={}, count={:?}\", vt.to_str(ccx), count);\n+    let llcount = C_uint(ccx, count);\n+    let vec_ty = node_id_type(bcx, vstore_expr.id);\n \n-    let llunitty = type_of::type_of(ccx, vt.unit_ty);\n-    let unit_sz = nonzero_llsize_of(ccx, llunitty);\n-\n+    let unit_sz = nonzero_llsize_of(ccx, type_of::type_of(ccx, vt.unit_ty));\n     let fill = Mul(bcx, C_uint(ccx, count), unit_sz);\n-    let alloc = if count < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n-    else { fill };\n-\n-    let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n-\n-    // ~[T] is not going to be changed to support alignment, since it's obsolete.\n+    let alloc = if count < 4u {\n+        Mul(bcx, C_int(ccx, 4), unit_sz)\n+    } else {\n+        fill\n+    };\n+    let llty_ptr = type_of::type_of(ccx, vt.unit_ty).ptr_to();\n     let align = C_uint(ccx, 8);\n-    let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, vec_ty, vecsize, align);\n-    Store(bcx, fill, GEPi(bcx, val, [0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, val, [0u, abi::vec_elt_alloc]));\n+    let Result { bcx: bcx, val: dataptr } = malloc_raw_dyn(bcx,\n+                                                           llty_ptr,\n+                                                           vec_ty,\n+                                                           alloc,\n+                                                           align);\n \n     // Create a temporary scope lest execution should fail while\n     // constructing the vector.\n     let temp_scope = fcx.push_custom_cleanup_scope();\n-\n-    // FIXME: #13994: the old `Box<[T]> will not support sized deallocation, this is a placeholder\n-    let content_ty = vt.unit_ty;\n+    // FIXME: #13994: the old `Box<[T]> will not support sized deallocation,\n+    // this is a placeholder\n     fcx.schedule_free_value(cleanup::CustomScope(temp_scope),\n-                            val, cleanup::HeapExchange, content_ty);\n-\n-    let dataptr = get_dataptr(bcx, val);\n+                            dataptr, cleanup::HeapExchange, vt.unit_ty);\n \n-    debug!(\"alloc_uniq_vec() returned val={}, dataptr={}\",\n-           bcx.val_to_string(val), bcx.val_to_string(dataptr));\n+        debug!(\"    alloc_uniq_vec() returned dataptr={}, len={}\",\n+               bcx.val_to_str(dataptr), count);\n \n-    let bcx = write_content(bcx, &vt, vstore_expr,\n-                            content_expr, SaveIn(dataptr));\n+        let bcx = write_content(bcx, &vt, vstore_expr,\n+                                content_expr, SaveIn(dataptr));\n \n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    immediate_rvalue_bcx(bcx, val, vec_ty).to_expr_datumblock()\n+    let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n+    Store(bcx, dataptr, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n+    Store(bcx, llcount, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+    DatumBlock(bcx, scratch.to_expr_datum())\n }\n \n pub fn write_content<'a>(\n@@ -451,21 +428,19 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_fixed_base_and_byte_len(bcx: &Block,\n-                                   llval: ValueRef,\n-                                   unit_ty: ty::t,\n-                                   vec_length: uint)\n-                                   -> (ValueRef, ValueRef) {\n+pub fn get_fixed_base_and_len(bcx: &Block,\n+                              llval: ValueRef,\n+                              vec_length: uint)\n+                              -> (ValueRef, ValueRef) {\n     /*!\n      * Converts a fixed-length vector into the slice pair.\n      * The vector should be stored in `llval` which should be by ref.\n      */\n \n     let ccx = bcx.ccx();\n-    let vt = vec_types(bcx, unit_ty);\n \n-    let base = GEPi(bcx, llval, [0u, 0u]);\n-    let len = Mul(bcx, C_uint(ccx, vec_length), vt.llunit_size);\n+    let base = GEPi(bcx, llval, [0u, abi::slice_elt_base]);\n+    let len = C_uint(ccx, vec_length);\n     (base, len)\n }\n \n@@ -488,23 +463,13 @@ pub fn get_base_and_len(bcx: &Block,\n             let base = GEPi(bcx, llval, [0u, 0u]);\n             (base, C_uint(ccx, n))\n         }\n-        ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n-                assert!(!type_is_immediate(bcx.ccx(), vec_ty));\n                 let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-                let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n-                (base, count)\n+                let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+                (base, len)\n             }\n-            _ => ccx.sess().bug(\"unexpected type (ty_rptr) in get_base_and_len\"),\n-        },\n-        ty::ty_uniq(t) => match ty::get(t).sty {\n-            ty::ty_vec(_, None) | ty::ty_str => {\n-                assert!(type_is_immediate(bcx.ccx(), vec_ty));\n-                let vt = vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty));\n-                let body = Load(bcx, llval);\n-                (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n-            }\n-            _ => ccx.sess().bug(\"unexpected type (ty_uniq) in get_base_and_len\"),\n+            _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n         },\n         _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n     }\n@@ -576,13 +541,15 @@ pub fn iter_vec_raw<'r,\n                     bcx: &'b Block<'b>,\n                     data_ptr: ValueRef,\n                     unit_ty: ty::t,\n-                    fill: ValueRef,\n+                    len: ValueRef,\n                     f: iter_vec_block<'r,'b>)\n                     -> &'b Block<'b> {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n     let fcx = bcx.fcx;\n \n     let vt = vec_types(bcx, unit_ty);\n+    let fill = Mul(bcx, len, vt.llunit_size);\n+\n     if vt.llunit_alloc_size == 0 {\n         // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n         iter_vec_loop(bcx, data_ptr, &vt, fill, f)"}, {"sha": "99850fb93866b957ae1ebeebf04021549c8e0c5c", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -215,7 +215,7 @@ impl Type {\n \n     pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n         Type::struct_(ccx,\n-            [Type::int(ccx), Type::int(ccx), Type::array(ty, 0)],\n+            [Type::array(ty, 0), Type::int(ccx)],\n         false)\n     }\n "}, {"sha": "bc17824ca328a8c3855ae79d632fbab7077bd3be", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -169,14 +169,8 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_box(..) |\n         ty::ty_ptr(..) => Type::i8p(cx),\n-        ty::ty_uniq(ty) => {\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n             match ty::get(ty).sty {\n-                ty::ty_trait(..) => Type::opaque_trait(cx),\n-                _ => Type::i8p(cx),\n-            }\n-        }\n-        ty::ty_rptr(_, mt) => {\n-            match ty::get(mt.ty).sty {\n                 ty::ty_vec(_, None) | ty::ty_str => {\n                     Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n                 }\n@@ -283,17 +277,10 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n       }\n-      ty::ty_uniq(typ) => {\n-          match ty::get(typ).sty {\n-              ty::ty_vec(mt, None) => Type::vec(cx, &type_of(cx, mt.ty)).ptr_to(),\n-              ty::ty_str => Type::vec(cx, &Type::i8(cx)).ptr_to(),\n-              ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ => type_of(cx, typ).ptr_to(),\n-          }\n-      }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n-      ty::ty_rptr(_, ref mt) => {\n-          match ty::get(mt.ty).sty {\n+\n+      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+          match ty::get(ty).sty {\n               ty::ty_vec(mt, None) => {\n                   let p_ty = type_of(cx, mt.ty).ptr_to();\n                   let u_ty = Type::uint_from_ty(cx, ast::TyU);\n@@ -304,7 +291,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n                   cx.tn.find_type(\"str_slice\").unwrap()\n               }\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ => type_of(cx, mt.ty).ptr_to(),\n+              _ => type_of(cx, ty).ptr_to(),\n           }\n       }\n "}, {"sha": "c00c462afae30aef114db047b798f92904d40dae", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -1816,8 +1816,7 @@ pub fn type_is_boxed(ty: t) -> bool {\n pub fn type_is_region_ptr(ty: t) -> bool {\n     match get(ty).sty {\n         ty_rptr(_, mt) => match get(mt.ty).sty {\n-            // FIXME(nrc, DST) slices weren't regarded as rptrs, so we preserve this\n-            // odd behaviour for now. (But ~[] were unique. I have no idea why).\n+            // DST pointers should not be treated like regular pointers.\n             ty_vec(_, None) | ty_str | ty_trait(..) => false,\n             _ => true\n         },"}, {"sha": "015331b8be00e318475a4e8ceb3b1df53fa85a4e", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -23,11 +23,5 @@ pub static fn_field_box: uint = 1u;\n pub static trt_field_vtable: uint = 0u;\n pub static trt_field_box: uint = 1u;\n \n-pub static vec_elt_fill: uint = 0u;\n-\n-pub static vec_elt_alloc: uint = 1u;\n-\n-pub static vec_elt_elems: uint = 2u;\n-\n pub static slice_elt_base: uint = 0u;\n pub static slice_elt_len: uint = 1u;"}, {"sha": "a9cbacb07bee5d12fc3b6664a5e7b32cc2d97588", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -18,6 +18,7 @@ use std::path;\n use std::rc::Rc;\n use std::gc::{Gc, GC};\n use std::cell::{Cell, RefCell};\n+use std::strbuf::StrBuf;\n \n pub trait Encoder<E> {\n     // Primitive types:"}, {"sha": "9a56dd5c0e47b46fe04164028db7af850b57fca7", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -268,7 +268,19 @@ pub struct Tm {\n     pub tm_nsec: i32,\n }\n \n+impl Tm {\n+    pub fn tm_zone<'a>(&'a self) -> &'a str {\n+        self.tm_zone.as_slice()\n+    }\n+}\n+\n pub fn empty_tm() -> Tm {\n+    // 64 is the max size of the timezone buffer allocated on windows\n+    // in rust_localtime. In glibc the max timezone size is supposedly 3.\n+    let mut zone = StrBuf::new();\n+    for _ in range(0, 64) {\n+        zone.push_char(' ')\n+    }\n     Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n@@ -280,6 +292,7 @@ pub fn empty_tm() -> Tm {\n         tm_yday: 0_i32,\n         tm_isdst: 0_i32,\n         tm_gmtoff: 0_i32,\n+        tm_zone: zone,\n         tm_nsec: 0_i32,\n     }\n }\n@@ -760,6 +773,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n           'Z' => {\n             if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n                 tm.tm_gmtoff = 0_i32;\n+                tm.tm_zone = \"UTC\".into_strbuf();\n                 Ok(pos + 3u)\n             } else {\n                 // It's odd, but to maintain compatibility with c's\n@@ -784,6 +798,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n                         tm.tm_gmtoff = 0_i32;\n+                        tm.tm_zone = \"UTC\".into_strbuf();\n                     }\n \n                     Ok(pos)\n@@ -813,6 +828,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n         tm_yday: 0_i32,\n         tm_isdst: 0_i32,\n         tm_gmtoff: 0_i32,\n+        tm_zone: StrBuf::new(),\n         tm_nsec: 0_i32,\n     };\n     let mut pos = 0u;\n@@ -859,6 +875,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, String> {\n             tm_yday: tm.tm_yday,\n             tm_isdst: tm.tm_isdst,\n             tm_gmtoff: tm.tm_gmtoff,\n+            tm_zone: tm.tm_zone.clone(),\n             tm_nsec: tm.tm_nsec,\n         })\n     } else { result }\n@@ -1060,7 +1077,7 @@ pub fn strftime(format: &str, tm: &Tm) -> String {\n           'w' => (tm.tm_wday as int).to_string(),\n           'Y' => (tm.tm_year as int + 1900).to_string(),\n           'y' => format!(\"{:02d}\", (tm.tm_year as int + 1900) % 100),\n-          'Z' => \"\".to_string(),    // FIXME(pcwalton): Implement this.\n+          'Z' => tm.tm_zone.as_slice().to_owned(),\n           'z' => {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = num::abs(tm.tm_gmtoff) / 60_i32;\n@@ -1186,6 +1203,7 @@ mod tests {\n         assert_eq!(utc.tm_yday, 43_i32);\n         assert_eq!(utc.tm_isdst, 0_i32);\n         assert_eq!(utc.tm_gmtoff, 0_i32);\n+        assert_eq!(utc.tm_zone(), \"UTC\");\n         assert_eq!(utc.tm_nsec, 54321_i32);\n     }\n \n@@ -1207,6 +1225,12 @@ mod tests {\n         assert_eq!(local.tm_yday, 43_i32);\n         assert_eq!(local.tm_isdst, 0_i32);\n         assert_eq!(local.tm_gmtoff, -28800_i32);\n+\n+        // FIXME (#2350): We should probably standardize on the timezone\n+        // abbreviation.\n+        let zone = local.tm_zone();\n+        assert!(zone == \"PST\" || zone == \"Pacific Standard Time\");\n+\n         assert_eq!(local.tm_nsec, 54321_i32);\n     }\n \n@@ -1249,6 +1273,7 @@ mod tests {\n             assert!(tm.tm_wday == 0_i32);\n             assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n+            assert!(tm.tm_zone() == \"\");\n             assert!(tm.tm_nsec == 0_i32);\n           }\n           Err(_) => ()\n@@ -1272,6 +1297,7 @@ mod tests {\n             assert!(tm.tm_yday == 0_i32);\n             assert!(tm.tm_isdst == 0_i32);\n             assert!(tm.tm_gmtoff == 0_i32);\n+            assert!(tm.tm_zone() == \"\");\n             assert!(tm.tm_nsec == 12340000_i32);\n           }\n         }\n@@ -1383,10 +1409,10 @@ mod tests {\n         assert!(test(\"6\", \"%w\"));\n         assert!(test(\"2009\", \"%Y\"));\n         assert!(test(\"09\", \"%y\"));\n-        assert!(strptime(\"-0000\", \"%z\").unwrap().tm_gmtoff ==\n-            0);\n-        assert!(strptime(\"-0800\", \"%z\").unwrap().tm_gmtoff ==\n-            0);\n+        assert!(strptime(\"UTC\", \"%Z\").unwrap().tm_zone() == \"UTC\");\n+        assert!(strptime(\"PST\", \"%Z\").unwrap().tm_zone() == \"\");\n+        assert!(strptime(\"-0000\", \"%z\").unwrap().tm_gmtoff == 0);\n+        assert!(strptime(\"-0800\", \"%z\").unwrap().tm_gmtoff == 0);\n         assert!(test(\"%\", \"%%\"));\n \n         // Test for #7256"}, {"sha": "1a9b1c1c818b709190ac58176af7a959084af032", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=34d607f9c9e3c103fc7f98b4c6fa18ff71905bb6", "patch": "@@ -127,6 +127,15 @@ rust_list_dir_wfd_fp_buf(void* wfd) {\n }\n #endif\n \n+typedef struct\n+{\n+    size_t fill;    // in bytes; if zero, heapified\n+    size_t alloc;   // in bytes\n+    uint8_t *data;\n+} rust_vec;\n+\n+typedef rust_vec rust_str_buf;\n+\n typedef struct {\n     int32_t tm_sec;\n     int32_t tm_min;\n@@ -138,6 +147,7 @@ typedef struct {\n     int32_t tm_yday;\n     int32_t tm_isdst;\n     int32_t tm_gmtoff;\n+    rust_str_buf tm_zone;\n     int32_t tm_nsec;\n } rust_tm;\n \n@@ -154,10 +164,8 @@ void rust_tm_to_tm(rust_tm* in_tm, struct tm* out_tm) {\n     out_tm->tm_isdst = in_tm->tm_isdst;\n }\n \n-void tm_to_rust_tm(struct tm* in_tm,\n-                   rust_tm* out_tm,\n-                   int32_t gmtoff,\n-                   int32_t nsec) {\n+void tm_to_rust_tm(struct tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n+                   const char *zone, int32_t nsec) {\n     out_tm->tm_sec = in_tm->tm_sec;\n     out_tm->tm_min = in_tm->tm_min;\n     out_tm->tm_hour = in_tm->tm_hour;\n@@ -169,6 +177,13 @@ void tm_to_rust_tm(struct tm* in_tm,\n     out_tm->tm_isdst = in_tm->tm_isdst;\n     out_tm->tm_gmtoff = gmtoff;\n     out_tm->tm_nsec = nsec;\n+\n+    if (zone != NULL) {\n+        size_t size = strlen(zone);\n+        assert(out_tm->tm_zone.alloc >= size);\n+        memcpy(out_tm->tm_zone.data, zone, size);\n+        out_tm->tm_zone.fill = size;\n+    }\n }\n \n #if defined(__WIN32__)\n@@ -210,7 +225,7 @@ rust_gmtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n     time_t s = sec;\n     GMTIME(&s, &tm);\n \n-    tm_to_rust_tm(&tm, timeptr, 0, nsec);\n+    tm_to_rust_tm(&tm, timeptr, 0, \"UTC\", nsec);\n }\n \n void\n@@ -219,13 +234,28 @@ rust_localtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n     time_t s = sec;\n     LOCALTIME(&s, &tm);\n \n+    const char* zone = NULL;\n #if defined(__WIN32__)\n     int32_t gmtoff = -timezone;\n+    wchar_t wbuffer[64] = {0};\n+    char buffer[256] = {0};\n+    // strftime(\"%Z\") can contain non-UTF-8 characters on non-English locale (issue #9418),\n+    // so time zone should be converted from UTF-16 string.\n+    // Since wcsftime depends on setlocale() result,\n+    // instead we convert it using MultiByteToWideChar.\n+    if (strftime(buffer, sizeof(buffer) / sizeof(char), \"%Z\", &tm) > 0) {\n+        // ANSI -> UTF-16\n+        MultiByteToWideChar(CP_ACP, 0, buffer, -1, wbuffer, sizeof(wbuffer) / sizeof(wchar_t));\n+        // UTF-16 -> UTF-8\n+        WideCharToMultiByte(CP_UTF8, 0, wbuffer, -1, buffer, sizeof(buffer), NULL, NULL);\n+        zone = buffer;\n+    }\n #else\n     int32_t gmtoff = tm.tm_gmtoff;\n+    zone = tm.tm_zone;\n #endif\n \n-    tm_to_rust_tm(&tm, timeptr, gmtoff, nsec);\n+    tm_to_rust_tm(&tm, timeptr, gmtoff, zone, nsec);\n }\n \n int64_t"}]}