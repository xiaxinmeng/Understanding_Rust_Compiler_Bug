{"sha": "4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNGM2MWIyZDJiOTllMmFlMjBhYjVmY2Y3YzFjNTlhOWFjN2QyMjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-09T00:23:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-16T18:57:46Z"}, "message": "move the impl-params-constrained check out of collect\n\nThis helps with incr. comp. because otherwise the Collect(Impl) check\nwinds up touching all of the impl items; since Collect(Impl) also\nproduces the types for the impl header, this creates a polluted graph\nwhere the impl types depend on the impl items.", "tree": {"sha": "dd2a3ce3d41fa37fbca4215b5b0e5265c9d320fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd2a3ce3d41fa37fbca4215b5b0e5265c9d320fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "html_url": "https://github.com/rust-lang/rust/commit/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae8cb22fb9f2fa753963504b9c6a4d9e333840ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8cb22fb9f2fa753963504b9c6a4d9e333840ba", "html_url": "https://github.com/rust-lang/rust/commit/ae8cb22fb9f2fa753963504b9c6a4d9e333840ba"}], "stats": {"total": 271, "additions": 160, "deletions": 111}, "files": [{"sha": "f08d26373e50e979ef977f2c2346a77275eda918", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "patch": "@@ -18,6 +18,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "defdcc7906c3505d5fd9a7eee6fd8886b4558b27", "filename": "src/librustc_typeck/check/impl_parameters_used.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fcheck%2Fimpl_parameters_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fcheck%2Fimpl_parameters_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimpl_parameters_used.rs?ref=4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use constrained_type_params as ctp;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty;\n+use rustc::util::nodemap::FxHashSet;\n+\n+use syntax_pos::Span;\n+\n+use CrateCtxt;\n+\n+/// Checks that all the type/lifetime parameters on an impl also\n+/// appear in the trait ref or self-type (or are constrained by a\n+/// where-clause). These rules are needed to ensure that, given a\n+/// trait ref like `<T as Trait<U>>`, we can derive the values of all\n+/// parameters on the impl (which is needed to make specialization\n+/// possible).\n+///\n+/// However, in the case of lifetimes, we only enforce these rules if\n+/// the lifetime parameter is used in an associated type.  This is a\n+/// concession to backwards compatibility; see comment at the end of\n+/// the fn for details.\n+///\n+/// Example:\n+///\n+/// ```\n+/// impl<T> Trait<Foo> for Bar { ... }\n+///      ^ T does not appear in `Foo` or `Bar`, error!\n+///\n+/// impl<T> Trait<Foo<T>> for Bar { ... }\n+///      ^ T appears in `Foo<T>`, ok.\n+///\n+/// impl<T> Trait<Foo> for Bar where Bar: Iterator<Item=T> { ... }\n+///      ^ T is bound to `<Bar as Iterator>::Item`, ok.\n+///\n+/// impl<'a> Trait<Foo> for Bar { }\n+///      ^ 'a is unused, but for back-compat we allow it\n+///\n+/// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n+///      ^ 'a is unused and appears in assoc type, error\n+/// ```\n+pub fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                     impl_hir_generics: &hir::Generics,\n+                                                     impl_def_id: DefId,\n+                                                     impl_item_ids: &[hir::ImplItemId])\n+{\n+    // Every lifetime used in an associated type must be constrained.\n+    let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n+    let impl_predicates = ccx.tcx.lookup_predicates(impl_def_id);\n+    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n+\n+    let mut input_parameters = ctp::parameters_for_impl(impl_scheme.ty, impl_trait_ref);\n+    ctp::identify_constrained_type_params(\n+        &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n+\n+    // Disallow ANY unconstrained type parameters.\n+    for (ty_param, param) in impl_scheme.generics.types.iter().zip(&impl_hir_generics.ty_params) {\n+        let param_ty = ty::ParamTy::for_def(ty_param);\n+        if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n+            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n+        }\n+    }\n+\n+    // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n+    let lifetimes_in_associated_types: FxHashSet<_> = impl_item_ids.iter()\n+        .map(|item_id|  ccx.tcx.map.local_def_id(item_id.id))\n+        .filter(|&def_id| {\n+            let item = ccx.tcx.associated_item(def_id);\n+            item.kind == ty::AssociatedKind::Type && item.has_value\n+        })\n+        .flat_map(|def_id| {\n+            ctp::parameters_for(&ccx.tcx.lookup_item_type(def_id).ty, true)\n+        }).collect();\n+    for (ty_lifetime, lifetime) in impl_scheme.generics.regions.iter()\n+        .zip(&impl_hir_generics.lifetimes)\n+    {\n+        let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());\n+\n+        if\n+            lifetimes_in_associated_types.contains(&param) && // (*)\n+            !input_parameters.contains(&param)\n+        {\n+            report_unused_parameter(ccx, lifetime.lifetime.span,\n+                                    \"lifetime\", &lifetime.lifetime.name.to_string());\n+        }\n+    }\n+\n+    // (*) This is a horrible concession to reality. I think it'd be\n+    // better to just ban unconstrianed lifetimes outright, but in\n+    // practice people do non-hygenic macros like:\n+    //\n+    // ```\n+    // macro_rules! __impl_slice_eq1 {\n+    //     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+    //         impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+    //            ....\n+    //         }\n+    //     }\n+    // }\n+    // ```\n+    //\n+    // In a concession to backwards compatbility, we continue to\n+    // permit those, so long as the lifetimes aren't used in\n+    // associated types. I believe this is sound, because lifetimes\n+    // used elsewhere are not projected back out.\n+}\n+\n+fn report_unused_parameter(ccx: &CrateCtxt,\n+                           span: Span,\n+                           kind: &str,\n+                           name: &str)\n+{\n+    struct_span_err!(\n+        ccx.tcx.sess, span, E0207,\n+        \"the {} parameter `{}` is not constrained by the \\\n+        impl trait, self type, or predicates\",\n+        kind, name)\n+        .span_label(span, &format!(\"unconstrained {} parameter\", kind))\n+        .emit();\n+}"}, {"sha": "12a1cc8279fde9a11a6be38577cf54dd9c1695c7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "patch": "@@ -143,6 +143,7 @@ mod closure;\n mod callee;\n mod compare_method;\n mod intrinsic;\n+mod impl_parameters_used;\n mod op;\n \n /// closures defined within the function.  For example:\n@@ -815,7 +816,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                             it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n-      hir::ItemImpl(.., ref impl_item_ids) => {\n+      hir::ItemImpl(_, _, ref hir_generics, _, _, ref impl_item_ids) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n@@ -827,6 +828,12 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n               let trait_def_id = impl_trait_ref.def_id;\n               check_on_unimplemented(ccx, trait_def_id, it);\n           }\n+\n+          impl_parameters_used::enforce_impl_params_are_constrained(ccx,\n+                                                                    hir_generics,\n+                                                                    impl_def_id,\n+                                                                    impl_item_ids);\n+\n       }\n       hir::ItemTrait(..) => {\n         let def_id = ccx.tcx.map.local_def_id(it.id);"}, {"sha": "e7873d2f81882037a71eda04e3e4d13b4f0344da", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 110, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "patch": "@@ -753,7 +753,15 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             });\n             tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n-            enforce_impl_params_are_constrained(ccx, generics, &mut ty_predicates, def_id);\n+            // Subtle: before we store the predicates into the tcx, we\n+            // sort them so that predicates like `T: Foo<Item=U>` come\n+            // before uses of `U`.  This avoids false ambiguity errors\n+            // in trait checking. See `setup_constraining_predicates`\n+            // for details.\n+            ctp::setup_constraining_predicates(&mut ty_predicates.predicates,\n+                                               trait_ref,\n+                                               &mut ctp::parameters_for_impl(selfty, trait_ref));\n+\n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n \n \n@@ -788,8 +796,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             for &impl_item_id in impl_item_ids {\n                 convert_impl_item(ccx, impl_item_id);\n             }\n-\n-            enforce_impl_lifetimes_are_constrained(ccx, generics, def_id, impl_item_ids);\n         },\n         hir::ItemTrait(.., ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -2084,110 +2090,3 @@ pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                      |def, _| tcx.mk_region(def.to_early_bound_region()),\n                      |def, _| tcx.mk_param_from_def(def))\n }\n-\n-/// Checks that all the type parameters on an impl\n-fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                 generics: &hir::Generics,\n-                                                 impl_predicates: &mut ty::GenericPredicates<'tcx>,\n-                                                 impl_def_id: DefId)\n-{\n-    let impl_ty = ccx.tcx.item_type(impl_def_id);\n-    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n-\n-    // The trait reference is an input, so find all type parameters\n-    // reachable from there, to start (if this is an inherent impl,\n-    // then just examine the self type).\n-    let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n-    if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for(trait_ref, false));\n-    }\n-\n-    ctp::setup_constraining_predicates(&mut impl_predicates.predicates,\n-                                       impl_trait_ref,\n-                                       &mut input_parameters);\n-\n-    let ty_generics = generics_of_def_id(ccx, impl_def_id);\n-    for (ty_param, param) in ty_generics.types.iter().zip(&generics.ty_params) {\n-        let param_ty = ty::ParamTy::for_def(ty_param);\n-        if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n-            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n-        }\n-    }\n-}\n-\n-fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                    ast_generics: &hir::Generics,\n-                                                    impl_def_id: DefId,\n-                                                    impl_item_ids: &[hir::ImplItemId])\n-{\n-    // Every lifetime used in an associated type must be constrained.\n-    let impl_ty = ccx.tcx.item_type(impl_def_id);\n-    let impl_predicates = ccx.tcx.item_predicates(impl_def_id);\n-    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n-\n-    let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n-    if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for(trait_ref, false));\n-    }\n-    ctp::identify_constrained_type_params(\n-        &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n-\n-    let lifetimes_in_associated_types: FxHashSet<_> = impl_item_ids.iter()\n-        .map(|item_id|  ccx.tcx.map.local_def_id(item_id.id))\n-        .filter(|&def_id| {\n-            let item = ccx.tcx.associated_item(def_id);\n-            item.kind == ty::AssociatedKind::Type && item.has_value\n-        })\n-        .flat_map(|def_id| {\n-            ctp::parameters_for(&ccx.tcx.item_type(def_id), true)\n-        }).collect();\n-\n-    for (ty_lifetime, lifetime) in ccx.tcx.item_generics(impl_def_id).regions.iter()\n-        .zip(&ast_generics.lifetimes)\n-    {\n-        let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());\n-\n-        if\n-            lifetimes_in_associated_types.contains(&param) && // (*)\n-            !input_parameters.contains(&param)\n-        {\n-            report_unused_parameter(ccx, lifetime.lifetime.span,\n-                                    \"lifetime\", &lifetime.lifetime.name.to_string());\n-        }\n-    }\n-\n-    // (*) This is a horrible concession to reality. I think it'd be\n-    // better to just ban unconstrianed lifetimes outright, but in\n-    // practice people do non-hygenic macros like:\n-    //\n-    // ```\n-    // macro_rules! __impl_slice_eq1 {\n-    //     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-    //         impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-    //            ....\n-    //         }\n-    //     }\n-    // }\n-    // ```\n-    //\n-    // In a concession to backwards compatbility, we continue to\n-    // permit those, so long as the lifetimes aren't used in\n-    // associated types. I believe this is sound, because lifetimes\n-    // used elsewhere are not projected back out.\n-}\n-\n-fn report_unused_parameter(ccx: &CrateCtxt,\n-                           span: Span,\n-                           kind: &str,\n-                           name: &str)\n-{\n-    struct_span_err!(\n-        ccx.tcx.sess, span, E0207,\n-        \"the {} parameter `{}` is not constrained by the \\\n-        impl trait, self type, or predicates\",\n-        kind, name)\n-        .span_label(span, &format!(\"unconstrained {} parameter\", kind))\n-        .emit();\n-}"}, {"sha": "22be4491273ef751ecdfd351bef02aa3e317ed80", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "patch": "@@ -23,6 +23,18 @@ impl From<ty::EarlyBoundRegion> for Parameter {\n     fn from(param: ty::EarlyBoundRegion) -> Self { Parameter(param.index) }\n }\n \n+/// Return the set of parameters constrained by the impl header.\n+pub fn parameters_for_impl<'tcx>(impl_self_ty: Ty<'tcx>,\n+                                 impl_trait_ref: Option<ty::TraitRef<'tcx>>)\n+                                 -> FxHashSet<Parameter>\n+{\n+    let vec = match impl_trait_ref {\n+        Some(tr) => parameters_for(&tr, false),\n+        None => parameters_for(&impl_self_ty, false),\n+    };\n+    vec.into_iter().collect()\n+}\n+\n /// If `include_projections` is false, returns the list of parameters that are\n /// constrained by `t` - i.e. the value of each parameter in the list is\n /// uniquely determined by `t` (see RFC 447). If it is true, return the list"}, {"sha": "222e60bb054548df134c512d2d2789c87aeb880d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=4a4c61b2d2b99e2ae20ab5fcf7c1c59a9ac7d226", "patch": "@@ -95,6 +95,7 @@ extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n+extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n \n pub use rustc::dep_graph;"}]}