{"sha": "4fa55787745ac71793253c47c4d6cd5ffe96b741", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYTU1Nzg3NzQ1YWM3MTc5MzI1M2M0N2M0ZDZjZDVmZmU5NmI3NDE=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-10-15T09:44:00Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-10-15T10:02:24Z"}, "message": "Replace target.target with target and target.ptr_width with target.pointer_width\n\nPreparation for a subsequent change that replaces\nrustc_target::config::Config with its wrapped Target.\n\nOn its own, this commit breaks the build. I don't like making\nbuild-breaking commits, but in this instance I believe that it\nmakes review easier, as the \"real\" changes of this PR can be\nseen much more easily.\n\nResult of running:\n\nfind compiler/ -type f -exec sed -i -e 's/target\\.target\\([)\\.,; ]\\)/target\\1/g' {} \\;\nfind compiler/ -type f -exec sed -i -e 's/target\\.target$/target/g' {} \\;\nfind compiler/ -type f -exec sed -i -e 's/target.ptr_width/target.pointer_width/g' {} \\;\n./x.py fmt", "tree": {"sha": "46a7cad18bbfa0e1e87e39d1e80dcdfd04049f13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46a7cad18bbfa0e1e87e39d1e80dcdfd04049f13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fa55787745ac71793253c47c4d6cd5ffe96b741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa55787745ac71793253c47c4d6cd5ffe96b741", "html_url": "https://github.com/rust-lang/rust/commit/4fa55787745ac71793253c47c4d6cd5ffe96b741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fa55787745ac71793253c47c4d6cd5ffe96b741/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d1aa1e0346630189b779da0939e8138a8e6d668", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1aa1e0346630189b779da0939e8138a8e6d668", "html_url": "https://github.com/rust-lang/rust/commit/0d1aa1e0346630189b779da0939e8138a8e6d668"}], "stats": {"total": 464, "additions": 224, "deletions": 240}, "files": [{"sha": "2d2caa7a808d7cdc9ce63fab17c7d8067a0079f1", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -985,7 +985,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             asm::InlineAsmReg::parse(\n                                 sess.asm_arch?,\n                                 |feature| sess.target_features.contains(&Symbol::intern(feature)),\n-                                &sess.target.target,\n+                                &sess.target,\n                                 s,\n                             )\n                             .map_err(|e| {"}, {"sha": "d9791fe743cdeeaedcf9af39a53dc24077f0ae12", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -796,7 +796,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match &expr.kind {\n-            ExprKind::LlvmInlineAsm(..) if !self.session.target.target.options.allow_asm => {\n+            ExprKind::LlvmInlineAsm(..) if !self.session.target.options.allow_asm => {\n                 struct_span_err!(\n                     self.session,\n                     expr.span,"}, {"sha": "da74f0aeaa193b54cc287a7b0d40a788719879fd", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -37,7 +37,7 @@ struct TestCtxt<'a> {\n pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n     let span_diagnostic = sess.diagnostic();\n     let panic_strategy = sess.panic_strategy();\n-    let platform_panic_strategy = sess.target.target.options.panic_strategy;\n+    let platform_panic_strategy = sess.target.options.panic_strategy;\n \n     // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n     // main test function the name `some_name` without hygiene. This needs to be"}, {"sha": "d02bc41f4af3bc535485afeca5ca31272442b313", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -16,7 +16,7 @@ pub(crate) unsafe fn codegen(\n ) {\n     let llcx = &*mods.llcx;\n     let llmod = mods.llmod();\n-    let usize = match tcx.sess.target.target.pointer_width {\n+    let usize = match tcx.sess.target.pointer_width {\n         16 => llvm::LLVMInt16TypeInContext(llcx),\n         32 => llvm::LLVMInt32TypeInContext(llcx),\n         64 => llvm::LLVMInt64TypeInContext(llcx),\n@@ -57,7 +57,7 @@ pub(crate) unsafe fn codegen(\n         let name = format!(\"__rust_{}\", method.name);\n         let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n \n-        if tcx.sess.target.target.options.default_hidden_visibility {\n+        if tcx.sess.target.options.default_hidden_visibility {\n             llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n@@ -98,7 +98,7 @@ pub(crate) unsafe fn codegen(\n     // -> ! DIFlagNoReturn\n     llvm::Attribute::NoReturn.apply_llfn(llvm::AttributePlace::Function, llfn);\n \n-    if tcx.sess.target.target.options.default_hidden_visibility {\n+    if tcx.sess.target.options.default_hidden_visibility {\n         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n     }\n     if tcx.sess.must_emit_unwind_tables() {"}, {"sha": "b096664bc74c6a4a4d40fe1a139b2c39d547d08e", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -60,7 +60,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n         // Default per-arch clobbers\n         // Basically what clang does\n-        let arch_clobbers = match &self.sess().target.target.arch[..] {\n+        let arch_clobbers = match &self.sess().target.arch[..] {\n             \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n             \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n             _ => Vec::new(),"}, {"sha": "b8ee3b4734fb23e02fdf674648e2ddbd970eac65", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -31,7 +31,7 @@ fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n         Hint => Attribute::InlineHint.apply_llfn(Function, val),\n         Always => Attribute::AlwaysInline.apply_llfn(Function, val),\n         Never => {\n-            if cx.tcx().sess.target.target.arch != \"amdgpu\" {\n+            if cx.tcx().sess.target.arch != \"amdgpu\" {\n                 Attribute::NoInline.apply_llfn(Function, val);\n             }\n         }\n@@ -91,8 +91,7 @@ fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n         // The function name varies on platforms.\n         // See test/CodeGen/mcount.c in clang.\n         let mcount_name =\n-            CString::new(cx.sess().target.target.options.target_mcount.as_str().as_bytes())\n-                .unwrap();\n+            CString::new(cx.sess().target.options.target_mcount.as_str().as_bytes()).unwrap();\n \n         llvm::AddFunctionAttrStringValue(\n             llfn,\n@@ -106,7 +105,7 @@ fn set_instrument_function(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Only use stack probes if the target specification indicates that we\n     // should be using stack probes\n-    if !cx.sess().target.target.options.stack_probes {\n+    if !cx.sess().target.options.stack_probes {\n         return;\n     }\n \n@@ -345,7 +344,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     // Note that currently the `wasm-import-module` doesn't do anything, but\n     // eventually LLVM 7 should read this and ferry the appropriate import\n     // module to the output file.\n-    if cx.tcx.sess.target.target.arch == \"wasm32\" {\n+    if cx.tcx.sess.target.arch == \"wasm32\" {\n         if let Some(module) = wasm_import_module(cx.tcx, instance.def_id()) {\n             llvm::AddFunctionAttrStringValue(\n                 llfn,"}, {"sha": "595655b2ca26fffbc78796e23f210529a2b87df7", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -206,7 +206,7 @@ impl<'a> LlvmArchiveBuilder<'a> {\n     }\n \n     fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n-        let kind = &*self.config.sess.target.target.options.archive_format;\n+        let kind = &*self.config.sess.target.options.archive_format;\n         kind.parse().map_err(|_| kind)\n     }\n "}, {"sha": "ea1a7cfa5d3b5325c88cced137a02431d9344ce8", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -128,40 +128,40 @@ pub fn target_machine_factory(\n     let (opt_level, _) = to_llvm_opt_settings(optlvl);\n     let use_softfp = sess.opts.cg.soft_float;\n \n-    let ffunction_sections = sess.target.target.options.function_sections;\n+    let ffunction_sections = sess.target.options.function_sections;\n     let fdata_sections = ffunction_sections;\n \n     let code_model = to_llvm_code_model(sess.code_model());\n \n     let features = attributes::llvm_target_features(sess).collect::<Vec<_>>();\n-    let mut singlethread = sess.target.target.options.singlethread;\n+    let mut singlethread = sess.target.options.singlethread;\n \n     // On the wasm target once the `atomics` feature is enabled that means that\n     // we're no longer single-threaded, or otherwise we don't want LLVM to\n     // lower atomic operations to single-threaded operations.\n     if singlethread\n-        && sess.target.target.llvm_target.contains(\"wasm32\")\n+        && sess.target.llvm_target.contains(\"wasm32\")\n         && sess.target_features.contains(&sym::atomics)\n     {\n         singlethread = false;\n     }\n \n-    let triple = SmallCStr::new(&sess.target.target.llvm_target);\n+    let triple = SmallCStr::new(&sess.target.llvm_target);\n     let cpu = SmallCStr::new(llvm_util::target_cpu(sess));\n     let features = features.join(\",\");\n     let features = CString::new(features).unwrap();\n-    let abi = SmallCStr::new(&sess.target.target.options.llvm_abiname);\n-    let trap_unreachable = sess.target.target.options.trap_unreachable;\n+    let abi = SmallCStr::new(&sess.target.options.llvm_abiname);\n+    let trap_unreachable = sess.target.options.trap_unreachable;\n     let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n \n     let asm_comments = sess.asm_comments();\n-    let relax_elf_relocations = sess.target.target.options.relax_elf_relocations;\n+    let relax_elf_relocations = sess.target.options.relax_elf_relocations;\n \n     let use_init_array = !sess\n         .opts\n         .debugging_opts\n         .use_ctors_section\n-        .unwrap_or(sess.target.target.options.use_ctors_section);\n+        .unwrap_or(sess.target.options.use_ctors_section);\n \n     Arc::new(move || {\n         let tm = unsafe {"}, {"sha": "1090d4a25c7cfd634c2e11bc92326b47189e5c3c", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -60,7 +60,7 @@ pub fn write_compressed_metadata<'tcx>(\n         unsafe { llvm::LLVMAddGlobal(metadata_llmod, common::val_ty(llconst), buf.as_ptr()) };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let section_name = metadata::metadata_section_name(&tcx.sess.target.target);\n+        let section_name = metadata::metadata_section_name(&tcx.sess.target);\n         let name = SmallCStr::new(section_name);\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n "}, {"sha": "174620ea2fa15962c9fbf651dccedfaa6e86b5e5", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -308,8 +308,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         use rustc_middle::ty::{Int, Uint};\n \n         let new_kind = match ty.kind() {\n-            Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.ptr_width)),\n-            Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.ptr_width)),\n+            Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),\n+            Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.pointer_width)),\n             t @ (Uint(_) | Int(_)) => t.clone(),\n             _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n         };\n@@ -541,7 +541,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn range_metadata(&mut self, load: &'ll Value, range: Range<u128>) {\n-        if self.sess().target.target.arch == \"amdgpu\" {\n+        if self.sess().target.arch == \"amdgpu\" {\n             // amdgpu/LLVM does something weird and thinks a i64 value is\n             // split into a v2i32, halving the bitwidth LLVM expects,\n             // tripping an assertion. So, for now, just disable this\n@@ -671,7 +671,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // WebAssembly has saturating floating point to integer casts if the\n         // `nontrapping-fptoint` target feature is activated. We'll use those if\n         // they are available.\n-        if self.sess().target.target.arch == \"wasm32\"\n+        if self.sess().target.arch == \"wasm32\"\n             && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n         {\n             let src_ty = self.cx.val_ty(val);\n@@ -696,7 +696,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // WebAssembly has saturating floating point to integer casts if the\n         // `nontrapping-fptoint` target feature is activated. We'll use those if\n         // they are available.\n-        if self.sess().target.target.arch == \"wasm32\"\n+        if self.sess().target.arch == \"wasm32\"\n             && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n         {\n             let src_ty = self.cx.val_ty(val);\n@@ -1427,7 +1427,7 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n-        self.sess().target.target.arch == \"wasm32\"\n+        self.sess().target.arch == \"wasm32\"\n             && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n     }\n }"}, {"sha": "e2003472d1263086807ddd6a1f4a2ba39efb51a3", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -176,7 +176,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n         // should use dllimport for functions.\n         if cx.use_dll_storage_attrs\n             && tcx.is_dllimport_foreign_item(instance_def_id)\n-            && tcx.sess.target.target.target_env != \"gnu\"\n+            && tcx.sess.target.target_env != \"gnu\"\n         {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);"}, {"sha": "b57a23328b66391935c6fe4c91547be15241b3b1", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -92,7 +92,7 @@ fn set_global_alignment(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Alig\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n     // which can force it to be smaller.  Rust doesn't support this yet.\n-    if let Some(min) = cx.sess().target.target.options.min_global_align {\n+    if let Some(min) = cx.sess().target.options.min_global_align {\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n@@ -283,7 +283,7 @@ impl CodegenCx<'ll, 'tcx> {\n             // argument validation.\n             debug_assert!(\n                 !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                    && self.tcx.sess.target.target.options.is_like_windows\n+                    && self.tcx.sess.target.options.is_like_windows\n                     && self.tcx.sess.opts.cg.prefer_dynamic)\n             );\n \n@@ -437,7 +437,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 // will use load-unaligned instructions instead, and thus avoiding the crash.\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n-                if self.tcx.sess.target.target.options.is_like_osx {\n+                if self.tcx.sess.target.options.is_like_osx {\n                     // The `inspect` method is okay here because we checked relocations, and\n                     // because we are doing this access to inspect the final interpreter state\n                     // (not as part of the interpreter execution)."}, {"sha": "150cedde7e833f2808d8185bf57434b8f5839319", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -118,18 +118,18 @@ pub unsafe fn create_module(\n     let mod_name = SmallCStr::new(mod_name);\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n-    let mut target_data_layout = sess.target.target.data_layout.clone();\n+    let mut target_data_layout = sess.target.data_layout.clone();\n     if llvm_util::get_major_version() < 9 {\n         target_data_layout = strip_function_ptr_alignment(target_data_layout);\n     }\n     if llvm_util::get_major_version() < 10 {\n-        if sess.target.target.arch == \"x86\" || sess.target.target.arch == \"x86_64\" {\n+        if sess.target.arch == \"x86\" || sess.target.arch == \"x86_64\" {\n             target_data_layout = strip_x86_address_spaces(target_data_layout);\n         }\n     }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n-    if sess.target.target.options.is_builtin {\n+    if sess.target.options.is_builtin {\n         let tm = crate::back::write::create_informational_target_machine(tcx.sess);\n         llvm::LLVMRustSetDataLayoutFromTargetMachine(llmod, tm);\n         llvm::LLVMRustDisposeTargetMachine(tm);\n@@ -160,7 +160,7 @@ pub unsafe fn create_module(\n             bug!(\n                 \"data-layout for builtin `{}` target, `{}`, \\\n                   differs from LLVM default, `{}`\",\n-                sess.target.target.llvm_target,\n+                sess.target.llvm_target,\n                 target_data_layout,\n                 llvm_data_layout\n             );\n@@ -170,7 +170,7 @@ pub unsafe fn create_module(\n     let data_layout = SmallCStr::new(&target_data_layout);\n     llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n \n-    let llvm_target = SmallCStr::new(&sess.target.target.llvm_target);\n+    let llvm_target = SmallCStr::new(&sess.target.llvm_target);\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n \n     if sess.relocation_model() == RelocModel::Pic {\n@@ -190,7 +190,7 @@ pub unsafe fn create_module(\n     }\n \n     // Control Flow Guard is currently only supported by the MSVC linker on Windows.\n-    if sess.target.target.options.is_like_msvc {\n+    if sess.target.options.is_like_msvc {\n         match sess.opts.cg.control_flow_guard {\n             CFGuard::Disabled => {}\n             CFGuard::NoChecks => {\n@@ -265,7 +265,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         // linker will take care of everything. Fixing this problem will likely\n         // require adding a few attributes to Rust itself (feature gated at the\n         // start) and then strongly recommending static linkage on Windows!\n-        let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_windows;\n+        let use_dll_storage_attrs = tcx.sess.target.options.is_like_windows;\n \n         let check_overflow = tcx.sess.overflow_checks();\n \n@@ -839,7 +839,7 @@ impl CodegenCx<'b, 'tcx> {\n             return eh_catch_typeinfo;\n         }\n         let tcx = self.tcx;\n-        assert!(self.sess().target.target.options.is_like_emscripten);\n+        assert!(self.sess().target.options.is_like_emscripten);\n         let eh_catch_typeinfo = match tcx.lang_items().eh_catch_typeinfo() {\n             Some(def_id) => self.get_static(def_id),\n             _ => {\n@@ -878,7 +878,7 @@ impl HasDataLayout for CodegenCx<'ll, 'tcx> {\n \n impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n     fn target_spec(&self) -> &Target {\n-        &self.tcx.sess.target.target\n+        &self.tcx.sess.target\n     }\n }\n "}, {"sha": "79721ff7e2d2b10724af97f06f27955090c8825d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -67,5 +67,5 @@ pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n \n     !omit_gdb_pretty_printer_section\n         && cx.sess().opts.debuginfo != DebugInfo::None\n-        && cx.sess().target.target.options.emit_debug_gdb_scripts\n+        && cx.sess().target.options.emit_debug_gdb_scripts\n }"}, {"sha": "5587e6ead1dbb3866bc4223a3487c996fb0906aa", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -874,7 +874,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n \n     // When targeting MSVC, emit MSVC style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let msvc_like_names = cx.tcx.sess.target.target.options.is_like_msvc;\n+    let msvc_like_names = cx.tcx.sess.target.options.is_like_msvc;\n \n     let (name, encoding) = match t.kind() {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n@@ -985,7 +985,7 @@ pub fn compile_unit_metadata(\n     // if multiple object files with the same `DW_AT_name` are linked together.\n     // As a workaround we generate unique names for each object file. Those do\n     // not correspond to an actual source file but that should be harmless.\n-    if tcx.sess.target.target.options.is_like_osx {\n+    if tcx.sess.target.options.is_like_osx {\n         name_in_debuginfo.push(\"@\");\n         name_in_debuginfo.push(codegen_unit_name);\n     }\n@@ -1401,7 +1401,7 @@ fn prepare_union_metadata(\n /// on MSVC we have to use the fallback mode, because LLVM doesn't\n /// lower variant parts to PDB.\n fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n-    cx.sess().target.target.options.is_like_msvc\n+    cx.sess().target.options.is_like_msvc\n }\n \n // FIXME(eddyb) maybe precompute this? Right now it's computed once"}, {"sha": "80e0e7bf2e06cb89af47aa139c57d121cb3f9ebb", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -120,12 +120,12 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n         // for macOS to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n         // Android has the same issue (#22398)\n-        if let Some(version) = cx.sess().target.target.options.dwarf_version {\n+        if let Some(version) = cx.sess().target.options.dwarf_version {\n             llvm::LLVMRustAddModuleFlag(cx.llmod, \"Dwarf Version\\0\".as_ptr().cast(), version)\n         }\n \n         // Indicate that we want CodeView debug information on MSVC\n-        if cx.sess().target.target.options.is_like_msvc {\n+        if cx.sess().target.options.is_like_msvc {\n             llvm::LLVMRustAddModuleFlag(cx.llmod, \"CodeView\\0\".as_ptr().cast(), 1)\n         }\n \n@@ -346,7 +346,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             });\n \n             // Arguments types\n-            if cx.sess().target.target.options.is_like_msvc {\n+            if cx.sess().target.options.is_like_msvc {\n                 // FIXME(#42800):\n                 // There is a bug in MSDIA that leads to a crash when it encounters\n                 // a fixed-size array of `u8` or something zero-sized in a"}, {"sha": "517246cd0b24b8a3a641bab86cb95f8b125ef51f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -38,7 +38,7 @@ impl CodegenCx<'ll, '_> {\n         // For MSVC, omit the column number.\n         // Otherwise, emit it. This mimics clang behaviour.\n         // See discussion in https://github.com/rust-lang/rust/issues/42921\n-        if self.sess().target.target.options.is_like_msvc {\n+        if self.sess().target.options.is_like_msvc {\n             DebugLoc { file, line, col: None }\n         } else {\n             DebugLoc { file, line, col }"}, {"sha": "9face7783224e35ff1eec752602d1972350ba5f6", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -42,7 +42,7 @@ fn declare_raw_fn(\n     // be merged.\n     llvm::SetUnnamedAddress(llfn, llvm::UnnamedAddr::Global);\n \n-    if cx.tcx.sess.opts.cg.no_redzone.unwrap_or(cx.tcx.sess.target.target.options.disable_redzone) {\n+    if cx.tcx.sess.opts.cg.no_redzone.unwrap_or(cx.tcx.sess.target.options.disable_redzone) {\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "8379fe472251f04939512aa2d2053ab10eb7af4b", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -367,7 +367,7 @@ fn try_intrinsic(\n         bx.store(bx.const_i32(0), dest, ret_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, try_func, data, catch_func, dest);\n-    } else if bx.sess().target.target.options.is_like_emscripten {\n+    } else if bx.sess().target.options.is_like_emscripten {\n         codegen_emcc_try(bx, try_func, data, catch_func, dest);\n     } else {\n         codegen_gnu_try(bx, try_func, data, catch_func, dest);\n@@ -1722,10 +1722,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n     match ty.kind() {\n         ty::Int(t) => {\n-            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), true))\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.pointer_width)), true))\n         }\n         ty::Uint(t) => {\n-            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), false))\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.pointer_width)), false))\n         }\n         _ => None,\n     }"}, {"sha": "9c1e1b8fac06f304e0fcfc0865375013de8091dc", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -46,7 +46,7 @@ fn require_inited() {\n }\n \n unsafe fn configure_llvm(sess: &Session) {\n-    let n_args = sess.opts.cg.llvm_args.len() + sess.target.target.options.llvm_args.len();\n+    let n_args = sess.opts.cg.llvm_args.len() + sess.target.options.llvm_args.len();\n     let mut llvm_c_strs = Vec::with_capacity(n_args + 1);\n     let mut llvm_args = Vec::with_capacity(n_args + 1);\n \n@@ -57,7 +57,7 @@ unsafe fn configure_llvm(sess: &Session) {\n     }\n \n     let cg_opts = sess.opts.cg.llvm_args.iter();\n-    let tg_opts = sess.target.target.options.llvm_args.iter();\n+    let tg_opts = sess.target.options.llvm_args.iter();\n     let sess_args = cg_opts.chain(tg_opts);\n \n     let user_specified_args: FxHashSet<_> =\n@@ -88,17 +88,15 @@ unsafe fn configure_llvm(sess: &Session) {\n             .opts\n             .debugging_opts\n             .merge_functions\n-            .unwrap_or(sess.target.target.options.merge_functions)\n+            .unwrap_or(sess.target.options.merge_functions)\n         {\n             MergeFunctions::Disabled | MergeFunctions::Trampolines => {}\n             MergeFunctions::Aliases => {\n                 add(\"-mergefunc-use-aliases\", false);\n             }\n         }\n \n-        if sess.target.target.target_os == \"emscripten\"\n-            && sess.panic_strategy() == PanicStrategy::Unwind\n-        {\n+        if sess.target.target_os == \"emscripten\" && sess.panic_strategy() == PanicStrategy::Unwind {\n             add(\"-enable-emscripten-cxx-exceptions\", false);\n         }\n \n@@ -140,7 +138,7 @@ pub fn time_trace_profiler_finish(file_name: &str) {\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n-    let arch = if sess.target.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.target.arch };\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n     match (arch, s) {\n         (\"x86\", \"pclmulqdq\") => \"pclmul\",\n         (\"x86\", \"rdrand\") => \"rdrnd\",\n@@ -217,7 +215,7 @@ fn handle_native(name: &str) -> &str {\n pub fn target_cpu(sess: &Session) -> &str {\n     let name = match sess.opts.cg.target_cpu {\n         Some(ref s) => &**s,\n-        None => &*sess.target.target.options.cpu,\n+        None => &*sess.target.options.cpu,\n     };\n \n     handle_native(name)"}, {"sha": "5f820f83a9438976c9ce9a0fcb47f66829b915ff", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -52,7 +52,7 @@ fn emit_direct_ptr_va_arg(\n     let next = bx.inbounds_gep(addr, &[full_direct_size]);\n     bx.store(next, va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n \n-    if size.bytes() < slot_size.bytes() && &*bx.tcx().sess.target.target.target_endian == \"big\" {\n+    if size.bytes() < slot_size.bytes() && &*bx.tcx().sess.target.target_endian == \"big\" {\n         let adjusted_size = bx.cx().const_i32((slot_size.bytes() - size.bytes()) as i32);\n         let adjusted = bx.inbounds_gep(addr, &[adjusted_size]);\n         (bx.bitcast(adjusted, bx.cx().type_ptr_to(llty)), addr_align)\n@@ -105,7 +105,7 @@ fn emit_aapcs_va_arg(\n     let mut end = bx.build_sibling_block(\"va_arg.end\");\n     let zero = bx.const_i32(0);\n     let offset_align = Align::from_bytes(4).unwrap();\n-    assert!(&*bx.tcx().sess.target.target.target_endian == \"little\");\n+    assert!(&*bx.tcx().sess.target.target_endian == \"little\");\n \n     let gr_type = target_ty.is_any_ptr() || target_ty.is_integral();\n     let (reg_off, reg_top_index, slot_size) = if gr_type {\n@@ -171,8 +171,8 @@ pub(super) fn emit_va_arg(\n ) -> &'ll Value {\n     // Determine the va_arg implementation to use. The LLVM va_arg instruction\n     // is lacking in some instances, so we should only use it as a fallback.\n-    let target = &bx.cx.tcx.sess.target.target;\n-    let arch = &bx.cx.tcx.sess.target.target.arch;\n+    let target = &bx.cx.tcx.sess.target;\n+    let arch = &bx.cx.tcx.sess.target.arch;\n     match (&**arch, target.options.is_like_windows) {\n         // Windows x86\n         (\"x86\", true) => {"}, {"sha": "ef722ecb599864e7d6e1271e37ca01a2c5fdc061", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -9,9 +9,7 @@ pub fn find_library(name: Symbol, search_paths: &[PathBuf], sess: &Session) -> P\n     // times show up as foo.lib\n     let oslibname = format!(\n         \"{}{}{}\",\n-        sess.target.target.options.staticlib_prefix,\n-        name,\n-        sess.target.target.options.staticlib_suffix\n+        sess.target.options.staticlib_prefix, name, sess.target.options.staticlib_suffix\n     );\n     let unixlibname = format!(\"lib{}.a\", name);\n "}, {"sha": "e3b4b6866cf54e28e1ce250c418dba2653ec54f9", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -152,7 +152,7 @@ fn get_linker(\n         _ => match flavor {\n             LinkerFlavor::Lld(f) => Command::lld(linker, f),\n             LinkerFlavor::Msvc\n-                if sess.opts.cg.linker.is_none() && sess.target.target.options.linker.is_none() =>\n+                if sess.opts.cg.linker.is_none() && sess.target.options.linker.is_none() =>\n             {\n                 Command::new(msvc_tool.as_ref().map(|t| t.path()).unwrap_or(linker))\n             }\n@@ -163,7 +163,7 @@ fn get_linker(\n     // UWP apps have API restrictions enforced during Store submissions.\n     // To comply with the Windows App Certification Kit,\n     // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n-    let t = &sess.target.target;\n+    let t = &sess.target;\n     if (flavor == LinkerFlavor::Msvc || flavor == LinkerFlavor::Lld(LldFlavor::Link))\n         && t.target_vendor == \"uwp\"\n     {\n@@ -197,7 +197,7 @@ fn get_linker(\n     // PATH for the child.\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths(self_contained);\n     let mut msvc_changed_path = false;\n-    if sess.target.target.options.is_like_msvc {\n+    if sess.target.options.is_like_msvc {\n         if let Some(ref tool) = msvc_tool {\n             cmd.args(tool.args());\n             for &(ref k, ref v) in tool.env() {\n@@ -365,7 +365,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n             // After adding all files to the archive, we need to update the\n             // symbol table of the archive. This currently dies on macOS (see\n             // #11162), and isn't necessary there anyway\n-            if !sess.target.target.options.is_like_osx {\n+            if !sess.target.options.is_like_osx {\n                 ab.update_symbols();\n             }\n         }\n@@ -476,10 +476,10 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n     linker::disable_localization(&mut cmd);\n \n-    for &(ref k, ref v) in &sess.target.target.options.link_env {\n+    for &(ref k, ref v) in &sess.target.options.link_env {\n         cmd.env(k, v);\n     }\n-    for k in &sess.target.target.options.link_env_remove {\n+    for k in &sess.target.options.link_env_remove {\n         cmd.env_remove(k);\n     }\n \n@@ -515,7 +515,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         // if the linker doesn't support -no-pie then it should not default to\n         // linking executables as pie. Different versions of gcc seem to use\n         // different quotes in the error message so don't check for them.\n-        if sess.target.target.options.linker_is_gnu\n+        if sess.target.options.linker_is_gnu\n             && flavor != LinkerFlavor::Ld\n             && (out.contains(\"unrecognized command line option\")\n                 || out.contains(\"unknown argument\"))\n@@ -535,7 +535,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n         // Detect '-static-pie' used with an older version of gcc or clang not supporting it.\n         // Fallback from '-static-pie' to '-static' in that case.\n-        if sess.target.target.options.linker_is_gnu\n+        if sess.target.options.linker_is_gnu\n             && flavor != LinkerFlavor::Ld\n             && (out.contains(\"unrecognized command line option\")\n                 || out.contains(\"unknown argument\"))\n@@ -548,7 +548,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n             );\n             // Mirror `add_(pre,post)_link_objects` to replace CRT objects.\n             let self_contained = crt_objects_fallback(sess, crate_type);\n-            let opts = &sess.target.target.options;\n+            let opts = &sess.target.options;\n             let pre_objects = if self_contained {\n                 &opts.pre_link_objects_fallback\n             } else {\n@@ -670,7 +670,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                 // is not a Microsoft LNK error then suggest a way to fix or\n                 // install the Visual Studio build tools.\n                 if let Some(code) = prog.status.code() {\n-                    if sess.target.target.options.is_like_msvc\n+                    if sess.target.options.is_like_msvc\n                         && flavor == LinkerFlavor::Msvc\n                         // Respect the command line override\n                         && sess.opts.cg.linker.is_none()\n@@ -741,7 +741,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n \n             linker_error.emit();\n \n-            if sess.target.target.options.is_like_msvc && linker_not_found {\n+            if sess.target.options.is_like_msvc && linker_not_found {\n                 sess.note_without_error(\n                     \"the msvc targets depend on the msvc linker \\\n                      but `link.exe` was not found\",\n@@ -758,7 +758,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     // On macOS, debuggers need this utility to get run to do some munging of\n     // the symbols. Note, though, that if the object files are being preserved\n     // for their debug information there's no need for us to run dsymutil.\n-    if sess.target.target.options.is_like_osx\n+    if sess.target.options.is_like_osx\n         && sess.opts.debuginfo != DebugInfo::None\n         && !preserve_objects_for_their_debuginfo(sess)\n     {\n@@ -776,7 +776,7 @@ fn link_sanitizers(sess: &Session, crate_type: CrateType, linker: &mut dyn Linke\n     let needs_runtime = match crate_type {\n         CrateType::Executable => true,\n         CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => {\n-            sess.target.target.options.is_like_osx\n+            sess.target.options.is_like_osx\n         }\n         CrateType::Rlib | CrateType::Staticlib => false,\n     };\n@@ -846,7 +846,7 @@ pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool\n     // If our target enables builtin function lowering in LLVM then the\n     // crates providing these functions don't participate in LTO (e.g.\n     // no_builtins or compiler builtins crates).\n-    !sess.target.target.options.no_builtins\n+    !sess.target.options.no_builtins\n         && (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n@@ -906,10 +906,10 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                 } else if stem == \"link\" || stem == \"lld-link\" {\n                     LinkerFlavor::Msvc\n                 } else if stem == \"lld\" || stem == \"rust-lld\" {\n-                    LinkerFlavor::Lld(sess.target.target.options.lld_flavor)\n+                    LinkerFlavor::Lld(sess.target.options.lld_flavor)\n                 } else {\n                     // fall back to the value in the target spec\n-                    sess.target.target.linker_flavor\n+                    sess.target.linker_flavor\n                 };\n \n                 Some((linker, flavor))\n@@ -926,8 +926,8 @@ fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     if let Some(ret) = infer_from(\n         sess,\n-        sess.target.target.options.linker.clone().map(PathBuf::from),\n-        Some(sess.target.target.linker_flavor),\n+        sess.target.options.linker.clone().map(PathBuf::from),\n+        Some(sess.target.linker_flavor),\n     ) {\n         return ret;\n     }\n@@ -962,7 +962,7 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     // Basically as a result this just means that if we're on OSX and we're\n     // *not* running dsymutil then the object files are the only source of truth\n     // for debug information, so we must preserve them.\n-    if sess.target.target.options.is_like_osx {\n+    if sess.target.options.is_like_osx {\n         return !sess.opts.debugging_opts.run_dsymutil;\n     }\n \n@@ -988,7 +988,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 NativeLibKind::StaticNoBundle\n                 | NativeLibKind::Dylib\n                 | NativeLibKind::Unspecified => {\n-                    if sess.target.target.options.is_like_msvc {\n+                    if sess.target.options.is_like_msvc {\n                         Some(format!(\"{}.lib\", name))\n                     } else {\n                         Some(format!(\"-l{}\", name))\n@@ -1070,16 +1070,13 @@ fn exec_linker(\n     let mut args = String::new();\n     for arg in cmd2.take_args() {\n         args.push_str(\n-            &Escape {\n-                arg: arg.to_str().unwrap(),\n-                is_like_msvc: sess.target.target.options.is_like_msvc,\n-            }\n-            .to_string(),\n+            &Escape { arg: arg.to_str().unwrap(), is_like_msvc: sess.target.options.is_like_msvc }\n+                .to_string(),\n         );\n         args.push('\\n');\n     }\n     let file = tmpdir.join(\"linker-arguments\");\n-    let bytes = if sess.target.target.options.is_like_msvc {\n+    let bytes = if sess.target.options.is_like_msvc {\n         let mut out = Vec::with_capacity((1 + args.len()) * 2);\n         // start the stream with a UTF-16 BOM\n         for c in std::iter::once(0xFEFF).chain(args.encode_utf16()) {\n@@ -1195,7 +1192,7 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     };\n \n     // Adjust the output kind to target capabilities.\n-    let opts = &sess.target.target.options;\n+    let opts = &sess.target.options;\n     let pic_exe_supported = opts.position_independent_executables;\n     let static_pic_exe_supported = opts.static_position_independent_executables;\n     let static_dylib_supported = opts.crt_static_allows_dylibs;\n@@ -1236,14 +1233,14 @@ fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n         return self_contained;\n     }\n \n-    match sess.target.target.options.crt_objects_fallback {\n+    match sess.target.options.crt_objects_fallback {\n         // FIXME: Find a better heuristic for \"native musl toolchain is available\",\n         // based on host and linker path, for example.\n         // (https://github.com/rust-lang/rust/pull/71769#issuecomment-626330237).\n         Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n         Some(CrtObjectsFallback::Mingw) => {\n-            sess.host == sess.target.target\n-                && sess.target.target.target_vendor != \"uwp\"\n+            sess.host == sess.target\n+                && sess.target.target_vendor != \"uwp\"\n                 && detect_self_contained_mingw(&sess)\n         }\n         // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n@@ -1259,7 +1256,7 @@ fn add_pre_link_objects(\n     link_output_kind: LinkOutputKind,\n     self_contained: bool,\n ) {\n-    let opts = &sess.target.target.options;\n+    let opts = &sess.target.options;\n     let objects =\n         if self_contained { &opts.pre_link_objects_fallback } else { &opts.pre_link_objects };\n     for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n@@ -1274,7 +1271,7 @@ fn add_post_link_objects(\n     link_output_kind: LinkOutputKind,\n     self_contained: bool,\n ) {\n-    let opts = &sess.target.target.options;\n+    let opts = &sess.target.options;\n     let objects =\n         if self_contained { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n     for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n@@ -1285,21 +1282,21 @@ fn add_post_link_objects(\n /// Add arbitrary \"pre-link\" args defined by the target spec or from command line.\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_pre_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n-    if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n+    if let Some(args) = sess.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n     cmd.args(&sess.opts.debugging_opts.pre_link_args);\n }\n \n /// Add a link script embedded in the target, if applicable.\n fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_type: CrateType) {\n-    match (crate_type, &sess.target.target.options.link_script) {\n+    match (crate_type, &sess.target.options.link_script) {\n         (CrateType::Cdylib | CrateType::Executable, Some(script)) => {\n-            if !sess.target.target.options.linker_is_gnu {\n+            if !sess.target.options.linker_is_gnu {\n                 sess.fatal(\"can only use link script when linking with GNU-like linker\");\n             }\n \n-            let file_name = [\"rustc\", &sess.target.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n+            let file_name = [\"rustc\", &sess.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n \n             let path = tmpdir.join(file_name);\n             if let Err(e) = fs::write(&path, script) {\n@@ -1338,23 +1335,23 @@ fn add_late_link_args(\n             *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n         });\n     if any_dynamic_crate {\n-        if let Some(args) = sess.target.target.options.late_link_args_dynamic.get(&flavor) {\n+        if let Some(args) = sess.target.options.late_link_args_dynamic.get(&flavor) {\n             cmd.args(args);\n         }\n     } else {\n-        if let Some(args) = sess.target.target.options.late_link_args_static.get(&flavor) {\n+        if let Some(args) = sess.target.options.late_link_args_static.get(&flavor) {\n             cmd.args(args);\n         }\n     }\n-    if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n+    if let Some(args) = sess.target.options.late_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n }\n \n /// Add arbitrary \"post-link\" args defined by the target spec.\n /// FIXME: Determine where exactly these args need to be inserted.\n fn add_post_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n-    if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n+    if let Some(args) = sess.target.options.post_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n }\n@@ -1456,7 +1453,7 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained:\n /// Add options making relocation sections in the produced ELF files read-only\n /// and suppressing lazy binding.\n fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) {\n-    match sess.opts.debugging_opts.relro_level.unwrap_or(sess.target.target.options.relro_level) {\n+    match sess.opts.debugging_opts.relro_level.unwrap_or(sess.target.options.relro_level) {\n         RelroLevel::Full => cmd.full_relro(),\n         RelroLevel::Partial => cmd.partial_relro(),\n         RelroLevel::Off => cmd.no_relro(),\n@@ -1487,9 +1484,9 @@ fn add_rpath_args(\n         let mut rpath_config = RPathConfig {\n             used_crates: &codegen_results.crate_info.used_crates_dynamic,\n             out_filename: out_filename.to_path_buf(),\n-            has_rpath: sess.target.target.options.has_rpath,\n-            is_like_osx: sess.target.target.options.is_like_osx,\n-            linker_is_gnu: sess.target.target.options.linker_is_gnu,\n+            has_rpath: sess.target.options.has_rpath,\n+            is_like_osx: sess.target.options.is_like_osx,\n+            linker_is_gnu: sess.target.options.linker_is_gnu,\n             get_install_prefix_lib_path: &mut get_install_prefix_lib_path,\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n@@ -1517,7 +1514,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     let base_cmd = get_linker(sess, path, flavor, crt_objects_fallback);\n     // FIXME: Move `/LIBPATH` addition for uwp targets from the linker construction\n     // to the linker args construction.\n-    assert!(base_cmd.get_args().is_empty() || sess.target.target.target_vendor == \"uwp\");\n+    assert!(base_cmd.get_args().is_empty() || sess.target.target_vendor == \"uwp\");\n     let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n     let link_output_kind = link_output_kind(sess, crate_type);\n \n@@ -1531,7 +1528,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_link_script(cmd, sess, tmpdir, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.target.target.options.is_like_fuchsia && crate_type == CrateType::Executable {\n+    if sess.target.options.is_like_fuchsia && crate_type == CrateType::Executable {\n         let prefix = if sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::ADDRESS) {\n             \"asan/\"\n         } else {\n@@ -1541,7 +1538,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.target.target.options.eh_frame_header {\n+    if sess.target.options.eh_frame_header {\n         cmd.add_eh_frame_header();\n     }\n \n@@ -1554,7 +1551,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_pre_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    if sess.target.target.options.is_like_emscripten {\n+    if sess.target.options.is_like_emscripten {\n         cmd.arg(\"-s\");\n         cmd.arg(if sess.panic_strategy() == PanicStrategy::Abort {\n             \"DISABLE_EXCEPTION_CATCHING=1\"\n@@ -1582,7 +1579,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     cmd.output_filename(out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    if crate_type == CrateType::Executable && sess.target.target.options.is_like_windows {\n+    if crate_type == CrateType::Executable && sess.target.options.is_like_windows {\n         if let Some(ref s) = codegen_results.windows_subsystem {\n             cmd.subsystem(s);\n         }\n@@ -1626,7 +1623,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // OBJECT-FILES-NO, AUDIT-ORDER\n     // We want to prevent the compiler from accidentally leaking in any system libraries,\n     // so by default we tell linkers not to link to any default libraries.\n-    if !sess.opts.cg.default_linker_libraries && sess.target.target.options.no_default_libraries {\n+    if !sess.opts.cg.default_linker_libraries && sess.target.options.no_default_libraries {\n         cmd.no_default_libraries();\n     }\n \n@@ -1945,7 +1942,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n                 // though, so we let that object file slide.\n                 let skip_because_lto = are_upstream_rust_objects_already_included(sess)\n                     && is_rust_object\n-                    && (sess.target.target.options.no_builtins\n+                    && (sess.target.options.no_builtins\n                         || !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n \n                 if skip_because_cfg_say_so || skip_because_lto {\n@@ -2088,10 +2085,10 @@ fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n }\n \n fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n-    let arch = &sess.target.target.arch;\n-    let os = &sess.target.target.target_os;\n-    let llvm_target = &sess.target.target.llvm_target;\n-    if sess.target.target.target_vendor != \"apple\"\n+    let arch = &sess.target.arch;\n+    let os = &sess.target.target_os;\n+    let llvm_target = &sess.target.llvm_target;\n+    if sess.target.target_vendor != \"apple\"\n         || !matches!(os.as_str(), \"ios\" | \"tvos\")\n         || flavor != LinkerFlavor::Gcc\n     {"}, {"sha": "3e13a1daecdef89e3636b23ed685b104b1bd4bb5", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -184,7 +184,7 @@ impl<'a> GccLinker<'a> {\n         // * On OSX they have their own linker, not binutils'\n         // * For WebAssembly the only functional linker is LLD, which doesn't\n         //   support hint flags\n-        !self.sess.target.target.options.is_like_osx && self.sess.target.target.arch != \"wasm32\"\n+        !self.sess.target.options.is_like_osx && self.sess.target.arch != \"wasm32\"\n     }\n \n     // Some platforms take hints about whether a library is static or dynamic.\n@@ -232,7 +232,7 @@ impl<'a> GccLinker<'a> {\n \n     fn build_dylib(&mut self, out_filename: &Path) {\n         // On mac we need to tell the linker to let this library be rpathed\n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             self.cmd.arg(\"-dynamiclib\");\n             self.linker_arg(\"-dylib\");\n \n@@ -248,17 +248,17 @@ impl<'a> GccLinker<'a> {\n             }\n         } else {\n             self.cmd.arg(\"-shared\");\n-            if self.sess.target.target.options.is_like_windows {\n+            if self.sess.target.options.is_like_windows {\n                 // The output filename already contains `dll_suffix` so\n                 // the resulting import library will have a name in the\n                 // form of libfoo.dll.a\n                 let implib_name =\n                     out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n                         format!(\n                             \"{}{}{}\",\n-                            self.sess.target.target.options.staticlib_prefix,\n+                            self.sess.target.options.staticlib_prefix,\n                             file,\n-                            self.sess.target.target.options.staticlib_suffix\n+                            self.sess.target.options.staticlib_suffix\n                         )\n                     });\n                 if let Some(implib_name) = implib_name {\n@@ -280,7 +280,7 @@ impl<'a> Linker for GccLinker<'a> {\n     fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n         match output_kind {\n             LinkOutputKind::DynamicNoPicExe => {\n-                if !self.is_ld && self.sess.target.target.options.linker_is_gnu {\n+                if !self.is_ld && self.sess.target.options.linker_is_gnu {\n                     self.cmd.arg(\"-no-pie\");\n                 }\n             }\n@@ -291,7 +291,7 @@ impl<'a> Linker for GccLinker<'a> {\n             LinkOutputKind::StaticNoPicExe => {\n                 // `-static` works for both gcc wrapper and ld.\n                 self.cmd.arg(\"-static\");\n-                if !self.is_ld && self.sess.target.target.options.linker_is_gnu {\n+                if !self.is_ld && self.sess.target.options.linker_is_gnu {\n                     self.cmd.arg(\"-no-pie\");\n                 }\n             }\n@@ -320,7 +320,7 @@ impl<'a> Linker for GccLinker<'a> {\n         // any `#[link]` attributes in the `libc` crate, see #72782 for details.\n         // FIXME: Switch to using `#[link]` attributes in the `libc` crate\n         // similarly to other targets.\n-        if self.sess.target.target.target_os == \"vxworks\"\n+        if self.sess.target.target_os == \"vxworks\"\n             && matches!(\n                 output_kind,\n                 LinkOutputKind::StaticNoPicExe\n@@ -385,7 +385,7 @@ impl<'a> Linker for GccLinker<'a> {\n     // functions, etc.\n     fn link_whole_staticlib(&mut self, lib: Symbol, search_path: &[PathBuf]) {\n         self.hint_static();\n-        let target = &self.sess.target.target;\n+        let target = &self.sess.target;\n         if !target.options.is_like_osx {\n             self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\", lib));\n             self.linker_arg(\"--no-whole-archive\");\n@@ -400,7 +400,7 @@ impl<'a> Linker for GccLinker<'a> {\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n         self.hint_static();\n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             self.linker_arg(\"-force_load\");\n             self.linker_arg(&lib);\n         } else {\n@@ -424,9 +424,9 @@ impl<'a> Linker for GccLinker<'a> {\n         // -dead_strip can't be part of the pre_link_args because it's also used\n         // for partial linking when using multiple codegen units (-r).  So we\n         // insert it here.\n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             self.linker_arg(\"-dead_strip\");\n-        } else if self.sess.target.target.options.is_like_solaris {\n+        } else if self.sess.target.options.is_like_solaris {\n             self.linker_arg(\"-zignore\");\n \n         // If we're building a dylib, we don't use --gc-sections because LLVM\n@@ -440,7 +440,7 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn optimize(&mut self) {\n-        if !self.sess.target.target.options.linker_is_gnu {\n+        if !self.sess.target.options.linker_is_gnu {\n             return;\n         }\n \n@@ -454,7 +454,7 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn pgo_gen(&mut self) {\n-        if !self.sess.target.target.options.linker_is_gnu {\n+        if !self.sess.target.options.linker_is_gnu {\n             return;\n         }\n \n@@ -504,7 +504,7 @@ impl<'a> Linker for GccLinker<'a> {\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // Symbol visibility in object files typically takes care of this.\n         if crate_type == CrateType::Executable\n-            && self.sess.target.target.options.override_export_symbols.is_none()\n+            && self.sess.target.options.override_export_symbols.is_none()\n         {\n             return;\n         }\n@@ -513,21 +513,21 @@ impl<'a> Linker for GccLinker<'a> {\n         // The object files have far more public symbols than we actually want to export,\n         // so we hide them all here.\n \n-        if !self.sess.target.target.options.limit_rdylib_exports {\n+        if !self.sess.target.options.limit_rdylib_exports {\n             return;\n         }\n \n         if crate_type == CrateType::ProcMacro {\n             return;\n         }\n \n-        let is_windows = self.sess.target.target.options.is_like_windows;\n+        let is_windows = self.sess.target.options.is_like_windows;\n         let mut arg = OsString::new();\n         let path = tmpdir.join(if is_windows { \"list.def\" } else { \"list\" });\n \n         debug!(\"EXPORTED SYMBOLS:\");\n \n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             // Write a plain, newline-separated list of symbols\n             let res: io::Result<()> = try {\n                 let mut f = BufWriter::new(File::create(&path)?);\n@@ -573,12 +573,12 @@ impl<'a> Linker for GccLinker<'a> {\n             }\n         }\n \n-        if self.sess.target.target.options.is_like_osx {\n+        if self.sess.target.options.is_like_osx {\n             if !self.is_ld {\n                 arg.push(\"-Wl,\")\n             }\n             arg.push(\"-exported_symbols_list,\");\n-        } else if self.sess.target.target.options.is_like_solaris {\n+        } else if self.sess.target.options.is_like_solaris {\n             if !self.is_ld {\n                 arg.push(\"-Wl,\")\n             }\n@@ -1203,7 +1203,7 @@ impl<'a> Linker for WasmLd<'a> {\n }\n \n fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n-    if let Some(ref exports) = tcx.sess.target.target.options.override_export_symbols {\n+    if let Some(ref exports) = tcx.sess.target.options.override_export_symbols {\n         return exports.clone();\n     }\n \n@@ -1293,7 +1293,7 @@ impl<'a> Linker for PtxLinker<'a> {\n         // Provide the linker with fallback to internal `target-cpu`.\n         self.cmd.arg(\"--fallback-arch\").arg(match self.sess.opts.cg.target_cpu {\n             Some(ref s) => s,\n-            None => &self.sess.target.target.options.cpu,\n+            None => &self.sess.target.options.cpu,\n         });\n     }\n "}, {"sha": "dd8d751d0459111eccfe91743754e376173bd829", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -229,8 +229,8 @@ fn exported_symbols_provider_local(\n         // needs to be exported.\n         // However, on platforms that don't allow for Rust dylibs, having\n         // external linkage is enough for monomorphization to be linked to.\n-        let need_visibility = tcx.sess.target.target.options.dynamic_linking\n-            && !tcx.sess.target.target.options.only_cdylib;\n+        let need_visibility =\n+            tcx.sess.target.options.dynamic_linking && !tcx.sess.target.options.only_cdylib;\n \n         let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n \n@@ -391,7 +391,7 @@ fn symbol_export_level(tcx: TyCtxt<'_>, sym_def_id: DefId) -> SymbolExportLevel\n         codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n \n     if is_extern && !std_internal {\n-        let target = &tcx.sess.target.target.llvm_target;\n+        let target = &tcx.sess.target.llvm_target;\n         // WebAssembly cannot export data symbols, so reduce their export level\n         if target.contains(\"emscripten\") {\n             if let Some(Node::Item(&hir::Item { kind: hir::ItemKind::Static(..), .. })) ="}, {"sha": "4d2cea18dcc6887fc65f6091d9b2e0be8805a43a", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -139,7 +139,7 @@ impl ModuleConfig {\n \n         let emit_obj = if !should_emit_obj {\n             EmitObj::None\n-        } else if sess.target.target.options.obj_is_bitcode\n+        } else if sess.target.options.obj_is_bitcode\n             || (sess.opts.cg.linker_plugin_lto.enabled() && !no_builtins)\n         {\n             // This case is selected if the target uses objects as bitcode, or\n@@ -221,11 +221,11 @@ impl ModuleConfig {\n                 false\n             ),\n             emit_obj,\n-            bc_cmdline: sess.target.target.options.bitcode_llvm_cmdline.clone(),\n+            bc_cmdline: sess.target.options.bitcode_llvm_cmdline.clone(),\n \n             verify_llvm_ir: sess.verify_llvm_ir(),\n             no_prepopulate_passes: sess.opts.cg.no_prepopulate_passes,\n-            no_builtins: no_builtins || sess.target.target.options.no_builtins,\n+            no_builtins: no_builtins || sess.target.options.no_builtins,\n \n             // Exclude metadata and allocator modules from time_passes output,\n             // since they throw off the \"LLVM passes\" measurement.\n@@ -252,7 +252,7 @@ impl ModuleConfig {\n                 .opts\n                 .debugging_opts\n                 .merge_functions\n-                .unwrap_or(sess.target.target.options.merge_functions)\n+                .unwrap_or(sess.target.options.merge_functions)\n             {\n                 MergeFunctions::Disabled => false,\n                 MergeFunctions::Trampolines | MergeFunctions::Aliases => {\n@@ -388,7 +388,7 @@ fn need_bitcode_in_object(sess: &Session) -> bool {\n     let requested_for_rlib = sess.opts.cg.embed_bitcode\n         && sess.crate_types().contains(&CrateType::Rlib)\n         && sess.opts.output_types.contains_key(&OutputType::Exe);\n-    let forced_by_target = sess.target.target.options.forces_embed_bitcode;\n+    let forced_by_target = sess.target.options.forces_embed_bitcode;\n     requested_for_rlib || forced_by_target\n }\n \n@@ -1022,8 +1022,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         tm_factory: TargetMachineFactory(backend.target_machine_factory(tcx.sess, ol)),\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n-        target_pointer_width: tcx.sess.target.target.pointer_width,\n-        target_arch: tcx.sess.target.target.arch.clone(),\n+        target_pointer_width: tcx.sess.target.pointer_width,\n+        target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n     };\n \n@@ -1865,11 +1865,11 @@ fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     // something is wrong with commandline arg validation.\n     assert!(\n         !(tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-            && tcx.sess.target.target.options.is_like_windows\n+            && tcx.sess.target.options.is_like_windows\n             && tcx.sess.opts.cg.prefer_dynamic)\n     );\n \n-    tcx.sess.target.target.options.is_like_windows &&\n+    tcx.sess.target.options.is_like_windows &&\n         tcx.sess.crate_types().iter().any(|ct| *ct == CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing"}, {"sha": "4d9376091320d2eacb9b3eb2700725b0129b009a", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -327,7 +327,7 @@ fn cast_shift_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n /// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n /// 64-bit MinGW) instead of \"full SEH\".\n pub fn wants_msvc_seh(sess: &Session) -> bool {\n-    sess.target.target.options.is_like_msvc\n+    sess.target.options.is_like_msvc\n }\n \n pub fn memcpy_ty<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n@@ -393,7 +393,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n         // depending on whether the target needs `argc` and `argv` to be passed in.\n-        let llfty = if cx.sess().target.target.options.main_needs_argc_argv {\n+        let llfty = if cx.sess().target.options.main_needs_argc_argv {\n             cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int())\n         } else {\n             cx.type_func(&[], cx.type_int())\n@@ -464,7 +464,7 @@ fn get_argc_argv<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     bx: &mut Bx,\n ) -> (Bx::Value, Bx::Value) {\n-    if cx.sess().target.target.options.main_needs_argc_argv {\n+    if cx.sess().target.options.main_needs_argc_argv {\n         // Params from native `main()` used as args for rust start function\n         let param_argc = bx.get_param(0);\n         let param_argv = bx.get_param(1);"}, {"sha": "c4c51d146a60635565ed7e14ae7dd80e5b0a20dd", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -33,7 +33,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n ) {\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let cpp_like_names = tcx.sess.target.target.options.is_like_msvc;\n+    let cpp_like_names = tcx.sess.target.options.is_like_msvc;\n \n     match *t.kind() {\n         ty::Bool => output.push_str(\"bool\"),"}, {"sha": "a051ae25a9c17509980841df3d879459ef525e62", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -872,7 +872,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let string = match ty.kind() {\n                             ty::Uint(_) => value.to_string(),\n                             ty::Int(int_ty) => {\n-                                match int_ty.normalize(bx.tcx().sess.target.ptr_width) {\n+                                match int_ty.normalize(bx.tcx().sess.target.pointer_width) {\n                                     ast::IntTy::I8 => (value as i8).to_string(),\n                                     ast::IntTy::I16 => (value as i16).to_string(),\n                                     ast::IntTy::I32 => (value as i32).to_string(),"}, {"sha": "2bf1ee43c736636cc2239eb86342da45f7a17257", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -580,8 +580,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n // stuffs.\n fn int_type_width_signed(ty: Ty<'_>, tcx: TyCtxt<'_>) -> Option<(u64, bool)> {\n     match ty.kind() {\n-        ty::Int(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), true)),\n-        ty::Uint(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), false)),\n+        ty::Int(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.pointer_width)), true))\n+        }\n+        ty::Uint(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.pointer_width)), false))\n+        }\n         _ => None,\n     }\n }"}, {"sha": "e1cc0268723a7f2d633b88e92f55ad26ec272be2", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -346,8 +346,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n-                    if bx.cx().sess().target.target.arch == \"arm\"\n-                        || bx.cx().sess().target.target.arch == \"aarch64\"\n+                    if bx.cx().sess().target.arch == \"arm\"\n+                        || bx.cx().sess().target.arch == \"aarch64\"\n                     {\n                         // FIXME(#34427): as workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value."}, {"sha": "a8d88a95f7a27d89b15d16d9a16168edc2a6d87a", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -138,7 +138,7 @@ pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol\n }\n \n pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n-    match &*sess.target.target.arch {\n+    match &*sess.target.arch {\n         \"arm\" => ARM_ALLOWED_FEATURES,\n         \"aarch64\" => AARCH64_ALLOWED_FEATURES,\n         \"x86\" | \"x86_64\" => X86_ALLOWED_FEATURES,"}, {"sha": "43bc0c831558fae8b7c0ba9461574085cc336de5", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -51,7 +51,7 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_int(&self) -> Self::Type {\n-        match &self.sess().target.target.target_c_int_width[..] {\n+        match &self.sess().target.target_c_int_width[..] {\n             \"16\" => self.type_i16(),\n             \"32\" => self.type_i32(),\n             \"64\" => self.type_i64(),"}, {"sha": "136c9f6ec7da061e9077ab9b69cbdbb853a5209d", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -670,7 +670,7 @@ impl RustcDefaultCalls {\n                 Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target.target, path, metadata_loader, &mut v)\n+                    locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v)\n                         .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n                 }\n@@ -724,7 +724,7 @@ impl RustcDefaultCalls {\n                     \"{}\",\n                     sess.target_tlib_path.as_ref().unwrap_or(&sess.host_tlib_path).dir.display()\n                 ),\n-                TargetSpec => println!(\"{}\", sess.target.target.to_json().pretty()),\n+                TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n                 FileNames | CrateName => {\n                     let input = input.unwrap_or_else(|| {\n                         early_error(ErrorOutputType::default(), \"no input file provided\")"}, {"sha": "af14f28ff9f46ab1140f2c1ec3c10a5a5eb27d16", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -304,7 +304,7 @@ fn lint_int_literal<'tcx>(\n     t: ast::IntTy,\n     v: u128,\n ) {\n-    let int_type = t.normalize(cx.sess().target.ptr_width);\n+    let int_type = t.normalize(cx.sess().target.pointer_width);\n     let (min, max) = int_ty_range(int_type);\n     let max = max as u128;\n     let negative = type_limits.negated_expr_id == Some(e.hir_id);\n@@ -352,7 +352,7 @@ fn lint_uint_literal<'tcx>(\n     lit: &hir::Lit,\n     t: ast::UintTy,\n ) {\n-    let uint_type = t.normalize(cx.sess().target.ptr_width);\n+    let uint_type = t.normalize(cx.sess().target.pointer_width);\n     let (min, max) = uint_ty_range(uint_type);\n     let lit_val: u128 = match lit.node {\n         // _v is u8, within range by definition"}, {"sha": "44f57cfbe2843a9a567c5a20e4faddfb982efd8d", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -127,7 +127,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         if ty == CrateType::Staticlib\n             || (ty == CrateType::Executable\n                 && sess.crt_static(Some(ty))\n-                && !sess.target.target.options.crt_static_allows_dylibs)\n+                && !sess.target.options.crt_static_allows_dylibs)\n         {\n             for &cnum in tcx.crates().iter() {\n                 if tcx.dep_kind(cnum).macros_only() {"}, {"sha": "f225f8acc89ffe260483ac5c85f053dd78a40527", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -325,7 +325,7 @@ impl<'a> CrateLocator<'a> {\n             hash,\n             host_hash,\n             extra_filename,\n-            target: if is_host { &sess.host } else { &sess.target.target },\n+            target: if is_host { &sess.host } else { &sess.target },\n             triple: if is_host {\n                 TargetTriple::from_triple(config::host_triple())\n             } else {"}, {"sha": "5e65f075ea43f4b196939b30db35372d22b444e1", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -149,7 +149,7 @@ impl Collector<'tcx> {\n             }\n             return;\n         }\n-        let is_osx = self.tcx.sess.target.target.options.is_like_osx;\n+        let is_osx = self.tcx.sess.target.options.is_like_osx;\n         if lib.kind == NativeLibKind::Framework && !is_osx {\n             let msg = \"native frameworks are only available on macOS targets\";\n             match span {"}, {"sha": "e24ba6d7a1e3db17e5b21beded8a6757061e80bb", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -1079,7 +1079,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         crate_name: &str,\n         output_filenames: &OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n-        let data_layout = TargetDataLayout::parse(&s.target.target).unwrap_or_else(|err| {\n+        let data_layout = TargetDataLayout::parse(&s.target).unwrap_or_else(|err| {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(arena);\n@@ -1522,7 +1522,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Determines whether identifiers in the assembly have strict naming rules.\n     /// Currently, only NVPTX* targets need it.\n     pub fn has_strict_asm_symbol_naming(self) -> bool {\n-        self.sess.target.target.arch.contains(\"nvptx\")\n+        self.sess.target.arch.contains(\"nvptx\")\n     }\n \n     /// Returns `&'static core::panic::Location<'static>`."}, {"sha": "91c3dcbfa81cfa9fad6c87a1224a6326505bb5d4", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -106,7 +106,7 @@ impl IntegerExt for Integer {\n         }\n \n         if repr.c() {\n-            match &tcx.sess.target.target.arch[..] {\n+            match &tcx.sess.target.arch[..] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding\n                 // to `at_least == I32` appears to be used on Linux and NetBSD,\n                 // but some systems may use the variant corresponding to no\n@@ -2548,7 +2548,7 @@ where\n         let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n \n         use rustc_target::spec::abi::Abi::*;\n-        let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n+        let conv = match cx.tcx().sess.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n \n             // It's the ABI's job to select this, not ours.\n@@ -2600,7 +2600,7 @@ where\n             extra_args.to_vec()\n         };\n \n-        let target = &cx.tcx().sess.target.target;\n+        let target = &cx.tcx().sess.target;\n         let target_env_gnu_like = matches!(&target.target_env[..], \"gnu\" | \"musl\");\n         let win_x64_gnu =\n             target.target_os == \"windows\" && target.arch == \"x86_64\" && target.target_env == \"gnu\";\n@@ -2775,7 +2775,7 @@ where\n                     // anyway, we control all calls to it in libstd.\n                     Abi::Vector { .. }\n                         if abi != SpecAbi::PlatformIntrinsic\n-                            && cx.tcx().sess.target.target.options.simd_types_indirect =>\n+                            && cx.tcx().sess.target.options.simd_types_indirect =>\n                     {\n                         arg.make_indirect();\n                         return;"}, {"sha": "5083a45b539eda42755450a2ec98608b7b376495", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -532,7 +532,7 @@ fn mono_item_visibility(\n }\n \n fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n-    if !tcx.sess.target.target.options.default_hidden_visibility {\n+    if !tcx.sess.target.options.default_hidden_visibility {\n         return Visibility::Default;\n     }\n "}, {"sha": "956be925be815eac5b223d198ec1f47b3da6ac06", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -143,7 +143,7 @@ impl ExprVisitor<'tcx> {\n     ) -> Option<InlineAsmType> {\n         // Check the type against the allowed types for inline asm.\n         let ty = self.typeck_results.expr_ty_adjusted(expr);\n-        let asm_ty_isize = match self.tcx.sess.target.ptr_width {\n+        let asm_ty_isize = match self.tcx.sess.target.pointer_width {\n             16 => InlineAsmType::I16,\n             32 => InlineAsmType::I32,\n             64 => InlineAsmType::I64,\n@@ -184,7 +184,7 @@ impl ExprVisitor<'tcx> {\n                         Some(InlineAsmType::VecI128(fields.len() as u64))\n                     }\n                     ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => {\n-                        Some(match self.tcx.sess.target.ptr_width {\n+                        Some(match self.tcx.sess.target.pointer_width {\n                             16 => InlineAsmType::VecI16(fields.len() as u64),\n                             32 => InlineAsmType::VecI32(fields.len() as u64),\n                             64 => InlineAsmType::VecI64(fields.len() as u64),"}, {"sha": "8650ee05d377a487db2bb64aa8ac6fbb3794b3a9", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -26,7 +26,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n     if items.eh_personality().is_none() {\n         items.missing.push(LangItem::EhPersonality);\n     }\n-    if tcx.sess.target.target.options.is_like_emscripten && items.eh_catch_typeinfo().is_none() {\n+    if tcx.sess.target.options.is_like_emscripten && items.eh_catch_typeinfo().is_none() {\n         items.missing.push(LangItem::EhCatchTypeinfo);\n     }\n "}, {"sha": "fd7364b40be325ee717a7ee26e49bfb15acc0b6f", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -740,24 +740,24 @@ pub const fn default_lib_output() -> CrateType {\n }\n \n pub fn default_configuration(sess: &Session) -> CrateConfig {\n-    let end = &sess.target.target.target_endian;\n-    let arch = &sess.target.target.arch;\n-    let wordsz = sess.target.target.pointer_width.to_string();\n-    let os = &sess.target.target.target_os;\n-    let env = &sess.target.target.target_env;\n-    let vendor = &sess.target.target.target_vendor;\n-    let min_atomic_width = sess.target.target.min_atomic_width();\n-    let max_atomic_width = sess.target.target.max_atomic_width();\n-    let atomic_cas = sess.target.target.options.atomic_cas;\n-    let layout = TargetDataLayout::parse(&sess.target.target).unwrap_or_else(|err| {\n+    let end = &sess.target.target_endian;\n+    let arch = &sess.target.arch;\n+    let wordsz = sess.target.pointer_width.to_string();\n+    let os = &sess.target.target_os;\n+    let env = &sess.target.target_env;\n+    let vendor = &sess.target.target_vendor;\n+    let min_atomic_width = sess.target.min_atomic_width();\n+    let max_atomic_width = sess.target.max_atomic_width();\n+    let atomic_cas = sess.target.options.atomic_cas;\n+    let layout = TargetDataLayout::parse(&sess.target).unwrap_or_else(|err| {\n         sess.fatal(&err);\n     });\n \n     let mut ret = FxHashSet::default();\n     ret.reserve(6); // the minimum number of insertions\n     // Target bindings.\n     ret.insert((sym::target_os, Some(Symbol::intern(os))));\n-    if let Some(ref fam) = sess.target.target.options.target_family {\n+    if let Some(ref fam) = sess.target.options.target_family {\n         ret.insert((sym::target_family, Some(Symbol::intern(fam))));\n         if fam == \"windows\" {\n             ret.insert((sym::windows, None));\n@@ -770,7 +770,7 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n     ret.insert((sym::target_pointer_width, Some(Symbol::intern(&wordsz))));\n     ret.insert((sym::target_env, Some(Symbol::intern(env))));\n     ret.insert((sym::target_vendor, Some(Symbol::intern(vendor))));\n-    if sess.target.target.options.has_elf_tls {\n+    if sess.target.options.has_elf_tls {\n         ret.insert((sym::target_thread_local, None));\n     }\n     for &(i, align) in &["}, {"sha": "0766c55da7431c486648b8434a66649565ccc675", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -151,18 +151,16 @@ pub fn filename_for_input(\n         CrateType::Rlib => outputs.out_directory.join(&format!(\"lib{}.rlib\", libname)),\n         CrateType::Cdylib | CrateType::ProcMacro | CrateType::Dylib => {\n             let (prefix, suffix) =\n-                (&sess.target.target.options.dll_prefix, &sess.target.target.options.dll_suffix);\n+                (&sess.target.options.dll_prefix, &sess.target.options.dll_suffix);\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n         CrateType::Staticlib => {\n-            let (prefix, suffix) = (\n-                &sess.target.target.options.staticlib_prefix,\n-                &sess.target.target.options.staticlib_suffix,\n-            );\n+            let (prefix, suffix) =\n+                (&sess.target.options.staticlib_prefix, &sess.target.options.staticlib_suffix);\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n         CrateType::Executable => {\n-            let suffix = &sess.target.target.options.exe_suffix;\n+            let suffix = &sess.target.options.exe_suffix;\n             let out_filename = outputs.path(OutputType::Exe);\n             if suffix.is_empty() { out_filename } else { out_filename.with_extension(&suffix[1..]) }\n         }\n@@ -179,35 +177,29 @@ pub fn filename_for_input(\n /// interaction with Rust code through static library is the only\n /// option for now\n pub fn default_output_for_target(sess: &Session) -> CrateType {\n-    if !sess.target.target.options.executables {\n-        CrateType::Staticlib\n-    } else {\n-        CrateType::Executable\n-    }\n+    if !sess.target.options.executables { CrateType::Staticlib } else { CrateType::Executable }\n }\n \n /// Checks if target supports crate_type as output\n pub fn invalid_output_for_target(sess: &Session, crate_type: CrateType) -> bool {\n     match crate_type {\n         CrateType::Cdylib | CrateType::Dylib | CrateType::ProcMacro => {\n-            if !sess.target.target.options.dynamic_linking {\n+            if !sess.target.options.dynamic_linking {\n                 return true;\n             }\n-            if sess.crt_static(Some(crate_type))\n-                && !sess.target.target.options.crt_static_allows_dylibs\n-            {\n+            if sess.crt_static(Some(crate_type)) && !sess.target.options.crt_static_allows_dylibs {\n                 return true;\n             }\n         }\n         _ => {}\n     }\n-    if sess.target.target.options.only_cdylib {\n+    if sess.target.options.only_cdylib {\n         match crate_type {\n             CrateType::ProcMacro | CrateType::Dylib => return true,\n             _ => {}\n         }\n     }\n-    if !sess.target.target.options.executables {\n+    if !sess.target.options.executables {\n         if crate_type == CrateType::Executable {\n             return true;\n         }"}, {"sha": "867d6abcac29ba3a78f690d77b240763a633ae5f", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -614,7 +614,7 @@ impl Session {\n     /// Calculates the flavor of LTO to use for this compilation.\n     pub fn lto(&self) -> config::Lto {\n         // If our target has codegen requirements ignore the command line\n-        if self.target.target.options.requires_lto {\n+        if self.target.options.requires_lto {\n             return config::Lto::Fat;\n         }\n \n@@ -682,7 +682,7 @@ impl Session {\n     /// Returns the panic strategy for this compile session. If the user explicitly selected one\n     /// using '-C panic', use that, otherwise use the panic strategy defined by the target.\n     pub fn panic_strategy(&self) -> PanicStrategy {\n-        self.opts.cg.panic.unwrap_or(self.target.target.options.panic_strategy)\n+        self.opts.cg.panic.unwrap_or(self.target.options.panic_strategy)\n     }\n     pub fn fewer_names(&self) -> bool {\n         let more_names = self.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n@@ -706,9 +706,9 @@ impl Session {\n \n     /// Check whether this compile session and crate type use static crt.\n     pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n-        if !self.target.target.options.crt_static_respected {\n+        if !self.target.options.crt_static_respected {\n             // If the target does not opt in to crt-static support, use its default.\n-            return self.target.target.options.crt_static_default;\n+            return self.target.options.crt_static_default;\n         }\n \n         let requested_features = self.opts.cg.target_feature.split(',');\n@@ -725,20 +725,20 @@ impl Session {\n             // We can't check `#![crate_type = \"proc-macro\"]` here.\n             false\n         } else {\n-            self.target.target.options.crt_static_default\n+            self.target.options.crt_static_default\n         }\n     }\n \n     pub fn relocation_model(&self) -> RelocModel {\n-        self.opts.cg.relocation_model.unwrap_or(self.target.target.options.relocation_model)\n+        self.opts.cg.relocation_model.unwrap_or(self.target.options.relocation_model)\n     }\n \n     pub fn code_model(&self) -> Option<CodeModel> {\n-        self.opts.cg.code_model.or(self.target.target.options.code_model)\n+        self.opts.cg.code_model.or(self.target.options.code_model)\n     }\n \n     pub fn tls_model(&self) -> TlsModel {\n-        self.opts.debugging_opts.tls_model.unwrap_or(self.target.target.options.tls_model)\n+        self.opts.debugging_opts.tls_model.unwrap_or(self.target.options.tls_model)\n     }\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n@@ -749,7 +749,7 @@ impl Session {\n         } else if let Some(x) = self.opts.cg.force_frame_pointers {\n             x\n         } else {\n-            !self.target.target.options.eliminate_frame_pointer\n+            !self.target.options.eliminate_frame_pointer\n         }\n     }\n \n@@ -773,7 +773,7 @@ impl Session {\n         // value, if it is provided, or disable them, if not.\n         if self.panic_strategy() == PanicStrategy::Unwind {\n             true\n-        } else if self.target.target.options.requires_uwtable {\n+        } else if self.target.options.requires_uwtable {\n             true\n         } else {\n             self.opts.cg.force_unwind_tables.unwrap_or(false)\n@@ -944,7 +944,7 @@ impl Session {\n         if let Some(n) = self.opts.cli_forced_codegen_units {\n             return n;\n         }\n-        if let Some(n) = self.target.target.options.default_codegen_units {\n+        if let Some(n) = self.target.options.default_codegen_units {\n             return n as usize;\n         }\n \n@@ -1029,11 +1029,11 @@ impl Session {\n     pub fn needs_plt(&self) -> bool {\n         // Check if the current target usually needs PLT to be enabled.\n         // The user can use the command line flag to override it.\n-        let needs_plt = self.target.target.options.needs_plt;\n+        let needs_plt = self.target.options.needs_plt;\n \n         let dbg_opts = &self.opts.debugging_opts;\n \n-        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.target.options.relro_level);\n+        let relro_level = dbg_opts.relro_level.unwrap_or(self.target.options.relro_level);\n \n         // Only enable this optimization by default if full relro is also enabled.\n         // In this case, lazy binding was already unavailable, so nothing is lost.\n@@ -1057,8 +1057,7 @@ impl Session {\n         match self.opts.cg.link_dead_code {\n             Some(explicitly_set) => explicitly_set,\n             None => {\n-                self.opts.debugging_opts.instrument_coverage\n-                    && !self.target.target.options.is_like_msvc\n+                self.opts.debugging_opts.instrument_coverage && !self.target.options.is_like_msvc\n                 // Issue #76038: (rustc `-Clink-dead-code` causes MSVC linker to produce invalid\n                 // binaries when LLVM InstrProf counters are enabled). As described by this issue,\n                 // the \"link dead code\" option produces incorrect binaries when compiled and linked\n@@ -1438,7 +1437,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     // the `dllimport` attributes and `__imp_` symbols in that case.\n     if sess.opts.cg.linker_plugin_lto.enabled()\n         && sess.opts.cg.prefer_dynamic\n-        && sess.target.target.options.is_like_windows\n+        && sess.target.options.is_like_windows\n     {\n         sess.err(\n             \"Linker plugin based LTO is not supported together with \\\n@@ -1466,7 +1465,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n             );\n         }\n \n-        if sess.target.target.options.requires_uwtable && !include_uwtables {\n+        if sess.target.options.requires_uwtable && !include_uwtables {\n             sess.err(\n                 \"target requires unwind tables, they cannot be disabled with \\\n                      `-C force-unwind-tables=no`.\",\n@@ -1481,7 +1480,7 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     // We should only display this error if we're actually going to run PGO.\n     // If we're just supposed to print out some data, don't show the error (#61002).\n     if sess.opts.cg.profile_generate.enabled()\n-        && sess.target.target.options.is_like_msvc\n+        && sess.target.options.is_like_msvc\n         && sess.panic_strategy() == PanicStrategy::Unwind\n         && sess.opts.prints.iter().all(|&p| p == PrintRequest::NativeStaticLibs)\n     {"}, {"sha": "28b4a78929e5906f86cc13b704dd6dc99015eeb4", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -201,7 +201,7 @@ fn compute_symbol_name(\n     //\n     // [1]: https://bugs.llvm.org/show_bug.cgi?id=44316\n     if is_foreign {\n-        if tcx.sess.target.target.arch != \"wasm32\"\n+        if tcx.sess.target.arch != \"wasm32\"\n             || !tcx.wasm_import_module_map(def_id.krate).contains_key(&def_id)\n         {\n             if let Some(name) = attrs.link_name {"}, {"sha": "1d3e61c49920845d57b309bf9d5d57921135d64f", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -1619,10 +1619,7 @@ impl ToJson for Target {\n \n         target_val!(llvm_target);\n         target_val!(target_endian);\n-        d.insert(\n-            \"target-pointer-width\".to_string(),\n-            self.pointer_width.to_string().to_json(),\n-        );\n+        d.insert(\"target-pointer-width\".to_string(), self.pointer_width.to_string().to_json());\n         target_val!(target_c_int_width);\n         target_val!(arch);\n         target_val!(target_os, \"os\");"}, {"sha": "b9a5db478552ee1de8a2a218a8fc5646a50d8bf2", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -29,7 +29,7 @@ pub fn check_wf_new(tcx: TyCtxt<'_>) {\n }\n \n pub(super) fn check_abi(tcx: TyCtxt<'_>, span: Span, abi: Abi) {\n-    if !tcx.sess.target.target.is_abi_supported(abi) {\n+    if !tcx.sess.target.is_abi_supported(abi) {\n         struct_span_err!(\n             tcx.sess,\n             span,"}, {"sha": "630e80d502efae0d2731a632964f14bf4fa3cca8", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa55787745ac71793253c47c4d6cd5ffe96b741/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=4fa55787745ac71793253c47c4d6cd5ffe96b741", "patch": "@@ -2555,7 +2555,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-            if !tcx.sess.target.target.llvm_target.contains(\"thumbv8m\") {\n+            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n                 struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n                     .emit();\n             }\n@@ -2655,7 +2655,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                             set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n                         match segments.as_slice() {\n                             [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                                if !tcx.sess.target.target.options.has_thumb_interworking {\n+                                if !tcx.sess.target.options.has_thumb_interworking {\n                                     struct_span_err!(\n                                         tcx.sess.diagnostic(),\n                                         attr.span,"}]}