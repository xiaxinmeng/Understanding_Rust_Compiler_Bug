{"sha": "012f9a333b4017f5cb3d7917b03132b79a26dc09", "node_id": "C_kwDOAAsO6NoAKDAxMmY5YTMzM2I0MDE3ZjVjYjNkNzkxN2IwMzEzMmI3OWEyNmRjMDk", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2023-02-20T00:25:07Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2023-05-05T23:14:36Z"}, "message": "Review feedback", "tree": {"sha": "aa728a7b413bd983181b29c798dfb66f5c8ba511", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa728a7b413bd983181b29c798dfb66f5c8ba511"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012f9a333b4017f5cb3d7917b03132b79a26dc09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012f9a333b4017f5cb3d7917b03132b79a26dc09", "html_url": "https://github.com/rust-lang/rust/commit/012f9a333b4017f5cb3d7917b03132b79a26dc09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012f9a333b4017f5cb3d7917b03132b79a26dc09/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c63a204e239f8360cfe8e35946e43a87a1c77577", "url": "https://api.github.com/repos/rust-lang/rust/commits/c63a204e239f8360cfe8e35946e43a87a1c77577", "html_url": "https://github.com/rust-lang/rust/commit/c63a204e239f8360cfe8e35946e43a87a1c77577"}], "stats": {"total": 37, "additions": 23, "deletions": 14}, "files": [{"sha": "e46c171d731542eb5c5ec970f571d7bf12d59dbc", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/012f9a333b4017f5cb3d7917b03132b79a26dc09/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f9a333b4017f5cb3d7917b03132b79a26dc09/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=012f9a333b4017f5cb3d7917b03132b79a26dc09", "patch": "@@ -729,34 +729,43 @@ pub trait LayoutCalculator {\n             align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n-        let mut optimize = !repr.inhibit_union_abi_opt();\n+        // If all the non-ZST fields have the same ABI and union ABI optimizations aren't\n+        // disabled, we can use that common ABI for the union as a whole.\n+        struct AbiMismatch;\n+        let mut common_non_zst_abi_and_align = if repr.inhibit_union_abi_opt() {\n+            // Can't optimize\n+            Err(AbiMismatch)\n+        } else {\n+            Ok(None)\n+        };\n+\n         let mut size = Size::ZERO;\n-        let mut common_non_zst_abi_and_align: Option<(Abi, AbiAndPrefAlign)> = None;\n         let only_variant = &variants[FIRST_VARIANT];\n         for field in only_variant {\n             assert!(field.0.is_sized());\n \n-            if !field.0.is_zst() && optimize {\n+            if !field.0.is_zst() && !common_non_zst_abi_and_align.is_err() {\n                 // Discard valid range information and allow undef\n                 let field_abi = field.abi().to_union();\n \n-                if let Some((abi, align)) = &mut common_non_zst_abi_and_align {\n-                    if *abi != field_abi {\n+                if let Ok(Some((common_abi, common_align))) = &mut common_non_zst_abi_and_align {\n+                    if *common_abi != field_abi {\n                         // Different fields have different ABI: disable opt\n-                        optimize = false;\n+                        common_non_zst_abi_and_align = Err(AbiMismatch);\n                     } else {\n                         // Fields with the same non-Aggregate ABI should also\n                         // have the same alignment\n-                        if !matches!(abi, Abi::Aggregate { .. }) {\n+                        if !matches!(common_abi, Abi::Aggregate { .. }) {\n                             assert_eq!(\n-                                align.abi,\n+                                *common_align,\n                                 field.align().abi,\n                                 \"non-Aggregate field with matching ABI but differing alignment\"\n                             );\n                         }\n                     }\n                 } else {\n-                    common_non_zst_abi_and_align = Some((field_abi, field.align()));\n+                    // First non-ZST field: record its ABI and alignment\n+                    common_non_zst_abi_and_align = Ok(Some((field_abi, field.align().abi)));\n                 }\n             }\n \n@@ -770,11 +779,11 @@ pub trait LayoutCalculator {\n \n         // If all non-ZST fields have the same ABI, we may forward that ABI\n         // for the union as a whole, unless otherwise inhibited.\n-        let abi = match (optimize, common_non_zst_abi_and_align) {\n-            (false, _) | (_, None) => Abi::Aggregate { sized: true },\n-            (true, Some((abi, _))) => {\n+        let abi = match common_non_zst_abi_and_align {\n+            Err(AbiMismatch) | Ok(None) => Abi::Aggregate { sized: true },\n+            Ok(Some((abi, _))) => {\n                 if abi.inherent_align(dl).map(|a| a.abi) != Some(align.abi) {\n-                    // Mismatched alignment: disable opt\n+                    // Mismatched alignment (e.g. union is #[repr(packed)]): disable opt\n                     Abi::Aggregate { sized: true }\n                 } else {\n                     abi"}, {"sha": "43db66a3c2869fa7834369165923c7cba20b1a28", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012f9a333b4017f5cb3d7917b03132b79a26dc09/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f9a333b4017f5cb3d7917b03132b79a26dc09/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=012f9a333b4017f5cb3d7917b03132b79a26dc09", "patch": "@@ -1306,7 +1306,7 @@ impl Abi {\n         })\n     }\n \n-    /// Discard valid range information and allow undef\n+    /// Discard validity range information and allow undef.\n     pub fn to_union(&self) -> Self {\n         assert!(self.is_sized());\n         match *self {"}]}