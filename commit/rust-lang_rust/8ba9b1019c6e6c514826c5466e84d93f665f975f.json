{"sha": "8ba9b1019c6e6c514826c5466e84d93f665f975f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYTliMTAxOWM2ZTZjNTE0ODI2YzU0NjZlODRkOTNmNjY1Zjk3NWY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-05T20:24:58Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-07T21:22:06Z"}, "message": "Fix cycle error with existential types\n\nFixes #61863\n\nWe now allow uses of 'existential type's that aren't defining uses -\nthat is, uses which don't constrain the underlying concrete type.\n\nTo make this work correctly, we also modify eq_opaque_type_and_type to\nnot try to apply additional constraints to an opaque type. If we have\ncode like this:\n\n```\nexistential type Foo;\nfn foo1() -> Foo { ... }\nfn foo2() -> Foo { foo1() }\n```\n\nthen 'foo2' doesn't end up constraining 'Foo', which means that\n'foo2' will end up using the type 'Foo' internally - that is, an actual\n'TyKind::Opaque'. We don't want to equate this to the underlying\nconcrete type - we just need to enforce the basic equality constraint\nbetween the two types (here, the return type of 'foo1' and the return\ntype of 'foo2')", "tree": {"sha": "f336346fc600e789a45be997a771e1b1cc81dea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f336346fc600e789a45be997a771e1b1cc81dea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ba9b1019c6e6c514826c5466e84d93f665f975f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl0iYn4ACgkQtAh+UQ6Y\nsWRH4BAArYbmL2u6uSbbmK3t5efW7GzG4/gKNm0pGhy/bogCUlM6UjUIv3cV6l9P\nolbMCGZNRe4/C346026GLtbfGRZvVRHv9X79WdQrkj0D3lNsLhBd8zSFyiEKUeU2\nupq+P5oB8ybk9wm7OMKFTTxJ98KZqozgmwNcRcM3VF0uUFx74S2+rY0IPI2GYpnF\n6PiJdZxWK3FLHTnEahK8oHVzYyTpoxA/vHF8HcQ07t0/+a8albwNjVhyDcGxB31y\nRNeFnkFvrS30uKlAW8brLR4hxY+IxisyCh2nw7d6OFgUkOO8WInO7XrVURDxFkK8\nUcjt9SQPjjMDdAv48qWBX0FyE+AfIqg/AbwUkTdT6VbeGLTqlIaMXNYys7eWA5Lh\nBilqaT8fCRASQxIB7E4XxOyBzTU0oAebAuG1K1LBVWx5B7wpGqAyKXKrma59vVOw\nYBts6lopGN9qkTT+9YdKVCoGWYn4sHSGRjh8RR+E/J4bEtPK3HfaNXFVDuG6sj85\nw0HimYO2IDSebT+TjdxWiNkfKq8TbzqjgcZnqt2x6Bc2ep3YCemWvt1oA80hkPUW\neSycVHUL4T7qcdbOUU+H3jDSm1vHZsPws5BzvN1melU41eqkMoLcDK5iMBUWAl0L\nX5xG93To+vXFNf6v/gkTuJ9g6qcNA+MHRlRPncod0uY098KZ7DY=\n=HnOa\n-----END PGP SIGNATURE-----", "payload": "tree f336346fc600e789a45be997a771e1b1cc81dea1\nparent dd2e8040a35883574ae0c4cc7a4e887ecb66469c\nauthor Aaron Hill <aa1ronham@gmail.com> 1562358298 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1562534526 -0400\n\nFix cycle error with existential types\n\nFixes #61863\n\nWe now allow uses of 'existential type's that aren't defining uses -\nthat is, uses which don't constrain the underlying concrete type.\n\nTo make this work correctly, we also modify eq_opaque_type_and_type to\nnot try to apply additional constraints to an opaque type. If we have\ncode like this:\n\n```\nexistential type Foo;\nfn foo1() -> Foo { ... }\nfn foo2() -> Foo { foo1() }\n```\n\nthen 'foo2' doesn't end up constraining 'Foo', which means that\n'foo2' will end up using the type 'Foo' internally - that is, an actual\n'TyKind::Opaque'. We don't want to equate this to the underlying\nconcrete type - we just need to enforce the basic equality constraint\nbetween the two types (here, the return type of 'foo1' and the return\ntype of 'foo2')\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ba9b1019c6e6c514826c5466e84d93f665f975f", "html_url": "https://github.com/rust-lang/rust/commit/8ba9b1019c6e6c514826c5466e84d93f665f975f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ba9b1019c6e6c514826c5466e84d93f665f975f/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd2e8040a35883574ae0c4cc7a4e887ecb66469c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd2e8040a35883574ae0c4cc7a4e887ecb66469c", "html_url": "https://github.com/rust-lang/rust/commit/dd2e8040a35883574ae0c4cc7a4e887ecb66469c"}], "stats": {"total": 202, "additions": 105, "deletions": 97}, "files": [{"sha": "8bc377b401e87d77f3ee24256eac13500a82d968", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -1253,17 +1253,38 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             &anon_ty,\n                             locations.span(body),\n                         ));\n+\n+                    let revealed_ty_is_opaque = revealed_ty.is_impl_trait();\n+\n                     debug!(\n                         \"eq_opaque_type_and_type: \\\n                          instantiated output_ty={:?} \\\n                          opaque_type_map={:#?} \\\n-                         revealed_ty={:?}\",\n-                        output_ty, opaque_type_map, revealed_ty\n+                         revealed_ty={:?} \\\n+                         revealed_ty_is_opaque={}\",\n+                        output_ty, opaque_type_map, revealed_ty, revealed_ty_is_opaque\n                     );\n                     obligations.add(infcx\n                         .at(&ObligationCause::dummy(), param_env)\n                         .eq(output_ty, revealed_ty)?);\n \n+                    // This is 'true' when we're using an existential\n+                    // type without 'revelaing' it. For example, code like this:\n+                    //\n+                    // existential type Foo: Debug;\n+                    // fn foo1() -> Foo { ... }\n+                    // fn foo2() -> Foo { foo1() }\n+                    //\n+                    // In 'foo2', we're not revealing the type of 'Foo' - we're\n+                    // just treating it as the opaque type. All of the constraints\n+                    // in our 'opaque_type_map' apply to the concrete type,\n+                    // not to the opaque type itself. Therefore, it's enough\n+                    // to simply equate the output and opque 'revealed_type',\n+                    // as we do above\n+                    if revealed_ty_is_opaque {\n+                        return Ok(InferOk { value: None, obligations: obligations.into_vec() });\n+                    }\n+\n                     for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n                         let opaque_defn_ty = tcx.type_of(opaque_def_id);\n                         let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);"}, {"sha": "14bd2f0fa7eb912cfe970b9f7d23ca3d2faaf1e5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -576,36 +576,38 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 })\n             };\n \n+            let mut skip_add = false;\n+\n             if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.sty {\n                 if def_id == defin_ty_def_id {\n-                    // Concrete type resolved to the existential type itself.\n-                    // Force a cycle error.\n-                    // FIXME(oli-obk): we could just not insert it into `concrete_existential_types`\n-                    // which simply would make this use not a defining use.\n-                    self.tcx().at(span).type_of(defin_ty_def_id);\n+                    debug!(\"Skipping adding concrete definition for opaque type {:?} {:?}\",\n+                           opaque_defn, defin_ty_def_id);\n+                    skip_add = true;\n                 }\n             }\n \n             if !opaque_defn.substs.has_local_value() {\n-                let new = ty::ResolvedOpaqueTy {\n-                    concrete_type: definition_ty,\n-                    substs: opaque_defn.substs,\n-                };\n-\n-                let old = self.tables\n-                    .concrete_existential_types\n-                    .insert(def_id, new);\n-                if let Some(old) = old {\n-                    if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n-                        span_bug!(\n-                            span,\n-                            \"visit_opaque_types tried to write \\\n-                            different types for the same existential type: {:?}, {:?}, {:?}, {:?}\",\n-                            def_id,\n-                            definition_ty,\n-                            opaque_defn,\n-                            old,\n-                        );\n+                if !skip_add {\n+                    let new = ty::ResolvedOpaqueTy {\n+                        concrete_type: definition_ty,\n+                        substs: opaque_defn.substs,\n+                    };\n+\n+                    let old = self.tables\n+                        .concrete_existential_types\n+                        .insert(def_id, new);\n+                    if let Some(old) = old {\n+                        if old.concrete_type != definition_ty || old.substs != opaque_defn.substs {\n+                            span_bug!(\n+                                span,\n+                                \"visit_opaque_types tried to write different types for the same \\\n+                                existential type: {:?}, {:?}, {:?}, {:?}\",\n+                                def_id,\n+                                definition_ty,\n+                                opaque_defn,\n+                                old,\n+                            );\n+                        }\n                     }\n                 }\n             } else {"}, {"sha": "333e15f3445bf19339632015055e908724491d88", "filename": "src/test/run-pass/existential_type_const.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Frun-pass%2Fexistential_type_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Frun-pass%2Fexistential_type_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexistential_type_const.rs?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -0,0 +1,17 @@\n+#![feature(existential_type)]\n+#![feature(impl_trait_in_bindings)]\n+//~^ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+\n+// Ensures that consts can constrain an existential type\n+\n+use std::fmt::Debug;\n+\n+// Type `Foo` refers to a type that implements the `Debug` trait.\n+// The concrete type to which `Foo` refers is inferred from this module,\n+// and this concrete type is hidden from outer modules (but not submodules).\n+pub existential type Foo: Debug;\n+\n+const _FOO: Foo = 5;\n+\n+fn main() {\n+}"}, {"sha": "b6d83fb170362e87ba312485a504b6e8f9f0ee78", "filename": "src/test/run-pass/existential_type_const.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Frun-pass%2Fexistential_type_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Frun-pass%2Fexistential_type_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexistential_type_const.stderr?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/existential_type_const.rs:2:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "e477dca9aad004a21d865108aee1636034cc4d39", "filename": "src/test/run-pass/existential_type_fns.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Frun-pass%2Fexistential_type_fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Frun-pass%2Fexistential_type_fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexistential_type_fns.rs?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -0,0 +1,25 @@\n+#![feature(existential_type)]\n+\n+// Regression test for issue #61863\n+\n+pub trait MyTrait {}\n+\n+#[derive(Debug)]\n+pub struct MyStruct {\n+  v: u64\n+}\n+\n+impl MyTrait for MyStruct {}\n+\n+pub fn bla() -> TE {\n+    return MyStruct {v:1}\n+}\n+\n+pub fn bla2() -> TE {\n+    bla()\n+}\n+\n+\n+existential type TE: MyTrait;\n+\n+fn main() {}"}, {"sha": "38fcabb5cc170fc360b8de518de23a80b10b5dba", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -1,7 +1,7 @@\n #![feature(existential_type)]\n \n existential type Foo: Fn() -> Foo;\n-//~^ ERROR: cycle detected when processing `Foo`\n+//~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {\n     x"}, {"sha": "98a269d5271a222691209e55992755f9e9990967", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -1,30 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/existential-types-with-cycle-error.rs:3:1\n    |\n LL | existential type Foo: Fn() -> Foo;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `crash`...\n-  --> $DIR/existential-types-with-cycle-error.rs:6:25\n-   |\n-LL |   fn crash(x: Foo) -> Foo {\n-   |  _________________________^\n-LL | |     x\n-LL | | }\n-   | |_^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/existential-types-with-cycle-error.rs:1:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | existential type Foo: Fn() -> Foo;\n-LL | |\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "f9e6bdb67d4dec6e1a0e94e6ff8b7e6fcb7c6f02", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -5,7 +5,7 @@ pub trait Bar<T> {\n }\n \n existential type Foo: Bar<Foo, Item = Foo>;\n-//~^ ERROR: cycle detected when processing `Foo`\n+//~^ ERROR: could not find defining uses\n \n fn crash(x: Foo) -> Foo {\n     x"}, {"sha": "830305d863119bc8d1e085e8b0fa9b1900c0c328", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -1,30 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/existential-types-with-cycle-error2.rs:7:1\n    |\n LL | existential type Foo: Bar<Foo, Item = Foo>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `crash`...\n-  --> $DIR/existential-types-with-cycle-error2.rs:10:25\n-   |\n-LL |   fn crash(x: Foo) -> Foo {\n-   |  _________________________^\n-LL | |     x\n-LL | | }\n-   | |_^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/existential-types-with-cycle-error2.rs:1:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | pub trait Bar<T> {\n-LL | |     type Item;\n-...  |\n-LL | |\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "eec8a4be63d9808bebca26c107b73c1c52b91489", "filename": "src/test/ui/existential_types/no_inferrable_concrete_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.rs?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -1,9 +1,9 @@\n-// Issue 52985: Cause cycle error if user code provides no use case that allows an existential type\n-// to be inferred to a concrete type. This results in an infinite cycle during type normalization.\n+// Issue 52985: user code provides no use case that allows an existential type\n+// We now emit a 'could not find defining uses' error\n \n #![feature(existential_type)]\n \n-existential type Foo: Copy; //~ cycle detected\n+existential type Foo: Copy; //~ could not find defining uses\n \n // make compiler happy about using 'Foo'\n fn bar(x: Foo) -> Foo { x }"}, {"sha": "bc9a883c8365c7b120531f3b7f504bddc9d35261", "filename": "src/test/ui/existential_types/no_inferrable_concrete_type.stderr", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ba9b1019c6e6c514826c5466e84d93f665f975f/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fno_inferrable_concrete_type.stderr?ref=8ba9b1019c6e6c514826c5466e84d93f665f975f", "patch": "@@ -1,27 +1,8 @@\n-error[E0391]: cycle detected when processing `Foo`\n+error: could not find defining uses\n   --> $DIR/no_inferrable_concrete_type.rs:6:1\n    |\n LL | existential type Foo: Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires processing `bar`...\n-  --> $DIR/no_inferrable_concrete_type.rs:9:23\n-   |\n-LL | fn bar(x: Foo) -> Foo { x }\n-   |                       ^^^^^\n-   = note: ...which again requires processing `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/no_inferrable_concrete_type.rs:4:1\n-   |\n-LL | / #![feature(existential_type)]\n-LL | |\n-LL | | existential type Foo: Copy;\n-LL | |\n-...  |\n-LL | |     let _: Foo = std::mem::transmute(0u8);\n-LL | | }\n-   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0391`."}]}