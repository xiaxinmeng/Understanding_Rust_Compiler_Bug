{"sha": "71966176691588623b9f40d96879e4024774b215", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxOTY2MTc2NjkxNTg4NjIzYjlmNDBkOTY4NzllNDAyNDc3NGIyMTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T23:23:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T23:23:13Z"}, "message": "tutorial: Reorder sections around the memory model discussion\n\nAlso some minor tweaks.", "tree": {"sha": "942cf35f9a5f61545972baf35ea150a88826963c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/942cf35f9a5f61545972baf35ea150a88826963c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71966176691588623b9f40d96879e4024774b215", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71966176691588623b9f40d96879e4024774b215", "html_url": "https://github.com/rust-lang/rust/commit/71966176691588623b9f40d96879e4024774b215", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71966176691588623b9f40d96879e4024774b215/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "994c881538f86757f7b1193f7dfa52a67e480805", "url": "https://api.github.com/repos/rust-lang/rust/commits/994c881538f86757f7b1193f7dfa52a67e480805", "html_url": "https://github.com/rust-lang/rust/commit/994c881538f86757f7b1193f7dfa52a67e480805"}], "stats": {"total": 870, "additions": 425, "deletions": 445}, "files": [{"sha": "d3bbb869e6e909951578b579ac0932c3683997a7", "filename": "doc/tutorial.md", "status": "modified", "additions": 425, "deletions": 445, "changes": 870, "blob_url": "https://github.com/rust-lang/rust/blob/71966176691588623b9f40d96879e4024774b215/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/71966176691588623b9f40d96879e4024774b215/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=71966176691588623b9f40d96879e4024774b215", "patch": "@@ -883,7 +883,7 @@ declared both at the top level and inside other functions (or modules,\n which we'll come back to [later](#modules-and-crates)).\n \n We've already seen several function definitions. They are introduced\n-with the `fn` keyword. The type of arguments are specified following\n+with the `fn` keyword, the type of arguments are specified following\n colons and the return type follows the arrow.\n \n ~~~~\n@@ -947,7 +947,211 @@ let dir = if can_go_left() { left }\n           else { dead_end(); };\n ~~~~\n \n+# Basic datatypes\n \n+The core datatypes of Rust are structural records, enums (tagged\n+unions, algebraic data types), and tuples. They are immutable\n+by default.\n+\n+~~~~\n+type point = {x: float, y: float};\n+\n+enum shape {\n+    circle(point, float),\n+    rectangle(point, point)\n+}\n+~~~~\n+\n+## Records\n+\n+Rust record types are written `{field1: T1, field2: T2 [, ...]}`,\n+where `T1`, `T2`, ... denote types.  Record literals are written in\n+the same way, but with expressions instead of types. They are quite\n+similar to C structs, and even laid out the same way in memory (so you\n+can read from a Rust struct in C, and vice-versa). The dot operator is\n+used to access record fields (`mypoint.x`).\n+\n+Fields that you want to mutate must be explicitly marked `mut`.\n+\n+~~~~\n+type stack = {content: ~[int], mut head: uint};\n+~~~~\n+\n+With such a type, you can do `mystack.head += 1u`. If `mut` were\n+omitted from the type, such an assignment would result in a type\n+error.\n+\n+To create a new record based on the value of an existing record\n+you construct it using the `with` keyword:\n+\n+~~~~\n+let oldpoint = {x: 10f, y: 20f};\n+let newpoint = {x: 0f with oldpoint};\n+assert newpoint == {x: 0f, y: 20f};\n+~~~~\n+\n+This will create a new record, copying all the fields from `oldpoint`\n+into it, except for the ones that are explicitly set in the literal.\n+\n+Rust record types are *structural*. This means that `{x: float, y:\n+float}` is not just a way to define a new type, but is the actual name\n+of the type. Record types can be used without first defining them. If\n+module A defines `type point = {x: float, y: float}`, and module B,\n+without knowing anything about A, defines a function that returns an\n+`{x: float, y: float}`, you can use that return value as a `point` in\n+module A. (Remember that `type` defines an additional name for a type,\n+not an actual new type.)\n+\n+## Record patterns\n+\n+Records can be destructured in `alt` patterns. The basic syntax is\n+`{fieldname: pattern, ...}`, but the pattern for a field can be\n+omitted as a shorthand for simply binding the variable with the same\n+name as the field.\n+\n+~~~~\n+# let mypoint = {x: 0f, y: 0f};\n+alt mypoint {\n+    {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }\n+    {x, y}             { /* Simply bind the fields */ }\n+}\n+~~~~\n+\n+The field names of a record do not have to appear in a pattern in the\n+same order they appear in the type. When you are not interested in all\n+the fields of a record, a record pattern may end with `, _` (as in\n+`{field1, _}`) to indicate that you're ignoring all other fields.\n+\n+## Enums\n+\n+Enums are datatypes that have several alternate representations. For\n+example, consider the type shown earlier:\n+\n+~~~~\n+# type point = {x: float, y: float};\n+enum shape {\n+    circle(point, float),\n+    rectangle(point, point)\n+}\n+~~~~\n+\n+A value of this type is either a circle, in which case it contains a\n+point record and a float, or a rectangle, in which case it contains\n+two point records. The run-time representation of such a value\n+includes an identifier of the actual form that it holds, much like the\n+'tagged union' pattern in C, but with better ergonomics.\n+\n+The above declaration will define a type `shape` that can be used to\n+refer to such shapes, and two functions, `circle` and `rectangle`,\n+which can be used to construct values of the type (taking arguments of\n+the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n+create a new circle.\n+\n+Enum variants need not have type parameters. This, for example, is\n+equivalent to a C enum:\n+\n+~~~~\n+enum direction {\n+    north,\n+    east,\n+    south,\n+    west\n+}\n+~~~~\n+\n+This will define `north`, `east`, `south`, and `west` as constants,\n+all of which have type `direction`.\n+\n+When an enum is C-like, that is, when none of the variants have\n+parameters, it is possible to explicitly set the discriminator values\n+to an integer value:\n+\n+~~~~\n+enum color {\n+  red = 0xff0000,\n+  green = 0x00ff00,\n+  blue = 0x0000ff\n+}\n+~~~~\n+\n+If an explicit discriminator is not specified for a variant, the value\n+defaults to the value of the previous variant plus one. If the first\n+variant does not have a discriminator, it defaults to 0. For example,\n+the value of `north` is 0, `east` is 1, etc.\n+\n+When an enum is C-like the `as` cast operator can be used to get the\n+discriminator's value.\n+\n+<a name=\"single_variant_enum\"></a>\n+\n+There is a special case for enums with a single variant. These are\n+used to define new types in such a way that the new name is not just a\n+synonym for an existing type, but its own distinct type. If you say:\n+\n+~~~~\n+enum gizmo_id = int;\n+~~~~\n+\n+That is a shorthand for this:\n+\n+~~~~\n+enum gizmo_id { gizmo_id(int) }\n+~~~~\n+\n+Enum types like this can have their content extracted with the\n+dereference (`*`) unary operator:\n+\n+~~~~\n+# enum gizmo_id = int;\n+let my_gizmo_id = gizmo_id(10);\n+let id_int: int = *my_gizmo_id;\n+~~~~\n+\n+## Enum patterns\n+\n+For enum types with multiple variants, destructuring is the only way to\n+get at their contents. All variant constructors can be used as\n+patterns, as in this definition of `area`:\n+\n+~~~~\n+# type point = {x: float, y: float};\n+# enum shape { circle(point, float), rectangle(point, point) }\n+fn area(sh: shape) -> float {\n+    alt sh {\n+        circle(_, size) { float::consts::pi * size * size }\n+        rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }\n+    }\n+}\n+~~~~\n+\n+Another example, matching nullary enum variants:\n+\n+~~~~\n+# type point = {x: float, y: float};\n+# enum direction { north, east, south, west }\n+fn point_from_direction(dir: direction) -> point {\n+    alt dir {\n+        north { {x:  0f, y:  1f} }\n+        east  { {x:  1f, y:  0f} }\n+        south { {x:  0f, y: -1f} }\n+        west  { {x: -1f, y:  0f} }\n+    }\n+}\n+~~~~\n+\n+## Tuples\n+\n+Tuples in Rust behave exactly like records, except that their fields\n+do not have names (and can thus not be accessed with dot notation).\n+Tuples can have any arity except for 0 or 1 (though you may consider\n+nil, `()`, as the empty tuple if you like).\n+\n+~~~~\n+let mytup: (int, int, float) = (10, 20, 30.0);\n+alt mytup {\n+  (a, b, c) { log(info, a + b + (c as int)); }\n+}\n+~~~~\n \n # The Rust Memory Model\n \n@@ -1024,42 +1228,236 @@ and the unique pointer (`~T`). These three sigils will appear\n repeatedly as we explore the language. Learning the appropriate role\n of each is key to using Rust effectively.\n \n-# Closures\n+# Pointers\n \n-Named functions, like those in the previous section, may not refer\n-to local variables decalared outside the function - they do not\n-close over their environment. For example you couldn't write the\n-following:\n+In contrast to a lot of modern languages, record and enum types in\n+Rust are not represented as pointers to allocated memory. They are,\n+like in C and C++, represented directly. This means that if you `let x\n+= {x: 1f, y: 1f};`, you are creating a record on the stack. If you\n+then copy it into a data structure, the whole record is copied, not\n+just a pointer.\n \n-~~~~ {.ignore}\n-let foo = 10;\n+For small records like `point`, this is usually more efficient than\n+allocating memory and going through a pointer. But for big records, or\n+records with mutable fields, it can be useful to have a single copy on\n+the heap, and refer to that through a pointer.\n \n-fn bar() -> int {\n-   ret foo; // `bar` cannot refer to `foo`\n-}\n-~~~~\n+Rust supports several types of pointers. The safe pointer types are\n+`@T` for shared boxes allocated on the local heap, `~T`, for\n+uniquely-owned boxes allocated on the exchange heap, and `&T`, for\n+borrowed pointers, which may point to any memory, and whose lifetimes\n+are governed by the call stack.\n \n-Rust also supports _closures_, functions that can access variables in\n-the enclosing scope.\n+Rust also has an unsafe pointer, written `*T`, which is a completely\n+unchecked pointer type only used in unsafe code (and thus, in typical\n+Rust code, very rarely).\n \n-~~~~\n-# import println = io::println;\n-fn call_closure_with_ten(b: fn(int)) { b(10); }\n+All pointer types can be dereferenced with the `*` unary operator.\n \n-let captured_var = 20;\n-let closure = |arg| println(#fmt(\"captured_var=%d, arg=%d\", captured_var, arg));\n+## Shared boxes\n \n-call_closure_with_ten(closure);\n-~~~~\n+Shared boxes are pointers to heap-allocated, reference counted memory.\n+A cycle collector ensures that circular references do not result in\n+memory leaks.\n \n-The types of the arguments are generally omitted, as is the return\n-type, because the compiler can almost always infer them. In the rare\n-case where the compiler needs assistance though, the arguments and\n-return types may be annotated.\n+Creating a shared box is done by simply applying the unary `@`\n+operator to an expression. The result of the expression will be boxed,\n+resulting in a box of the right type. For example:\n \n ~~~~\n-# type mygoodness = fn(str) -> str; type what_the = int;\n-let bloop = |well, oh: mygoodness| -> what_the { fail oh(well) };\n+let x = @10; // New box, refcount of 1\n+let y = x; // Copy the pointer, increase refcount\n+// When x and y go out of scope, refcount goes to 0, box is freed\n+~~~~\n+\n+> ***Note:*** We will in the future switch to garbage collection,\n+> rather than reference counting, for shared boxes.\n+\n+Shared boxes never cross task boundaries.\n+\n+## Unique boxes\n+\n+In contrast to shared boxes, unique boxes have a single owner and thus\n+two unique boxes may not refer to the same memory. All unique boxes\n+across all tasks are allocated on a single _exchange heap_, where\n+their uniquely owned nature allows them to be passed between tasks.\n+\n+Because unique boxes are uniquely owned, copying them involves allocating\n+a new unique box and duplicating the contents. Copying unique boxes\n+is expensive so the compiler will complain if you do.\n+\n+~~~~\n+let x = ~10;\n+let y = x; // error: copying a non-implicitly copyable type\n+~~~~\n+\n+If you really want to copy a unique box you must say so explicitly.\n+\n+~~~~\n+let x = ~10;\n+let y = copy x;\n+~~~~\n+\n+This is where the 'move' (`<-`) operator comes in. It is similar to\n+`=`, but it de-initializes its source. Thus, the unique box can move\n+from `x` to `y`, without violating the constraint that it only has a\n+single owner (if you used assignment instead of the move operator, the\n+box would, in principle, be copied).\n+\n+~~~~\n+let x = ~10;\n+let y <- x;\n+~~~~\n+\n+Unique boxes, when they do not contain any shared boxes, can be sent\n+to other tasks. The sending task will give up ownership of the box,\n+and won't be able to access it afterwards. The receiving task will\n+become the sole owner of the box.\n+\n+## Borrowed pointers\n+\n+Rust borrowed pointers are a general purpose reference/pointer type,\n+similar to the C++ reference type, but guaranteed to point to valid\n+memory. In contrast to unique pointers, where the holder of a unique\n+pointer is the owner of the pointed-to memory, borrowed pointers never\n+imply ownership. Pointers may be borrowed from any type, in which case\n+the pointer is guaranteed not to outlive the value it points to.\n+\n+~~~~\n+# fn work_with_foo_by_pointer(f: &str) { }\n+let foo = \"foo\";\n+work_with_foo_by_pointer(&foo);\n+~~~~\n+\n+The following shows an example of what is _not_ possible with borrowed\n+pointers. If you were able to write this then the pointer to `foo`\n+would outlive `foo` itself.\n+\n+~~~~ {.ignore}\n+let foo_ptr;\n+{\n+    let foo = \"foo\";\n+    foo_ptr = &foo;\n+}\n+~~~~\n+\n+## Mutability\n+\n+All pointer types have a mutable variant, written `@mut T` or `~mut\n+T`. Given such a pointer, you can write to its contents by combining\n+the dereference operator with a mutating action.\n+\n+~~~~\n+fn increase_contents(pt: @mut int) {\n+    *pt += 1;\n+}\n+~~~~\n+\n+# Vectors\n+\n+Rust vectors are always heap-allocated and unique. A value of type\n+`~[T]` is represented by a pointer to a section of heap memory\n+containing any number of values of type `T`.\n+\n+> ***Note:*** This uniqueness is turning out to be quite awkward in\n+> practice, and might change in the future.\n+\n+Vector literals are enclosed in square brackets. Dereferencing is done\n+with square brackets (zero-based):\n+\n+~~~~\n+let myvec = ~[true, false, true, false];\n+if myvec[1] { io::println(\"boom\"); }\n+~~~~\n+\n+By default, vectors are immutable\u2014you can not replace their elements.\n+The type written as `~[mut T]` is a vector with mutable\n+elements. Mutable vector literals are written `~[mut]` (empty) or `~[mut\n+1, 2, 3]` (with elements).\n+\n+The `+` operator means concatenation when applied to vector types.\n+Growing a vector in Rust is not as inefficient as it looks :\n+\n+~~~~\n+let mut myvec = ~[], i = 0;\n+while i < 100 {\n+    myvec += ~[i];\n+    i += 1;\n+}\n+~~~~\n+\n+Because a vector is unique, replacing it with a longer one (which is\n+what `+= ~[i]` does) is indistinguishable from appending to it\n+in-place. Vector representations are optimized to grow\n+logarithmically, so the above code generates about the same amount of\n+copying and reallocation as `push` implementations in most other\n+languages.\n+\n+> ***Note:*** Actually, currently, growing a vector is *exactly* as\n+> inefficient as it looks, since vector `+` has been moved to the\n+> libraries and Rust's operator overloading support is insufficient to\n+> allow this optimization. Try using `vec::push`.\n+\n+## Strings\n+\n+The `str` type in Rust is represented exactly the same way as a vector\n+of bytes (`~[u8]`), except that it is guaranteed to have a trailing\n+null byte (for interoperability with C APIs).\n+\n+This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n+characters. This has the advantage that UTF-8 encoded I/O (which\n+should really be the default for modern systems) is very fast, and\n+that strings have, for most intents and purposes, a nicely compact\n+representation. It has the disadvantage that you only get\n+constant-time access by byte, not by character.\n+\n+A lot of algorithms don't need constant-time indexed access (they\n+iterate over all characters, which `str::chars` helps with), and\n+for those that do, many don't need actual characters, and can operate\n+on bytes. For algorithms that do really need to index by character,\n+there's the option to convert your string to a character vector (using\n+`str::chars`).\n+\n+Like vectors, strings are always unique. You can wrap them in a shared\n+box to share them. Unlike vectors, there is no mutable variant of\n+strings. They are always immutable.\n+\n+# Closures\n+\n+Named functions, like those in the previous section, may not refer\n+to local variables decalared outside the function - they do not\n+close over their environment. For example you couldn't write the\n+following:\n+\n+~~~~ {.ignore}\n+let foo = 10;\n+\n+fn bar() -> int {\n+   ret foo; // `bar` cannot refer to `foo`\n+}\n+~~~~\n+\n+Rust also supports _closures_, functions that can access variables in\n+the enclosing scope.\n+\n+~~~~\n+# import println = io::println;\n+fn call_closure_with_ten(b: fn(int)) { b(10); }\n+\n+let captured_var = 20;\n+let closure = |arg| println(#fmt(\"captured_var=%d, arg=%d\", captured_var, arg));\n+\n+call_closure_with_ten(closure);\n+~~~~\n+\n+The types of the arguments are generally omitted, as is the return\n+type, because the compiler can almost always infer them. In the rare\n+case where the compiler needs assistance though, the arguments and\n+return types may be annotated.\n+\n+~~~~\n+# type mygoodness = fn(str) -> str; type what_the = int;\n+let bloop = |well, oh: mygoodness| -> what_the { fail oh(well) };\n ~~~~\n \n There are several forms of closure, each with its own role. The most\n@@ -1289,424 +1687,6 @@ fn contains(v: ~[int], elt: int) -> bool {\n \n `for` syntax only works with stack closures.\n \n-\n-# Datatypes\n-\n-The core datatypes of Rust are structural records, enums (tagged\n-unions, algebraic data types), and classes. They are immutable\n-by default.\n-\n-~~~~\n-type point = {x: float, y: float};\n-\n-enum shape {\n-    circle(point, float),\n-    rectangle(point, point)\n-}\n-\n-class drawing {\n-    let mut shapes: [shape];\n-\n-    new() {\n-        self.shapes = [];\n-    }\n-\n-    fn add_shape(new_shape: shape) {\n-        self.shapes += [new_shape];\n-    }\n-}\n-\n-let my_drawing = drawing();\n-my_drawing.add_shape(circle({x: 0.0, y: 0.0}, 10.0));\n-~~~~\n-\n-## Records\n-\n-Rust record types are written `{field1: T1, field2: T2 [, ...]}`,\n-where `T1`, `T2`, ... denote types.  Record literals are written in\n-the same way, but with expressions instead of types. They are quite\n-similar to C structs, and even laid out the same way in memory (so you\n-can read from a Rust struct in C, and vice-versa). The dot operator is\n-used to access record fields (`mypoint.x`).\n-\n-Fields that you want to mutate must be explicitly marked `mut`.\n-\n-~~~~\n-type stack = {content: ~[int], mut head: uint};\n-~~~~\n-\n-With such a type, you can do `mystack.head += 1u`. If `mut` were\n-omitted from the type, such an assignment would result in a type\n-error.\n-\n-To create a new record based on the value of an existing record\n-you construct it using the `with` keyword:\n-\n-~~~~\n-let oldpoint = {x: 10f, y: 20f};\n-let newpoint = {x: 0f with oldpoint};\n-assert newpoint == {x: 0f, y: 20f};\n-~~~~\n-\n-This will create a new record, copying all the fields from `oldpoint`\n-into it, except for the ones that are explicitly set in the literal.\n-\n-Rust record types are *structural*. This means that `{x: float, y:\n-float}` is not just a way to define a new type, but is the actual name\n-of the type. Record types can be used without first defining them. If\n-module A defines `type point = {x: float, y: float}`, and module B,\n-without knowing anything about A, defines a function that returns an\n-`{x: float, y: float}`, you can use that return value as a `point` in\n-module A. (Remember that `type` defines an additional name for a type,\n-not an actual new type.)\n-\n-## Record patterns\n-\n-Records can be destructured in `alt` patterns. The basic syntax is\n-`{fieldname: pattern, ...}`, but the pattern for a field can be\n-omitted as a shorthand for simply binding the variable with the same\n-name as the field.\n-\n-~~~~\n-# let mypoint = {x: 0f, y: 0f};\n-alt mypoint {\n-    {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }\n-    {x, y}             { /* Simply bind the fields */ }\n-}\n-~~~~\n-\n-The field names of a record do not have to appear in a pattern in the\n-same order they appear in the type. When you are not interested in all\n-the fields of a record, a record pattern may end with `, _` (as in\n-`{field1, _}`) to indicate that you're ignoring all other fields.\n-\n-## Enums\n-\n-Enums are datatypes that have several alternate representations. For\n-example, consider the type shown earlier:\n-\n-~~~~\n-# type point = {x: float, y: float};\n-enum shape {\n-    circle(point, float),\n-    rectangle(point, point)\n-}\n-~~~~\n-\n-A value of this type is either a circle, in which case it contains a\n-point record and a float, or a rectangle, in which case it contains\n-two point records. The run-time representation of such a value\n-includes an identifier of the actual form that it holds, much like the\n-'tagged union' pattern in C, but with better ergonomics.\n-\n-The above declaration will define a type `shape` that can be used to\n-refer to such shapes, and two functions, `circle` and `rectangle`,\n-which can be used to construct values of the type (taking arguments of\n-the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n-create a new circle.\n-\n-Enum variants need not have type parameters. This, for example, is\n-equivalent to a C enum:\n-\n-~~~~\n-enum direction {\n-    north,\n-    east,\n-    south,\n-    west\n-}\n-~~~~\n-\n-This will define `north`, `east`, `south`, and `west` as constants,\n-all of which have type `direction`.\n-\n-When an enum is C-like, that is, when none of the variants have\n-parameters, it is possible to explicitly set the discriminator values\n-to an integer value:\n-\n-~~~~\n-enum color {\n-  red = 0xff0000,\n-  green = 0x00ff00,\n-  blue = 0x0000ff\n-}\n-~~~~\n-\n-If an explicit discriminator is not specified for a variant, the value\n-defaults to the value of the previous variant plus one. If the first\n-variant does not have a discriminator, it defaults to 0. For example,\n-the value of `north` is 0, `east` is 1, etc.\n-\n-When an enum is C-like the `as` cast operator can be used to get the\n-discriminator's value.\n-\n-<a name=\"single_variant_enum\"></a>\n-\n-There is a special case for enums with a single variant. These are\n-used to define new types in such a way that the new name is not just a\n-synonym for an existing type, but its own distinct type. If you say:\n-\n-~~~~\n-enum gizmo_id = int;\n-~~~~\n-\n-That is a shorthand for this:\n-\n-~~~~\n-enum gizmo_id { gizmo_id(int) }\n-~~~~\n-\n-Enum types like this can have their content extracted with the\n-dereference (`*`) unary operator:\n-\n-~~~~\n-# enum gizmo_id = int;\n-let my_gizmo_id = gizmo_id(10);\n-let id_int: int = *my_gizmo_id;\n-~~~~\n-\n-## Enum patterns\n-\n-For enum types with multiple variants, destructuring is the only way to\n-get at their contents. All variant constructors can be used as\n-patterns, as in this definition of `area`:\n-\n-~~~~\n-# type point = {x: float, y: float};\n-# enum shape { circle(point, float), rectangle(point, point) }\n-fn area(sh: shape) -> float {\n-    alt sh {\n-        circle(_, size) { float::consts::pi * size * size }\n-        rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }\n-    }\n-}\n-~~~~\n-\n-Another example, matching nullary enum variants:\n-\n-~~~~\n-# type point = {x: float, y: float};\n-# enum direction { north, east, south, west }\n-fn point_from_direction(dir: direction) -> point {\n-    alt dir {\n-        north { {x:  0f, y:  1f} }\n-        east  { {x:  1f, y:  0f} }\n-        south { {x:  0f, y: -1f} }\n-        west  { {x: -1f, y:  0f} }\n-    }\n-}\n-~~~~\n-\n-## Tuples\n-\n-Tuples in Rust behave exactly like records, except that their fields\n-do not have names (and can thus not be accessed with dot notation).\n-Tuples can have any arity except for 0 or 1 (though you may consider\n-nil, `()`, as the empty tuple if you like).\n-\n-~~~~\n-let mytup: (int, int, float) = (10, 20, 30.0);\n-alt mytup {\n-  (a, b, c) { log(info, a + b + (c as int)); }\n-}\n-~~~~\n-\n-## Pointers\n-\n-In contrast to a lot of modern languages, record and enum types in\n-Rust are not represented as pointers to allocated memory. They are,\n-like in C and C++, represented directly. This means that if you `let x\n-= {x: 1f, y: 1f};`, you are creating a record on the stack. If you\n-then copy it into a data structure, the whole record is copied, not\n-just a pointer.\n-\n-For small records like `point`, this is usually more efficient than\n-allocating memory and going through a pointer. But for big records, or\n-records with mutable fields, it can be useful to have a single copy on\n-the heap, and refer to that through a pointer.\n-\n-Rust supports several types of pointers. The safe pointer types are\n-`@T` for shared boxes allocated on the local heap, `~T`, for\n-uniquely-owned boxes allocated on the exchange heap, and `&T`, for\n-borrowed pointers, which may point to any memory, and whose lifetimes\n-are governed by the call stack.\n-\n-Rust also has an unsafe pointer, written `*T`, which is a completely\n-unchecked pointer type only used in unsafe code (and thus, in typical\n-Rust code, very rarely).\n-\n-All pointer types can be dereferenced with the `*` unary operator.\n-\n-### Shared boxes\n-\n-Shared boxes are pointers to heap-allocated, reference counted memory.\n-A cycle collector ensures that circular references do not result in\n-memory leaks.\n-\n-Creating a shared box is done by simply applying the unary `@`\n-operator to an expression. The result of the expression will be boxed,\n-resulting in a box of the right type. For example:\n-\n-~~~~\n-let x = @10; // New box, refcount of 1\n-let y = x; // Copy the pointer, increase refcount\n-// When x and y go out of scope, refcount goes to 0, box is freed\n-~~~~\n-\n-> ***Note:*** We will in the future switch to garbage collection,\n-> rather than reference counting, for shared boxes.\n-\n-Shared boxes never cross task boundaries.\n-\n-### Unique boxes\n-\n-In contrast to shared boxes, unique boxes have a single owner and thus\n-two unique boxes may not refer to the same memory. All unique boxes\n-across all tasks are allocated on a single _exchange heap_, where\n-their uniquely owned nature allows them to be passed between tasks.\n-\n-Because unique boxes are uniquely owned, copying them involves allocating\n-a new unique box and duplicating the contents. Copying unique boxes\n-is expensive so the compiler will complain if you do.\n-\n-~~~~\n-let x = ~10;\n-let y = x; // error: copying a non-implicitly copyable type\n-~~~~\n-\n-If you really want to copy a unique box you must say so explicitly.\n-\n-~~~~\n-let x = ~10;\n-let y = copy x;\n-~~~~\n-\n-This is where the 'move' (`<-`) operator comes in. It is similar to\n-`=`, but it de-initializes its source. Thus, the unique box can move\n-from `x` to `y`, without violating the constraint that it only has a\n-single owner (if you used assignment instead of the move operator, the\n-box would, in principle, be copied).\n-\n-~~~~\n-let x = ~10;\n-let y <- x;\n-~~~~\n-\n-Unique boxes, when they do not contain any shared boxes, can be sent\n-to other tasks. The sending task will give up ownership of the box,\n-and won't be able to access it afterwards. The receiving task will\n-become the sole owner of the box.\n-\n-### Borrowed pointers\n-\n-Rust borrowed pointers are a general purpose reference/pointer type,\n-similar to the C++ reference type, but guaranteed to point to valid\n-memory. In contrast to unique pointers, where the holder of a unique\n-pointer is the owner of the pointed-to memory, borrowed pointers never\n-imply ownership. Pointers may be borrowed from any type, in which case\n-the pointer is guaranteed not to outlive the value it points to.\n-\n-~~~~\n-# fn work_with_foo_by_pointer(f: &str) { }\n-let foo = \"foo\";\n-work_with_foo_by_pointer(&foo);\n-~~~~\n-\n-The following shows an example of what is _not_ possible with borrowed\n-pointers. If you were able to write this then the pointer to `foo`\n-would outlive `foo` itself.\n-\n-~~~~ {.ignore}\n-let foo_ptr;\n-{\n-    let foo = \"foo\";\n-    foo_ptr = &foo;\n-}\n-~~~~\n-\n-### Mutability\n-\n-All pointer types have a mutable variant, written `@mut T` or `~mut\n-T`. Given such a pointer, you can write to its contents by combining\n-the dereference operator with a mutating action.\n-\n-~~~~\n-fn increase_contents(pt: @mut int) {\n-    *pt += 1;\n-}\n-~~~~\n-\n-## Vectors\n-\n-Rust vectors are always heap-allocated and unique. A value of type\n-`~[T]` is represented by a pointer to a section of heap memory\n-containing any number of values of type `T`.\n-\n-> ***Note:*** This uniqueness is turning out to be quite awkward in\n-> practice, and might change in the future.\n-\n-Vector literals are enclosed in square brackets. Dereferencing is done\n-with square brackets (zero-based):\n-\n-~~~~\n-let myvec = ~[true, false, true, false];\n-if myvec[1] { io::println(\"boom\"); }\n-~~~~\n-\n-By default, vectors are immutable\u2014you can not replace their elements.\n-The type written as `~[mut T]` is a vector with mutable\n-elements. Mutable vector literals are written `~[mut]` (empty) or `~[mut\n-1, 2, 3]` (with elements).\n-\n-The `+` operator means concatenation when applied to vector types.\n-Growing a vector in Rust is not as inefficient as it looks :\n-\n-~~~~\n-let mut myvec = ~[], i = 0;\n-while i < 100 {\n-    myvec += ~[i];\n-    i += 1;\n-}\n-~~~~\n-\n-Because a vector is unique, replacing it with a longer one (which is\n-what `+= ~[i]` does) is indistinguishable from appending to it\n-in-place. Vector representations are optimized to grow\n-logarithmically, so the above code generates about the same amount of\n-copying and reallocation as `push` implementations in most other\n-languages.\n-\n-> ***Note:*** Actually, currently, growing a vector is *exactly* as\n-> inefficient as it looks, since vector `+` has been moved to the\n-> libraries and Rust's operator overloading support is insufficient to\n-> allow this optimization. Try using `vec::push`.\n-\n-## Strings\n-\n-The `str` type in Rust is represented exactly the same way as a vector\n-of bytes (`~[u8]`), except that it is guaranteed to have a trailing\n-null byte (for interoperability with C APIs).\n-\n-This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n-characters. This has the advantage that UTF-8 encoded I/O (which\n-should really be the default for modern systems) is very fast, and\n-that strings have, for most intents and purposes, a nicely compact\n-representation. It has the disadvantage that you only get\n-constant-time access by byte, not by character.\n-\n-A lot of algorithms don't need constant-time indexed access (they\n-iterate over all characters, which `str::chars` helps with), and\n-for those that do, many don't need actual characters, and can operate\n-on bytes. For algorithms that do really need to index by character,\n-there's the option to convert your string to a character vector (using\n-`str::chars`).\n-\n-Like vectors, strings are always unique. You can wrap them in a shared\n-box to share them. Unlike vectors, there is no mutable variant of\n-strings. They are always immutable.\n-\n-NOTE: Section on resources removed. ToDo: document classes and destructors\n-\n # Argument passing\n \n Rust datatypes are not trivial to copy (the way, for example,"}]}