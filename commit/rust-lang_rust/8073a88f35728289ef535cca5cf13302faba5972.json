{"sha": "8073a88f35728289ef535cca5cf13302faba5972", "node_id": "C_kwDOAAsO6NoAKDgwNzNhODhmMzU3MjgyODllZjUzNWNjYTVjZjEzMzAyZmFiYTU5NzI", "commit": {"author": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-03-09T19:46:23Z"}, "committer": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2022-03-09T19:46:23Z"}, "message": "Implement macro meta-variable expressions", "tree": {"sha": "d316fe90367710336d489ec4371d5f6116eb8791", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d316fe90367710336d489ec4371d5f6116eb8791"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8073a88f35728289ef535cca5cf13302faba5972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8073a88f35728289ef535cca5cf13302faba5972", "html_url": "https://github.com/rust-lang/rust/commit/8073a88f35728289ef535cca5cf13302faba5972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8073a88f35728289ef535cca5cf13302faba5972/comments", "author": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "url": "https://api.github.com/repos/rust-lang/rust/commits/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287", "html_url": "https://github.com/rust-lang/rust/commit/10dccdc7fcbdc64ee9efe2c1ed975ab8c1d61287"}], "stats": {"total": 944, "additions": 900, "deletions": 44}, "files": [{"sha": "9c18f55c03b4d28c091bf6cc411f215e7fc05c91", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -23,7 +23,7 @@ pub enum LitError {\n \n impl LitKind {\n     /// Converts literal token into a semantic literal.\n-    fn from_lit_token(lit: token::Lit) -> Result<LitKind, LitError> {\n+    pub fn from_lit_token(lit: token::Lit) -> Result<LitKind, LitError> {\n         let token::Lit { kind, symbol, suffix } = lit;\n         if suffix.is_some() && !kind.may_have_suffix() {\n             return Err(LitError::InvalidSuffix);"}, {"sha": "8a9efe01368e39625efca240f973ad2f3e45d42b", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -3,6 +3,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(if_let_guard)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "3d4c77aba7339ebe37516c84a08f3634d5c0cc40", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -6,17 +6,17 @@\n crate mod macro_check;\n crate mod macro_parser;\n crate mod macro_rules;\n+crate mod metavar_expr;\n crate mod quoted;\n crate mod transcribe;\n \n+use metavar_expr::MetaVarExpr;\n use rustc_ast::token::{self, NonterminalKind, Token, TokenKind};\n use rustc_ast::tokenstream::DelimSpan;\n-\n+use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-use rustc_data_structures::sync::Lrc;\n-\n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n@@ -73,8 +73,8 @@ enum KleeneOp {\n     ZeroOrOne,\n }\n \n-/// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n-/// are \"first-class\" token trees. Useful for parsing macros.\n+/// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, `$(...)`,\n+/// and `${...}` are \"first-class\" token trees. Useful for parsing macros.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n enum TokenTree {\n     Token(Token),\n@@ -85,6 +85,8 @@ enum TokenTree {\n     MetaVar(Span, Ident),\n     /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n     MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n+    /// A meta-variable expression inside `${...}`\n+    MetaVarExpr(DelimSpan, MetaVarExpr),\n }\n \n impl TokenTree {\n@@ -139,7 +141,9 @@ impl TokenTree {\n             TokenTree::Token(Token { span, .. })\n             | TokenTree::MetaVar(span, _)\n             | TokenTree::MetaVarDecl(span, _, _) => span,\n-            TokenTree::Delimited(span, _) | TokenTree::Sequence(span, _) => span.entire(),\n+            TokenTree::Delimited(span, _)\n+            | TokenTree::MetaVarExpr(span, _)\n+            | TokenTree::Sequence(span, _) => span.entire(),\n         }\n     }\n "}, {"sha": "88e11693220937da33a66996e74d7ff48ac346cf", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -278,6 +278,8 @@ fn check_binders(\n                 binders.insert(name, BinderInfo { span, ops: ops.into() });\n             }\n         }\n+        // `MetaVarExpr` can not appear in the LHS of a macro arm\n+        TokenTree::MetaVarExpr(..) => {}\n         TokenTree::Delimited(_, ref del) => {\n             for tt in &del.tts {\n                 check_binders(sess, node_id, tt, macros, binders, ops, valid);\n@@ -335,6 +337,8 @@ fn check_occurrences(\n             let name = MacroRulesNormalizedIdent::new(name);\n             check_ops_is_prefix(sess, node_id, macros, binders, ops, span, name);\n         }\n+        // FIXME(c410-f3r) Check token (https://github.com/rust-lang/rust/issues/93902)\n+        TokenTree::MetaVarExpr(..) => {}\n         TokenTree::Delimited(_, ref del) => {\n             check_nested_occurrences(sess, node_id, &del.tts, macros, binders, ops, valid);\n         }"}, {"sha": "04137086088ddef368c3844091ccebd9c90782c7", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -200,7 +200,7 @@ struct MatcherPos<'root, 'tt> {\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MatcherPos<'_, '_>, 192);\n+rustc_data_structures::static_assert_size!(MatcherPos<'_, '_>, 240);\n \n impl<'root, 'tt> MatcherPos<'root, 'tt> {\n     /// Generates the top-level matcher position in which the \"dot\" is before the first token of\n@@ -321,10 +321,13 @@ pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count\n             + match *elt {\n-                TokenTree::Sequence(_, ref seq) => seq.num_captures,\n                 TokenTree::Delimited(_, ref delim) => count_names(&delim.tts),\n                 TokenTree::MetaVar(..) => 0,\n                 TokenTree::MetaVarDecl(..) => 1,\n+                // FIXME(c410-f3r) MetaVarExpr should be handled instead of being ignored\n+                // https://github.com/rust-lang/rust/issues/9390\n+                TokenTree::MetaVarExpr(..) => 0,\n+                TokenTree::Sequence(_, ref seq) => seq.num_captures,\n                 TokenTree::Token(..) => 0,\n             }\n     })\n@@ -436,7 +439,9 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                 }\n                 Occupied(..) => return Err((sp, format!(\"duplicated bind name: {}\", bind_name))),\n             },\n-            TokenTree::MetaVar(..) | TokenTree::Token(..) => (),\n+            // FIXME(c410-f3r) MetaVar and MetaVarExpr should be handled instead of being ignored\n+            // https://github.com/rust-lang/rust/issues/9390\n+            TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) | TokenTree::Token(..) => {}\n         }\n \n         Ok(())\n@@ -650,7 +655,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 // rules. NOTE that this is not necessarily an error unless _all_ items in\n                 // `cur_items` end up doing this. There may still be some other matchers that do\n                 // end up working out.\n-                TokenTree::Token(..) | TokenTree::MetaVar(..) => {}\n+                TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => {}\n             }\n         }\n     }"}, {"sha": "c3b1b34aa29b933ba6863d71afeaec3e15623a57", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -580,7 +580,10 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n     use mbe::TokenTree;\n     for tt in tts {\n         match *tt {\n-            TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => (),\n+            TokenTree::Token(..)\n+            | TokenTree::MetaVar(..)\n+            | TokenTree::MetaVarDecl(..)\n+            | TokenTree::MetaVarExpr(..) => (),\n             TokenTree::Delimited(_, ref del) => {\n                 if !check_lhs_no_empty_seq(sess, &del.tts) {\n                     return false;\n@@ -669,7 +672,10 @@ impl FirstSets {\n             let mut first = TokenSet::empty();\n             for tt in tts.iter().rev() {\n                 match *tt {\n-                    TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n+                    TokenTree::Token(..)\n+                    | TokenTree::MetaVar(..)\n+                    | TokenTree::MetaVarDecl(..)\n+                    | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(tt.clone());\n                     }\n                     TokenTree::Delimited(span, ref delimited) => {\n@@ -731,7 +737,10 @@ impl FirstSets {\n         for tt in tts.iter() {\n             assert!(first.maybe_empty);\n             match *tt {\n-                TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n+                TokenTree::Token(..)\n+                | TokenTree::MetaVar(..)\n+                | TokenTree::MetaVarDecl(..)\n+                | TokenTree::MetaVarExpr(..) => {\n                     first.add_one(tt.clone());\n                     return first;\n                 }\n@@ -907,7 +916,10 @@ fn check_matcher_core(\n         // First, update `last` so that it corresponds to the set\n         // of NT tokens that might end the sequence `... token`.\n         match *token {\n-            TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n+            TokenTree::Token(..)\n+            | TokenTree::MetaVar(..)\n+            | TokenTree::MetaVarDecl(..)\n+            | TokenTree::MetaVarExpr(..) => {\n                 if token_can_be_followed_by_any(token) {\n                     // don't need to track tokens that work with any,\n                     last.replace_with_irrelevant();"}, {"sha": "6c5a755da6f4095d3291f4693ec42e98b8272e94", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -0,0 +1,157 @@\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::{Cursor, TokenStream, TokenTree};\n+use rustc_ast::{LitIntType, LitKind};\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::{Applicability, PResult};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+/// A meta-variable expression, for expansions based on properties of meta-variables.\n+#[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n+crate enum MetaVarExpr {\n+    /// The number of repetitions of an identifier, optionally limited to a number\n+    /// of outer-most repetition depths. If the depth limit is `None` then the depth is unlimited.\n+    Count(Ident, Option<usize>),\n+\n+    /// Ignore a meta-variable for repetition without expansion.\n+    Ignore(Ident),\n+\n+    /// The index of the repetition at a particular depth, where 0 is the inner-most\n+    /// repetition. The `usize` is the depth.\n+    Index(usize),\n+\n+    /// The length of the repetition at a particular depth, where 0 is the inner-most\n+    /// repetition. The `usize` is the depth.\n+    Length(usize),\n+}\n+\n+impl MetaVarExpr {\n+    /// Attempt to parse a meta-variable expression from a token stream.\n+    crate fn parse<'sess>(\n+        input: &TokenStream,\n+        outer_span: Span,\n+        sess: &'sess ParseSess,\n+    ) -> PResult<'sess, MetaVarExpr> {\n+        let mut tts = input.trees();\n+        let ident = parse_ident(&mut tts, sess, outer_span)?;\n+        let Some(TokenTree::Delimited(_, token::Paren, args)) = tts.next() else {\n+            let msg = \"meta-variable expression parameter must be wrapped in parentheses\";\n+            return Err(sess.span_diagnostic.struct_span_err(ident.span, msg));\n+        };\n+        check_trailing_token(&mut tts, sess)?;\n+        let mut iter = args.trees();\n+        let rslt = match &*ident.as_str() {\n+            \"count\" => parse_count(&mut iter, sess, ident.span)?,\n+            \"ignore\" => MetaVarExpr::Ignore(parse_ident(&mut iter, sess, ident.span)?),\n+            \"index\" => MetaVarExpr::Index(parse_depth(&mut iter, sess, ident.span)?),\n+            \"length\" => MetaVarExpr::Length(parse_depth(&mut iter, sess, ident.span)?),\n+            _ => {\n+                let err_msg = \"unrecognized meta-variable expression\";\n+                let mut err = sess.span_diagnostic.struct_span_err(ident.span, err_msg);\n+                err.span_suggestion(\n+                    ident.span,\n+                    \"supported expressions are count, ignore, index and length\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+                return Err(err);\n+            }\n+        };\n+        check_trailing_token(&mut iter, sess)?;\n+        Ok(rslt)\n+    }\n+\n+    crate fn ident(&self) -> Option<&Ident> {\n+        match self {\n+            MetaVarExpr::Count(ident, _) | MetaVarExpr::Ignore(ident) => Some(&ident),\n+            MetaVarExpr::Index(..) | MetaVarExpr::Length(..) => None,\n+        }\n+    }\n+}\n+\n+// Checks if there are any remaining tokens. For example, `${ignore(ident ... a b c ...)}`\n+fn check_trailing_token<'sess>(iter: &mut Cursor, sess: &'sess ParseSess) -> PResult<'sess, ()> {\n+    if let Some(tt) = iter.next() {\n+        let mut diag = sess.span_diagnostic.struct_span_err(\n+            tt.span(),\n+            &format!(\"unexpected token: {}\", pprust::tt_to_string(&tt)),\n+        );\n+        diag.span_note(tt.span(), \"meta-variable expression must not have trailing tokens\");\n+        Err(diag)\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+/// Parse a meta-variable `count` expression: `count(ident[, depth])`\n+fn parse_count<'sess>(\n+    iter: &mut Cursor,\n+    sess: &'sess ParseSess,\n+    span: Span,\n+) -> PResult<'sess, MetaVarExpr> {\n+    let ident = parse_ident(iter, sess, span)?;\n+    let depth = if try_eat_comma(iter) { Some(parse_depth(iter, sess, span)?) } else { None };\n+    Ok(MetaVarExpr::Count(ident, depth))\n+}\n+\n+/// Parses the depth used by index(depth) and length(depth).\n+fn parse_depth<'sess>(\n+    iter: &mut Cursor,\n+    sess: &'sess ParseSess,\n+    span: Span,\n+) -> PResult<'sess, usize> {\n+    let Some(tt) = iter.next() else { return Ok(0) };\n+    let TokenTree::Token(token::Token {\n+        kind: token::TokenKind::Literal(lit), ..\n+    }) = tt else {\n+        return Err(sess.span_diagnostic.struct_span_err(\n+            span,\n+            \"meta-variable expression depth must be a literal\"\n+        ));\n+    };\n+    if let Ok(lit_kind) = LitKind::from_lit_token(lit)\n+        && let LitKind::Int(n_u128, LitIntType::Unsuffixed) = lit_kind\n+        && let Ok(n_usize) = usize::try_from(n_u128)\n+    {\n+        Ok(n_usize)\n+    }\n+    else {\n+        let msg = \"only unsuffixes integer literals are supported in meta-variable expressions\";\n+        Err(sess.span_diagnostic.struct_span_err(span, msg))\n+    }\n+}\n+\n+/// Parses an generic ident\n+fn parse_ident<'sess>(\n+    iter: &mut Cursor,\n+    sess: &'sess ParseSess,\n+    span: Span,\n+) -> PResult<'sess, Ident> {\n+    let err_fn = |msg| sess.span_diagnostic.struct_span_err(span, msg);\n+    if let Some(tt) = iter.next() && let TokenTree::Token(token) = tt {\n+        if let Some((elem, false)) = token.ident() {\n+            return Ok(elem);\n+        }\n+        let token_str = pprust::token_to_string(&token);\n+        let mut err = err_fn(&format!(\"expected identifier, found `{}`\", &token_str));\n+        err.span_suggestion(\n+            token.span,\n+            &format!(\"try removing `{}`\", &token_str),\n+            String::new(),\n+            Applicability::MaybeIncorrect,\n+        );\n+        return Err(err);\n+    }\n+    Err(err_fn(\"expected identifier\"))\n+}\n+\n+/// Tries to move the iterator forward returning `true` if there is a comma. If not, then the\n+/// iterator is not modified and the result is `false`.\n+fn try_eat_comma(iter: &mut Cursor) -> bool {\n+    if let Some(TokenTree::Token(token::Token { kind: token::Comma, .. })) = iter.look_ahead(0) {\n+        let _ = iter.next();\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "12c5dac9e0bf47c33366940ae60959f9a13dc4e0", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 94, "deletions": 29, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -1,13 +1,13 @@\n use crate::mbe::macro_parser;\n-use crate::mbe::{Delimited, KleeneOp, KleeneToken, SequenceRepetition, TokenTree};\n+use crate::mbe::{Delimited, KleeneOp, KleeneToken, MetaVarExpr, SequenceRepetition, TokenTree};\n \n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream;\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_feature::Features;\n-use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_span::symbol::{kw, sym, Ident};\n \n use rustc_span::edition::Edition;\n use rustc_span::{Span, SyntaxContext};\n@@ -25,22 +25,22 @@ const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n /// # Parameters\n ///\n /// - `input`: a token stream to read from, the contents of which we are parsing.\n-/// - `expect_matchers`: `parse` can be used to parse either the \"patterns\" or the \"body\" of a\n-///   macro. Both take roughly the same form _except_ that in a pattern, metavars are declared with\n-///   their \"matcher\" type. For example `$var:expr` or `$id:ident`. In this example, `expr` and\n-///   `ident` are \"matchers\". They are not present in the body of a macro rule -- just in the\n-///   pattern, so we pass a parameter to indicate whether to expect them or not.\n+/// - `parsing_patterns`: `parse` can be used to parse either the \"patterns\" or the \"body\" of a\n+///   macro. Both take roughly the same form _except_ that:\n+///   - In a pattern, metavars are declared with their \"matcher\" type. For example `$var:expr` or\n+///     `$id:ident`. In this example, `expr` and `ident` are \"matchers\". They are not present in the\n+///     body of a macro rule -- just in the pattern.\n+///   - Metavariable expressions are only valid in the \"body\", not the \"pattern\".\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `node_id`: the NodeId of the macro we are parsing.\n /// - `features`: language features so we can do feature gating.\n-/// - `edition`: the edition of the crate defining the macro\n ///\n /// # Returns\n ///\n /// A collection of `self::TokenTree`. There may also be some errors emitted to `sess`.\n pub(super) fn parse(\n     input: tokenstream::TokenStream,\n-    expect_matchers: bool,\n+    parsing_patterns: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n     features: &Features,\n@@ -55,9 +55,9 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id, features, edition);\n+        let tree = parse_tree(tree, &mut trees, parsing_patterns, sess, node_id, features, edition);\n         match tree {\n-            TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n+            TokenTree::MetaVar(start_sp, ident) if parsing_patterns => {\n                 let span = match trees.next() {\n                     Some(tokenstream::TokenTree::Token(Token { kind: token::Colon, span })) => {\n                         match trees.next() {\n@@ -118,6 +118,14 @@ pub(super) fn parse(\n     result\n }\n \n+/// Asks for the `macro_metavar_expr` feature if it is not already declared\n+fn maybe_emit_macro_metavar_expr_feature(features: &Features, sess: &ParseSess, span: Span) {\n+    if !features.macro_metavar_expr {\n+        let msg = \"meta-variable expressions are unstable\";\n+        feature_err(&sess, sym::macro_metavar_expr, span, msg).emit();\n+    }\n+}\n+\n /// Takes a `tokenstream::TokenTree` and returns a `self::TokenTree`. Specifically, this takes a\n /// generic `TokenTree`, such as is used in the rest of the compiler, and returns a `TokenTree`\n /// for use in parsing a macro.\n@@ -129,14 +137,13 @@ pub(super) fn parse(\n /// - `tree`: the tree we wish to convert.\n /// - `outer_trees`: an iterator over trees. We may need to read more tokens from it in order to finish\n ///   converting `tree`\n-/// - `expect_matchers`: same as for `parse` (see above).\n+/// - `parsing_patterns`: same as [parse].\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `features`: language features so we can do feature gating.\n-/// - `edition` - the edition of the crate defining the macro\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n     outer_trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n-    expect_matchers: bool,\n+    parsing_patterns: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n     features: &Features,\n@@ -158,24 +165,57 @@ fn parse_tree(\n             }\n \n             match next {\n-                // `tree` is followed by a delimited set of token trees. This indicates the beginning\n-                // of a repetition sequence in the macro (e.g. `$(pat)*`).\n-                Some(tokenstream::TokenTree::Delimited(span, delim, tts)) => {\n-                    // Must have `(` not `{` or `[`\n-                    if delim != token::Paren {\n-                        let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n-                        let msg = format!(\"expected `(`, found `{}`\", tok);\n-                        sess.span_diagnostic.span_err(span.entire(), &msg);\n+                // `tree` is followed by a delimited set of token trees.\n+                Some(tokenstream::TokenTree::Delimited(delim_span, delim, tts)) => {\n+                    if parsing_patterns {\n+                        if delim != token::Paren {\n+                            span_dollar_dollar_or_metavar_in_the_lhs_err(\n+                                sess,\n+                                &Token { kind: token::OpenDelim(delim), span: delim_span.entire() },\n+                            );\n+                        }\n+                    } else {\n+                        match delim {\n+                            token::Brace => {\n+                                // The delimiter is `{`.  This indicates the beginning\n+                                // of a meta-variable expression (e.g. `${count(ident)}`).\n+                                // Try to parse the meta-variable expression.\n+                                match MetaVarExpr::parse(&tts, delim_span.entire(), sess) {\n+                                    Err(mut err) => {\n+                                        err.emit();\n+                                        // Returns early the same read `$` to avoid spanning\n+                                        // unrelated diagnostics that could be performed afterwards\n+                                        return TokenTree::token(token::Dollar, span);\n+                                    }\n+                                    Ok(elem) => {\n+                                        maybe_emit_macro_metavar_expr_feature(\n+                                            features,\n+                                            sess,\n+                                            delim_span.entire(),\n+                                        );\n+                                        return TokenTree::MetaVarExpr(delim_span, elem);\n+                                    }\n+                                }\n+                            }\n+                            token::Paren => {}\n+                            _ => {\n+                                let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n+                                let msg = format!(\"expected `(` or `{{`, found `{}`\", tok);\n+                                sess.span_diagnostic.span_err(delim_span.entire(), &msg);\n+                            }\n+                        }\n                     }\n-                    // Parse the contents of the sequence itself\n-                    let sequence = parse(tts, expect_matchers, sess, node_id, features, edition);\n+                    // If we didn't find a metavar expression above, then we must have a\n+                    // repetition sequence in the macro (e.g. `$(pat)*`).  Parse the\n+                    // contents of the sequence itself\n+                    let sequence = parse(tts, parsing_patterns, sess, node_id, features, edition);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n-                        parse_sep_and_kleene_op(&mut trees, span.entire(), sess);\n+                        parse_sep_and_kleene_op(&mut trees, delim_span.entire(), sess);\n                     // Count the number of captured \"names\" (i.e., named metavars)\n                     let name_captures = macro_parser::count_names(&sequence);\n                     TokenTree::Sequence(\n-                        span,\n+                        delim_span,\n                         Lrc::new(SequenceRepetition {\n                             tts: sequence,\n                             separator,\n@@ -197,7 +237,20 @@ fn parse_tree(\n                     }\n                 }\n \n-                // `tree` is followed by a random token. This is an error.\n+                // `tree` is followed by another `$`. This is an escaped `$`.\n+                Some(tokenstream::TokenTree::Token(Token { kind: token::Dollar, span })) => {\n+                    if parsing_patterns {\n+                        span_dollar_dollar_or_metavar_in_the_lhs_err(\n+                            sess,\n+                            &Token { kind: token::Dollar, span },\n+                        );\n+                    } else {\n+                        maybe_emit_macro_metavar_expr_feature(features, sess, span);\n+                    }\n+                    TokenTree::token(token::Dollar, span)\n+                }\n+\n+                // `tree` is followed by some other token. This is an error.\n                 Some(tokenstream::TokenTree::Token(token)) => {\n                     let msg = format!(\n                         \"expected identifier, found `{}`\",\n@@ -221,7 +274,7 @@ fn parse_tree(\n             span,\n             Lrc::new(Delimited {\n                 delim,\n-                tts: parse(tts, expect_matchers, sess, node_id, features, edition),\n+                tts: parse(tts, parsing_patterns, sess, node_id, features, edition),\n             }),\n         ),\n     }\n@@ -309,3 +362,15 @@ fn parse_sep_and_kleene_op(\n     // Return a dummy\n     (None, KleeneToken::new(KleeneOp::ZeroOrMore, span))\n }\n+\n+// `$$` or a meta-variable is the lhs of a macro but shouldn't.\n+//\n+// For example, `macro_rules! foo { ( ${length()} ) => {} }`\n+fn span_dollar_dollar_or_metavar_in_the_lhs_err<'sess>(sess: &'sess ParseSess, token: &Token) {\n+    sess.span_diagnostic\n+        .span_err(token.span, &format!(\"unexpected token: {}\", pprust::token_to_string(token)));\n+    sess.span_diagnostic.span_note_without_error(\n+        token.span,\n+        \"`$$` and meta-variable expressions are not allowed inside macro parameter definitions\",\n+    );\n+}"}, {"sha": "b8d8394754134ca6f63417e0d35229ed039da1ff", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -255,6 +255,11 @@ pub(super) fn transcribe<'a>(\n                 }\n             }\n \n+            // Replace meta-variable expressions with the result of their expansion.\n+            mbe::TokenTree::MetaVarExpr(sp, expr) => {\n+                transcribe_metavar_expr(cx, expr, interp, &repeats, &mut result, &sp)?;\n+            }\n+\n             // If we are entering a new delimiter, we push its contents to the `stack` to be\n             // processed, and we push all of the currently produced results to the `result_stack`.\n             // We will produce all of the results of the inside of the `Delimited` and then we will\n@@ -391,6 +396,28 @@ fn lockstep_iter_size(\n                 _ => LockstepIterSize::Unconstrained,\n             }\n         }\n+        TokenTree::MetaVarExpr(_, ref expr) => {\n+            let default_rslt = LockstepIterSize::Unconstrained;\n+            let Some(ident) = expr.ident() else { return default_rslt; };\n+            let name = MacroRulesNormalizedIdent::new(ident.clone());\n+            match lookup_cur_matched(name, interpolations, repeats) {\n+                Some(MatchedSeq(ref ads)) => {\n+                    default_rslt.with(LockstepIterSize::Constraint(ads.len(), name))\n+                }\n+                _ => default_rslt,\n+            }\n+        }\n         TokenTree::Token(..) => LockstepIterSize::Unconstrained,\n     }\n }\n+\n+fn transcribe_metavar_expr<'a>(\n+    _cx: &ExtCtxt<'a>,\n+    _expr: mbe::MetaVarExpr,\n+    _interp: &FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n+    _repeats: &[(usize, usize)],\n+    _result: &mut Vec<TreeAndSpacing>,\n+    _sp: &DelimSpan,\n+) -> PResult<'a, ()> {\n+    Ok(())\n+}"}, {"sha": "a91f05587b2772e02ac29b1f3411c22876123acd", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -426,6 +426,8 @@ declare_features! (\n     (active, link_cfg, \"1.14.0\", Some(37406), None),\n     /// Allows using `reason` in lint attributes and the `#[expect(lint)]` lint check.\n     (active, lint_reasons, \"1.31.0\", Some(54503), None),\n+    /// Give access to additional metadata about declarative macro meta-variables.\n+    (active, macro_metavar_expr, \"1.61.0\", Some(83527), None),\n     /// Allows `#[marker]` on certain traits allowing overlapping implementations.\n     (active, marker_trait_attr, \"1.30.0\", Some(29864), None),\n     /// A minimal, sound subset of specialization intended to be used by the"}, {"sha": "0d87233d9d79da36b699e1bb04f9d41068a38253", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -845,6 +845,7 @@ symbols! {\n         macro_export,\n         macro_lifetime_matcher,\n         macro_literal_matcher,\n+        macro_metavar_expr,\n         macro_reexport,\n         macro_use,\n         macro_vis_matcher,"}, {"sha": "ed94c27cf05ca432a1b73a564435ac1e66dcbeb5", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/dollar-dollar-has-correct-behavior.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fdollar-dollar-has-correct-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fdollar-dollar-has-correct-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fdollar-dollar-has-correct-behavior.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -0,0 +1,28 @@\n+// run-pass\n+\n+#![feature(macro_metavar_expr)]\n+\n+macro_rules! nested {\n+    ( $a:ident ) => {\n+        macro_rules! $a {\n+            ( $$( $b:ident ),* ) => {\n+                $$(\n+                    macro_rules! $b {\n+                        ( $$$$( $c:ident ),* ) => {\n+                            $$$$(\n+                                fn $c() -> &'static str { stringify!($c) }\n+                            ),*\n+                        };\n+                    }\n+                )*\n+            };\n+        }\n+    };\n+}\n+\n+fn main() {\n+    nested!(a);\n+    a!(b);\n+    b!(c);\n+    assert_eq!(c(), \"c\");\n+}"}, {"sha": "6434ecc7e092df4ba67378218e209777aeea2b13", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/feature-gate-macro_metavar_expr.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Ffeature-gate-macro_metavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Ffeature-gate-macro_metavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Ffeature-gate-macro_metavar_expr.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+\n+#![feature(macro_metavar_expr)]\n+\n+macro_rules! ignore {\n+    ( $( $i:ident ),* ) => {{\n+        let array: [i32; 0] = [$( ${ignore(i)} )*];\n+        array\n+    }};\n+}\n+\n+fn main() {\n+    assert_eq!(ignore!(a, b, c), []);\n+}"}, {"sha": "cff6f29a1538637e2f08755f2d324e6b5816156d", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/required-feature.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -0,0 +1,9 @@\n+macro_rules! count {\n+    ( $( $e:stmt ),* ) => {\n+        ${ count(e) }\n+        //~^ ERROR meta-variable expressions are unstable\n+    };\n+}\n+\n+fn main() {\n+}"}, {"sha": "f573194479314fb875b2bec3b0a5909f4a1ffbfe", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/required-feature.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Frequired-feature.stderr?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: meta-variable expressions are unstable\n+  --> $DIR/required-feature.rs:3:10\n+   |\n+LL |         ${ count(e) }\n+   |          ^^^^^^^^^^^^\n+   |\n+   = note: see issue #83527 <https://github.com/rust-lang/rust/issues/83527> for more information\n+   = help: add `#![feature(macro_metavar_expr)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ea73fd0813c5bd249cc1b5c14497b07c46d53b08", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/syntax-errors.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.rs?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -0,0 +1,148 @@\n+#![feature(macro_metavar_expr)]\n+\n+// `curly` = Right hand side curly brackets\n+// `no_rhs_dollar` = No dollar sign at the right hand side meta variable \"function\"\n+// `round` = Left hand side round brackets\n+\n+macro_rules! curly__no_rhs_dollar__round {\n+    ( $( $i:ident ),* ) => { ${ count(i) } };\n+}\n+\n+macro_rules! curly__no_rhs_dollar__no_round {\n+    ( $i:ident ) => { ${ count(i) } };\n+}\n+\n+macro_rules! curly__rhs_dollar__round {\n+    ( $( $i:ident ),* ) => { ${ count($i) } };\n+    //~^ ERROR expected identifier, found `$`\n+    //~| ERROR expected expression, found `$`\n+}\n+\n+macro_rules! curly__rhs_dollar__no_round {\n+    ( $i:ident ) => { ${ count($i) } };\n+    //~^ ERROR expected identifier, found `$`\n+    //~| ERROR expected expression, found `$`\n+}\n+\n+macro_rules! no_curly__no_rhs_dollar__round {\n+    ( $( $i:ident ),* ) => { count(i) };\n+    //~^ ERROR cannot find function `count` in this scope\n+    //~| ERROR cannot find value `i` in this scope\n+}\n+\n+macro_rules! no_curly__no_rhs_dollar__no_round {\n+    ( $i:ident ) => { count(i) };\n+    //~^ ERROR cannot find function `count` in this scope\n+    //~| ERROR cannot find value `i` in this scope\n+}\n+\n+macro_rules! no_curly__rhs_dollar__round {\n+    ( $( $i:ident ),* ) => { count($i) };\n+    //~^ ERROR variable 'i' is still repeating at this depth\n+}\n+\n+macro_rules! no_curly__rhs_dollar__no_round {\n+    ( $i:ident ) => { count($i) };\n+    //~^ ERROR cannot find function `count` in this scope\n+}\n+\n+// Other scenarios\n+\n+macro_rules! dollar_dollar_in_the_lhs {\n+    ( $$ $a:ident ) => {\n+    //~^ ERROR unexpected token: $\n+    };\n+}\n+\n+macro_rules! extra_garbage_after_metavar {\n+    ( $( $i:ident ),* ) => {\n+        ${count() a b c}\n+        //~^ ERROR unexpected token: a\n+        //~| ERROR expected expression, found `$`\n+        ${count(i a b c)}\n+        //~^ ERROR unexpected token: a\n+        ${count(i, 1 a b c)}\n+        //~^ ERROR unexpected token: a\n+        ${count(i) a b c}\n+        //~^ ERROR unexpected token: a\n+\n+        ${ignore(i) a b c}\n+        //~^ ERROR unexpected token: a\n+        ${ignore(i a b c)}\n+        //~^ ERROR unexpected token: a\n+\n+        ${index() a b c}\n+        //~^ ERROR unexpected token: a\n+        ${index(1 a b c)}\n+        //~^ ERROR unexpected token: a\n+\n+        ${index() a b c}\n+        //~^ ERROR unexpected token: a\n+        ${index(1 a b c)}\n+        //~^ ERROR unexpected token: a\n+    };\n+}\n+\n+const IDX: usize = 1;\n+macro_rules! metavar_depth_is_not_literal {\n+    ( $( $i:ident ),* ) => { ${ index(IDX) } };\n+    //~^ ERROR meta-variable expression depth must be a literal\n+    //~| ERROR expected expression, found `$`\n+}\n+\n+macro_rules! metavar_in_the_lhs {\n+    ( ${ length() } ) => {\n+        //~^ ERROR unexpected token: {\n+        //~| ERROR expected one of: `*`, `+`, or `?`\n+    };\n+}\n+\n+macro_rules! metavar_token_without_ident {\n+    ( $( $i:ident ),* ) => { ${ ignore() } };\n+    //~^ ERROR expected identifier\n+    //~| ERROR expected expression, found `$`\n+}\n+\n+macro_rules! metavar_with_literal_suffix {\n+    ( $( $i:ident ),* ) => { ${ index(1u32) } };\n+    //~^ ERROR only unsuffixes integer literals are supported in meta-variable expressions\n+    //~| ERROR expected expression, found `$`\n+}\n+\n+macro_rules! metavar_without_parens {\n+    ( $( $i:ident ),* ) => { ${ count{i} } };\n+    //~^ ERROR meta-variable expression parameter must be wrapped in parentheses\n+    //~| ERROR expected expression, found `$`\n+}\n+\n+macro_rules! open_brackets_without_tokens {\n+    ( $( $i:ident ),* ) => { ${ {} } };\n+    //~^ ERROR expected expression, found `$`\n+    //~| ERROR expected identifier\n+}\n+\n+macro_rules! unknown_metavar {\n+    ( $( $i:ident ),* ) => { ${ aaaaaaaaaaaaaa(i) } };\n+    //~^ ERROR unrecognized meta-variable expression\n+    //~| ERROR expected expression\n+}\n+\n+fn main() {\n+    curly__no_rhs_dollar__round!(a, b, c);\n+    curly__no_rhs_dollar__no_round!(a);\n+    curly__rhs_dollar__round!(a, b, c);\n+    curly__rhs_dollar__no_round!(a);\n+    no_curly__no_rhs_dollar__round!(a, b, c);\n+    no_curly__no_rhs_dollar__no_round!(a);\n+    no_curly__rhs_dollar__round!(a, b, c);\n+    no_curly__rhs_dollar__no_round!(a);\n+    //~^ ERROR cannot find value `a` in this scope\n+\n+    extra_garbage_after_metavar!(a);\n+    unknown_metavar!(a);\n+    metavar_without_parens!(a);\n+    metavar_token_without_ident!(a);\n+    metavar_depth_is_not_literal!(a);\n+    metavar_with_literal_suffix!(a);\n+    open_brackets_without_tokens!(a)\n+}"}, {"sha": "dc8b7a668c4ee749abd8b61a28308187e55c6d72", "filename": "src/test/ui/macros/rfc-3086-metavar-expr/syntax-errors.stderr", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8073a88f35728289ef535cca5cf13302faba5972/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-3086-metavar-expr%2Fsyntax-errors.stderr?ref=8073a88f35728289ef535cca5cf13302faba5972", "patch": "@@ -0,0 +1,367 @@\n+error: expected identifier, found `$`\n+  --> $DIR/syntax-errors.rs:16:33\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ count($i) } };\n+   |                                 ^^^^^ - help: try removing `$`\n+\n+error: expected identifier, found `$`\n+  --> $DIR/syntax-errors.rs:22:26\n+   |\n+LL |     ( $i:ident ) => { ${ count($i) } };\n+   |                          ^^^^^ - help: try removing `$`\n+\n+error: unexpected token: $\n+  --> $DIR/syntax-errors.rs:52:8\n+   |\n+LL |     ( $$ $a:ident ) => {\n+   |        ^\n+\n+note: `$$` and meta-variable expressions are not allowed inside macro parameter definitions\n+  --> $DIR/syntax-errors.rs:52:8\n+   |\n+LL |     ( $$ $a:ident ) => {\n+   |        ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:59:19\n+   |\n+LL |         ${count() a b c}\n+   |                   ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:59:19\n+   |\n+LL |         ${count() a b c}\n+   |                   ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:62:19\n+   |\n+LL |         ${count(i a b c)}\n+   |                   ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:62:19\n+   |\n+LL |         ${count(i a b c)}\n+   |                   ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:64:22\n+   |\n+LL |         ${count(i, 1 a b c)}\n+   |                      ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:64:22\n+   |\n+LL |         ${count(i, 1 a b c)}\n+   |                      ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:66:20\n+   |\n+LL |         ${count(i) a b c}\n+   |                    ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:66:20\n+   |\n+LL |         ${count(i) a b c}\n+   |                    ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:69:21\n+   |\n+LL |         ${ignore(i) a b c}\n+   |                     ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:69:21\n+   |\n+LL |         ${ignore(i) a b c}\n+   |                     ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:71:20\n+   |\n+LL |         ${ignore(i a b c)}\n+   |                    ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:71:20\n+   |\n+LL |         ${ignore(i a b c)}\n+   |                    ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:74:19\n+   |\n+LL |         ${index() a b c}\n+   |                   ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:74:19\n+   |\n+LL |         ${index() a b c}\n+   |                   ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:76:19\n+   |\n+LL |         ${index(1 a b c)}\n+   |                   ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:76:19\n+   |\n+LL |         ${index(1 a b c)}\n+   |                   ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:79:19\n+   |\n+LL |         ${index() a b c}\n+   |                   ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:79:19\n+   |\n+LL |         ${index() a b c}\n+   |                   ^\n+\n+error: unexpected token: a\n+  --> $DIR/syntax-errors.rs:81:19\n+   |\n+LL |         ${index(1 a b c)}\n+   |                   ^\n+   |\n+note: meta-variable expression must not have trailing tokens\n+  --> $DIR/syntax-errors.rs:81:19\n+   |\n+LL |         ${index(1 a b c)}\n+   |                   ^\n+\n+error: meta-variable expression depth must be a literal\n+  --> $DIR/syntax-errors.rs:88:33\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ index(IDX) } };\n+   |                                 ^^^^^\n+\n+error: unexpected token: {\n+  --> $DIR/syntax-errors.rs:94:8\n+   |\n+LL |     ( ${ length() } ) => {\n+   |        ^^^^^^^^^^^^\n+\n+note: `$$` and meta-variable expressions are not allowed inside macro parameter definitions\n+  --> $DIR/syntax-errors.rs:94:8\n+   |\n+LL |     ( ${ length() } ) => {\n+   |        ^^^^^^^^^^^^\n+\n+error: expected one of: `*`, `+`, or `?`\n+  --> $DIR/syntax-errors.rs:94:8\n+   |\n+LL |     ( ${ length() } ) => {\n+   |        ^^^^^^^^^^^^\n+\n+error: expected identifier\n+  --> $DIR/syntax-errors.rs:101:33\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ ignore() } };\n+   |                                 ^^^^^^\n+\n+error: only unsuffixes integer literals are supported in meta-variable expressions\n+  --> $DIR/syntax-errors.rs:107:33\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ index(1u32) } };\n+   |                                 ^^^^^\n+\n+error: meta-variable expression parameter must be wrapped in parentheses\n+  --> $DIR/syntax-errors.rs:113:33\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ count{i} } };\n+   |                                 ^^^^^\n+\n+error: expected identifier\n+  --> $DIR/syntax-errors.rs:119:31\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ {} } };\n+   |                               ^^^^^^\n+\n+error: unrecognized meta-variable expression\n+  --> $DIR/syntax-errors.rs:125:33\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ aaaaaaaaaaaaaa(i) } };\n+   |                                 ^^^^^^^^^^^^^^ help: supported expressions are count, ignore, index and length\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:16:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ count($i) } };\n+   |                              ^ expected expression\n+...\n+LL |     curly__rhs_dollar__round!(a, b, c);\n+   |     ---------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `curly__rhs_dollar__round` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:22:23\n+   |\n+LL |     ( $i:ident ) => { ${ count($i) } };\n+   |                       ^ expected expression\n+...\n+LL |     curly__rhs_dollar__no_round!(a);\n+   |     ------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `curly__rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: variable 'i' is still repeating at this depth\n+  --> $DIR/syntax-errors.rs:40:36\n+   |\n+LL |     ( $( $i:ident ),* ) => { count($i) };\n+   |                                    ^^\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:59:9\n+   |\n+LL |         ${count() a b c}\n+   |         ^ expected expression\n+...\n+LL |     extra_garbage_after_metavar!(a);\n+   |     ------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `extra_garbage_after_metavar` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:125:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ aaaaaaaaaaaaaa(i) } };\n+   |                              ^ expected expression\n+...\n+LL |     unknown_metavar!(a);\n+   |     ------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `unknown_metavar` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:113:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ count{i} } };\n+   |                              ^ expected expression\n+...\n+LL |     metavar_without_parens!(a);\n+   |     -------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `metavar_without_parens` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:101:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ ignore() } };\n+   |                              ^ expected expression\n+...\n+LL |     metavar_token_without_ident!(a);\n+   |     ------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `metavar_token_without_ident` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:88:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ index(IDX) } };\n+   |                              ^ expected expression\n+...\n+LL |     metavar_depth_is_not_literal!(a);\n+   |     -------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `metavar_depth_is_not_literal` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:107:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ index(1u32) } };\n+   |                              ^ expected expression\n+...\n+LL |     metavar_with_literal_suffix!(a);\n+   |     ------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `metavar_with_literal_suffix` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expected expression, found `$`\n+  --> $DIR/syntax-errors.rs:119:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { ${ {} } };\n+   |                              ^ expected expression\n+...\n+LL |     open_brackets_without_tokens!(a)\n+   |     -------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `open_brackets_without_tokens` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find function `count` in this scope\n+  --> $DIR/syntax-errors.rs:28:30\n+   |\n+LL |     ( $( $i:ident ),* ) => { count(i) };\n+   |                              ^^^^^ not found in this scope\n+...\n+LL |     no_curly__no_rhs_dollar__round!(a, b, c);\n+   |     ---------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `no_curly__no_rhs_dollar__round` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find value `i` in this scope\n+  --> $DIR/syntax-errors.rs:28:36\n+   |\n+LL |     ( $( $i:ident ),* ) => { count(i) };\n+   |                                    ^ not found in this scope\n+...\n+LL |     no_curly__no_rhs_dollar__round!(a, b, c);\n+   |     ---------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `no_curly__no_rhs_dollar__round` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find function `count` in this scope\n+  --> $DIR/syntax-errors.rs:34:23\n+   |\n+LL |     ( $i:ident ) => { count(i) };\n+   |                       ^^^^^ not found in this scope\n+...\n+LL |     no_curly__no_rhs_dollar__no_round!(a);\n+   |     ------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `no_curly__no_rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find value `i` in this scope\n+  --> $DIR/syntax-errors.rs:34:29\n+   |\n+LL |     ( $i:ident ) => { count(i) };\n+   |                             ^ not found in this scope\n+...\n+LL |     no_curly__no_rhs_dollar__no_round!(a);\n+   |     ------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `no_curly__no_rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find function `count` in this scope\n+  --> $DIR/syntax-errors.rs:45:23\n+   |\n+LL |     ( $i:ident ) => { count($i) };\n+   |                       ^^^^^ not found in this scope\n+...\n+LL |     no_curly__rhs_dollar__no_round!(a);\n+   |     ---------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `no_curly__rhs_dollar__no_round` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/syntax-errors.rs:138:37\n+   |\n+LL |     no_curly__rhs_dollar__no_round!(a);\n+   |                                     ^ not found in this scope\n+\n+error: aborting due to 37 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}]}