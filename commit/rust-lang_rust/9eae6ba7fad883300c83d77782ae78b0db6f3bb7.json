{"sha": "9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYWU2YmE3ZmFkODgzMzAwYzgzZDc3NzgyYWU3OGIwZGI2ZjNiYjc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-20T07:26:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: remove unnecessary ItemSubsts wrapper.", "tree": {"sha": "33b88d3c873792f000023e1c458a1541e6fb3be8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33b88d3c873792f000023e1c458a1541e6fb3be8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "html_url": "https://github.com/rust-lang/rust/commit/9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "html_url": "https://github.com/rust-lang/rust/commit/a65ced5d161d31e7e5b097b36bff0f51ec0843bc"}], "stats": {"total": 122, "additions": 27, "deletions": 95}, "files": [{"sha": "2615fdd86d68d68f20af3e01150ed1d7463c3717", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -19,8 +19,6 @@ use std::mem;\n use syntax_pos::symbol::InternedString;\n use ty;\n \n-impl_stable_hash_for!(struct ty::ItemSubsts<'tcx> { substs });\n-\n impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for &'tcx ty::Slice<T>\n     where T: HashStable<StableHashingContext<'a, 'tcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -602,7 +600,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'\n         let ty::TypeckTables {\n             ref type_relative_path_defs,\n             ref node_types,\n-            ref item_substs,\n+            ref node_substs,\n             ref adjustments,\n             ref method_map,\n             ref upvar_capture_map,\n@@ -623,7 +621,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             ich::hash_stable_nodemap(hcx, hasher, type_relative_path_defs);\n             ich::hash_stable_nodemap(hcx, hasher, node_types);\n-            ich::hash_stable_nodemap(hcx, hasher, item_substs);\n+            ich::hash_stable_nodemap(hcx, hasher, node_substs);\n             ich::hash_stable_nodemap(hcx, hasher, adjustments);\n             ich::hash_stable_nodemap(hcx, hasher, method_map);\n             ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {"}, {"sha": "a0ad3da45e07c616803497c0bb5f3d82d29a40db", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -218,7 +218,7 @@ pub struct TypeckTables<'tcx> {\n     /// of this node.  This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n+    pub node_substs: NodeMap<&'tcx Substs<'tcx>>,\n \n     pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n \n@@ -273,7 +273,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         TypeckTables {\n             type_relative_path_defs: NodeMap(),\n             node_types: FxHashMap(),\n-            item_substs: NodeMap(),\n+            node_substs: NodeMap(),\n             adjustments: NodeMap(),\n             method_map: FxHashMap(),\n             upvar_capture_map: FxHashMap(),\n@@ -313,8 +313,8 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_types.get(&id).cloned()\n     }\n \n-    pub fn node_id_item_substs(&self, id: NodeId) -> Option<&'tcx Substs<'tcx>> {\n-        self.item_substs.get(&id).map(|ts| ts.substs)\n+    pub fn node_substs(&self, id: NodeId) -> &'tcx Substs<'tcx> {\n+        self.node_substs.get(&id).cloned().unwrap_or(Substs::empty())\n     }\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function"}, {"sha": "a45f85db4c25752e16423b5f79dafbf105d6894e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -1809,13 +1809,6 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     }\n }\n \n-/// Records the substitutions used to translate the polytype for an\n-/// item into the monotype of an item reference.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct ItemSubsts<'tcx> {\n-    pub substs: &'tcx Substs<'tcx>,\n-}\n-\n #[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum ClosureKind {\n     // Warning: Ordering is significant here! The ordering is chosen\n@@ -1893,12 +1886,6 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> ItemSubsts<'tcx> {\n-    pub fn is_noop(&self) -> bool {\n-        self.substs.is_noop()\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,"}, {"sha": "9336e7beae20a5b36c4c2422d5c2db9780d4516e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -220,17 +220,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n-    type Lifted = ty::ItemSubsts<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| {\n-            ty::ItemSubsts {\n-                substs: substs\n-            }\n-        })\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -654,18 +643,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ItemSubsts {\n-            substs: self.substs.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.substs.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "6f6d48cdf58af1209defc6050b0d8d522e4fc04c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -361,12 +361,6 @@ impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ItemSubsts<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ItemSubsts({:?})\", self.substs)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // when printing out the debug representation, we don't need"}, {"sha": "a6b39f22277de0c852024512b15f0ca6c43d3c06", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -286,8 +286,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-        let substs = cx.tables.node_id_item_substs(e.id)\n-            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+        let substs = cx.tables.node_substs(e.id);\n \n         // Avoid applying substitutions if they're empty, that'd ICE.\n         let substs = if cx.substs.is_empty() {"}, {"sha": "d8e76218a4a0b555e844198cfabe7e0a8dfd89f7", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -585,8 +585,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let tcx = self.tcx.global_tcx();\n-                let substs = self.tables.node_id_item_substs(id)\n-                    .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                let substs = self.tables.node_substs(id);\n                 match eval::lookup_const_by_id(tcx, def_id, substs) {\n                     Some((def_id, _substs)) => {\n                         // Enter the inlined constant's tables temporarily."}, {"sha": "8a374358bb9981d00e48c048a1ca8108d412e5e2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -911,8 +911,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     };\n                     match def {\n                         Def::Method(def_id) => {\n-                            let substs = cx.tables.node_id_item_substs(callee.id)\n-                                .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n+                            let substs = cx.tables.node_substs(callee.id);\n                             method_call_refers_to_method(\n                                 cx.tcx, method, def_id, substs, id)\n                         }"}, {"sha": "c11cd38fe3437ed94be20d65be6a629e5fc6a48f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -297,8 +297,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tables().node_id_item_substs(fun.id)\n-                        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n+                    let substs = cx.tables().node_substs(fun.id);\n                     let field_refs = args.iter()\n                         .enumerate()\n                         .map(|(idx, e)| {\n@@ -735,8 +734,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tables().node_id_item_substs(expr.id)\n-        .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n+    let substs = cx.tables().node_substs(expr.id);\n     match def {\n         // A regular function, constructor function or a constant.\n         Def::Fn(def_id) |"}, {"sha": "0b0233103ef7bdf1cef214de6bb6de0cca969db4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -52,7 +52,7 @@ can be broken down into several distinct phases:\n \n While type checking a function, the intermediate types for the\n expressions, blocks, and so forth contained within the function are\n-stored in `fcx.node_types` and `fcx.item_substs`.  These types\n+stored in `fcx.node_types` and `fcx.node_substs`.  These types\n may contain unresolved type variables.  After type checking is\n complete, the functions in the writeback module are used to take the\n types from this table, resolve them, and then write them into their\n@@ -1758,14 +1758,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n-        if !substs.substs.is_noop() {\n+    pub fn write_substs(&self, node_id: ast::NodeId, substs: &'tcx Substs<'tcx>) {\n+        if !substs.is_noop() {\n             debug!(\"write_substs({}, {:?}) in fcx {}\",\n                    node_id,\n                    substs,\n                    self.tag());\n \n-            self.tables.borrow_mut().item_substs.insert(node_id, substs);\n+            self.tables.borrow_mut().node_substs.insert(node_id, substs);\n         }\n     }\n \n@@ -1959,16 +1959,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn opt_node_ty_substs<F>(&self,\n-                                 id: ast::NodeId,\n-                                 f: F) where\n-        F: FnOnce(&ty::ItemSubsts<'tcx>),\n-    {\n-        if let Some(s) = self.tables.borrow().item_substs.get(&id) {\n-            f(s);\n-        }\n-    }\n-\n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n@@ -3550,9 +3540,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n-              self.opt_node_ty_substs(expr.id, |item_substs| {\n-                  self.add_wf_bounds(&item_substs.substs, expr);\n-              });\n+              let substs = self.tables.borrow().node_substs(expr.id);\n+              self.add_wf_bounds(substs, expr);\n \n               ty\n           }\n@@ -4375,9 +4364,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(node_id, ty);\n-                self.write_substs(node_id, ty::ItemSubsts {\n-                    substs: self.tcx.intern_substs(&[])\n-                });\n                 return ty;\n             }\n             _ => {}\n@@ -4509,9 +4495,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_substs(node_id, ty::ItemSubsts {\n-            substs: substs\n-        });\n+        self.write_substs(node_id, substs);\n         ty_substituted\n     }\n "}, {"sha": "2fae9d8e70e5c7f27def2994b974a1837137e87c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -608,10 +608,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                expr, self.repeating_scope);\n         match expr.node {\n             hir::ExprPath(_) => {\n-                self.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n-                    let origin = infer::ParameterOrigin::Path;\n-                    self.substs_wf_in_scope(origin, &item_substs.substs, expr.span, expr_region);\n-                });\n+                let substs = self.tables.borrow().node_substs(expr.id);\n+                let origin = infer::ParameterOrigin::Path;\n+                self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             }\n \n             hir::ExprCall(ref callee, ref args) => {"}, {"sha": "dcdfed6cbd888e98196a1aea8aaa4bce175baad8", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9eae6ba7fad883300c83d77782ae78b0db6f3bb7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9eae6ba7fad883300c83d77782ae78b0db6f3bb7", "patch": "@@ -295,14 +295,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         debug!(\"Node {} has type {:?}\", node_id, n_ty);\n \n         // Resolve any substitutions\n-        self.fcx.opt_node_ty_substs(node_id, |item_substs| {\n-            let item_substs = self.resolve(item_substs, &span);\n-            if !item_substs.is_noop() {\n-                debug!(\"write_substs_to_tcx({}, {:?})\", node_id, item_substs);\n-                assert!(!item_substs.substs.needs_infer());\n-                self.tables.item_substs.insert(node_id, item_substs);\n-            }\n-        });\n+        if let Some(&substs) = self.fcx.tables.borrow().node_substs.get(&node_id) {\n+            let substs = self.resolve(&substs, &span);\n+            debug!(\"write_substs_to_tcx({}, {:?})\", node_id, substs);\n+            assert!(!substs.needs_infer());\n+            self.tables.node_substs.insert(node_id, substs);\n+        }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, node_id: ast::NodeId) {"}]}