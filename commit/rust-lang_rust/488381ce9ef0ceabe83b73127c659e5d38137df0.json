{"sha": "488381ce9ef0ceabe83b73127c659e5d38137df0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ODM4MWNlOWVmMGNlYWJlODNiNzMxMjdjNjU5ZTVkMzgxMzdkZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-28T15:54:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-28T15:54:12Z"}, "message": "Auto merge of #64419 - wesleywiser:const_prop_use_ecx, r=oli-obk\n\nDeduplicate some code between miri and const prop\n\nr? @oli-obk", "tree": {"sha": "52f815c3f1c7004a270ba8fafe2668f3a511916f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52f815c3f1c7004a270ba8fafe2668f3a511916f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/488381ce9ef0ceabe83b73127c659e5d38137df0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/488381ce9ef0ceabe83b73127c659e5d38137df0", "html_url": "https://github.com/rust-lang/rust/commit/488381ce9ef0ceabe83b73127c659e5d38137df0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/488381ce9ef0ceabe83b73127c659e5d38137df0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f00b949615b1faa7feec95d58b087d146d3198", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f00b949615b1faa7feec95d58b087d146d3198", "html_url": "https://github.com/rust-lang/rust/commit/18f00b949615b1faa7feec95d58b087d146d3198"}, {"sha": "ba2d6c42fc4ca5c4e590c133ef91412507b7a640", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2d6c42fc4ca5c4e590c133ef91412507b7a640", "html_url": "https://github.com/rust-lang/rust/commit/ba2d6c42fc4ca5c4e590c133ef91412507b7a640"}], "stats": {"total": 679, "additions": 425, "deletions": 254}, "files": [{"sha": "71967b513a049455ec509bf8a730a6e45b63cf40", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -389,6 +389,10 @@ pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n+    /// FIXME(#64506) Error used to work around accessing projections of\n+    /// uninhabited types.\n+    UninhabitedValue,\n+\n     // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -552,6 +556,8 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     not a power of two\"),\n             Unsupported(ref msg) =>\n                 write!(f, \"{}\", msg),\n+            UninhabitedValue =>\n+                write!(f, \"tried to use an uninhabited value\"),\n         }\n     }\n }"}, {"sha": "bb02b99dd8d87df01fc721a9841af1d446e666cc", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -21,7 +21,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar, Pointer,\n-    RawConst, ConstValue,\n+    RawConst, ConstValue, Machine,\n     InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind, Memory,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n@@ -41,7 +41,7 @@ const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n /// that inform us about the generic bounds of the constant. E.g., using an associated constant\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n+fn mk_eval_cx<'mir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -169,7 +169,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n }\n \n #[derive(Clone, Debug)]\n-enum ConstEvalError {\n+pub enum ConstEvalError {\n     NeedsRfc(String),\n }\n \n@@ -521,8 +521,8 @@ pub fn const_variant_index<'tcx>(\n /// Turn an interpreter error into something to report to the user.\n /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n /// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx>(\n-    ecx: &InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n+    ecx: &InterpCx<'mir, 'tcx, M>,\n     mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();"}, {"sha": "c30c59bbf10c8a57f553e5467587a0804fe262c9", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -12,6 +12,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n     InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n+    Frame, Operand,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -184,6 +185,22 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n+    /// Called to read the specified `local` from the `frame`.\n+    fn access_local(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        local: mir::Local,\n+    ) -> InterpResult<'tcx, Operand<Self::PointerTag>> {\n+        frame.locals[local].access()\n+    }\n+\n+    /// Called before a `StaticKind::Static` value is accessed.\n+    fn before_access_static(\n+        _allocation: &Allocation,\n+    ) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra."}, {"sha": "924474c53175c3407bddcbe47f7c29ad9712cae2", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -462,6 +462,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // Make sure we use the ID of the resolved memory, not the lazy one!\n                     let id = raw_const.alloc_id;\n                     let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+\n+                    M::before_access_static(allocation)?;\n                     Cow::Borrowed(allocation)\n                 }\n             }"}, {"sha": "861e5ebef877deb024ed8654ff39c56d4b706b5e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -458,7 +458,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Do not read from ZST, they might not be initialized\n             Operand::Immediate(Scalar::zst().into())\n         } else {\n-            frame.locals[local].access()?\n+            M::access_local(&self, frame, local)?\n         };\n         Ok(OpTy { op, layout })\n     }\n@@ -481,7 +481,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n     // avoid allocations.\n-    pub(super) fn eval_place_to_op(\n+    pub fn eval_place_to_op(\n         &self,\n         place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,"}, {"sha": "1166ca9bf24443b30c8a550aad2f0708b8ca7021", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -9,7 +9,7 @@ use rustc::mir;\n use rustc::mir::interpret::truncate;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{\n-    self, Size, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx, PrimitiveExt\n+    self, Size, Abi, Align, LayoutOf, TyLayout, HasDataLayout, VariantIdx, PrimitiveExt\n };\n use rustc::ty::TypeFoldable;\n \n@@ -385,6 +385,10 @@ where\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {\n+                // FIXME(#64506) `UninhabitedValue` can be removed when this issue is resolved\n+                if base.layout.abi == Abi::Uninhabited {\n+                    throw_unsup!(UninhabitedValue);\n+                }\n                 assert!(field < count as u64,\n                         \"Tried to access field {} of union with {} fields\", field, count);\n                 // Offset is always 0"}, {"sha": "daca7a25787ca5d734bb137b3efe93fc5fa17e3b", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -132,7 +132,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ///\n     /// There is no separate `eval_rvalue` function. Instead, the code for handling each rvalue\n     /// type writes its results directly into the memory specified by the place.\n-    fn eval_rvalue_into_place(\n+    pub fn eval_rvalue_into_place(\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n         place: &mir::Place<'tcx>,"}, {"sha": "612822b6d9d34362d41a9d0d1170023fb2089ccb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 292, "deletions": 218, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -1,34 +1,38 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n \n use rustc::hir::def::DefKind;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n-    Local, NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n-    TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp, ProjectionElem,\n-    SourceScope, SourceScopeLocalData, LocalDecl,\n+    Local, NullOp, UnOp, StatementKind, Statement, LocalKind,\n+    TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp,\n+    SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n };\n-use rustc::mir::interpret::{Scalar, GlobalId, InterpResult, PanicInfo};\n+use rustc::mir::interpret::{Scalar, InterpResult, PanicInfo};\n use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n+use syntax::ast::Mutability;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n use crate::interpret::{\n     self, InterpCx, ScalarMaybeUndef, Immediate, OpTy,\n-    ImmTy, MemoryKind, StackPopCleanup, LocalValue, LocalState,\n-};\n-use crate::const_eval::{\n-    CompileTimeInterpreter, error_to_const_error, mk_eval_cx,\n+    StackPopCleanup, LocalValue, LocalState, AllocId, Frame,\n+    Allocation, MemoryKind, ImmTy, Pointer, Memory, PlaceTy,\n+    Operand as InterpOperand,\n };\n+use crate::const_eval::error_to_const_error;\n use crate::transform::{MirPass, MirSource};\n \n pub struct ConstProp;\n@@ -57,6 +61,14 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             return\n         }\n \n+        let is_generator = tcx.type_of(source.def_id()).is_generator();\n+        // FIXME(welseywiser) const prop doesn't work on generators because of query cycles\n+        // computing their layout.\n+        if is_generator {\n+            trace!(\"ConstProp skipped for generator {:?}\", source.def_id());\n+            return\n+        }\n+\n         trace!(\"ConstProp starting for {:?}\", source.def_id());\n \n         // Steal some data we need from `body`.\n@@ -103,11 +115,154 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n     }\n }\n \n+struct ConstPropMachine;\n+\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n+    type MemoryKinds= !;\n+    type PointerTag = ();\n+    type ExtraFnVal = !;\n+\n+    type FrameExtra = ();\n+    type MemoryExtra = ();\n+    type AllocExtra = ();\n+\n+    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n+\n+    const STATIC_KIND: Option<!> = None;\n+\n+    const CHECK_ALIGN: bool = false;\n+\n+    #[inline(always)]\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        false\n+    }\n+\n+    fn find_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[OpTy<'tcx>],\n+        _dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<BasicBlock>,\n+    ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n+        Ok(None)\n+    }\n+\n+    fn call_extra_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: !,\n+        _args: &[OpTy<'tcx>],\n+        _dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        match fn_val {}\n+    }\n+\n+    fn call_intrinsic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[OpTy<'tcx>],\n+        _dest: PlaceTy<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        throw_unsup_format!(\"calling intrinsics isn't supported in ConstProp\");\n+    }\n+\n+    fn ptr_to_int(\n+        _mem: &Memory<'mir, 'tcx, Self>,\n+        _ptr: Pointer,\n+    ) -> InterpResult<'tcx, u64> {\n+        throw_unsup_format!(\"ptr-to-int casts aren't supported in ConstProp\");\n+    }\n+\n+    fn binary_ptr_op(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: BinOp,\n+        _left: ImmTy<'tcx>,\n+        _right: ImmTy<'tcx>,\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n+        // We can't do this because aliasing of memory can differ between const eval and llvm\n+        throw_unsup_format!(\"pointer arithmetic or comparisons aren't supported in ConstProp\");\n+    }\n+\n+    fn find_foreign_static(\n+        _tcx: TyCtxt<'tcx>,\n+        _def_id: DefId,\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n+        throw_unsup!(ReadForeignStatic)\n+    }\n+\n+    #[inline(always)]\n+    fn tag_allocation<'b>(\n+        _memory_extra: &(),\n+        _id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        _kind: Option<MemoryKind<!>>,\n+    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+        // We do not use a tag so we can just cheaply forward the allocation\n+        (alloc, ())\n+    }\n+\n+    #[inline(always)]\n+    fn tag_static_base_pointer(\n+        _memory_extra: &(),\n+        _id: AllocId,\n+    ) -> Self::PointerTag {\n+        ()\n+    }\n+\n+    fn box_alloc(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _dest: PlaceTy<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        throw_unsup_format!(\"can't const prop `box` keyword\");\n+    }\n+\n+    fn access_local(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        local: Local,\n+    ) -> InterpResult<'tcx, InterpOperand<Self::PointerTag>> {\n+        let l = &frame.locals[local];\n+\n+        if l.value == LocalValue::Uninitialized {\n+            throw_unsup_format!(\"tried to access an uninitialized local\");\n+        }\n+\n+        l.access()\n+    }\n+\n+    fn before_access_static(\n+        allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+    ) -> InterpResult<'tcx> {\n+        // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n+        // the memory behind that in the future), then we can't const prop it\n+        if allocation.mutability == Mutability::Mutable || allocation.relocations().len() > 0 {\n+            throw_unsup_format!(\"can't eval mutable statics in ConstProp\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Called immediately before a stack frame gets popped.\n+    #[inline(always)]\n+    fn stack_pop(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+}\n+\n type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n-    ecx: InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    ecx: InterpCx<'mir, 'tcx, ConstPropMachine>,\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     can_const_prop: IndexVec<Local, bool>,\n@@ -150,7 +305,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let def_id = source.def_id();\n         let param_env = tcx.param_env(def_id);\n         let span = tcx.def_span(def_id);\n-        let mut ecx = mk_eval_cx(tcx, span, param_env);\n+        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n         let can_const_prop = CanConstProp::check(body);\n \n         ecx.push_stack_frame(\n@@ -282,53 +437,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        let mut eval = match place.base {\n-            PlaceBase::Local(loc) => self.get_const(loc).clone()?,\n-            PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted, _), ..}) => {\n-                let generics = self.tcx.generics_of(self.source.def_id());\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n-                }\n-                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                let instance = Instance::new(self.source.def_id(), substs);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(promoted),\n-                };\n-                let res = self.use_ecx(source_info, |this| {\n-                    this.ecx.const_eval_raw(cid)\n-                })?;\n-                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                res.into()\n-            }\n-            _ => return None,\n-        };\n-\n-        for (i, elem) in place.projection.iter().enumerate() {\n-            let proj_base = &place.projection[..i];\n-\n-            match elem {\n-                ProjectionElem::Field(field, _) => {\n-                    trace!(\"field proj on {:?}\", proj_base);\n-                    eval = self.use_ecx(source_info, |this| {\n-                        this.ecx.operand_field(eval, field.index() as u64)\n-                    })?;\n-                },\n-                ProjectionElem::Deref => {\n-                    trace!(\"processing deref\");\n-                    eval = self.use_ecx(source_info, |this| {\n-                        this.ecx.deref_operand(eval)\n-                    })?.into();\n-                }\n-                // We could get more projections by using e.g., `operand_projection`,\n-                // but we do not even have the stack frame set up properly so\n-                // an `Index` projection would throw us off-track.\n-                _ => return None,\n-            }\n-        }\n-\n-        Some(eval)\n+        self.use_ecx(source_info, |this| {\n+            this.ecx.eval_place_to_op(place, None)\n+        })\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n@@ -344,166 +455,118 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         place_layout: TyLayout<'tcx>,\n         source_info: SourceInfo,\n+        place: &Place<'tcx>,\n     ) -> Option<Const<'tcx>> {\n         let span = source_info.span;\n-        match *rvalue {\n-            Rvalue::Use(ref op) => {\n-                self.eval_operand(op, source_info)\n-            },\n-            Rvalue::Ref(_, _, ref place) => {\n-                let src = self.eval_place(place, source_info)?;\n-                let mplace = src.try_as_mplace().ok()?;\n-                Some(ImmTy::from_scalar(mplace.ptr.into(), place_layout).into())\n-            },\n+\n+        // if this isn't a supported operation, then return None\n+        match rvalue {\n             Rvalue::Repeat(..) |\n             Rvalue::Aggregate(..) |\n             Rvalue::NullaryOp(NullOp::Box, _) |\n-            Rvalue::Discriminant(..) => None,\n-\n-            Rvalue::Cast(kind, ref operand, _) => {\n-                let op = self.eval_operand(operand, source_info)?;\n-                self.use_ecx(source_info, |this| {\n-                    let dest = this.ecx.allocate(place_layout, MemoryKind::Stack);\n-                    this.ecx.cast(op, kind, dest.into())?;\n-                    Ok(dest.into())\n-                })\n-            },\n-            Rvalue::Len(ref place) => {\n-                let place = self.eval_place(&place, source_info)?;\n-                let mplace = place.try_as_mplace().ok()?;\n-\n-                if let ty::Slice(_) = mplace.layout.ty.kind {\n-                    let len = mplace.meta.unwrap().to_usize(&self.ecx).unwrap();\n-\n-                    Some(ImmTy::from_uint(\n-                        len,\n-                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    ).into())\n-                } else {\n-                    trace!(\"not slice: {:?}\", mplace.layout.ty.kind);\n-                    None\n-                }\n-            },\n-            Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n-                    ImmTy::from_uint(\n-                        n,\n-                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    ).into()\n-                ))\n-            }\n-            Rvalue::UnaryOp(op, ref arg) => {\n-                let def_id = if self.tcx.is_closure(self.source.def_id()) {\n-                    self.tcx.closure_base_def_id(self.source.def_id())\n-                } else {\n-                    self.source.def_id()\n-                };\n-                let generics = self.tcx.generics_of(def_id);\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n-                }\n+            Rvalue::Discriminant(..) => return None,\n+\n+            Rvalue::Use(_) |\n+            Rvalue::Len(_) |\n+            Rvalue::Cast(..) |\n+            Rvalue::NullaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::Ref(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::BinaryOp(..) => { }\n+        }\n \n-                let arg = self.eval_operand(arg, source_info)?;\n-                let oflo_check = self.tcx.sess.overflow_checks();\n-                let val = self.use_ecx(source_info, |this| {\n-                    let prim = this.ecx.read_immediate(arg)?;\n-                    match op {\n-                        UnOp::Neg => {\n-                            // We check overflow in debug mode already\n-                            // so should only check in release mode.\n-                            if !oflo_check\n-                            && prim.layout.ty.is_signed()\n-                            && prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                                throw_panic!(OverflowNeg)\n-                            }\n-                        }\n-                        UnOp::Not => {\n-                            // Cannot overflow\n+        // perform any special checking for specific Rvalue types\n+        if let Rvalue::UnaryOp(op, arg) = rvalue {\n+            trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n+            let overflow_check = self.tcx.sess.overflow_checks();\n+\n+            self.use_ecx(source_info, |this| {\n+                // We check overflow in debug mode already\n+                // so should only check in release mode.\n+                if *op == UnOp::Neg && !overflow_check {\n+                    let ty = arg.ty(&this.local_decls, this.tcx);\n+\n+                    if ty.is_integral() {\n+                        let arg = this.ecx.eval_operand(arg, None)?;\n+                        let prim = this.ecx.read_immediate(arg)?;\n+                        // Need to do overflow check here: For actual CTFE, MIR\n+                        // generation emits code that does this before calling the op.\n+                        if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n+                            throw_panic!(OverflowNeg)\n                         }\n                     }\n-                    // Now run the actual operation.\n-                    this.ecx.unary_op(op, prim)\n-                })?;\n-                Some(val.into())\n-            }\n-            Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n-            Rvalue::BinaryOp(op, ref left, ref right) => {\n-                trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n-                let right = self.eval_operand(right, source_info)?;\n-                let def_id = if self.tcx.is_closure(self.source.def_id()) {\n-                    self.tcx.closure_base_def_id(self.source.def_id())\n-                } else {\n-                    self.source.def_id()\n-                };\n-                let generics = self.tcx.generics_of(def_id);\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n+                }\n+\n+                Ok(())\n+            })?;\n+        } else if let Rvalue::BinaryOp(op, left, right) = rvalue {\n+            trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n+\n+            let r = self.use_ecx(source_info, |this| {\n+                this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n+            })?;\n+            if *op == BinOp::Shr || *op == BinOp::Shl {\n+                let left_bits = place_layout.size.bits();\n+                let right_size = r.layout.size;\n+                let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n+                if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n+                    let source_scope_local_data = match self.source_scope_local_data {\n+                        ClearCrossCrate::Set(ref data) => data,\n+                        ClearCrossCrate::Clear => return None,\n+                    };\n+                    let dir = if *op == BinOp::Shr {\n+                        \"right\"\n+                    } else {\n+                        \"left\"\n+                    };\n+                    let hir_id = source_scope_local_data[source_info.scope].lint_root;\n+                    self.tcx.lint_hir(\n+                        ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n+                        hir_id,\n+                        span,\n+                        &format!(\"attempt to shift {} with overflow\", dir));\n                     return None;\n                 }\n+            }\n+            self.use_ecx(source_info, |this| {\n+                let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n+                let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n+\n+                // We check overflow in debug mode already\n+                // so should only check in release mode.\n+                if !this.tcx.sess.overflow_checks() && overflow {\n+                    let err = err_panic!(Overflow(*op)).into();\n+                    return Err(err);\n+                }\n \n-                let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(right)\n-                })?;\n-                if op == BinOp::Shr || op == BinOp::Shl {\n-                    let left_ty = left.ty(&self.local_decls, self.tcx);\n-                    let left_bits = self\n-                        .tcx\n-                        .layout_of(self.param_env.and(left_ty))\n-                        .unwrap()\n-                        .size\n-                        .bits();\n-                    let right_size = right.layout.size;\n-                    let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n-                    if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n-                        let source_scope_local_data = match self.source_scope_local_data {\n-                            ClearCrossCrate::Set(ref data) => data,\n-                            ClearCrossCrate::Clear => return None,\n-                        };\n-                        let dir = if op == BinOp::Shr {\n-                            \"right\"\n-                        } else {\n-                            \"left\"\n-                        };\n-                        let hir_id = source_scope_local_data[source_info.scope].lint_root;\n-                        self.tcx.lint_hir(\n-                            ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                            hir_id,\n-                            span,\n-                            &format!(\"attempt to shift {} with overflow\", dir));\n-                        return None;\n-                    }\n+                Ok(())\n+            })?;\n+        } else if let Rvalue::Ref(_, _, place) = rvalue {\n+            trace!(\"checking Ref({:?})\", place);\n+            // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n+            // from a function argument that hasn't been assigned to in this function.\n+            if let Place {\n+                base: PlaceBase::Local(local),\n+                projection: box []\n+            } = place {\n+                let alive =\n+                    if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n+                        true\n+                    } else { false };\n+\n+                if local.as_usize() <= self.ecx.frame().body.arg_count && !alive {\n+                    trace!(\"skipping Ref({:?})\", place);\n+                    return None;\n                 }\n-                let left = self.eval_operand(left, source_info)?;\n-                let l = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(left)\n-                })?;\n-                trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n-                let (val, overflow, _ty) = self.use_ecx(source_info, |this| {\n-                    this.ecx.overflowing_binary_op(op, l, r)\n-                })?;\n-                let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n-                    Immediate::ScalarPair(\n-                        val.into(),\n-                        Scalar::from_bool(overflow).into(),\n-                    )\n-                } else {\n-                    // We check overflow in debug mode already\n-                    // so should only check in release mode.\n-                    if !self.tcx.sess.overflow_checks() && overflow {\n-                        let err = err_panic!(Overflow(op)).into();\n-                        let _: Option<()> = self.use_ecx(source_info, |_| Err(err));\n-                        return None;\n-                    }\n-                    Immediate::Scalar(val.into())\n-                };\n-                let res = ImmTy {\n-                    imm: val,\n-                    layout: place_layout,\n-                };\n-                Some(res.into())\n-            },\n+            }\n         }\n+\n+        self.use_ecx(source_info, |this| {\n+            trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n+            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+            this.ecx.eval_place_to_op(place, Some(place_layout))\n+        })\n     }\n \n     fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>, span: Span) -> Operand<'tcx> {\n@@ -577,14 +640,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n }\n \n-fn type_size_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<u64> {\n-    tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n-}\n-\n struct CanConstProp {\n     can_const_prop: IndexVec<Local, bool>,\n     // false at the beginning, once set, there are not allowed to be any more assignments\n@@ -670,15 +725,19 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 .ty(&self.local_decls, self.tcx)\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n-                    if let Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: box [],\n-                    } = *place {\n+                if let Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: box [],\n+                } = *place {\n+                    if let Some(value) = self.const_prop(rval,\n+                                                         place_layout,\n+                                                         statement.source_info,\n+                                                         place) {\n                         trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n                         if self.can_const_prop[local] {\n                             trace!(\"storing {:?} to {:?}\", value, local);\n-                            assert!(self.get_const(local).is_none());\n+                            assert!(self.get_const(local).is_none() ||\n+                                    self.get_const(local) == Some(value));\n                             self.set_const(local, value);\n \n                             if self.should_const_prop() {\n@@ -692,7 +751,22 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                     }\n                 }\n             }\n+        } else {\n+            match statement.kind {\n+                StatementKind::StorageLive(local) |\n+                StatementKind::StorageDead(local) if self.can_const_prop[local] => {\n+                    let frame = self.ecx.frame_mut();\n+                    frame.locals[local].value =\n+                        if let StatementKind::StorageLive(_) = statement.kind {\n+                            LocalValue::Uninitialized\n+                        } else {\n+                            LocalValue::Dead\n+                        };\n+                }\n+                _ => {}\n+            }\n         }\n+\n         self.super_statement(statement, location);\n     }\n "}, {"sha": "c2902dbd7c12953cbe598d5e7a6ff24ee23bb7f7", "filename": "src/test/mir-opt/const_prop/read_immutable_static.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -0,0 +1,29 @@\n+// compile-flags: -O\n+\n+static FOO: u8 = 2;\n+\n+fn main() {\n+    let x = FOO + FOO;\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.ConstProp.before.mir\n+//  bb0: {\n+//      ...\n+//      _2 = (FOO: u8);\n+//      ...\n+//      _3 = (FOO: u8);\n+//      _1 = Add(move _2, move _3);\n+//      ...\n+//  }\n+// END rustc.main.ConstProp.before.mir\n+// START rustc.main.ConstProp.after.mir\n+//  bb0: {\n+//      ...\n+//      _2 = const 2u8;\n+//      ...\n+//      _3 = const 2u8;\n+//      _1 = Add(move _2, move _3);\n+//      ...\n+//  }\n+// END rustc.main.ConstProp.after.mir"}, {"sha": "e9b61690cf89e43b40eda855ca94340cb1a21c93", "filename": "src/test/mir-opt/const_prop/reify_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -16,7 +16,7 @@ fn main() {\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(AllocId(1).0x0) : fn();\n+//      _3 = const Scalar(AllocId(0).0x0) : fn();\n //      _2 = move _3 as usize (Misc);\n //      ...\n //      _1 = move _2 as *const fn() (Misc);"}, {"sha": "05595ce147c96f6b17472fda1e6b2325f2cb8f9a", "filename": "src/test/mir-opt/const_prop/slice_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -34,7 +34,7 @@ fn main() {\n //      assert(const true, \"index out of bounds: the len is move _7 but the index is _6\") -> bb1;\n //  }\n //  bb1: {\n-//      _1 = (*_2)[_6];\n+//      _1 = const 2u32;\n //      ...\n //      return;\n //  }"}, {"sha": "37fbf01e487dc6610a6649b0e3245de218bc1e42", "filename": "src/test/run-fail/overflowing-lsh-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -2,6 +2,7 @@\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     let _x = 1_i32 << 32;"}, {"sha": "7b0b37dfed043e437a44e1c8f331dd097d1aa21d", "filename": "src/test/run-fail/overflowing-lsh-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -2,6 +2,7 @@\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     let _x = 1 << -1;"}, {"sha": "1768a8e6d3138f49f5cebb5b2449cba729065e2d", "filename": "src/test/run-fail/overflowing-lsh-3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -2,6 +2,7 @@\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     let _x = 1_u64 << 64;"}, {"sha": "ec304b4144e0f80772e6d45639d5108386f1d21e", "filename": "src/test/run-fail/overflowing-lsh-4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -5,6 +5,7 @@\n // sidestep the overflow checking.\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     // this signals overflow when checking is on"}, {"sha": "14514540c06e1c8801540c73e012b5acb6505281", "filename": "src/test/run-fail/overflowing-rsh-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -2,6 +2,7 @@\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     let _x = -1_i32 >> 32;"}, {"sha": "83dcbd13d2ad8200a93891dab5d517e006bc9485", "filename": "src/test/run-fail/overflowing-rsh-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -2,6 +2,7 @@\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     let _x = -1_i32 >> -1;"}, {"sha": "3521c0506591c37f7304d1e6f3cbd1c5c6dcbdcb", "filename": "src/test/run-fail/overflowing-rsh-3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -2,6 +2,7 @@\n // compile-flags: -C debug-assertions\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     let _x = -1_i64 >> 64;"}, {"sha": "ed1191849e57cce2937015a192d932bda032b54d", "filename": "src/test/run-fail/overflowing-rsh-4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -5,6 +5,7 @@\n // truncation does not sidestep the overflow checking.\n \n #![warn(exceeding_bitshifts)]\n+#![warn(const_err)]\n \n fn main() {\n     // this signals overflow when checking is on"}, {"sha": "274967ef60de54cb477ee0948057e7133d342a0c", "filename": "src/test/ui/consts/const-eval/issue-50814.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -11,6 +11,7 @@ struct Sum<A,B>(A,B);\n \n impl<A: Unsigned, B: Unsigned> Unsigned for Sum<A,B> {\n     const MAX: u8 = A::MAX + B::MAX; //~ ERROR any use of this value will cause an error\n+    //~| ERROR any use of this value will cause an error\n }\n \n fn foo<T>(_: T) -> &'static u8 {"}, {"sha": "de3459c72dd2b0397ab80996ed1dae5c62814d9f", "filename": "src/test/ui/consts/const-eval/issue-50814.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -9,13 +9,21 @@ LL |     const MAX: u8 = A::MAX + B::MAX;\n    = note: `#[deny(const_err)]` on by default\n \n error[E0080]: evaluation of constant expression failed\n-  --> $DIR/issue-50814.rs:17:5\n+  --> $DIR/issue-50814.rs:18:5\n    |\n LL |     &Sum::<U8,U8>::MAX\n    |     ^-----------------\n    |      |\n    |      referenced constant has errors\n \n-error: aborting due to 2 previous errors\n+error: any use of this value will cause an error\n+  --> $DIR/issue-50814.rs:13:21\n+   |\n+LL |     const MAX: u8 = A::MAX + B::MAX;\n+   |     ----------------^^^^^^^^^^^^^^^-\n+   |                     |\n+   |                     attempt to add with overflow\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "7504fd525955a2cbdbf23a47791321b8f954c0b2", "filename": "src/test/ui/consts/const-prop-read-static-in-const.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+// run-pass\n+\n+#![allow(dead_code)]\n+\n+const TEST: u8 = MY_STATIC;\n+//~^ skipping const checks\n+\n+static MY_STATIC: u8 = 4;\n+\n+fn main() {\n+}"}, {"sha": "bbd5b12ed7dfcfd3ff92d9b8a1961d2661740d08", "filename": "src/test/ui/consts/const-prop-read-static-in-const.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.stderr?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -0,0 +1,6 @@\n+warning: skipping const checks\n+  --> $DIR/const-prop-read-static-in-const.rs:6:18\n+   |\n+LL | const TEST: u8 = MY_STATIC;\n+   |                  ^^^^^^^^^\n+"}, {"sha": "dd3b8393429118841702526154796474869c591a", "filename": "src/test/ui/lint/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -O\n+\n #![deny(exceeding_bitshifts, const_err)]\n #![allow(unused_variables)]\n #![allow(dead_code)]"}, {"sha": "25e079b6d814f34e7450398528b453995c4356f6", "filename": "src/test/ui/lint/lint-exceeding-bitshifts.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.stderr?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -1,113 +1,113 @@\n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:7:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:9:15\n    |\n LL |       let n = 1u8 << 8;\n    |               ^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-exceeding-bitshifts.rs:1:9\n+  --> $DIR/lint-exceeding-bitshifts.rs:3:9\n    |\n LL | #![deny(exceeding_bitshifts, const_err)]\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:9:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:11:15\n    |\n LL |       let n = 1u16 << 16;\n    |               ^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:11:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:13:15\n    |\n LL |       let n = 1u32 << 32;\n    |               ^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:13:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:15:15\n    |\n LL |       let n = 1u64 << 64;\n    |               ^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:15:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:17:15\n    |\n LL |       let n = 1i8 << 8;\n    |               ^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:17:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:19:15\n    |\n LL |       let n = 1i16 << 16;\n    |               ^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:19:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:21:15\n    |\n LL |       let n = 1i32 << 32;\n    |               ^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:21:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:23:15\n    |\n LL |       let n = 1i64 << 64;\n    |               ^^^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:24:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:26:15\n    |\n LL |       let n = 1u8 >> 8;\n    |               ^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:26:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:28:15\n    |\n LL |       let n = 1u16 >> 16;\n    |               ^^^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:28:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:30:15\n    |\n LL |       let n = 1u32 >> 32;\n    |               ^^^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:30:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:32:15\n    |\n LL |       let n = 1u64 >> 64;\n    |               ^^^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:32:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:34:15\n    |\n LL |       let n = 1i8 >> 8;\n    |               ^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:34:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:36:15\n    |\n LL |       let n = 1i16 >> 16;\n    |               ^^^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:36:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:38:15\n    |\n LL |       let n = 1i32 >> 32;\n    |               ^^^^^^^^^^\n \n error: attempt to shift right with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:38:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:40:15\n    |\n LL |       let n = 1i64 >> 64;\n    |               ^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:42:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:44:15\n    |\n LL |       let n = n << 8;\n    |               ^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts.rs:44:15\n+  --> $DIR/lint-exceeding-bitshifts.rs:46:15\n    |\n LL |       let n = 1u8 << -8;\n    |               ^^^^^^^^^"}, {"sha": "69b627355b8019198c33399011e4eb87dcc5454f", "filename": "src/test/ui/lint/lint-exceeding-bitshifts2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts2.rs?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -O\n+\n #![deny(exceeding_bitshifts, const_err)]\n #![allow(unused_variables)]\n #![allow(dead_code)]"}, {"sha": "cb96982a78930c01cd6084ffd4129ad78d5e3388", "filename": "src/test/ui/lint/lint-exceeding-bitshifts2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/488381ce9ef0ceabe83b73127c659e5d38137df0/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts2.stderr?ref=488381ce9ef0ceabe83b73127c659e5d38137df0", "patch": "@@ -1,23 +1,23 @@\n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts2.rs:7:15\n+  --> $DIR/lint-exceeding-bitshifts2.rs:9:15\n    |\n LL |       let n = 1u8 << (4+4);\n    |               ^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/lint-exceeding-bitshifts2.rs:1:9\n+  --> $DIR/lint-exceeding-bitshifts2.rs:3:9\n    |\n LL | #![deny(exceeding_bitshifts, const_err)]\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts2.rs:15:15\n+  --> $DIR/lint-exceeding-bitshifts2.rs:17:15\n    |\n LL |       let n = 1_isize << BITS;\n    |               ^^^^^^^^^^^^^^^\n \n error: attempt to shift left with overflow\n-  --> $DIR/lint-exceeding-bitshifts2.rs:16:15\n+  --> $DIR/lint-exceeding-bitshifts2.rs:18:15\n    |\n LL |       let n = 1_usize << BITS;\n    |               ^^^^^^^^^^^^^^^"}]}