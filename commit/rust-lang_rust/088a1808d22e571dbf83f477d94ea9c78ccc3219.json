{"sha": "088a1808d22e571dbf83f477d94ea9c78ccc3219", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4OGExODA4ZDIyZTU3MWRiZjgzZjQ3N2Q5NGVhOWM3OGNjYzMyMTk=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2020-01-11T00:19:09Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2020-01-11T01:56:25Z"}, "message": "Add suggestions when encountering chained comparisons", "tree": {"sha": "bfe6cd0861555b1f11ef2ca0b785cb3f7599e0d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfe6cd0861555b1f11ef2ca0b785cb3f7599e0d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/088a1808d22e571dbf83f477d94ea9c78ccc3219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/088a1808d22e571dbf83f477d94ea9c78ccc3219", "html_url": "https://github.com/rust-lang/rust/commit/088a1808d22e571dbf83f477d94ea9c78ccc3219", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/088a1808d22e571dbf83f477d94ea9c78ccc3219/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d8d559bbecf6272eb41f8a800e319238aa9d621", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8d559bbecf6272eb41f8a800e319238aa9d621", "html_url": "https://github.com/rust-lang/rust/commit/2d8d559bbecf6272eb41f8a800e319238aa9d621"}], "stats": {"total": 384, "additions": 335, "deletions": 49}, "files": [{"sha": "ecbd183b6e929eca48804954c06dd6e3bfe16d22", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_error_codes::*;\n use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, Handler, PResult};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::kw;\n use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n use syntax::ast::{\n@@ -500,6 +501,58 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Check to see if a pair of chained operators looks like an attempt at chained comparison,\n+    /// e.g. `1 < x <= 3`. If so, suggest either splitting the comparison into two, or\n+    /// parenthesising the leftmost comparison.\n+    fn attempt_chained_comparison_suggestion(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        inner_op: &Expr,\n+        outer_op: &Spanned<AssocOp>,\n+    ) {\n+        if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n+            match (op.node, &outer_op.node) {\n+                // `x < y < z` and friends.\n+                (BinOpKind::Lt, AssocOp::Less) | (BinOpKind::Lt, AssocOp::LessEqual) |\n+                (BinOpKind::Le, AssocOp::LessEqual) | (BinOpKind::Le, AssocOp::Less) |\n+                // `x > y > z` and friends.\n+                (BinOpKind::Gt, AssocOp::Greater) | (BinOpKind::Gt, AssocOp::GreaterEqual) |\n+                (BinOpKind::Ge, AssocOp::GreaterEqual) | (BinOpKind::Ge, AssocOp::Greater) => {\n+                    let expr_to_str = |e: &Expr| {\n+                        self.span_to_snippet(e.span)\n+                            .unwrap_or_else(|_| pprust::expr_to_string(&e))\n+                    };\n+                    err.span_suggestion(\n+                        inner_op.span.to(outer_op.span),\n+                        \"split the comparison into two...\",\n+                        format!(\n+                            \"{} {} {} && {} {}\",\n+                            expr_to_str(&l1),\n+                            op.node.to_string(),\n+                            expr_to_str(&r1),\n+                            expr_to_str(&r1),\n+                            outer_op.node.to_ast_binop().unwrap().to_string(),\n+                        ),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    err.span_suggestion(\n+                        inner_op.span.to(outer_op.span),\n+                        \"...or parenthesize one of the comparisons\",\n+                        format!(\n+                            \"({} {} {}) {}\",\n+                            expr_to_str(&l1),\n+                            op.node.to_string(),\n+                            expr_to_str(&r1),\n+                            outer_op.node.to_ast_binop().unwrap().to_string(),\n+                        ),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n     /// Produces an error if comparison operators are chained (RFC #558).\n     /// We only need to check the LHS, not the RHS, because all comparison ops have same\n     /// precedence (see `fn precedence`) and are left-associative (see `fn fixity`).\n@@ -515,27 +568,31 @@ impl<'a> Parser<'a> {\n     ///           /   \\\n     ///     inner_op   r2\n     ///        /  \\\n-    ///     l1    r1\n+    ///      l1    r1\n     pub(super) fn check_no_chained_comparison(\n         &mut self,\n-        lhs: &Expr,\n-        outer_op: &AssocOp,\n+        inner_op: &Expr,\n+        outer_op: &Spanned<AssocOp>,\n     ) -> PResult<'a, Option<P<Expr>>> {\n         debug_assert!(\n-            outer_op.is_comparison(),\n+            outer_op.node.is_comparison(),\n             \"check_no_chained_comparison: {:?} is not comparison\",\n-            outer_op,\n+            outer_op.node,\n         );\n \n         let mk_err_expr =\n             |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())));\n \n-        match lhs.kind {\n+        match inner_op.kind {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // Respan to include both operators.\n                 let op_span = op.span.to(self.prev_span);\n-                let mut err = self\n-                    .struct_span_err(op_span, \"chained comparison operators require parentheses\");\n+                let mut err =\n+                    self.struct_span_err(op_span, \"comparison operators cannot be chained\");\n+\n+                // If it looks like a genuine attempt to chain operators (as opposed to a\n+                // misformatted turbofish, for instance), suggest a correct form.\n+                self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n \n                 let suggest = |err: &mut DiagnosticBuilder<'_>| {\n                     err.span_suggestion_verbose(\n@@ -547,12 +604,12 @@ impl<'a> Parser<'a> {\n                 };\n \n                 if op.node == BinOpKind::Lt &&\n-                    *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n-                    *outer_op == AssocOp::Greater\n+                    outer_op.node == AssocOp::Less ||  // Include `<` to provide this recommendation\n+                    outer_op.node == AssocOp::Greater\n                 // even in a case like the following:\n                 {\n                     //     Foo<Bar<Baz<Qux, ()>>>\n-                    if *outer_op == AssocOp::Less {\n+                    if outer_op.node == AssocOp::Less {\n                         let snapshot = self.clone();\n                         self.bump();\n                         // So far we have parsed `foo<bar<`, consume the rest of the type args.\n@@ -584,7 +641,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, lhs.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n                             }\n                             Err(mut expr_err) => {\n                                 expr_err.cancel();\n@@ -606,7 +663,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME: actually check that the two expressions in the binop are\n                                 // paths and resynthesize new fn call expression instead of using\n                                 // `ExprKind::Err` placeholder.\n-                                mk_err_expr(self, lhs.span.to(self.prev_span))\n+                                mk_err_expr(self, inner_op.span.to(self.prev_span))\n                             }\n                         }\n                     } else {"}, {"sha": "3c286d363c9db8e21573fc822feba17709e2f636", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -5,7 +5,7 @@ use super::{SemiColonMode, SeqSep, TokenExpectType};\n use crate::maybe_recover_from_interpolated_ty_qpath;\n \n use rustc_errors::{Applicability, PResult};\n-use rustc_span::source_map::{self, Span};\n+use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::mem;\n use syntax::ast::{self, AttrStyle, AttrVec, CaptureBy, Field, Ident, Lit, DUMMY_NODE_ID};\n@@ -181,17 +181,17 @@ impl<'a> Parser<'a> {\n             };\n \n             let cur_op_span = self.token.span;\n-            let restrictions = if op.is_assign_like() {\n+            let restrictions = if op.node.is_assign_like() {\n                 self.restrictions & Restrictions::NO_STRUCT_LITERAL\n             } else {\n                 self.restrictions\n             };\n-            let prec = op.precedence();\n+            let prec = op.node.precedence();\n             if prec < min_prec {\n                 break;\n             }\n             // Check for deprecated `...` syntax\n-            if self.token == token::DotDotDot && op == AssocOp::DotDotEq {\n+            if self.token == token::DotDotDot && op.node == AssocOp::DotDotEq {\n                 self.err_dotdotdot_syntax(self.token.span);\n             }\n \n@@ -200,11 +200,12 @@ impl<'a> Parser<'a> {\n             }\n \n             self.bump();\n-            if op.is_comparison() {\n+            if op.node.is_comparison() {\n                 if let Some(expr) = self.check_no_chained_comparison(&lhs, &op)? {\n                     return Ok(expr);\n                 }\n             }\n+            let op = op.node;\n             // Special cases:\n             if op == AssocOp::As {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n@@ -298,7 +299,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn should_continue_as_assoc_expr(&mut self, lhs: &Expr) -> bool {\n-        match (self.expr_is_complete(lhs), self.check_assoc_op()) {\n+        match (self.expr_is_complete(lhs), self.check_assoc_op().map(|op| op.node)) {\n             // Semi-statement forms are odd:\n             // See https://github.com/rust-lang/rust/issues/29071\n             (true, None) => false,\n@@ -343,19 +344,22 @@ impl<'a> Parser<'a> {\n     /// The method does not advance the current token.\n     ///\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n-    fn check_assoc_op(&self) -> Option<AssocOp> {\n-        match (AssocOp::from_token(&self.token), &self.token.kind) {\n-            (op @ Some(_), _) => op,\n-            (None, token::Ident(sym::and, false)) => {\n-                self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n-                Some(AssocOp::LAnd)\n-            }\n-            (None, token::Ident(sym::or, false)) => {\n-                self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n-                Some(AssocOp::LOr)\n-            }\n-            _ => None,\n-        }\n+    fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n+        Some(Spanned {\n+            node: match (AssocOp::from_token(&self.token), &self.token.kind) {\n+                (Some(op), _) => op,\n+                (None, token::Ident(sym::and, false)) => {\n+                    self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n+                    AssocOp::LAnd\n+                }\n+                (None, token::Ident(sym::or, false)) => {\n+                    self.error_bad_logical_op(\"or\", \"||\", \"disjunction\");\n+                    AssocOp::LOr\n+                }\n+                _ => return None,\n+            },\n+            span: self.token.span,\n+        })\n     }\n \n     /// Error on `and` and `or` suggesting `&&` and `||` respectively."}, {"sha": "e4e94bb9492371c811fb2a0ccc56fef040e673df", "filename": "src/test/ui/did_you_mean/issue-40396.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.rs?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -1,8 +1,8 @@\n fn main() {\n     (0..13).collect<Vec<i32>>();\n-    //~^ ERROR chained comparison\n+    //~^ ERROR comparison operators cannot be chained\n     Vec<i32>::new();\n-    //~^ ERROR chained comparison\n+    //~^ ERROR comparison operators cannot be chained\n     (0..13).collect<Vec<i32>();\n-    //~^ ERROR chained comparison\n+    //~^ ERROR comparison operators cannot be chained\n }"}, {"sha": "f952136a7bfe36b8b1031acbf17606dfa9259e4f", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -1,15 +1,23 @@\n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:2:20\n    |\n LL |     (0..13).collect<Vec<i32>>();\n    |                    ^^^^^\n    |\n+help: split the comparison into two...\n+   |\n+LL |     (0..13).collect < Vec && Vec <i32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     ((0..13).collect < Vec) <i32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>>();\n    |                    ^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:4:8\n    |\n LL |     Vec<i32>::new();\n@@ -20,12 +28,20 @@ help: use `::<...>` instead of `<...>` to specify type arguments\n LL |     Vec::<i32>::new();\n    |        ^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:6:20\n    |\n LL |     (0..13).collect<Vec<i32>();\n    |                    ^^^^^\n    |\n+help: split the comparison into two...\n+   |\n+LL |     (0..13).collect < Vec && Vec <i32>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     ((0..13).collect < Vec) <i32>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>();"}, {"sha": "0431196f1744e064b78ff66937a00b14bb3f1d3b", "filename": "src/test/ui/parser/chained-comparison-suggestion.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -0,0 +1,40 @@\n+// Check that we get nice suggestions when attempting a chained comparison.\n+\n+fn comp1() {\n+    1 < 2 <= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp2() {\n+    1 < 2 < 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp3() {\n+    1 <= 2 < 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp4() {\n+    1 <= 2 <= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp5() {\n+    1 > 2 >= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn comp6() {\n+    1 > 2 > 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp7() {\n+    1 >= 2 > 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp8() {\n+    1 >= 2 >= 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "5c10a4599dd032e984b9f1fa11cf8e1f98a8ac16", "filename": "src/test/ui/parser/chained-comparison-suggestion.stderr", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -0,0 +1,159 @@\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:4:7\n+   |\n+LL |     1 < 2 <= 3;\n+   |       ^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 < 2 && 2 <= 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 < 2) <= 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:9:7\n+   |\n+LL |     1 < 2 < 3;\n+   |       ^^^^^\n+   |\n+   = help: use `::<...>` instead of `<...>` to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+help: split the comparison into two...\n+   |\n+LL |     1 < 2 && 2 < 3;\n+   |     ^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 < 2) < 3;\n+   |     ^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:13:7\n+   |\n+LL |     1 <= 2 < 3;\n+   |       ^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 <= 2 && 2 < 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 <= 2) < 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:18:7\n+   |\n+LL |     1 <= 2 <= 3;\n+   |       ^^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 <= 2 && 2 <= 3;\n+   |     ^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 <= 2) <= 3;\n+   |     ^^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:23:7\n+   |\n+LL |     1 > 2 >= 3;\n+   |       ^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 > 2 && 2 >= 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 > 2) >= 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:28:7\n+   |\n+LL |     1 > 2 > 3;\n+   |       ^^^^^\n+   |\n+   = help: use `::<...>` instead of `<...>` to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+help: split the comparison into two...\n+   |\n+LL |     1 > 2 && 2 > 3;\n+   |     ^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 > 2) > 3;\n+   |     ^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:32:7\n+   |\n+LL |     1 >= 2 > 3;\n+   |       ^^^^^^\n+   |\n+   = help: use `::<...>` instead of `<...>` to specify type arguments\n+   = help: or use `(...)` if you meant to specify fn arguments\n+help: split the comparison into two...\n+   |\n+LL |     1 >= 2 && 2 > 3;\n+   |     ^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 >= 2) > 3;\n+   |     ^^^^^^^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:36:7\n+   |\n+LL |     1 >= 2 >= 3;\n+   |       ^^^^^^^\n+   |\n+help: split the comparison into two...\n+   |\n+LL |     1 >= 2 && 2 >= 3;\n+   |     ^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (1 >= 2) >= 3;\n+   |     ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:4:14\n+   |\n+LL |     1 < 2 <= 3;\n+   |              ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:13:14\n+   |\n+LL |     1 <= 2 < 3;\n+   |              ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:18:15\n+   |\n+LL |     1 <= 2 <= 3;\n+   |               ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:23:14\n+   |\n+LL |     1 > 2 >= 3;\n+   |              ^ expected `bool`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:36:15\n+   |\n+LL |     1 >= 2 >= 3;\n+   |               ^ expected `bool`, found integer\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e27b03dddc5be56882eaf84089585bd4ceb9e98d", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -3,24 +3,26 @@ struct X;\n \n fn main() {\n     false == false == false;\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n \n     false == 0 < 2;\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n     //~| ERROR mismatched types\n     //~| ERROR mismatched types\n \n     f<X>();\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n+    //~| HELP split the comparison into two...\n+    //~| ...or parenthesize one of the comparisons\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     use std::convert::identity;\n     let _ = identity<u8>;\n-    //~^ ERROR chained comparison operators require parentheses\n+    //~^ ERROR comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n     //~| HELP or use `(...)` if you meant to specify fn arguments\n }"}, {"sha": "44edf2de7f8de22adccbaf1aa6c0168f4671c671", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/088a1808d22e571dbf83f477d94ea9c78ccc3219/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=088a1808d22e571dbf83f477d94ea9c78ccc3219", "patch": "@@ -1,16 +1,16 @@\n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:5:11\n    |\n LL |     false == false == false;\n    |           ^^^^^^^^^^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:8:11\n    |\n LL |     false == 0 < 2;\n    |           ^^^^^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:13:6\n    |\n LL |     f<X>();\n@@ -21,19 +21,27 @@ help: use `::<...>` instead of `<...>` to specify type arguments\n LL |     f::<X>();\n    |      ^^\n \n-error: chained comparison operators require parentheses\n+error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:17:6\n    |\n LL |     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^^^^^^^\n    |\n+help: split the comparison into two...\n+   |\n+LL |     f < Result && Result <Option<X>, Option<Option<X>>>(1, 2);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+help: ...or parenthesize one of the comparisons\n+   |\n+LL |     (f < Result) <Option<X>, Option<Option<X>>>(1, 2);\n+   |     ^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     f::<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^\n \n-error: chained comparison operators require parentheses\n-  --> $DIR/require-parens-for-chained-comparison.rs:22:21\n+error: comparison operators cannot be chained\n+  --> $DIR/require-parens-for-chained-comparison.rs:24:21\n    |\n LL |     let _ = identity<u8>;\n    |                     ^^^^"}]}