{"sha": "bbe15522d5837abfe45652bf7dac40ffd8caea66", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiZTE1NTIyZDU4MzdhYmZlNDU2NTJiZjdkYWM0MGZmZDhjYWVhNjY=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-08-11T04:20:28Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-08-11T04:20:28Z"}, "message": "Some tweaks and comments", "tree": {"sha": "b22fa58c2996f8ea26d60f82bf113c018a33037c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b22fa58c2996f8ea26d60f82bf113c018a33037c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbe15522d5837abfe45652bf7dac40ffd8caea66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe15522d5837abfe45652bf7dac40ffd8caea66", "html_url": "https://github.com/rust-lang/rust/commit/bbe15522d5837abfe45652bf7dac40ffd8caea66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbe15522d5837abfe45652bf7dac40ffd8caea66/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffcd32cfe62735a19dd9e81fe30a3b448c39fe2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffcd32cfe62735a19dd9e81fe30a3b448c39fe2f", "html_url": "https://github.com/rust-lang/rust/commit/ffcd32cfe62735a19dd9e81fe30a3b448c39fe2f"}], "stats": {"total": 153, "additions": 102, "deletions": 51}, "files": [{"sha": "20e74f47c9e2965ad1e60a68ebf9b235b864d711", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bbe15522d5837abfe45652bf7dac40ffd8caea66/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbe15522d5837abfe45652bf7dac40ffd8caea66/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=bbe15522d5837abfe45652bf7dac40ffd8caea66", "patch": "@@ -412,12 +412,13 @@ pub struct LocalDecl<'tcx> {\n     pub is_user_variable: bool,\n \n     /// True if this is an internal local.\n-    /// Such locals are not checked against the legal types in a generator.\n-    ///\n-    /// Scalar state variables created by optimizations (e.g. nonzeroing drop\n-    /// flags) should not be included in generator OIBIT computations.\n-    /// Therefore, we mark them as `internal` so we can ignore them when\n-    /// sanity-checking the OIBIT list.\n+    /// These locals are not based on types in the source code and are only used\n+    /// for drop flags at the moment.\n+    /// The generator transformation will sanity check the locals which are live across\n+    /// a suspension point against the type components of the generator which\n+    /// type checking knows are live across a suspension point.\n+    /// We need to flag drop flags to avoid triggering this check as they are introduced\n+    /// after typeck.\n     pub internal: bool,\n \n     /// Type of this local."}, {"sha": "6a29de1361b0b58b2331dc3261c27558142b6768", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 95, "deletions": 45, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/bbe15522d5837abfe45652bf7dac40ffd8caea66/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbe15522d5837abfe45652bf7dac40ffd8caea66/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=bbe15522d5837abfe45652bf7dac40ffd8caea66", "patch": "@@ -26,7 +26,6 @@ use std::collections::HashMap;\n use std::borrow::Cow;\n use std::iter::once;\n use std::mem;\n-use syntax::ast::NodeId;\n use transform::simplify;\n \n pub struct StateTransform;\n@@ -67,20 +66,35 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: &'tcx Substs<'tcx>,\n+\n+    // The index of the generator state in the generator struct\n+    state_field: usize,\n+\n+    // Mapping from Local to (type of local, generator struct index)\n     remap: HashMap<Local, (Ty<'tcx>, usize)>,\n+\n+    // The number of generator states. 0 is unresumed, 1 is poisoned. So this is initialized to 2\n     bb_target_count: u32,\n+\n+    // Map from a (which block to resume execution at, which block to use to drop the generator) to a \n+    // genrator state\n     bb_targets: HashMap<(BasicBlock, Option<BasicBlock>), u32>,\n+\n+    // The original RETURN_POINTER local\n     new_ret_local: Local,\n+\n+    // The block to resume execution when for Return\n     return_block: BasicBlock,\n-    state_field: usize,\n }\n \n impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n+    // Make a GeneratorState rvalue\n     fn make_state(&self, idx: usize, val: Operand<'tcx>) -> Rvalue<'tcx> {\n         let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None);\n         Rvalue::Aggregate(box adt, vec![val])\n     }\n \n+    // Create a Lvalue referencing a generator struct field\n     fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n         let base = Lvalue::Local(Local::new(1));\n         let field = Projection {\n@@ -90,6 +104,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n         Lvalue::Projection(Box::new(field))\n     }\n \n+    // Create a statement which changes the generator state\n     fn set_state(&self, state_disc: u32, source_info: SourceInfo) -> Statement<'tcx> {\n         let state = self.make_field(self.state_field, self.tcx.types.u32);\n         let val = Operand::Constant(box Constant {\n@@ -112,6 +127,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n         if let Lvalue::Local(l) = *lvalue {\n+            // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, idx)) = self.remap.get(&l) {\n                 *lvalue = self.make_field(idx, ty);\n             }\n@@ -135,6 +151,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n             _ => None\n         };\n \n+        // Remove StorageLive and StorageDead statements for remapped locals\n         data.retain_statements(|s| {\n             match s.kind {\n                 StatementKind::StorageLive(ref l) | StatementKind::StorageDead(ref l) => {\n@@ -172,16 +189,6 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n     }\n }\n \n-fn ensure_generator_state_argument<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                node_id: NodeId,\n-                def_id: DefId,\n-                mir: &mut Mir<'tcx>) -> (Ty<'tcx>, GeneratorInterior<'tcx>) {\n-    let interior = *tcx.typeck_tables_of(def_id).generator_interiors.get(&node_id).unwrap();\n-    let gen_ty = mir.local_decls.raw[1].ty;\n-    (gen_ty, interior)\n-}\n-\n fn make_generator_state_argument_indirect<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 def_id: DefId,\n@@ -259,14 +266,21 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             mir: &mut Mir<'tcx>)\n     -> (HashMap<Local, (Ty<'tcx>, usize)>, GeneratorLayout<'tcx>)\n {\n+    // Use a liveness analysis to compute locals which are live across a suspension point\n     let live_locals = locals_live_across_suspend_points(tcx, mir, source);\n \n+    // Erase regions from the types passed in from typeck so we can compare them with\n+    // MIR types\n     let allowed = tcx.erase_regions(&interior.as_slice());\n \n     for (local, decl) in mir.local_decls.iter_enumerated() {\n+        // Ignore locals which are internal or not live\n         if !live_locals.contains(&local) || decl.internal {\n             continue;\n         }\n+\n+        // Sanity check that typeck knows about the type of locals which are\n+        // live across a suspension point\n         if !allowed.contains(&decl.ty) {\n             span_bug!(mir.span,\n                       \"Broken MIR: generator contains type {} in MIR, \\\n@@ -278,10 +292,17 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let upvar_len = mir.upvar_decls.len();\n     let dummy_local = LocalDecl::new_internal(tcx.mk_nil(), mir.span);\n+\n+    // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n+    // to avoid changing local indices\n     let live_decls = live_locals.iter().map(|local| {\n         let var = mem::replace(&mut mir.local_decls[local], dummy_local.clone());\n         (local, var)\n     });\n+\n+    // Create a map from local indices to generator struct indices.\n+    // These are offset by (upvar_len + 1) because of fields which comes before locals.\n+    // We also create a vector of the LocalDecls of these locals.\n     let (remap, vars) = live_decls.enumerate().map(|(idx, (local, var))| {\n         ((local, (var.ty, upvar_len + 1 + idx)), var)\n     }).unzip();\n@@ -353,14 +374,16 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn generate_drop<'a, 'tcx>(\n+fn create_generator_drop_shim<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 transform: &TransformVisitor<'a, 'tcx>,\n                 def_id: DefId,\n                 source: MirSource,\n                 gen_ty: Ty<'tcx>,\n-                mir: &mut Mir<'tcx>,\n-                drop_clean: BasicBlock) {\n+                mir: &Mir<'tcx>,\n+                drop_clean: BasicBlock) -> Mir<'tcx> {\n+    let mut mir = mir.clone();\n+\n     let source_info = SourceInfo {\n         span: mir.span,\n         scope: ARGUMENT_VISIBILITY_SCOPE,\n@@ -393,7 +416,7 @@ fn generate_drop<'a, 'tcx>(\n         targets: cases.iter().map(|&(_, d)| d).chain(once(return_block)).collect(),\n     };\n \n-    insert_entry_point(mir, BasicBlockData {\n+    insert_entry_point(&mut mir, BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -425,7 +448,7 @@ fn generate_drop<'a, 'tcx>(\n         is_user_variable: false,\n     };\n \n-    make_generator_state_argument_indirect(tcx, def_id, mir);\n+    make_generator_state_argument_indirect(tcx, def_id, &mut mir);\n \n     // Change the generator argument from &mut to *mut\n     mir.local_decls[Local::new(1)] = LocalDecl {\n@@ -442,12 +465,14 @@ fn generate_drop<'a, 'tcx>(\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function\n-    simplify::remove_dead_blocks(mir);\n+    simplify::remove_dead_blocks(&mut mir);\n+\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, mir);\n+    mir\n }\n \n-fn insert_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         mir: &mut Mir<'tcx>) {\n     let assert_block = BasicBlock::new(mir.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n@@ -479,12 +504,12 @@ fn insert_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n }\n \n-fn generate_entry_point<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                mut transform: TransformVisitor<'a, 'tcx>,\n-                def_id: DefId,\n-                source: MirSource,\n-                mir: &mut Mir<'tcx>) {\n+fn creator_generator_resume_function<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        mut transform: TransformVisitor<'a, 'tcx>,\n+        def_id: DefId,\n+        source: MirSource,\n+        mir: &mut Mir<'tcx>) {\n     // Poison the generator when it unwinds\n     for block in mir.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n@@ -555,7 +580,7 @@ fn generate_entry_point<'a, 'tcx>(\n     dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n }\n \n-fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> (BasicBlock, BasicBlock) {\n+fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     let source_info = SourceInfo {\n         span: mir.span,\n         scope: ARGUMENT_VISIBILITY_SCOPE,\n@@ -587,7 +612,7 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> (BasicBlock, BasicBlock)\n         is_cleanup: false,\n     });\n \n-    (return_block, drop_clean)\n+    drop_clean\n }\n \n impl MirPass for StateTransform {\n@@ -607,25 +632,39 @@ impl MirPass for StateTransform {\n         let node_id = source.item_id();\n         let def_id = tcx.hir.local_def_id(source.item_id());\n \n-        let (gen_ty, interior) = ensure_generator_state_argument(tcx, node_id, def_id, mir);\n+        // Get the interior types which typeck computed\n+        let interior = *tcx.typeck_tables_of(def_id).generator_interiors.get(&node_id).unwrap();\n \n+        // The first argument is the generator type passed by value\n+        let gen_ty = mir.local_decls.raw[1].ty;\n+\n+        // Compute GeneratorState<yield_ty, return_ty>\n         let state_did = tcx.lang_items.gen_state().unwrap();\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.mk_substs([Kind::from(yield_ty),\n             Kind::from(mir.return_ty)].iter());\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n+        // We rename RETURN_POINTER which has type mir.return_ty to new_ret_local\n+        // RETURN_POINTER then is a fresh unused local with type ret_ty.\n         let new_ret_local = replace_result_variable(ret_ty, mir);\n \n+        // Extract locals which are live across suspension point into `layout`\n+        // `remap` gives a mapping from local indices onto generator struct indices\n         let (remap, layout) = compute_layout(tcx, source, interior, mir);\n \n-        let tail_block = BasicBlock::new(mir.basic_blocks().len());\n-\n         let state_field = mir.upvar_decls.len();\n \n         let mut bb_targets = HashMap::new();\n+\n+        // If we jump to the entry point, we should go to the initial 0 generator state.\n+        // FIXME: Could this result in the need for destruction for state 0?\n         bb_targets.insert((BasicBlock::new(0), None), 0);\n \n+        // Run the transformation which converts Lvalues from Local to generator struct\n+        // accesses for locals in `remap`.\n+        // It also rewrites `return x` and `yield y` as writing a new generator state and returning\n+        // GeneratorState::Complete(x) and GeneratorState::Yielded(y) respectively.\n         let mut transform = TransformVisitor {\n             tcx,\n             state_adt_ref,\n@@ -634,39 +673,50 @@ impl MirPass for StateTransform {\n             bb_target_count: 2,\n             bb_targets,\n             new_ret_local,\n-            return_block: tail_block,\n             state_field,\n+\n+            // For returns we will resume execution at the next added basic block.\n+            // This happens in `insert_panic_on_resume_after_return`\n+            return_block: BasicBlock::new(mir.basic_blocks().len()),\n         };\n         transform.visit_mir(mir);\n \n+        // Update our MIR struct to reflect the changed we've made\n         mir.return_ty = ret_ty;\n         mir.yield_ty = None;\n         mir.arg_count = 1;\n         mir.spread_arg = None;\n         mir.generator_layout = Some(layout);\n \n-        insert_resume_after_return(tcx, mir);\n+        // Panic if we resumed after returning\n+        insert_panic_on_resume_after_return(tcx, mir);\n \n-        let (_return_block, drop_clean) = insert_clean_drop(mir);\n+        // Insert `drop(generator_struct)` which is used to drop upvars for generators in\n+        // the unresumed (0) state.\n+        // This is expanded to a drop ladder in `elaborate_generator_drops`.\n+        let drop_clean = insert_clean_drop(mir);\n \n         dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir);\n \n+        // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n+        // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n+        // However we need to also elaborate the code generated by `insert_clean_drop`.\n         elaborate_generator_drops(tcx, def_id, mir);\n \n         dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n \n-        let mut drop_impl = mir.clone();\n-\n-        generate_drop(tcx,\n-                      &transform,\n-                      def_id,\n-                      source,\n-                      gen_ty,\n-                      &mut drop_impl,\n-                      drop_clean);\n+        // Create a copy of our MIR and use it to create the drop shim for the generator\n+        let drop_shim = create_generator_drop_shim(tcx,\n+            &transform,\n+            def_id,\n+            source,\n+            gen_ty,\n+            &mir,\n+            drop_clean);\n \n-        mir.generator_drop = Some(box drop_impl);\n+        mir.generator_drop = Some(box drop_shim);\n \n-        generate_entry_point(tcx, transform, def_id, source, mir);\n+        // Create the Genreator::resume function\n+        creator_generator_resume_function(tcx, transform, def_id, source, mir);\n     }\n }"}]}