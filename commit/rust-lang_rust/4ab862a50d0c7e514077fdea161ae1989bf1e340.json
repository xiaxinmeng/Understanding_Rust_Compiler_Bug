{"sha": "4ab862a50d0c7e514077fdea161ae1989bf1e340", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYjg2MmE1MGQwYzdlNTE0MDc3ZmRlYTE2MWFlMTk4OWJmMWUzNDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-09T13:50:26Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-09T18:44:04Z"}, "message": "Switch resolve pass to use visit.rs rather than walk.rs", "tree": {"sha": "9c1d71bad302c8115503be83165daf3ad9ac06e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c1d71bad302c8115503be83165daf3ad9ac06e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ab862a50d0c7e514077fdea161ae1989bf1e340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab862a50d0c7e514077fdea161ae1989bf1e340", "html_url": "https://github.com/rust-lang/rust/commit/4ab862a50d0c7e514077fdea161ae1989bf1e340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ab862a50d0c7e514077fdea161ae1989bf1e340/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8516178e51e495579b32bfdf6630079a4ffdf42", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8516178e51e495579b32bfdf6630079a4ffdf42", "html_url": "https://github.com/rust-lang/rust/commit/d8516178e51e495579b32bfdf6630079a4ffdf42"}], "stats": {"total": 239, "additions": 94, "deletions": 145}, "files": [{"sha": "58f801ca48e3a11a37ac636fcafb59e41b039831", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 94, "deletions": 145, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/4ab862a50d0c7e514077fdea161ae1989bf1e340/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ab862a50d0c7e514077fdea161ae1989bf1e340/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=4ab862a50d0c7e514077fdea161ae1989bf1e340", "patch": "@@ -11,6 +11,7 @@ import util::common::new_uint_hash;\n import util::common::new_str_hash;\n import util::common::span;\n import middle::tstate::ann::ts_ann;\n+import visit::vt;\n import std::map::hashmap;\n import std::list;\n import std::list::list;\n@@ -36,14 +37,16 @@ import std::vec;\n tag scope {\n     scope_crate(@ast::crate);\n     scope_item(@ast::item);\n+    scope_fn(ast::fn_decl, vec[ast::ty_param]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::decl); // there's only 1 decl per loop.\n     scope_block(ast::block);\n     scope_arm(ast::arm);\n }\n+type scopes = list[scope];\n \n tag import_state {\n-    todo(@ast::view_item, list[scope]); // only used for explicit imports\n+    todo(@ast::view_item, scopes); // only used for explicit imports\n     resolving(span);\n     resolved(option::t[def] /* value */,\n              option::t[def] /* type */,\n@@ -116,47 +119,43 @@ fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n                   ext_cache = new_ext_hash(),\n                   sess = sess);\n     creader::read_crates(sess, e.crate_map, *crate);\n-    map_crate(e, *crate);\n+    map_crate(e, crate);\n     resolve_imports(*e);\n     check_for_collisions(e, *crate);\n-    resolve_names(e, *crate);\n+    resolve_names(e, crate);\n     ret e.def_map;\n }\n \n \n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n \n-fn map_crate(&@env e, &ast::crate c) {\n-\n+fn map_crate(&@env e, &@ast::crate c) {\n     // First, find all the modules, and index the names that they contain\n-\n-    auto cell = @mutable nil[scope];\n-    auto index_names = \n-        rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n-            visit_crate_post = bind pop_env_for_crate(cell, _),\n-            visit_view_item_pre = bind index_vi(e, cell, _),\n-            visit_item_pre = bind index_i(e, cell, _),\n-            visit_item_post = bind pop_env_for_item(cell, _)\n-            with walk::default_visitor());\n-    // Register the top-level mod\n+    auto v_map_mod =\n+        @rec(visit_view_item = bind index_vi(e, _, _, _),\n+             visit_item = bind index_i(e, _, _, _)\n+             with *visit::default_visitor[scopes]());\n+    visit::visit_crate(*c, cons(scope_crate(c), @nil),\n+                       visit::vtor(v_map_mod));\n+    // Register the top-level mod \n     e.mod_map.insert(-1, @rec(m=some(c.node.module),\n                               index=index_mod(c.node.module),\n                               glob_imports=vec::empty[def](),\n                               glob_imported_names\n                               =new_str_hash[import_state]()));\n-    walk::walk_crate(index_names, c);\n \n-    fn index_vi(@env e, @mutable list[scope] sc, &@ast::view_item i) {\n+    fn index_vi(@env e, &@ast::view_item i, &scopes sc, &vt[scopes] v) {\n         alt (i.node) {\n             case (ast::view_item_import(_, ?ids, ?defid)) {\n-                e.imports.insert(defid._1, todo(i, {*sc}));\n+                e.imports.insert(defid._1, todo(i, sc));\n             }\n             case (_) {}\n         }\n     }\n-    fn index_i(@env e, @mutable list[scope] sc, &@ast::item i) {\n-        push_env_for_item(sc, i);\n+\n+    fn index_i(@env e, &@ast::item i, &scopes sc, &vt[scopes] v) {\n+        visit_item_with_scope(i, sc, v);\n         alt (i.node) {\n             case (ast::item_mod(_, ?md, ?defid)) {\n                 e.mod_map.insert(defid._1, \n@@ -195,18 +194,15 @@ fn map_crate(&@env e, &ast::crate c) {\n     }\n \n     // Next, assemble the links for globbed imports.\n-    cell = @mutable nil[scope];\n-    auto link_globs =\n-        rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n-            visit_crate_post = bind pop_env_for_crate(cell, _),\n-            visit_view_item_pre = bind link_glob(e, cell, _),\n-            visit_item_pre = bind push_env_for_item(cell, _),\n-            visit_item_post = bind pop_env_for_item(cell, _)\n-            with walk::default_visitor());\n-    walk::walk_crate(link_globs, c);\n+    auto v_link_glob =\n+        @rec(visit_view_item = bind link_glob(e, _, _, _),\n+             visit_item = visit_item_with_scope\n+             with *visit::default_visitor[scopes]());\n+    visit::visit_crate(*c, cons(scope_crate(c), @nil),\n+                       visit::vtor(v_link_glob));\n             \n-    fn link_glob(@env e, @mutable list[scope] sc, &@ast::view_item vi) {\n-        fn find_mod(@env e, list[scope] sc) -> @indexed_mod {\n+    fn link_glob(@env e, &@ast::view_item vi, &scopes sc, &vt[scopes] v) {\n+        fn find_mod(@env e, scopes sc) -> @indexed_mod {\n             alt (sc) {\n                 case (cons(scope_item(?i), ?tl)) {\n                     alt(i.node) {\n@@ -230,8 +226,8 @@ fn map_crate(&@env e, &ast::crate c) {\n         alt (vi.node) {\n             //if it really is a glob import, that is\n             case (ast::view_item_import_glob(?path, _)) {\n-                find_mod(e, *sc).glob_imports \n-                    += [follow_import(*e, {*sc}, path, vi.span)];\n+                find_mod(e, sc).glob_imports \n+                    += [follow_import(*e, sc, path, vi.span)];\n             }\n             case (_) {}\n         }\n@@ -251,52 +247,45 @@ fn resolve_imports(&env e) {\n     }\n }\n \n-fn resolve_names(&@env e, &ast::crate c) {\n-    auto cell = @mutable nil[scope];\n-    auto v = rec(visit_crate_pre = bind push_env_for_crate(cell, _),\n-                 visit_crate_post = bind pop_env_for_crate(cell, _),\n-                 visit_item_pre = bind push_env_for_item(cell, _),\n-                 visit_item_post = bind pop_env_for_item(cell, _),\n-                 visit_method_pre = bind push_env_for_method(cell, _),\n-                 visit_method_post = bind pop_env_for_method(cell, _),\n-                 visit_native_item_pre = bind push_env_for_n_item(cell, _),\n-                 visit_native_item_post = bind pop_env_for_n_item(cell, _),\n-                 visit_block_pre = bind push_env_for_block(cell, _),\n-                 visit_block_post = bind pop_env_for_block(cell, _),\n-                 visit_arm_pre = bind walk_arm(e, cell, _),\n-                 visit_arm_post = bind pop_env_for_arm(cell, _),\n-                 visit_expr_pre = bind walk_expr(e, cell, _),\n-                 visit_expr_post = bind pop_env_for_expr(cell, _),\n-                 visit_ty_pre = bind walk_ty(e, cell, _)\n-                 with walk::default_visitor());\n-    walk::walk_crate(v, c);\n-\n-    fn walk_expr(@env e, @mutable list[scope] sc, &@ast::expr exp) {\n-        push_env_for_expr(sc, exp);\n+fn resolve_names(&@env e, &@ast::crate c) {\n+    auto v = @rec(visit_native_item = visit_native_item_with_scope,\n+                  visit_item = visit_item_with_scope,\n+                  visit_block = visit_block_with_scope,\n+                  visit_arm = bind walk_arm(e, _, _, _),\n+                  visit_expr = bind walk_expr(e, _, _, _),\n+                  visit_ty = bind walk_ty(e, _, _, _),\n+                  visit_fn = visit_fn_with_scope\n+                  with *visit::default_visitor());\n+    visit::visit_crate(*c, cons(scope_crate(c), @nil),\n+                       visit::vtor(v));\n+\n+    fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n+        visit_expr_with_scope(exp, sc, v);\n         alt (exp.node) {\n             case (ast::expr_path(?p, ?a)) {\n-                auto df = lookup_path_strict(*e, {*sc}, exp.span,\n+                auto df = lookup_path_strict(*e, sc, exp.span,\n                                              p.node.idents, ns_value);\n                 e.def_map.insert(a.id, df);\n             }\n             case (_) {}\n         }\n     }\n-    fn walk_ty(@env e, @mutable list[scope] sc, &@ast::ty t) {\n+    fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n+        visit::visit_ty(t, sc, v);\n         alt (t.node) {\n             case (ast::ty_path(?p, ?a)) {\n-                auto new_def = lookup_path_strict(*e, {*sc}, t.span,\n+                auto new_def = lookup_path_strict(*e, sc, t.span,\n                                                   p.node.idents, ns_type);\n                 e.def_map.insert(a.id, new_def);\n             }\n             case (_) {}\n         }\n     }\n-    fn walk_arm(@env e, @mutable list[scope] sc, &ast::arm a) {\n-        walk_pat(*e, {*sc}, a.pat);\n-        push_env_for_arm(sc, a);\n+    fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n+        walk_pat(*e, sc, a.pat);\n+        visit_arm_with_scope(a, sc, v);\n     }\n-    fn walk_pat(&env e, &list[scope] sc, &@ast::pat pat) {\n+    fn walk_pat(&env e, &scopes sc, &@ast::pat pat) {\n         alt (pat.node) {\n             case (ast::pat_tag(?p, ?children, ?a)) {\n                 auto fnd = lookup_path_strict(e, sc, p.span, p.node.idents,\n@@ -319,81 +308,42 @@ fn resolve_names(&@env e, &ast::crate c) {\n     }\n }\n \n-// Helpers for tracking scope during a walk\n-\n-fn push_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n-    *sc = cons[scope](scope_crate(@c), @*sc);\n-}\n-fn pop_env_for_crate(@mutable list[scope] sc, &ast::crate c) {\n-    *sc = std::list::cdr({*sc});\n-}\n+// Visit helper functions\n \n-fn push_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n-    *sc = cons[scope](scope_item(i), @*sc);\n+fn visit_item_with_scope(&@ast::item i, &scopes sc, &vt[scopes] v) {\n+    visit::visit_item(i, cons(scope_item(i), @sc), v);\n }\n-fn pop_env_for_item(@mutable list[scope] sc, &@ast::item i) {\n-    *sc = std::list::cdr({*sc});\n+fn visit_native_item_with_scope(&@ast::native_item ni,\n+                                &scopes sc, &vt[scopes] v) {\n+    visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n-\n-fn push_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n-    let vec[ast::ty_param] tp = [];\n-    let @ast::item i = @rec(node=ast::item_fn(m.node.ident,\n-                                              m.node.meth,\n-                                              tp,\n-                                              m.node.id,\n-                                              m.node.ann),\n-                            span=m.span);\n-    *sc = cons[scope](scope_item(i), @*sc);\n+fn visit_fn_with_scope(&ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n+                       &ident name, &def_id d_id, &ann a,\n+                       &scopes sc, &vt[scopes] v) {\n+    visit::visit_fn(f, tp, sp, name, d_id, a,\n+                    cons(scope_fn(f.decl, tp), @sc), v);\n }\n-fn pop_env_for_method(@mutable list[scope] sc, &@ast::method m) {\n-    *sc = std::list::cdr({*sc});\n+fn visit_block_with_scope(&ast::block b, &scopes sc, &vt[scopes] v) {\n+    visit::visit_block(b, cons(scope_block(b), @sc), v);\n }\n-\n-fn push_env_for_n_item(@mutable list[scope] sc, &@ast::native_item i) {\n-    *sc = cons[scope](scope_native_item(i), @*sc);\n-}\n-fn pop_env_for_n_item(@mutable list[scope] sc, &@ast::native_item i) {\n-    *sc = std::list::cdr({*sc});\n-}\n-\n-fn push_env_for_block(@mutable list[scope] sc, &ast::block b) {\n-    *sc = cons[scope](scope_block(b), @*sc);\n-}\n-fn pop_env_for_block(@mutable list[scope] sc, &ast::block b) {\n-    *sc = std::list::cdr({*sc});\n-}\n-\n-fn push_env_for_expr(@mutable list[scope] sc, &@ast::expr x) {\n-    alt (x.node) {\n-        case (ast::expr_for(?d, _, _, _)) {\n-            *sc = cons[scope](scope_loop(d), @*sc);\n-        }\n-        case (ast::expr_for_each(?d, _, _, _)) {\n-            *sc = cons[scope](scope_loop(d), @*sc);\n-        }\n-        case (_) {}\n-    }\n+fn visit_arm_with_scope(&ast::arm a, &scopes sc, &vt[scopes] v) {\n+    visit::visit_arm(a, cons(scope_arm(a), @sc), v);\n }\n-fn pop_env_for_expr(@mutable list[scope] sc, &@ast::expr x) {\n-    alt (x.node) {\n+fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n+    auto new_sc = alt (x.node) {\n         case (ast::expr_for(?d, _, _, _)) {\n-            *sc = std::list::cdr({*sc});\n+            cons[scope](scope_loop(d), @sc)\n         }\n         case (ast::expr_for_each(?d, _, _, _)) {\n-            *sc = std::list::cdr({*sc});\n+            cons[scope](scope_loop(d), @sc)\n         }\n-        case (_) {}\n-    }\n+        case (_) { sc }\n+    };\n+    visit::visit_expr(x, new_sc, v);\n }\n \n-fn push_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n-    *sc = cons[scope](scope_arm(p), @*sc);\n-}\n-fn pop_env_for_arm(@mutable list[scope] sc, &ast::arm p) {\n-    *sc = std::list::cdr({*sc});\n-}\n \n-fn follow_import(&env e, &list[scope] sc, vec[ident] path, &span sp) \n+fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) \n     -> def {\n     auto path_len = vec::len(path);\n     auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n@@ -420,7 +370,7 @@ fn follow_import(&env e, &list[scope] sc, vec[ident] path, &span sp)\n \n // Import resolution\n \n-fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n+fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n     auto defid; auto ids;\n     alt (it.node) {\n         case (ast::view_item_import(_, ?_ids, ?_defid)) {\n@@ -487,7 +437,7 @@ fn unresolved(&env e, &span sp, &ident id, &str kind) -> ! {\n \n // Lookup helpers\n \n-fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n+fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n                       namespace ns) -> def {\n     auto n_idents = vec::len(idents);\n     auto headns = if (n_idents == 1u) { ns } else { ns_module };\n@@ -501,7 +451,7 @@ fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n     ret dcur;\n }\n                       \n-fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, &ident id,\n+fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident id,\n                         namespace ns) -> def {\n     alt (lookup_in_scope(e, sc, sp, id, ns)) {\n         case (none) {\n@@ -515,12 +465,7 @@ fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, &ident id,\n \n fn scope_is_fn(&scope sc) -> bool {\n     ret alt (sc) {\n-        case (scope_item(?it)) {\n-            alt (it.node) {\n-                case (ast::item_fn(_, _, _, _, _)) { true }\n-                case (_) { false }\n-            }\n-        }\n+        case (scope_fn(_, _)) { true }\n         case (scope_native_item(_)) { true }\n         case (_) { false }\n     };\n@@ -541,7 +486,7 @@ fn def_is_obj_field(&def d) -> bool {\n     };\n }\n \n-fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n+fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns)\n     -> option::t[def] {\n     fn in_scope(&env e, &span sp, &ident id, &scope s, namespace ns)\n         -> option::t[def] {\n@@ -554,9 +499,6 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n-                    case (ast::item_fn(_, ?f, ?ty_params, _, _)) {\n-                        ret lookup_in_fn(id, f.decl, ty_params, ns);\n-                    }\n                     case (ast::item_obj(_, ?ob, ?ty_params, _, _)) {\n                         ret lookup_in_obj(id, ob, ty_params, ns);\n                     }\n@@ -586,6 +528,9 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n                     }\n                 }\n             }\n+            case (scope_fn(?decl, ?ty_params)) {\n+                ret lookup_in_fn(id, decl, ty_params, ns);\n+            }\n             case (scope_loop(?d)) {\n                 if (ns == ns_value) {\n                     alt (d.node) {\n@@ -1118,11 +1063,11 @@ fn check_for_collisions(&@env e, &ast::crate c) {\n     }\n \n     // Other scopes have to be checked the hard way.\n-    auto v = rec(visit_item_pre = bind check_item(e, _),\n-                 visit_block_pre = bind check_block(e, _),\n-                 visit_arm_pre = bind check_arm(e, _)\n-                 with walk::default_visitor());\n-    walk::walk_crate(v, c);\n+    auto v = @rec(visit_item = bind check_item(e, _, _, _),\n+                  visit_block = bind check_block(e, _, _, _),\n+                  visit_arm = bind check_arm(e, _, _, _)\n+                  with *visit::default_visitor());\n+    visit::visit_crate(c, (), visit::vtor(v));\n }\n \n fn check_mod_name(&env e, &ident name, &list[mod_index_entry] entries) {\n@@ -1164,7 +1109,8 @@ fn mie_span(&mod_index_entry mie) -> span {\n }\n \n \n-fn check_item(@env e, &@ast::item i) {\n+fn check_item(@env e, &@ast::item i, &() x, &vt[()] v) {\n+    visit::visit_item(i, x, v);\n     alt (i.node) {\n         case (ast::item_fn(_, ?f, ?ty_params, _, _)) {\n             check_fn(*e, i.span, f);\n@@ -1187,7 +1133,8 @@ fn check_item(@env e, &@ast::item i) {\n     }\n }\n \n-fn check_arm(@env e, &ast::arm a) {\n+fn check_arm(@env e, &ast::arm a, &() x, &vt[()] v) {\n+    visit::visit_arm(a, x, v);\n     fn walk_pat(checker ch, &@ast::pat p) {\n         alt (p.node) {\n             case (ast::pat_bind(?name, _, _)) {\n@@ -1204,7 +1151,9 @@ fn check_arm(@env e, &ast::arm a) {\n     walk_pat(checker(*e, \"binding\"), a.pat);\n }\n \n-fn check_block(@env e, &ast::block b) {\n+fn check_block(@env e, &ast::block b, &() x, &vt[()] v) {\n+    visit::visit_block(b, x, v);\n+\n     auto values = checker(*e, \"value\");\n     auto types = checker(*e, \"type\");\n     auto mods = checker(*e, \"module\");"}]}