{"sha": "69a320f40d802060c27d022e98e91bba0a4cc537", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YTMyMGY0MGQ4MDIwNjBjMjdkMDIyZTk4ZTkxYmJhMGE0Y2M1Mzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-02T18:05:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T11:08:00Z"}, "message": "also validate everything that has a Scalar layout, to catch NonNull", "tree": {"sha": "71098e8d09ae160ba9aeb60b8c455c33cab686f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71098e8d09ae160ba9aeb60b8c455c33cab686f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69a320f40d802060c27d022e98e91bba0a4cc537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69a320f40d802060c27d022e98e91bba0a4cc537", "html_url": "https://github.com/rust-lang/rust/commit/69a320f40d802060c27d022e98e91bba0a4cc537", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69a320f40d802060c27d022e98e91bba0a4cc537/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a2fae6cb72a19e690b74bd57a67b9b36deef81c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2fae6cb72a19e690b74bd57a67b9b36deef81c", "html_url": "https://github.com/rust-lang/rust/commit/0a2fae6cb72a19e690b74bd57a67b9b36deef81c"}], "stats": {"total": 162, "additions": 146, "deletions": 16}, "files": [{"sha": "a174645b7ef5feb623054ef598dc047afd8c1ebb", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 86, "deletions": 8, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -140,14 +140,15 @@ fn scalar_format(value: ScalarMaybeUndef) -> String {\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    fn validate_scalar(\n+    /// Make sure that `value` is valid for `ty`\n+    fn validate_scalar_type(\n         &self,\n         value: ScalarMaybeUndef,\n         size: Size,\n         path: &Vec<PathElem>,\n         ty: Ty,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"validate scalar: {:#?}, {:#?}, {}\", value, size, ty);\n+        trace!(\"validate scalar by type: {:#?}, {:#?}, {}\", value, size, ty);\n \n         // Go over all the primitive types\n         match ty.sty {\n@@ -189,6 +190,62 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(())\n     }\n \n+    /// Make sure that `value` matches the\n+    fn validate_scalar_layout(\n+        &self,\n+        value: ScalarMaybeUndef,\n+        size: Size,\n+        path: &Vec<PathElem>,\n+        layout: &layout::Scalar,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"validate scalar by layout: {:#?}, {:#?}, {:#?}\", value, size, layout);\n+        let (lo, hi) = layout.valid_range.clone().into_inner();\n+        if lo == u128::min_value() && hi == u128::max_value() {\n+            // Nothing to check\n+            return Ok(());\n+        }\n+        // At least one value is excluded. Get the bits.\n+        let value = try_validation!(value.not_undef(),\n+            scalar_format(value), path, format!(\"something in the range {:?}\", layout.valid_range));\n+        let bits = match value {\n+            Scalar::Ptr(_) => {\n+                // Comparing a ptr with a range is not meaningfully possible.\n+                // In principle, *if* the pointer is inbonds, we could exclude NULL, but\n+                // that does not seem worth it.\n+                return Ok(());\n+            }\n+            Scalar::Bits { bits, size: value_size } => {\n+                assert_eq!(value_size as u64, size.bytes());\n+                bits\n+            }\n+        };\n+        // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n+        use std::ops::RangeInclusive;\n+        let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n+        if lo > hi {\n+            // wrapping around\n+            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n+                Ok(())\n+            } else {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?} or {:?}\", 0..=hi, lo..=u128::max_value())\n+                )\n+            }\n+        } else {\n+            if in_range(layout.valid_range.clone()) {\n+                Ok(())\n+            } else {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?}\", layout.valid_range)\n+                )\n+            }\n+        }\n+    }\n+\n     /// Validate a reference, potentially recursively. `place` is assumed to already be\n     /// dereferenced, i.e. it describes the target.\n     fn validate_ref(\n@@ -297,6 +354,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // Remember the length, in case we need to truncate\n         let path_len = path.len();\n \n+        // If this is a scalar, validate the scalar layout.\n+        // Things can be aggregates and have scalar layout at the same time, and that\n+        // is very relevant for `NonNull` and similar structs: We need to validate them\n+        // at their scalar layout *before* descending into their fields.\n+        match dest.layout.abi {\n+            layout::Abi::Uninhabited =>\n+                return validation_failure!(\"a value of an uninhabited type\", path),\n+            layout::Abi::Scalar(ref layout) => {\n+                let value = try_validation!(self.read_scalar(dest),\n+                            \"uninitialized or unrepresentable data\", path);\n+                self.validate_scalar_layout(value, dest.layout.size, &path, layout)?;\n+            }\n+            // FIXME: Should we do something for ScalarPair? Vector?\n+            _ => {}\n+        }\n+\n         // Validate all fields\n         match dest.layout.fields {\n             // Primitives appear as Union with 0 fields -- except for fat pointers.\n@@ -305,21 +378,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // fields to get a proper `path`.\n             layout::FieldPlacement::Union(0) => {\n                 match dest.layout.abi {\n-                    // nothing to do, whatever the pointer points to, it is never going to be read\n-                    layout::Abi::Uninhabited =>\n-                        return validation_failure!(\"a value of an uninhabited type\", path),\n                     // check that the scalar is a valid pointer or that its bit range matches the\n                     // expectation.\n                     layout::Abi::Scalar(_) => {\n                         let value = try_validation!(self.read_value(dest),\n                             \"uninitialized or unrepresentable data\", path);\n-                        let scalar = value.to_scalar_or_undef();\n-                        self.validate_scalar(scalar, dest.layout.size, &path, dest.layout.ty)?;\n+                        self.validate_scalar_type(\n+                            value.to_scalar_or_undef(),\n+                            dest.layout.size,\n+                            &path,\n+                            dest.layout.ty\n+                        )?;\n                         // Recursively check *safe* references\n                         if dest.layout.ty.builtin_deref(true).is_some() &&\n                             !dest.layout.ty.is_unsafe_ptr()\n                         {\n-                            self.validate_ref(self.ref_to_mplace(value)?, path, ref_tracking)?;\n+                            self.validate_ref(\n+                                self.ref_to_mplace(value)?,\n+                                path,\n+                                ref_tracking\n+                            )?;\n                         }\n                     },\n                     _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),"}, {"sha": "c9beca7aa30ac6aef684485cc9d983e55158cb92", "filename": "src/test/ui/consts/const-eval/transmute-const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ftransmute-const.stderr?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -2,7 +2,7 @@ error[E0080]: this static likely exhibits undefined behavior\n   --> $DIR/transmute-const.rs:15:1\n    |\n LL | static FOO: bool = unsafe { mem::transmute(3u8) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3, but expected a boolean\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "243343c94b065b0131dc4b30f4f9ff24916d2cca", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -18,7 +18,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:45:1\n    |\n LL | const BAD_ENUM_CHAR : Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .Some.0.1, but expected a valid unicode codepoint\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .Some.0.1, but expected something in the range 0..=1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "2b07eee3ccb465aa448d4ae023d3c683b018df58", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_transmute)]\n+\n+use std::mem;\n+use std::ptr::NonNull;\n+use std::num::{NonZeroU8, NonZeroUsize};\n+\n+const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {}"}, {"sha": "5ebec560da6e872631d71c3ffda52ed4f9e2e7af", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -0,0 +1,27 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-nonnull.rs:17:1\n+   |\n+LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something in the range 1..=18446744073709551615\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-nonnull.rs:20:1\n+   |\n+LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something in the range 1..=255\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-nonnull.rs:22:1\n+   |\n+LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something in the range 1..=18446744073709551615\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "2848bc62aee962ecafd60c5e8f1c82c525204b69", "filename": "src/test/ui/consts/const-eval/union-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -13,7 +13,7 @@ LL | / const FIELD_PATH: Struct = Struct { //~ ERROR this constant likely exhibi\n LL | |     a: 42,\n LL | |     b: unsafe { UNION.field3 },\n LL | | };\n-   | |__^ type validation failed: encountered uninitialized bytes at .b, but expected initialized plain bits\n+   | |__^ type validation failed: encountered uninitialized bytes at .b, but expected something in the range 0..=18446744073709551615\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "2a04dae337b271616a5662179ee57f1d4aa39cda", "filename": "src/test/ui/consts/const-eval/union-ub.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.stderr?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -2,7 +2,7 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub.rs:36:1\n    |\n LL | const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected a boolean\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "08aaa40e2f3c9e8b564de169487c63db5ca05689", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69a320f40d802060c27d022e98e91bba0a4cc537/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=69a320f40d802060c27d022e98e91bba0a4cc537", "patch": "@@ -66,31 +66,31 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:116:1\n    |\n LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected a boolean\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:119:1\n    |\n LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:125:1\n    |\n LL | const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:128:1\n    |\n LL | const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}