{"sha": "a322848c6b0e037c1f0209387558ecb6ab763714", "node_id": "C_kwDOAAsO6NoAKGEzMjI4NDhjNmIwZTAzN2MxZjAyMDkzODc1NThlY2I2YWI3NjM3MTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-30T17:01:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-30T17:01:29Z"}, "message": "Auto merge of #107472 - matthiaskrgr:rollup-s9gn4n7, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #107125 (Add and use expect methods to hir.)\n - #107172 (Reimplement NormalizeArrayLen based on SsaLocals)\n - #107177 (Keep all theme-updating logic together)\n - #107424 (Make Vec::clone_from and slice::clone_into share the same code)\n - #107455 (use a more descriptive name)\n - #107465 (`has_allow_dead_code_or_lang_attr` micro refactor)\n - #107469 (Change turbofish context link to an archive link)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8e750043fdb7da14adc43c892f341b9b3bdd76d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e750043fdb7da14adc43c892f341b9b3bdd76d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a322848c6b0e037c1f0209387558ecb6ab763714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a322848c6b0e037c1f0209387558ecb6ab763714", "html_url": "https://github.com/rust-lang/rust/commit/a322848c6b0e037c1f0209387558ecb6ab763714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a322848c6b0e037c1f0209387558ecb6ab763714/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "006ca9b14da1e0145844598b3d6a554c042c702a", "url": "https://api.github.com/repos/rust-lang/rust/commits/006ca9b14da1e0145844598b3d6a554c042c702a", "html_url": "https://github.com/rust-lang/rust/commit/006ca9b14da1e0145844598b3d6a554c042c702a"}, {"sha": "d79a40d4d3997d1fc5244225323349f0fb36e1d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d79a40d4d3997d1fc5244225323349f0fb36e1d8", "html_url": "https://github.com/rust-lang/rust/commit/d79a40d4d3997d1fc5244225323349f0fb36e1d8"}], "stats": {"total": 1271, "additions": 685, "deletions": 586}, "files": [{"sha": "a063307af0cb4109e7c14dddf7504df9584e9839", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 360, "deletions": 3, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -2263,7 +2263,7 @@ pub struct TraitItem<'hir> {\n     pub defaultness: Defaultness,\n }\n \n-impl TraitItem<'_> {\n+impl<'hir> TraitItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2273,6 +2273,32 @@ impl TraitItem<'_> {\n     pub fn trait_item_id(&self) -> TraitItemId {\n         TraitItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`TraitItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, Option<BodyId>) {\n+        let TraitItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`TraitItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &TraitFn<'hir>) {\n+        let TraitItemKind::Fn(ty, trfn) = &self.kind else { self.expect_failed(\"a function\") };\n+        (ty, trfn)\n+    }\n+\n+    /// Expect an [`TraitItemKind::Type`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> (GenericBounds<'hir>, Option<&'hir Ty<'hir>>) {\n+        let TraitItemKind::Type(bounds, ty) = self.kind else { self.expect_failed(\"a type\") };\n+        (bounds, ty)\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents a trait method's body (or just argument names).\n@@ -2325,7 +2351,7 @@ pub struct ImplItem<'hir> {\n     pub vis_span: Span,\n }\n \n-impl ImplItem<'_> {\n+impl<'hir> ImplItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2335,6 +2361,32 @@ impl ImplItem<'_> {\n     pub fn impl_item_id(&self) -> ImplItemId {\n         ImplItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ImplItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ImplItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, BodyId) {\n+        let ImplItemKind::Fn(ty, body) = &self.kind else { self.expect_failed(\"a function\") };\n+        (ty, *body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::Type`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> &'hir Ty<'hir> {\n+        let ImplItemKind::Type(ty) = self.kind else { self.expect_failed(\"a type\") };\n+        ty\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents various kinds of content within an `impl`.\n@@ -2995,7 +3047,7 @@ pub struct Item<'hir> {\n     pub vis_span: Span,\n }\n \n-impl Item<'_> {\n+impl<'hir> Item<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -3005,6 +3057,132 @@ impl Item<'_> {\n     pub fn item_id(&self) -> ItemId {\n         ItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ItemKind::ExternCrate`] or panic.\n+    #[track_caller]\n+    pub fn expect_extern_crate(&self) -> Option<Symbol> {\n+        let ItemKind::ExternCrate(s) = self.kind else { self.expect_failed(\"an extern crate\") };\n+        s\n+    }\n+\n+    /// Expect an [`ItemKind::Use`] or panic.\n+    #[track_caller]\n+    pub fn expect_use(&self) -> (&'hir UsePath<'hir>, UseKind) {\n+        let ItemKind::Use(p, uk) = self.kind else { self.expect_failed(\"a use\") };\n+        (p, uk)\n+    }\n+\n+    /// Expect an [`ItemKind::Static`] or panic.\n+    #[track_caller]\n+    pub fn expect_static(&self) -> (&'hir Ty<'hir>, Mutability, BodyId) {\n+        let ItemKind::Static(ty, mutbl, body) = self.kind else { self.expect_failed(\"a static\") };\n+        (ty, mutbl, body)\n+    }\n+    /// Expect an [`ItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+    /// Expect an [`ItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &'hir Generics<'hir>, BodyId) {\n+        let ItemKind::Fn(sig, gen, body) = &self.kind else { self.expect_failed(\"a function\") };\n+        (sig, gen, *body)\n+    }\n+\n+    /// Expect an [`ItemKind::Macro`] or panic.\n+    #[track_caller]\n+    pub fn expect_macro(&self) -> (&ast::MacroDef, MacroKind) {\n+        let ItemKind::Macro(def, mk) = &self.kind else { self.expect_failed(\"a macro\") };\n+        (def, *mk)\n+    }\n+\n+    /// Expect an [`ItemKind::Mod`] or panic.\n+    #[track_caller]\n+    pub fn expect_mod(&self) -> &'hir Mod<'hir> {\n+        let ItemKind::Mod(m) = self.kind else { self.expect_failed(\"a module\") };\n+        m\n+    }\n+\n+    /// Expect an [`ItemKind::ForeignMod`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_mod(&self) -> (Abi, &'hir [ForeignItemRef]) {\n+        let ItemKind::ForeignMod { abi, items } = self.kind else { self.expect_failed(\"a foreign module\") };\n+        (abi, items)\n+    }\n+\n+    /// Expect an [`ItemKind::GlobalAsm`] or panic.\n+    #[track_caller]\n+    pub fn expect_global_asm(&self) -> &'hir InlineAsm<'hir> {\n+        let ItemKind::GlobalAsm(asm) = self.kind else { self.expect_failed(\"a global asm\") };\n+        asm\n+    }\n+\n+    /// Expect an [`ItemKind::TyAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty_alias(&self) -> (&'hir Ty<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::TyAlias(ty, gen) = self.kind else { self.expect_failed(\"a type alias\") };\n+        (ty, gen)\n+    }\n+\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n+    /// Expect an [`ItemKind::OpaqueTy`] or panic.\n+    #[track_caller]\n+    pub fn expect_opaque_ty(&self) -> &OpaqueTy<'hir> {\n+        let ItemKind::OpaqueTy(ty) = &self.kind else { self.expect_failed(\"an opaque type\") };\n+        ty\n+    }\n+\n+    /// Expect an [`ItemKind::Enum`] or panic.\n+    #[track_caller]\n+    pub fn expect_enum(&self) -> (&EnumDef<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Enum(def, gen) = &self.kind else { self.expect_failed(\"an enum\") };\n+        (def, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Struct`] or panic.\n+    #[track_caller]\n+    pub fn expect_struct(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Struct(data, gen) = &self.kind else { self.expect_failed(\"a struct\") };\n+        (data, gen)\n+    }\n+\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n+    /// Expect an [`ItemKind::Union`] or panic.\n+    #[track_caller]\n+    pub fn expect_union(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Union(data, gen) = &self.kind else { self.expect_failed(\"a union\") };\n+        (data, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Trait`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait(\n+        self,\n+    ) -> (IsAuto, Unsafety, &'hir Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]) {\n+        let ItemKind::Trait(is_auto, unsafety, gen, bounds, items) = self.kind else { self.expect_failed(\"a trait\") };\n+        (is_auto, unsafety, gen, bounds, items)\n+    }\n+\n+    /// Expect an [`ItemKind::TraitAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_alias(&self) -> (&'hir Generics<'hir>, GenericBounds<'hir>) {\n+        let ItemKind::TraitAlias(gen, bounds) = self.kind else { self.expect_failed(\"a trait alias\") };\n+        (gen, bounds)\n+    }\n+\n+    /// Expect an [`ItemKind::Impl`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl(&self) -> &'hir Impl<'hir> {\n+        let ItemKind::Impl(imp) = self.kind else { self.expect_failed(\"an impl\") };\n+        imp\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -3597,6 +3775,185 @@ impl<'hir> Node<'hir> {\n     pub fn tuple_fields(&self) -> Option<&'hir [FieldDef<'hir>]> {\n         if let Node::Ctor(&VariantData::Tuple(fields, _, _)) = self { Some(fields) } else { None }\n     }\n+\n+    /// Expect a [`Node::Param`] or panic.\n+    #[track_caller]\n+    pub fn expect_param(self) -> &'hir Param<'hir> {\n+        let Node::Param(this) = self else { self.expect_failed(\"a parameter\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Item`] or panic.\n+    #[track_caller]\n+    pub fn expect_item(self) -> &'hir Item<'hir> {\n+        let Node::Item(this) = self else { self.expect_failed(\"a item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ForeignItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_item(self) -> &'hir ForeignItem<'hir> {\n+        let Node::ForeignItem(this) = self else { self.expect_failed(\"a foreign item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_item(self) -> &'hir TraitItem<'hir> {\n+        let Node::TraitItem(this) = self else { self.expect_failed(\"a trait item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ImplItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl_item(self) -> &'hir ImplItem<'hir> {\n+        let Node::ImplItem(this) = self else { self.expect_failed(\"an implementation item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Variant`] or panic.\n+    #[track_caller]\n+    pub fn expect_variant(self) -> &'hir Variant<'hir> {\n+        let Node::Variant(this) = self else { self.expect_failed(\"a variant\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Field`] or panic.\n+    #[track_caller]\n+    pub fn expect_field(self) -> &'hir FieldDef<'hir> {\n+        let Node::Field(this) = self else { self.expect_failed(\"a field definition\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::AnonConst`] or panic.\n+    #[track_caller]\n+    pub fn expect_anon_const(self) -> &'hir AnonConst {\n+        let Node::AnonConst(this) = self else { self.expect_failed(\"an anonymous constant\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Expr`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr(self) -> &'hir Expr<'hir> {\n+        let Node::Expr(this) = self else { self.expect_failed(\"an expression\") };\n+        this\n+    }\n+    /// Expect a [`Node::ExprField`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr_field(self) -> &'hir ExprField<'hir> {\n+        let Node::ExprField(this) = self else { self.expect_failed(\"an expression field\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Stmt`] or panic.\n+    #[track_caller]\n+    pub fn expect_stmt(self) -> &'hir Stmt<'hir> {\n+        let Node::Stmt(this) = self else { self.expect_failed(\"a statement\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PathSegment`] or panic.\n+    #[track_caller]\n+    pub fn expect_path_segment(self) -> &'hir PathSegment<'hir> {\n+        let Node::PathSegment(this) = self else { self.expect_failed(\"a path segment\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ty`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty(self) -> &'hir Ty<'hir> {\n+        let Node::Ty(this) = self else { self.expect_failed(\"a type\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TypeBinding`] or panic.\n+    #[track_caller]\n+    pub fn expect_type_binding(self) -> &'hir TypeBinding<'hir> {\n+        let Node::TypeBinding(this) = self else { self.expect_failed(\"a type binding\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitRef`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_ref(self) -> &'hir TraitRef<'hir> {\n+        let Node::TraitRef(this) = self else { self.expect_failed(\"a trait reference\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Pat`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat(self) -> &'hir Pat<'hir> {\n+        let Node::Pat(this) = self else { self.expect_failed(\"a pattern\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PatField`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat_field(self) -> &'hir PatField<'hir> {\n+        let Node::PatField(this) = self else { self.expect_failed(\"a pattern field\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Arm`] or panic.\n+    #[track_caller]\n+    pub fn expect_arm(self) -> &'hir Arm<'hir> {\n+        let Node::Arm(this) = self else { self.expect_failed(\"an arm\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Block`] or panic.\n+    #[track_caller]\n+    pub fn expect_block(self) -> &'hir Block<'hir> {\n+        let Node::Block(this) = self else { self.expect_failed(\"a block\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Local`] or panic.\n+    #[track_caller]\n+    pub fn expect_local(self) -> &'hir Local<'hir> {\n+        let Node::Local(this) = self else { self.expect_failed(\"a local\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ctor`] or panic.\n+    #[track_caller]\n+    pub fn expect_ctor(self) -> &'hir VariantData<'hir> {\n+        let Node::Ctor(this) = self else { self.expect_failed(\"a constructor\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Lifetime`] or panic.\n+    #[track_caller]\n+    pub fn expect_lifetime(self) -> &'hir Lifetime {\n+        let Node::Lifetime(this) = self else { self.expect_failed(\"a lifetime\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::GenericParam`] or panic.\n+    #[track_caller]\n+    pub fn expect_generic_param(self) -> &'hir GenericParam<'hir> {\n+        let Node::GenericParam(this) = self else { self.expect_failed(\"a generic parameter\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Crate`] or panic.\n+    #[track_caller]\n+    pub fn expect_crate(self) -> &'hir Mod<'hir> {\n+        let Node::Crate(this) = self else { self.expect_failed(\"a crate\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Infer`] or panic.\n+    #[track_caller]\n+    pub fn expect_infer(self) -> &'hir InferArg {\n+        let Node::Infer(this) = self else { self.expect_failed(\"an infer\") };\n+        this\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} node, found {self:?}\")\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "bec9f0ff0772cb8a9862d65f761f07282b4be2cf", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -3140,8 +3140,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), ident, .. }) =\n             hir.get(fn_hir_id) else { return None };\n-        let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n-                hir.get_parent(fn_hir_id) else { bug!(\"ImplItem should have Impl parent\") };\n+        let i = hir.get_parent(fn_hir_id).expect_item().expect_impl();\n \n         let trait_ref = self.instantiate_mono_trait_ref(\n             i.of_trait.as_ref()?,"}, {"sha": "3115f5f464a09c44969f09a03cd1d81db92dd27a", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n-use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc_hir::{GenericParamKind, ImplItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n@@ -918,7 +918,7 @@ fn report_trait_method_mismatch<'tcx>(\n             // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n             // span points only at the type `Box<Self`>, but we want to cover the whole\n             // argument pattern and type.\n-            let ImplItemKind::Fn(ref sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{impl_m:?} is not a method\") };\n+            let (sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n             let span = tcx\n                 .hir()\n                 .body_param_names(body)\n@@ -1080,12 +1080,12 @@ fn extract_spans_for_error_reporting<'tcx>(\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let mut impl_args = {\n-        let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (sig, _) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     };\n \n     let trait_args = trait_m.def_id.as_local().map(|def_id| {\n-        let TraitItemKind::Fn(sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m) };\n+        let (sig, _) = tcx.hir().expect_trait_item(def_id).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     });\n \n@@ -1358,7 +1358,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             .def_id\n             .as_local()\n             .and_then(|def_id| {\n-                let TraitItemKind::Fn(trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+                let (trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).expect_fn();\n                 let pos = trait_number_args.saturating_sub(1);\n                 trait_m_sig.decl.inputs.get(pos).map(|arg| {\n                     if pos == 0 {\n@@ -1370,7 +1370,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             })\n             .or(trait_item_span);\n \n-        let ImplItemKind::Fn(impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         let pos = impl_number_args.saturating_sub(1);\n         let impl_span = impl_m_sig\n             .decl\n@@ -1506,7 +1506,7 @@ fn compare_synthetic_generics<'tcx>(\n                     let _: Option<_> = try {\n                         let impl_m = impl_m.def_id.as_local()?;\n                         let impl_m = tcx.hir().expect_impl_item(impl_m);\n-                        let hir::ImplItemKind::Fn(sig, _) = &impl_m.kind else { unreachable!() };\n+                        let (sig, _) = impl_m.expect_fn();\n                         let input_tys = sig.decl.inputs;\n \n                         struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n@@ -1704,7 +1704,7 @@ pub(super) fn compare_impl_const_raw(\n         );\n \n         // Locate the Span containing just the type of the offending impl\n-        let ImplItemKind::Const(ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).kind else { bug!(\"{impl_const_item:?} is not a impl const\") };\n+        let (ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).expect_const();\n         cause.span = ty.span;\n \n         let mut diag = struct_span_err!(\n@@ -1717,7 +1717,7 @@ pub(super) fn compare_impl_const_raw(\n \n         let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n             // Add a label to the Span containing just the type of the const\n-            let TraitItemKind::Const(ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).kind else { bug!(\"{trait_const_item:?} is not a trait const\") };\n+            let (ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).expect_const();\n             ty.span\n         });\n "}, {"sha": "5b9b57da3820e48e8a2c42a8364db3971384d272", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -1072,8 +1072,8 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             // All field types must be well-formed.\n             for field in &variant.fields {\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n                     hir_ty.span,\n@@ -1106,8 +1106,8 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             {\n                 let last = idx == variant.fields.len() - 1;\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new("}, {"sha": "5716be4f1a95445c5f4db941b7c89123f440c13b", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -29,7 +29,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n         if item.span.is_dummy() {\n             continue;\n         }\n-        let hir::ItemKind::Use(path, _) = item.kind else { unreachable!() };\n+        let (path, _) = item.expect_use();\n         let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(path.span) {\n             format!(\"unused import: `{}`\", snippet)\n         } else {"}, {"sha": "6600e4216bd1f4a54304af6e41bc128ff22d4670", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -56,7 +56,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => {}\n     }\n \n-    let ItemKind::Impl(impl_) = tcx.hir().expect_item(impl_did).kind else { bug!(\"expected Drop impl item\") };\n+    let impl_ = tcx.hir().expect_item(impl_did).expect_impl();\n \n     tcx.sess.emit_err(DropImplOnWrongItem { span: impl_.self_ty.span });\n }"}, {"sha": "c6b16171311fb0de221c0bbcb9c2c667a7aba35d", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -3,15 +3,13 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::Unsafety;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::LocalDefId;\n \n pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Impl));\n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = item.expect_impl();\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_ref = trait_ref.subst_identity();"}, {"sha": "cc7235a61c0b822ef6c9ba0cbc71162b2ab949f9", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -1348,8 +1348,7 @@ fn suggest_impl_trait<'tcx>(\n \n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = tcx.hir().expect_item(def_id.expect_local()).expect_impl();\n     impl_\n         .of_trait\n         .as_ref()"}, {"sha": "7a05ee2ff37fdc3dbc3324603b203fec44e59f60", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -318,16 +318,19 @@ impl<'tcx> CodegenUnit<'tcx> {\n         base_n::encode(hash, base_n::CASE_INSENSITIVE)\n     }\n \n-    pub fn estimate_size(&mut self, tcx: TyCtxt<'tcx>) {\n+    pub fn create_size_estimate(&mut self, tcx: TyCtxt<'tcx>) {\n         // Estimate the size of a codegen unit as (approximately) the number of MIR\n         // statements it corresponds to.\n         self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n     }\n \n     #[inline]\n+    /// Should only be called if [`create_size_estimate`] has previously been called.\n+    ///\n+    /// [`create_size_estimate`]: Self::create_size_estimate\n     pub fn size_estimate(&self) -> usize {\n-        // Should only be called if `estimate_size` has previously been called.\n-        self.size_estimate.expect(\"estimate_size must be called before getting a size_estimate\")\n+        self.size_estimate\n+            .expect(\"create_size_estimate must be called before getting a size_estimate\")\n     }\n \n     pub fn modify_size_estimate(&mut self, delta: usize) {"}, {"sha": "cbebca15483de9da56b1b1f9b55a21c3b173dcb6", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -548,13 +548,13 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &[\n             &reveal_all::RevealAll, // has to be done before inlining, since inlined code is in RevealAll mode.\n             &lower_slice_len::LowerSliceLenCalls, // has to be done before inlining, otherwise actual call will be almost always inlined. Also simple, so can just do first\n-            &normalize_array_len::NormalizeArrayLen, // has to run after `slice::len` lowering\n             &unreachable_prop::UnreachablePropagation,\n             &uninhabited_enum_branching::UninhabitedEnumBranching,\n             &o1(simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\")),\n             &inline::Inline,\n             &remove_storage_markers::RemoveStorageMarkers,\n             &remove_zsts::RemoveZsts,\n+            &normalize_array_len::NormalizeArrayLen, // has to run after `slice::len` lowering\n             &const_goto::ConstGoto,\n             &remove_unneeded_drops::RemoveUnneededDrops,\n             &sroa::ScalarReplacementOfAggregates,"}, {"sha": "b36c8a0bd5369b45fbb2864b5302957c576c4d7c", "filename": "compiler/rustc_mir_transform/src/normalize_array_len.rs", "status": "modified", "additions": 69, "deletions": 253, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnormalize_array_len.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -1,288 +1,104 @@\n //! This pass eliminates casting of arrays into slices when their length\n //! is taken using `.len()` method. Handy to preserve information in MIR for const prop\n \n+use crate::ssa::SsaLocals;\n use crate::MirPass;\n-use rustc_data_structures::fx::FxIndexMap;\n-use rustc_data_structures::intern::Interned;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, ReErased, Region, TyCtxt};\n-\n-const MAX_NUM_BLOCKS: usize = 800;\n-const MAX_NUM_LOCALS: usize = 3000;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_mir_dataflow::impls::borrowed_locals;\n \n pub struct NormalizeArrayLen;\n \n impl<'tcx> MirPass<'tcx> for NormalizeArrayLen {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n-        // See #105929\n-        sess.mir_opt_level() >= 4 && sess.opts.unstable_opts.unsound_mir_opts\n+        sess.mir_opt_level() >= 3\n     }\n \n+    #[instrument(level = \"trace\", skip(self, tcx, body))]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        // early returns for edge cases of highly unrolled functions\n-        if body.basic_blocks.len() > MAX_NUM_BLOCKS {\n-            return;\n-        }\n-        if body.local_decls.len() > MAX_NUM_LOCALS {\n-            return;\n-        }\n+        debug!(def_id = ?body.source.def_id());\n         normalize_array_len_calls(tcx, body)\n     }\n }\n \n-pub fn normalize_array_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    // We don't ever touch terminators, so no need to invalidate the CFG cache\n-    let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n-    let local_decls = &mut body.local_decls;\n+fn normalize_array_len_calls<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n+    let borrowed_locals = borrowed_locals(body);\n+    let ssa = SsaLocals::new(tcx, param_env, body, &borrowed_locals);\n \n-    // do a preliminary analysis to see if we ever have locals of type `[T;N]` or `&[T;N]`\n-    let mut interesting_locals = BitSet::new_empty(local_decls.len());\n-    for (local, decl) in local_decls.iter_enumerated() {\n-        match decl.ty.kind() {\n-            ty::Array(..) => {\n-                interesting_locals.insert(local);\n-            }\n-            ty::Ref(.., ty, Mutability::Not) => match ty.kind() {\n-                ty::Array(..) => {\n-                    interesting_locals.insert(local);\n-                }\n-                _ => {}\n-            },\n-            _ => {}\n-        }\n-    }\n-    if interesting_locals.is_empty() {\n-        // we have found nothing to analyze\n-        return;\n-    }\n-    let num_intesting_locals = interesting_locals.count();\n-    let mut state = FxIndexMap::with_capacity_and_hasher(num_intesting_locals, Default::default());\n-    let mut patches_scratchpad =\n-        FxIndexMap::with_capacity_and_hasher(num_intesting_locals, Default::default());\n-    let mut replacements_scratchpad =\n-        FxIndexMap::with_capacity_and_hasher(num_intesting_locals, Default::default());\n-    for block in basic_blocks {\n-        // make length calls for arrays [T; N] not to decay into length calls for &[T]\n-        // that forbids constant propagation\n-        normalize_array_len_call(\n-            tcx,\n-            block,\n-            local_decls,\n-            &interesting_locals,\n-            &mut state,\n-            &mut patches_scratchpad,\n-            &mut replacements_scratchpad,\n-        );\n-        state.clear();\n-        patches_scratchpad.clear();\n-        replacements_scratchpad.clear();\n-    }\n-}\n+    let slice_lengths = compute_slice_length(tcx, &ssa, body);\n+    debug!(?slice_lengths);\n \n-struct Patcher<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    patches_scratchpad: &'a FxIndexMap<usize, usize>,\n-    replacements_scratchpad: &'a mut FxIndexMap<usize, Local>,\n-    local_decls: &'a mut IndexVec<Local, LocalDecl<'tcx>>,\n-    statement_idx: usize,\n+    Replacer { tcx, slice_lengths }.visit_body_preserves_cfg(body);\n }\n \n-impl<'tcx> Patcher<'_, 'tcx> {\n-    fn patch_expand_statement(\n-        &mut self,\n-        statement: &mut Statement<'tcx>,\n-    ) -> Option<std::vec::IntoIter<Statement<'tcx>>> {\n-        let idx = self.statement_idx;\n-        if let Some(len_statemnt_idx) = self.patches_scratchpad.get(&idx).copied() {\n-            let mut statements = Vec::with_capacity(2);\n-\n-            // we are at statement that performs a cast. The only sound way is\n-            // to create another local that performs a similar copy without a cast and then\n-            // use this copy in the Len operation\n-\n-            match &statement.kind {\n-                StatementKind::Assign(box (\n-                    ..,\n-                    Rvalue::Cast(\n-                        CastKind::Pointer(ty::adjustment::PointerCast::Unsize),\n-                        operand,\n-                        _,\n-                    ),\n-                )) => {\n-                    match operand {\n-                        Operand::Copy(place) | Operand::Move(place) => {\n-                            // create new local\n-                            let ty = operand.ty(self.local_decls, self.tcx);\n-                            let local_decl = LocalDecl::with_source_info(ty, statement.source_info);\n-                            let local = self.local_decls.push(local_decl);\n-                            // make it live\n-                            let mut make_live_statement = statement.clone();\n-                            make_live_statement.kind = StatementKind::StorageLive(local);\n-                            statements.push(make_live_statement);\n-                            // copy into it\n-\n-                            let operand = Operand::Copy(*place);\n-                            let mut make_copy_statement = statement.clone();\n-                            let assign_to = Place::from(local);\n-                            let rvalue = Rvalue::Use(operand);\n-                            make_copy_statement.kind =\n-                                StatementKind::Assign(Box::new((assign_to, rvalue)));\n-                            statements.push(make_copy_statement);\n-\n-                            // to reorder we have to copy and make NOP\n-                            statements.push(statement.clone());\n-                            statement.make_nop();\n-\n-                            self.replacements_scratchpad.insert(len_statemnt_idx, local);\n-                        }\n-                        _ => {\n-                            unreachable!(\"it's a bug in the implementation\")\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    unreachable!(\"it's a bug in the implementation\")\n+fn compute_slice_length<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ssa: &SsaLocals,\n+    body: &Body<'tcx>,\n+) -> IndexVec<Local, Option<ty::Const<'tcx>>> {\n+    let mut slice_lengths = IndexVec::from_elem(None, &body.local_decls);\n+\n+    for (local, rvalue) in ssa.assignments(body) {\n+        match rvalue {\n+            Rvalue::Cast(\n+                CastKind::Pointer(ty::adjustment::PointerCast::Unsize),\n+                operand,\n+                cast_ty,\n+            ) => {\n+                let operand_ty = operand.ty(body, tcx);\n+                debug!(?operand_ty);\n+                if let Some(operand_ty) = operand_ty.builtin_deref(true)\n+                    && let ty::Array(_, len) = operand_ty.ty.kind()\n+                    && let Some(cast_ty) = cast_ty.builtin_deref(true)\n+                    && let ty::Slice(..) = cast_ty.ty.kind()\n+                {\n+                    slice_lengths[local] = Some(*len);\n                 }\n             }\n-\n-            self.statement_idx += 1;\n-\n-            Some(statements.into_iter())\n-        } else if let Some(local) = self.replacements_scratchpad.get(&idx).copied() {\n-            let mut statements = Vec::with_capacity(2);\n-\n-            match &statement.kind {\n-                StatementKind::Assign(box (into, Rvalue::Len(place))) => {\n-                    let add_deref = if let Some(..) = place.as_local() {\n-                        false\n-                    } else if let Some(..) = place.local_or_deref_local() {\n-                        true\n-                    } else {\n-                        unreachable!(\"it's a bug in the implementation\")\n-                    };\n-                    // replace len statement\n-                    let mut len_statement = statement.clone();\n-                    let mut place = Place::from(local);\n-                    if add_deref {\n-                        place = self.tcx.mk_place_deref(place);\n-                    }\n-                    len_statement.kind =\n-                        StatementKind::Assign(Box::new((*into, Rvalue::Len(place))));\n-                    statements.push(len_statement);\n-\n-                    // make temporary dead\n-                    let mut make_dead_statement = statement.clone();\n-                    make_dead_statement.kind = StatementKind::StorageDead(local);\n-                    statements.push(make_dead_statement);\n-\n-                    // make original statement NOP\n-                    statement.make_nop();\n+            // The length information is stored in the fat pointer, so we treat `operand` as a value.\n+            Rvalue::Use(operand) => {\n+                if let Some(rhs) = operand.place() && let Some(rhs) = rhs.as_local() {\n+                    slice_lengths[local] = slice_lengths[rhs];\n                 }\n-                _ => {\n-                    unreachable!(\"it's a bug in the implementation\")\n+            }\n+            // The length information is stored in the fat pointer.\n+            // Reborrowing copies length information from one pointer to the other.\n+            Rvalue::Ref(_, _, rhs) | Rvalue::AddressOf(_, rhs) => {\n+                if let [PlaceElem::Deref] = rhs.projection[..] {\n+                    slice_lengths[local] = slice_lengths[rhs.local];\n                 }\n             }\n-\n-            self.statement_idx += 1;\n-\n-            Some(statements.into_iter())\n-        } else {\n-            self.statement_idx += 1;\n-            None\n+            _ => {}\n         }\n     }\n+\n+    slice_lengths\n }\n \n-fn normalize_array_len_call<'tcx>(\n+struct Replacer<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    block: &mut BasicBlockData<'tcx>,\n-    local_decls: &mut IndexVec<Local, LocalDecl<'tcx>>,\n-    interesting_locals: &BitSet<Local>,\n-    state: &mut FxIndexMap<Local, usize>,\n-    patches_scratchpad: &mut FxIndexMap<usize, usize>,\n-    replacements_scratchpad: &mut FxIndexMap<usize, Local>,\n-) {\n-    for (statement_idx, statement) in block.statements.iter_mut().enumerate() {\n-        match &mut statement.kind {\n-            StatementKind::Assign(box (place, rvalue)) => {\n-                match rvalue {\n-                    Rvalue::Cast(\n-                        CastKind::Pointer(ty::adjustment::PointerCast::Unsize),\n-                        operand,\n-                        cast_ty,\n-                    ) => {\n-                        let Some(local) = place.as_local() else { return };\n-                        match operand {\n-                            Operand::Copy(place) | Operand::Move(place) => {\n-                                let Some(operand_local) = place.local_or_deref_local() else { return; };\n-                                if !interesting_locals.contains(operand_local) {\n-                                    return;\n-                                }\n-                                let operand_ty = local_decls[operand_local].ty;\n-                                match (operand_ty.kind(), cast_ty.kind()) {\n-                                    (ty::Array(of_ty_src, ..), ty::Slice(of_ty_dst)) => {\n-                                        if of_ty_src == of_ty_dst {\n-                                            // this is a cast from [T; N] into [T], so we are good\n-                                            state.insert(local, statement_idx);\n-                                        }\n-                                    }\n-                                    // current way of patching doesn't allow to work with `mut`\n-                                    (\n-                                        ty::Ref(\n-                                            Region(Interned(ReErased, _)),\n-                                            operand_ty,\n-                                            Mutability::Not,\n-                                        ),\n-                                        ty::Ref(\n-                                            Region(Interned(ReErased, _)),\n-                                            cast_ty,\n-                                            Mutability::Not,\n-                                        ),\n-                                    ) => {\n-                                        match (operand_ty.kind(), cast_ty.kind()) {\n-                                            // current way of patching doesn't allow to work with `mut`\n-                                            (ty::Array(of_ty_src, ..), ty::Slice(of_ty_dst)) => {\n-                                                if of_ty_src == of_ty_dst {\n-                                                    // this is a cast from [T; N] into [T], so we are good\n-                                                    state.insert(local, statement_idx);\n-                                                }\n-                                            }\n-                                            _ => {}\n-                                        }\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                    Rvalue::Len(place) => {\n-                        let Some(local) = place.local_or_deref_local() else {\n-                            return;\n-                        };\n-                        if let Some(cast_statement_idx) = state.get(&local).copied() {\n-                            patches_scratchpad.insert(cast_statement_idx, statement_idx);\n-                        }\n-                    }\n-                    _ => {\n-                        // invalidate\n-                        state.remove(&place.local);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n+    slice_lengths: IndexVec<Local, Option<ty::Const<'tcx>>>,\n+}\n \n-    let mut patcher = Patcher {\n-        tcx,\n-        patches_scratchpad: &*patches_scratchpad,\n-        replacements_scratchpad,\n-        local_decls,\n-        statement_idx: 0,\n-    };\n+impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n \n-    block.expand_statements(|st| patcher.patch_expand_statement(st));\n+    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, loc: Location) {\n+        if let Rvalue::Len(place) = rvalue\n+            && let [PlaceElem::Deref] = &place.projection[..]\n+            && let Some(len) = self.slice_lengths[place.local]\n+        {\n+            *rvalue = Rvalue::Use(Operand::Constant(Box::new(Constant {\n+                span: rustc_span::DUMMY_SP,\n+                user_ty: None,\n+                literal: ConstantKind::from_const(len, self.tcx),\n+            })));\n+        }\n+        self.super_rvalue(rvalue, loc);\n+    }\n }"}, {"sha": "615126e8b5896c789e162522a69b43fd2b1df671", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -180,7 +180,7 @@ pub fn partition<'tcx>(\n         partitioner.place_root_mono_items(cx, mono_items)\n     };\n \n-    initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n+    initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.create_size_estimate(tcx));\n \n     debug_dump(tcx, \"INITIAL PARTITIONING:\", initial_partitioning.codegen_units.iter());\n \n@@ -200,7 +200,7 @@ pub fn partition<'tcx>(\n         partitioner.place_inlined_mono_items(cx, initial_partitioning)\n     };\n \n-    post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n+    post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.create_size_estimate(tcx));\n \n     debug_dump(tcx, \"POST INLINING:\", post_inlining.codegen_units.iter());\n "}, {"sha": "83adfeb6b10b6ef2c5d317bb28172c131e335fd9", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -459,30 +459,32 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n }\n \n fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    if tcx.has_attr(def_id.to_def_id(), sym::lang) {\n-        return true;\n+    fn has_lang_attr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+        tcx.has_attr(def_id.to_def_id(), sym::lang)\n+            // Stable attribute for #[lang = \"panic_impl\"]\n+            || tcx.has_attr(def_id.to_def_id(), sym::panic_handler)\n     }\n \n-    // Stable attribute for #[lang = \"panic_impl\"]\n-    if tcx.has_attr(def_id.to_def_id(), sym::panic_handler) {\n-        return true;\n+    fn has_allow_dead_code(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        tcx.lint_level_at_node(lint::builtin::DEAD_CODE, hir_id).0 == lint::Allow\n     }\n \n-    if tcx.def_kind(def_id).has_codegen_attrs() {\n-        let cg_attrs = tcx.codegen_fn_attrs(def_id);\n+    fn has_used_like_attr(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+        tcx.def_kind(def_id).has_codegen_attrs() && {\n+            let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n-        // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n-        // forcefully, e.g., for placing it in a specific section.\n-        if cg_attrs.contains_extern_indicator()\n-            || cg_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-            || cg_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n-        {\n-            return true;\n+            // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n+            // forcefully, e.g., for placing it in a specific section.\n+            cg_attrs.contains_extern_indicator()\n+                || cg_attrs.flags.contains(CodegenFnAttrFlags::USED)\n+                || cg_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n         }\n     }\n \n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    tcx.lint_level_at_node(lint::builtin::DEAD_CODE, hir_id).0 == lint::Allow\n+    has_allow_dead_code(tcx, def_id)\n+        || has_used_like_attr(tcx, def_id)\n+        || has_lang_attr(tcx, def_id)\n }\n \n // These check_* functions seeds items that"}, {"sha": "093dcbbe8bf775c3b437ee7329527ca7ed5d6da7", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -782,6 +782,38 @@ impl<T, A: Allocator> BorrowMut<[T]> for Vec<T, A> {\n     }\n }\n \n+// Specializable trait for implementing ToOwned::clone_into. This is\n+// public in the crate and has the Allocator parameter so that\n+// vec::clone_from use it too.\n+#[cfg(not(no_global_oom_handling))]\n+pub(crate) trait SpecCloneIntoVec<T, A: Allocator> {\n+    fn clone_into(&self, target: &mut Vec<T, A>);\n+}\n+\n+#[cfg(not(no_global_oom_handling))]\n+impl<T: Clone, A: Allocator> SpecCloneIntoVec<T, A> for [T] {\n+    default fn clone_into(&self, target: &mut Vec<T, A>) {\n+        // drop anything in target that will not be overwritten\n+        target.truncate(self.len());\n+\n+        // target.len <= self.len due to the truncate above, so the\n+        // slices here are always in-bounds.\n+        let (init, tail) = self.split_at(target.len());\n+\n+        // reuse the contained values' allocations/resources.\n+        target.clone_from_slice(init);\n+        target.extend_from_slice(tail);\n+    }\n+}\n+\n+#[cfg(not(no_global_oom_handling))]\n+impl<T: Copy, A: Allocator> SpecCloneIntoVec<T, A> for [T] {\n+    fn clone_into(&self, target: &mut Vec<T, A>) {\n+        target.clear();\n+        target.extend_from_slice(self);\n+    }\n+}\n+\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> ToOwned for [T] {\n@@ -797,16 +829,7 @@ impl<T: Clone> ToOwned for [T] {\n     }\n \n     fn clone_into(&self, target: &mut Vec<T>) {\n-        // drop anything in target that will not be overwritten\n-        target.truncate(self.len());\n-\n-        // target.len <= self.len due to the truncate above, so the\n-        // slices here are always in-bounds.\n-        let (init, tail) = self.split_at(target.len());\n-\n-        // reuse the contained values' allocations/resources.\n-        target.clone_from_slice(init);\n-        target.extend_from_slice(tail);\n+        SpecCloneIntoVec::clone_into(self, target);\n     }\n }\n "}, {"sha": "a07f3da78d33e58c4ec92954130d6816c1e6a8ee", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -2646,35 +2646,6 @@ impl<T, A: Allocator> ops::DerefMut for Vec<T, A> {\n     }\n }\n \n-#[cfg(not(no_global_oom_handling))]\n-trait SpecCloneFrom {\n-    fn clone_from(this: &mut Self, other: &Self);\n-}\n-\n-#[cfg(not(no_global_oom_handling))]\n-impl<T: Clone, A: Allocator> SpecCloneFrom for Vec<T, A> {\n-    default fn clone_from(this: &mut Self, other: &Self) {\n-        // drop anything that will not be overwritten\n-        this.truncate(other.len());\n-\n-        // self.len <= other.len due to the truncate above, so the\n-        // slices here are always in-bounds.\n-        let (init, tail) = other.split_at(this.len());\n-\n-        // reuse the contained values' allocations/resources.\n-        this.clone_from_slice(init);\n-        this.extend_from_slice(tail);\n-    }\n-}\n-\n-#[cfg(not(no_global_oom_handling))]\n-impl<T: Copy, A: Allocator> SpecCloneFrom for Vec<T, A> {\n-    fn clone_from(this: &mut Self, other: &Self) {\n-        this.clear();\n-        this.extend_from_slice(other);\n-    }\n-}\n-\n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n@@ -2695,7 +2666,7 @@ impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n     }\n \n     fn clone_from(&mut self, other: &Self) {\n-        SpecCloneFrom::clone_from(self, other)\n+        crate::slice::SpecCloneIntoVec::clone_into(other.as_slice(), self);\n     }\n }\n "}, {"sha": "2c514a0c8267b80b7763660520a80b5803e2e3e1", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -509,7 +509,7 @@ impl Options {\n                 // these values up both in `dataset` and in the storage API, so it needs to be able\n                 // to convert the names back and forth.  Despite doing this kebab-case to\n                 // StudlyCaps transformation automatically, the JS DOM API does not provide a\n-                // mechanism for doing the just transformation on a string.  So we want to avoid\n+                // mechanism for doing just the transformation on a string.  So we want to avoid\n                 // the StudlyCaps representation in the `dataset` property.\n                 //\n                 // We solve this by replacing all the `-`s with `_`s.  We do that here, when we"}, {"sha": "1cd552e7f25b712799c2855fd2dc6281e34ed215", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -1,5 +1,5 @@\n // Local js definitions:\n-/* global getSettingValue, getVirtualKey, updateLocalStorage, updateSystemTheme */\n+/* global getSettingValue, getVirtualKey, updateLocalStorage, updateTheme */\n /* global addClass, removeClass, onEach, onEachLazy, blurHandler, elemIsInParent */\n /* global MAIN_ID, getVar, getSettingsButton */\n \n@@ -19,7 +19,7 @@\n             case \"theme\":\n             case \"preferred-dark-theme\":\n             case \"preferred-light-theme\":\n-                updateSystemTheme();\n+                updateTheme();\n                 updateLightAndDark();\n                 break;\n             case \"line-numbers\":"}, {"sha": "8836d1b2e464bca1dd00c35ad9bd240ddbf72152", "filename": "src/librustdoc/html/static/js/storage.js", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -153,79 +153,74 @@ function switchTheme(styleElem, mainStyleElem, newThemeName, saveTheme) {\n     }\n }\n \n-// This function is called from \"main.js\".\n-// eslint-disable-next-line no-unused-vars\n-function useSystemTheme(value) {\n-    if (value === undefined) {\n-        value = true;\n-    }\n-\n-    updateLocalStorage(\"use-system-theme\", value);\n-\n-    // update the toggle if we're on the settings page\n-    const toggle = document.getElementById(\"use-system-theme\");\n-    if (toggle && toggle instanceof HTMLInputElement) {\n-        toggle.checked = value;\n-    }\n-}\n-\n-const updateSystemTheme = (function() {\n-    if (!window.matchMedia) {\n-        // fallback to the CSS computed value\n-        return () => {\n-            const cssTheme = getComputedStyle(document.documentElement)\n-                .getPropertyValue(\"content\");\n-\n-            switchTheme(\n-                window.currentTheme,\n-                window.mainTheme,\n-                JSON.parse(cssTheme) || \"light\",\n-                true\n-            );\n+const updateTheme = (function() {\n+    /**\n+     * Update the current theme to match whatever the current combination of\n+     * * the preference for using the system theme\n+     *   (if this is the case, the value of preferred-light-theme, if the\n+     *   system theme is light, otherwise if dark, the value of\n+     *   preferred-dark-theme.)\n+     * * the preferred theme\n+     * \u2026 dictates that it should be.\n+     */\n+    function updateTheme() {\n+        const use = (theme, saveTheme) => {\n+            switchTheme(window.currentTheme, window.mainTheme, theme, saveTheme);\n         };\n-    }\n-\n-    // only listen to (prefers-color-scheme: dark) because light is the default\n-    const mql = window.matchMedia(\"(prefers-color-scheme: dark)\");\n \n-    function handlePreferenceChange(mql) {\n-        const use = theme => {\n-            switchTheme(window.currentTheme, window.mainTheme, theme, true);\n-        };\n         // maybe the user has disabled the setting in the meantime!\n         if (getSettingValue(\"use-system-theme\") !== \"false\") {\n             const lightTheme = getSettingValue(\"preferred-light-theme\") || \"light\";\n             const darkTheme = getSettingValue(\"preferred-dark-theme\") || \"dark\";\n \n-            if (mql.matches) {\n-                use(darkTheme);\n+            if (isDarkMode()) {\n+                use(darkTheme, true);\n             } else {\n                 // prefers a light theme, or has no preference\n-                use(lightTheme);\n+                use(lightTheme, true);\n             }\n             // note: we save the theme so that it doesn't suddenly change when\n             // the user disables \"use-system-theme\" and reloads the page or\n             // navigates to another page\n         } else {\n-            use(getSettingValue(\"theme\"));\n+            use(getSettingValue(\"theme\"), false);\n         }\n     }\n \n-    mql.addListener(handlePreferenceChange);\n+    // This is always updated below to a function () => bool.\n+    let isDarkMode;\n \n-    return () => {\n-        handlePreferenceChange(mql);\n-    };\n-})();\n+    // Determine the function for isDarkMode, and if we have\n+    // `window.matchMedia`, set up an event listener on the preferred color\n+    // scheme.\n+    //\n+    // Otherwise, fall back to the prefers-color-scheme value CSS captured in\n+    // the \"content\" property.\n+    if (window.matchMedia) {\n+        // only listen to (prefers-color-scheme: dark) because light is the default\n+        const mql = window.matchMedia(\"(prefers-color-scheme: dark)\");\n \n-function switchToSavedTheme() {\n-    switchTheme(\n-        window.currentTheme,\n-        window.mainTheme,\n-        getSettingValue(\"theme\") || \"light\",\n-        false\n-    );\n-}\n+        isDarkMode = () => mql.matches;\n+\n+        if (mql.addEventListener) {\n+            mql.addEventListener(\"change\", updateTheme);\n+        } else {\n+            // This is deprecated, see:\n+            // https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList/addListener\n+            mql.addListener(updateTheme);\n+        }\n+    } else {\n+        // fallback to the CSS computed value\n+        const cssContent = getComputedStyle(document.documentElement)\n+            .getPropertyValue(\"content\");\n+        // (Note: the double-quotes come from that this is a CSS value, which\n+        // might be a length, string, etc.)\n+        const cssColorScheme = cssContent || \"\\\"light\\\"\";\n+        isDarkMode = () => (cssColorScheme === \"\\\"dark\\\"\");\n+    }\n+\n+    return updateTheme;\n+})();\n \n if (getSettingValue(\"use-system-theme\") !== \"false\" && window.matchMedia) {\n     // update the preferred dark theme if the user is already using a dark theme\n@@ -235,13 +230,10 @@ if (getSettingValue(\"use-system-theme\") !== \"false\" && window.matchMedia) {\n         && darkThemes.indexOf(localStoredTheme) >= 0) {\n         updateLocalStorage(\"preferred-dark-theme\", localStoredTheme);\n     }\n-\n-    // call the function to initialize the theme at least once!\n-    updateSystemTheme();\n-} else {\n-    switchToSavedTheme();\n }\n \n+updateTheme();\n+\n if (getSettingValue(\"source-sidebar-show\") === \"true\") {\n     // At this point in page load, `document.body` is not available yet.\n     // Set a class on the `<html>` element instead.\n@@ -259,6 +251,6 @@ if (getSettingValue(\"source-sidebar-show\") === \"true\") {\n // specifically when talking to a remote website with no caching.\n window.addEventListener(\"pageshow\", ev => {\n     if (ev.persisted) {\n-        setTimeout(switchToSavedTheme, 0);\n+        setTimeout(updateTheme, 0);\n     }\n });"}, {"sha": "38d402b8f21610381d70f397bae53822793f76e9", "filename": "tests/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -33,11 +33,11 @@\n           StorageLive(_4);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n           StorageLive(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n           _5 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n-          _6 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+          _6 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n -         _7 = Lt(_5, _6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n -         assert(move _7, \"index out of bounds: the length is {} but the index is {}\", move _6, _5) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-+         _7 = Lt(const 3_usize, _6);      // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-+         assert(move _7, \"index out of bounds: the length is {} but the index is {}\", move _6, const 3_usize) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         _7 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         assert(const false, \"index out of bounds: the length is {} but the index is {}\", const 3_usize, const 3_usize) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n       }\n   \n       bb1: {"}, {"sha": "38d402b8f21610381d70f397bae53822793f76e9", "filename": "tests/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -33,11 +33,11 @@\n           StorageLive(_4);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:13: +3:15\n           StorageLive(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n           _5 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:23: +3:24\n-          _6 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n+          _6 = const 3_usize;              // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n -         _7 = Lt(_5, _6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n -         assert(move _7, \"index out of bounds: the length is {} but the index is {}\", move _6, _5) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-+         _7 = Lt(const 3_usize, _6);      // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n-+         assert(move _7, \"index out of bounds: the length is {} but the index is {}\", move _6, const 3_usize) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         _7 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n++         assert(const false, \"index out of bounds: the length is {} but the index is {}\", const 3_usize, const 3_usize) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:+3:18: +3:25\n       }\n   \n       bb1: {"}, {"sha": "fbbfd4ceb112ba59980ecfd1da1ae8f1d28f4cc6", "filename": "tests/mir-opt/issue_76432.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Fissue_76432.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Fissue_76432.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_76432.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -1,3 +1,4 @@\n+// compile-flags: -Zmir-enable-passes=-NormalizeArrayLen\n // Check that we do not insert StorageDead at each target if StorageDead was never seen\n \n // EMIT_MIR issue_76432.test.SimplifyComparisonIntegral.diff"}, {"sha": "59de067f4a4f8c9773ff04726b13cbd9e8aab13f", "filename": "tests/mir-opt/lower_array_len.array_bound.NormalizeArrayLen.diff", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_bound.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_bound.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len.array_bound.NormalizeArrayLen.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -13,7 +13,6 @@\n       let _8: usize;                       // in scope 0 at $DIR/lower_array_len.rs:+2:15: +2:20\n       let mut _9: usize;                   // in scope 0 at $DIR/lower_array_len.rs:+2:9: +2:21\n       let mut _10: bool;                   // in scope 0 at $DIR/lower_array_len.rs:+2:9: +2:21\n-+     let mut _11: &[u8; N];               // in scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n   \n       bb0: {\n           StorageLive(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n@@ -23,13 +22,10 @@\n           StorageLive(_6);                 // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           StorageLive(_7);                 // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           _7 = &(*_2);                     // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         StorageLive(_11);                // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         _11 = _7;                        // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           _6 = move _7 as &[u8] (Pointer(Unsize)); // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           StorageDead(_7);                 // scope 0 at $DIR/lower_array_len.rs:+1:20: +1:21\n -         _5 = Len((*_6));                 // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         _5 = Len((*_11));                // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         StorageDead(_11);                // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n++         _5 = const N;                    // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           goto -> bb1;                     // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n       }\n   "}, {"sha": "17574b1b635681aee95cfd859ad695a51f61e153", "filename": "tests/mir-opt/lower_array_len.array_bound_mut.NormalizeArrayLen.diff", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_bound_mut.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_bound_mut.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len.array_bound_mut.NormalizeArrayLen.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -16,7 +16,6 @@\n       let _11: usize;                      // in scope 0 at $DIR/lower_array_len.rs:+4:15: +4:16\n       let mut _12: usize;                  // in scope 0 at $DIR/lower_array_len.rs:+4:9: +4:17\n       let mut _13: bool;                   // in scope 0 at $DIR/lower_array_len.rs:+4:9: +4:17\n-+     let mut _14: &[u8; N];               // in scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n   \n       bb0: {\n           StorageLive(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n@@ -26,13 +25,10 @@\n           StorageLive(_6);                 // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           StorageLive(_7);                 // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           _7 = &(*_2);                     // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         StorageLive(_14);                // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         _14 = _7;                        // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           _6 = move _7 as &[u8] (Pointer(Unsize)); // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           StorageDead(_7);                 // scope 0 at $DIR/lower_array_len.rs:+1:20: +1:21\n -         _5 = Len((*_6));                 // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         _5 = Len((*_14));                // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n-+         StorageDead(_14);                // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n++         _5 = const N;                    // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n           goto -> bb1;                     // scope 0 at $DIR/lower_array_len.rs:+1:16: +1:27\n       }\n   "}, {"sha": "66feff62f424680192a6bb3549433058facf6d2a", "filename": "tests/mir-opt/lower_array_len.array_len.NormalizeArrayLen.diff", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len.array_len.NormalizeArrayLen.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -6,19 +6,15 @@\n       let mut _0: usize;                   // return place in scope 0 at $DIR/lower_array_len.rs:+0:52: +0:57\n       let mut _2: &[u8];                   // in scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n       let mut _3: &[u8; N];                // in scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+     let mut _4: &[u8; N];                // in scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           StorageLive(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           _3 = &(*_1);                     // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         StorageLive(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         _4 = _3;                         // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           _2 = move _3 as &[u8] (Pointer(Unsize)); // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           StorageDead(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:7: +1:8\n -         _0 = Len((*_2));                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         _0 = Len((*_4));                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         StorageDead(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n++         _0 = const N;                    // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           goto -> bb1;                     // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n       }\n   "}, {"sha": "c0a277edc46700ea9ece6e395f77f5bb1a4430bd", "filename": "tests/mir-opt/lower_array_len.array_len_by_value.NormalizeArrayLen.diff", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len_by_value.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len_by_value.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len.array_len_by_value.NormalizeArrayLen.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -6,19 +6,15 @@\n       let mut _0: usize;                   // return place in scope 0 at $DIR/lower_array_len.rs:+0:60: +0:65\n       let mut _2: &[u8];                   // in scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n       let mut _3: &[u8; N];                // in scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+     let mut _4: &[u8; N];                // in scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           StorageLive(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           _3 = &_1;                        // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         StorageLive(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         _4 = _3;                         // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           _2 = move _3 as &[u8] (Pointer(Unsize)); // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           StorageDead(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:7: +1:8\n -         _0 = Len((*_2));                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         _0 = Len((*_4));                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n-+         StorageDead(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n++         _0 = const N;                    // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n           goto -> bb1;                     // scope 0 at $DIR/lower_array_len.rs:+1:5: +1:14\n       }\n   "}, {"sha": "8b35fd57fa016bdcd8974197bf679f060ebee01c", "filename": "tests/mir-opt/lower_array_len.array_len_raw.NormalizeArrayLen.diff", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len_raw.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len_raw.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len.array_len_raw.NormalizeArrayLen.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -0,0 +1,50 @@\n+- // MIR for `array_len_raw` before NormalizeArrayLen\n++ // MIR for `array_len_raw` after NormalizeArrayLen\n+  \n+  fn array_len_raw(_1: [u8; N]) -> usize {\n+      debug arr => _1;                     // in scope 0 at $DIR/lower_array_len.rs:+0:38: +0:41\n+      let mut _0: usize;                   // return place in scope 0 at $DIR/lower_array_len.rs:+0:55: +0:60\n+      let _2: &[u8];                       // in scope 0 at $DIR/lower_array_len.rs:+1:9: +1:12\n+      let mut _3: &[u8; N];                // in scope 0 at $DIR/lower_array_len.rs:+1:21: +1:25\n+      let _4: &[u8; N];                    // in scope 0 at $DIR/lower_array_len.rs:+1:21: +1:25\n+      let mut _6: &[u8];                   // in scope 0 at $DIR/lower_array_len.rs:+3:5: +3:27\n+      let _7: &[u8];                       // in scope 0 at $DIR/lower_array_len.rs:+3:14: +3:19\n+      scope 1 {\n+          debug arr => _2;                 // in scope 1 at $DIR/lower_array_len.rs:+1:9: +1:12\n+          let _5: *const [u8];             // in scope 1 at $DIR/lower_array_len.rs:+2:9: +2:12\n+          scope 2 {\n+              debug arr => _5;             // in scope 2 at $DIR/lower_array_len.rs:+2:9: +2:12\n+              scope 3 {\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/lower_array_len.rs:+1:9: +1:12\n+          StorageLive(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:21: +1:25\n+          StorageLive(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:21: +1:25\n+          _4 = &_1;                        // scope 0 at $DIR/lower_array_len.rs:+1:21: +1:25\n+          _3 = &(*_4);                     // scope 0 at $DIR/lower_array_len.rs:+1:21: +1:25\n+          _2 = move _3 as &[u8] (Pointer(Unsize)); // scope 0 at $DIR/lower_array_len.rs:+1:21: +1:25\n+          StorageDead(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:24: +1:25\n+          StorageDead(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:25: +1:26\n+          StorageLive(_5);                 // scope 1 at $DIR/lower_array_len.rs:+2:9: +2:12\n+          _5 = &raw const (*_2);           // scope 1 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+          StorageLive(_6);                 // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:27\n+          StorageLive(_7);                 // scope 2 at $DIR/lower_array_len.rs:+3:14: +3:19\n+          _7 = &(*_5);                     // scope 3 at $DIR/lower_array_len.rs:+3:14: +3:19\n+          _6 = &(*_7);                     // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:27\n+-         _0 = Len((*_6));                 // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:27\n++         _0 = const N;                    // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:27\n+          goto -> bb1;                     // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:27\n+      }\n+  \n+      bb1: {\n+          StorageDead(_6);                 // scope 2 at $DIR/lower_array_len.rs:+3:26: +3:27\n+          StorageDead(_5);                 // scope 1 at $DIR/lower_array_len.rs:+4:1: +4:2\n+          StorageDead(_2);                 // scope 0 at $DIR/lower_array_len.rs:+4:1: +4:2\n+          StorageDead(_7);                 // scope 0 at $DIR/lower_array_len.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/lower_array_len.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "8bdd2ede6bc41b6ee3f78ccb40b8b4d2254225d5", "filename": "tests/mir-opt/lower_array_len.array_len_reborrow.NormalizeArrayLen.diff", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len_reborrow.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.array_len_reborrow.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len.array_len_reborrow.NormalizeArrayLen.diff?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -0,0 +1,44 @@\n+- // MIR for `array_len_reborrow` before NormalizeArrayLen\n++ // MIR for `array_len_reborrow` after NormalizeArrayLen\n+  \n+  fn array_len_reborrow(_1: [u8; N]) -> usize {\n+      debug arr => _1;                     // in scope 0 at $DIR/lower_array_len.rs:+0:43: +0:50\n+      let mut _0: usize;                   // return place in scope 0 at $DIR/lower_array_len.rs:+0:64: +0:69\n+      let _2: &mut [u8];                   // in scope 0 at $DIR/lower_array_len.rs:+1:9: +1:12\n+      let mut _3: &mut [u8; N];            // in scope 0 at $DIR/lower_array_len.rs:+1:25: +1:33\n+      let mut _4: &mut [u8; N];            // in scope 0 at $DIR/lower_array_len.rs:+1:25: +1:33\n+      let mut _6: &[u8];                   // in scope 0 at $DIR/lower_array_len.rs:+3:5: +3:14\n+      scope 1 {\n+          debug arr => _2;                 // in scope 1 at $DIR/lower_array_len.rs:+1:9: +1:12\n+          let _5: &[u8];                   // in scope 1 at $DIR/lower_array_len.rs:+2:9: +2:12\n+          scope 2 {\n+              debug arr => _5;             // in scope 2 at $DIR/lower_array_len.rs:+2:9: +2:12\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/lower_array_len.rs:+1:9: +1:12\n+          StorageLive(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:25: +1:33\n+          StorageLive(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:25: +1:33\n+          _4 = &mut _1;                    // scope 0 at $DIR/lower_array_len.rs:+1:25: +1:33\n+          _3 = &mut (*_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:25: +1:33\n+          _2 = move _3 as &mut [u8] (Pointer(Unsize)); // scope 0 at $DIR/lower_array_len.rs:+1:25: +1:33\n+          StorageDead(_3);                 // scope 0 at $DIR/lower_array_len.rs:+1:32: +1:33\n+          StorageDead(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:33: +1:34\n+          StorageLive(_5);                 // scope 1 at $DIR/lower_array_len.rs:+2:9: +2:12\n+          _5 = &(*_2);                     // scope 1 at $DIR/lower_array_len.rs:+2:15: +2:20\n+          StorageLive(_6);                 // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:14\n+          _6 = &(*_5);                     // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:14\n+-         _0 = Len((*_6));                 // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:14\n++         _0 = const N;                    // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:14\n+          goto -> bb1;                     // scope 2 at $DIR/lower_array_len.rs:+3:5: +3:14\n+      }\n+  \n+      bb1: {\n+          StorageDead(_6);                 // scope 2 at $DIR/lower_array_len.rs:+3:13: +3:14\n+          StorageDead(_5);                 // scope 1 at $DIR/lower_array_len.rs:+4:1: +4:2\n+          StorageDead(_2);                 // scope 0 at $DIR/lower_array_len.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/lower_array_len.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "972d46cb8e2bd284976d1bdee770da63aa3a7f86", "filename": "tests/mir-opt/lower_array_len.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fmir-opt%2Flower_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -31,10 +31,26 @@ pub fn array_len_by_value<const N: usize>(arr: [u8; N]) -> usize {\n     arr.len()\n }\n \n+// EMIT_MIR lower_array_len.array_len_reborrow.NormalizeArrayLen.diff\n+pub fn array_len_reborrow<const N: usize>(mut arr: [u8; N]) -> usize {\n+    let arr: &mut [_] = &mut arr;\n+    let arr = &*arr;\n+    arr.len()\n+}\n+\n+// EMIT_MIR lower_array_len.array_len_raw.NormalizeArrayLen.diff\n+pub fn array_len_raw<const N: usize>(arr: [u8; N]) -> usize {\n+    let arr: &[_] = &arr;\n+    let arr = std::ptr::addr_of!(*arr);\n+    unsafe { &*arr }.len()\n+}\n+\n fn main() {\n     let _ = array_bound(3, &[0, 1, 2, 3]);\n     let mut tmp = [0, 1, 2, 3, 4];\n     let _ = array_bound_mut(3, &mut [0, 1, 2, 3]);\n     let _ = array_len(&[0]);\n     let _ = array_len_by_value([0, 2]);\n+    let _ = array_len_reborrow([0, 2]);\n+    let _ = array_len_raw([0, 2]);\n }"}, {"sha": "dee1d538395ef86b9b5ec4b86666ae6478b72943", "filename": "tests/mir-opt/lower_array_len_e2e.array_bound.PreCodegen.after.mir", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir?ref=006ca9b14da1e0145844598b3d6a554c042c702a", "patch": "@@ -1,41 +0,0 @@\n-// MIR for `array_bound` after PreCodegen\n-\n-fn array_bound(_1: usize, _2: &[u8; N]) -> u8 {\n-    debug index => _1;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+0:36: +0:41\n-    debug slice => _2;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+0:50: +0:55\n-    let mut _0: u8;                      // return place in scope 0 at $DIR/lower_array_len_e2e.rs:+0:70: +0:72\n-    let mut _3: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-    let mut _4: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-    let mut _5: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    let mut _6: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-\n-    bb0: {\n-        StorageLive(_3);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-        StorageLive(_4);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-        _4 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-        _3 = Lt(_1, move _4);            // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-        StorageDead(_4);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:26: +1:27\n-        switchInt(move _3) -> [0: bb3, otherwise: bb1]; // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-    }\n-\n-    bb1: {\n-        _5 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        _6 = Lt(_1, _5);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        assert(move _6, \"index out of bounds: the length is {} but the index is {}\", move _5, _1) -> bb2; // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    }\n-\n-    bb2: {\n-        _0 = (*_2)[_1];                  // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        goto -> bb4;                     // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +5:6\n-    }\n-\n-    bb3: {\n-        _0 = const 42_u8;                // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:11\n-        goto -> bb4;                     // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +5:6\n-    }\n-\n-    bb4: {\n-        StorageDead(_3);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+5:5: +5:6\n-        return;                          // scope 0 at $DIR/lower_array_len_e2e.rs:+6:2: +6:2\n-    }\n-}"}, {"sha": "e35fe758ab12ddea899bddedcba028e5e02fc4c3", "filename": "tests/mir-opt/lower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir?ref=006ca9b14da1e0145844598b3d6a554c042c702a", "patch": "@@ -1,54 +0,0 @@\n-// MIR for `array_bound_mut` after PreCodegen\n-\n-fn array_bound_mut(_1: usize, _2: &mut [u8; N]) -> u8 {\n-    debug index => _1;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+0:40: +0:45\n-    debug slice => _2;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+0:54: +0:59\n-    let mut _0: u8;                      // return place in scope 0 at $DIR/lower_array_len_e2e.rs:+0:78: +0:80\n-    let mut _3: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-    let mut _4: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-    let mut _5: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    let mut _6: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    let _7: usize;                       // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n-    let mut _8: usize;                   // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-    let mut _9: bool;                    // in scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-\n-    bb0: {\n-        StorageLive(_3);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-        StorageLive(_4);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-        _4 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+1:16: +1:27\n-        _3 = Lt(_1, move _4);            // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-        StorageDead(_4);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:26: +1:27\n-        switchInt(move _3) -> [0: bb3, otherwise: bb1]; // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n-    }\n-\n-    bb1: {\n-        _5 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        _6 = Lt(_1, _5);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        assert(move _6, \"index out of bounds: the length is {} but the index is {}\", move _5, _1) -> bb2; // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-    }\n-\n-    bb2: {\n-        _0 = (*_2)[_1];                  // scope 0 at $DIR/lower_array_len_e2e.rs:+2:9: +2:21\n-        goto -> bb5;                     // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +7:6\n-    }\n-\n-    bb3: {\n-        StorageLive(_7);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n-        _7 = const 0_usize;              // scope 0 at $DIR/lower_array_len_e2e.rs:+4:15: +4:16\n-        _8 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-        _9 = Lt(const 0_usize, _8);      // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-        assert(move _9, \"index out of bounds: the length is {} but the index is {}\", move _8, const 0_usize) -> bb4; // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:17\n-    }\n-\n-    bb4: {\n-        (*_2)[_7] = const 42_u8;         // scope 0 at $DIR/lower_array_len_e2e.rs:+4:9: +4:22\n-        StorageDead(_7);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+4:22: +4:23\n-        _0 = const 42_u8;                // scope 0 at $DIR/lower_array_len_e2e.rs:+6:9: +6:11\n-        goto -> bb5;                     // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +7:6\n-    }\n-\n-    bb5: {\n-        StorageDead(_3);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+7:5: +7:6\n-        return;                          // scope 0 at $DIR/lower_array_len_e2e.rs:+8:2: +8:2\n-    }\n-}"}, {"sha": "4b19f6795588960697bef697eaee8f8cbd6010bb", "filename": "tests/mir-opt/lower_array_len_e2e.array_len.PreCodegen.after.mir", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_len.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_len.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len_e2e.array_len.PreCodegen.after.mir?ref=006ca9b14da1e0145844598b3d6a554c042c702a", "patch": "@@ -1,11 +0,0 @@\n-// MIR for `array_len` after PreCodegen\n-\n-fn array_len(_1: &[u8; N]) -> usize {\n-    debug arr => _1;                     // in scope 0 at $DIR/lower_array_len_e2e.rs:+0:34: +0:37\n-    let mut _0: usize;                   // return place in scope 0 at $DIR/lower_array_len_e2e.rs:+0:52: +0:57\n-\n-    bb0: {\n-        _0 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +1:14\n-        return;                          // scope 0 at $DIR/lower_array_len_e2e.rs:+2:2: +2:2\n-    }\n-}"}, {"sha": "4dc0ba9a268ea1bf8a35d024eff98b70eddc87a3", "filename": "tests/mir-opt/lower_array_len_e2e.array_len_by_value.PreCodegen.after.mir", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_len_by_value.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.array_len_by_value.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len_e2e.array_len_by_value.PreCodegen.after.mir?ref=006ca9b14da1e0145844598b3d6a554c042c702a", "patch": "@@ -1,11 +0,0 @@\n-// MIR for `array_len_by_value` after PreCodegen\n-\n-fn array_len_by_value(_1: [u8; N]) -> usize {\n-    debug arr => _1;                     // in scope 0 at $DIR/lower_array_len_e2e.rs:+0:43: +0:46\n-    let mut _0: usize;                   // return place in scope 0 at $DIR/lower_array_len_e2e.rs:+0:60: +0:65\n-\n-    bb0: {\n-        _0 = const N;                    // scope 0 at $DIR/lower_array_len_e2e.rs:+1:5: +1:14\n-        return;                          // scope 0 at $DIR/lower_array_len_e2e.rs:+2:2: +2:2\n-    }\n-}"}, {"sha": "d8e4e521ee6820b91fb3dc9ee41f8f5310bebb71", "filename": "tests/mir-opt/lower_array_len_e2e.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.rs", "raw_url": "https://github.com/rust-lang/rust/raw/006ca9b14da1e0145844598b3d6a554c042c702a/tests%2Fmir-opt%2Flower_array_len_e2e.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_array_len_e2e.rs?ref=006ca9b14da1e0145844598b3d6a554c042c702a", "patch": "@@ -1,39 +0,0 @@\n-// compile-flags: -Z mir-opt-level=4 -Zunsound-mir-opts\n-\n-// EMIT_MIR lower_array_len_e2e.array_bound.PreCodegen.after.mir\n-pub fn array_bound<const N: usize>(index: usize, slice: &[u8; N]) -> u8 {\n-    if index < slice.len() {\n-        slice[index]\n-    } else {\n-        42\n-    }\n-}\n-\n-// EMIT_MIR lower_array_len_e2e.array_bound_mut.PreCodegen.after.mir\n-pub fn array_bound_mut<const N: usize>(index: usize, slice: &mut [u8; N]) -> u8 {\n-    if index < slice.len() {\n-        slice[index]\n-    } else {\n-        slice[0] = 42;\n-\n-        42\n-    }\n-}\n-\n-// EMIT_MIR lower_array_len_e2e.array_len.PreCodegen.after.mir\n-pub fn array_len<const N: usize>(arr: &[u8; N]) -> usize {\n-    arr.len()\n-}\n-\n-// EMIT_MIR lower_array_len_e2e.array_len_by_value.PreCodegen.after.mir\n-pub fn array_len_by_value<const N: usize>(arr: [u8; N]) -> usize {\n-    arr.len()\n-}\n-\n-fn main() {\n-    let _ = array_bound(3, &[0, 1, 2, 3]);\n-    let mut tmp = [0, 1, 2, 3, 4];\n-    let _ = array_bound_mut(3, &mut [0, 1, 2, 3]);\n-    let _ = array_len(&[0]);\n-    let _ = array_len_by_value([0, 2]);\n-}"}, {"sha": "7ceea676d3a37d0bf9bc68dc8946ead9d029846d", "filename": "tests/ui/parser/bastion-of-the-turbofish.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fui%2Fparser%2Fbastion-of-the-turbofish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a322848c6b0e037c1f0209387558ecb6ab763714/tests%2Fui%2Fparser%2Fbastion-of-the-turbofish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fbastion-of-the-turbofish.rs?ref=a322848c6b0e037c1f0209387558ecb6ab763714", "patch": "@@ -34,7 +34,7 @@\n \n // See https://github.com/rust-lang/rust/pull/53562\n // and https://github.com/rust-lang/rfcs/pull/2527\n-// and https://twitter.com/garblefart/status/1393236602856611843\n+// and https://web.archive.org/web/20211010063452/https://twitter.com/garblefart/status/1393236602856611843\n // for context.\n \n fn main() {"}]}