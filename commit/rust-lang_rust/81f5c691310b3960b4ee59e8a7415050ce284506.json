{"sha": "81f5c691310b3960b4ee59e8a7415050ce284506", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZjVjNjkxMzEwYjM5NjBiNGVlNTllOGE3NDE1MDUwY2UyODQ1MDY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-09-16T05:50:07Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-09-16T05:50:07Z"}, "message": "Enhance CHARS_*_CMP lint", "tree": {"sha": "4586c7b36e5eb4d4dff9b44f45e5459e692b2450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4586c7b36e5eb4d4dff9b44f45e5459e692b2450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81f5c691310b3960b4ee59e8a7415050ce284506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81f5c691310b3960b4ee59e8a7415050ce284506", "html_url": "https://github.com/rust-lang/rust/commit/81f5c691310b3960b4ee59e8a7415050ce284506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81f5c691310b3960b4ee59e8a7415050ce284506/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f64bae4ae385172fd27ce03e74e0c0f2bf738159", "url": "https://api.github.com/repos/rust-lang/rust/commits/f64bae4ae385172fd27ce03e74e0c0f2bf738159", "html_url": "https://github.com/rust-lang/rust/commit/f64bae4ae385172fd27ce03e74e0c0f2bf738159"}], "stats": {"total": 131, "additions": 119, "deletions": 12}, "files": [{"sha": "b36e1851d0de4acdc5bc0497f6af06d56cbe4c75", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 119, "deletions": 12, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/81f5c691310b3960b4ee59e8a7415050ce284506/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81f5c691310b3960b4ee59e8a7415050ce284506/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=81f5c691310b3960b4ee59e8a7415050ce284506", "patch": "@@ -7,6 +7,7 @@ use rustc::ty::subst::Substs;\n use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n use std::fmt;\n+use syntax::ast;\n use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n             iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n@@ -544,6 +545,24 @@ declare_lint! {\n     \"using `.cloned().collect()` on slice to create a `Vec`\"\n }\n \n+/// **What it does:** Checks for usage of `.chars().last()` or\n+/// `.chars().next_back()` on a `str` to check if it ends with a given char.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as\n+/// `_.ends_with(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// name.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n+/// ```\n+declare_lint! {\n+    pub CHARS_LAST_CMP,\n+    Warn,\n+    \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\"\n+}\n+\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n@@ -557,6 +576,7 @@ impl LintPass for Pass {\n             OPTION_MAP_UNWRAP_OR_ELSE,\n             OR_FUN_CALL,\n             CHARS_NEXT_CMP,\n+            CHARS_LAST_CMP,\n             CLONE_ON_COPY,\n             CLONE_ON_REF_PTR,\n             CLONE_DOUBLE_REF,\n@@ -648,9 +668,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n             },\n             hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n-                if !lint_chars_next(cx, expr, lhs, rhs, op.node == hir::BiEq) {\n-                    lint_chars_next(cx, expr, rhs, lhs, op.node == hir::BiEq);\n-                }\n+                let mut info = BinaryExprInfo {\n+                    expr: expr,\n+                    chain: lhs,\n+                    other: rhs,\n+                    eq: op.node == hir::BiEq,\n+                };\n+                lint_binary_expr_with_method_call(cx, &mut info);\n             },\n             _ => (),\n         }\n@@ -1285,11 +1309,39 @@ fn lint_search_is_some<'a, 'tcx>(\n     }\n }\n \n-/// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, chain: &'tcx hir::Expr, other: &'tcx hir::Expr, eq: bool) -> bool {\n+/// Used for `lint_binary_expr_with_method_call`.\n+#[derive(Copy, Clone)]\n+struct BinaryExprInfo<'a> {\n+    expr: &'a hir::Expr,\n+    chain: &'a hir::Expr,\n+    other: &'a hir::Expr,\n+    eq: bool,\n+}\n+\n+/// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n+fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, info: &mut BinaryExprInfo) {\n+    macro_rules! lint_with_both_lhs_and_rhs {\n+        ($func:ident, $cx:expr, $info:ident) => {\n+            if !$func($cx, $info) {\n+                ::std::mem::swap(&mut $info.chain, &mut $info.other);\n+                if $func($cx, $info) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    lint_with_both_lhs_and_rhs!(lint_chars_next_cmp, cx, info);\n+    lint_with_both_lhs_and_rhs!(lint_chars_last_cmp, cx, info);\n+    lint_with_both_lhs_and_rhs!(lint_chars_next_cmp_with_unwrap, cx, info);\n+    lint_with_both_lhs_and_rhs!(lint_chars_last_cmp_with_unwrap, cx, info);\n+}\n+\n+/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n+fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n     if_let_chain! {[\n-        let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n-        let hir::ExprCall(ref fun, ref arg_char) = other.node,\n+        let Some(args) = method_chain_args(info.chain, chain_methods),\n+        let hir::ExprCall(ref fun, ref arg_char) = info.other.node,\n         arg_char.len() == 1,\n         let hir::ExprPath(ref qpath) = fun.node,\n         let Some(segment) = single_segment_path(qpath),\n@@ -1302,13 +1354,14 @@ fn lint_chars_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n         }\n \n         span_lint_and_sugg(cx,\n-                           CHARS_NEXT_CMP,\n-                           expr.span,\n-                           \"you should use the `starts_with` method\",\n+                           lint,\n+                           info.expr.span,\n+                           &format!(\"you should use the `{}` method\", suggest),\n                            \"like this\",\n-                           format!(\"{}{}.starts_with({})\",\n-                                   if eq { \"\" } else { \"!\" },\n+                           format!(\"{}{}.{}({})\",\n+                                   if info.eq { \"\" } else { \"!\" },\n                                    snippet(cx, args[0][0].span, \"_\"),\n+                                   suggest,\n                                    snippet(cx, arg_char[0].span, \"_\")));\n \n         return true;\n@@ -1317,6 +1370,60 @@ fn lint_chars_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n     false\n }\n \n+/// Checks for the `CHARS_NEXT_CMP` lint.\n+fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n+}\n+\n+/// Checks for the `CHARS_LAST_CMP` lint.\n+fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_NEXT_CMP, \"ends_with\") {\n+        true\n+    } else {\n+        lint_chars_cmp(cx, info, &[\"chars\", \"next_back\"], CHARS_NEXT_CMP, \"ends_with\")\n+    }\n+}\n+\n+/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n+fn lint_chars_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n+    if_let_chain! {[\n+        let Some(args) = method_chain_args(info.chain, chain_methods),\n+        let hir::ExprLit(ref lit) = info.other.node,\n+        let ast::LitKind::Char(c) = lit.node,\n+    ], {\n+        span_lint_and_sugg(\n+            cx,\n+            lint,\n+            info.expr.span,\n+            &format!(\"you should use the `{}` method\", suggest),\n+            \"like this\",\n+            format!(\"{}{}.{}('{}')\",\n+                    if info.eq { \"\" } else { \"!\" },\n+                    snippet(cx, args[0][0].span, \"_\"),\n+                    suggest,\n+                    c)\n+        );\n+\n+        return true;\n+    }}\n+\n+    false\n+}\n+\n+/// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n+fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n+}\n+\n+/// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n+fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    if lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n+        true\n+    } else {\n+        lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next_back\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\")\n+    }\n+}\n+\n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, arg: &'tcx hir::Expr) {\n     let parent_item = cx.tcx.hir.get_parent(arg.id);"}]}