{"sha": "0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "node_id": "C_kwDOAAsO6NoAKDBmNGM4MWExYTljNmM0NWEyYjQ1YzMzNmRkNzdiM2JiOWZkZmM2MmU", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-03-15T02:48:53Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-03-15T23:28:07Z"}, "message": "Extend the irrefutable_let_patterns lint to let chains\n\nOnly look for complete suffixes or prefixes of irrefutable let patterns, so\nthat an irrefutable let pattern in a chain surrounded by refutable ones is\nnot linted, as it is an useful pattern.", "tree": {"sha": "6eab97435d4001c0c1ee9169130b0f38dc08de41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eab97435d4001c0c1ee9169130b0f38dc08de41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "html_url": "https://github.com/rust-lang/rust/commit/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83460d5e624e9dff72ea8c8f6e79c10af10a3aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/83460d5e624e9dff72ea8c8f6e79c10af10a3aa1", "html_url": "https://github.com/rust-lang/rust/commit/83460d5e624e9dff72ea8c8f6e79c10af10a3aa1"}], "stats": {"total": 384, "additions": 339, "deletions": 45}, "files": [{"sha": "8a3a46c11903aac8eff0e07b06aee3339a032374", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 180, "deletions": 35, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "patch": "@@ -158,7 +158,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         self.check_patterns(pat, Refutable);\n         let mut cx = self.new_cx(scrutinee.hir_id);\n         let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n-        check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n+        self.check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n     }\n \n     fn check_match(\n@@ -176,7 +176,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             if let Some(hir::Guard::IfLet(ref pat, _)) = arm.guard {\n                 self.check_patterns(pat, Refutable);\n                 let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n-                check_let_reachability(&mut cx, pat.hir_id, tpat, tpat.span());\n+                self.check_let_reachability(&mut cx, pat.hir_id, tpat, tpat.span());\n             }\n         }\n \n@@ -224,6 +224,157 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         }\n     }\n \n+    fn check_let_reachability(\n+        &mut self,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+        pat_id: HirId,\n+        pat: &'p DeconstructedPat<'p, 'tcx>,\n+        span: Span,\n+    ) {\n+        if self.check_let_chain(cx, pat_id) {\n+            return;\n+        }\n+\n+        if is_let_irrefutable(cx, pat_id, pat) {\n+            irrefutable_let_pattern(cx.tcx, pat_id, span);\n+        }\n+    }\n+\n+    fn check_let_chain(&mut self, cx: &mut MatchCheckCtxt<'p, 'tcx>, pat_id: HirId) -> bool {\n+        let hir = self.tcx.hir();\n+        let parent = hir.get_parent_node(pat_id);\n+\n+        // First, figure out if the given pattern is part of a let chain,\n+        // and if so, obtain the top node of the chain.\n+        let mut top = parent;\n+        let mut part_of_chain = false;\n+        loop {\n+            let new_top = hir.get_parent_node(top);\n+            if let hir::Node::Expr(\n+                hir::Expr {\n+                    kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n+                    ..\n+                },\n+                ..,\n+            ) = hir.get(new_top)\n+            {\n+                // If this isn't the first iteration, we need to check\n+                // if there is a let expr before us in the chain, so\n+                // that we avoid doubly checking the let chain.\n+\n+                // The way a chain of &&s is encoded is ((let ... && let ...) && let ...) && let ...\n+                // as && is left-to-right associative. Thus, we need to check rhs.\n+                if part_of_chain && matches!(rhs.kind, hir::ExprKind::Let(..)) {\n+                    return true;\n+                }\n+                // If there is a let at the lhs, and we provide the rhs, we don't do any checking either.\n+                if !part_of_chain && matches!(lhs.kind, hir::ExprKind::Let(..)) && rhs.hir_id == top\n+                {\n+                    return true;\n+                }\n+            } else {\n+                // We've reached the top.\n+                break;\n+            }\n+\n+            // Since this function is called within a let context, it is reasonable to assume that any parent\n+            // `&&` infers a let chain\n+            part_of_chain = true;\n+            top = new_top;\n+        }\n+        if !part_of_chain {\n+            return false;\n+        }\n+\n+        // Second, obtain the refutabilities of all exprs in the chain,\n+        // and record chain members that aren't let exprs.\n+        let mut chain_refutabilities = Vec::new();\n+        let hir::Node::Expr(top_expr) = hir.get(top) else {\n+            // We ensure right above that it's an Expr\n+            unreachable!()\n+        };\n+        let mut cur_expr = top_expr;\n+        loop {\n+            let mut add = |expr: &hir::Expr<'tcx>| {\n+                let refutability = match expr.kind {\n+                    hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n+                        let mut ncx = self.new_cx(init.hir_id);\n+                        let tpat = self.lower_pattern(&mut ncx, pat, &mut false);\n+\n+                        let refutable = !is_let_irrefutable(&mut ncx, pat.hir_id, tpat);\n+                        Some((*span, refutable))\n+                    }\n+                    _ => None,\n+                };\n+                chain_refutabilities.push(refutability);\n+            };\n+            if let hir::Expr {\n+                kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, lhs, rhs),\n+                ..\n+            } = cur_expr\n+            {\n+                add(rhs);\n+                cur_expr = lhs;\n+            } else {\n+                add(cur_expr);\n+                break;\n+            }\n+        }\n+        chain_refutabilities.reverse();\n+\n+        // Third, emit the actual warnings.\n+\n+        if chain_refutabilities.iter().all(|r| matches!(*r, Some((_, false)))) {\n+            // The entire chain is made up of irrefutable `let` statements\n+            let let_source = let_source_parent(self.tcx, top, None);\n+            irrefutable_let_patterns(\n+                cx.tcx,\n+                top,\n+                let_source,\n+                chain_refutabilities.len(),\n+                top_expr.span,\n+            );\n+            return true;\n+        }\n+        let lint_affix = |affix: &[Option<(Span, bool)>], kind, suggestion| {\n+            let span_start = affix[0].unwrap().0;\n+            let span_end = affix.last().unwrap().unwrap().0;\n+            let span = span_start.to(span_end);\n+            let cnt = affix.len();\n+            cx.tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, top, span, |lint| {\n+                let s = pluralize!(cnt);\n+                let mut diag = lint.build(&format!(\"{kind} irrefutable pattern{s} in let chain\"));\n+                diag.note(&format!(\n+                    \"{these} pattern{s} will always match\",\n+                    these = pluralize!(\"this\", cnt),\n+                ));\n+                diag.help(&format!(\n+                    \"consider moving {} {suggestion}\",\n+                    if cnt > 1 { \"them\" } else { \"it\" }\n+                ));\n+                diag.emit()\n+            });\n+        };\n+        if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n+            // The chain has a non-zero prefix of irrefutable `let` statements.\n+\n+            // Check if the let source is while, for there is no alternative place to put a prefix,\n+            // and we shouldn't lint.\n+            let let_source = let_source_parent(self.tcx, top, None);\n+            if !matches!(let_source, LetSource::WhileLet) {\n+                // Emit the lint\n+                let prefix = &chain_refutabilities[..until];\n+                lint_affix(prefix, \"leading\", \"outside of the construct\");\n+            }\n+        }\n+        if let Some(from) = chain_refutabilities.iter().rposition(|r| !matches!(*r, Some((_, false)))) && from != (chain_refutabilities.len() - 1) {\n+            // The chain has a non-empty suffix of irrefutable `let` statements\n+            let suffix = &chain_refutabilities[from + 1..];\n+            lint_affix(suffix, \"trailing\", \"into the body\");\n+        }\n+        true\n+    }\n+\n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(pat.hir_id);\n \n@@ -453,21 +604,33 @@ fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n+    let source = let_source(tcx, id);\n+    irrefutable_let_patterns(tcx, id, source, 1, span);\n+}\n+\n+fn irrefutable_let_patterns(\n+    tcx: TyCtxt<'_>,\n+    id: HirId,\n+    source: LetSource,\n+    count: usize,\n+    span: Span,\n+) {\n     macro_rules! emit_diag {\n         (\n             $lint:expr,\n             $source_name:expr,\n             $note_sufix:expr,\n             $help_sufix:expr\n         ) => {{\n-            let mut diag = $lint.build(concat!(\"irrefutable \", $source_name, \" pattern\"));\n-            diag.note(concat!(\"this pattern will always match, so the \", $note_sufix));\n+            let s = pluralize!(count);\n+            let these = pluralize!(\"this\", count);\n+            let mut diag = $lint.build(&format!(\"irrefutable {} pattern{s}\", $source_name));\n+            diag.note(&format!(\"{these} pattern{s} will always match, so the {}\", $note_sufix));\n             diag.help(concat!(\"consider \", $help_sufix));\n             diag.emit()\n         }};\n     }\n \n-    let source = let_source(tcx, id);\n     let span = match source {\n         LetSource::LetElse(span) => span,\n         _ => span,\n@@ -511,16 +674,11 @@ fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n     });\n }\n \n-fn check_let_reachability<'p, 'tcx>(\n+fn is_let_irrefutable<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     pat_id: HirId,\n     pat: &'p DeconstructedPat<'p, 'tcx>,\n-    span: Span,\n-) {\n-    if is_let_chain(cx.tcx, pat_id) {\n-        return;\n-    }\n-\n+) -> bool {\n     let arms = [MatchArm { pat, hir_id: pat_id, has_guard: false }];\n     let report = compute_match_usefulness(&cx, &arms, pat_id, pat.ty());\n \n@@ -529,10 +687,9 @@ fn check_let_reachability<'p, 'tcx>(\n     // `is_uninhabited` check.\n     report_arm_reachability(&cx, &report);\n \n-    if report.non_exhaustiveness_witnesses.is_empty() {\n-        // The match is exhaustive, i.e. the `if let` pattern is irrefutable.\n-        irrefutable_let_pattern(cx.tcx, pat_id, span);\n-    }\n+    // If the list of witnesses is empty, the match is exhaustive,\n+    // i.e. the `if let` pattern is irrefutable.\n+    report.non_exhaustiveness_witnesses.is_empty()\n }\n \n /// Report unreachable arms, if any.\n@@ -941,13 +1098,19 @@ fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n     let hir = tcx.hir();\n \n     let parent = hir.get_parent_node(pat_id);\n+    let_source_parent(tcx, parent, Some(pat_id))\n+}\n+\n+fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> LetSource {\n+    let hir = tcx.hir();\n+\n     let parent_node = hir.get(parent);\n \n     match parent_node {\n         hir::Node::Arm(hir::Arm {\n             guard: Some(hir::Guard::IfLet(&hir::Pat { hir_id, .. }, _)),\n             ..\n-        }) if hir_id == pat_id => {\n+        }) if Some(hir_id) == pat_id => {\n             return LetSource::IfLetGuard;\n         }\n         hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Let(..), span, .. }) => {\n@@ -980,21 +1143,3 @@ fn let_source(tcx: TyCtxt<'_>, pat_id: HirId) -> LetSource {\n \n     LetSource::GenericLet\n }\n-\n-// Since this function is called within a let context, it is reasonable to assume that any parent\n-// `&&` infers a let chain\n-fn is_let_chain(tcx: TyCtxt<'_>, pat_id: HirId) -> bool {\n-    let hir = tcx.hir();\n-    let parent = hir.get_parent_node(pat_id);\n-    let parent_parent = hir.get_parent_node(parent);\n-    matches!(\n-        hir.get(parent_parent),\n-        hir::Node::Expr(\n-            hir::Expr {\n-                kind: hir::ExprKind::Binary(Spanned { node: hir::BinOpKind::And, .. }, ..),\n-                ..\n-            },\n-            ..\n-        )\n-    )\n-}"}, {"sha": "6498a5195719493dea0b0b46241c39d744f7c4ab", "filename": "src/test/ui/mir/mir_let_chains_drop_order.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs?ref=0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "patch": "@@ -5,6 +5,7 @@\n // See `mir_drop_order.rs` for more information\n \n #![feature(let_chains)]\n+#![allow(irrefutable_let_patterns)]\n \n use std::cell::RefCell;\n use std::panic;"}, {"sha": "d851fac8e644fdac9dc70743538ff83ffc1322e1", "filename": "src/test/ui/rfc-2497-if-let-chains/ast-lowering-does-not-wrap-let-chains.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fast-lowering-does-not-wrap-let-chains.rs?ref=0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n #![feature(let_chains)]\n+#![allow(irrefutable_let_patterns)]\n \n fn main() {\n     let first = Some(1);"}, {"sha": "d1d5288aea31c25a1a649a321c87ce719b893777", "filename": "src/test/ui/rfc-2497-if-let-chains/irrefutable-lets.disallowed.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.disallowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.disallowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.disallowed.stderr?ref=0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "patch": "@@ -0,0 +1,115 @@\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:13:8\n+   |\n+LL |     if let first = &opt && let Some(ref second) = first && let None = second.start {}\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/irrefutable-lets.rs:6:30\n+   |\n+LL | #![cfg_attr(disallowed, deny(irrefutable_let_patterns))]\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: irrefutable `if let` patterns\n+  --> $DIR/irrefutable-lets.rs:19:8\n+   |\n+LL |     if let first = &opt && let (a, b) = (1, 2) {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match, so the `if let` is useless\n+   = help: consider replacing the `if let` with a `let`\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:22:8\n+   |\n+LL |     if let first = &opt && let Some(ref second) = first && let None = second.start && let v = 0 {}\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: trailing irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:22:87\n+   |\n+LL |     if let first = &opt && let Some(ref second) = first && let None = second.start && let v = 0 {}\n+   |                                                                                       ^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it into the body\n+\n+error: trailing irrefutable patterns in let chain\n+  --> $DIR/irrefutable-lets.rs:26:37\n+   |\n+LL |     if let Some(ref first) = opt && let second = first && let _third = second {}\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match\n+   = help: consider moving them into the body\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:29:8\n+   |\n+LL |     if let Range { start: local_start, end: _ } = (None..Some(1)) && let None = local_start {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:32:8\n+   |\n+LL |     if let (a, b, c) = (Some(1), Some(1), Some(1)) && let None = Some(1) {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:35:8\n+   |\n+LL |     if let first = &opt && let None = Some(1) {}\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: irrefutable `let` patterns\n+  --> $DIR/irrefutable-lets.rs:44:28\n+   |\n+LL |         Some(ref first) if let second = first && let _third = second && let v = 4 + 4 => {},\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match, so the `let` is useless\n+   = help: consider removing `let`\n+\n+error: leading irrefutable pattern in let chain\n+  --> $DIR/irrefutable-lets.rs:50:28\n+   |\n+LL |         Some(ref first) if let Range { start: local_start, end: _ } = first\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this pattern will always match\n+   = help: consider moving it outside of the construct\n+\n+error: irrefutable `while let` patterns\n+  --> $DIR/irrefutable-lets.rs:59:11\n+   |\n+LL |     while let first = &opt && let (a, b) = (1, 2) {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match, so the loop will never exit\n+   = help: consider instead using a `loop { ... }` with a `let` inside it\n+\n+error: trailing irrefutable patterns in let chain\n+  --> $DIR/irrefutable-lets.rs:62:40\n+   |\n+LL |     while let Some(ref first) = opt && let second = first && let _third = second {}\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: these patterns will always match\n+   = help: consider moving them into the body\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "3d1626e8ffb9adb95afc00a8db2aa8e40279be6e", "filename": "src/test/ui/rfc-2497-if-let-chains/irrefutable-lets.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Firrefutable-lets.rs?ref=0f4c81a1a9c6c45a2b45c336dd77b3bb9fdfc62e", "patch": "@@ -1,35 +1,67 @@\n-// check-pass\n+// revisions: allowed disallowed\n+//[allowed] check-pass\n \n #![feature(if_let_guard, let_chains)]\n+#![cfg_attr(allowed, allow(irrefutable_let_patterns))]\n+#![cfg_attr(disallowed, deny(irrefutable_let_patterns))]\n \n use std::ops::Range;\n \n fn main() {\n     let opt = Some(None..Some(1));\n \n-    if let first = &opt && let Some(ref second) = first && let None = second.start {\n-    }\n-    if let Some(ref first) = opt && let second = first && let _third = second {\n-    }\n+    if let first = &opt && let Some(ref second) = first && let None = second.start {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n+    // No lint as the irrefutable pattern is surrounded by other stuff\n+    if 4 * 2 == 0 && let first = &opt && let Some(ref second) = first && let None = second.start {}\n+\n+    if let first = &opt && let (a, b) = (1, 2) {}\n+    //[disallowed]~^ ERROR irrefutable `if let` patterns\n+\n+    if let first = &opt && let Some(ref second) = first && let None = second.start && let v = 0 {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+    //[disallowed]~^^ ERROR trailing irrefutable pattern in let chain\n+\n+    if let Some(ref first) = opt && let second = first && let _third = second {}\n+    //[disallowed]~^ ERROR trailing irrefutable patterns in let chain\n+\n+    if let Range { start: local_start, end: _ } = (None..Some(1)) && let None = local_start {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n+    if let (a, b, c) = (Some(1), Some(1), Some(1)) && let None = Some(1) {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n+    if let first = &opt && let None = Some(1) {}\n+    //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n+\n     if let Some(ref first) = opt\n         && let Range { start: local_start, end: _ } = first\n         && let None = local_start {\n     }\n \n     match opt {\n-        Some(ref first) if let second = first && let _third = second => {},\n+        Some(ref first) if let second = first && let _third = second && let v = 4 + 4 => {},\n+        //[disallowed]~^ ERROR irrefutable `let` patterns\n         _ => {}\n     }\n+\n     match opt {\n         Some(ref first) if let Range { start: local_start, end: _ } = first\n+        //[disallowed]~^ ERROR leading irrefutable pattern in let chain\n             && let None = local_start => {},\n         _ => {}\n     }\n \n-    while let first = &opt && let Some(ref second) = first && let None = second.start {\n-    }\n-    while let Some(ref first) = opt && let second = first && let _third = second {\n-    }\n+    // No error, despite the prefix being irrefutable\n+    while let first = &opt && let Some(ref second) = first && let None = second.start {}\n+\n+    while let first = &opt && let (a, b) = (1, 2) {}\n+    //[disallowed]~^ ERROR irrefutable `while let` patterns\n+\n+    while let Some(ref first) = opt && let second = first && let _third = second {}\n+    //[disallowed]~^ ERROR trailing irrefutable patterns in let chain\n+\n     while let Some(ref first) = opt\n         && let Range { start: local_start, end: _ } = first\n         && let None = local_start {"}]}