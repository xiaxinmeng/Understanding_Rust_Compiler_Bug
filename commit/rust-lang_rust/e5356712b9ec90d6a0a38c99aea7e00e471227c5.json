{"sha": "e5356712b9ec90d6a0a38c99aea7e00e471227c5", "node_id": "C_kwDOAAsO6NoAKGU1MzU2NzEyYjllYzkwZDZhMGEzOGM5OWFlYTdlMDBlNDcxMjI3YzU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-31T19:30:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T19:30:13Z"}, "message": "Rollup merge of #101165 - ldm0:drain_to_iter, r=cjgillot\n\nUse more `into_iter` rather than `drain(..)`\n\nClearer semantic.", "tree": {"sha": "fa1c5fb8ecbd6a056b2a77ff882a717028470942", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa1c5fb8ecbd6a056b2a77ff882a717028470942"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5356712b9ec90d6a0a38c99aea7e00e471227c5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjD7bFCRBK7hj4Ov3rIwAAT6cIAG99oHVNwcL89rA0E4GA8UWX\nHRNGeas7JzqpqFGFctOoSzwgq2dCjttm3daMdtfMU8tA1SljwhIYY7+Cvgf65xcl\n0K3e5Orhpe7lo9PbcxUQYMd6D9zar56d89kcmQG5D723iJ+6I6ILd089PR2zIuRZ\nlRGSbXACWeXyGxNxggHQMPuNJbYGwYcInrxOFLm8ZlZdSOrVD/qEF3+FTycXxxMY\nqUMpYBOfm95X8KPZA0vqz7Y2/GNtB8O4uCkPSo/PF1Mljm3HQ/yALzEE7U8OppAV\nzN3smiXGBW3dKK6xfNtvs+X3FZIyxjYZcG8RnmvuJ85uccRHSHvfWpDc1dj86NI=\n=ll8n\n-----END PGP SIGNATURE-----\n", "payload": "tree fa1c5fb8ecbd6a056b2a77ff882a717028470942\nparent f378155fb6e9b1f22bef53a37fe61a1b21eed545\nparent 97b1a6146c630374ddab15f424eb8141dbb88960\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661974213 +0200\ncommitter GitHub <noreply@github.com> 1661974213 +0200\n\nRollup merge of #101165 - ldm0:drain_to_iter, r=cjgillot\n\nUse more `into_iter` rather than `drain(..)`\n\nClearer semantic.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5356712b9ec90d6a0a38c99aea7e00e471227c5", "html_url": "https://github.com/rust-lang/rust/commit/e5356712b9ec90d6a0a38c99aea7e00e471227c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5356712b9ec90d6a0a38c99aea7e00e471227c5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f378155fb6e9b1f22bef53a37fe61a1b21eed545", "url": "https://api.github.com/repos/rust-lang/rust/commits/f378155fb6e9b1f22bef53a37fe61a1b21eed545", "html_url": "https://github.com/rust-lang/rust/commit/f378155fb6e9b1f22bef53a37fe61a1b21eed545"}, {"sha": "97b1a6146c630374ddab15f424eb8141dbb88960", "url": "https://api.github.com/repos/rust-lang/rust/commits/97b1a6146c630374ddab15f424eb8141dbb88960", "html_url": "https://github.com/rust-lang/rust/commit/97b1a6146c630374ddab15f424eb8141dbb88960"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "fd5aa9391976f1a2f1686e33a0cbddd3c017ba09", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=e5356712b9ec90d6a0a38c99aea7e00e471227c5", "patch": "@@ -555,7 +555,7 @@ impl TokenStreamBuilder {\n \n                 // Get the first stream, which will become the result stream.\n                 // If it's `None`, create an empty stream.\n-                let mut iter = streams.drain(..);\n+                let mut iter = streams.into_iter();\n                 let mut res_stream_lrc = iter.next().unwrap().0;\n \n                 // Append the subsequent elements to the result stream, after"}, {"sha": "937cb671573a1c97b2096d3dab4382075365a97e", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=e5356712b9ec90d6a0a38c99aea7e00e471227c5", "patch": "@@ -164,7 +164,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     /// It is up to the caller to make sure that the elements are sorted by key\n     /// and that there are no duplicates.\n     #[inline]\n-    pub fn insert_presorted(&mut self, mut elements: Vec<(K, V)>) {\n+    pub fn insert_presorted(&mut self, elements: Vec<(K, V)>) {\n         if elements.is_empty() {\n             return;\n         }\n@@ -173,28 +173,28 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n         let start_index = self.lookup_index_for(&elements[0].0);\n \n-        let drain = match start_index {\n+        let elements = match start_index {\n             Ok(index) => {\n-                let mut drain = elements.drain(..);\n-                self.data[index] = drain.next().unwrap();\n-                drain\n+                let mut elements = elements.into_iter();\n+                self.data[index] = elements.next().unwrap();\n+                elements\n             }\n             Err(index) => {\n                 if index == self.data.len() || elements.last().unwrap().0 < self.data[index].0 {\n                     // We can copy the whole range without having to mix with\n                     // existing elements.\n-                    self.data.splice(index..index, elements.drain(..));\n+                    self.data.splice(index..index, elements.into_iter());\n                     return;\n                 }\n \n-                let mut drain = elements.drain(..);\n-                self.data.insert(index, drain.next().unwrap());\n-                drain\n+                let mut elements = elements.into_iter();\n+                self.data.insert(index, elements.next().unwrap());\n+                elements\n             }\n         };\n \n         // Insert the rest\n-        for (k, v) in drain {\n+        for (k, v) in elements {\n             self.insert(k, v);\n         }\n     }"}, {"sha": "95ae9765a4816fcd7a44102fb21c06545b69c962", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=e5356712b9ec90d6a0a38c99aea7e00e471227c5", "patch": "@@ -974,12 +974,12 @@ impl Diagnostic {\n     fn sub_with_highlights<M: Into<SubdiagnosticMessage>>(\n         &mut self,\n         level: Level,\n-        mut message: Vec<(M, Style)>,\n+        message: Vec<(M, Style)>,\n         span: MultiSpan,\n         render_span: Option<MultiSpan>,\n     ) {\n         let message = message\n-            .drain(..)\n+            .into_iter()\n             .map(|m| (self.subdiagnostic_message_to_diagnostic_message(m.0), m.1))\n             .collect();\n         let sub = SubDiagnostic { level, message, span, render_span };"}, {"sha": "4f407badb3f9eb777e3857ac835dccc9cdab1993", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=e5356712b9ec90d6a0a38c99aea7e00e471227c5", "patch": "@@ -21,7 +21,7 @@ pub trait Translate {\n     /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n     /// passed around as a reference thereafter.\n     fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n-        FromIterator::from_iter(args.to_vec().drain(..))\n+        FromIterator::from_iter(args.iter().cloned())\n     }\n \n     /// Convert `DiagnosticMessage`s to a string, performing translation if necessary."}, {"sha": "2a4fe48a8aca28de4c5875ace0fb3f0f06051133", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=e5356712b9ec90d6a0a38c99aea7e00e471227c5", "patch": "@@ -239,7 +239,7 @@ impl DiagnosticDeriveBuilder {\n             }\n         }\n \n-        Ok(tokens.drain(..).collect())\n+        Ok(tokens.into_iter().collect())\n     }\n \n     fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {"}, {"sha": "9ecf34e9ad3e71ac81b187cf6fded98962d1e86a", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5356712b9ec90d6a0a38c99aea7e00e471227c5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=e5356712b9ec90d6a0a38c99aea7e00e471227c5", "patch": "@@ -501,7 +501,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         if !errors_buffer.is_empty() {\n             errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n-            for mut diag in errors_buffer.drain(..) {\n+            for mut diag in errors_buffer {\n                 self.tcx().sess.diagnostic().emit_diagnostic(&mut diag);\n             }\n         }"}]}