{"sha": "b973158aeb337041d4e1434cf5d8c609a0b02bef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NzMxNThhZWIzMzcwNDFkNGUxNDM0Y2Y1ZDhjNjA5YTBiMDJiZWY=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-03-13T12:03:31Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-16T17:38:19Z"}, "message": "Make MBE expansion more resilient (WIP)", "tree": {"sha": "e3da1bb7a3c2d89623382865edc7ef64c039496d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3da1bb7a3c2d89623382865edc7ef64c039496d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b973158aeb337041d4e1434cf5d8c609a0b02bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b973158aeb337041d4e1434cf5d8c609a0b02bef", "html_url": "https://github.com/rust-lang/rust/commit/b973158aeb337041d4e1434cf5d8c609a0b02bef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b973158aeb337041d4e1434cf5d8c609a0b02bef/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3773ec1522681de117d354f0c82e753c68c6d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3773ec1522681de117d354f0c82e753c68c6d0b", "html_url": "https://github.com/rust-lang/rust/commit/d3773ec1522681de117d354f0c82e753c68c6d0b"}], "stats": {"total": 259, "additions": 168, "deletions": 91}, "files": [{"sha": "e7b81a1e6839982019128291d67ba77a9f65ea47", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -27,11 +27,12 @@ impl TokenExpander {\n         db: &dyn AstDatabase,\n         id: LazyMacroId,\n         tt: &tt::Subtree,\n-    ) -> Result<tt::Subtree, mbe::ExpandError> {\n+    ) -> mbe::ExpandResult<tt::Subtree> {\n         match self {\n             TokenExpander::MacroRules(it) => it.expand(tt),\n-            TokenExpander::Builtin(it) => it.expand(db, id, tt),\n-            TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt),\n+            // FIXME switch these to ExpandResult as well\n+            TokenExpander::Builtin(it) => it.expand(db, id, tt).map_or_else(|e| (tt::Subtree::default(), Some(e)), |r| (r, None)),\n+            TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt).map_or_else(|e| (tt::Subtree::default(), Some(e)), |r| (r, None)),\n         }\n     }\n \n@@ -66,7 +67,7 @@ pub trait AstDatabase: SourceDatabase {\n     fn macro_def(&self, id: MacroDefId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>>;\n     fn parse_macro(&self, macro_file: MacroFile)\n         -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>;\n-    fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n+    fn macro_expand(&self, macro_call: MacroCallId) -> (Option<Arc<tt::Subtree>>, Option<String>);\n \n     #[salsa::interned]\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n@@ -153,7 +154,7 @@ pub(crate) fn macro_arg(\n pub(crate) fn macro_expand(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n-) -> Result<Arc<tt::Subtree>, String> {\n+) -> (Option<Arc<tt::Subtree>>, Option<String>) {\n     macro_expand_with_arg(db, id, None)\n }\n \n@@ -174,31 +175,39 @@ fn macro_expand_with_arg(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n     arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n-) -> Result<Arc<tt::Subtree>, String> {\n+) -> (Option<Arc<tt::Subtree>>, Option<String>) {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(id) => {\n             if arg.is_some() {\n-                return Err(\n-                    \"hypothetical macro expansion not implemented for eager macro\".to_owned()\n+                return (\n+                    None,\n+                    Some(\"hypothetical macro expansion not implemented for eager macro\".to_owned())\n                 );\n             } else {\n-                return Ok(db.lookup_intern_eager_expansion(id).subtree);\n+                return (Some(db.lookup_intern_eager_expansion(id).subtree), None);\n             }\n         }\n     };\n \n     let loc = db.lookup_intern_macro(lazy_id);\n-    let macro_arg = arg.or_else(|| db.macro_arg(id)).ok_or(\"Fail to args in to tt::TokenTree\")?;\n+    let macro_arg = match arg.or_else(|| db.macro_arg(id)) {\n+        Some(it) => it,\n+        None => return (None, Some(\"Fail to args in to tt::TokenTree\".into())),\n+    };\n \n-    let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.0.expand(db, lazy_id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n+    let macro_rules = match db.macro_def(loc.def) {\n+        Some(it) => it,\n+        None => return (None, Some(\"Fail to find macro definition\".into())),\n+    };\n+    let (tt, err) = macro_rules.0.expand(db, lazy_id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n+    eprintln!(\"expansion size: {}\", tt.count());\n     let count = tt.count();\n     if count > 65536 {\n-        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n+        return (None, Some(format!(\"Total tokens count exceed limit : count = {}\", count)));\n     }\n-    Ok(Arc::new(tt))\n+    (Some(Arc::new(tt)), err.map(|e| format!(\"{:?}\", e)))\n }\n \n pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n@@ -225,42 +234,41 @@ pub fn parse_macro_with_arg(\n     let _p = profile(\"parse_macro_query\");\n \n     let macro_call_id = macro_file.macro_call_id;\n-    let expansion = if let Some(arg) = arg {\n+    let (tt, err) = if let Some(arg) = arg {\n         macro_expand_with_arg(db, macro_call_id, Some(arg))\n     } else {\n         db.macro_expand(macro_call_id)\n     };\n-    let tt = expansion\n-        .map_err(|err| {\n-            // Note:\n-            // The final goal we would like to make all parse_macro success,\n-            // such that the following log will not call anyway.\n-            match macro_call_id {\n-                MacroCallId::LazyMacro(id) => {\n-                    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n-                    let node = loc.kind.node(db);\n-\n-                    // collect parent information for warning log\n-                    let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n-                        it.file_id.call_node(db)\n-                    })\n+    if let Some(err) = err {\n+        // Note:\n+        // The final goal we would like to make all parse_macro success,\n+        // such that the following log will not call anyway.\n+        match macro_call_id {\n+            MacroCallId::LazyMacro(id) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+                let node = loc.kind.node(db);\n+\n+                // collect parent information for warning log\n+                let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n+                    it.file_id.call_node(db)\n+                })\n                     .map(|n| format!(\"{:#}\", n.value))\n                     .collect::<Vec<_>>()\n                     .join(\"\\n\");\n \n-                    log::warn!(\n-                        \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\",\n-                        err,\n-                        node.value,\n-                        parents\n-                    );\n-                }\n-                _ => {\n-                    log::warn!(\"fail on macro_parse: (reason: {})\", err);\n-                }\n+                log::warn!(\n+                    \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\",\n+                    err,\n+                    node.value,\n+                    parents\n+                );\n+            }\n+            _ => {\n+                log::warn!(\"fail on macro_parse: (reason: {})\", err);\n             }\n-        })\n-        .ok()?;\n+        }\n+    };\n+    let tt = tt?;\n \n     let fragment_kind = to_fragment_kind(db, macro_call_id);\n "}, {"sha": "2e309a379148db319426418b2f574d7f483b25c3", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -462,7 +462,7 @@ fn main() {\n fn infer_builtin_macros_include() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n \n@@ -483,7 +483,7 @@ fn bar() -> u32 {0}\n fn infer_builtin_macros_include_concat() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n \n@@ -507,7 +507,7 @@ fn bar() -> u32 {0}\n fn infer_builtin_macros_include_concat_with_bad_env_should_failed() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n \n@@ -534,7 +534,7 @@ fn bar() -> u32 {0}\n fn infer_builtin_macros_include_itself_should_failed() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n "}, {"sha": "a30d1c2ded67e5d38bcae5f32a4029e28fa0afb8", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -751,6 +751,43 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn macro_expansion_resilient() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! dbg {\n+                    () => {};\n+                    ($val:expr) => {\n+                        match $val { tmp => { tmp } }\n+                    };\n+                    // Trailing comma with single argument is ignored\n+                    ($val:expr,) => { $crate::dbg!($val) };\n+                    ($($val:expr),+ $(,)?) => {\n+                        ($($crate::dbg!($val)),+,)\n+                    };\n+                }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    dbg!(a.<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [552; 553),\n+                delete: [552; 553),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_method_completion_3547() {\n         assert_debug_snapshot!("}, {"sha": "e58526f31f50d637cf2b7cc84214aa41feb03fe1", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -259,7 +259,7 @@ fn some_thing() -> u32 {\n         );\n \n         assert_eq!(res.name, \"foo\");\n-        assert_snapshot!(res.expansion, @r###\"bar!()\"###);\n+        assert_snapshot!(res.expansion, @r###\"\"###);\n     }\n \n     #[test]"}, {"sha": "3adec4978abb135554aeeadac1f924caad90b8ee", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -30,6 +30,8 @@ pub enum ExpandError {\n     InvalidRepeat,\n }\n \n+pub type ExpandResult<T> = (T, Option<ExpandError>);\n+\n pub use crate::syntax_bridge::{\n     ast_to_token_tree, parse_to_token_tree, syntax_node_to_token_tree, token_tree_to_syntax_node,\n     TokenMap,\n@@ -150,7 +152,7 @@ impl MacroRules {\n         Ok(MacroRules { rules, shift: Shift::new(tt) })\n     }\n \n-    pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n+    pub fn expand(&self, tt: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n         // apply shift\n         let mut tt = tt.clone();\n         self.shift.shift_all(&mut tt);"}, {"sha": "da39524281ae73816c12db9755a768bc4ce064a9", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -8,19 +8,30 @@ mod transcriber;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n \n-use crate::ExpandError;\n+use crate::{ExpandResult, ExpandError};\n \n pub(crate) fn expand(\n     rules: &crate::MacroRules,\n     input: &tt::Subtree,\n-) -> Result<tt::Subtree, ExpandError> {\n-    rules.rules.iter().find_map(|it| expand_rule(it, input).ok()).ok_or(ExpandError::NoMatchingRule)\n+) -> ExpandResult<tt::Subtree> {\n+    let (mut result, mut err) = (tt::Subtree::default(), Some(ExpandError::NoMatchingRule));\n+    for rule in &rules.rules {\n+        let (res, e) = expand_rule(rule, input);\n+        if e.is_none() {\n+            // if we find a rule that applies without errors, we're done\n+            return (res, None);\n+        }\n+        // TODO decide which result is better\n+        result = res;\n+        err = e;\n+    }\n+    (result, err)\n }\n \n-fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n-    let bindings = matcher::match_(&rule.lhs, input)?;\n-    let res = transcriber::transcribe(&rule.rhs, &bindings)?;\n-    Ok(res)\n+fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+    let (bindings, bindings_err) = dbg!(matcher::match_(&rule.lhs, input));\n+    let (res, transcribe_err) = dbg!(transcriber::transcribe(&rule.rhs, &bindings));\n+    (res, bindings_err.or(transcribe_err))\n }\n \n /// The actual algorithm for expansion is not too hard, but is pretty tricky.\n@@ -111,7 +122,7 @@ mod tests {\n     }\n \n     fn assert_err(macro_body: &str, invocation: &str, err: ExpandError) {\n-        assert_eq!(expand_first(&create_rules(&format_macro(macro_body)), invocation), Err(err));\n+        assert_eq!(expand_first(&create_rules(&format_macro(macro_body)), invocation).1, Some(err));\n     }\n \n     fn format_macro(macro_body: &str) -> String {\n@@ -138,7 +149,7 @@ mod tests {\n     fn expand_first(\n         rules: &crate::MacroRules,\n         invocation: &str,\n-    ) -> Result<tt::Subtree, ExpandError> {\n+    ) -> ExpandResult<tt::Subtree> {\n         let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n         let macro_invocation =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();"}, {"sha": "f9d4952c6d0966f8d451563f225a32a60508a8ad", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -11,6 +11,7 @@ use crate::{\n use ra_parser::{FragmentKind::*, TreeSink};\n use ra_syntax::{SmolStr, SyntaxKind};\n use tt::buffer::{Cursor, TokenBuffer};\n+use super::ExpandResult;\n \n impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n@@ -64,19 +65,19 @@ macro_rules! bail {\n     };\n }\n \n-pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Bindings, ExpandError> {\n+pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> ExpandResult<Bindings> {\n     assert!(pattern.delimiter == None);\n \n     let mut res = Bindings::default();\n     let mut src = TtIter::new(src);\n \n-    match_subtree(&mut res, pattern, &mut src)?;\n+    let mut err = match_subtree(&mut res, pattern, &mut src).err();\n \n-    if src.len() > 0 {\n-        bail!(\"leftover tokens\");\n+    if src.len() > 0 && err.is_none() {\n+        err = Some(err!(\"leftover tokens\"));\n     }\n \n-    Ok(res)\n+    (res, err)\n }\n \n fn match_subtree("}, {"sha": "c53c2d35e68ba1a0a32eaa5770d4971f5a0b3566", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -3,6 +3,7 @@\n \n use ra_syntax::SmolStr;\n \n+use super::ExpandResult;\n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n     parser::{parse_template, Op, RepeatKind, Separator},\n@@ -49,10 +50,7 @@ impl Bindings {\n     }\n }\n \n-pub(super) fn transcribe(\n-    template: &tt::Subtree,\n-    bindings: &Bindings,\n-) -> Result<tt::Subtree, ExpandError> {\n+pub(super) fn transcribe(template: &tt::Subtree, bindings: &Bindings) -> ExpandResult<tt::Subtree> {\n     assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n     expand_subtree(&mut ctx, template)\n@@ -75,35 +73,46 @@ struct ExpandCtx<'a> {\n     nesting: Vec<NestingState>,\n }\n \n-fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n+fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n+    let mut err = None;\n     for op in parse_template(template) {\n-        match op? {\n+        let op = match op {\n+            Ok(op) => op,\n+            Err(e) => {\n+                err = Some(e);\n+                break;\n+            }\n+        };\n+        match op {\n             Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => buf.push(tt.clone()),\n             Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n-                let tt = expand_subtree(ctx, tt)?;\n+                let (tt, e) = expand_subtree(ctx, tt);\n+                err = err.or(e);\n                 buf.push(tt.into());\n             }\n             Op::Var { name, kind: _ } => {\n-                let fragment = expand_var(ctx, name)?;\n+                let (fragment, e) = expand_var(ctx, name);\n+                err = err.or(e);\n                 push_fragment(&mut buf, fragment);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                let fragment = expand_repeat(ctx, subtree, kind, separator)?;\n+                let (fragment, e) = expand_repeat(ctx, subtree, kind, separator);\n+                err = err.or(e);\n                 push_fragment(&mut buf, fragment)\n             }\n         }\n     }\n-    Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n+    (tt::Subtree { delimiter: template.delimiter, token_trees: buf }, err)\n }\n \n-fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> Result<Fragment, ExpandError> {\n-    let res = if v == \"crate\" {\n+fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n+    if v == \"crate\" {\n         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n         let tt =\n             tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n                 .into();\n-        Fragment::Tokens(tt)\n+        (Fragment::Tokens(tt), None)\n     } else if !ctx.bindings.contains(v) {\n         // Note that it is possible to have a `$var` inside a macro which is not bound.\n         // For example:\n@@ -132,29 +141,31 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> Result<Fragment, ExpandError>\n             ],\n         }\n         .into();\n-        Fragment::Tokens(tt)\n+        (Fragment::Tokens(tt), None)\n     } else {\n-        ctx.bindings.get(&v, &mut ctx.nesting)?.clone()\n-    };\n-    Ok(res)\n+        ctx.bindings.get(&v, &mut ctx.nesting).map_or_else(\n+            |e| (Fragment::Tokens(tt::TokenTree::empty()), Some(e)),\n+            |b| (b.clone(), None),\n+        )\n+    }\n }\n \n fn expand_repeat(\n     ctx: &mut ExpandCtx,\n     template: &tt::Subtree,\n     kind: RepeatKind,\n     separator: Option<Separator>,\n-) -> Result<Fragment, ExpandError> {\n+) -> ExpandResult<Fragment> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n     ctx.nesting.push(NestingState { idx: 0, at_end: false, hit: false });\n     // Dirty hack to make macro-expansion terminate.\n-    // This should be replaced by a propper macro-by-example implementation\n+    // This should be replaced by a proper macro-by-example implementation\n     let limit = 65536;\n     let mut has_seps = 0;\n     let mut counter = 0;\n \n     loop {\n-        let res = expand_subtree(ctx, template);\n+        let (mut t, e) = expand_subtree(ctx, template);\n         let nesting_state = ctx.nesting.last_mut().unwrap();\n         if nesting_state.at_end || !nesting_state.hit {\n             break;\n@@ -172,10 +183,10 @@ fn expand_repeat(\n             break;\n         }\n \n-        let mut t = match res {\n-            Ok(t) => t,\n-            Err(_) => continue,\n-        };\n+        if e.is_some() {\n+            continue;\n+        }\n+\n         t.delimiter = None;\n         push_subtree(&mut buf, t);\n \n@@ -209,14 +220,14 @@ fn expand_repeat(\n         buf.pop();\n     }\n \n-    if RepeatKind::OneOrMore == kind && counter == 0 {\n-        return Err(ExpandError::UnexpectedToken);\n-    }\n-\n     // Check if it is a single token subtree without any delimiter\n     // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n     let tt = tt::Subtree { delimiter: None, token_trees: buf }.into();\n-    Ok(Fragment::Tokens(tt))\n+\n+    if RepeatKind::OneOrMore == kind && counter == 0 {\n+        return (Fragment::Tokens(tt), Some(ExpandError::UnexpectedToken));\n+    }\n+    (Fragment::Tokens(tt), None)\n }\n \n fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {"}, {"sha": "4d3140fa9e0782934a7892abf00020b46b6e33ab", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -1430,7 +1430,8 @@ impl MacroFixture {\n         let (invocation_tt, _) =\n             ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n-        self.rules.expand(&invocation_tt)\n+        let (tt, err) = self.rules.expand(&invocation_tt);\n+        err.map(Err).unwrap_or(Ok(tt))\n     }\n \n     fn assert_expand_err(&self, invocation: &str, err: &ExpandError) {"}, {"sha": "1e2fb8b913b8da9a640bb0efedf864faec1645fb", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b973158aeb337041d4e1434cf5d8c609a0b02bef/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=b973158aeb337041d4e1434cf5d8c609a0b02bef", "patch": "@@ -40,6 +40,12 @@ pub enum TokenTree {\n }\n impl_froms!(TokenTree: Leaf, Subtree);\n \n+impl TokenTree {\n+    pub fn empty() -> Self {\n+        TokenTree::Subtree(Subtree::default())\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Leaf {\n     Literal(Literal),"}]}