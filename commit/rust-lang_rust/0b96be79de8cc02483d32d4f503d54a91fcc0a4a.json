{"sha": "0b96be79de8cc02483d32d4f503d54a91fcc0a4a", "node_id": "C_kwDOAAsO6NoAKDBiOTZiZTc5ZGU4Y2MwMjQ4M2QzMmQ0ZjUwM2Q1NGE5MWZjYzBhNGE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-29T21:54:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-29T21:54:40Z"}, "message": "Rollup merge of #96536 - rust-lang:notriddle/deref-slice-core, r=GuillaumeGomez\n\nrustdoc: fix missing method list for primitive deref target\n\nThis change makes it so that local impls count when listing primitives that need retained.\n\nFixes #95325", "tree": {"sha": "daf9b5df9e7270d752db6a62abbcad9f962db810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daf9b5df9e7270d752db6a62abbcad9f962db810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b96be79de8cc02483d32d4f503d54a91fcc0a4a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJibF6gCRBK7hj4Ov3rIwAAWAAIAExWHq20/bqmIHATl/qJz2za\noCAQsMUvaZkjLZ7D6KIX9a8Ix4dhCIzuBkD/J+MBTAOR2wHrZnesz+ROoh218syC\nAbryHMmhMmESPHjA37Ye1bLFK8FQ8mNAubIQg/jOt+gTJqM2XlAg4VhbNmdNeHs0\n2lwyhVeGrXvqv8EDGd1dCwjyM9K2ntotKPMZ7vNvmG0KhVMOXtzo/LnNYg6CL4EZ\nUzoEkpIV2wROXryrC4pn8SV3jTEgxmOOHGzkLVuVYWbpimfSO9GbC5q2cMbcXzxe\n0l+Y9DEiVX/UL03osyJnrsXr7/aZkCzuqrN5aRjH+6Pg8mAz65dMWiBnThtOuoI=\n=0uZL\n-----END PGP SIGNATURE-----\n", "payload": "tree daf9b5df9e7270d752db6a62abbcad9f962db810\nparent 041f3b64dd0509b87c62ae8b76163127fa488c3e\nparent 8743ce85231d1b889323286aa3c88e0cfbc1a76b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1651269280 +0200\ncommitter GitHub <noreply@github.com> 1651269280 +0200\n\nRollup merge of #96536 - rust-lang:notriddle/deref-slice-core, r=GuillaumeGomez\n\nrustdoc: fix missing method list for primitive deref target\n\nThis change makes it so that local impls count when listing primitives that need retained.\n\nFixes #95325\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b96be79de8cc02483d32d4f503d54a91fcc0a4a", "html_url": "https://github.com/rust-lang/rust/commit/0b96be79de8cc02483d32d4f503d54a91fcc0a4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b96be79de8cc02483d32d4f503d54a91fcc0a4a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "041f3b64dd0509b87c62ae8b76163127fa488c3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/041f3b64dd0509b87c62ae8b76163127fa488c3e", "html_url": "https://github.com/rust-lang/rust/commit/041f3b64dd0509b87c62ae8b76163127fa488c3e"}, {"sha": "8743ce85231d1b889323286aa3c88e0cfbc1a76b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8743ce85231d1b889323286aa3c88e0cfbc1a76b", "html_url": "https://github.com/rust-lang/rust/commit/8743ce85231d1b889323286aa3c88e0cfbc1a76b"}], "stats": {"total": 110, "additions": 72, "deletions": 38}, "files": [{"sha": "9644e3d15fdfadbf366e86f6b6a81a88c466d2c0", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0b96be79de8cc02483d32d4f503d54a91fcc0a4a/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b96be79de8cc02483d32d4f503d54a91fcc0a4a/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=0b96be79de8cc02483d32d4f503d54a91fcc0a4a", "patch": "@@ -33,21 +33,50 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         coll.items\n     };\n \n-    let mut new_items = Vec::new();\n+    let mut new_items_external = Vec::new();\n+    let mut new_items_local = Vec::new();\n \n     // External trait impls.\n     cx.with_all_trait_impls(|cx, all_trait_impls| {\n         let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n         for &impl_def_id in all_trait_impls.iter().skip_while(|def_id| def_id.is_local()) {\n-            inline::build_impl(cx, None, impl_def_id, None, &mut new_items);\n+            inline::build_impl(cx, None, impl_def_id, None, &mut new_items_external);\n+        }\n+    });\n+\n+    // Local trait impls.\n+    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n+        let mut attr_buf = Vec::new();\n+        for &impl_def_id in all_trait_impls.iter().take_while(|def_id| def_id.is_local()) {\n+            let mut parent = cx.tcx.parent(impl_def_id);\n+            while let Some(did) = parent {\n+                attr_buf.extend(\n+                    cx.tcx\n+                        .get_attrs(did)\n+                        .iter()\n+                        .filter(|attr| attr.has_name(sym::doc))\n+                        .filter(|attr| {\n+                            if let Some([attr]) = attr.meta_item_list().as_deref() {\n+                                attr.has_name(sym::cfg)\n+                            } else {\n+                                false\n+                            }\n+                        })\n+                        .cloned(),\n+                );\n+                parent = cx.tcx.parent(did);\n+            }\n+            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items_local);\n+            attr_buf.clear();\n         }\n     });\n \n     cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n         for def_id in PrimitiveType::all_impls(cx.tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n-                inline::build_impl(cx, None, def_id, None, &mut new_items);\n+                inline::build_impl(cx, None, def_id, None, &mut new_items_external);\n             }\n         }\n         for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {\n@@ -57,7 +86,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n             if did.is_local() {\n                 for def_id in prim.impls(cx.tcx) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n-                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.item_id)));\n+                    new_items_external.extend(impls.filter(|i| cx.inlined.insert(i.item_id)));\n                 }\n             }\n         }\n@@ -71,6 +100,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         cx: &DocContext<'_>,\n         map: &FxHashMap<DefId, &Type>,\n         cleaner: &mut BadImplStripper<'_>,\n+        targets: &mut FxHashSet<DefId>,\n         type_did: DefId,\n     ) {\n         if let Some(target) = map.get(&type_did) {\n@@ -79,18 +109,18 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                 cleaner.prims.insert(target_prim);\n             } else if let Some(target_did) = target.def_id(&cx.cache) {\n                 // `impl Deref<Target = S> for S`\n-                if target_did == type_did {\n+                if !targets.insert(target_did) {\n                     // Avoid infinite cycles\n                     return;\n                 }\n                 cleaner.items.insert(target_did.into());\n-                add_deref_target(cx, map, cleaner, target_did);\n+                add_deref_target(cx, map, cleaner, targets, target_did);\n             }\n         }\n     }\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n-    for it in &new_items {\n+    for it in new_items_external.iter().chain(new_items_local.iter()) {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n             if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n                 && cleaner.keep_impl(for_, true)\n@@ -114,15 +144,24 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                         // `Deref` target type and the impl for type positions, this map of types is keyed by\n                         // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n                         if cleaner.keep_impl_with_def_id(for_did.into()) {\n-                            add_deref_target(cx, &type_did_to_deref_target, &mut cleaner, for_did);\n+                            let mut targets = FxHashSet::default();\n+                            targets.insert(for_did);\n+                            add_deref_target(\n+                                cx,\n+                                &type_did_to_deref_target,\n+                                &mut cleaner,\n+                                &mut targets,\n+                                for_did,\n+                            );\n                         }\n                     }\n                 }\n             }\n         }\n     }\n \n-    new_items.retain(|it| {\n+    // Filter out external items that are not needed\n+    new_items_external.retain(|it| {\n         if let ImplItem(Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n             cleaner.keep_impl(\n                 for_,\n@@ -134,37 +173,10 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         }\n     });\n \n-    // Local trait impls.\n-    cx.with_all_trait_impls(|cx, all_trait_impls| {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n-        let mut attr_buf = Vec::new();\n-        for &impl_def_id in all_trait_impls.iter().take_while(|def_id| def_id.is_local()) {\n-            let mut parent = cx.tcx.parent(impl_def_id);\n-            while let Some(did) = parent {\n-                attr_buf.extend(\n-                    cx.tcx\n-                        .get_attrs(did)\n-                        .iter()\n-                        .filter(|attr| attr.has_name(sym::doc))\n-                        .filter(|attr| {\n-                            if let Some([attr]) = attr.meta_item_list().as_deref() {\n-                                attr.has_name(sym::cfg)\n-                            } else {\n-                                false\n-                            }\n-                        })\n-                        .cloned(),\n-                );\n-                parent = cx.tcx.parent(did);\n-            }\n-            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items);\n-            attr_buf.clear();\n-        }\n-    });\n-\n     if let ModuleItem(Module { items, .. }) = &mut *krate.module.kind {\n         items.extend(synth_impls);\n-        items.extend(new_items);\n+        items.extend(new_items_external);\n+        items.extend(new_items_local);\n     } else {\n         panic!(\"collect-trait-impls can't run\");\n     };"}, {"sha": "cccf273a820283afbcd848eb50b8bc7192bc8556", "filename": "src/test/rustdoc/deref-slice-core.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b96be79de8cc02483d32d4f503d54a91fcc0a4a/src%2Ftest%2Frustdoc%2Fderef-slice-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b96be79de8cc02483d32d4f503d54a91fcc0a4a/src%2Ftest%2Frustdoc%2Fderef-slice-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-slice-core.rs?ref=0b96be79de8cc02483d32d4f503d54a91fcc0a4a", "patch": "@@ -0,0 +1,22 @@\n+// https://github.com/rust-lang/rust/issues/95325\n+//\n+// Show methods reachable from Deref of primitive.\n+#![no_std]\n+\n+use core::ops::Deref;\n+\n+// @has 'deref_slice_core/struct.MyArray.html'\n+// @has '-' '//*[@id=\"deref-methods-%5BT%5D\"]' 'Methods from Deref<Target = [T]>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.len\"]' 'pub fn len(&self)'\n+\n+pub struct MyArray<T> {\n+    array: [T; 10],\n+}\n+\n+impl<T> Deref for MyArray<T> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.array\n+    }\n+}"}]}