{"sha": "3826026f98de137adf51d3df88d5c4e40d790cf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MjYwMjZmOThkZTEzN2FkZjUxZDNkZjg4ZDVjNGU0MGQ3OTBjZjA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-07-25T00:01:42Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-08-07T11:54:13Z"}, "message": "rustc: gensym the module names for --test to avoid introducing user-accessible names.\n\nThis requires avoiding `quote_...!` for constructing the parts of the\n__test module, since that stringifies and reinterns the idents, losing\nthe special gensym'd nature of them. (#15962.)", "tree": {"sha": "f3bbd604a6403b734484744df3952e3e4263ccac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3bbd604a6403b734484744df3952e3e4263ccac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3826026f98de137adf51d3df88d5c4e40d790cf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3826026f98de137adf51d3df88d5c4e40d790cf0", "html_url": "https://github.com/rust-lang/rust/commit/3826026f98de137adf51d3df88d5c4e40d790cf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3826026f98de137adf51d3df88d5c4e40d790cf0/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "055e25acbe9fd48e0791c6a97db27a19b4f36b45", "url": "https://api.github.com/repos/rust-lang/rust/commits/055e25acbe9fd48e0791c6a97db27a19b4f36b45", "html_url": "https://github.com/rust-lang/rust/commit/055e25acbe9fd48e0791c6a97db27a19b4f36b45"}], "stats": {"total": 134, "additions": 84, "deletions": 50}, "files": [{"sha": "c2581fb888fdfad9b6cec2905ba04bd4309f9c46", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3826026f98de137adf51d3df88d5c4e40d790cf0/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3826026f98de137adf51d3df88d5c4e40d790cf0/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=3826026f98de137adf51d3df88d5c4e40d790cf0", "patch": "@@ -206,7 +206,7 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate) -> ast::Crate {\n                              }),\n         path: Vec::new(),\n         testfns: Vec::new(),\n-        reexport_mod_ident: token::str_to_ident(\"__test_reexports\"),\n+        reexport_mod_ident: token::gensym_ident(\"__test_reexports\"),\n         is_test_crate: is_test_crate(&krate),\n         config: krate.config.clone(),\n     };\n@@ -384,7 +384,7 @@ fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n     let item_ = ast::ItemMod(testmod);\n \n     let item = ast::Item {\n-        ident: token::str_to_ident(\"__test\"),\n+        ident: token::gensym_ident(\"__test\"),\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n@@ -417,11 +417,27 @@ fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n-    (quote_item!(&cx.ext_cx,\n-        pub static TESTS : &'static [self::test::TestDescAndFn] =\n-            $test_descs\n-        ;\n-    )).unwrap()\n+    // FIXME #15962: should be using quote_item, but that stringifies\n+    // __test_reexports, causing it to be reinterned, losing the\n+    // gensym information.\n+    let sp = DUMMY_SP;\n+    let ecx = &cx.ext_cx;\n+    let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n+                                                    ecx.ident_of(\"test\"),\n+                                                    ecx.ident_of(\"TestDescAndFn\")]),\n+                                  None);\n+    let static_lt = ecx.lifetime(sp, token::special_idents::static_lifetime.name);\n+    // &'static [self::test::TestDescAndFn]\n+    let static_type = ecx.ty_rptr(sp,\n+                                  ecx.ty(sp, ast::TyVec(struct_type)),\n+                                  Some(static_lt),\n+                                  ast::MutImmutable);\n+    // static TESTS: $static_type = &[...];\n+    ecx.item_static(sp,\n+                    ecx.ident_of(\"TESTS\"),\n+                    static_type,\n+                    ast::MutImmutable,\n+                    test_descs)\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n@@ -448,59 +464,58 @@ fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n }\n \n fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n+    // FIXME #15962: should be using quote_expr, but that stringifies\n+    // __test_reexports, causing it to be reinterned, losing the\n+    // gensym information.\n+\n     let span = test.span;\n     let path = test.path.clone();\n+    let ecx = &cx.ext_cx;\n+    let self_id = ecx.ident_of(\"self\");\n+    let test_id = ecx.ident_of(\"test\");\n+\n+    // creates self::test::$name\n+    let test_path = |name| {\n+        ecx.path(span, vec![self_id, test_id, ecx.ident_of(name)])\n+    };\n+    // creates $name: $expr\n+    let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n     debug!(\"encoding {}\", ast_util::path_name_i(path.as_slice()));\n \n-    let name_lit: ast::Lit =\n-        nospan(ast::LitStr(token::intern_and_get_ident(\n-                    ast_util::path_name_i(path.as_slice()).as_slice()),\n-                    ast::CookedStr));\n+    // path to the #[test] function: \"foo::bar::baz\"\n+    let path_string = ast_util::path_name_i(path.as_slice());\n+    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(path_string.as_slice()));\n \n-    let name_expr = box(GC) ast::Expr {\n-          id: ast::DUMMY_NODE_ID,\n-          node: ast::ExprLit(box(GC) name_lit),\n-          span: span\n-    };\n+    // self::test::StaticTestName($name_expr)\n+    let name_expr = ecx.expr_call(span,\n+                                  ecx.expr_path(test_path(\"StaticTestName\")),\n+                                  vec![name_expr]);\n \n-    let mut visible_path = vec![cx.reexport_mod_ident.clone()];\n-    visible_path.extend(path.move_iter());\n-    let fn_path = cx.ext_cx.path_global(DUMMY_SP, visible_path);\n+    let ignore_expr = ecx.expr_bool(span, test.ignore);\n+    let fail_expr = ecx.expr_bool(span, test.should_fail);\n \n-    let fn_expr = box(GC) ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprPath(fn_path),\n-        span: span,\n-    };\n+    // self::test::TestDesc { ... }\n+    let desc_expr = ecx.expr_struct(\n+        span,\n+        test_path(\"TestDesc\"),\n+        vec![field(\"name\", name_expr),\n+             field(\"ignore\", ignore_expr),\n+             field(\"should_fail\", fail_expr)]);\n \n-    let t_expr = if test.bench {\n-        quote_expr!(&cx.ext_cx, self::test::StaticBenchFn($fn_expr) )\n-    } else {\n-        quote_expr!(&cx.ext_cx, self::test::StaticTestFn($fn_expr) )\n-    };\n \n-    let ignore_expr = if test.ignore {\n-        quote_expr!(&cx.ext_cx, true )\n-    } else {\n-        quote_expr!(&cx.ext_cx, false )\n-    };\n+    let mut visible_path = vec![cx.reexport_mod_ident.clone()];\n+    visible_path.extend(path.move_iter());\n \n-    let fail_expr = if test.should_fail {\n-        quote_expr!(&cx.ext_cx, true )\n-    } else {\n-        quote_expr!(&cx.ext_cx, false )\n-    };\n+    let fn_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n \n-    let e = quote_expr!(&cx.ext_cx,\n-        self::test::TestDescAndFn {\n-            desc: self::test::TestDesc {\n-                name: self::test::StaticTestName($name_expr),\n-                ignore: $ignore_expr,\n-                should_fail: $fail_expr\n-            },\n-            testfn: $t_expr,\n-        }\n-    );\n-    e\n+    let variant_name = if test.bench { \"StaticBenchFn\" } else { \"StaticTestFn\" };\n+    // self::test::$variant_name($fn_expr)\n+    let testfn_expr = ecx.expr_call(span, ecx.expr_path(test_path(variant_name)), vec![fn_expr]);\n+\n+    // self::test::TestDescAndFn { ... }\n+    ecx.expr_struct(span,\n+                    test_path(\"TestDescAndFn\"),\n+                    vec![field(\"desc\", desc_expr),\n+                         field(\"testfn\", testfn_expr)])\n }"}, {"sha": "b646f8083b8d5590286cf99672a9fb1db7d5a060", "filename": "src/test/compile-fail/inaccessible-test-modules.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3826026f98de137adf51d3df88d5c4e40d790cf0/src%2Ftest%2Fcompile-fail%2Finaccessible-test-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3826026f98de137adf51d3df88d5c4e40d790cf0/src%2Ftest%2Fcompile-fail%2Finaccessible-test-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finaccessible-test-modules.rs?ref=3826026f98de137adf51d3df88d5c4e40d790cf0", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+\n+// the `--test` harness creates modules with these textual names, but\n+// they should be inaccessible from normal code.\n+use x = __test; //~ ERROR unresolved import `__test`\n+use y = __test_reexports; //~ ERROR unresolved import `__test_reexports`\n+\n+#[test]\n+fn baz() {}"}]}