{"sha": "30317050092cc7a469f0815d40d400a812749564", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMzE3MDUwMDkyY2M3YTQ2OWYwODE1ZDQwZDQwMGE4MTI3NDk1NjQ=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-14T08:44:12Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-14T08:44:12Z"}, "message": "some more refactor of FnType. Things build now", "tree": {"sha": "2584d3d385f4520b3f88b762f8ab6f6c679802c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2584d3d385f4520b3f88b762f8ab6f6c679802c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30317050092cc7a469f0815d40d400a812749564", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30317050092cc7a469f0815d40d400a812749564", "html_url": "https://github.com/rust-lang/rust/commit/30317050092cc7a469f0815d40d400a812749564", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30317050092cc7a469f0815d40d400a812749564/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11426a4d502cac062773071cf7fd320a383564ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/11426a4d502cac062773071cf7fd320a383564ff", "html_url": "https://github.com/rust-lang/rust/commit/11426a4d502cac062773071cf7fd320a383564ff"}], "stats": {"total": 493, "additions": 409, "deletions": 84}, "files": [{"sha": "6d7b0926c7ae26527fbb131fbec4f251104bbc04", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 110, "deletions": 76, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=30317050092cc7a469f0815d40d400a812749564", "patch": "@@ -19,9 +19,9 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n pub use rustc_target::abi::*;\n-use rustc_target::spec::HasTargetSpec;\n+use rustc_target::spec::{HasTargetSpec, abi::Abi as SpecAbi};\n use rustc_target::abi::call::{\n-    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode\n+    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode, Reg, RegKind\n };\n \n \n@@ -2266,81 +2266,48 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n     }\n }\n \n-pub trait FnTypeExt<'tcx, C> {\n-    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>;\n-    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>;\n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>;\n+pub trait FnTypeExt<'tcx, C>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+        + HasDataLayout\n+        + HasTargetSpec\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n+{\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self;\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n     fn new_internal(\n         cx: &C,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>;\n+    ) -> Self;\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n \n-\n-impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>,\n-    {\n+impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+        + HasDataLayout\n+        + HasTargetSpec\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n+{\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self {\n         let sig = instance.fn_sig(cx.tcx());\n         let sig = cx\n             .tcx()\n             .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         call::FnType::new(cx, sig, &[])\n     }\n \n-    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>,\n-    {\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n         call::FnType::new_internal(cx, sig, extra_args, |ty, _| ArgType::new(cx.layout_of(ty)))\n     }\n \n-\n-    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>,\n-    {\n-        FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        FnTypeExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n             // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n@@ -2395,19 +2362,11 @@ impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>> {\n     }\n \n     fn new_internal(\n-    cx: &C,\n-    sig: ty::FnSig<'tcx>,\n-    extra_args: &[Ty<'tcx>],\n-    mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self\n-    where\n-        C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n-            + HasDataLayout\n-            + HasTargetSpec\n-            + HasTargetSpec\n-            + HasTyCtxt<'tcx>\n-            + HasParamEnv<'tcx>,\n-    {\n+        cx: &C,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self {\n         debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n \n         use rustc_target::spec::abi::Abi::*;\n@@ -2591,7 +2550,7 @@ impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>> {\n             arg\n         };\n \n-        let fn_ty = FnType {\n+        let mut fn_ty = FnType {\n             ret: arg_of(sig.output(), None),\n             args: inputs\n                 .iter()\n@@ -2603,8 +2562,83 @@ impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>> {\n             c_variadic: sig.c_variadic,\n             conv,\n         };\n-        // FIXME: uncomment this after figuring out wwhere should adjust_for_abi reside.\n-        //fn_ty.adjust_for_abi(cx, sig.abi);\n+        fn_ty.adjust_for_abi(cx, sig.abi);\n         fn_ty\n     }\n+\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) {\n+        if abi == SpecAbi::Unadjusted {\n+            return;\n+        }\n+\n+        if abi == SpecAbi::Rust\n+            || abi == SpecAbi::RustCall\n+            || abi == SpecAbi::RustIntrinsic\n+            || abi == SpecAbi::PlatformIntrinsic\n+        {\n+            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n+                if arg.is_ignore() {\n+                    return;\n+                }\n+\n+                match arg.layout.abi {\n+                    Abi::Aggregate { .. } => {}\n+\n+                    // This is a fun case! The gist of what this is doing is\n+                    // that we want callers and callees to always agree on the\n+                    // ABI of how they pass SIMD arguments. If we were to *not*\n+                    // make these arguments indirect then they'd be immediates\n+                    // in LLVM, which means that they'd used whatever the\n+                    // appropriate ABI is for the callee and the caller. That\n+                    // means, for example, if the caller doesn't have AVX\n+                    // enabled but the callee does, then passing an AVX argument\n+                    // across this boundary would cause corrupt data to show up.\n+                    //\n+                    // This problem is fixed by unconditionally passing SIMD\n+                    // arguments through memory between callers and callees\n+                    // which should get them all to agree on ABI regardless of\n+                    // target feature sets. Some more information about this\n+                    // issue can be found in #44367.\n+                    //\n+                    // Note that the platform intrinsic ABI is exempt here as\n+                    // that's how we connect up to LLVM and it's unstable\n+                    // anyway, we control all calls to it in libstd.\n+                    Abi::Vector { .. }\n+                        if abi != SpecAbi::PlatformIntrinsic\n+                            && cx.tcx().sess.target.target.options.simd_types_indirect =>\n+                    {\n+                        arg.make_indirect();\n+                        return;\n+                    }\n+\n+                    _ => return,\n+                }\n+\n+                let size = arg.layout.size;\n+                if arg.layout.is_unsized() || size > Pointer.size(cx) {\n+                    arg.make_indirect();\n+                } else {\n+                    // We want to pass small aggregates as immediates, but using\n+                    // a LLVM aggregate type for this leads to bad optimizations,\n+                    // so we pick an appropriately sized integer type instead.\n+                    arg.cast_to(Reg {\n+                        kind: RegKind::Integer,\n+                        size,\n+                    });\n+                }\n+            };\n+            fixup(&mut self.ret);\n+            for arg in &mut self.args {\n+                fixup(arg);\n+            }\n+            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n+                attrs.set(ArgAttribute::StructRet);\n+            }\n+            return;\n+        }\n+\n+        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n+            cx.tcx().sess.fatal(&msg);\n+        }\n+    }\n }"}, {"sha": "00e17ff990d95f3f9230c8f45f277afc8f330a9f", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 294, "deletions": 3, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=30317050092cc7a469f0815d40d400a812749564", "patch": "@@ -295,6 +295,19 @@ impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n }\n \n pub trait FnTypeExt<'tcx> {\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n+    fn new(cx: &CodegenCx<'ll, 'tcx>,\n+           sig: ty::FnSig<'tcx>,\n+           extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n+                  sig: ty::FnSig<'tcx>,\n+                  extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_internal(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self;\n     fn adjust_for_abi(&mut self,\n                       cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi);\n@@ -306,6 +319,284 @@ pub trait FnTypeExt<'tcx> {\n }\n \n impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n+    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self {\n+        let sig = instance.fn_sig(cx.tcx);\n+        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        FnTypeExt::new(cx, sig, &[])\n+    }\n+\n+    fn new(cx: &CodegenCx<'ll, 'tcx>,\n+           sig: ty::FnSig<'tcx>,\n+           extra_args: &[Ty<'tcx>]) -> Self {\n+        FnTypeExt::new_internal(cx, sig, extra_args, |ty, _| {\n+            ArgType::new(cx.layout_of(ty))\n+        })\n+    }\n+\n+    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n+                  sig: ty::FnSig<'tcx>,\n+                  extra_args: &[Ty<'tcx>]) -> Self {\n+        FnTypeExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+            let mut layout = cx.layout_of(ty);\n+            // Don't pass the vtable, it's not an argument of the virtual fn.\n+            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n+            if arg_idx == Some(0) {\n+                let fat_pointer_ty = if layout.is_unsized() {\n+                    // unsized `self` is passed as a pointer to `self`\n+                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+                    cx.tcx.mk_mut_ptr(layout.ty)\n+                } else {\n+                    match layout.abi {\n+                        LayoutAbi::ScalarPair(..) => (),\n+                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout)\n+                    }\n+\n+                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+                    // elsewhere in the compiler as a method on a `dyn Trait`.\n+                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+                    // get a built-in pointer type\n+                    let mut fat_pointer_layout = layout;\n+                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+                        && !fat_pointer_layout.ty.is_region_ptr()\n+                    {\n+                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n+                            let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                            if !field_layout.is_zst() {\n+                                fat_pointer_layout = field_layout;\n+                                continue 'descend_newtypes\n+                            }\n+                        }\n+\n+                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n+                    }\n+\n+                    fat_pointer_layout.ty\n+                };\n+\n+                // we now have a type like `*mut RcBox<dyn Trait>`\n+                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+                // this is understood as a special case elsewhere in the compiler\n+                let unit_pointer_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_unit());\n+                layout = cx.layout_of(unit_pointer_ty);\n+                layout.ty = fat_pointer_ty;\n+            }\n+            ArgType::new(layout)\n+        })\n+    }\n+\n+    fn new_internal(\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self {\n+        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n+\n+        use self::Abi::*;\n+        let conv = match cx.sess().target.target.adjust_abi(sig.abi) {\n+            RustIntrinsic | PlatformIntrinsic |\n+            Rust | RustCall => Conv::C,\n+\n+            // It's the ABI's job to select this, not ours.\n+            System => bug!(\"system abi should be selected elsewhere\"),\n+\n+            Stdcall => Conv::X86Stdcall,\n+            Fastcall => Conv::X86Fastcall,\n+            Vectorcall => Conv::X86VectorCall,\n+            Thiscall => Conv::X86ThisCall,\n+            C => Conv::C,\n+            Unadjusted => Conv::C,\n+            Win64 => Conv::X86_64Win64,\n+            SysV64 => Conv::X86_64SysV,\n+            Aapcs => Conv::ArmAapcs,\n+            PtxKernel => Conv::PtxKernel,\n+            Msp430Interrupt => Conv::Msp430Intr,\n+            X86Interrupt => Conv::X86Intr,\n+            AmdGpuKernel => Conv::AmdGpuKernel,\n+\n+            // These API constants ought to be more specific...\n+            Cdecl => Conv::C,\n+        };\n+\n+        let mut inputs = sig.inputs();\n+        let extra_args = if sig.abi == RustCall {\n+            assert!(!sig.c_variadic && extra_args.is_empty());\n+\n+            match sig.inputs().last().unwrap().sty {\n+                ty::Tuple(tupled_arguments) => {\n+                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n+                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n+                }\n+                _ => {\n+                    bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n+                          is not a tuple\");\n+                }\n+            }\n+        } else {\n+            assert!(sig.c_variadic || extra_args.is_empty());\n+            extra_args.to_vec()\n+        };\n+\n+        let target = &cx.sess().target.target;\n+        let win_x64_gnu = target.target_os == \"windows\"\n+                       && target.arch == \"x86_64\"\n+                       && target.target_env == \"gnu\";\n+        let linux_s390x = target.target_os == \"linux\"\n+                       && target.arch == \"s390x\"\n+                       && target.target_env == \"gnu\";\n+        let linux_sparc64 = target.target_os == \"linux\"\n+                       && target.arch == \"sparc64\"\n+                       && target.target_env == \"gnu\";\n+        let rust_abi = match sig.abi {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n+            _ => false\n+        };\n+\n+        // Handle safe Rust thin and fat pointers.\n+        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n+                                      scalar: &layout::Scalar,\n+                                      layout: TyLayout<'tcx, Ty<'tcx>>,\n+                                      offset: Size,\n+                                      is_return: bool| {\n+            // Booleans are always an i1 that needs to be zero-extended.\n+            if scalar.is_bool() {\n+                attrs.set(ArgAttribute::ZExt);\n+                return;\n+            }\n+\n+            // Only pointer types handled below.\n+            if scalar.value != layout::Pointer {\n+                return;\n+            }\n+\n+            if scalar.valid_range.start() < scalar.valid_range.end() {\n+                if *scalar.valid_range.start() > 0 {\n+                    attrs.set(ArgAttribute::NonNull);\n+                }\n+            }\n+\n+            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n+                if let Some(kind) = pointee.safe {\n+                    attrs.pointee_size = pointee.size;\n+                    attrs.pointee_align = Some(pointee.align);\n+\n+                    // `Box` pointer parameters never alias because ownership is transferred\n+                    // `&mut` pointer parameters never alias other parameters,\n+                    // or mutable global data\n+                    //\n+                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+                    // and can be marked as both `readonly` and `noalias`, as\n+                    // LLVM's definition of `noalias` is based solely on memory\n+                    // dependencies rather than pointer equality\n+                    let no_alias = match kind {\n+                        PointerKind::Shared => false,\n+                        PointerKind::UniqueOwned => true,\n+                        PointerKind::Frozen |\n+                        PointerKind::UniqueBorrowed => !is_return\n+                    };\n+                    if no_alias {\n+                        attrs.set(ArgAttribute::NoAlias);\n+                    }\n+\n+                    if kind == PointerKind::Frozen && !is_return {\n+                        attrs.set(ArgAttribute::ReadOnly);\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Store the index of the last argument. This is useful for working with\n+        // C-compatible variadic arguments.\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+\n+        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n+            let is_return = arg_idx.is_none();\n+            let mut arg = mk_arg_type(ty, arg_idx);\n+            if arg.layout.is_zst() {\n+                // For some forsaken reason, x86_64-pc-windows-gnu\n+                // doesn't ignore zero-sized struct arguments.\n+                // The same is true for s390x-unknown-linux-gnu\n+                // and sparc64-unknown-linux-gnu.\n+                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n+                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n+                }\n+            }\n+\n+            // If this is a C-variadic function, this is not the return value,\n+            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // is ignored as an argument.\n+            if sig.c_variadic {\n+                match (last_arg_idx, arg_idx) {\n+                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n+                        let va_list_did = match cx.tcx.lang_items().va_list() {\n+                            Some(did) => did,\n+                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n+                        };\n+                        match ty.sty {\n+                            ty::Adt(def, _) if def.did == va_list_did => {\n+                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // so that it will be ignored.\n+                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n+                            },\n+                            _ => (),\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n+            if !is_return && rust_abi {\n+                if let layout::Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n+                    let mut a_attrs = ArgAttributes::new();\n+                    let mut b_attrs = ArgAttributes::new();\n+                    adjust_for_rust_scalar(&mut a_attrs,\n+                                           a,\n+                                           arg.layout,\n+                                           Size::ZERO,\n+                                           false);\n+                    adjust_for_rust_scalar(&mut b_attrs,\n+                                           b,\n+                                           arg.layout,\n+                                           a.value.size(cx).align_to(b.value.align(cx).abi),\n+                                           false);\n+                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n+                    return arg;\n+                }\n+            }\n+\n+            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    adjust_for_rust_scalar(attrs,\n+                                           scalar,\n+                                           arg.layout,\n+                                           Size::ZERO,\n+                                           is_return);\n+                }\n+            }\n+\n+            arg\n+        };\n+\n+        let mut fn_ty = FnType {\n+            ret: arg_of(sig.output(), None),\n+            args: inputs.iter().cloned().chain(extra_args).enumerate().map(|(i, ty)| {\n+                arg_of(ty, Some(i))\n+            }).collect(),\n+            c_variadic: sig.c_variadic,\n+            conv,\n+        };\n+        FnTypeExt::adjust_for_abi(&mut fn_ty, cx, sig.abi);\n+        fn_ty\n+    }\n+\n     fn adjust_for_abi(&mut self,\n                       cx: &CodegenCx<'ll, 'tcx>,\n                       abi: Abi) {\n@@ -547,17 +838,17 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n \n impl AbiMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn new_fn_type(&self, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::new(&self, sig, extra_args)\n+        FnTypeExt::new(&self, sig, extra_args)\n     }\n     fn new_vtable(\n         &self,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>]\n     ) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::new_vtable(&self, sig, extra_args)\n+        FnTypeExt::new_vtable(&self, sig, extra_args)\n     }\n     fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::of_instance(&self, instance)\n+        FnTypeExt::of_instance(&self, instance)\n     }\n }\n "}, {"sha": "6b8a45da1803fd6ce3bea9f8c3a16ac266107661", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=30317050092cc7a469f0815d40d400a812749564", "patch": "@@ -18,8 +18,8 @@ use crate::attributes;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::value::Value;\n-use rustc::ty::{self, PolyFnSig};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::{self, PolyFnSig, Ty};\n+use rustc::ty::layout::{FnTypeExt as FnTypeExt1, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;\n@@ -100,7 +100,7 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let sig = self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-        let fty = FnType::new(self, sig, &[]);\n+        let fty: FnType<'tcx, Ty<'tcx>> = FnTypeExt1::new(self, sig, &[]);\n         let llfn = declare_raw_fn(self, name, fty.llvm_cconv(), fty.llvm_type(self));\n \n         if self.layout_of(sig.output()).abi.is_uninhabited() {"}, {"sha": "800bf505125d677842d88e8023848b91edb342fa", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30317050092cc7a469f0815d40d400a812749564/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=30317050092cc7a469f0815d40d400a812749564", "patch": "@@ -1,8 +1,8 @@\n-use crate::abi::{FnType, FnTypeExt};\n+use crate::abi::{FnType};\n use crate::common::*;\n use crate::type_::Type;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutOf, PointeeInfo, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, FnTypeExt, PointeeInfo, Size, TyLayout};\n use rustc_target::abi::{FloatTy, TyLayoutMethods};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;"}]}