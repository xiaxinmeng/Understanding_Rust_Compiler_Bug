{"sha": "0c3a128419e2b75be1fa6de6ff92d32fba11e005", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjM2ExMjg0MTllMmI3NWJlMWZhNmRlNmZmOTJkMzJmYmExMWUwMDU=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-26T00:45:50Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-26T01:32:18Z"}, "message": "Update word-count-generic to latest syntax and un-xfail it. Closes #1740.", "tree": {"sha": "0f44b2260e269b3d745567a855f0ccab7c646117", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f44b2260e269b3d745567a855f0ccab7c646117"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c3a128419e2b75be1fa6de6ff92d32fba11e005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3a128419e2b75be1fa6de6ff92d32fba11e005", "html_url": "https://github.com/rust-lang/rust/commit/0c3a128419e2b75be1fa6de6ff92d32fba11e005", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c3a128419e2b75be1fa6de6ff92d32fba11e005/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e11742de323bd3cfc2c9488e180739cc17040a19", "url": "https://api.github.com/repos/rust-lang/rust/commits/e11742de323bd3cfc2c9488e180739cc17040a19", "html_url": "https://github.com/rust-lang/rust/commit/e11742de323bd3cfc2c9488e180739cc17040a19"}], "stats": {"total": 128, "additions": 76, "deletions": 52}, "files": [{"sha": "f41629a00dbcd957867968cdfa63e3ba36f12c57", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 76, "deletions": 52, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0c3a128419e2b75be1fa6de6ff92d32fba11e005/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3a128419e2b75be1fa6de6ff92d32fba11e005/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=0c3a128419e2b75be1fa6de6ff92d32fba11e005", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test - #1038 - Can't do this safely with bare functions\n-\n /**\n    A parallel word-frequency counting program.\n \n@@ -18,21 +16,41 @@ import option::none;\n import str;\n import std::treemap;\n import vec;\n-import std::io;\n+import io;\n+import io::{reader_util, writer_util};\n \n import std::time;\n import u64;\n \n import task;\n-import task::joinable_task;\n import comm;\n import comm::chan;\n import comm::port;\n import comm::recv;\n import comm::send;\n+import comm::methods;\n+\n+// These used to be in task, but they disappeard.\n+type joinable_task = port<()>;\n+fn spawn_joinable(f: fn~()) -> joinable_task {\n+    let p = port();\n+    let c = chan(p);\n+    task::spawn() {||\n+        f();\n+        c.send(());\n+    }\n+    p\n+}\n+\n+fn join(t: joinable_task) {\n+    t.recv()\n+}\n \n fn map(&&filename: [u8], emit: map_reduce::putter<[u8], int>) {\n-    let f = io::file_reader(str::from_bytes(filename));\n+    let f = alt io::file_reader(str::from_bytes(filename)) {\n+      result::ok(f) { f }\n+      result::err(e) { fail #fmt(\"%?\", e) }\n+    };\n \n     loop {\n         alt read_word(f) {\n@@ -42,10 +60,12 @@ fn map(&&filename: [u8], emit: map_reduce::putter<[u8], int>) {\n     }\n }\n \n-fn reduce(&&_word: [u8], get: map_reduce::getter<int>) {\n-    let count = 0;\n+fn reduce(&&word: [u8], get: map_reduce::getter<int>) {\n+    let mut count = 0;\n \n     loop { alt get() { some(_) { count += 1; } none { break; } } }\n+    \n+    io::println(#fmt(\"%?\\t%?\", word, count));\n }\n \n mod map_reduce {\n@@ -59,41 +79,43 @@ mod map_reduce {\n \n     // FIXME: the first K1 parameter should probably be a -, but that\n     // doesn't parse at the moment.\n-    type mapper<K1: send, K2: send, V: send> = fn(K1, putter<K2, V>);\n+    type mapper<K1: send, K2: send, V: send> = fn~(K1, putter<K2, V>);\n \n     type getter<V: send> = fn() -> option<V>;\n \n-    type reducer<K: send, V: send> = fn(K, getter<V>);\n+    type reducer<K: copy send, V: copy send> = fn~(K, getter<V>);\n \n-    enum ctrl_proto<K: send, V: send> {\n-        find_reducer(K, chan<chan<reduce_proto<V>>>);\n-        mapper_done;\n+    enum ctrl_proto<K: copy send, V: copy send> {\n+        find_reducer(K, chan<chan<reduce_proto<V>>>),\n+        mapper_done\n     }\n \n-    enum reduce_proto<V: send> { emit_val(V); done; ref; release; }\n+    enum reduce_proto<V: copy send> { emit_val(V), done, ref, release }\n \n-    fn start_mappers<K1: send, K2: send,\n-                     V: send>(map: mapper<K1, K2, V>,\n-                         ctrl: chan<ctrl_proto<K2, V>>, inputs: [K1]) ->\n-       [joinable_task] {\n-        let tasks = [];\n+    fn start_mappers<K1: copy send, K2: copy send, V: copy send>(\n+        map: mapper<K1, K2, V>,\n+        ctrl: chan<ctrl_proto<K2, V>>, inputs: [K1])\n+        -> [joinable_task]\n+    {\n+        let mut tasks = [];\n         for inputs.each {|i|\n-            let m = map, c = ctrl, ii = i;\n-            tasks += [task::spawn_joinable {|| map_task(m, c, ii)}];\n+            tasks += [spawn_joinable {|| map_task(map, ctrl, i)}];\n         }\n         ret tasks;\n     }\n \n-    fn map_task<K: send1, K: send2,\n-                V: send>(-map: mapper<K1, K2, V>,\n-                          -ctrl: chan<ctrl_proto<K2, V>>,\n-                    -input: K1) {\n+    fn map_task<K1: copy send, K2: copy send, V: copy send>(\n+        map: mapper<K1, K2, V>,\n+        ctrl: chan<ctrl_proto<K2, V>>,\n+        input: K1)\n+    {\n         // log(error, \"map_task \" + input);\n-        let intermediates = treemap::init();\n+        let intermediates = treemap::treemap();\n \n-        fn emit<K: send2,\n-                V: send>(im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n-                    ctrl: chan<ctrl_proto<K2, V>>, key: K2, val: V) {\n+        fn emit<K2: copy send, V: copy send>(\n+            im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n+            ctrl: chan<ctrl_proto<K2, V>>, key: K2, val: V)\n+        {\n             let c;\n             alt treemap::find(im, key) {\n               some(_c) { c = _c; }\n@@ -110,25 +132,28 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        fn finish<K: send, V: send>(_k: K, v: chan<reduce_proto<V>>) {\n+        fn finish<K: copy send, V: copy send>(_k: K, v: chan<reduce_proto<V>>)\n+        {\n             send(v, release);\n         }\n         treemap::traverse(intermediates, finish);\n         send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task<K: send,\n-                   V: send>(-reduce: reducer<K, V>, -key: K,\n-                       -out: chan<chan<reduce_proto<V>>>) {\n+    fn reduce_task<K: copy send, V: copy send>(\n+        reduce: reducer<K, V>, \n+        key: K,\n+        out: chan<chan<reduce_proto<V>>>)\n+    {\n         let p = port();\n \n         send(out, chan(p));\n \n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get<V: send>(p: port<reduce_proto<V>>,\n-                         &ref_count: int, &is_done: bool)\n+        fn get<V: copy send>(p: port<reduce_proto<V>>,\n+                             &ref_count: int, &is_done: bool)\n            -> option<V> {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n@@ -140,8 +165,8 @@ mod map_reduce {\n                     // #error(\"all done\");\n                     is_done = true;\n                   }\n-                  ref. { ref_count += 1; }\n-                  release. { ref_count -= 1; }\n+                  ref { ref_count += 1; }\n+                  release { ref_count -= 1; }\n                 }\n             }\n             ret none;\n@@ -150,19 +175,19 @@ mod map_reduce {\n         reduce(key, bind get(p, ref_count, is_done));\n     }\n \n-    fn map_reduce<K: send1, K: send2,\n-                  V: send>(map: mapper<K1, K2, V>, reduce: reducer<K2, V>,\n-                      inputs: [K1]) {\n+    fn map_reduce<K1: copy send, K2: copy send, V: copy send>(\n+        map: mapper<K1, K2, V>,\n+        reduce: reducer<K2, V>,\n+        inputs: [K1])\n+    {\n         let ctrl = port();\n \n         // This task becomes the master control task. It task::_spawns\n         // to do the rest.\n \n-        let reducers = treemap::init();\n-\n-        let tasks = start_mappers(map, chan(ctrl), inputs);\n-\n-        let num_mappers = vec::len(inputs) as int;\n+        let reducers = treemap::treemap();\n+        let mut tasks = start_mappers(map, chan(ctrl), inputs);\n+        let mut num_mappers = vec::len(inputs) as int;\n \n         while num_mappers > 0 {\n             alt recv(ctrl) {\n@@ -185,7 +210,7 @@ mod map_reduce {\n                     let ch = chan(p);\n                     let r = reduce, kk = k;\n                     tasks += [\n-                        task::spawn_joinable {|| reduce_task(r, kk, ch) }\n+                        spawn_joinable {|| reduce_task(r, kk, ch) }\n                     ];\n                     c = recv(p);\n                     treemap::insert(reducers, k, c);\n@@ -196,12 +221,13 @@ mod map_reduce {\n             }\n         }\n \n-        fn finish<K: send, V: send>(_k: K, v: chan<reduce_proto<V>>) {\n+        fn finish<K: copy send, V: copy send>(_k: K, v: chan<reduce_proto<V>>)\n+        {\n             send(v, done);\n         }\n         treemap::traverse(reducers, finish);\n \n-        for tasks.each {|t| task::join(t); }\n+        for tasks.each {|t| join(t); }\n     }\n }\n \n@@ -217,7 +243,7 @@ fn main(argv: [str]) {\n         ret;\n     }\n \n-    let iargs = [];\n+    let mut iargs = [];\n     vec::iter_between(argv, 1u, vec::len(argv)) {|a|\n         iargs += [str::bytes(a)];\n     }\n@@ -227,20 +253,18 @@ fn main(argv: [str]) {\n     map_reduce::map_reduce(map, reduce, iargs);\n     let stop = time::precise_time_ns();\n \n-    let elapsed = stop - start;\n-    elapsed /= 1000000u64;\n+    let elapsed = (stop - start) / 1000000u64;\n \n     log(error, \"MapReduce completed in \"\n              + u64::str(elapsed) + \"ms\");\n }\n \n fn read_word(r: io::reader) -> option<str> {\n-    let w = \"\";\n+    let mut w = \"\";\n \n     while !r.eof() {\n         let c = r.read_char();\n \n-\n         if is_word_char(c) {\n             w += str::from_char(c);\n         } else { if w != \"\" { ret some(w); } }"}]}