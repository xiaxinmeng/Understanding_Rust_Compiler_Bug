{"sha": "a9bb599fb14fab9a9acee13c590b11a47c392cf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YmI1OTlmYjE0ZmFiOWE5YWNlZTEzYzU5MGIxMWE0N2MzOTJjZjY=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-08-23T21:38:45Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-09-02T01:21:29Z"}, "message": "powerpc64: improve extern struct ABI\n\nThese fixes all have to do with the 64-bit PowerPC ELF ABI for big-endian\ntargets.  The ELF v2 ABI for powerpc64le already worked well.\n\n- Return after marking return aggregates indirect. Fixes #42757.\n- Pass one-member float aggregates as direct argument values.\n- Aggregate arguments less than 64-bit must be written in the least-\n  significant bits of the parameter space.\n- Larger aggregates are instead padded at the tail.\n  (i.e. filling MSBs, padding the remaining LSBs.)\n\nNew tests were also added for the single-float aggregate, and a 3-byte\naggregate to check that it's filled into LSBs.  Overall, at least these\nformerly-failing tests now pass on powerpc64:\n\n- run-make/extern-fn-struct-passing-abi\n- run-make/extern-fn-with-packed-struct\n- run-pass/extern-pass-TwoU16s.rs\n- run-pass/extern-pass-TwoU8s.rs\n- run-pass/struct-return.rs", "tree": {"sha": "ef67f8dcbfb516516472802cabc7d81aed5b0c28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef67f8dcbfb516516472802cabc7d81aed5b0c28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9bb599fb14fab9a9acee13c590b11a47c392cf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bb599fb14fab9a9acee13c590b11a47c392cf6", "html_url": "https://github.com/rust-lang/rust/commit/a9bb599fb14fab9a9acee13c590b11a47c392cf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9bb599fb14fab9a9acee13c590b11a47c392cf6/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f861b6ee46465097eec266c160ac53e230df7cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f861b6ee46465097eec266c160ac53e230df7cf0", "html_url": "https://github.com/rust-lang/rust/commit/f861b6ee46465097eec266c160ac53e230df7cf0"}], "stats": {"total": 149, "additions": 111, "deletions": 38}, "files": [{"sha": "fb5472eb6ae1fa3bb154efa6583329ca08945d7e", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=a9bb599fb14fab9a9acee13c590b11a47c392cf6", "patch": "@@ -14,14 +14,26 @@\n \n use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n+use rustc::ty::layout;\n \n-fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+enum ABI {\n+    ELFv1, // original ABI used for powerpc64 (big-endian)\n+    ELFv2, // newer ABI used for powerpc64le\n+}\n+use self::ABI::*;\n+\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                      arg: &mut ArgType<'tcx>,\n+                                      abi: ABI)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n         let size = arg.layout.size(ccx);\n \n-        // Ensure we have at most eight uniquely addressable members.\n-        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+        // ELFv1 only passes one-member aggregates transparently.\n+        // ELFv2 passes up to eight uniquely addressable members.\n+        if (abi == ELFv1 && size > unit.size)\n+                || size > unit.size.checked_mul(8, ccx).unwrap() {\n             return None;\n         }\n \n@@ -42,21 +54,23 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut Ar\n     })\n }\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>, abi: ABI) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n \n-    // The PowerPC64 big endian ABI doesn't return aggregates in registers\n-    if ccx.sess().target.target.target_endian == \"big\" {\n+    // The ELFv1 ABI doesn't return aggregates in registers\n+    if abi == ELFv1 {\n         ret.make_indirect(ccx);\n+        return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, ret, abi) {\n         ret.cast_to(ccx, uniform);\n         return;\n     }\n+\n     let size = ret.layout.size(ccx);\n     let bits = size.bits();\n     if bits <= 128 {\n@@ -80,31 +94,55 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+    if let Some(uniform) = is_homogeneous_aggregate(ccx, arg, abi) {\n         arg.cast_to(ccx, uniform);\n         return;\n     }\n \n-    let total = arg.layout.size(ccx);\n+    let size = arg.layout.size(ccx);\n+    let (unit, total) = match abi {\n+        ELFv1 => {\n+            // In ELFv1, aggregates smaller than a doubleword should appear in\n+            // the least-significant bits of the parameter doubleword.  The rest\n+            // should be padded at their tail to fill out multiple doublewords.\n+            if size.bits() <= 64 {\n+                (Reg { kind: RegKind::Integer, size }, size)\n+            } else {\n+                let align = layout::Align::from_bits(64, 64).unwrap();\n+                (Reg::i64(), size.abi_align(align))\n+            }\n+        },\n+        ELFv2 => {\n+            // In ELFv2, we can just cast directly.\n+            (Reg::i64(), size)\n+        },\n+    };\n+\n     arg.cast_to(ccx, Uniform {\n-        unit: Reg::i64(),\n+        unit,\n         total\n     });\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let abi = match ccx.sess().target.target.target_endian.as_str() {\n+        \"big\" => ELFv1,\n+        \"little\" => ELFv2,\n+        _ => unimplemented!(),\n+    };\n+\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, abi);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(ccx, arg, abi);\n     }\n }"}, {"sha": "25cd6da10b8fd105399db6c286df9d39b887b73e", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c?ref=a9bb599fb14fab9a9acee13c590b11a47c392cf6", "patch": "@@ -43,6 +43,16 @@ struct FloatPoint {\n     double y;\n };\n \n+struct FloatOne {\n+    double x;\n+};\n+\n+struct IntOdd {\n+    int8_t a;\n+    int8_t b;\n+    int8_t c;\n+};\n+\n // System V x86_64 ABI:\n // a, b, c, d, e should be in registers\n // s should be byval pointer\n@@ -283,7 +293,7 @@ struct Huge huge_struct(struct Huge s) {\n // p should be in registers\n // return should be in registers\n //\n-// Win64 ABI:\n+// Win64 ABI and 64-bit PowerPC ELFv1 ABI:\n // p should be a byval pointer\n // return should be in a hidden sret pointer\n struct FloatPoint float_point(struct FloatPoint p) {\n@@ -292,3 +302,23 @@ struct FloatPoint float_point(struct FloatPoint p) {\n \n     return p;\n }\n+\n+// 64-bit PowerPC ELFv1 ABI:\n+// f1 should be in a register\n+// return should be in a hidden sret pointer\n+struct FloatOne float_one(struct FloatOne f1) {\n+    assert(f1.x == 7.);\n+\n+    return f1;\n+}\n+\n+// 64-bit PowerPC ELFv1 ABI:\n+// i should be in the least-significant bits of a register\n+// return should be in a hidden sret pointer\n+struct IntOdd int_odd(struct IntOdd i) {\n+    assert(i.a == 1);\n+    assert(i.b == 2);\n+    assert(i.c == 3);\n+\n+    return i;\n+}"}, {"sha": "79fec9683a0144fc0596afc744aaa32e5e73bc3b", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs?ref=a9bb599fb14fab9a9acee13c590b11a47c392cf6", "patch": "@@ -53,6 +53,20 @@ struct FloatPoint {\n     y: f64\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+#[repr(C)]\n+struct FloatOne {\n+    x: f64,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+#[repr(C)]\n+struct IntOdd {\n+    a: i8,\n+    b: i8,\n+    c: i8,\n+}\n+\n #[link(name = \"test\", kind = \"static\")]\n extern {\n     fn byval_rect(a: i32, b: i32, c: i32, d: i32, e: i32, s: Rect);\n@@ -83,6 +97,10 @@ extern {\n     fn huge_struct(s: Huge) -> Huge;\n \n     fn float_point(p: FloatPoint) -> FloatPoint;\n+\n+    fn float_one(f: FloatOne) -> FloatOne;\n+\n+    fn int_odd(i: IntOdd) -> IntOdd;\n }\n \n fn main() {\n@@ -91,6 +109,8 @@ fn main() {\n     let u = FloatRect { a: 3489, b: 3490, c: 8. };\n     let v = Huge { a: 5647, b: 5648, c: 5649, d: 5650, e: 5651 };\n     let p = FloatPoint { x: 5., y: -3. };\n+    let f1 = FloatOne { x: 7. };\n+    let i = IntOdd { a: 1, b: 2, c: 3 };\n \n     unsafe {\n         byval_rect(1, 2, 3, 4, 5, s);\n@@ -113,5 +133,7 @@ fn main() {\n         assert_eq!(sret_byval_struct(1, 2, 3, 4, s), t);\n         assert_eq!(sret_split_struct(1, 2, s), t);\n         assert_eq!(float_point(p), p);\n+        assert_eq!(float_one(f1), f1);\n+        assert_eq!(int_odd(i), i);\n     }\n }"}, {"sha": "4124e202c1dd05d4f0875493c6912dc41748f97b", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.c?ref=a9bb599fb14fab9a9acee13c590b11a47c392cf6", "patch": "@@ -1,6 +1,8 @@\n // ignore-license\n // Pragma needed cause of gcc bug on windows: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52991\n \n+#include <assert.h>\n+\n #ifdef _MSC_VER\n #pragma pack(push,1)\n struct Foo {\n@@ -18,5 +20,8 @@ struct __attribute__((packed)) Foo {\n #endif\n \n struct Foo foo(struct Foo foo) {\n+    assert(foo.a == 1);\n+    assert(foo.b == 2);\n+    assert(foo.c == 3);\n     return foo;\n }"}, {"sha": "d2540ad61542b0bc709cafac2a2fa304388f3218", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bb599fb14fab9a9acee13c590b11a47c392cf6/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs?ref=a9bb599fb14fab9a9acee13c590b11a47c392cf6", "patch": "@@ -8,36 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt;\n-\n-#[repr(packed)]\n-#[derive(Copy, Clone)]\n+#[repr(C, packed)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n struct Foo {\n     a: i8,\n     b: i16,\n     c: i8\n }\n \n-impl PartialEq for Foo {\n-    fn eq(&self, other: &Foo) -> bool {\n-        self.a == other.a && self.b == other.b && self.c == other.c\n-    }\n-}\n-\n-impl fmt::Debug for Foo {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let a = self.a;\n-        let b = self.b;\n-        let c = self.c;\n-\n-        f.debug_struct(\"Foo\")\n-            .field(\"a\", &a)\n-            .field(\"b\", &b)\n-            .field(\"c\", &c)\n-            .finish()\n-    }\n-}\n-\n #[link(name = \"test\", kind = \"static\")]\n extern {\n     fn foo(f: Foo) -> Foo;"}]}