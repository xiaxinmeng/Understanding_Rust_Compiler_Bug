{"sha": "2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "node_id": "C_kwDOAAsO6NoAKDJlNDRjMTdjMTJjZWM0NWI2YTY4MmIxZTUzYTA0YWM1YjVmY2M5ZDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-10T12:07:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-10T12:07:29Z"}, "message": "Auto merge of #100968 - cjgillot:mir-upvar-vec, r=wesleywiser\n\nOnly compute captures once when building MIR.", "tree": {"sha": "2e0ee9abc49436740c5117449d87cf05a0652c82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e0ee9abc49436740c5117449d87cf05a0652c82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "html_url": "https://github.com/rust-lang/rust/commit/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "html_url": "https://github.com/rust-lang/rust/commit/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c"}, {"sha": "bcbd183ca3c2aec7786b14385e3dfd35ba3a57a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcbd183ca3c2aec7786b14385e3dfd35ba3a57a4", "html_url": "https://github.com/rust-lang/rust/commit/bcbd183ca3c2aec7786b14385e3dfd35ba3a57a4"}], "stats": {"total": 235, "additions": 83, "deletions": 152}, "files": [{"sha": "ebb56e5a23365d636996c1b053825e9a463b3a6b", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 34, "deletions": 102, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -2,7 +2,7 @@\n \n use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n-use crate::build::{BlockAnd, BlockAndExtension, Builder};\n+use crate::build::{BlockAnd, BlockAndExtension, Builder, Capture, CaptureMap};\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::hir::place::Projection as HirProjection;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n@@ -59,8 +59,6 @@ pub(crate) enum PlaceBase {\n         var_hir_id: LocalVarId,\n         /// DefId of the closure\n         closure_def_id: LocalDefId,\n-        /// The trait closure implements, `Fn`, `FnMut`, `FnOnce`\n-        closure_kind: ty::ClosureKind,\n     },\n }\n \n@@ -145,27 +143,6 @@ fn is_ancestor_or_same_capture(\n     iter::zip(proj_possible_ancestor, proj_capture).all(|(a, b)| a == b)\n }\n \n-/// Computes the index of a capture within the desugared closure provided the closure's\n-/// `closure_min_captures` and the capture's index of the capture in the\n-/// `ty::MinCaptureList` of the root variable `var_hir_id`.\n-fn compute_capture_idx<'tcx>(\n-    closure_min_captures: &ty::RootVariableMinCaptureList<'tcx>,\n-    var_hir_id: LocalVarId,\n-    root_var_idx: usize,\n-) -> usize {\n-    let mut res = 0;\n-    for (var_id, capture_list) in closure_min_captures {\n-        if *var_id == var_hir_id.0 {\n-            res += root_var_idx;\n-            break;\n-        } else {\n-            res += capture_list.len();\n-        }\n-    }\n-\n-    res\n-}\n-\n /// Given a closure, returns the index of a capture within the desugared closure struct and the\n /// `ty::CapturedPlace` which is the ancestor of the Place represented using the `var_hir_id`\n /// and `projection`.\n@@ -174,27 +151,17 @@ fn compute_capture_idx<'tcx>(\n ///\n /// Returns None, when the ancestor is not found.\n fn find_capture_matching_projections<'a, 'tcx>(\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    upvars: &'a CaptureMap<'tcx>,\n     var_hir_id: LocalVarId,\n-    closure_def_id: LocalDefId,\n     projections: &[PlaceElem<'tcx>],\n-) -> Option<(usize, &'a ty::CapturedPlace<'tcx>)> {\n-    let closure_min_captures = typeck_results.closure_min_captures.get(&closure_def_id)?;\n-    let root_variable_min_captures = closure_min_captures.get(&var_hir_id.0)?;\n-\n+) -> Option<(usize, &'a Capture<'tcx>)> {\n     let hir_projections = convert_to_hir_projections_and_truncate_for_capture(projections);\n \n-    // If an ancestor is found, `idx` is the index within the list of captured places\n-    // for root variable `var_hir_id` and `capture` is the `ty::CapturedPlace` itself.\n-    let (idx, capture) = root_variable_min_captures.iter().enumerate().find(|(_, capture)| {\n+    upvars.get_by_key_enumerated(var_hir_id.0).find(|(_, capture)| {\n         let possible_ancestor_proj_kinds: Vec<_> =\n-            capture.place.projections.iter().map(|proj| proj.kind).collect();\n+            capture.captured_place.place.projections.iter().map(|proj| proj.kind).collect();\n         is_ancestor_or_same_capture(&possible_ancestor_proj_kinds, &hir_projections)\n-    })?;\n-\n-    // Convert index to be from the perspective of the entire closure_min_captures map\n-    // instead of just the root variable capture list\n-    Some((compute_capture_idx(closure_min_captures, var_hir_id, idx), capture))\n+    })\n }\n \n /// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n@@ -204,24 +171,15 @@ fn find_capture_matching_projections<'a, 'tcx>(\n fn to_upvars_resolved_place_builder<'a, 'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    upvars: &'a CaptureMap<'tcx>,\n ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n     match from_builder.base {\n         PlaceBase::Local(_) => Ok(from_builder),\n-        PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind } => {\n-            let mut upvar_resolved_place_builder = PlaceBuilder::from(ty::CAPTURE_STRUCT_LOCAL);\n-            match closure_kind {\n-                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n-                    upvar_resolved_place_builder = upvar_resolved_place_builder.deref();\n-                }\n-                ty::ClosureKind::FnOnce => {}\n-            }\n-\n+        PlaceBase::Upvar { var_hir_id, closure_def_id } => {\n             let Some((capture_index, capture)) =\n                 find_capture_matching_projections(\n-                    typeck_results,\n+                    upvars,\n                     var_hir_id,\n-                    closure_def_id,\n                     &from_builder.projection,\n                 ) else {\n                 let closure_span = tcx.def_span(closure_def_id);\n@@ -241,39 +199,17 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                 return Err(from_builder);\n             };\n \n-            // We won't be building MIR if the closure wasn't local\n-            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id);\n-            let closure_ty = typeck_results.node_type(closure_hir_id);\n-\n-            let substs = match closure_ty.kind() {\n-                ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n-                ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n-                _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty),\n-            };\n-\n             // Access the capture by accessing the field within the Closure struct.\n-            //\n-            // We must have inferred the capture types since we are building MIR, therefore\n-            // it's safe to call `tuple_element_ty` and we can unwrap here because\n-            // we know that the capture exists and is the `capture_index`-th capture.\n-            let var_ty = substs.tupled_upvars_ty().tuple_fields()[capture_index];\n-\n-            upvar_resolved_place_builder =\n-                upvar_resolved_place_builder.field(Field::new(capture_index), var_ty);\n-\n-            // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n-            // we need to deref it\n-            upvar_resolved_place_builder = match capture.info.capture_kind {\n-                ty::UpvarCapture::ByRef(_) => upvar_resolved_place_builder.deref(),\n-                ty::UpvarCapture::ByValue => upvar_resolved_place_builder,\n-            };\n+            let capture_info = &upvars[capture_index];\n+\n+            let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n \n             // We used some of the projections to build the capture itself,\n             // now we apply the remaining to the upvar resolved place.\n             let remaining_projections = strip_prefix(\n-                capture.place.base_ty,\n+                capture.captured_place.place.base_ty,\n                 from_builder.projection,\n-                &capture.place.projections,\n+                &capture.captured_place.place.projections,\n             );\n             upvar_resolved_place_builder.projection.extend(remaining_projections);\n \n@@ -315,24 +251,24 @@ fn strip_prefix<'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    pub(crate) fn into_place<'a>(\n+    pub(in crate::build) fn into_place<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n+        upvars: &'a CaptureMap<'tcx>,\n     ) -> Place<'tcx> {\n         if let PlaceBase::Local(local) = self.base {\n             Place { local, projection: tcx.intern_place_elems(&self.projection) }\n         } else {\n-            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n+            self.expect_upvars_resolved(tcx, upvars).into_place(tcx, upvars)\n         }\n     }\n \n     fn expect_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n+        upvars: &'a CaptureMap<'tcx>,\n     ) -> PlaceBuilder<'tcx> {\n-        to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n+        to_upvars_resolved_place_builder(self, tcx, upvars).unwrap()\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n@@ -346,12 +282,12 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    pub(crate) fn try_upvars_resolved<'a>(\n+    pub(in crate::build) fn try_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n+        upvars: &'a CaptureMap<'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        to_upvars_resolved_place_builder(self, tcx, typeck_results)\n+        to_upvars_resolved_place_builder(self, tcx, upvars)\n     }\n \n     pub(crate) fn base(&self) -> PlaceBase {\n@@ -392,6 +328,12 @@ impl<'tcx> From<PlaceBase> for PlaceBuilder<'tcx> {\n     }\n }\n \n+impl<'tcx> From<Place<'tcx>> for PlaceBuilder<'tcx> {\n+    fn from(p: Place<'tcx>) -> Self {\n+        Self { base: PlaceBase::Local(p.local), projection: p.projection.to_vec() }\n+    }\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a place that we can move from etc.\n     ///\n@@ -411,7 +353,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n+        block.and(place_builder.into_place(self.tcx, &self.upvars))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -435,7 +377,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n+        block.and(place_builder.into_place(self.tcx, &self.upvars))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -530,7 +472,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this.tcx, this.typeck_results);\n+                    let place = place_builder.clone().into_place(this.tcx, &this.upvars);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -629,17 +571,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         closure_def_id: LocalDefId,\n         var_hir_id: LocalVarId,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        let closure_ty =\n-            self.typeck_results.node_type(self.tcx.hir().local_def_id_to_hir_id(closure_def_id));\n-\n-        let closure_kind = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-            self.infcx.closure_kind(closure_substs).unwrap()\n-        } else {\n-            // Generators are considered FnOnce.\n-            ty::ClosureKind::FnOnce\n-        };\n-\n-        block.and(PlaceBuilder::from(PlaceBase::Upvar { var_hir_id, closure_def_id, closure_kind }))\n+        block.and(PlaceBuilder::from(PlaceBase::Upvar { var_hir_id, closure_def_id }))\n     }\n \n     /// Lower an index expression\n@@ -678,7 +610,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place = base_place.expect_upvars_resolved(self.tcx, self.typeck_results);\n+            base_place = base_place.expect_upvars_resolved(self.tcx, &self.upvars);\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -710,7 +642,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block,\n             source_info,\n             len,\n-            Rvalue::Len(slice.into_place(self.tcx, self.typeck_results)),\n+            Rvalue::Len(slice.into_place(self.tcx, &self.upvars)),\n         );\n         // lt = idx < len\n         self.cfg.push_assign("}, {"sha": "c1282b8ddaff47c20d314297479d38d443bb10d5", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -328,10 +328,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n                     if let Ok(place_builder_resolved) =\n-                        place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n+                        place_builder.try_upvars_resolved(this.tcx, &this.upvars)\n                     {\n-                        let mir_place =\n-                            place_builder_resolved.into_place(this.tcx, this.typeck_results);\n+                        let mir_place = place_builder_resolved.into_place(this.tcx, &this.upvars);\n                         this.cfg.push_fake_read(\n                             block,\n                             this.source_info(this.tcx.hir().span(*hir_id)),\n@@ -623,7 +622,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n                 let enclosing_upvars_resolved =\n-                    arg_place_builder.clone().into_place(this.tcx, this.typeck_results);\n+                    arg_place_builder.clone().into_place(this.tcx, &this.upvars);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -643,12 +642,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         );\n                         // Not in a closure\n                         debug_assert!(\n-                            this.upvar_mutbls.len() > upvar_index.index(),\n-                            \"Unexpected capture place, upvar_mutbls={:#?}, upvar_index={:?}\",\n-                            this.upvar_mutbls,\n+                            this.upvars.len() > upvar_index.index(),\n+                            \"Unexpected capture place, upvars={:#?}, upvar_index={:?}\",\n+                            this.upvars,\n                             upvar_index\n                         );\n-                        this.upvar_mutbls[upvar_index.index()]\n+                        this.upvars[upvar_index.index()].mutability\n                     }\n                     _ => bug!(\"Unexpected capture place\"),\n                 }\n@@ -660,7 +659,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this.tcx, this.typeck_results);\n+        let arg_place = arg_place_builder.into_place(this.tcx, &this.upvars);\n \n         this.cfg.push_assign(\n             block,"}, {"sha": "6ed5f1fc0d34845462876af340994cfda08d7618", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -366,9 +366,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             None => {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n-                                    place_builder\n-                                        .field(n, *ty)\n-                                        .into_place(this.tcx, this.typeck_results),\n+                                    place_builder.field(n, *ty).into_place(this.tcx, &this.upvars),\n                                 )\n                             }\n                         })"}, {"sha": "505273033a4ca3c357c167205bcf9ec67292a8a1", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -221,9 +221,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let source_info = self.source_info(scrutinee_span);\n \n         if let Ok(scrutinee_builder) =\n-            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, &self.upvars)\n         {\n-            let scrutinee_place = scrutinee_builder.into_place(self.tcx, self.typeck_results);\n+            let scrutinee_place = scrutinee_builder.into_place(self.tcx, &self.upvars);\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -348,12 +348,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // ```\n                     let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n                     let scrutinee_place: Place<'tcx>;\n-                    if let Ok(scrutinee_builder) = scrutinee_place_builder\n-                        .clone()\n-                        .try_upvars_resolved(this.tcx, this.typeck_results)\n+                    if let Ok(scrutinee_builder) =\n+                        scrutinee_place_builder.clone().try_upvars_resolved(this.tcx, &this.upvars)\n                     {\n-                        scrutinee_place =\n-                            scrutinee_builder.into_place(this.tcx, this.typeck_results);\n+                        scrutinee_place = scrutinee_builder.into_place(this.tcx, &this.upvars);\n                         opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n                     }\n                     let scope = this.declare_bindings(\n@@ -620,9 +618,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // };\n                     // ```\n                     if let Ok(match_pair_resolved) =\n-                        initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                        initializer.clone().try_upvars_resolved(self.tcx, &self.upvars)\n                     {\n-                        let place = match_pair_resolved.into_place(self.tcx, self.typeck_results);\n+                        let place = match_pair_resolved.into_place(self.tcx, &self.upvars);\n                         *match_place = Some(place);\n                     }\n                 }\n@@ -1602,9 +1600,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows && let Ok(match_place_resolved) =\n-            match_place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+            match_place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n         {\n-            let resolved_place = match_place_resolved.into_place(self.tcx, self.typeck_results);\n+            let resolved_place = match_place_resolved.into_place(self.tcx, &self.upvars);\n             fb.insert(resolved_place);\n         }\n \n@@ -1791,10 +1789,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n         let expr_place: Place<'tcx>;\n-        if let Ok(expr_builder) =\n-            expr_place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n-        {\n-            expr_place = expr_builder.into_place(self.tcx, self.typeck_results);\n+        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self.tcx, &self.upvars) {\n+            expr_place = expr_builder.into_place(self.tcx, &self.upvars);\n             opt_expr_place = Some((Some(&expr_place), expr_span));\n         }\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();"}, {"sha": "df221d356038451da21f71b9a3f32e9def014824", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -156,11 +156,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n                 if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                    match_pair.place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n                 {\n                     candidate.ascriptions.push(Ascription {\n                         annotation: annotation.clone(),\n-                        source: place_resolved.into_place(self.tcx, self.typeck_results),\n+                        source: place_resolved.into_place(self.tcx, &self.upvars),\n                         variance,\n                     });\n                 }\n@@ -185,11 +185,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 is_primary: _,\n             } => {\n                 if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                    match_pair.place.clone().try_upvars_resolved(self.tcx, &self.upvars)\n                 {\n                     candidate.bindings.push(Binding {\n                         span: match_pair.pattern.span,\n-                        source: place_resolved.into_place(self.tcx, self.typeck_results),\n+                        source: place_resolved.into_place(self.tcx, &self.upvars),\n                         var_id: var,\n                         binding_mode: mode,\n                     });"}, {"sha": "47d05a6e32c86a43be1d2c6d691f882ac5c5be95", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -154,10 +154,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n         let place: Place<'tcx>;\n-        if let Ok(test_place_builder) =\n-            place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n-        {\n-            place = test_place_builder.into_place(self.tcx, self.typeck_results);\n+        if let Ok(test_place_builder) = place_builder.try_upvars_resolved(self.tcx, &self.upvars) {\n+            place = test_place_builder.into_place(self.tcx, &self.upvars);\n         } else {\n             return;\n         }"}, {"sha": "b61c4fe50dd3f18886008e399d39ca53b6edf3ec", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -32,13 +32,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx;\n         let (min_length, exact_size) = if let Ok(place_resolved) =\n-            place.clone().try_upvars_resolved(tcx, self.typeck_results)\n+            place.clone().try_upvars_resolved(tcx, &self.upvars)\n         {\n-            match place_resolved\n-                .into_place(tcx, self.typeck_results)\n-                .ty(&self.local_decls, tcx)\n-                .ty\n-                .kind()\n+            match place_resolved.into_place(tcx, &self.upvars).ty(&self.local_decls, tcx).ty.kind()\n             {\n                 ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n                 _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),"}, {"sha": "7d41969a314b69c0dd981062e6d832dbe2c72c07", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=2e44c17c12cec45b6a682b1e53a04ac5b5fcc9d2", "patch": "@@ -6,6 +6,7 @@ use crate::thir::pattern::pat_from_hir;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -415,12 +416,21 @@ struct Builder<'a, 'tcx> {\n     var_indices: FxHashMap<LocalVarId, LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n-    upvar_mutbls: Vec<Mutability>,\n+    upvars: CaptureMap<'tcx>,\n     unit_temp: Option<Place<'tcx>>,\n \n     var_debug_info: Vec<VarDebugInfo<'tcx>>,\n }\n \n+type CaptureMap<'tcx> = SortedIndexMultiMap<usize, hir::HirId, Capture<'tcx>>;\n+\n+#[derive(Debug)]\n+struct Capture<'tcx> {\n+    captured_place: &'tcx ty::CapturedPlace<'tcx>,\n+    use_place: Place<'tcx>,\n+    mutability: Mutability,\n+}\n+\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn is_bound_var_in_guard(&self, id: LocalVarId) -> bool {\n         self.guard_context.iter().any(|frame| frame.locals.iter().any(|local| local.id == id))\n@@ -865,7 +875,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             in_scope_unsafe: safety,\n             local_decls: IndexVec::from_elem_n(LocalDecl::new(return_ty, return_span), 1),\n             canonical_user_type_annotations: IndexVec::new(),\n-            upvar_mutbls: vec![],\n+            upvars: CaptureMap::new(),\n             var_indices: Default::default(),\n             unit_temp: None,\n             var_debug_info: vec![],\n@@ -934,7 +944,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // indexed closure and we stored in a map called closure_min_captures in TypeckResults\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar\n-        // debuginfo and to fill `self.upvar_mutbls`.\n+        // debuginfo and to fill `self.upvars`.\n         if hir_typeck_results.closure_min_captures.get(&fn_def_id).is_some() {\n             let mut closure_env_projs = vec![];\n             let mut closure_ty = self.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty;\n@@ -954,7 +964,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 .closure_min_captures_flattened(fn_def_id)\n                 .zip(capture_tys.zip(capture_syms));\n \n-            self.upvar_mutbls = captures_with_tys\n+            self.upvars = captures_with_tys\n                 .enumerate()\n                 .map(|(i, (captured_place, (ty, sym)))| {\n                     let capture = captured_place.info.capture_kind;\n@@ -974,16 +984,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     };\n \n+                    let use_place = Place {\n+                        local: ty::CAPTURE_STRUCT_LOCAL,\n+                        projection: tcx.intern_place_elems(&projs),\n+                    };\n                     self.var_debug_info.push(VarDebugInfo {\n                         name: *sym,\n                         source_info: SourceInfo::outermost(tcx_hir.span(var_id)),\n-                        value: VarDebugInfoContents::Place(Place {\n-                            local: ty::CAPTURE_STRUCT_LOCAL,\n-                            projection: tcx.intern_place_elems(&projs),\n-                        }),\n+                        value: VarDebugInfoContents::Place(use_place),\n                     });\n \n-                    mutability\n+                    let capture = Capture { captured_place, use_place, mutability };\n+                    (var_id, capture)\n                 })\n                 .collect();\n         }"}]}