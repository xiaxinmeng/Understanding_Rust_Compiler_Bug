{"sha": "e3adad658763ce79753e6f6e63c6f24964d03ea0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYWRhZDY1ODc2M2NlNzk3NTNlNmY2ZTYzYzZmMjQ5NjRkMDNlYTA=", "commit": {"author": {"name": "Andrey Tonkih", "email": "xosmig@gmail.com", "date": "2016-05-29T10:30:13Z"}, "committer": {"name": "Andrey Tonkih", "email": "xosmig@gmail.com", "date": "2016-06-01T07:02:25Z"}, "message": "Implement split_off for BTreeMap and BTreeSet (RFC 509)", "tree": {"sha": "63f353f3648ca21906e99075eeb0466fbc11e93b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63f353f3648ca21906e99075eeb0466fbc11e93b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3adad658763ce79753e6f6e63c6f24964d03ea0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3adad658763ce79753e6f6e63c6f24964d03ea0", "html_url": "https://github.com/rust-lang/rust/commit/e3adad658763ce79753e6f6e63c6f24964d03ea0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3adad658763ce79753e6f6e63c6f24964d03ea0/comments", "author": {"login": "xosmig", "id": 16969945, "node_id": "MDQ6VXNlcjE2OTY5OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/16969945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xosmig", "html_url": "https://github.com/xosmig", "followers_url": "https://api.github.com/users/xosmig/followers", "following_url": "https://api.github.com/users/xosmig/following{/other_user}", "gists_url": "https://api.github.com/users/xosmig/gists{/gist_id}", "starred_url": "https://api.github.com/users/xosmig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xosmig/subscriptions", "organizations_url": "https://api.github.com/users/xosmig/orgs", "repos_url": "https://api.github.com/users/xosmig/repos", "events_url": "https://api.github.com/users/xosmig/events{/privacy}", "received_events_url": "https://api.github.com/users/xosmig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xosmig", "id": 16969945, "node_id": "MDQ6VXNlcjE2OTY5OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/16969945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xosmig", "html_url": "https://github.com/xosmig", "followers_url": "https://api.github.com/users/xosmig/followers", "following_url": "https://api.github.com/users/xosmig/following{/other_user}", "gists_url": "https://api.github.com/users/xosmig/gists{/gist_id}", "starred_url": "https://api.github.com/users/xosmig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xosmig/subscriptions", "organizations_url": "https://api.github.com/users/xosmig/orgs", "repos_url": "https://api.github.com/users/xosmig/repos", "events_url": "https://api.github.com/users/xosmig/events{/privacy}", "received_events_url": "https://api.github.com/users/xosmig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "397cfaec0ce28289b0ab04ed6f6c3ba6ee1042ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/397cfaec0ce28289b0ab04ed6f6c3ba6ee1042ea", "html_url": "https://github.com/rust-lang/rust/commit/397cfaec0ce28289b0ab04ed6f6c3ba6ee1042ea"}], "stats": {"total": 630, "additions": 538, "deletions": 92}, "files": [{"sha": "29f3e4b1b6159cd4a02d23baf4468d653180af39", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 170, "deletions": 2, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e3adad658763ce79753e6f6e63c6f24964d03ea0", "patch": "@@ -842,20 +842,188 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n             let right_child_len = last_edge.reborrow().descend().len();\n-            if right_child_len < node::CAPACITY / 2 {\n+            if right_child_len < node::MIN_LEN {\n                 // We need to steal.\n                 let mut last_kv = match last_edge.left_kv() {\n                     Ok(left) => left,\n                     Err(_) => unreachable!(),\n                 };\n-                last_kv.bulk_steal_left(node::CAPACITY/2 - right_child_len);\n+                last_kv.bulk_steal_left(node::MIN_LEN - right_child_len);\n                 last_edge = last_kv.right_edge();\n             }\n \n             // Go further down.\n             cur_node = last_edge.descend();\n         }\n     }\n+\n+    /// Splits the collection into two at the given key. Returns everything after the given key,\n+    /// including the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_split_off)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(17, \"d\");\n+    /// a.insert(41, \"e\");\n+    ///\n+    /// let b = a.split_off(&3);\n+    ///\n+    /// assert_eq!(a.len(), 2);\n+    /// assert_eq!(b.len(), 3);\n+    ///\n+    /// assert_eq!(a[&1], \"a\");\n+    /// assert_eq!(a[&2], \"b\");\n+    ///\n+    /// assert_eq!(b[&3], \"c\");\n+    /// assert_eq!(b[&17], \"d\");\n+    /// assert_eq!(b[&41], \"e\");\n+    /// ```\n+    #[unstable(feature = \"btree_split_off\",\n+               reason = \"recently added as part of collections reform 2\",\n+               issue = \"19986\")]\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where K: Borrow<Q> {\n+        if self.is_empty() {\n+            return Self::new();\n+        }\n+\n+        let total_num = self.len();\n+\n+        let mut right = Self::new();\n+        for _ in 0..(self.root.as_ref().height()) {\n+            right.root.push_level();\n+        }\n+\n+        {\n+            let mut left_node = self.root.as_mut();\n+            let mut right_node = right.root.as_mut();\n+\n+            loop {\n+                let mut split_edge = match search::search_node(left_node, key) {\n+                    // key is going to the right tree\n+                    Found(handle) => handle.left_edge(),\n+                    GoDown(handle) => handle\n+                };\n+\n+                split_edge.move_suffix(&mut right_node);\n+\n+                match (split_edge.force(), right_node.force()) {\n+                    (Internal(edge), Internal(node)) => {\n+                        left_node = edge.descend();\n+                        right_node = node.first_edge().descend();\n+                    }\n+                    (Leaf(_), Leaf(_)) => { break; },\n+                    _ => { unreachable!(); }\n+                }\n+            }\n+        }\n+\n+        self.fix_right_border();\n+        right.fix_left_border();\n+\n+        if self.root.as_ref().height() < right.root.as_ref().height() {\n+            self.recalc_length();\n+            right.length = total_num - self.len();\n+        } else {\n+            right.recalc_length();\n+            self.length = total_num - right.len();\n+        }\n+\n+        right\n+    }\n+\n+    /// Calculates the number of elements if it is incorrect.\n+    fn recalc_length(&mut self) {\n+        fn dfs<K, V>(node: NodeRef<marker::Immut, K, V, marker::LeafOrInternal>) -> usize {\n+            let mut res = node.len();\n+\n+            if let Internal(node) = node.force() {\n+                let mut edge = node.first_edge();\n+                loop {\n+                    res += dfs(edge.reborrow().descend());\n+                    match edge.right_kv() {\n+                        Ok(right_kv) => { edge = right_kv.right_edge(); },\n+                        Err(_) => { break; }\n+                    }\n+                }\n+            }\n+\n+            res\n+        }\n+\n+        self.length = dfs(self.root.as_ref());\n+    }\n+\n+    /// Removes empty levels on the top.\n+    fn fix_top(&mut self) {\n+        loop {\n+            {\n+                let node = self.root.as_ref();\n+                if node.height() == 0 || node.len() > 0 {\n+                    break;\n+                }\n+            }\n+            self.root.pop_level();\n+        }\n+    }\n+\n+    fn fix_right_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.root.as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut last_kv = node.last_kv();\n+\n+                if last_kv.can_merge() {\n+                    cur_node = last_kv.merge().descend();\n+                } else {\n+                    let right_len = last_kv.reborrow().right_edge().descend().len();\n+                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n+                    if right_len < node::MIN_LEN + 1 {\n+                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n+                    }\n+                    cur_node = last_kv.right_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+\n+    /// The symmetric clone of `fix_right_border`.\n+    fn fix_left_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.root.as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut first_kv = node.first_kv();\n+\n+                if first_kv.can_merge() {\n+                    cur_node = first_kv.merge().descend();\n+                } else {\n+                    let left_len = first_kv.reborrow().left_edge().descend().len();\n+                    if left_len < node::MIN_LEN + 1 {\n+                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n+                    }\n+                    cur_node = first_kv.left_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n }\n \n impl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {"}, {"sha": "e9bc29118d508aa6b4bf36e926c16bfd4cae40f3", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 204, "deletions": 90, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e3adad658763ce79753e6f6e63c6f24964d03ea0", "patch": "@@ -51,6 +51,7 @@ use core::slice;\n use boxed::Box;\n \n const B: usize = 6;\n+pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n \n /// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n@@ -413,6 +414,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         let len = self.len();\n         Handle::new_edge(self, len)\n     }\n+\n+    /// Note that `self` must be nonempty.\n+    pub fn first_kv(self) -> Handle<Self, marker::KV> {\n+        debug_assert!(self.len() > 0);\n+        Handle::new_kv(self, 0)\n+    }\n+\n+    /// Note that `self` must be nonempty.\n+    pub fn last_kv(self) -> Handle<Self, marker::KV> {\n+        let len = self.len();\n+        debug_assert!(len > 0);\n+        Handle::new_kv(self, len - 1)\n+    }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n@@ -602,6 +616,17 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n+    fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+        for i in first..after_last {\n+            Handle::new_edge(unsafe { self.reborrow_mut() }, i).correct_parent_link();\n+        }\n+    }\n+\n+    fn correct_all_childrens_parent_links(&mut self) {\n+        let len = self.len();\n+        self.correct_childrens_parent_links(0, len + 1);\n+    }\n+\n     /// Adds a key/value pair and an edge to go to the left of that pair to\n     /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n@@ -623,11 +648,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n \n             self.as_leaf_mut().len += 1;\n \n-            for i in 0..self.len()+1 {\n-                Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n-            }\n+            self.correct_all_childrens_parent_links();\n         }\n-\n     }\n }\n \n@@ -696,6 +718,13 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             (key, val, edge)\n         }\n     }\n+\n+    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+        (\n+            self.keys_mut().as_mut_ptr(),\n+            self.vals_mut().as_mut_ptr()\n+        )\n+    }\n }\n \n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n@@ -1275,105 +1304,155 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     }\n \n     /// This does stealing similar to `steal_left` but steals multiple elements at once.\n-    pub fn bulk_steal_left(&mut self, n: usize) {\n+    pub fn bulk_steal_left(&mut self, count: usize) {\n         unsafe {\n-            // Get raw pointers to left child's keys, values and edges.\n-            let (left_len, left_k, left_v, left_e) = {\n-                let mut left = self.reborrow_mut().left_edge().descend();\n-\n-                (left.len(),\n-                 left.keys_mut().as_mut_ptr(),\n-                 left.vals_mut().as_mut_ptr(),\n-                 match left.force() {\n-                     ForceResult::Leaf(_) => None,\n-                     ForceResult::Internal(mut i) => Some(i.as_internal_mut().edges.as_mut_ptr()),\n-                 })\n-            };\n-\n-            // Get raw pointers to right child's keys, values and edges.\n-            let (right_len, right_k, right_v, right_e) = {\n-                let mut right = self.reborrow_mut().right_edge().descend();\n-\n-                (right.len(),\n-                 right.keys_mut().as_mut_ptr(),\n-                 right.vals_mut().as_mut_ptr(),\n-                 match right.force() {\n-                     ForceResult::Leaf(_) => None,\n-                     ForceResult::Internal(mut i) => Some(i.as_internal_mut().edges.as_mut_ptr()),\n-                 })\n-            };\n-\n-            // Get raw pointers to parent's key and value.\n-            let (parent_k, parent_v) = {\n-                let kv = self.reborrow_mut().into_kv_mut();\n-                (kv.0 as *mut K, kv.1 as *mut V)\n-            };\n+            let mut left_node = ptr::read(self).left_edge().descend();\n+            let left_len = left_node.len();\n+            let mut right_node = ptr::read(self).right_edge().descend();\n+            let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            debug_assert!(right_len + n <= CAPACITY);\n-            debug_assert!(left_len >= n);\n-\n-            // Make room for stolen elements in right child.\n-            ptr::copy(right_k,\n-                      right_k.offset(n as isize),\n-                      right_len);\n-            ptr::copy(right_v,\n-                      right_v.offset(n as isize),\n-                      right_len);\n-            if let Some(edges) = right_e {\n-                ptr::copy(edges,\n-                          edges.offset(n as isize),\n-                          right_len+1);\n+            debug_assert!(right_len + count <= CAPACITY);\n+            debug_assert!(left_len >= count);\n+\n+            let new_left_len = left_len - count;\n+\n+            // Move data.\n+            {\n+                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n+                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n+                let parent_kv = {\n+                    let kv = self.reborrow_mut().into_kv_mut();\n+                    (kv.0 as *mut K, kv.1 as *mut V)\n+                };\n+\n+                // Make room for stolen elements in the right child.\n+                ptr::copy(right_kv.0,\n+                          right_kv.0.offset(count as isize),\n+                          right_len);\n+                ptr::copy(right_kv.1,\n+                          right_kv.1.offset(count as isize),\n+                          right_len);\n+\n+                // Move elements from the left child to the right one.\n+                move_kv(left_kv, new_left_len + 1, right_kv, 0, count - 1);\n+\n+                // Move parent's key/value pair to the right child.\n+                move_kv(parent_kv, 0, right_kv, count - 1, 1);\n+\n+                // Move the left-most stolen pair to the parent.\n+                move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            // Move elements from the left child to the right one.\n-            let left_ind = (left_len - n) as isize;\n-            ptr::copy_nonoverlapping(left_k.offset(left_ind + 1),\n-                                     right_k,\n-                                     n - 1);\n-            ptr::copy_nonoverlapping(left_v.offset(left_ind + 1),\n-                                     right_v,\n-                                     n - 1);\n-            match (left_e, right_e) {\n-                (Some(left), Some(right)) => {\n-                    ptr::copy_nonoverlapping(left.offset(left_ind + 1),\n-                                             right,\n-                                             n);\n+            left_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n+            right_node.reborrow_mut().as_leaf_mut().len += count as u16;\n+\n+            match (left_node.force(), right_node.force()) {\n+                (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n+                    // Make room for stolen edges.\n+                    let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n+                    ptr::copy(right_edges,\n+                              right_edges.offset(count as isize),\n+                              right_len + 1);\n+                    right.correct_childrens_parent_links(count, count + right_len + 1);\n+\n+                    move_edges(left, new_left_len + 1, right, 0, count);\n                 },\n-                (Some(_), None) => unreachable!(),\n-                (None, Some(_)) => unreachable!(),\n-                (None, None) => {},\n+                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => { }\n+                _ => { unreachable!(); }\n             }\n+        }\n+    }\n \n-            // Copy parent key/value pair to right child.\n-            ptr::copy_nonoverlapping(parent_k,\n-                                     right_k.offset(n as isize - 1),\n-                                     1);\n-            ptr::copy_nonoverlapping(parent_v,\n-                                     right_v.offset(n as isize - 1),\n-                                     1);\n-            // Copy left-most stolen pair to parent.\n-            ptr::copy_nonoverlapping(left_k.offset(left_ind),\n-                                     parent_k,\n-                                     1);\n-            ptr::copy_nonoverlapping(left_v.offset(left_ind),\n-                                     parent_v,\n-                                     1);\n-\n-            // Fix lengths of left and right child and parent pointers in children of the right\n-            // child.\n-            self.reborrow_mut().left_edge().descend().as_leaf_mut().len -= n as u16;\n-            let mut right = self.reborrow_mut().right_edge().descend();\n-            right.as_leaf_mut().len += n as u16;\n-            if let ForceResult::Internal(mut node) = right.force() {\n-                for i in 0..(right_len+n+1) {\n-                    Handle::new_edge(node.reborrow_mut(), i as usize).correct_parent_link();\n-                }\n+    /// The symmetric clone of `bulk_steal_left`.\n+    pub fn bulk_steal_right(&mut self, count: usize) {\n+        unsafe {\n+            let mut left_node = ptr::read(self).left_edge().descend();\n+            let left_len = left_node.len();\n+            let mut right_node = ptr::read(self).right_edge().descend();\n+            let right_len = right_node.len();\n+\n+            // Make sure that we may steal safely.\n+            debug_assert!(left_len + count <= CAPACITY);\n+            debug_assert!(right_len >= count);\n+\n+            let new_right_len = right_len - count;\n+\n+            // Move data.\n+            {\n+                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n+                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n+                let parent_kv = {\n+                    let kv = self.reborrow_mut().into_kv_mut();\n+                    (kv.0 as *mut K, kv.1 as *mut V)\n+                };\n+\n+                // Move parent's key/value pair to the left child.\n+                move_kv(parent_kv, 0, left_kv, left_len, 1);\n+\n+                // Move elements from the right child to the left one.\n+                move_kv(right_kv, 0, left_kv, left_len + 1, count - 1);\n+\n+                // Move the right-most stolen pair to the parent.\n+                move_kv(right_kv, count - 1, parent_kv, 0, 1);\n+\n+                // Fix right indexing\n+                ptr::copy(right_kv.0.offset(count as isize),\n+                          right_kv.0,\n+                          new_right_len);\n+                ptr::copy(right_kv.1.offset(count as isize),\n+                          right_kv.1,\n+                          new_right_len);\n+            }\n+\n+            left_node.reborrow_mut().as_leaf_mut().len += count as u16;\n+            right_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n+\n+            match (left_node.force(), right_node.force()) {\n+                (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n+                    move_edges(right.reborrow_mut(), 0, left, left_len + 1, count);\n+\n+                    // Fix right indexing.\n+                    let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n+                    ptr::copy(right_edges.offset(count as isize),\n+                              right_edges,\n+                              new_right_len + 1);\n+                    right.correct_childrens_parent_links(0, new_right_len + 1);\n+                },\n+                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => { }\n+                _ => { unreachable!(); }\n             }\n         }\n     }\n }\n \n+unsafe fn move_kv<K, V>(\n+    source: (*mut K, *mut V), source_offset: usize,\n+    dest: (*mut K, *mut V), dest_offset: usize,\n+    count: usize)\n+{\n+    ptr::copy_nonoverlapping(source.0.offset(source_offset as isize),\n+                             dest.0.offset(dest_offset as isize),\n+                             count);\n+    ptr::copy_nonoverlapping(source.1.offset(source_offset as isize),\n+                             dest.1.offset(dest_offset as isize),\n+                             count);\n+}\n+\n+// Source and destination must have the same height.\n+unsafe fn move_edges<K, V>(\n+    mut source: NodeRef<marker::Mut, K, V, marker::Internal>, source_offset: usize,\n+    mut dest: NodeRef<marker::Mut, K, V, marker::Internal>, dest_offset: usize,\n+    count: usize)\n+{\n+    let source_ptr = source.as_internal_mut().edges.as_mut_ptr();\n+    let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n+    ptr::copy_nonoverlapping(source_ptr.offset(source_offset as isize),\n+                             dest_ptr.offset(dest_offset as isize),\n+                             count);\n+    dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+}\n+\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n@@ -1397,6 +1476,41 @@ impl<BorrowType, K, V, HandleType>\n     }\n }\n \n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n+    /// Move the suffix after `self` from one node to another one. `right` must be empty.\n+    /// The first edge of `right` remains unchanged.\n+    pub fn move_suffix(&mut self,\n+            right: &mut NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>) {\n+        unsafe {\n+            let left_new_len = self.idx;\n+            let mut left_node = self.reborrow_mut().into_node();\n+\n+            let right_new_len = left_node.len() - left_new_len;\n+            let mut right_node = right.reborrow_mut();\n+\n+            debug_assert!(right_node.len() == 0);\n+            debug_assert!(left_node.height == right_node.height);\n+\n+            let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n+            let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n+\n+\n+            move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n+\n+            left_node.reborrow_mut().as_leaf_mut().len = left_new_len as u16;\n+            right_node.reborrow_mut().as_leaf_mut().len = right_new_len as u16;\n+\n+            match (left_node.force(), right_node.force()) {\n+                (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n+                    move_edges(left, left_new_len + 1, right, 1, right_new_len);\n+                },\n+                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => { }\n+                _ => { unreachable!(); }\n+            }\n+        }\n+    }\n+}\n+\n pub enum ForceResult<Leaf, Internal> {\n     Leaf(Leaf),\n     Internal(Internal)"}, {"sha": "765595be317c117b705aaa8c90933d383cd1019d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=e3adad658763ce79753e6f6e63c6f24964d03ea0", "patch": "@@ -580,6 +580,43 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn append(&mut self, other: &mut Self) {\n         self.map.append(&mut other.map);\n     }\n+\n+    /// Splits the collection into two at the given key. Returns everything after the given key,\n+    /// including the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_split_off)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(17, \"d\");\n+    /// a.insert(41, \"e\");\n+    ///\n+    /// let b = a.split_off(&3);\n+    ///\n+    /// assert_eq!(a.len(), 2);\n+    /// assert_eq!(b.len(), 3);\n+    ///\n+    /// assert_eq!(a[&1], \"a\");\n+    /// assert_eq!(a[&2], \"b\");\n+    ///\n+    /// assert_eq!(b[&3], \"c\");\n+    /// assert_eq!(b[&17], \"d\");\n+    /// assert_eq!(b[&41], \"e\");\n+    /// ```\n+    #[unstable(feature = \"btree_split_off\",\n+               reason = \"recently added as part of collections reform 2\",\n+               issue = \"19986\")]\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where T: Borrow<Q> {\n+        BTreeSet { map: self.map.split_off(key) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "49fce68d15e542138a720a59b05d19c880951dd7", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=e3adad658763ce79753e6f6e63c6f24964d03ea0", "patch": "@@ -13,6 +13,9 @@ use std::collections::Bound::{self, Excluded, Included, Unbounded};\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n use std::rc::Rc;\n \n+use std::iter::FromIterator;\n+use super::DeterministicRng;\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n@@ -528,6 +531,51 @@ create_append_test!(test_append_181, 181);\n create_append_test!(test_append_239, 239);\n create_append_test!(test_append_1700, 1700);\n \n+fn rand_data(len: usize) -> Vec<(u32, u32)> {\n+    let mut rng = DeterministicRng::new();\n+    Vec::from_iter(\n+        (0..len).map(|_| (rng.next(), rng.next()))\n+    )\n+}\n+\n+#[test]\n+fn test_split_off_empty_right() {\n+    let mut data = rand_data(173);\n+\n+    let mut map = BTreeMap::from_iter(data.clone());\n+    let right = map.split_off(&(data.iter().max().unwrap().0 + 1));\n+\n+    data.sort();\n+    assert!(map.into_iter().eq(data));\n+    assert!(right.into_iter().eq(None));\n+}\n+\n+#[test]\n+fn test_split_off_empty_left() {\n+    let mut data = rand_data(314);\n+\n+    let mut map = BTreeMap::from_iter(data.clone());\n+    let right = map.split_off(&data.iter().min().unwrap().0);\n+\n+    data.sort();\n+    assert!(map.into_iter().eq(None));\n+    assert!(right.into_iter().eq(data));\n+}\n+\n+#[test]\n+fn test_split_off_large_random_sorted() {\n+    let mut data = rand_data(1529);\n+    // special case with maximum height.\n+    data.sort();\n+\n+    let mut map = BTreeMap::from_iter(data.clone());\n+    let key = data[data.len() / 2].0;\n+    let right = map.split_off(&key);\n+\n+    assert!(map.into_iter().eq(data.clone().into_iter().filter(|x| x.0 < key)));\n+    assert!(right.into_iter().eq(data.into_iter().filter(|x| x.0 >= key)));\n+}\n+\n mod bench {\n     use std::collections::BTreeMap;\n     use std::__rand::{Rng, thread_rng};"}, {"sha": "ea43f423b7c1f0bf7e60570c110cd317444202fe", "filename": "src/libcollectionstest/btree/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmod.rs?ref=e3adad658763ce79753e6f6e63c6f24964d03ea0", "patch": "@@ -10,3 +10,33 @@\n \n mod map;\n mod set;\n+\n+/// XorShiftRng\n+struct DeterministicRng {\n+    x: u32,\n+    y: u32,\n+    z: u32,\n+    w: u32,\n+}\n+\n+impl DeterministicRng {\n+    fn new() -> Self {\n+        DeterministicRng {\n+            x: 0x193a6754,\n+            y: 0xa8a7d469,\n+            z: 0x97830e05,\n+            w: 0x113ba7bb\n+        }\n+    }\n+\n+    fn next(&mut self) -> u32 {\n+        let x = self.x;\n+        let t = x ^ (x << 11);\n+        self.x = self.y;\n+        self.y = self.z;\n+        self.z = self.w;\n+        let w_ = self.w;\n+        self.w = w_ ^ (w_ >> 19) ^ (t ^ (t >> 8));\n+        self.w\n+    }\n+}"}, {"sha": "f7b647d7772db4a57d91ec37d1cfc300703f23e6", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=e3adad658763ce79753e6f6e63c6f24964d03ea0", "patch": "@@ -10,6 +10,9 @@\n \n use std::collections::BTreeSet;\n \n+use std::iter::FromIterator;\n+use super::DeterministicRng;\n+\n #[test]\n fn test_clone_eq() {\n   let mut m = BTreeSet::new();\n@@ -289,3 +292,48 @@ fn test_append() {\n     assert_eq!(a.contains(&4), true);\n     assert_eq!(a.contains(&5), true);\n }\n+\n+fn rand_data(len: usize) -> Vec<u32> {\n+    let mut rng = DeterministicRng::new();\n+    Vec::from_iter(\n+        (0..len).map(|_| rng.next())\n+    )\n+}\n+\n+#[test]\n+fn test_split_off_empty_right() {\n+    let mut data = rand_data(173);\n+\n+    let mut set = BTreeSet::from_iter(data.clone());\n+    let right = set.split_off(&(data.iter().max().unwrap() + 1));\n+\n+    data.sort();\n+    assert!(set.into_iter().eq(data));\n+    assert!(right.into_iter().eq(None));\n+}\n+\n+#[test]\n+fn test_split_off_empty_left() {\n+    let mut data = rand_data(314);\n+\n+    let mut set = BTreeSet::from_iter(data.clone());\n+    let right = set.split_off(data.iter().min().unwrap());\n+\n+    data.sort();\n+    assert!(set.into_iter().eq(None));\n+    assert!(right.into_iter().eq(data));\n+}\n+\n+#[test]\n+fn test_split_off_large_random_sorted() {\n+    let mut data = rand_data(1529);\n+    // special case with maximum height.\n+    data.sort();\n+\n+    let mut set = BTreeSet::from_iter(data.clone());\n+    let key = data[data.len() / 2];\n+    let right = set.split_off(&key);\n+\n+    assert!(set.into_iter().eq(data.clone().into_iter().filter(|x| *x < key)));\n+    assert!(right.into_iter().eq(data.into_iter().filter(|x| *x >= key)));\n+}"}, {"sha": "840a83f048b3b901476d5fc8383afb1f2035c19a", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3adad658763ce79753e6f6e63c6f24964d03ea0/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=e3adad658763ce79753e6f6e63c6f24964d03ea0", "patch": "@@ -14,6 +14,7 @@\n #![feature(binary_heap_append)]\n #![feature(box_syntax)]\n #![feature(btree_append)]\n+#![feature(btree_split_off)]\n #![feature(btree_range)]\n #![feature(collections)]\n #![feature(collections_bound)]"}]}