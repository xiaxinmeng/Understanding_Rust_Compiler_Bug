{"sha": "962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "node_id": "C_kwDOAAsO6NoAKDk2MmJmNjNkYmZjYjE5MGJkNzUyZTJkYmZmN2QxMzNhYjExMDFmNWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-30T08:52:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-30T08:52:35Z"}, "message": "Auto merge of #2639 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "0d0567de3defda59316b51e53e7687b36025df6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d0567de3defda59316b51e53e7687b36025df6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "html_url": "https://github.com/rust-lang/rust/commit/962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "html_url": "https://github.com/rust-lang/rust/commit/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc"}, {"sha": "0b49a5d17354c3b0980c3148f8291e429fc9a194", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b49a5d17354c3b0980c3148f8291e429fc9a194", "html_url": "https://github.com/rust-lang/rust/commit/0b49a5d17354c3b0980c3148f8291e429fc9a194"}], "stats": {"total": 12919, "additions": 8440, "deletions": 4479}, "files": [{"sha": "a3df56f1d2afcaa4fea11229c9f32737867afb09", "filename": "RELEASES.md", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,3 +1,106 @@\n+Version 1.65.0 (2022-11-03)\n+==========================\n+\n+Language\n+--------\n+- [Error on `as` casts of enums with `#[non_exhaustive]` variants](https://github.com/rust-lang/rust/pull/92744/)\n+- [Stabilize `let else`](https://github.com/rust-lang/rust/pull/93628/)\n+- [Stabilize generic associated types (GATs)](https://github.com/rust-lang/rust/pull/96709/)\n+- [Add lints `let_underscore_drop`, `let_underscore_lock`, and `let_underscore_must_use` from Clippy](https://github.com/rust-lang/rust/pull/97739/)\n+- [Stabilize `break`ing from arbitrary labeled blocks (\"label-break-value\")](https://github.com/rust-lang/rust/pull/99332/)\n+- [Uninitialized integers, floats, and raw pointers are now considered immediate UB](https://github.com/rust-lang/rust/pull/98919/).\n+  Usage of `MaybeUninit` is the correct way to work with uninitialized memory.\n+- [Stabilize raw-dylib for Windows x86_64, aarch64, and thumbv7a](https://github.com/rust-lang/rust/pull/99916/)\n+- [Do not allow `Drop` impl on foreign ADTs](https://github.com/rust-lang/rust/pull/99576/)\n+\n+Compiler\n+--------\n+- [Stabilize -Csplit-debuginfo on Linux](https://github.com/rust-lang/rust/pull/98051/)\n+- [Use niche-filling optimization even when multiple variants have data](https://github.com/rust-lang/rust/pull/94075/)\n+- [Associated type projections are now verified to be well-formed prior to resolving the underlying type](https://github.com/rust-lang/rust/pull/99217/#issuecomment-1209365630)\n+- [Stringify non-shorthand visibility correctly](https://github.com/rust-lang/rust/pull/100350/)\n+- [Normalize struct field types when unsizing](https://github.com/rust-lang/rust/pull/101831/)\n+- [Update to LLVM 15](https://github.com/rust-lang/rust/pull/99464/)\n+- [Fix aarch64 call abi to correctly zeroext when needed](https://github.com/rust-lang/rust/pull/97800/)\n+- [debuginfo: Generalize C++-like encoding for enums](https://github.com/rust-lang/rust/pull/98393/)\n+- [Add `special_module_name` lint](https://github.com/rust-lang/rust/pull/94467/)\n+- [Add support for generating unique profraw files by default when using `-C instrument-coverage`](https://github.com/rust-lang/rust/pull/100384/)\n+- [Allow dynamic linking for iOS/tvOS targets](https://github.com/rust-lang/rust/pull/100636/)\n+\n+New targets:\n+\n+- [Add armv4t-none-eabi as a tier 3 target](https://github.com/rust-lang/rust/pull/100244/)\n+- [Add powerpc64-unknown-openbsd and riscv64-unknown-openbsd as tier 3 targets](https://github.com/rust-lang/rust/pull/101025/)\n+  - Refer to Rust's [platform support page][platform-support-doc] for more\n+    information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+\n+- [Don't generate `PartialEq::ne` in derive(PartialEq)](https://github.com/rust-lang/rust/pull/98655/)\n+- [Windows RNG: Use `BCRYPT_RNG_ALG_HANDLE` by default](https://github.com/rust-lang/rust/pull/101325/)\n+- [Forbid mixing `System` with direct system allocator calls](https://github.com/rust-lang/rust/pull/101394/)\n+- [Document no support for writing to non-blocking stdio/stderr](https://github.com/rust-lang/rust/pull/101416/)\n+- [`std::layout::Layout` size must not overflow `isize::MAX` when rounded up to `align`](https://github.com/rust-lang/rust/pull/95295)\n+  This also changes the safety conditions on `Layout::from_size_align_unchecked`.\n+\n+Stabilized APIs\n+---------------\n+\n+- [`std::backtrace::Backtrace`](https://doc.rust-lang.org/stable/std/backtrace/struct.Backtrace.html)\n+- [`Bound::as_ref`](https://doc.rust-lang.org/stable/std/ops/enum.Bound.html#method.as_ref)\n+- [`std::io::read_to_string`](https://doc.rust-lang.org/stable/std/io/fn.read_to_string.html)\n+- [`<*const T>::cast_mut`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_mut)\n+- [`<*mut T>::cast_const`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_const)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`<*const T>::offset_from`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from)\n+- [`<*mut T>::offset_from`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from)\n+\n+Cargo\n+-----\n+\n+- [Apply GitHub fast path even for partial hashes](https://github.com/rust-lang/cargo/pull/10807/)\n+- [Do not add home bin path to PATH if it's already there](https://github.com/rust-lang/cargo/pull/11023/)\n+- [Take priority into account within the pending queue](https://github.com/rust-lang/cargo/pull/11032/).\n+  This slightly optimizes job scheduling by Cargo, with typically small improvements on larger crate graph builds.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [`std::layout::Layout` size must not overflow `isize::MAX` when rounded up to `align`](https://github.com/rust-lang/rust/pull/95295).\n+  This also changes the safety conditions on `Layout::from_size_align_unchecked`.\n+- [`PollFn` now only implements `Unpin` if the closure is `Unpin`](https://github.com/rust-lang/rust/pull/102737).\n+  This is a possible breaking change if users were relying on the blanket unpin implementation.\n+  See discussion on the PR for details of why this change was made.\n+- [Drop ExactSizeIterator impl from std::char::EscapeAscii](https://github.com/rust-lang/rust/pull/99880)\n+  This is a backwards-incompatible change to the standard library's surface\n+  area, but is unlikely to affect real world usage.\n+- [Do not consider a single repeated lifetime eligible for elision in the return type](https://github.com/rust-lang/rust/pull/103450)\n+  This behavior was unintentionally changed in 1.64.0, and this release reverts that change by making this an error again.\n+- [Reenable disabled early syntax gates as future-incompatibility lints](https://github.com/rust-lang/rust/pull/99935/)\n+- [Update the minimum external LLVM to 13](https://github.com/rust-lang/rust/pull/100460/)\n+- [Don't duplicate file descriptors into stdio fds](https://github.com/rust-lang/rust/pull/101426/)\n+- [Sunset RLS](https://github.com/rust-lang/rust/pull/100863/)\n+- [Deny usage of `#![cfg_attr(..., crate_type = ...)]` to set the crate type](https://github.com/rust-lang/rust/pull/99784/)\n+  This strengthens the forward compatibility lint deprecated_cfg_attr_crate_type_name to deny.\n+- [`llvm-has-rust-patches` allows setting the build system to treat the LLVM as having Rust-specific patches](https://github.com/rust-lang/rust/pull/101072)\n+  This option may need to be set for distributions that are building Rust with a patched LLVM via `llvm-config`, not the built-in LLVM.\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Add `x.sh` and `x.ps1` shell scripts](https://github.com/rust-lang/rust/pull/99992/)\n+- [compiletest: use target cfg instead of hard-coded tables](https://github.com/rust-lang/rust/pull/100260/)\n+- [Use object instead of LLVM for reading bitcode from rlibs](https://github.com/rust-lang/rust/pull/98100/)\n+- [Enable MIR inlining for optimized compilations](https://github.com/rust-lang/rust/pull/91743)\n+  This provides a 3-10% improvement in compiletimes for real world crates. See [perf results](https://perf.rust-lang.org/compare.html?start=aedf78e56b2279cc869962feac5153b6ba7001ed&end=0075bb4fad68e64b6d1be06bf2db366c30bc75e1&stat=instructions:u).\n+\n Version 1.64.0 (2022-09-22)\n ===========================\n "}, {"sha": "4ef43735a62c8eac79b0499268553cfd223e91d3", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1112,24 +1112,6 @@ pub struct Expr {\n }\n \n impl Expr {\n-    /// Returns `true` if this expression would be valid somewhere that expects a value;\n-    /// for example, an `if` condition.\n-    pub fn returns(&self) -> bool {\n-        if let ExprKind::Block(ref block, _) = self.kind {\n-            match block.stmts.last().map(|last_stmt| &last_stmt.kind) {\n-                // Implicit return\n-                Some(StmtKind::Expr(_)) => true,\n-                // Last statement is an explicit return?\n-                Some(StmtKind::Semi(expr)) => matches!(expr.kind, ExprKind::Ret(_)),\n-                // This is a block that doesn't end in either an implicit or explicit return.\n-                _ => false,\n-            }\n-        } else {\n-            // This is not a block, it is a value.\n-            true\n-        }\n-    }\n-\n     /// Is this expr either `N`, or `{ N }`.\n     ///\n     /// If this is not the case, name resolution does not resolve `N` when using"}, {"sha": "b970e57e0173c444a5dddef1862087d6036c35d9", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -152,6 +152,12 @@ pub trait MutVisitor: Sized {\n         noop_visit_expr(e, self);\n     }\n \n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &mut P<Expr>) {\n+        self.visit_expr(ex)\n+    }\n+\n     fn filter_map_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n         noop_filter_map_expr(e, self)\n     }\n@@ -1301,7 +1307,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_ident(ident);\n             vis.visit_id(id);\n             visit_opt(args, |args| vis.visit_generic_args(args));\n-            vis.visit_expr(receiver);\n+            vis.visit_method_receiver_expr(receiver);\n             visit_exprs(exprs, vis);\n             vis.visit_span(span);\n         }\n@@ -1589,3 +1595,9 @@ impl DummyAstNode for Crate {\n         }\n     }\n }\n+\n+impl<N: DummyAstNode, T: DummyAstNode> DummyAstNode for crate::ast_traits::AstNodeWrapper<N, T> {\n+    fn dummy() -> Self {\n+        crate::ast_traits::AstNodeWrapper::new(N::dummy(), T::dummy())\n+    }\n+}"}, {"sha": "6f56c1ef0e8daa6ff4e5fad425bd1171a51cc4f6", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -140,6 +140,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr(&mut self, ex: &'ast Expr) {\n         walk_expr(self, ex)\n     }\n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &'ast Expr) {\n+        self.visit_expr(ex)\n+    }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) {}\n     fn visit_ty(&mut self, t: &'ast Ty) {\n         walk_ty(self, t)"}, {"sha": "f1851d7b40ea27a4dae8f979300d4e1892bc926d", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -112,19 +112,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.insert_nested(item.def_id.def_id);\n+        self.insert_nested(item.owner_id.def_id);\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.insert_nested(item_id.def_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.insert_nested(item_id.def_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n-        self.insert_nested(foreign_id.def_id.def_id);\n+        self.insert_nested(foreign_id.owner_id.def_id);\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n@@ -143,7 +143,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n-        debug_assert_eq!(i.def_id, self.owner);\n+        debug_assert_eq!(i.owner_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n             if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n@@ -157,7 +157,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        debug_assert_eq!(fi.def_id, self.owner);\n+        debug_assert_eq!(fi.owner_id, self.owner);\n         self.with_parent(fi.hir_id(), |this| {\n             intravisit::walk_foreign_item(this, fi);\n         });\n@@ -176,15 +176,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        debug_assert_eq!(ti.def_id, self.owner);\n+        debug_assert_eq!(ti.owner_id, self.owner);\n         self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        debug_assert_eq!(ii.def_id, self.owner);\n+        debug_assert_eq!(ii.owner_id, self.owner);\n         self.with_parent(ii.hir_id(), |this| {\n             intravisit::walk_impl_item(this, ii);\n         });"}, {"sha": "76316a574acb7033c2311b45e32d06a84e9f3a2d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -178,7 +178,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n         let mut node_ids =\n-            smallvec![hir::ItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n+            smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -195,7 +195,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n                     vec.push(hir::ItemId {\n-                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n                     });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n@@ -206,7 +206,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n                     vec.push(hir::ItemId {\n-                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n                     });\n                 }\n             }\n@@ -220,7 +220,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, vis_span, &i.kind);\n         let item = hir::Item {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n             vis_span,\n@@ -562,7 +562,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: hir::OwnerId { def_id: new_id },\n+                            owner_id: hir::OwnerId { def_id: new_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -640,7 +640,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: hir::OwnerId { def_id: new_hir_id },\n+                            owner_id: hir::OwnerId { def_id: new_hir_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -660,10 +660,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> &'hir hir::ForeignItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n-        let def_id = hir_id.expect_owner();\n+        let owner_id = hir_id.expect_owner();\n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ForeignItem {\n-            def_id,\n+            owner_id,\n             ident: self.lower_ident(i.ident),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n@@ -702,7 +702,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n+            id: hir::ForeignItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -845,7 +845,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::TraitItem {\n-            def_id: trait_item_def_id,\n+            owner_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n@@ -864,7 +864,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n+        let id = hir::TraitItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n         hir::TraitItemRef {\n             id,\n             ident: self.lower_ident(i.ident),\n@@ -931,7 +931,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ImplItem {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n@@ -944,7 +944,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n+            id: hir::ImplItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             kind: match &i.kind {"}, {"sha": "ff29d15f1b525aae9208cd40bcbc5b15adef37ed", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1574,7 +1574,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n         hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             lifetimes,\n             in_trait,\n         )\n@@ -1593,7 +1593,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            def_id: hir::OwnerId { def_id: opaque_ty_id },\n+            owner_id: hir::OwnerId { def_id: opaque_ty_id },\n             ident: Ident::empty(),\n             kind: opaque_ty_item_kind,\n             vis_span: self.lower_span(span.shrink_to_lo()),\n@@ -2044,7 +2044,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             generic_args,\n             in_trait,\n         );"}, {"sha": "546010135a72532fa0324c2adbaa4bc1a16781c6", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n-use rustc_ast::{PatKind, RangeEnd, VariantData};\n+use rustc_ast::{PatKind, RangeEnd};\n use rustc_errors::{struct_span_err, Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n@@ -116,46 +116,6 @@ impl<'a> PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn maybe_report_invalid_custom_discriminants(&self, variants: &[ast::Variant]) {\n-        let has_fields = variants.iter().any(|variant| match variant.data {\n-            VariantData::Tuple(..) | VariantData::Struct(..) => true,\n-            VariantData::Unit(..) => false,\n-        });\n-\n-        let discriminant_spans = variants\n-            .iter()\n-            .filter(|variant| match variant.data {\n-                VariantData::Tuple(..) | VariantData::Struct(..) => false,\n-                VariantData::Unit(..) => true,\n-            })\n-            .filter_map(|variant| variant.disr_expr.as_ref().map(|c| c.value.span))\n-            .collect::<Vec<_>>();\n-\n-        if !discriminant_spans.is_empty() && has_fields {\n-            let mut err = feature_err(\n-                &self.sess.parse_sess,\n-                sym::arbitrary_enum_discriminant,\n-                discriminant_spans.clone(),\n-                \"custom discriminant values are not allowed in enums with tuple or struct variants\",\n-            );\n-            for sp in discriminant_spans {\n-                err.span_label(sp, \"disallowed custom discriminant\");\n-            }\n-            for variant in variants.iter() {\n-                match &variant.data {\n-                    VariantData::Struct(..) => {\n-                        err.span_label(variant.span, \"struct variant defined here\");\n-                    }\n-                    VariantData::Tuple(..) => {\n-                        err.span_label(variant.span, \"tuple variant defined here\");\n-                    }\n-                    VariantData::Unit(..) => {}\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n-\n     /// Feature gate `impl Trait` inside `type Alias = $type_expr;`.\n     fn check_impl_trait(&self, ty: &ast::Ty) {\n         struct ImplTraitVisitor<'a> {\n@@ -273,26 +233,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemKind::Enum(ast::EnumDef { ref variants, .. }, ..) => {\n-                for variant in variants {\n-                    match (&variant.data, &variant.disr_expr) {\n-                        (ast::VariantData::Unit(..), _) => {}\n-                        (_, Some(disr_expr)) => gate_feature_post!(\n-                            &self,\n-                            arbitrary_enum_discriminant,\n-                            disr_expr.value.span,\n-                            \"discriminants on non-unit variants are experimental\"\n-                        ),\n-                        _ => {}\n-                    }\n-                }\n-\n-                let has_feature = self.features.arbitrary_enum_discriminant;\n-                if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n-                    self.maybe_report_invalid_custom_discriminants(&variants);\n-                }\n-            }\n-\n             ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, ref of_trait, .. }) => {\n                 if let ast::ImplPolarity::Negative(span) = polarity {\n                     gate_feature_post!("}, {"sha": "df04128135b8986c2a976af99df433447e1f1af2", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -92,7 +92,7 @@ pub struct OutlivesConstraint<'tcx> {\n     pub span: Span,\n \n     /// What caused this constraint?\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n \n     /// Variance diagnostic information\n     pub variance_info: VarianceDiagInfo<'tcx>,"}, {"sha": "583bc2e281da4a507f1e06231c08da6bf3cb0ada", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -983,7 +983,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err: &mut Diagnostic,\n         location: Location,\n         issued_borrow: &BorrowData<'tcx>,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) {\n         let used_in_call = matches!(\n             explanation,\n@@ -1333,7 +1333,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n@@ -1539,7 +1539,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         if let BorrowExplanation::MustBeValidFor { category, span, from_closure: false, .. } =\n             explanation\n@@ -1653,7 +1653,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         borrow_span: Span,\n         return_span: Span,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx, ErrorGuaranteed>> {\n         let return_kind = match category {\n@@ -1748,7 +1748,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         use_span: UseSpans<'tcx>,\n         var_span: Span,\n         fr_name: &RegionName,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         constraint_span: Span,\n         captured_var: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {"}, {"sha": "582d683dd359320679164d3aff5c75991122b2a7", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -21,7 +21,7 @@ use crate::{\n use super::{find_use, RegionName, UseSpans};\n \n #[derive(Debug)]\n-pub(crate) enum BorrowExplanation {\n+pub(crate) enum BorrowExplanation<'tcx> {\n     UsedLater(LaterUseKind, Span, Option<Span>),\n     UsedLaterInLoop(LaterUseKind, Span, Option<Span>),\n     UsedLaterWhenDropped {\n@@ -30,7 +30,7 @@ pub(crate) enum BorrowExplanation {\n         should_note_order: bool,\n     },\n     MustBeValidFor {\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         from_closure: bool,\n         span: Span,\n         region_name: RegionName,\n@@ -49,7 +49,7 @@ pub(crate) enum LaterUseKind {\n     Other,\n }\n \n-impl<'tcx> BorrowExplanation {\n+impl<'tcx> BorrowExplanation<'tcx> {\n     pub(crate) fn is_explained(&self) -> bool {\n         !matches!(self, BorrowExplanation::Unexplained)\n     }\n@@ -284,7 +284,7 @@ impl<'tcx> BorrowExplanation {\n     fn add_lifetime_bound_suggestion_to_diagnostic(\n         &self,\n         err: &mut Diagnostic,\n-        category: &ConstraintCategory,\n+        category: &ConstraintCategory<'tcx>,\n         span: Span,\n         region_name: &RegionName,\n     ) {\n@@ -316,7 +316,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n         let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n             borrow_region,\n             NllRegionVariableOrigin::FreeRegion,\n@@ -348,7 +348,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, Place<'tcx>)>,\n-    ) -> BorrowExplanation {\n+    ) -> BorrowExplanation<'tcx> {\n         let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;"}, {"sha": "35c3df768995a0d2907db1cb174122666596a9cc", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -161,7 +161,7 @@ impl OutlivesSuggestionBuilder {\n     pub(crate) fn intermediate_suggestion(\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'_>,\n         diag: &mut Diagnostic,\n     ) {\n         // Emit an intermediate note."}, {"sha": "15230718dc0dee21f140070050507b30338714ae", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2,7 +2,6 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n //! Error reporting machinery for lifetime errors.\n \n-use either::Either;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n@@ -17,7 +16,7 @@ use rustc_infer::infer::{\n     NllRegionVariableOrigin, RelateParamBound,\n };\n use rustc_middle::hir::place::PlaceBase;\n-use rustc_middle::mir::{ConstraintCategory, ReturnConstraint, TerminatorKind};\n+use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n@@ -40,7 +39,7 @@ use crate::{\n     MirBorrowckCtxt,\n };\n \n-impl ConstraintDescription for ConstraintCategory {\n+impl<'tcx> ConstraintDescription for ConstraintCategory<'tcx> {\n     fn description(&self) -> &'static str {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n@@ -116,15 +115,15 @@ pub(crate) enum RegionErrorKind<'tcx> {\n \n /// Information about the various region constraints involved in a borrow checker error.\n #[derive(Clone, Debug)]\n-pub struct ErrorConstraintInfo {\n+pub struct ErrorConstraintInfo<'tcx> {\n     // fr: outlived_fr\n     pub(super) fr: RegionVid,\n     pub(super) fr_is_local: bool,\n     pub(super) outlived_fr: RegionVid,\n     pub(super) outlived_fr_is_local: bool,\n \n     // Category and span for best blame constraint\n-    pub(super) category: ConstraintCategory,\n+    pub(super) category: ConstraintCategory<'tcx>,\n     pub(super) span: Span,\n }\n \n@@ -499,7 +498,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n         kind: ReturnConstraint,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n@@ -572,7 +571,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_data_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n@@ -676,7 +675,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo {\n             fr,\n@@ -789,20 +788,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         diag: &mut Diagnostic,\n         f: Region<'tcx>,\n         o: Region<'tcx>,\n-        category: &ConstraintCategory,\n+        category: &ConstraintCategory<'tcx>,\n     ) {\n         if !o.is_static() {\n             return;\n         }\n \n         let tcx = self.infcx.tcx;\n \n-        let instance =\n-            if let ConstraintCategory::CallArgument(location) = category\n-                && let Either::Right(term) = self.body.stmt_at(*location)\n-                && let TerminatorKind::Call { func, .. } = &term.kind\n-        {\n-            let func_ty = func.ty(self.body, tcx);\n+        let instance = if let ConstraintCategory::CallArgument(Some(func_ty)) = category {\n             let (fn_did, substs) = match func_ty.kind() {\n                 ty::FnDef(fn_did, substs) => (fn_did, substs),\n                 _ => return,"}, {"sha": "8b63294fbab0ee3af1abd29c58269aa2546352e5", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -91,7 +91,7 @@ pub struct RegionInferenceContext<'tcx> {\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n \n     /// Map universe indexes to information on why we created it.\n     universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n@@ -267,7 +267,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n-            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n+            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>,\n         >,\n         universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n@@ -1807,7 +1807,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn retrieve_closure_constraint_info(\n         &self,\n         constraint: OutlivesConstraint<'tcx>,\n-    ) -> Option<(ConstraintCategory, Span)> {\n+    ) -> Option<(ConstraintCategory<'tcx>, Span)> {\n         match constraint.locations {\n             Locations::All(_) => None,\n             Locations::Single(loc) => {\n@@ -1822,7 +1822,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n-    ) -> (ConstraintCategory, ObligationCause<'tcx>) {\n+    ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n         let BlameConstraint { category, cause, .. } = self\n             .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n             .0;\n@@ -2362,7 +2362,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n \n #[derive(Clone, Debug)]\n pub struct BlameConstraint<'tcx> {\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,"}, {"sha": "465f353aaa37f426bdc770213eadb5ea807abbba", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -263,13 +263,11 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n-        match infcx.register_hidden_type(\n-            OpaqueTypeKey { def_id, substs: id_substs },\n-            ObligationCause::misc(instantiated_ty.span, body_id),\n-            param_env,\n-            definition_ty,\n-            origin,\n-        ) {\n+        let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n+        match infcx\n+            .at(&ObligationCause::misc(instantiated_ty.span, body_id), param_env)\n+            .eq(opaque_ty, definition_ty)\n+        {\n             Ok(infer_ok) => {\n                 for obligation in infer_ok.obligations {\n                     fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n@@ -280,7 +278,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     .err_ctxt()\n                     .report_mismatched_types(\n                         &ObligationCause::misc(instantiated_ty.span, body_id),\n-                        self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n+                        opaque_ty,\n                         definition_ty,\n                         err,\n                     )"}, {"sha": "a581726a15c9c4ff6bfc77e9d241074a365b3a62", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         op: Op,\n     ) -> Fallible<R>\n     where\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         trait_ref: ty::TraitRef<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         self.prove_predicate(\n             ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         for predicate in predicates {\n             let predicate = predicate.to_predicate(self.tcx());\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicate: ty::Predicate<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         value: T,\n         location: impl NormalizeLocation,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> T\n     where\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,"}, {"sha": "d5bfc2f520826c7163b12fdd187a6ef6d0bfa17d", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -37,7 +37,7 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n     span: Span,\n-    category: ConstraintCategory,\n+    category: ConstraintCategory<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n@@ -50,7 +50,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         span: Span,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n     ) -> Self {\n         Self {\n@@ -175,7 +175,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         &mut self,\n         sup: ty::RegionVid,\n         sub: ty::RegionVid,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         let category = match self.category {\n             ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n@@ -203,7 +203,7 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        constraint_category: ConstraintCategory,\n+        constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);"}, {"sha": "3c1c3ab45ce7a6639a74211a35be77ce01ddb07c", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -942,7 +942,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n     pub(crate) closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n \n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n@@ -1133,7 +1133,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         data: &QueryRegionConstraints<'tcx>,\n     ) {\n         debug!(\"constraints generated: {:#?}\", data);\n@@ -1158,7 +1158,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         sub: Ty<'tcx>,\n         sup: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         // Use this order of parameters because the sup type is usually the\n         // \"expected\" type in diagnostics.\n@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n@@ -1183,7 +1183,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         user_ty: &UserTypeProjection,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n@@ -1618,12 +1618,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n \n+        let func_ty = if let TerminatorKind::Call { func, .. } = &term.kind {\n+            Some(func.ty(body, self.infcx.tcx))\n+        } else {\n+            None\n+        };\n+        debug!(?func_ty);\n+\n         for (n, (fn_arg, op_arg)) in iter::zip(sig.inputs(), args).enumerate() {\n             let op_arg_ty = op_arg.ty(body, self.tcx());\n \n             let op_arg_ty = self.normalize(op_arg_ty, term_location);\n             let category = if from_hir_call {\n-                ConstraintCategory::CallArgument(term_location)\n+                ConstraintCategory::CallArgument(self.infcx.tcx.erase_regions(func_ty))\n             } else {\n                 ConstraintCategory::Boring\n             };\n@@ -1776,7 +1783,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let erased_ty = tcx.erase_regions(ty);\n-        if !erased_ty.is_sized(tcx.at(span), self.param_env) {\n+        if !erased_ty.is_sized(tcx, self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough"}, {"sha": "4f2dc263bf57b024c138adb9ab90ca41d387b0cb", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,6 +1,6 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::NllRegionVariableOrigin;\n-use rustc_infer::traits::ObligationCause;\n+use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         b: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         TypeRelating::new(\n             self.infcx,\n@@ -45,7 +45,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         a: ty::SubstsRef<'tcx>,\n         b: ty::SubstsRef<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         TypeRelating::new(\n             self.infcx,\n@@ -64,7 +64,7 @@ struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     locations: Locations,\n \n     /// What category do we assign the resulting `'a: 'b` relationships?\n-    category: ConstraintCategory,\n+    category: ConstraintCategory<'tcx>,\n \n     /// Information so that error reporting knows what types we are relating\n     /// when reporting a bound region error.\n@@ -75,7 +75,7 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     fn new(\n         type_checker: &'me mut TypeChecker<'bccx, 'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         universe_info: UniverseInfo<'tcx>,\n     ) -> Self {\n         Self { type_checker, locations, category, universe_info }\n@@ -155,27 +155,16 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         true\n     }\n \n-    fn register_opaque_type(\n+    fn register_opaque_type_obligations(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n+        obligations: PredicateObligations<'tcx>,\n     ) -> Result<(), TypeError<'tcx>> {\n-        let param_env = self.param_env();\n-        let span = self.span();\n-        let def_id = self.type_checker.body.source.def_id().expect_local();\n-        let body_id = self.type_checker.tcx().hir().local_def_id_to_hir_id(def_id);\n-        let cause = ObligationCause::misc(span, body_id);\n         self.type_checker\n             .fully_perform_op(\n                 self.locations,\n                 self.category,\n                 InstantiateOpaqueType {\n-                    obligations: self\n-                        .type_checker\n-                        .infcx\n-                        .handle_opaque_type(a, b, a_is_expected, &cause, param_env)?\n-                        .obligations,\n+                    obligations,\n                     // These fields are filled in during execution of the operation\n                     base_universe: None,\n                     region_constraints: None,"}, {"sha": "750f1fe121f6d90a368ee38a7a4f7b3bc0a1aa66", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -210,8 +210,15 @@ impl CfgEval<'_, '_> {\n }\n \n impl MutVisitor for CfgEval<'_, '_> {\n+    #[instrument(level = \"trace\", skip(self))]\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.cfg.configure_expr(expr);\n+        self.cfg.configure_expr(expr, false);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_method_receiver_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr, true);\n         mut_visit::noop_visit_expr(expr, self);\n     }\n "}, {"sha": "1db44502742e921b4bcbbdff9d76bce7e1e5e849", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -770,11 +770,7 @@ fn codegen_stmt<'tcx>(\n                     lval.write_cvalue(fx, CValue::by_val(operand, box_layout));\n                 }\n                 Rvalue::NullaryOp(null_op, ty) => {\n-                    assert!(\n-                        lval.layout()\n-                            .ty\n-                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n-                    );\n+                    assert!(lval.layout().ty.is_sized(fx.tcx, ParamEnv::reveal_all()));\n                     let layout = fx.layout_of(fx.monomorphize(ty));\n                     let val = match null_op {\n                         NullOp::SizeOf => layout.size.bytes(),"}, {"sha": "148b66d959e8a74126c5fdde83eb48f3a3de1290", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n-use rustc_span::DUMMY_SP;\n \n use cranelift_module::*;\n \n@@ -291,7 +290,7 @@ fn data_id_for_static(\n     let is_mutable = if tcx.is_mutable_static(def_id) {\n         true\n     } else {\n-        !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+        !ty.is_freeze(tcx, ParamEnv::reveal_all())\n     };\n     let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n "}, {"sha": "bdc6a91cf6ab5f411cd61602e2920212dfb228eb", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -5,7 +5,6 @@ use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n use rustc_target::abi::{AddressSpace, Integer};\n \n@@ -75,16 +74,16 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_sized(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_freeze(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n         let param_env = ty::ParamEnv::reveal_all();\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), param_env) {\n+        if ty.is_sized(self.tcx(), param_env) {\n             return false;\n         }\n "}, {"sha": "f1674d04f8d15f16be1f3011eaead81daad003e7", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 16, "deletions": 56, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -25,10 +25,12 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n /// report whether said intrinsic has a `rustc_const_{un,}stable` attribute. Otherwise, return\n /// `Constness::NotConst`.\n fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    match tcx.hir().get(hir_id) {\n-        hir::Node::Ctor(_) => hir::Constness::Const,\n+    let def_id = def_id.expect_local();\n+    let node = tcx.hir().get_by_def_id(def_id);\n \n+    match node {\n+        hir::Node::Ctor(_) => hir::Constness::Const,\n+        hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.constness,\n         hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) => {\n             // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n             // foreign items cannot be evaluated at compile-time.\n@@ -39,62 +41,20 @@ fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n             };\n             if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n         }\n+        _ => {\n+            if let Some(fn_kind) = node.fn_kind() {\n+                if fn_kind.constness() == hir::Constness::Const {\n+                    return hir::Constness::Const;\n+                }\n \n-        hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n-            if tcx.is_const_default_method(def_id) =>\n-        {\n-            hir::Constness::Const\n-        }\n-\n-        hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(..), .. })\n-        | hir::Node::Item(hir::Item { kind: hir::ItemKind::Static(..), .. })\n-        | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Const(..), .. })\n-        | hir::Node::AnonConst(_)\n-        | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n-        | hir::Node::ImplItem(hir::ImplItem {\n-            kind:\n-                hir::ImplItemKind::Fn(\n-                    hir::FnSig {\n-                        header: hir::FnHeader { constness: hir::Constness::Const, .. },\n-                        ..\n-                    },\n-                    ..,\n-                ),\n-            ..\n-        }) => hir::Constness::Const,\n-\n-        hir::Node::ImplItem(hir::ImplItem {\n-            kind: hir::ImplItemKind::Type(..) | hir::ImplItemKind::Fn(..),\n-            ..\n-        }) => {\n-            let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n-            match tcx.hir().get(parent_hir_id) {\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n-                    ..\n-                }) => *constness,\n-                _ => span_bug!(\n-                    tcx.def_span(parent_hir_id.owner),\n-                    \"impl item's parent node is not an impl\",\n-                ),\n+                // If the function itself is not annotated with `const`, it may still be a `const fn`\n+                // if it resides in a const trait impl.\n+                let is_const = is_parent_const_impl_raw(tcx, def_id);\n+                if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n+            } else {\n+                hir::Constness::NotConst\n             }\n         }\n-\n-        hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n-            ..\n-        })\n-        | hir::Node::TraitItem(hir::TraitItem {\n-            kind:\n-                hir::TraitItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n-            ..\n-        })\n-        | hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n-            ..\n-        }) => *constness,\n-\n-        _ => hir::Constness::NotConst,\n     }\n }\n "}, {"sha": "35d58d2f638bfceb56d3699deba074b0c8bcc76c", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2,10 +2,10 @@ use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::borrow::Borrow;\n-use std::collections::hash_map::Entry;\n use std::hash::Hash;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::IndexEntry;\n use std::fmt;\n \n use rustc_ast::Mutability;\n@@ -107,26 +107,26 @@ impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     }\n }\n \n-impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n+impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxIndexMap<K, V> {\n     #[inline(always)]\n     fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n     where\n         K: Borrow<Q>,\n     {\n-        FxHashMap::contains_key(self, k)\n+        FxIndexMap::contains_key(self, k)\n     }\n \n     #[inline(always)]\n     fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        FxHashMap::insert(self, k, v)\n+        FxIndexMap::insert(self, k, v)\n     }\n \n     #[inline(always)]\n     fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n     where\n         K: Borrow<Q>,\n     {\n-        FxHashMap::remove(self, k)\n+        FxIndexMap::remove(self, k)\n     }\n \n     #[inline(always)]\n@@ -148,8 +148,8 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     #[inline(always)]\n     fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n         match self.entry(k) {\n-            Entry::Occupied(e) => Ok(e.into_mut()),\n-            Entry::Vacant(e) => {\n+            IndexEntry::Occupied(e) => Ok(e.into_mut()),\n+            IndexEntry::Vacant(e) => {\n                 let v = vacant()?;\n                 Ok(e.insert(v))\n             }"}, {"sha": "f4da11883957a73f0376d35c2202c659a2d1a8ab", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -212,7 +212,7 @@ fn create_pointee_place<'tcx>(\n ) -> MPlaceTy<'tcx> {\n     let tcx = ecx.tcx.tcx;\n \n-    if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n+    if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty()) {\n         // We need to create `Allocation`s for custom DSTs\n \n         let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n@@ -398,7 +398,7 @@ fn valtree_into_mplace<'tcx>(\n \n                 let mut place_inner = match ty.kind() {\n                     ty::Str | ty::Slice(_) => ecx.mplace_index(&place, i as u64).unwrap(),\n-                    _ if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty())\n+                    _ if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty())\n                         && i == branches.len() - 1 =>\n                     {\n                         // Note: For custom DSTs we need to manually process the last unsized field."}, {"sha": "269ae15d4974547f929544764313ce900982ecc0", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -138,23 +138,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    /// Handles 'IntToInt' and 'IntToFloat' casts.\n     pub fn int_to_int_or_float(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n-        if (src.layout.ty.is_integral() || src.layout.ty.is_char() || src.layout.ty.is_bool())\n-            && (cast_ty.is_floating_point() || cast_ty.is_integral() || cast_ty.is_char())\n-        {\n-            let scalar = src.to_scalar();\n-            Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n-        } else {\n-            bug!(\"Unexpected cast from type {:?}\", src.layout.ty)\n-        }\n+        assert!(src.layout.ty.is_integral() || src.layout.ty.is_char() || src.layout.ty.is_bool());\n+        assert!(cast_ty.is_floating_point() || cast_ty.is_integral() || cast_ty.is_char());\n+\n+        Ok(self.cast_from_int_like(src.to_scalar(), src.layout, cast_ty)?.into())\n     }\n \n+    /// Handles 'FloatToFloat' and 'FloatToInt' casts.\n     pub fn float_to_float_or_int(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n@@ -176,35 +174,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Handles 'FnPtrToPtr' and 'PtrToPtr' casts.\n     pub fn ptr_to_ptr(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n+        assert!(src.layout.ty.is_any_ptr());\n+        assert!(cast_ty.is_unsafe_ptr());\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n-        if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n-            let dest_layout = self.layout_of(cast_ty)?;\n-            if dest_layout.size == src.layout.size {\n-                // Thin or fat pointer that just hast the ptr kind of target type changed.\n-                return Ok(**src);\n-            } else {\n-                // Casting the metadata away from a fat ptr.\n-                assert_eq!(src.layout.size, 2 * self.pointer_size());\n-                assert_eq!(dest_layout.size, self.pointer_size());\n-                assert!(src.layout.ty.is_unsafe_ptr());\n-                return match **src {\n-                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n-                    Immediate::Scalar(..) => span_bug!(\n-                        self.cur_span(),\n-                        \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n-                        *src,\n-                        src.layout.ty,\n-                        cast_ty\n-                    ),\n-                    Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n-                };\n-            }\n+        let dest_layout = self.layout_of(cast_ty)?;\n+        if dest_layout.size == src.layout.size {\n+            // Thin or fat pointer that just hast the ptr kind of target type changed.\n+            return Ok(**src);\n         } else {\n-            bug!(\"Can't cast 'Ptr' or 'FnPtr' into {:?}\", cast_ty);\n+            // Casting the metadata away from a fat ptr.\n+            assert_eq!(src.layout.size, 2 * self.pointer_size());\n+            assert_eq!(dest_layout.size, self.pointer_size());\n+            assert!(src.layout.ty.is_unsafe_ptr());\n+            return match **src {\n+                Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                Immediate::Scalar(..) => span_bug!(\n+                    self.cur_span(),\n+                    \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n+                    *src,\n+                    src.layout.ty,\n+                    cast_ty\n+                ),\n+                Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n+            };\n         }\n     }\n \n@@ -226,7 +222,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn pointer_from_exposed_address_cast(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n@@ -243,6 +239,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(Scalar::from_maybe_pointer(ptr, self).into())\n     }\n \n+    /// Low-level cast helper function. This works directly on scalars and can take 'int-like' input\n+    /// type (basically everything with a scalar layout) to int/float/char types.\n     pub fn cast_from_int_like(\n         &self,\n         scalar: Scalar<M::Provenance>, // input value (there is no ScalarTy so we separate data+layout)\n@@ -282,6 +280,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n+    /// Low-level cast helper function. Converts an apfloat `f` into int or float types.\n     fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::Provenance>\n     where\n         F: Float + Into<Scalar<M::Provenance>> + FloatConvert<Single> + FloatConvert<Double>,"}, {"sha": "a9063ad31cfe65c8b9d631888538b076eeeb9cdd", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -468,7 +468,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, self.param_env)\n+        ty.is_freeze(*self.tcx, self.param_env)\n     }\n \n     pub fn load_mir("}, {"sha": "6809a42dc45364b78a5fecbc3bfa218f304daec9", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -15,7 +15,7 @@\n //! that contains allocations whose mutability we cannot identify.)\n \n use super::validity::RefTracking;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n@@ -37,7 +37,7 @@ pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n     ExtraFnVal = !,\n     FrameExtra = (),\n     AllocExtra = (),\n-    MemoryMap = FxHashMap<AllocId, (MemoryKind<T>, Allocation)>,\n+    MemoryMap = FxIndexMap<AllocId, (MemoryKind<T>, Allocation)>,\n >;\n \n struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>> {\n@@ -47,7 +47,7 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_ev\n     ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, InternMode)>,\n     /// A list of all encountered allocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n-    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n+    leftover_allocations: &'rt mut FxIndexSet<AllocId>,\n     /// The root kind of the value that we're looking at. This field is never mutated for a\n     /// particular allocation. It is primarily used to make as many allocations as possible\n     /// read-only so LLVM can place them in const memory.\n@@ -79,7 +79,7 @@ struct IsStaticOrFn;\n /// to account for (e.g. for vtables).\n fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>>(\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n-    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n+    leftover_allocations: &'rt mut FxIndexSet<AllocId>,\n     alloc_id: AllocId,\n     mode: InternMode,\n     ty: Option<Ty<'tcx>>,\n@@ -114,7 +114,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env));\n         // For statics, allocation mutability is the combination of place mutability and\n         // type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n@@ -355,7 +355,7 @@ pub fn intern_const_alloc_recursive<\n     // `leftover_allocations` collects *all* allocations we see, because some might not\n     // be available in a typed way. They get interned at the end.\n     let mut ref_tracking = RefTracking::empty();\n-    let leftover_allocations = &mut FxHashSet::default();\n+    let leftover_allocations = &mut FxIndexSet::default();\n \n     // start with the outermost allocation\n     intern_shallow("}, {"sha": "ffdb8de5b6c8c355b1fad36cb5b0e09f20932f67", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::definitions::DisambiguatedDefPathData;\n use rustc_middle::mir::interpret::{Allocation, ConstAllocation};\n use rustc_middle::ty::{\n     self,\n-    print::{PrettyPrinter, Print, Printer},\n+    print::{with_no_verbose_constants, PrettyPrinter, Print, Printer},\n     subst::{GenericArg, GenericArgKind},\n     Ty, TyCtxt,\n };\n@@ -190,7 +190,9 @@ impl Write for AbsolutePathPrinter<'_> {\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n-    let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n+    let path = with_no_verbose_constants!(\n+        AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path\n+    );\n     let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n     tcx.intern_const_alloc(alloc)\n }"}, {"sha": "351152eba01f6ae219c2034ff8ffacb37b0ca054", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -426,7 +426,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type ExtraFnVal = !;\n \n     type MemoryMap =\n-        rustc_data_structures::fx::FxHashMap<AllocId, (MemoryKind<Self::MemoryKind>, Allocation)>;\n+        rustc_data_structures::fx::FxIndexMap<AllocId, (MemoryKind<Self::MemoryKind>, Allocation)>;\n     const GLOBAL_KIND: Option<Self::MemoryKind> = None; // no copying of globals from `tcx` to machine memory\n \n     type AllocExtra = ();"}, {"sha": "0c212cf59e17fe1d5b2e26eccd8fa04699289a8c", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -554,6 +554,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         val: &mir::ConstantKind<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n+        // FIXME(const_prop): normalization needed b/c const prop lint in\n+        // `mir_drops_elaborated_and_const_checked`, which happens before\n+        // optimized MIR. Only after optimizing the MIR can we guarantee\n+        // that the `RevealAll` pass has happened and that the body's consts\n+        // are normalized, so any call to resolve before that needs to be\n+        // manually normalized.\n+        let val = self.tcx.normalize_erasing_regions(self.param_env, *val);\n         match val {\n             mir::ConstantKind::Ty(ct) => {\n                 match ct.kind() {\n@@ -585,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n             }\n-            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n+            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(val, ty, layout),\n             mir::ConstantKind::Unevaluated(uv, _) => {\n                 let instance = self.resolve(uv.def, uv.substs)?;\n                 Ok(self.eval_to_allocation(GlobalId { instance, promoted: uv.promoted })?.into())"}, {"sha": "8aa56c275d91b93c51b1618c87687a9146ca57c7", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, WrappingRange};\n \n use std::hash::Hash;\n@@ -726,7 +725,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         // Special check preventing `UnsafeCell` inside unions in the inner part of constants.\n         if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. })) {\n-            if !op.layout.ty.is_freeze(self.ecx.tcx.at(DUMMY_SP), self.ecx.param_env) {\n+            if !op.layout.ty.is_freeze(*self.ecx.tcx, self.ecx.param_env) {\n                 throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n             }\n         }"}, {"sha": "443c01fdb90c6d474658ab38a417a2e5a6e2665b", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -22,7 +22,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(yeet_expr)]\n #![feature(is_some_and)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "335992342a64756e393398380fea985ca93cbf6b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -8,7 +8,6 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n     self, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n@@ -92,7 +91,7 @@ impl Qualif for HasMutInterior {\n     }\n \n     fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-        !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+        !ty.is_freeze(cx.tcx, cx.param_env)\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "805e6096b35c8577c2a033d3f999f26c462c5a55", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -8,7 +8,6 @@ use rustc_middle::mir::{self, BasicBlock, Local, Location, Statement, StatementK\n use rustc_mir_dataflow::fmt::DebugWithContext;\n use rustc_mir_dataflow::JoinSemiLattice;\n use rustc_mir_dataflow::{Analysis, AnalysisDomain, CallReturnPlaces};\n-use rustc_span::DUMMY_SP;\n \n use std::fmt;\n use std::marker::PhantomData;\n@@ -120,10 +119,7 @@ where\n     ///\n     /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n     fn shared_borrow_allows_mutation(&self, place: mir::Place<'tcx>) -> bool {\n-        !place\n-            .ty(self.ccx.body, self.ccx.tcx)\n-            .ty\n-            .is_freeze(self.ccx.tcx.at(DUMMY_SP), self.ccx.param_env)\n+        !place.ty(self.ccx.body, self.ccx.tcx).ty.is_freeze(self.ccx.tcx, self.ccx.param_env)\n     }\n }\n "}, {"sha": "f3ae16da43bd1062ba2ae3b303b53a886321f13a", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -41,10 +41,6 @@ pub struct PromoteTemps<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::Analysis(AnalysisPhase::Initial))\n-    }\n-\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         //"}, {"sha": "81b82a21fa1a7276796672a3980784bad79869ed", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -235,9 +235,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             // `Operand::Copy` is only supposed to be used with `Copy` types.\n             if let Operand::Copy(place) = operand {\n                 let ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-                let span = self.body.source_info(location).span;\n \n-                if !ty.is_copy_modulo_regions(self.tcx.at(span), self.param_env) {\n+                if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n                     self.fail(location, format!(\"`Operand::Copy` with non-`Copy` type {}\", ty));\n                 }\n             }"}, {"sha": "3a2000233c5d10fac7150e1956b2e33f7a9a7042", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -22,6 +22,7 @@\n #![feature(new_uninit)]\n #![feature(once_cell)]\n #![feature(rustc_attrs)]\n+#![feature(negative_impls)]\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n@@ -86,6 +87,7 @@ pub mod steal;\n pub mod tagged_ptr;\n pub mod temp_dir;\n pub mod unhash;\n+pub mod unord;\n \n pub use ena::undo_log;\n pub use ena::unify;"}, {"sha": "c015f1232cd927c74ec8c968c1328985940a693a", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,382 @@\n+//! This module contains collection types that don't expose their internal\n+//! ordering. This is a useful property for deterministic computations, such\n+//! as required by the query system.\n+\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::SmallVec;\n+use std::{\n+    borrow::Borrow,\n+    hash::Hash,\n+    iter::{Product, Sum},\n+};\n+\n+use crate::{\n+    fingerprint::Fingerprint,\n+    stable_hasher::{HashStable, StableHasher, ToStableHashKey},\n+};\n+\n+/// `UnordItems` is the order-less version of `Iterator`. It only contains methods\n+/// that don't (easily) expose an ordering of the underlying items.\n+///\n+/// Most methods take an `Fn` where the `Iterator`-version takes an `FnMut`. This\n+/// is to reduce the risk of accidentally leaking the internal order via the closure\n+/// environment. Otherwise one could easily do something like\n+///\n+/// ```rust,ignore (pseudo code)\n+/// let mut ordered = vec![];\n+/// unordered_items.all(|x| ordered.push(x));\n+/// ```\n+///\n+/// It's still possible to do the same thing with an `Fn` by using interior mutability,\n+/// but the chance of doing it accidentally is reduced.\n+pub struct UnordItems<T, I: Iterator<Item = T>>(I);\n+\n+impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n+    #[inline]\n+    pub fn map<U, F: Fn(T) -> U>(self, f: F) -> UnordItems<U, impl Iterator<Item = U>> {\n+        UnordItems(self.0.map(f))\n+    }\n+\n+    #[inline]\n+    pub fn all<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+        self.0.all(f)\n+    }\n+\n+    #[inline]\n+    pub fn any<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+        self.0.any(f)\n+    }\n+\n+    #[inline]\n+    pub fn filter<U, F: Fn(&T) -> bool>(self, f: F) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.filter(f))\n+    }\n+\n+    #[inline]\n+    pub fn filter_map<U, F: Fn(T) -> Option<U>>(\n+        self,\n+        f: F,\n+    ) -> UnordItems<U, impl Iterator<Item = U>> {\n+        UnordItems(self.0.filter_map(f))\n+    }\n+\n+    #[inline]\n+    pub fn max(self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n+        self.0.max()\n+    }\n+\n+    #[inline]\n+    pub fn min(self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n+        self.0.min()\n+    }\n+\n+    #[inline]\n+    pub fn sum<S>(self) -> S\n+    where\n+        S: Sum<T>,\n+    {\n+        self.0.sum()\n+    }\n+\n+    #[inline]\n+    pub fn product<S>(self) -> S\n+    where\n+        S: Product<T>,\n+    {\n+        self.0.product()\n+    }\n+\n+    #[inline]\n+    pub fn count(self) -> usize {\n+        self.0.count()\n+    }\n+}\n+\n+impl<'a, T: Clone + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n+    #[inline]\n+    pub fn cloned(self) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.cloned())\n+    }\n+}\n+\n+impl<'a, T: Copy + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n+    #[inline]\n+    pub fn copied(self) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.copied())\n+    }\n+}\n+\n+impl<T: Ord, I: Iterator<Item = T>> UnordItems<T, I> {\n+    pub fn into_sorted<HCX>(self, hcx: &HCX) -> Vec<T>\n+    where\n+        T: ToStableHashKey<HCX>,\n+    {\n+        let mut items: Vec<T> = self.0.collect();\n+        items.sort_by_cached_key(|x| x.to_stable_hash_key(hcx));\n+        items\n+    }\n+\n+    pub fn into_sorted_small_vec<HCX, const LEN: usize>(self, hcx: &HCX) -> SmallVec<[T; LEN]>\n+    where\n+        T: ToStableHashKey<HCX>,\n+    {\n+        let mut items: SmallVec<[T; LEN]> = self.0.collect();\n+        items.sort_by_cached_key(|x| x.to_stable_hash_key(hcx));\n+        items\n+    }\n+}\n+\n+/// This is a set collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for set-like collections the\n+/// keys of which don't have a semantic ordering.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordSet<V: Eq + Hash> {\n+    inner: FxHashSet<V>,\n+}\n+\n+impl<V: Eq + Hash> Default for UnordSet<V> {\n+    fn default() -> Self {\n+        Self { inner: FxHashSet::default() }\n+    }\n+}\n+\n+impl<V: Eq + Hash> UnordSet<V> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { inner: Default::default() }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, v: V) -> bool {\n+        self.inner.insert(v)\n+    }\n+\n+    #[inline]\n+    pub fn contains<Q: ?Sized>(&self, v: &Q) -> bool\n+    where\n+        V: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.contains(v)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<V, impl Iterator<Item = V>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordSet from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<V: Hash + Eq> Extend<V> for UnordSet<V> {\n+    fn extend<T: IntoIterator<Item = V>>(&mut self, iter: T) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordSet<V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+/// This is a map collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for map-like collections the\n+/// keys of which don't have a semantic ordering.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordMap<K: Eq + Hash, V> {\n+    inner: FxHashMap<K, V>,\n+}\n+\n+impl<K: Eq + Hash, V> Default for UnordMap<K, V> {\n+    fn default() -> Self {\n+        Self { inner: FxHashMap::default() }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> Extend<(K, V)> for UnordMap<K, V> {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> UnordMap<K, V> {\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        self.inner.insert(k, v)\n+    }\n+\n+    #[inline]\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.contains_key(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<(K, V), impl Iterator<Item = (K, V)>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordMap from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = (K, V)>>(&mut self, items: UnordItems<(K, V), I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<HCX, K: Hash + Eq + HashStable<HCX>, V: HashStable<HCX>> HashStable<HCX> for UnordMap<K, V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+/// This is a collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for collections the\n+/// keys of which don't have a semantic ordering and don't implement\n+/// `Hash` or `Eq`.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Default, Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordBag<V> {\n+    inner: Vec<V>,\n+}\n+\n+impl<V> UnordBag<V> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { inner: Default::default() }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn push(&mut self, v: V) {\n+        self.inner.push(v);\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<V, impl Iterator<Item = V>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordSet from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<T> Extend<T> for UnordBag<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordBag<V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+fn hash_iter_order_independent<\n+    HCX,\n+    T: HashStable<HCX>,\n+    I: Iterator<Item = T> + ExactSizeIterator,\n+>(\n+    mut it: I,\n+    hcx: &mut HCX,\n+    hasher: &mut StableHasher,\n+) {\n+    let len = it.len();\n+    len.hash_stable(hcx, hasher);\n+\n+    match len {\n+        0 => {\n+            // We're done\n+        }\n+        1 => {\n+            // No need to instantiate a hasher\n+            it.next().unwrap().hash_stable(hcx, hasher);\n+        }\n+        _ => {\n+            let mut accumulator = Fingerprint::ZERO;\n+            for item in it {\n+                let mut item_hasher = StableHasher::new();\n+                item.hash_stable(hcx, &mut item_hasher);\n+                let item_fingerprint: Fingerprint = item_hasher.finish();\n+                accumulator = accumulator.combine_commutative(item_fingerprint);\n+            }\n+            accumulator.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+// Do not implement IntoIterator for the collections in this module.\n+// They only exist to hide iteration order in the first place.\n+impl<T> !IntoIterator for UnordBag<T> {}\n+impl<V> !IntoIterator for UnordSet<V> {}\n+impl<K, V> !IntoIterator for UnordMap<K, V> {}\n+impl<T, I> !IntoIterator for UnordItems<T, I> {}"}, {"sha": "cfa734c7df39c331a9eb39b1a482d003f9f6d62d", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -427,18 +427,6 @@ fn run_compiler(\n     })\n }\n \n-#[cfg(unix)]\n-pub fn set_sigpipe_handler() {\n-    unsafe {\n-        // Set the SIGPIPE signal handler, so that an EPIPE\n-        // will cause rustc to terminate, as expected.\n-        assert_ne!(libc::signal(libc::SIGPIPE, libc::SIG_DFL), libc::SIG_ERR);\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn set_sigpipe_handler() {}\n-\n // Extract output directory and file from matches.\n fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n     let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));"}, {"sha": "9536fdbf0df87362eac7e509c289361d8be95c73", "filename": "compiler/rustc_error_codes/src/error_codes/E0732.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0732.md", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0732.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0732.md?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -3,8 +3,6 @@ An `enum` with a discriminant must specify a `#[repr(inttype)]`.\n Erroneous code example:\n \n ```compile_fail,E0732\n-#![feature(arbitrary_enum_discriminant)]\n-\n enum Enum { // error!\n     Unit = 1,\n     Tuple() = 2,\n@@ -20,8 +18,6 @@ is a well-defined way to extract a variant's discriminant from a value;\n for instance:\n \n ```\n-#![feature(arbitrary_enum_discriminant)]\n-\n #[repr(u8)]\n enum Enum {\n     Unit = 3,"}, {"sha": "74088f4dfbe70d46b03b4a96a554a0c216e32d62", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -93,7 +93,7 @@ hir_analysis_expected_default_return_type = expected `()` because of default ret\n hir_analysis_expected_return_type = expected `{$expected}` because of return type\n \n hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n-    .note = `{$name}` must be used in combination with a concrete type within the same module\n+    .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n \n hir_analysis_missing_type_params =\n     the type {$parameterCount ->\n@@ -137,3 +137,16 @@ hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(l\n hir_analysis_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n \n hir_analysis_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n+\n+hir_analysis_const_impl_for_non_const_trait =\n+    const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n+    .suggestion = mark `{$trait_name}` as const\n+    .note = marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+    .adding = adding a non-const method body in the future would be a breaking change\n+\n+hir_analysis_const_bound_for_non_const_trait =\n+    ~const can only be applied to `#[const_trait]` traits\n+\n+hir_analysis_self_in_impl_self =\n+    `Self` is not valid in the self type of an impl block\n+    .note = replace `Self` with a different type"}, {"sha": "23f29a24fe79feb71a6385d2dde8f4062a71ab12", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -690,6 +690,24 @@ impl Diagnostic {\n         msg: impl Into<SubdiagnosticMessage>,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n+    ) -> &mut Self {\n+        self.span_suggestions_with_style(\n+            sp,\n+            msg,\n+            suggestions,\n+            applicability,\n+            SuggestionStyle::ShowCode,\n+        )\n+    }\n+\n+    /// [`Diagnostic::span_suggestions()`] but you can set the [`SuggestionStyle`].\n+    pub fn span_suggestions_with_style(\n+        &mut self,\n+        sp: Span,\n+        msg: impl Into<SubdiagnosticMessage>,\n+        suggestions: impl Iterator<Item = String>,\n+        applicability: Applicability,\n+        style: SuggestionStyle,\n     ) -> &mut Self {\n         let mut suggestions: Vec<_> = suggestions.collect();\n         suggestions.sort();\n@@ -706,14 +724,15 @@ impl Diagnostic {\n         self.push_suggestion(CodeSuggestion {\n             substitutions,\n             msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n-            style: SuggestionStyle::ShowCode,\n+            style,\n             applicability,\n         });\n         self\n     }\n \n-    /// Prints out a message with multiple suggested edits of the code.\n-    /// See also [`Diagnostic::span_suggestion()`].\n+    /// Prints out a message with multiple suggested edits of the code, where each edit consists of\n+    /// multiple parts.\n+    /// See also [`Diagnostic::multipart_suggestion()`].\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: impl Into<SubdiagnosticMessage>,\n@@ -745,6 +764,7 @@ impl Diagnostic {\n         });\n         self\n     }\n+\n     /// Prints out a message with a suggested edit of the code. If the suggestion is presented\n     /// inline, it will only show the message and not the suggestion.\n     ///"}, {"sha": "1d2b1298a68f6372dca41d0bf71b0241636eda44", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -469,6 +469,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`\n+    #[instrument(level = \"trace\", skip(self))]\n     pub(crate) fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n@@ -486,9 +487,12 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_expr(&self, expr: &mut P<ast::Expr>) {\n-        for attr in expr.attrs.iter() {\n-            self.maybe_emit_expr_attr_err(attr);\n+    #[instrument(level = \"trace\", skip(self))]\n+    pub fn configure_expr(&self, expr: &mut P<ast::Expr>, method_receiver: bool) {\n+        if !method_receiver {\n+            for attr in expr.attrs.iter() {\n+                self.maybe_emit_expr_attr_err(attr);\n+            }\n         }\n \n         // If an expr is valid to cfg away it will have been removed by the"}, {"sha": "57713fb3cd61d59c7a2f33fdc46d8938b7eafb17", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -50,20 +50,23 @@ macro_rules! ast_fragments {\n         /// Can also serve as an input and intermediate result for macro expansion operations.\n         pub enum AstFragment {\n             OptExpr(Option<P<ast::Expr>>),\n+            MethodReceiverExpr(P<ast::Expr>),\n             $($Kind($AstTy),)*\n         }\n \n         /// \"Discriminant\" of an AST fragment.\n         #[derive(Copy, Clone, PartialEq, Eq)]\n         pub enum AstFragmentKind {\n             OptExpr,\n+            MethodReceiverExpr,\n             $($Kind,)*\n         }\n \n         impl AstFragmentKind {\n             pub fn name(self) -> &'static str {\n                 match self {\n                     AstFragmentKind::OptExpr => \"expression\",\n+                    AstFragmentKind::MethodReceiverExpr => \"expression\",\n                     $(AstFragmentKind::$Kind => $kind_name,)*\n                 }\n             }\n@@ -72,6 +75,8 @@ macro_rules! ast_fragments {\n                 match self {\n                     AstFragmentKind::OptExpr =>\n                         result.make_expr().map(Some).map(AstFragment::OptExpr),\n+                    AstFragmentKind::MethodReceiverExpr =>\n+                        result.make_expr().map(AstFragment::MethodReceiverExpr),\n                     $(AstFragmentKind::$Kind => result.$make_ast().map(AstFragment::$Kind),)*\n                 }\n             }\n@@ -98,6 +103,13 @@ macro_rules! ast_fragments {\n                 }\n             }\n \n+            pub fn make_method_receiver_expr(self) -> P<ast::Expr> {\n+                match self {\n+                    AstFragment::MethodReceiverExpr(expr) => expr,\n+                    _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n+                }\n+            }\n+\n             $(pub fn $make_ast(self) -> $AstTy {\n                 match self {\n                     AstFragment::$Kind(ast) => ast,\n@@ -120,6 +132,7 @@ macro_rules! ast_fragments {\n                             }\n                         });\n                     }\n+                    AstFragment::MethodReceiverExpr(expr) => vis.visit_method_receiver_expr(expr),\n                     $($(AstFragment::$Kind(ast) => vis.$mut_visit_ast(ast),)?)*\n                     $($(AstFragment::$Kind(ast) =>\n                         ast.flat_map_in_place(|ast| vis.$flat_map_ast_elt(ast)),)?)*\n@@ -130,6 +143,7 @@ macro_rules! ast_fragments {\n                 match *self {\n                     AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n+                    AstFragment::MethodReceiverExpr(ref expr) => visitor.visit_method_receiver_expr(expr),\n                     $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n                     $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt, $($args)*);\n@@ -222,6 +236,7 @@ impl AstFragmentKind {\n         match self {\n             AstFragmentKind::OptExpr\n             | AstFragmentKind::Expr\n+            | AstFragmentKind::MethodReceiverExpr\n             | AstFragmentKind::Stmts\n             | AstFragmentKind::Ty\n             | AstFragmentKind::Pat => SupportsMacroExpansion::Yes { supports_inner_attrs: false },\n@@ -285,6 +300,9 @@ impl AstFragmentKind {\n             AstFragmentKind::Expr => AstFragment::Expr(\n                 items.next().expect(\"expected exactly one expression\").expect_expr(),\n             ),\n+            AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(\n+                items.next().expect(\"expected exactly one expression\").expect_expr(),\n+            ),\n             AstFragmentKind::OptExpr => {\n                 AstFragment::OptExpr(items.next().map(Annotatable::expect_expr))\n             }\n@@ -893,6 +911,7 @@ pub fn parse_ast_fragment<'a>(\n             AstFragment::Stmts(stmts)\n         }\n         AstFragmentKind::Expr => AstFragment::Expr(this.parse_expr()?),\n+        AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(this.parse_expr()?),\n         AstFragmentKind::OptExpr => {\n             if this.token != token::Eof {\n                 AstFragment::OptExpr(Some(this.parse_expr()?))\n@@ -1477,6 +1496,42 @@ impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, OptExprTag> {\n     }\n }\n \n+/// This struct is a hack to workaround unstable of `stmt_expr_attributes`.\n+/// It can be removed once that feature is stabilized.\n+struct MethodReceiverTag;\n+impl DummyAstNode for MethodReceiverTag {\n+    fn dummy() -> MethodReceiverTag {\n+        MethodReceiverTag\n+    }\n+}\n+impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, MethodReceiverTag> {\n+    type OutputTy = Self;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::MethodReceiverExpr;\n+    fn descr() -> &'static str {\n+        \"an expression\"\n+    }\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        AstNodeWrapper::new(fragment.make_method_receiver_expr(), MethodReceiverTag)\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_expr(&mut self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n+        let node = self.wrapped.into_inner();\n+        match node.kind {\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     invocations: Vec<(Invocation, Option<Lrc<SyntaxExtension>>)>,\n@@ -1840,6 +1895,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         self.visit_node(node)\n     }\n \n+    fn visit_method_receiver_expr(&mut self, node: &mut P<ast::Expr>) {\n+        visit_clobber(node, |node| {\n+            let mut wrapper = AstNodeWrapper::new(node, MethodReceiverTag);\n+            self.visit_node(&mut wrapper);\n+            wrapper.wrapped\n+        })\n+    }\n+\n     fn filter_map_expr(&mut self, node: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         self.flat_map_node(AstNodeWrapper::new(node, OptExprTag))\n     }"}, {"sha": "f6fe38174f7c5566f380e7a2c587c8e3b98aa272", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -250,6 +250,7 @@ fn expand_macro<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n+    // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n     let parser = parser_from_cx(sess, arg.clone());\n \n     // Try each arm's matchers."}, {"sha": "faaf3b3fea58916ae2740546351fcfbc1cb0301a", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -55,6 +55,7 @@ pub fn placeholder(\n         }),\n         AstFragmentKind::Expr => AstFragment::Expr(expr_placeholder()),\n         AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n+        AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(expr_placeholder()),\n         AstFragmentKind::Items => AstFragment::Items(smallvec![P(ast::Item {\n             id,\n             span,\n@@ -296,6 +297,13 @@ impl MutVisitor for PlaceholderExpander {\n         }\n     }\n \n+    fn visit_method_receiver_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        match expr.kind {\n+            ast::ExprKind::MacCall(_) => *expr = self.remove(expr.id).make_method_receiver_expr(),\n+            _ => noop_visit_expr(expr, self),\n+        }\n+    }\n+\n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         match expr.kind {\n             ast::ExprKind::MacCall(_) => self.remove(expr.id).make_opt_expr(),"}, {"sha": "db289a64046a7dac4f38c3642259761e0236c30f", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -53,6 +53,8 @@ declare_features! (\n     (accepted, abi_sysv64, \"1.24.0\", Some(36167), None),\n     /// Allows using ADX intrinsics from `core::arch::{x86, x86_64}`.\n     (accepted, adx_target_feature, \"1.61.0\", Some(44839), None),\n+    /// Allows explicit discriminants on non-unit enum variants.\n+    (accepted, arbitrary_enum_discriminant, \"CURRENT_RUSTC_VERSION\", Some(60553), None),\n     /// Allows using `sym` operands in inline assembly.\n     (accepted, asm_sym, \"CURRENT_RUSTC_VERSION\", Some(93333), None),\n     /// Allows the definition of associated constants in `trait` or `impl` blocks."}, {"sha": "4facb6140a300046e710b06a9aa82c35c6c15115", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -292,8 +292,6 @@ declare_features! (\n     (incomplete, adt_const_params, \"1.56.0\", Some(95174), None),\n     /// Allows defining an `#[alloc_error_handler]`.\n     (active, alloc_error_handler, \"1.29.0\", Some(51540), None),\n-    /// Allows explicit discriminants on non-unit enum variants.\n-    (active, arbitrary_enum_discriminant, \"1.37.0\", Some(60553), None),\n     /// Allows trait methods with arbitrary self types.\n     (active, arbitrary_self_types, \"1.23.0\", Some(44874), None),\n     /// Allows using `const` operands in inline assembly."}, {"sha": "ef00c1ffc302d9ab12e510db364b7357c2b0fe5c", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2207,14 +2207,14 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct TraitItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl TraitItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -2225,7 +2225,7 @@ impl TraitItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n@@ -2236,11 +2236,11 @@ impl TraitItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn trait_item_id(&self) -> TraitItemId {\n-        TraitItemId { def_id: self.def_id }\n+        TraitItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -2271,22 +2271,22 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ImplItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ImplItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub defaultness: Defaultness,\n@@ -2298,11 +2298,11 @@ impl ImplItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn impl_item_id(&self) -> ImplItemId {\n-        ImplItemId { def_id: self.def_id }\n+        ImplItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -2418,6 +2418,30 @@ impl<'hir> Ty<'hir> {\n         }\n         final_ty\n     }\n+\n+    pub fn find_self_aliases(&self) -> Vec<Span> {\n+        use crate::intravisit::Visitor;\n+        struct MyVisitor(Vec<Span>);\n+        impl<'v> Visitor<'v> for MyVisitor {\n+            fn visit_ty(&mut self, t: &'v Ty<'v>) {\n+                if matches!(\n+                    &t.kind,\n+                    TyKind::Path(QPath::Resolved(\n+                        _,\n+                        Path { res: crate::def::Res::SelfTyAlias { .. }, .. },\n+                    ))\n+                ) {\n+                    self.0.push(t.span);\n+                    return;\n+                }\n+                crate::intravisit::walk_ty(self, t);\n+            }\n+        }\n+\n+        let mut my_visitor = MyVisitor(vec![]);\n+        my_visitor.visit_ty(self);\n+        my_visitor.0\n+    }\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n@@ -2890,14 +2914,14 @@ impl<'hir> VariantData<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, Hash, HashStable_Generic)]\n pub struct ItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -2907,7 +2931,7 @@ impl ItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub kind: ItemKind<'hir>,\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2917,11 +2941,11 @@ impl Item<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn item_id(&self) -> ItemId {\n-        ItemId { def_id: self.def_id }\n+        ItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -3134,14 +3158,14 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ForeignItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ForeignItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -3162,7 +3186,7 @@ pub struct ForeignItemRef {\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub span: Span,\n     pub vis_span: Span,\n }\n@@ -3171,11 +3195,11 @@ impl ForeignItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn foreign_item_id(&self) -> ForeignItemId {\n-        ForeignItemId { def_id: self.def_id }\n+        ForeignItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -3267,10 +3291,10 @@ impl<'hir> OwnerNode<'hir> {\n \n     pub fn def_id(self) -> OwnerId {\n         match self {\n-            OwnerNode::Item(Item { def_id, .. })\n-            | OwnerNode::TraitItem(TraitItem { def_id, .. })\n-            | OwnerNode::ImplItem(ImplItem { def_id, .. })\n-            | OwnerNode::ForeignItem(ForeignItem { def_id, .. }) => *def_id,\n+            OwnerNode::Item(Item { owner_id, .. })\n+            | OwnerNode::TraitItem(TraitItem { owner_id, .. })\n+            | OwnerNode::ImplItem(ImplItem { owner_id, .. })\n+            | OwnerNode::ForeignItem(ForeignItem { owner_id, .. }) => *owner_id,\n             OwnerNode::Crate(..) => crate::CRATE_HIR_ID.owner,\n         }\n     }"}, {"sha": "be77e6fd36a07ec858c9c524dae13e43c05d9ff5", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -912,7 +912,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let TraitItem { ident, generics, ref defaultness, ref kind, span, def_id: _ } = *trait_item;\n+    let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n     let hir_id = trait_item.hir_id();\n     visitor.visit_ident(ident);\n     visitor.visit_generics(&generics);\n@@ -952,7 +952,7 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n-        def_id: _,\n+        owner_id: _,\n         ident,\n         ref generics,\n         ref kind,"}, {"sha": "23423e8f3b3bff5f7121730e857a190e665d8667", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -49,7 +49,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -58,7 +58,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -67,7 +67,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -76,7 +76,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "38f195dabb90428cac239c1103fd115b2a473874", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -36,7 +36,7 @@ use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECT\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -275,6 +275,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n+            None,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -324,6 +325,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n+        constness: Option<ty::BoundConstness>,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -534,6 +536,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &mut substs_ctx,\n         );\n \n+        if let Some(ty::BoundConstness::ConstIfConst) = constness\n+            && generics.has_self && !tcx.has_attr(def_id, sym::const_trait)\n+        {\n+            tcx.sess.emit_err(crate::errors::ConstBoundForNonConstTrait { span } );\n+        }\n+\n         (substs, arg_count)\n     }\n \n@@ -601,6 +609,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n+            None,\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n@@ -620,6 +629,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n+        constness: ty::BoundConstness,\n     ) -> ty::TraitRef<'tcx> {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n \n@@ -629,6 +639,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n             true,\n+            Some(constness),\n         )\n     }\n \n@@ -655,6 +666,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             args,\n             infer_args,\n             Some(self_ty),\n+            Some(constness),\n         );\n \n         let tcx = self.tcx();\n@@ -680,6 +692,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 speculative,\n                 &mut dup_bindings,\n                 binding_span.unwrap_or(binding.span),\n+                constness,\n             );\n             // Okay to ignore `Err` because of `ErrorGuaranteed` (see above).\n         }\n@@ -783,13 +796,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &hir::PathSegment<'_>,\n         is_impl: bool,\n+        constness: Option<ty::BoundConstness>,\n     ) -> ty::TraitRef<'tcx> {\n         let (substs, _) = self.create_substs_for_ast_trait_ref(\n             span,\n             trait_def_id,\n             self_ty,\n             trait_segment,\n             is_impl,\n+            constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -805,6 +820,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n         is_impl: bool,\n+        constness: Option<ty::BoundConstness>,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, is_impl);\n \n@@ -816,6 +832,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_segment.args(),\n             trait_segment.infer_args,\n             Some(self_ty),\n+            constness,\n         )\n     }\n \n@@ -1027,6 +1044,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         speculative: bool,\n         dup_bindings: &mut FxHashMap<DefId, Span>,\n         path_span: Span,\n+        constness: ty::BoundConstness,\n     ) -> Result<(), ErrorGuaranteed> {\n         // Given something like `U: SomeTrait<T = X>`, we want to produce a\n         // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n@@ -1122,10 +1140,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 trait_ref.substs,\n             );\n \n-            debug!(\n-                \"add_predicates_for_ast_type_binding: substs for trait-ref and assoc_item: {:?}\",\n-                substs_trait_ref_and_assoc_item\n-            );\n+            debug!(?substs_trait_ref_and_assoc_item);\n \n             ty::ProjectionTy {\n                 item_def_id: assoc_item.def_id,\n@@ -1146,8 +1161,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     tcx.collect_constrained_late_bound_regions(&projection_ty);\n                 let late_bound_in_ty =\n                     tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n-                debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n-                debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+                debug!(?late_bound_in_trait_ref);\n+                debug!(?late_bound_in_ty);\n \n                 // FIXME: point at the type params that don't have appropriate lifetimes:\n                 // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n@@ -1648,6 +1663,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     // Checks that `bounds` contains exactly one element and reports appropriate\n     // errors otherwise.\n+    #[instrument(level = \"debug\", skip(self, all_candidates, ty_param_name, is_equality), ret)]\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n@@ -1677,10 +1693,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 return Err(reported);\n             }\n         };\n-        debug!(\"one_bound_for_assoc_type: bound = {:?}\", bound);\n+        debug!(?bound);\n \n         if let Some(bound2) = next_cand {\n-            debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n+            debug!(?bound2);\n \n             let is_equality = is_equality();\n             let bounds = IntoIterator::into_iter([bound, bound2]).chain(matching_candidates);\n@@ -1776,6 +1792,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // parameter or `Self`.\n     // NOTE: When this function starts resolving `Trait::AssocTy` successfully\n     // it should also start reporting the `BARE_TRAIT_OBJECTS` lint.\n+    #[instrument(level = \"debug\", skip(self, hir_ref_id, span, qself, assoc_segment), fields(assoc_ident=?assoc_segment.ident), ret)]\n     pub fn associated_path_to_ty(\n         &self,\n         hir_ref_id: hir::HirId,\n@@ -1793,8 +1810,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::Err\n         };\n \n-        debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n-\n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n         if let ty::Adt(adt_def, _) = qself_ty.kind() {\n@@ -2050,6 +2065,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_def_id: DefId,\n         trait_segment: &hir::PathSegment<'_>,\n         item_segment: &hir::PathSegment<'_>,\n+        constness: ty::BoundConstness,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -2094,8 +2110,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-        let trait_ref =\n-            self.ast_path_to_mono_trait_ref(span, trait_def_id, self_ty, trait_segment, false);\n+        let trait_ref = self.ast_path_to_mono_trait_ref(\n+            span,\n+            trait_def_id,\n+            self_ty,\n+            trait_segment,\n+            false,\n+            Some(constness),\n+        );\n \n         let item_substs = self.create_substs_for_associated_item(\n             span,\n@@ -2534,12 +2556,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n                 self.prohibit_generics(path.segments[..path.segments.len() - 2].iter(), |_| {});\n+                // HACK: until we support `<Type as ~const Trait>`, assume all of them are.\n+                let constness = if tcx.has_attr(tcx.parent(def_id), sym::const_trait) {\n+                    ty::BoundConstness::ConstIfConst\n+                } else {\n+                    ty::BoundConstness::NotConst\n+                };\n                 self.qpath_to_ty(\n                     span,\n                     opt_self_ty,\n                     def_id,\n                     &path.segments[path.segments.len() - 2],\n                     path.segments.last().unwrap(),\n+                    constness,\n                 )\n             }\n             Res::PrimTy(prim_ty) => {\n@@ -2632,7 +2661,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n-                let def_id = item_id.def_id.to_def_id();\n+                let def_id = item_id.owner_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n@@ -2658,6 +2687,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &GenericArgs::none(),\n                     true,\n                     None,\n+                    None,\n                 );\n                 EarlyBinder(self.normalize_ty(span, tcx.at(span).type_of(def_id)))\n                     .subst(tcx, substs)\n@@ -2766,6 +2796,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, hir_id, unsafety, abi, decl, generics, hir_ty), ret)]\n     pub fn ty_of_fn(\n         &self,\n         hir_id: hir::HirId,\n@@ -2775,8 +2806,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generics: Option<&hir::Generics<'_>>,\n         hir_ty: Option<&hir::Ty<'_>>,\n     ) -> ty::PolyFnSig<'tcx> {\n-        debug!(\"ty_of_fn\");\n-\n         let tcx = self.tcx();\n         let bound_vars = tcx.late_bound_vars(hir_id);\n         debug!(?bound_vars);\n@@ -2826,7 +2855,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::FnRetTy::DefaultReturn(..) => tcx.mk_unit(),\n         };\n \n-        debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n+        debug!(?output_ty);\n \n         let fn_ty = tcx.mk_fn_sig(input_tys.into_iter(), output_ty, decl.c_variadic, unsafety, abi);\n         let bare_fn_ty = ty::Binder::bind_with_vars(fn_ty, bound_vars);\n@@ -2903,8 +2932,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n                 hir.get(hir.get_parent_node(fn_hir_id)) else { bug!(\"ImplItem should have Impl parent\") };\n \n-        let trait_ref =\n-            self.instantiate_mono_trait_ref(i.of_trait.as_ref()?, self.ast_ty_to_ty(i.self_ty));\n+        let trait_ref = self.instantiate_mono_trait_ref(\n+            i.of_trait.as_ref()?,\n+            self.ast_ty_to_ty(i.self_ty),\n+            ty::BoundConstness::NotConst,\n+        );\n \n         let assoc = tcx.associated_items(trait_ref.def_id).find_by_name_and_kind(\n             tcx,"}, {"sha": "b70ac02058d3dd3d5dccdcd58d129bcb0c30bee1", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -114,7 +114,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n                 _ => {\n                     // Fallback case: allow `ManuallyDrop` and things that are `Copy`.\n                     ty.ty_adt_def().is_some_and(|adt_def| adt_def.is_manually_drop())\n-                        || ty.is_copy_modulo_regions(tcx.at(span), param_env)\n+                        || ty.is_copy_modulo_regions(tcx, param_env)\n                 }\n             }\n         }\n@@ -227,17 +227,17 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n         return;\n     }\n \n-    let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n-    let span = tcx.def_span(item.def_id.def_id);\n+    let substs = InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id());\n+    let span = tcx.def_span(item.owner_id.def_id);\n \n-    check_opaque_for_inheriting_lifetimes(tcx, item.def_id.def_id, span);\n-    if tcx.type_of(item.def_id.def_id).references_error() {\n+    check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n+    if tcx.type_of(item.owner_id.def_id).references_error() {\n         return;\n     }\n-    if check_opaque_for_cycles(tcx, item.def_id.def_id, substs, span, &origin).is_err() {\n+    if check_opaque_for_cycles(tcx, item.owner_id.def_id, substs, span, &origin).is_err() {\n         return;\n     }\n-    check_opaque_meets_bounds(tcx, item.def_id.def_id, substs, span, &origin);\n+    check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n }\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n@@ -492,38 +492,38 @@ fn check_opaque_meets_bounds<'tcx>(\n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n-        id.def_id,\n-        tcx.def_path_str(id.def_id.to_def_id())\n+        id.owner_id,\n+        tcx.def_path_str(id.owner_id.to_def_id())\n     );\n     let _indenter = indenter();\n-    match tcx.def_kind(id.def_id) {\n+    match tcx.def_kind(id.owner_id) {\n         DefKind::Static(..) => {\n-            tcx.ensure().typeck(id.def_id.def_id);\n-            maybe_check_static_with_link_section(tcx, id.def_id.def_id);\n-            check_static_inhabited(tcx, id.def_id.def_id);\n+            tcx.ensure().typeck(id.owner_id.def_id);\n+            maybe_check_static_with_link_section(tcx, id.owner_id.def_id);\n+            check_static_inhabited(tcx, id.owner_id.def_id);\n         }\n         DefKind::Const => {\n-            tcx.ensure().typeck(id.def_id.def_id);\n+            tcx.ensure().typeck(id.owner_id.def_id);\n         }\n         DefKind::Enum => {\n             let item = tcx.hir().item(id);\n             let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n                 return;\n             };\n-            check_enum(tcx, &enum_definition.variants, item.def_id.def_id);\n+            check_enum(tcx, &enum_definition.variants, item.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::Impl(ref impl_) = it.kind else {\n                 return;\n             };\n-            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.def_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.def_id) {\n+            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n-                    it.def_id.def_id,\n+                    it.owner_id.def_id,\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n@@ -545,32 +545,32 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                         fn_maybe_err(tcx, item.ident.span, abi);\n                     }\n                     hir::TraitItemKind::Type(.., Some(default)) => {\n-                        let assoc_item = tcx.associated_item(item.def_id);\n+                        let assoc_item = tcx.associated_item(item.owner_id);\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, it.owner_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorGuaranteed> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n                             default.span,\n-                            ty::TraitRef { def_id: it.def_id.to_def_id(), substs: trait_substs },\n+                            ty::TraitRef { def_id: it.owner_id.to_def_id(), substs: trait_substs },\n                         );\n                     }\n                     _ => {}\n                 }\n             }\n         }\n         DefKind::Struct => {\n-            check_struct(tcx, id.def_id.def_id);\n+            check_struct(tcx, id.owner_id.def_id);\n         }\n         DefKind::Union => {\n-            check_union(tcx, id.def_id.def_id);\n+            check_union(tcx, id.owner_id.def_id);\n         }\n         DefKind::OpaqueTy => {\n             check_opaque(tcx, id);\n         }\n         DefKind::ImplTraitPlaceholder => {\n-            let parent = tcx.impl_trait_in_trait_parent(id.def_id.to_def_id());\n+            let parent = tcx.impl_trait_in_trait_parent(id.owner_id.to_def_id());\n             // Only check the validity of this opaque type if the function has a default body\n             if let hir::Node::TraitItem(hir::TraitItem {\n                 kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)),\n@@ -581,8 +581,8 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             }\n         }\n         DefKind::TyAlias => {\n-            let pty_ty = tcx.type_of(id.def_id);\n-            let generics = tcx.generics_of(id.def_id);\n+            let pty_ty = tcx.type_of(id.owner_id);\n+            let generics = tcx.generics_of(id.owner_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n         DefKind::ForeignMod => {\n@@ -604,7 +604,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                 }\n             } else {\n                 for item in items {\n-                    let def_id = item.id.def_id.def_id;\n+                    let def_id = item.id.owner_id.def_id;\n                     let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n@@ -659,7 +659,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.def_id.to_def_id());\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>(\n@@ -746,7 +746,7 @@ fn check_impl_items_against_trait<'tcx>(\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n \n     for impl_item in impl_item_refs {\n-        let ty_impl_item = tcx.associated_item(impl_item.id.def_id);\n+        let ty_impl_item = tcx.associated_item(impl_item.id.owner_id);\n         let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n             tcx.associated_item(trait_item_id)\n         } else {\n@@ -758,7 +758,7 @@ fn check_impl_items_against_trait<'tcx>(\n         match impl_item_full.kind {\n             hir::ImplItemKind::Const(..) => {\n                 let _ = tcx.compare_assoc_const_impl_item_with_trait_item((\n-                    impl_item.id.def_id.def_id,\n+                    impl_item.id.owner_id.def_id,\n                     ty_impl_item.trait_item_def_id.unwrap(),\n                 ));\n             }\n@@ -1180,7 +1180,7 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n         }\n     }\n \n-    if tcx.adt_def(def_id).repr().int.is_none() && tcx.features().arbitrary_enum_discriminant {\n+    if tcx.adt_def(def_id).repr().int.is_none() {\n         let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n \n         let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();"}, {"sha": "32f66b06f835859cd34c5c934ae2a9f0c71ad702", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -597,7 +597,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n                 let num_trait_substs = trait_to_impl_substs.len();\n                 let num_impl_substs = tcx.generics_of(impl_m.container_id(tcx)).params.len();\n                 let ty = tcx.fold_regions(ty, |region, _| {\n-                    let ty::ReFree(_) = region.kind() else { return region; };\n+                    let (ty::ReFree(_) | ty::ReEarlyBound(_)) = region.kind() else { return region; };\n                     let Some(ty::ReEarlyBound(e)) = map.get(&region.into()).map(|r| r.expect_region().kind())\n                     else {\n                         tcx"}, {"sha": "609095c9ceaa7511b8c0106a73c6202116116e86", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -26,7 +26,7 @@ fn equate_intrinsic_type<'tcx>(\n ) {\n     let (own_counts, span) = match &it.kind {\n         hir::ForeignItemKind::Fn(.., generics) => {\n-            let own_counts = tcx.generics_of(it.def_id.to_def_id()).own_counts();\n+            let own_counts = tcx.generics_of(it.owner_id.to_def_id()).own_counts();\n             (own_counts, generics.span)\n         }\n         _ => {\n@@ -57,7 +57,7 @@ fn equate_intrinsic_type<'tcx>(\n     {\n         let fty = tcx.mk_fn_ptr(sig);\n         let cause = ObligationCause::new(it.span, it.hir_id(), ObligationCauseCode::IntrinsicType);\n-        require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.def_id)), fty);\n+        require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id)), fty);\n     }\n }\n \n@@ -129,7 +129,7 @@ pub fn intrinsic_operation_unsafety(tcx: TyCtxt<'_>, intrinsic_id: DefId) -> hir\n /// and in `library/core/src/intrinsics.rs`.\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n-    let intrinsic_id = it.def_id.to_def_id();\n+    let intrinsic_id = it.owner_id.to_def_id();\n     let intrinsic_name = tcx.item_name(intrinsic_id);\n     let name_str = intrinsic_name.as_str();\n "}, {"sha": "17c4d0d482f2ab0b2a72e58c27aad8717f3decff", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n         // Type still may have region variables, but `Sized` does not depend\n         // on those, so just erase them before querying.\n-        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+        if ty.is_sized(self.tcx, self.param_env) {\n             return true;\n         }\n         if let ty::Foreign(..) = ty.kind() {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !ty.is_copy_modulo_regions(self.tcx.at(expr.span), self.param_env) {\n+        if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));"}, {"sha": "a23575004655bdc28f84aebec9828dccabb3cc14", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -147,10 +147,10 @@ fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n /// the types first.\n #[instrument(skip(tcx), level = \"debug\")]\n fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n \n     debug!(\n-        ?item.def_id,\n+        ?item.owner_id,\n         item.name = ? tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -246,10 +246,10 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n }\n \n fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n \n     debug!(\n-        ?item.def_id,\n+        ?item.owner_id,\n         item.name = ? tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -263,7 +263,7 @@ fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n }\n \n fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n-    let def_id = trait_item.def_id.def_id;\n+    let def_id = trait_item.owner_id.def_id;\n \n     let (method_sig, span) = match trait_item.kind {\n         hir::TraitItemKind::Fn(ref sig, _) => (Some(sig), trait_item.span),\n@@ -275,7 +275,7 @@ fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n \n     let encl_trait_def_id = tcx.local_parent(def_id);\n     let encl_trait = tcx.hir().expect_item(encl_trait_def_id);\n-    let encl_trait_def_id = encl_trait.def_id.to_def_id();\n+    let encl_trait_def_id = encl_trait.owner_id.to_def_id();\n     let fn_lang_item_name = if Some(encl_trait_def_id) == tcx.lang_items().fn_trait() {\n         Some(\"fn\")\n     } else if Some(encl_trait_def_id) == tcx.lang_items().fn_mut_trait() {\n@@ -348,7 +348,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n     loop {\n         let mut should_continue = false;\n         for gat_item in associated_items {\n-            let gat_def_id = gat_item.id.def_id;\n+            let gat_def_id = gat_item.id.owner_id;\n             let gat_item = tcx.associated_item(gat_def_id);\n             // If this item is not an assoc ty, or has no substs, then it's not a GAT\n             if gat_item.kind != ty::AssocKind::Type {\n@@ -365,7 +365,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             // constrains the GAT with individually.\n             let mut new_required_bounds: Option<FxHashSet<ty::Predicate<'_>>> = None;\n             for item in associated_items {\n-                let item_def_id = item.id.def_id;\n+                let item_def_id = item.id.owner_id;\n                 // Skip our own GAT, since it does not constrain itself at all.\n                 if item_def_id == gat_def_id {\n                     continue;\n@@ -713,6 +713,10 @@ fn resolve_regions_with_wf_tys<'tcx>(\n \n     add_constraints(&infcx, region_bound_pairs);\n \n+    infcx.process_registered_region_obligations(\n+        outlives_environment.region_bound_pairs(),\n+        param_env,\n+    );\n     let errors = infcx.resolve_regions(&outlives_environment);\n \n     debug!(?errors, \"errors\");\n@@ -786,7 +790,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n     let (trait_name, trait_def_id) =\n         match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(item.hir_id()).def_id) {\n             hir::Node::Item(item) => match item.kind {\n-                hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n+                hir::ItemKind::Trait(..) => (item.ident, item.owner_id),\n                 _ => return,\n             },\n             _ => return,\n@@ -841,7 +845,7 @@ fn check_impl_item(tcx: TyCtxt<'_>, impl_item: &hir::ImplItem<'_>) {\n         _ => (None, impl_item.span),\n     };\n \n-    check_associated_item(tcx, impl_item.def_id.def_id, span, method_sig);\n+    check_associated_item(tcx, impl_item.owner_id.def_id, span, method_sig);\n }\n \n fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n@@ -1041,11 +1045,11 @@ fn check_type_defn<'tcx, F>(\n ) where\n     F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n-    let _ = tcx.representability(item.def_id.def_id);\n+    let _ = tcx.representability(item.owner_id.def_id);\n \n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n         let variants = lookup_fields(wfcx);\n-        let packed = tcx.adt_def(item.def_id).repr().packed();\n+        let packed = tcx.adt_def(item.owner_id).repr().packed();\n \n         for variant in &variants {\n             // All field types must be well-formed.\n@@ -1069,7 +1073,7 @@ fn check_type_defn<'tcx, F>(\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n-                        ty.needs_drop(tcx, tcx.param_env(item.def_id))\n+                        ty.needs_drop(tcx, tcx.param_env(item.owner_id))\n                     }\n                 }\n             };\n@@ -1117,15 +1121,15 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n+        check_where_clauses(wfcx, item.span, item.owner_id.def_id);\n     });\n }\n \n #[instrument(skip(tcx, item))]\n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n-    debug!(?item.def_id);\n+    debug!(?item.owner_id);\n \n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n     let trait_def = tcx.trait_def(def_id);\n     if trait_def.is_marker\n         || matches!(trait_def.specialization_kind, TraitSpecializationKind::Marker)\n@@ -1236,13 +1240,13 @@ fn check_impl<'tcx>(\n     ast_trait_ref: &Option<hir::TraitRef<'_>>,\n     constness: hir::Constness,\n ) {\n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = tcx.impl_trait_ref(item.def_id).unwrap();\n+                let trait_ref = tcx.impl_trait_ref(item.owner_id).unwrap();\n                 let trait_ref = wfcx.normalize(ast_trait_ref.path.span, None, trait_ref);\n                 let trait_pred = ty::TraitPredicate {\n                     trait_ref,\n@@ -1264,7 +1268,7 @@ fn check_impl<'tcx>(\n                 wfcx.register_obligations(obligations);\n             }\n             None => {\n-                let self_ty = tcx.type_of(item.def_id);\n+                let self_ty = tcx.type_of(item.owner_id);\n                 let self_ty = wfcx.normalize(\n                     item.span,\n                     Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),\n@@ -1278,7 +1282,7 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n+        check_where_clauses(wfcx, item.span, item.owner_id.def_id);\n     });\n }\n \n@@ -1774,14 +1778,14 @@ fn check_variances_for_type_defn<'tcx>(\n     item: &hir::Item<'tcx>,\n     hir_generics: &hir::Generics<'_>,\n ) {\n-    let ty = tcx.type_of(item.def_id);\n+    let ty = tcx.type_of(item.owner_id);\n     if tcx.has_error_field(ty) {\n         return;\n     }\n \n-    let ty_predicates = tcx.predicates_of(item.def_id);\n+    let ty_predicates = tcx.predicates_of(item.owner_id);\n     assert_eq!(ty_predicates.parent, None);\n-    let variances = tcx.variances_of(item.def_id);\n+    let variances = tcx.variances_of(item.owner_id);\n \n     let mut constrained_parameters: FxHashSet<_> = variances\n         .iter()\n@@ -1794,7 +1798,7 @@ fn check_variances_for_type_defn<'tcx>(\n \n     // Lazily calculated because it is only needed in case of an error.\n     let explicitly_bounded_params = LazyCell::new(|| {\n-        let icx = crate::collect::ItemCtxt::new(tcx, item.def_id.to_def_id());\n+        let icx = crate::collect::ItemCtxt::new(tcx, item.owner_id.to_def_id());\n         hir_generics\n             .predicates\n             .iter()\n@@ -1915,10 +1919,10 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let items = tcx.hir_module_items(module);\n-    items.par_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_impl_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_trait_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.def_id));\n+    items.par_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_impl_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_trait_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "d0c31733481b63ef24e1f5a2e9cc54d37a6a03c9", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,5 +1,6 @@\n use crate::errors::{ExternCrateNotIdiomatic, UnusedExternCrate};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -8,12 +9,12 @@ use rustc_session::lint;\n use rustc_span::{Span, Symbol};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n-    let mut used_trait_imports: FxHashSet<LocalDefId> = FxHashSet::default();\n+    let mut used_trait_imports: UnordSet<LocalDefId> = Default::default();\n \n     for item_def_id in tcx.hir().body_owners() {\n         let imports = tcx.used_trait_imports(item_def_id);\n         debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n-        used_trait_imports.extend(imports.iter());\n+        used_trait_imports.extend(imports.items().copied());\n     }\n \n     for &id in tcx.maybe_unused_trait_imports(()) {\n@@ -89,11 +90,11 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let mut crates_to_lint = vec![];\n \n     for id in tcx.hir().items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::ExternCrate) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::ExternCrate) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n                 crates_to_lint.push(ExternCrateToLint {\n-                    def_id: item.def_id.to_def_id(),\n+                    def_id: item.owner_id.to_def_id(),\n                     span: item.span,\n                     orig_name,\n                     warn_if_unused: !item.ident.as_str().starts_with('_'),"}, {"sha": "2890c149b3afe3f2ac1eba2ecc37a438e9824e75", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -58,7 +58,7 @@ const ADD_ATTR: &str =\n \n impl<'tcx> InherentCollect<'tcx> {\n     fn check_def_id(&mut self, item: &hir::Item<'_>, self_ty: Ty<'tcx>, def_id: DefId) {\n-        let impl_def_id = item.def_id;\n+        let impl_def_id = item.owner_id;\n         if let Some(def_id) = def_id.as_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n@@ -89,7 +89,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             for impl_item in items {\n                 if !self\n                     .tcx\n-                    .has_attr(impl_item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                    .has_attr(impl_item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n                 {\n                     struct_span_err!(\n                         self.tcx.sess,\n@@ -135,7 +135,7 @@ impl<'tcx> InherentCollect<'tcx> {\n                 for item in items {\n                     if !self\n                         .tcx\n-                        .has_attr(item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                        .has_attr(item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n                     {\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -177,7 +177,7 @@ impl<'tcx> InherentCollect<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        if !matches!(self.tcx.def_kind(id.def_id), DefKind::Impl) {\n+        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::Impl) {\n             return;\n         }\n \n@@ -186,7 +186,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             return;\n         };\n \n-        let self_ty = self.tcx.type_of(item.def_id);\n+        let self_ty = self.tcx.type_of(item.owner_id);\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n                 self.check_def_id(item, self_ty, def.did());\n@@ -221,7 +221,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Never\n             | ty::FnPtr(_)\n             | ty::Tuple(..) => {\n-                self.check_primitive_impl(item.def_id.def_id, self_ty, items, ty.span)\n+                self.check_primitive_impl(item.owner_id.def_id, self_ty, items, ty.span)\n             }\n             ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n@@ -243,7 +243,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.owner_id, self_ty);\n             }\n             ty::Error(_) => {}\n         }"}, {"sha": "972769eb1970735f7736ddf7168f94ac51072fa8", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -156,14 +156,14 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        let def_kind = self.tcx.def_kind(id.def_id);\n+        let def_kind = self.tcx.def_kind(id.owner_id);\n         if !matches!(def_kind, DefKind::Enum | DefKind::Struct | DefKind::Trait | DefKind::Union) {\n             return;\n         }\n \n-        let impls = self.tcx.inherent_impls(id.def_id);\n+        let impls = self.tcx.inherent_impls(id.owner_id);\n \n-        let overlap_mode = OverlapMode::get(self.tcx, id.def_id.to_def_id());\n+        let overlap_mode = OverlapMode::get(self.tcx, id.owner_id.to_def_id());\n \n         let impls_items = impls\n             .iter()"}, {"sha": "bb45c3823d839cb33d238c3c96c308fd00778be9", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -101,7 +101,7 @@ fn do_orphan_check_impl<'tcx>(\n         span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n     }\n \n-    match traits::orphan_check(tcx, item.def_id.to_def_id()) {\n+    match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error(\n             tcx,"}, {"sha": "a34815b45b3adeb7834cc163c66bbd5cbc7257fc", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let item = tcx.hir().expect_item(def_id);\n     let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n \n-    if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n+    if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_def = tcx.trait_def(trait_ref.def_id);\n         let unsafe_attr =\n             impl_.generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\");\n@@ -26,6 +26,12 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     \"implementing the trait `{}` is not unsafe\",\n                     trait_ref.print_only_trait_path()\n                 )\n+                .span_suggestion_verbose(\n+                    item.span.with_hi(item.span.lo() + rustc_span::BytePos(7)),\n+                    \"remove `unsafe` from this trait implementation\",\n+                    \"\",\n+                    rustc_errors::Applicability::MachineApplicable,\n+                )\n                 .emit();\n             }\n \n@@ -37,6 +43,18 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     \"the trait `{}` requires an `unsafe impl` declaration\",\n                     trait_ref.print_only_trait_path()\n                 )\n+                .note(format!(\n+                    \"the trait `{}` enforces invariants that the compiler can't check. \\\n+                    Review the trait documentation and make sure this implementation \\\n+                    upholds those invariants before adding the `unsafe` keyword\",\n+                    trait_ref.print_only_trait_path()\n+                ))\n+                .span_suggestion_verbose(\n+                    item.span.shrink_to_lo(),\n+                    \"add `unsafe` to this trait implementation\",\n+                    \"unsafe \",\n+                    rustc_errors::Applicability::MaybeIncorrect,\n+                )\n                 .emit();\n             }\n \n@@ -48,6 +66,18 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n                     attr_name\n                 )\n+                .note(format!(\n+                    \"the trait `{}` enforces invariants that the compiler can't check. \\\n+                    Review the trait documentation and make sure this implementation \\\n+                    upholds those invariants before adding the `unsafe` keyword\",\n+                    trait_ref.print_only_trait_path()\n+                ))\n+                .span_suggestion_verbose(\n+                    item.span.shrink_to_lo(),\n+                    \"add `unsafe` to this trait implementation\",\n+                    \"unsafe \",\n+                    rustc_errors::Applicability::MaybeIncorrect,\n+                )\n                 .emit();\n             }\n "}, {"sha": "346d2e2fc4b18cb2a8c862cbeb0966d08e1ead30", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -571,7 +571,7 @@ fn get_new_lifetime_name<'tcx>(\n fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     let it = tcx.hir().item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n-    let def_id = item_id.def_id.def_id;\n+    let def_id = item_id.owner_id.def_id;\n \n     match it.kind {\n         // These don't define types.\n@@ -583,11 +583,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         hir::ItemKind::ForeignMod { items, .. } => {\n             for item in items {\n                 let item = tcx.hir().foreign_item(item.id);\n-                tcx.ensure().generics_of(item.def_id);\n-                tcx.ensure().type_of(item.def_id);\n-                tcx.ensure().predicates_of(item.def_id);\n+                tcx.ensure().generics_of(item.owner_id);\n+                tcx.ensure().type_of(item.owner_id);\n+                tcx.ensure().predicates_of(item.owner_id);\n                 match item.kind {\n-                    hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.def_id),\n+                    hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.owner_id),\n                     hir::ForeignItemKind::Static(..) => {\n                         let mut visitor = HirPlaceholderCollector::default();\n                         visitor.visit_foreign_item(item);\n@@ -683,7 +683,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n \n fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n     let trait_item = tcx.hir().trait_item(trait_item_id);\n-    let def_id = trait_item_id.def_id;\n+    let def_id = trait_item_id.owner_id;\n     tcx.ensure().generics_of(def_id);\n \n     match trait_item.kind {\n@@ -730,7 +730,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n }\n \n fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n-    let def_id = impl_item_id.def_id;\n+    let def_id = impl_item_id.owner_id;\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n@@ -1010,7 +1010,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n \n                 match item {\n                     Some(item) if matches!(item.kind, hir::AssocItemKind::Fn { .. }) => {\n-                        if !tcx.impl_defaultness(item.id.def_id).has_value() {\n+                        if !tcx.impl_defaultness(item.id.owner_id).has_value() {\n                             tcx.sess\n                                 .struct_span_err(\n                                     item.span,\n@@ -1143,7 +1143,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         }\n \n         ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), generics, .. }) => {\n-            // Do not try to inference the return type for a impl method coming from a trait\n+            // Do not try to infer the return type for a impl method coming from a trait\n             if let Item(hir::Item { kind: ItemKind::Impl(i), .. }) =\n                 tcx.hir().get(tcx.hir().get_parent_node(hir_id))\n                 && i.of_trait.is_some()\n@@ -1286,15 +1286,46 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n \n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    match tcx.hir().expect_item(def_id.expect_local()).kind {\n+    let item = tcx.hir().expect_item(def_id.expect_local());\n+    match item.kind {\n         hir::ItemKind::Impl(ref impl_) => impl_.of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n-            <dyn AstConv<'_>>::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n+            <dyn AstConv<'_>>::instantiate_mono_trait_ref(\n+                &icx,\n+                ast_trait_ref,\n+                selfty,\n+                check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n+            )\n         }),\n         _ => bug!(),\n     }\n }\n \n+fn check_impl_constness(\n+    tcx: TyCtxt<'_>,\n+    constness: hir::Constness,\n+    ast_trait_ref: &hir::TraitRef<'_>,\n+) -> ty::BoundConstness {\n+    match constness {\n+        hir::Constness::Const => {\n+            if let Some(trait_def_id) = ast_trait_ref.trait_def_id() && !tcx.has_attr(trait_def_id, sym::const_trait) {\n+                let trait_name = tcx.item_name(trait_def_id).to_string();\n+                tcx.sess.emit_err(errors::ConstImplForNonConstTrait {\n+                    trait_ref_span: ast_trait_ref.path.span,\n+                    trait_name,\n+                    local_trait_span: trait_def_id.as_local().map(|_| tcx.def_span(trait_def_id).shrink_to_lo()),\n+                    marking: (),\n+                    adding: (),\n+                });\n+                ty::BoundConstness::NotConst\n+            } else {\n+                ty::BoundConstness::ConstIfConst\n+            }\n+        },\n+        hir::Constness::NotConst => ty::BoundConstness::NotConst,\n+    }\n+}\n+\n fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(def_id.expect_local());"}, {"sha": "c7777a946893a689e3eb56b45109a7138320f38a", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -249,6 +249,11 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n     // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n+    let mut next_index = || {\n+        let prev = i;\n+        i += 1;\n+        prev as u32 + type_start\n+    };\n \n     const TYPE_DEFAULT_NOT_ALLOWED: &'static str = \"defaults for type parameters are only allowed in \\\n     `struct`, `enum`, `type`, or `trait` definitions\";\n@@ -278,15 +283,13 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n \n             let kind = ty::GenericParamDefKind::Type { has_default: default.is_some(), synthetic };\n \n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n+            Some(ty::GenericParamDef {\n+                index: next_index(),\n                 name: param.name.ident().name,\n                 def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind,\n-            };\n-            i += 1;\n-            Some(param_def)\n+            })\n         }\n         GenericParamKind::Const { default, .. } => {\n             if !matches!(allow_defaults, Defaults::Allowed) && default.is_some() {\n@@ -297,15 +300,13 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 );\n             }\n \n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n+            Some(ty::GenericParamDef {\n+                index: next_index(),\n                 name: param.name.ident().name,\n                 def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Const { has_default: default.is_some() },\n-            };\n-            i += 1;\n-            Some(param_def)\n+            })\n         }\n     }));\n \n@@ -323,8 +324,8 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             &[\"<closure_kind>\", \"<closure_signature>\", \"<upvars>\"][..]\n         };\n \n-        params.extend(dummy_args.iter().enumerate().map(|(i, &arg)| ty::GenericParamDef {\n-            index: type_start + i as u32,\n+        params.extend(dummy_args.iter().map(|&arg| ty::GenericParamDef {\n+            index: next_index(),\n             name: Symbol::intern(arg),\n             def_id,\n             pure_wrt_drop: false,\n@@ -337,7 +338,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n         if let Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) = parent_node {\n             params.push(ty::GenericParamDef {\n-                index: type_start,\n+                index: next_index(),\n                 name: Symbol::intern(\"<const_ty>\"),\n                 def_id,\n                 pure_wrt_drop: false,"}, {"sha": "3f263a6de24ead04dc1cbaadf4d2a808d57bac12", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -331,8 +331,8 @@ fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetime\n /// `resolve_lifetimes`.\n fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: hir::OwnerId) -> &'tcx ResolveLifetimes {\n     let item_id = item_for(tcx, def_id.def_id);\n-    let local_def_id = item_id.def_id.def_id;\n-    if item_id.def_id == def_id {\n+    let local_def_id = item_id.owner_id.def_id;\n+    if item_id.owner_id == def_id {\n         let item = tcx.hir().item(item_id);\n         match item.kind {\n             hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(local_def_id),\n@@ -557,11 +557,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // their owner, we can keep going until we find the Item that owns that. We then\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n-                for (_hir_id, node) in self.tcx.hir().parent_iter(item.def_id.into()) {\n+                for (_hir_id, node) in self.tcx.hir().parent_iter(item.owner_id.into()) {\n                     match node {\n                         hir::Node::Item(parent_item) => {\n                             let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(\n-                                item_for(self.tcx, parent_item.def_id.def_id).def_id.def_id,\n+                                item_for(self.tcx, parent_item.owner_id.def_id).owner_id.def_id,\n                             );\n                             // We need to add *all* deps, since opaque tys may want them from *us*\n                             for (&owner, defs) in resolved_lifetimes.defs.iter() {"}, {"sha": "c29a645eb4a888332f961c500e07d5b7c58d0b11", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -319,7 +319,15 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     }\n                 }\n                 ItemKind::TyAlias(self_ty, _) => icx.to_ty(self_ty),\n-                ItemKind::Impl(hir::Impl { self_ty, .. }) => icx.to_ty(*self_ty),\n+                ItemKind::Impl(hir::Impl { self_ty, .. }) => {\n+                    match self_ty.find_self_aliases() {\n+                        spans if spans.len() > 0 => {\n+                            tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: (), });\n+                            tcx.ty_error()\n+                        },\n+                        _ => icx.to_ty(*self_ty),\n+                    }\n+                },\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                     tcx.mk_fn_def(def_id.to_def_id(), substs)\n@@ -635,24 +643,24 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.def_id);\n-            self.check(it.def_id.def_id);\n+            trace!(?it.owner_id);\n+            self.check(it.owner_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n@@ -693,6 +701,12 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n         tcx.sess.emit_err(UnconstrainedOpaqueType {\n             span: tcx.def_span(def_id),\n             name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n+            what: match tcx.hir().get(scope) {\n+                _ if scope == hir::CRATE_HIR_ID => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n+                _ => \"item\",\n+            },\n         });\n         return tcx.ty_error();\n     };\n@@ -764,24 +778,24 @@ fn find_opaque_ty_constraints_for_rpit(\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.def_id);\n-            self.check(it.def_id.def_id);\n+            trace!(?it.owner_id);\n+            self.check(it.owner_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }"}, {"sha": "d5b1a7ce1c26967ff058457b99a76b7db87e9c2f", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,7 +1,7 @@\n //! Errors emitted by `rustc_hir_analysis`.\n \n-use rustc_errors::IntoDiagnostic;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler};\n+use rustc_errors::{IntoDiagnostic, MultiSpan};\n use rustc_macros::{Diagnostic, LintDiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n@@ -143,6 +143,7 @@ pub struct UnconstrainedOpaqueType {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n+    pub what: &'static str,\n }\n \n pub struct MissingTypeParams {\n@@ -249,3 +250,33 @@ pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_impl_for_non_const_trait)]\n+pub struct ConstImplForNonConstTrait {\n+    #[primary_span]\n+    pub trait_ref_span: Span,\n+    pub trait_name: String,\n+    #[suggestion(applicability = \"machine-applicable\", code = \"#[const_trait]\")]\n+    pub local_trait_span: Option<Span>,\n+    #[note]\n+    pub marking: (),\n+    #[note(adding)]\n+    pub adding: (),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_bound_for_non_const_trait)]\n+pub struct ConstBoundForNonConstTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_self_in_impl_self)]\n+pub struct SelfInImplSelf {\n+    #[primary_span]\n+    pub span: MultiSpan,\n+    #[note]\n+    pub note: (),\n+}"}, {"sha": "136f6199911a0eeb9ba7ac07032bf630df2eef6a", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -55,10 +55,10 @@ fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-            enforce_impl_params_are_constrained(tcx, id.def_id.def_id);\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+            enforce_impl_params_are_constrained(tcx, id.owner_id.def_id);\n             if min_specialization {\n-                check_min_specialization(tcx, id.def_id.def_id);\n+                check_min_specialization(tcx, id.owner_id.def_id);\n             }\n         }\n     }"}, {"sha": "525cd24190a4c920db4a1fc0030ba56c31c54f18", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -381,7 +381,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         error = true;\n                     }\n                     if let hir::IsAsync::Async = sig.header.asyncness {\n-                        let span = tcx.def_span(it.def_id);\n+                        let span = tcx.def_span(it.owner_id);\n                         struct_span_err!(\n                             tcx.sess,\n                             span,"}, {"sha": "90c6edb65e46faa6aac8214fb3587c9abd5a5723", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -29,7 +29,7 @@ pub(super) fn infer_predicates<'tcx>(\n \n         // Visit all the crates and infer predicates\n         for id in tcx.hir().items() {\n-            let item_did = id.def_id;\n+            let item_did = id.owner_id;\n \n             debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n "}, {"sha": "fa2ac56593bcf5c38d685bdf9023b60be02f626e", "filename": "compiler/rustc_hir_analysis/src/outlives/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -6,11 +6,11 @@ pub fn test_inferred_outlives(tcx: TyCtxt<'_>) {\n     for id in tcx.hir().items() {\n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_outlives) {\n-            let inferred_outlives_of = tcx.inferred_outlives_of(id.def_id);\n+        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_outlives) {\n+            let inferred_outlives_of = tcx.inferred_outlives_of(id.owner_id);\n             struct_span_err!(\n                 tcx.sess,\n-                tcx.def_span(id.def_id),\n+                tcx.def_span(id.owner_id),\n                 E0640,\n                 \"{:?}\",\n                 inferred_outlives_of"}, {"sha": "83ed3e44b3d733ca28477c985a4674c1eb201041", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -6,9 +6,10 @@ pub fn test_variance(tcx: TyCtxt<'_>) {\n     // For unit testing: check for a special \"rustc_variance\"\n     // attribute and report an error with various results if found.\n     for id in tcx.hir().items() {\n-        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_variance) {\n-            let variances_of = tcx.variances_of(id.def_id);\n-            struct_span_err!(tcx.sess, tcx.def_span(id.def_id), E0208, \"{:?}\", variances_of).emit();\n+        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_variance) {\n+            let variances_of = tcx.variances_of(id.owner_id);\n+            struct_span_err!(tcx.sess, tcx.def_span(id.owner_id), E0208, \"{:?}\", variances_of)\n+                .emit();\n         }\n     }\n }"}, {"sha": "d1dab0540be956087c2236fa649818272eb1c251", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -60,6 +60,8 @@ pub struct CastCheck<'tcx> {\n     cast_ty: Ty<'tcx>,\n     cast_span: Span,\n     span: Span,\n+    /// whether the cast is made in a const context or not.\n+    pub constness: hir::Constness,\n }\n \n /// The kind of pointer and associated metadata (thin, length or vtable) - we\n@@ -210,9 +212,10 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         cast_ty: Ty<'tcx>,\n         cast_span: Span,\n         span: Span,\n+        constness: hir::Constness,\n     ) -> Result<CastCheck<'tcx>, ErrorGuaranteed> {\n         let expr_span = expr.span.find_ancestor_inside(span).unwrap_or(expr.span);\n-        let check = CastCheck { expr, expr_ty, expr_span, cast_ty, cast_span, span };\n+        let check = CastCheck { expr, expr_ty, expr_span, cast_ty, cast_span, span, constness };\n \n         // For better error messages, check for some obviously unsized\n         // cases now. We do a more thorough check at the end, once\n@@ -866,7 +869,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n \n-            (_, DynStar) | (DynStar, _) => bug!(\"should be handled by `try_coerce`\"),\n+            (_, DynStar) | (DynStar, _) => {\n+                if fcx.tcx.features().dyn_star {\n+                    bug!(\"should be handled by `try_coerce`\")\n+                } else {\n+                    Err(CastError::IllegalCast)\n+                }\n+            }\n         }\n     }\n "}, {"sha": "16febfc46da902ae3333a2bce5ab8add720ac206", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -530,24 +530,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         hir_id: hir::HirId,\n     ) -> Vec<AssocItem> {\n-        let mut methods =\n-            self.probe_for_return_type(span, probe::Mode::MethodCall, expected, checked_ty, hir_id);\n-        methods.retain(|m| {\n-            self.has_only_self_parameter(m)\n-                && self\n-                    .tcx\n-                    // This special internal attribute is used to permit\n-                    // \"identity-like\" conversion methods to be suggested here.\n-                    //\n-                    // FIXME (#46459 and #46460): ideally\n-                    // `std::convert::Into::into` and `std::borrow:ToOwned` would\n-                    // also be `#[rustc_conversion_suggestion]`, if not for\n-                    // method-probing false-positives and -negatives (respectively).\n-                    //\n-                    // FIXME? Other potential candidate methods: `as_ref` and\n-                    // `as_mut`?\n-                    .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n-        });\n+        let methods = self.probe_for_return_type(\n+            span,\n+            probe::Mode::MethodCall,\n+            expected,\n+            checked_ty,\n+            hir_id,\n+            |m| {\n+                self.has_only_self_parameter(m)\n+                    && self\n+                        .tcx\n+                        // This special internal attribute is used to permit\n+                        // \"identity-like\" conversion methods to be suggested here.\n+                        //\n+                        // FIXME (#46459 and #46460): ideally\n+                        // `std::convert::Into::into` and `std::borrow:ToOwned` would\n+                        // also be `#[rustc_conversion_suggestion]`, if not for\n+                        // method-probing false-positives and -negatives (respectively).\n+                        //\n+                        // FIXME? Other potential candidate methods: `as_ref` and\n+                        // `as_mut`?\n+                        .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n+            },\n+        );\n \n         methods\n     }\n@@ -714,7 +719,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n-    ) -> Option<(Span, String, String, Applicability, bool /* verbose */)> {\n+    ) -> Option<(\n+        Span,\n+        String,\n+        String,\n+        Applicability,\n+        bool, /* verbose */\n+        bool, /* suggest `&` or `&mut` type annotation */\n+    )> {\n         let sess = self.sess();\n         let sp = expr.span;\n \n@@ -746,6 +758,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     String::new(),\n                                     Applicability::MachineApplicable,\n                                     true,\n+                                    false,\n                                 ));\n                             }\n                         }\n@@ -760,6 +773,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     \"b\".to_string(),\n                                     Applicability::MachineApplicable,\n                                     true,\n+                                    false,\n                                 ));\n                     }\n                 }\n@@ -817,6 +831,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 sugg.2,\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ));\n                         }\n \n@@ -844,13 +859,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 format!(\"{prefix}&mut {sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\".to_string(),\n                                 format!(\"{prefix}&{sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ),\n                         });\n                     }\n@@ -880,6 +897,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n+                            true\n                         ));\n                     }\n                     return None;\n@@ -893,6 +911,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         String::new(),\n                         Applicability::MachineApplicable,\n                         true,\n+                        true,\n                     ));\n                 }\n             }\n@@ -959,6 +978,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             src,\n                             applicability,\n                             true,\n+                            false,\n                         ));\n                     }\n                 }\n@@ -999,6 +1019,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Applicability::MachineApplicable\n                             },\n                             true,\n+                            false,\n                         ));\n                     }\n \n@@ -1050,6 +1071,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             suggestion,\n                             Applicability::MachineApplicable,\n                             true,\n+                            false,\n                         ));\n                     }\n                 }"}, {"sha": "9fde62a81a1a666704152916dd50dcd36a8a2c94", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1272,7 +1272,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-            match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+            match cast::CastCheck::new(\n+                self,\n+                e,\n+                t_expr,\n+                t_cast,\n+                t.span,\n+                expr.span,\n+                self.param_env.constness(),\n+            ) {\n                 Ok(cast_check) => {\n                     debug!(\n                         \"check_expr_cast: deferring cast from {:?} to {:?}: {:?}\","}, {"sha": "8e0fcb56c7f37155dc714fe0afc0117a6f5e794f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -33,16 +33,27 @@ use rustc_span::{self, sym, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::iter;\n+use std::mem;\n use std::ops::ControlFlow;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub(in super::super) fn check_casts(&self) {\n-        let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+    pub(in super::super) fn check_casts(&mut self) {\n+        // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n+        // when writing to `self.param_env`.\n+        let mut deferred_cast_checks = mem::take(&mut *self.deferred_cast_checks.borrow_mut());\n+\n         debug!(\"FnCtxt::check_casts: {} deferred checks\", deferred_cast_checks.len());\n         for cast in deferred_cast_checks.drain(..) {\n+            let prev_env = self.param_env;\n+            self.param_env = self.param_env.with_constness(cast.constness);\n+\n             cast.check(self);\n+\n+            self.param_env = prev_env;\n         }\n+\n+        *self.deferred_cast_checks.borrow_mut() = deferred_cast_checks;\n     }\n \n     pub(in super::super) fn check_transmutes(&self) {"}, {"sha": "4db9c56f98fee3440daa27e6aafa5e4002c283bf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -327,17 +327,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         let expr = expr.peel_blocks();\n-        if let Some((sp, msg, suggestion, applicability, verbose)) =\n+        if let Some((sp, msg, suggestion, applicability, verbose, annotation)) =\n             self.check_ref(expr, found, expected)\n         {\n             if verbose {\n                 err.span_suggestion_verbose(sp, &msg, suggestion, applicability);\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n+            if annotation {\n+                let suggest_annotation = match expr.peel_drop_temps().kind {\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, _) => \"&\",\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) => \"&mut \",\n+                    _ => return true,\n+                };\n+                let mut tuple_indexes = Vec::new();\n+                let mut expr_id = expr.hir_id;\n+                for (parent_id, node) in self.tcx.hir().parent_iter(expr.hir_id) {\n+                    match node {\n+                        Node::Expr(&Expr { kind: ExprKind::Tup(subs), .. }) => {\n+                            tuple_indexes.push(\n+                                subs.iter()\n+                                    .enumerate()\n+                                    .find(|(_, sub_expr)| sub_expr.hir_id == expr_id)\n+                                    .unwrap()\n+                                    .0,\n+                            );\n+                            expr_id = parent_id;\n+                        }\n+                        Node::Local(local) => {\n+                            if let Some(mut ty) = local.ty {\n+                                while let Some(index) = tuple_indexes.pop() {\n+                                    match ty.kind {\n+                                        TyKind::Tup(tys) => ty = &tys[index],\n+                                        _ => return true,\n+                                    }\n+                                }\n+                                let annotation_span = ty.span;\n+                                err.span_suggestion(\n+                                    annotation_span.with_hi(annotation_span.lo()),\n+                                    format!(\"alternatively, consider changing the type annotation\"),\n+                                    suggest_annotation,\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            break;\n+                        }\n+                        _ => break,\n+                    }\n+                }\n+            }\n             return true;\n-        } else if self.suggest_else_fn_with_closure(err, expr, found, expected)\n-        {\n+        } else if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n             return true;\n         } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n             && let ty::FnDef(def_id, ..) = &found.kind()"}, {"sha": "959c54866453dd8520f2ef00eaf979ce3886d264", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -52,7 +52,7 @@ pub use inherited::{Inherited, InheritedBuilder};\n use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{struct_span_err, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -174,7 +174,7 @@ fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n+fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &UnordSet<LocalDefId> {\n     &*tcx.typeck(def_id).used_trait_imports\n }\n "}, {"sha": "28aa2302f882f92a03e4aaea45318f32c2046942", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -252,14 +252,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// would result in an error (basically, the same criteria we\n     /// would use to decide if a method is a plausible fit for\n     /// ambiguity purposes).\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self, candidate_filter))]\n     pub fn probe_for_return_type(\n         &self,\n         span: Span,\n         mode: Mode,\n         return_type: Ty<'tcx>,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n+        candidate_filter: impl Fn(&ty::AssocItem) -> bool,\n     ) -> Vec<ty::AssocItem> {\n         let method_names = self\n             .probe_op(\n@@ -271,7 +272,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self_ty,\n                 scope_expr_id,\n                 ProbeScope::AllTraits,\n-                |probe_cx| Ok(probe_cx.candidate_method_names()),\n+                |probe_cx| Ok(probe_cx.candidate_method_names(candidate_filter)),\n             )\n             .unwrap_or_default();\n         method_names\n@@ -966,12 +967,16 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn candidate_method_names(&self) -> Vec<Ident> {\n+    fn candidate_method_names(\n+        &self,\n+        candidate_filter: impl Fn(&ty::AssocItem) -> bool,\n+    ) -> Vec<Ident> {\n         let mut set = FxHashSet::default();\n         let mut names: Vec<_> = self\n             .inherent_candidates\n             .iter()\n             .chain(&self.extension_candidates)\n+            .filter(|candidate| candidate_filter(&candidate.item))\n             .filter(|candidate| {\n                 if let Some(return_ty) = self.return_type {\n                     self.matches_return_type(&candidate.item, None, return_ty)\n@@ -1689,7 +1694,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n \n-            let method_names = pcx.candidate_method_names();\n+            let method_names = pcx.candidate_method_names(|_| true);\n             pcx.allow_similar_names = false;\n             let applicable_close_candidates: Vec<ty::AssocItem> = method_names\n                 .iter()"}, {"sha": "6c21ed902d007112c7b256412fafeb6f86ae8f85", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let report_candidates = |span: Span,\n                                  err: &mut Diagnostic,\n-                                 mut sources: Vec<CandidateSource>,\n+                                 sources: &mut Vec<CandidateSource>,\n                                  sugg_span: Span| {\n             sources.sort();\n             sources.dedup();\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match error {\n             MethodError::NoMatch(NoMatchData {\n-                static_candidates: static_sources,\n+                static_candidates: mut static_sources,\n                 unsatisfied_predicates,\n                 out_of_scope_traits,\n                 lev_candidate,\n@@ -422,9 +422,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n                     }\n \n-                    report_candidates(span, &mut err, static_sources, sugg_span);\n+                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n                 } else if static_sources.len() > 1 {\n-                    report_candidates(span, &mut err, static_sources, sugg_span);\n+                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n                 }\n \n                 let mut bound_spans = vec![];\n@@ -1007,6 +1007,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         source,\n                         out_of_scope_traits,\n                         &unsatisfied_predicates,\n+                        &static_sources,\n                         unsatisfied_bounds,\n                     );\n                 }\n@@ -1079,7 +1080,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return Some(err);\n             }\n \n-            MethodError::Ambiguity(sources) => {\n+            MethodError::Ambiguity(mut sources) => {\n                 let mut err = struct_span_err!(\n                     self.sess(),\n                     item_name.span,\n@@ -1088,7 +1089,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 err.span_label(item_name.span, format!(\"multiple `{}` found\", item_name));\n \n-                report_candidates(span, &mut err, sources, sugg_span);\n+                report_candidates(span, &mut err, &mut sources, sugg_span);\n                 err.emit();\n             }\n \n@@ -2015,6 +2016,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Option<ty::Predicate<'tcx>>,\n             Option<ObligationCause<'tcx>>,\n         )],\n+        static_candidates: &[CandidateSource],\n         unsatisfied_bounds: bool,\n     ) {\n         let mut alt_rcvr_sugg = false;\n@@ -2128,6 +2130,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(attr) => attr.level.is_stable(),\n                 None => true,\n             })\n+            .filter(|info| {\n+                // Static candidates are already implemented, and known not to work\n+                // Do not suggest them again\n+                static_candidates.iter().all(|sc| match *sc {\n+                    CandidateSource::Trait(def_id) => def_id != info.def_id,\n+                    CandidateSource::Impl(def_id) => {\n+                        self.tcx.trait_id_of_impl(def_id) != Some(info.def_id)\n+                    }\n+                })\n+            })\n             .filter(|info| {\n                 // We approximate the coherence rules to only suggest\n                 // traits that are legal to implement by requiring that"}, {"sha": "79e2d371ed37394c8a3e549a3d9be616452fe541", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -149,19 +149,19 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         for id in crate_items.trait_items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         for id in crate_items.impl_items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         for id in crate_items.foreign_items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         let mut all_attrs = FindAllAttrs { tcx, found_attrs: vec![] };"}, {"sha": "a299a3e578d2237bf8a32dea8157939fdcedf200", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -16,8 +16,8 @@ use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelating\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n-use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n+use crate::traits::{PredicateObligations, TraitEngine};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n@@ -509,7 +509,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         for &(a, b) in &query_response.value.opaque_types {\n             let a = substitute_value(self.tcx, &result_subst, a);\n             let b = substitute_value(self.tcx, &result_subst, b);\n-            obligations.extend(self.handle_opaque_type(a, b, true, cause, param_env)?.obligations);\n+            obligations.extend(self.at(cause, param_env).eq(a, b)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })\n@@ -632,7 +632,7 @@ impl<'tcx> InferCtxt<'tcx> {\n /// creates query region constraints.\n pub fn make_query_region_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory)>,\n+    outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n     let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n@@ -741,17 +741,11 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         true\n     }\n \n-    fn register_opaque_type(\n+    fn register_opaque_type_obligations(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n+        obligations: PredicateObligations<'tcx>,\n     ) -> Result<(), TypeError<'tcx>> {\n-        self.obligations.extend(\n-            self.infcx\n-                .handle_opaque_type(a, b, a_is_expected, &self.cause, self.param_env)?\n-                .obligations,\n-        );\n+        self.obligations.extend(obligations);\n         Ok(())\n     }\n }"}, {"sha": "9bf755d7fcdf974855b4ac88687c671cd00669e7", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -286,8 +286,8 @@ pub fn suggest_new_region_bound(\n ) {\n     debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n     // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-    let consider = \"consider changing the\";\n-    let declare = \"to declare that the\";\n+    let consider = \"consider changing\";\n+    let declare = \"to declare that\";\n     let explicit = format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n     let explicit_static =\n         arg.map(|arg| format!(\"explicit `'static` bound to the lifetime of {}\", arg));\n@@ -305,6 +305,10 @@ pub fn suggest_new_region_bound(\n                     return;\n                 };\n \n+                // Get the identity type for this RPIT\n+                let did = item_id.owner_id.to_def_id();\n+                let ty = tcx.mk_opaque(did, ty::InternalSubsts::identity_for_item(tcx, did));\n+\n                 if let Some(span) = opaque\n                     .bounds\n                     .iter()\n@@ -321,7 +325,7 @@ pub fn suggest_new_region_bound(\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n-                            &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                            &format!(\"{consider} `{ty}`'s {explicit_static}\"),\n                             &lifetime_name,\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -351,12 +355,7 @@ pub fn suggest_new_region_bound(\n                 } else {\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n-                        &format!(\n-                            \"{declare} `impl Trait` {captures}, {explicit}\",\n-                            declare = declare,\n-                            captures = captures,\n-                            explicit = explicit,\n-                        ),\n+                        &format!(\"{declare} `{ty}` {captures}, {explicit}\",),\n                         &plus_lt,\n                         Applicability::MaybeIncorrect,\n                     );\n@@ -367,7 +366,7 @@ pub fn suggest_new_region_bound(\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n                         &format!(\n-                            \"{declare} trait object {captures}, {explicit}\",\n+                            \"{declare} the trait object {captures}, {explicit}\",\n                             declare = declare,\n                             captures = captures,\n                             explicit = explicit,\n@@ -384,7 +383,7 @@ pub fn suggest_new_region_bound(\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             lt.span,\n-                            &format!(\"{} trait object's {}\", consider, explicit_static),\n+                            &format!(\"{} the trait object's {}\", consider, explicit_static),\n                             &lifetime_name,\n                             Applicability::MaybeIncorrect,\n                         );"}, {"sha": "ffb020398b858f90d1e3104a93a8a622619be9f0", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -425,7 +425,7 @@ pub enum SubregionOrigin<'tcx> {\n static_assert_size!(SubregionOrigin<'_>, 32);\n \n impl<'tcx> SubregionOrigin<'tcx> {\n-    pub fn to_constraint_category(&self) -> ConstraintCategory {\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n         match self {\n             Self::Subtype(type_trace) => type_trace.cause.to_constraint_category(),\n             Self::AscribeUserTypeProvePredicate(span) => ConstraintCategory::Predicate(*span),\n@@ -1469,7 +1469,12 @@ impl<'tcx> InferCtxt<'tcx> {\n          * except during the writeback phase.\n          */\n \n-        resolve::fully_resolve(self, value)\n+        let value = resolve::fully_resolve(self, value);\n+        assert!(\n+            value.as_ref().map_or(true, |value| !value.needs_infer()),\n+            \"`{value:?}` is not fully resolved\"\n+        );\n+        value\n     }\n \n     pub fn replace_bound_vars_with_fresh_vars<T>("}, {"sha": "600f94f095eace0056fc0af4292245a197946f0f", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -25,7 +25,9 @@ use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::traits::PredicateObligation;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n@@ -91,11 +93,9 @@ pub trait TypeRelatingDelegate<'tcx> {\n     );\n \n     fn const_equate(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n-    fn register_opaque_type(\n+    fn register_opaque_type_obligations(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n+        obligations: Vec<PredicateObligation<'tcx>>,\n     ) -> Result<(), TypeError<'tcx>>;\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n@@ -414,7 +414,12 @@ where\n             (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n             _ => unreachable!(),\n         };\n-        self.delegate.register_opaque_type(a, b, true)?;\n+        let cause = ObligationCause::dummy_with_span(self.delegate.span());\n+        let obligations = self\n+            .infcx\n+            .handle_opaque_type(a, b, true, &cause, self.delegate.param_env())?\n+            .obligations;\n+        self.delegate.register_opaque_type_obligations(obligations)?;\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }\n@@ -592,7 +597,7 @@ where\n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n             (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-                infcx.commit_if_ok(|_| infcx.super_combine_tys(self, a, b)).or_else(|err| {\n+                infcx.super_combine_tys(self, a, b).or_else(|err| {\n                     self.tcx().sess.delay_span_bug(\n                         self.delegate.span(),\n                         \"failure to relate an opaque to itself should result in an error later on\","}, {"sha": "a982f11f7187fa7703f46bf1eb5f81694479f272", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             return Ok(InferOk { value: (), obligations: vec![] });\n         }\n         let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n-        let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n+        let process = |a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected| match *a.kind() {\n             ty::Opaque(def_id, substs) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n                 let origin = match self.defining_use_anchor {\n@@ -169,13 +169,14 @@ impl<'tcx> InferCtxt<'tcx> {\n                     param_env,\n                     b,\n                     origin,\n+                    a_is_expected,\n                 ))\n             }\n             _ => None,\n         };\n-        if let Some(res) = process(a, b) {\n+        if let Some(res) = process(a, b, true) {\n             res\n-        } else if let Some(res) = process(b, a) {\n+        } else if let Some(res) = process(b, a, false) {\n             res\n         } else {\n             let (a, b) = self.resolve_vars_if_possible((a, b));\n@@ -514,13 +515,14 @@ impl UseKind {\n \n impl<'tcx> InferCtxt<'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn register_hidden_type(\n+    fn register_hidden_type(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         hidden_ty: Ty<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n+        a_is_expected: bool,\n     ) -> InferResult<'tcx, ()> {\n         let tcx = self.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n@@ -539,7 +541,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             origin,\n         );\n         if let Some(prev) = prev {\n-            obligations = self.at(&cause, param_env).eq(prev, hidden_ty)?.obligations;\n+            obligations =\n+                self.at(&cause, param_env).eq_exp(a_is_expected, prev, hidden_ty)?.obligations;\n         }\n \n         let item_bounds = tcx.bound_explicit_item_bounds(def_id.to_def_id());"}, {"sha": "6ca884799aa6fb3b77b5891c6ff20175f9aab922", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -210,7 +210,7 @@ pub trait TypeOutlivesDelegate<'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        constraint_category: ConstraintCategory,\n+        constraint_category: ConstraintCategory<'tcx>,\n     );\n \n     fn push_verify(\n@@ -259,7 +259,7 @@ where\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         assert!(!ty.has_escaping_bound_vars());\n \n@@ -273,7 +273,7 @@ where\n         origin: infer::SubregionOrigin<'tcx>,\n         components: &[Component<'tcx>],\n         region: ty::Region<'tcx>,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         for component in components.iter() {\n             let origin = origin.clone();\n@@ -529,7 +529,7 @@ impl<'cx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'tcx> {\n         origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        _constraint_category: ConstraintCategory,\n+        _constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         self.sub_regions(origin, a, b)\n     }"}, {"sha": "97354ba5d1bd1c2cf044988eaedf7cf536750423", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2,9 +2,7 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::Obligation;\n-use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::TyVar;\n@@ -130,39 +128,18 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n                 if self.fields.define_opaque_types && did.is_local() =>\n             {\n-                let mut generalize = |ty, ty_is_expected| {\n-                    let var = infcx.next_ty_var_id_in_universe(\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: self.fields.trace.cause.span,\n-                        },\n-                        ty::UniverseIndex::ROOT,\n-                    );\n-                    self.fields.instantiate(ty, RelationDir::SubtypeOf, var, ty_is_expected)?;\n-                    Ok(infcx.tcx.mk_ty_var(var))\n-                };\n-                let (a, b) = if self.a_is_expected { (a, b) } else { (b, a) };\n-                let (ga, gb) = match (a.kind(), b.kind()) {\n-                    (&ty::Opaque(..), _) => (a, generalize(b, true)?),\n-                    (_, &ty::Opaque(..)) => (generalize(a, false)?, b),\n-                    _ => unreachable!(),\n-                };\n                 self.fields.obligations.extend(\n                     infcx\n-                        .handle_opaque_type(ga, gb, true, &self.fields.trace.cause, self.param_env())\n-                        // Don't leak any generalized type variables out of this\n-                        // subtyping relation in the case of a type error.\n-                        .map_err(|err| {\n-                            let (ga, gb) = self.fields.infcx.resolve_vars_if_possible((ga, gb));\n-                            if let TypeError::Sorts(sorts) = err && sorts.expected == ga && sorts.found == gb {\n-                                TypeError::Sorts(ExpectedFound { expected: a, found: b })\n-                            } else {\n-                                err\n-                            }\n-                        })?\n+                        .handle_opaque_type(\n+                            a,\n+                            b,\n+                            self.a_is_expected,\n+                            &self.fields.trace.cause,\n+                            self.param_env(),\n+                        )?\n                         .obligations,\n                 );\n-                Ok(ga)\n+                Ok(a)\n             }\n             // Optimization of GeneratorWitness relation since we know that all\n             // free regions are replaced with bound regions during construction."}, {"sha": "7f1d21bf1d8b0cdebacd4fb2dc8b1ab73776d69d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::{ErrorGuaranteed, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::StableCrateId;\n-use rustc_hir::definitions::Definitions;\n use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n@@ -30,7 +29,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn};\n+use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -135,10 +134,7 @@ mod boxed_resolver {\n             f((&mut *resolver).as_mut().unwrap())\n         }\n \n-        pub fn to_resolver_outputs(\n-            resolver: Rc<RefCell<BoxedResolver>>,\n-        ) -> (Definitions, Box<CrateStoreDyn>, ty::ResolverOutputs, ty::ResolverAstLowering)\n-        {\n+        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ty::ResolverOutputs {\n             match Rc::try_unwrap(resolver) {\n                 Ok(resolver) => {\n                     let mut resolver = resolver.into_inner();\n@@ -788,8 +784,7 @@ pub fn create_global_ctxt<'tcx>(\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n-    let (definitions, cstore, resolver_outputs, resolver_for_lowering) =\n-        BoxedResolver::to_resolver_outputs(resolver);\n+    let resolver_outputs = BoxedResolver::to_resolver_outputs(resolver);\n \n     let sess = &compiler.session();\n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n@@ -816,10 +811,7 @@ pub fn create_global_ctxt<'tcx>(\n                 lint_store,\n                 arena,\n                 hir_arena,\n-                definitions,\n-                cstore,\n                 resolver_outputs,\n-                resolver_for_lowering,\n                 krate,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n@@ -935,7 +927,7 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n     sess.time(\"misc_checking_3\", || {\n         parallel!(\n             {\n-                tcx.ensure().privacy_access_levels(());\n+                tcx.ensure().effective_visibilities(());\n \n                 parallel!(\n                     {"}, {"sha": "4c236c693d0feafed883e1dd2365ec050e58892b", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -9,7 +9,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n     for id in tcx.hir().items() {\n         let attrs = finder.tcx.hir().attrs(id.hir_id());\n         if finder.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n-            finder.decls = Some(id.def_id.def_id);\n+            finder.decls = Some(id.owner_id.def_id);\n         }\n     }\n "}, {"sha": "51515976e4ee97371520f892b854ad076ba36fb4", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -57,29 +57,42 @@ pub enum TokenKind {\n     // Multi-char tokens:\n     /// \"// comment\"\n     LineComment { doc_style: Option<DocStyle> },\n+\n     /// `/* block comment */`\n     ///\n-    /// Block comments can be recursive, so the sequence like `/* /* */`\n+    /// Block comments can be recursive, so a sequence like `/* /* */`\n     /// will not be considered terminated and will result in a parsing error.\n     BlockComment { doc_style: Option<DocStyle>, terminated: bool },\n-    /// Any whitespace characters sequence.\n+\n+    /// Any whitespace character sequence.\n     Whitespace,\n+\n     /// \"ident\" or \"continue\"\n-    /// At this step keywords are also considered identifiers.\n+    ///\n+    /// At this step, keywords are also considered identifiers.\n     Ident,\n+\n     /// Like the above, but containing invalid unicode codepoints.\n     InvalidIdent,\n+\n     /// \"r#ident\"\n     RawIdent,\n-    /// An unknown prefix like `foo#`, `foo'`, `foo\"`. Note that only the\n+\n+    /// An unknown prefix, like `foo#`, `foo'`, `foo\"`.\n+    ///\n+    /// Note that only the\n     /// prefix (`foo`) is included in the token, not the separator (which is\n     /// lexed as its own distinct token). In Rust 2021 and later, reserved\n     /// prefixes are reported as errors; in earlier editions, they result in a\n     /// (allowed by default) lint, and are treated as regular identifier\n     /// tokens.\n     UnknownPrefix,\n-    /// \"12_u8\", \"1.0e-40\", \"b\"123\"\". See `LiteralKind` for more details.\n+\n+    /// Examples: `\"12_u8\"`, `\"1.0e-40\"`, `b\"123`.\n+    ///\n+    /// See [LiteralKind] for more details.\n     Literal { kind: LiteralKind, suffix_start: u32 },\n+\n     /// \"'a\"\n     Lifetime { starts_with_number: bool },\n "}, {"sha": "d425adf47f06c10064d872790233d63d983dc4d1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -177,7 +177,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..) => {\n-                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.def_id))\n+                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.owner_id))\n             }\n             _ => (),\n         }\n@@ -563,7 +563,7 @@ impl MissingDoc {\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a `NodeId`).\n         if def_id != CRATE_DEF_ID {\n-            if !cx.access_levels.is_exported(def_id) {\n+            if !cx.effective_visibilities.is_exported(def_id) {\n                 return;\n             }\n         }\n@@ -606,9 +606,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         match it.kind {\n             hir::ItemKind::Trait(..) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n-                if cx.tcx.visibility(it.def_id)\n+                if cx.tcx.visibility(it.owner_id)\n                     == ty::Visibility::Restricted(\n-                        cx.tcx.parent_module_from_def_id(it.def_id.def_id).to_def_id(),\n+                        cx.tcx.parent_module_from_def_id(it.owner_id.def_id).to_def_id(),\n                     )\n                 {\n                     return;\n@@ -627,15 +627,15 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             _ => return,\n         };\n \n-        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.owner_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, it.def_id.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, it.owner_id.def_id, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n-        let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(trait_item.owner_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, trait_item.def_id.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, trait_item.owner_id.def_id, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n@@ -662,13 +662,13 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             }\n         }\n \n-        let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, impl_item.def_id.def_id, article, desc);\n+        let (article, desc) = cx.tcx.article_and_description(impl_item.owner_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, impl_item.owner_id.def_id, article, desc);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n-        let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, foreign_item.def_id.def_id, article, desc);\n+        let (article, desc) = cx.tcx.article_and_description(foreign_item.owner_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, foreign_item.owner_id.def_id, article, desc);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, sf: &hir::FieldDef<'_>) {\n@@ -721,29 +721,29 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_reachable(item.owner_id.def_id) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(item.def_id);\n+                let def = cx.tcx.adt_def(item.owner_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(item.def_id);\n+                let def = cx.tcx.adt_def(item.owner_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(item.def_id);\n+                let def = cx.tcx.adt_def(item.owner_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -752,7 +752,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             return;\n         }\n         let param_env = ty::ParamEnv::empty();\n-        if ty.is_copy_modulo_regions(cx.tcx.at(item.span), param_env) {\n+        if ty.is_copy_modulo_regions(cx.tcx, param_env) {\n             return;\n         }\n         if can_type_implement_copy(\n@@ -814,7 +814,7 @@ impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_reachable(item.owner_id.def_id) {\n             return;\n         }\n \n@@ -841,7 +841,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             debug!(\"{:?}\", self.impling_types);\n         }\n \n-        if !self.impling_types.as_ref().unwrap().contains(&item.def_id.def_id) {\n+        if !self.impling_types.as_ref().unwrap().contains(&item.owner_id.def_id) {\n             cx.struct_span_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n@@ -1226,7 +1226,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n                                 Some(generics),\n-                                cx.tcx.hir().get_generics(it.id.def_id.def_id).unwrap(),\n+                                cx.tcx.hir().get_generics(it.id.owner_id.def_id).unwrap(),\n                                 it.span,\n                             );\n                         }\n@@ -1385,7 +1385,8 @@ impl UnreachablePub {\n         exportable: bool,\n     ) {\n         let mut applicability = Applicability::MachineApplicable;\n-        if cx.tcx.visibility(def_id).is_public() && !cx.access_levels.is_reachable(def_id) {\n+        if cx.tcx.visibility(def_id).is_public() && !cx.effective_visibilities.is_reachable(def_id)\n+        {\n             if vis_span.from_expansion() {\n                 applicability = Applicability::MaybeIncorrect;\n             }\n@@ -1414,11 +1415,11 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n         if let hir::ItemKind::Use(_, hir::UseKind::ListStem) = &item.kind {\n             return;\n         }\n-        self.perform_lint(cx, \"item\", item.def_id.def_id, item.vis_span, true);\n+        self.perform_lint(cx, \"item\", item.owner_id.def_id, item.vis_span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n-        self.perform_lint(cx, \"item\", foreign_item.def_id.def_id, foreign_item.vis_span, true);\n+        self.perform_lint(cx, \"item\", foreign_item.owner_id.def_id, foreign_item.vis_span, true);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n@@ -1428,8 +1429,8 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // Only lint inherent impl items.\n-        if cx.tcx.associated_item(impl_item.def_id).trait_item_def_id.is_none() {\n-            self.perform_lint(cx, \"item\", impl_item.def_id.def_id, impl_item.vis_span, false);\n+        if cx.tcx.associated_item(impl_item.owner_id).trait_item_def_id.is_none() {\n+            self.perform_lint(cx, \"item\", impl_item.owner_id.def_id, impl_item.vis_span, false);\n         }\n     }\n }\n@@ -1638,7 +1639,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n         use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n-            let predicates = cx.tcx.predicates_of(item.def_id);\n+            let predicates = cx.tcx.predicates_of(item.owner_id);\n             for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate.kind().skip_binder() {\n                     Trait(..) => \"trait\",\n@@ -1881,7 +1882,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n                 self.items_nameable = false;\n-                self.boundary = Some(it.def_id);\n+                self.boundary = Some(it.owner_id);\n             }\n             return;\n         }\n@@ -1898,7 +1899,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_>, it: &hir::Item<'_>) {\n-        if !self.items_nameable && self.boundary == Some(it.def_id) {\n+        if !self.items_nameable && self.boundary == Some(it.owner_id) {\n             self.items_nameable = true;\n         }\n     }\n@@ -2164,7 +2165,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n-        let def_id = item.def_id.def_id;\n+        let def_id = item.owner_id.def_id;\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n         | hir::ItemKind::Enum(_, ref hir_generics)\n         | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n@@ -2743,7 +2744,7 @@ impl ClashingExternDeclarations {\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists\n     /// for the item, return its HirId without updating the set.\n     fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<HirId> {\n-        let did = fi.def_id.to_def_id();\n+        let did = fi.owner_id.to_def_id();\n         let instance = Instance::new(did, ty::List::identity_for_item(tcx, did));\n         let name = Symbol::intern(tcx.symbol_name(instance).name);\n         if let Some(&hir_id) = self.seen_decls.get(&name) {\n@@ -2761,14 +2762,14 @@ impl ClashingExternDeclarations {\n     /// symbol's name.\n     fn name_of_extern_decl(tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> SymbolName {\n         if let Some((overridden_link_name, overridden_link_name_span)) =\n-            tcx.codegen_fn_attrs(fi.def_id).link_name.map(|overridden_link_name| {\n+            tcx.codegen_fn_attrs(fi.owner_id).link_name.map(|overridden_link_name| {\n                 // FIXME: Instead of searching through the attributes again to get span\n                 // information, we could have codegen_fn_attrs also give span information back for\n                 // where the attribute was defined. However, until this is found to be a\n                 // bottleneck, this does just fine.\n                 (\n                     overridden_link_name,\n-                    tcx.get_attr(fi.def_id.to_def_id(), sym::link_name).unwrap().span,\n+                    tcx.get_attr(fi.owner_id.to_def_id(), sym::link_name).unwrap().span,\n                 )\n             })\n         {\n@@ -2985,10 +2986,10 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n             let tcx = cx.tcx;\n             if let Some(existing_hid) = self.insert(tcx, this_fi) {\n                 let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n-                let this_decl_ty = tcx.type_of(this_fi.def_id);\n+                let this_decl_ty = tcx.type_of(this_fi.owner_id);\n                 debug!(\n                     \"ClashingExternDeclarations: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n-                    existing_hid, existing_decl_ty, this_fi.def_id, this_decl_ty\n+                    existing_hid, existing_decl_ty, this_fi.owner_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n                 if !Self::structurally_same_type("}, {"sha": "cec0003ffea78b1460f2a999be9a9c1799d6ed0f", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -31,7 +31,7 @@ use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -542,7 +542,7 @@ pub struct LateContext<'tcx> {\n     pub param_env: ty::ParamEnv<'tcx>,\n \n     /// Items accessible from the crate being checked.\n-    pub access_levels: &'tcx AccessLevels,\n+    pub effective_visibilities: &'tcx EffectiveVisibilities,\n \n     /// The store of registered lints and the lint levels.\n     pub lint_store: &'tcx LintStore,"}, {"sha": "303fcb1a1d152349709856e31a4d02d54d0152b9", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -338,14 +338,14 @@ fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n     module_def_id: LocalDefId,\n     pass: T,\n ) {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n \n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n         cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n-        access_levels,\n+        effective_visibilities,\n         lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: tcx.hir().local_def_id_to_hir_id(module_def_id),\n         generics: None,\n@@ -386,14 +386,14 @@ pub fn late_lint_mod<'tcx, T: LateLintPass<'tcx>>(\n }\n \n fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n \n     let context = LateContext {\n         tcx,\n         enclosing_body: None,\n         cached_typeck_results: Cell::new(None),\n         param_env: ty::ParamEnv::empty(),\n-        access_levels,\n+        effective_visibilities,\n         lint_store: unerased_lint_store(tcx),\n         last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n         generics: None,"}, {"sha": "5288fc542d79a0b0f200f9bab547da6cbf1fa948", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -212,7 +212,7 @@ macro_rules! late_lint_mod_passes {\n                 TypeLimits: TypeLimits::new(),\n                 NonSnakeCase: NonSnakeCase,\n                 InvalidNoMangleItems: InvalidNoMangleItems,\n-                // Depends on access levels\n+                // Depends on effective visibilities\n                 UnreachablePub: UnreachablePub,\n                 ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n                 InvalidValue: InvalidValue,"}, {"sha": "00bf287ba6bdd9a49031dd3a61c7ca34b67aa49c", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -61,7 +61,7 @@ declare_lint_pass!(OpaqueHiddenInferredBound => [OPAQUE_HIDDEN_INFERRED_BOUND]);\n impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         let hir::ItemKind::OpaqueTy(_) = &item.kind else { return; };\n-        let def_id = item.def_id.def_id.to_def_id();\n+        let def_id = item.owner_id.def_id.to_def_id();\n         let infcx = &cx.tcx.infer_ctxt().build();\n         // For every projection predicate in the opaque type's explicit bounds,\n         // check that the type that we're assigning actually satisfies the bounds"}, {"sha": "f22f38aa2cea2abb832921555ca592e765ece362", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::PredicateKind::*;\n \n-        let predicates = cx.tcx.explicit_predicates_of(item.def_id);\n+        let predicates = cx.tcx.explicit_predicates_of(item.owner_id);\n         for &(predicate, span) in predicates.predicates {\n             let Trait(trait_predicate) = predicate.kind().skip_binder() else {\n                 continue"}, {"sha": "37caab2da0f5b0e61e6f618882b1ba40cfae6e86", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{Span, Symbol};\n use rustc_target::abi::{Abi, WrappingRange};\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n@@ -931,7 +931,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         match *ty.kind() {\n             ty::Adt(def, substs) => {\n                 if def.is_box() && matches!(self.mode, CItemKind::Definition) {\n-                    if ty.boxed_ty().is_sized(tcx.at(DUMMY_SP), self.cx.param_env) {\n+                    if ty.boxed_ty().is_sized(tcx, self.cx.param_env) {\n                         return FfiSafe;\n                     } else {\n                         return FfiUnsafe {\n@@ -1082,7 +1082,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n                 if {\n                     matches!(self.mode, CItemKind::Definition)\n-                        && ty.is_sized(self.cx.tcx.at(DUMMY_SP), self.cx.param_env)\n+                        && ty.is_sized(self.cx.tcx, self.cx.param_env)\n                 } =>\n             {\n                 FfiSafe\n@@ -1360,7 +1360,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n-            let t = cx.tcx.type_of(it.def_id);\n+            let t = cx.tcx.type_of(it.owner_id);\n             let ty = cx.tcx.erase_regions(t);\n             let Ok(layout) = cx.layout_of(ty) else { return };\n             let Variants::Multiple {"}, {"sha": "18d37d95a83575dc5e61f5f86364a402dcc916ed", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -69,7 +69,9 @@ extern \"C\" void LLVMInitializePasses() {\n   initializeAnalysis(Registry);\n   initializeTransformUtils(Registry);\n   initializeInstCombine(Registry);\n+#if LLVM_VERSION_LT(16, 0)\n   initializeInstrumentation(Registry);\n+#endif\n   initializeTarget(Registry);\n }\n "}, {"sha": "3ea83fd09c794d5092586afe89cdc70a76be9fe5", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -454,7 +454,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n \n                 self.formatting_init.extend(code_init);\n                 Ok(quote! {\n-                    #diag.span_suggestion_with_style(\n+                    #diag.span_suggestions_with_style(\n                         #span_field,\n                         rustc_errors::fluent::#slug,\n                         #code_field,"}, {"sha": "fa0ca5a52423af786b2c53bce1e4d6cf6a60874b", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -11,9 +11,11 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n+use super::utils::{build_suggestion_code, AllowMultipleAlternatives};\n+\n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n@@ -414,30 +416,31 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n                     let nested_name = nested_name.as_str();\n \n-                    let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) = meta else {\n-                        throw_invalid_nested_attr!(attr, &nested_attr);\n-                    };\n-\n                     match nested_name {\n                         \"code\" => {\n-                            let formatted_str = self.build_format(&value.value(), value.span());\n                             let code_field = new_code_ident();\n-                            code.set_once((code_field, formatted_str), span);\n+                            let formatting_init = build_suggestion_code(\n+                                &code_field,\n+                                meta,\n+                                self,\n+                                AllowMultipleAlternatives::No,\n+                            );\n+                            code.set_once((code_field, formatting_init), span);\n                         }\n                         _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n                         }),\n                     }\n                 }\n \n-                let Some((code_field, formatted_str)) = code.value() else {\n+                let Some((code_field, formatting_init)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                     return Ok(quote! {});\n                 };\n                 let binding = info.binding;\n \n-                self.formatting_init.extend(quote! { let #code_field = #formatted_str; });\n+                self.formatting_init.extend(formatting_init);\n                 let code_field = if clone_suggestion_code {\n                     quote! { #code_field.clone() }\n                 } else {"}, {"sha": "374c795d0a6385c81802224989716ab9227b9efa", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 94, "deletions": 11, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2,7 +2,7 @@ use crate::diagnostics::error::{\n     span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n };\n use proc_macro::Span;\n-use proc_macro2::TokenStream;\n+use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote, ToTokens};\n use std::cell::RefCell;\n use std::collections::{BTreeSet, HashMap};\n@@ -395,6 +395,82 @@ pub(super) fn build_field_mapping<'v>(variant: &VariantInfo<'v>) -> HashMap<Stri\n     fields_map\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub(super) enum AllowMultipleAlternatives {\n+    No,\n+    Yes,\n+}\n+\n+/// Constructs the `format!()` invocation(s) necessary for a `#[suggestion*(code = \"foo\")]` or\n+/// `#[suggestion*(code(\"foo\", \"bar\"))]` attribute field\n+pub(super) fn build_suggestion_code(\n+    code_field: &Ident,\n+    meta: &Meta,\n+    fields: &impl HasFieldMap,\n+    allow_multiple: AllowMultipleAlternatives,\n+) -> TokenStream {\n+    let values = match meta {\n+        // `code = \"foo\"`\n+        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => vec![s],\n+        // `code(\"foo\", \"bar\")`\n+        Meta::List(MetaList { nested, .. }) => {\n+            if let AllowMultipleAlternatives::No = allow_multiple {\n+                span_err(\n+                    meta.span().unwrap(),\n+                    \"expected exactly one string literal for `code = ...`\",\n+                )\n+                .emit();\n+                vec![]\n+            } else if nested.is_empty() {\n+                span_err(\n+                    meta.span().unwrap(),\n+                    \"expected at least one string literal for `code(...)`\",\n+                )\n+                .emit();\n+                vec![]\n+            } else {\n+                nested\n+                    .into_iter()\n+                    .filter_map(|item| {\n+                        if let NestedMeta::Lit(syn::Lit::Str(s)) = item {\n+                            Some(s)\n+                        } else {\n+                            span_err(\n+                                item.span().unwrap(),\n+                                \"`code(...)` must contain only string literals\",\n+                            )\n+                            .emit();\n+                            None\n+                        }\n+                    })\n+                    .collect()\n+            }\n+        }\n+        _ => {\n+            span_err(\n+                meta.span().unwrap(),\n+                r#\"`code = \"...\"`/`code(...)` must contain only string literals\"#,\n+            )\n+            .emit();\n+            vec![]\n+        }\n+    };\n+\n+    if let AllowMultipleAlternatives::Yes = allow_multiple {\n+        let formatted_strings: Vec<_> = values\n+            .into_iter()\n+            .map(|value| fields.build_format(&value.value(), value.span()))\n+            .collect();\n+        quote! { let #code_field = [#(#formatted_strings),*].into_iter(); }\n+    } else if let [value] = values.as_slice() {\n+        let formatted_str = fields.build_format(&value.value(), value.span());\n+        quote! { let #code_field = #formatted_str; }\n+    } else {\n+        // error handled previously\n+        quote! { let #code_field = String::new(); }\n+    }\n+}\n+\n /// Possible styles for suggestion subdiagnostics.\n #[derive(Clone, Copy)]\n pub(super) enum SuggestionKind {\n@@ -571,28 +647,35 @@ impl SubdiagnosticKind {\n             let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n             let nested_name = nested_name.as_str();\n \n-            let value = match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n+            let string_value = match meta {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => Some(value),\n+\n                 Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                     diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n                 }),\n-                _ => {\n-                    invalid_nested_attr(attr, &nested_attr).emit();\n-                    continue;\n-                }\n+                _ => None,\n             };\n \n             match (nested_name, &mut kind) {\n                 (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n-                    let formatted_str = fields.build_format(&value.value(), value.span());\n-                    let code_init = quote! { let #code_field = #formatted_str; };\n+                    let code_init = build_suggestion_code(\n+                        code_field,\n+                        meta,\n+                        fields,\n+                        AllowMultipleAlternatives::Yes,\n+                    );\n                     code.set_once(code_init, span);\n                 }\n                 (\n                     \"applicability\",\n                     SubdiagnosticKind::Suggestion { ref mut applicability, .. }\n                     | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n                 ) => {\n+                    let Some(value) = string_value else {\n+                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        continue;\n+                    };\n+\n                     let value = Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n                         span_err(span, \"invalid applicability\").emit();\n                         Applicability::Unspecified\n@@ -623,7 +706,7 @@ impl SubdiagnosticKind {\n                     init\n                 } else {\n                     span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                    quote! { let #code_field: String = unreachable!(); }\n+                    quote! { let #code_field = std::iter::empty(); }\n                 };\n             }\n             SubdiagnosticKind::Label\n@@ -644,7 +727,7 @@ impl quote::IdentFragment for SubdiagnosticKind {\n             SubdiagnosticKind::Note => write!(f, \"note\"),\n             SubdiagnosticKind::Help => write!(f, \"help\"),\n             SubdiagnosticKind::Warn => write!(f, \"warn\"),\n-            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n+            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestions_with_style\"),\n             SubdiagnosticKind::MultipartSuggestion { .. } => {\n                 write!(f, \"multipart_suggestion_with_style\")\n             }"}, {"sha": "d1c2f3104d072a34feb9806f5d468f1df136cbf7", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -6,13 +6,13 @@ use rustc_session::cstore::ForeignModule;\n pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut modules = Vec::new();\n     for id in tcx.hir().items() {\n-        if !matches!(tcx.def_kind(id.def_id), DefKind::ForeignMod) {\n+        if !matches!(tcx.def_kind(id.owner_id), DefKind::ForeignMod) {\n             continue;\n         }\n         let item = tcx.hir().item(id);\n         if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n-            let foreign_items = items.iter().map(|it| it.id.def_id.to_def_id()).collect();\n-            modules.push(ForeignModule { foreign_items, def_id: id.def_id.to_def_id() });\n+            let foreign_items = items.iter().map(|it| it.id.owner_id.to_def_id()).collect();\n+            modules.push(ForeignModule { foreign_items, def_id: id.owner_id.to_def_id() });\n         }\n     }\n     modules"}, {"sha": "20a2e78299aed0bb49dbe047f3befefc65e58046", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -98,7 +98,7 @@ struct Collector<'tcx> {\n \n impl<'tcx> Collector<'tcx> {\n     fn process_item(&mut self, id: rustc_hir::ItemId) {\n-        if !matches!(self.tcx.def_kind(id.def_id), DefKind::ForeignMod) {\n+        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::ForeignMod) {\n             return;\n         }\n \n@@ -372,17 +372,17 @@ impl<'tcx> Collector<'tcx> {\n                 }\n                 _ => {\n                     for child_item in foreign_mod_items {\n-                        if self.tcx.def_kind(child_item.id.def_id).has_codegen_attrs()\n+                        if self.tcx.def_kind(child_item.id.owner_id).has_codegen_attrs()\n                             && self\n                                 .tcx\n-                                .codegen_fn_attrs(child_item.id.def_id)\n+                                .codegen_fn_attrs(child_item.id.owner_id)\n                                 .link_ordinal\n                                 .is_some()\n                         {\n                             let link_ordinal_attr = self\n                                 .tcx\n                                 .hir()\n-                                .attrs(child_item.id.def_id.into())\n+                                .attrs(child_item.id.owner_id.into())\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();\n@@ -402,7 +402,7 @@ impl<'tcx> Collector<'tcx> {\n                 filename,\n                 kind,\n                 cfg,\n-                foreign_module: Some(it.def_id.to_def_id()),\n+                foreign_module: Some(it.owner_id.to_def_id()),\n                 wasm_import_module: wasm_import_module.map(|(name, _)| name),\n                 verbatim,\n                 dll_imports,\n@@ -505,7 +505,7 @@ impl<'tcx> Collector<'tcx> {\n     fn i686_arg_list_size(&self, item: &hir::ForeignItemRef) -> usize {\n         let argument_types: &List<Ty<'_>> = self.tcx.erase_late_bound_regions(\n             self.tcx\n-                .type_of(item.id.def_id)\n+                .type_of(item.id.owner_id)\n                 .fn_sig(self.tcx)\n                 .inputs()\n                 .map_bound(|slice| self.tcx.mk_type_list(slice.iter())),\n@@ -557,7 +557,7 @@ impl<'tcx> Collector<'tcx> {\n             }\n         };\n \n-        let codegen_fn_attrs = self.tcx.codegen_fn_attrs(item.id.def_id);\n+        let codegen_fn_attrs = self.tcx.codegen_fn_attrs(item.id.owner_id);\n         let import_name_type = codegen_fn_attrs\n             .link_ordinal\n             .map_or(import_name_type, |ord| Some(PeImportNameType::Ordinal(ord)));\n@@ -567,7 +567,7 @@ impl<'tcx> Collector<'tcx> {\n             import_name_type,\n             calling_convention,\n             span: item.span,\n-            is_fn: self.tcx.def_kind(item.id.def_id).is_fn_like(),\n+            is_fn: self.tcx.def_kind(item.id.owner_id).is_fn_like(),\n         }\n     }\n }"}, {"sha": "691e3d0f8f9026aafc0b2fde5040962be4e7e1fe", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -773,7 +773,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn opt_item_name(self, item_index: DefIndex) -> Option<Symbol> {\n-        self.def_key(item_index).disambiguated_data.data.get_opt_name()\n+        let def_key = self.def_key(item_index);\n+        def_key.disambiguated_data.data.get_opt_name().or_else(|| {\n+            if def_key.disambiguated_data.data == DefPathData::Ctor {\n+                let parent_index = def_key.parent.expect(\"no parent for a constructor\");\n+                self.def_key(parent_index).disambiguated_data.data.get_opt_name()\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     fn item_name(self, item_index: DefIndex) -> Symbol {\n@@ -905,7 +913,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n-                .map(|index| self.get_variant(&self.def_kind(index), index, did))\n+                .filter_map(|index| {\n+                    let kind = self.def_kind(index);\n+                    match kind {\n+                        DefKind::Ctor(..) => None,\n+                        _ => Some(self.get_variant(&kind, index, did)),\n+                    }\n+                })\n                 .collect()\n         } else {\n             std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n@@ -1029,50 +1043,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 callback(ModChild { ident, res, vis, span, macro_rules });\n \n-                // For non-re-export structs and variants add their constructors to children.\n-                // Re-export lists automatically contain constructors when necessary.\n-                match kind {\n-                    DefKind::Struct => {\n-                        if let Some((ctor_def_id, ctor_kind)) =\n-                            self.get_ctor_def_id_and_kind(child_index)\n-                        {\n-                            let ctor_res =\n-                                Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n-                            let vis = self.get_visibility(ctor_def_id.index);\n-                            callback(ModChild {\n-                                ident,\n-                                res: ctor_res,\n-                                vis,\n-                                span,\n-                                macro_rules: false,\n-                            });\n-                        }\n-                    }\n-                    DefKind::Variant => {\n-                        // Braced variants, unlike structs, generate unusable names in\n-                        // value namespace, they are reserved for possible future use.\n-                        // It's ok to use the variant's id as a ctor id since an\n-                        // error will be reported on any use of such resolution anyway.\n-                        let (ctor_def_id, ctor_kind) = self\n-                            .get_ctor_def_id_and_kind(child_index)\n-                            .unwrap_or((def_id, CtorKind::Fictive));\n-                        let ctor_res =\n-                            Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-                        let mut vis = self.get_visibility(ctor_def_id.index);\n-                        if ctor_def_id == def_id && vis.is_public() {\n-                            // For non-exhaustive variants lower the constructor visibility to\n-                            // within the crate. We only need this for fictive constructors,\n-                            // for other constructors correct visibilities\n-                            // were already encoded in metadata.\n-                            let mut attrs = self.get_item_attrs(def_id.index, sess);\n-                            if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n-                                let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n-                                vis = ty::Visibility::Restricted(crate_def_id);\n-                            }\n+                // For non-reexport variants add their fictive constructors to children.\n+                // Braced variants, unlike structs, generate unusable names in value namespace,\n+                // they are reserved for possible future use. It's ok to use the variant's id as\n+                // a ctor id since an error will be reported on any use of such resolution anyway.\n+                // Reexport lists automatically contain such constructors when necessary.\n+                if kind == DefKind::Variant && self.get_ctor_def_id_and_kind(child_index).is_none()\n+                {\n+                    let ctor_res =\n+                        Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive), def_id);\n+                    let mut vis = vis;\n+                    if vis.is_public() {\n+                        // For non-exhaustive variants lower the constructor visibility to\n+                        // within the crate. We only need this for fictive constructors,\n+                        // for other constructors correct visibilities\n+                        // were already encoded in metadata.\n+                        let mut attrs = self.get_item_attrs(def_id.index, sess);\n+                        if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n+                            vis = ty::Visibility::Restricted(self.local_def_id(CRATE_DEF_INDEX));\n                         }\n-                        callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                     }\n-                    _ => {}\n+                    callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                 }\n             }\n         }"}, {"sha": "049514ec7b240ab2fb0d6d83cb4b64ee94167a85", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 51, "deletions": 65, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -787,9 +787,8 @@ fn should_encode_attr(\n     } else if attr.doc_str().is_some() {\n         // We keep all public doc comments because they might be \"imported\" into downstream crates\n         // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n-        *is_def_id_public.get_or_insert_with(|| {\n-            tcx.privacy_access_levels(()).get_effective_vis(def_id).is_some()\n-        })\n+        *is_def_id_public\n+            .get_or_insert_with(|| tcx.effective_visibilities(()).effective_vis(def_id).is_some())\n     } else if attr.has_name(sym::doc) {\n         // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n         // remove it. It won't be inlinable in downstream crates.\n@@ -1094,43 +1093,6 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n     }\n }\n \n-fn should_encode_constness(def_kind: DefKind) -> bool {\n-    match def_kind {\n-        DefKind::Struct\n-        | DefKind::Union\n-        | DefKind::Enum\n-        | DefKind::Trait\n-        | DefKind::AssocTy\n-        | DefKind::Fn\n-        | DefKind::Const\n-        | DefKind::Static(..)\n-        | DefKind::Ctor(..)\n-        | DefKind::AssocFn\n-        | DefKind::AssocConst\n-        | DefKind::AnonConst\n-        | DefKind::InlineConst\n-        | DefKind::OpaqueTy\n-        | DefKind::ImplTraitPlaceholder\n-        | DefKind::Impl\n-        | DefKind::Closure\n-        | DefKind::Generator\n-        | DefKind::TyAlias => true,\n-        DefKind::Variant\n-        | DefKind::TraitAlias\n-        | DefKind::ForeignTy\n-        | DefKind::Field\n-        | DefKind::TyParam\n-        | DefKind::Mod\n-        | DefKind::ForeignMod\n-        | DefKind::ConstParam\n-        | DefKind::Macro(..)\n-        | DefKind::Use\n-        | DefKind::LifetimeParam\n-        | DefKind::GlobalAsm\n-        | DefKind::ExternCrate => false,\n-    }\n-}\n-\n fn should_encode_trait_impl_trait_tys<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     if tcx.def_kind(def_id) != DefKind::AssocFn {\n         return false;\n@@ -1239,9 +1201,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n-            if should_encode_constness(def_kind) {\n-                self.tables.constness.set(def_id.index, tcx.constness(def_id));\n-            }\n         }\n         let inherent_impls = tcx.crate_inherent_impls(());\n         for (def_id, implementations) in inherent_impls.inherent_impls.iter() {\n@@ -1269,6 +1228,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.variant_data[def_id] <- data);\n+        self.tables.constness.set(def_id.index, hir::Constness::Const);\n         record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n@@ -1296,6 +1256,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.variant_data[def_id] <- data);\n+        self.tables.constness.set(def_id.index, hir::Constness::Const);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1329,14 +1290,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         // from name resolution point of view.\n                         hir::ItemKind::ForeignMod { items, .. } => {\n                             for foreign_item in items {\n-                                yield foreign_item.id.def_id.def_id.local_def_index;\n+                                yield foreign_item.id.owner_id.def_id.local_def_index;\n                             }\n                         }\n                         // Only encode named non-reexport children, reexports are encoded\n                         // separately and unnamed items are not used by name resolution.\n                         hir::ItemKind::ExternCrate(..) => continue,\n-                        _ if tcx.def_key(item_id.def_id.to_def_id()).get_opt_name().is_some() => {\n-                            yield item_id.def_id.def_id.local_def_index;\n+                        hir::ItemKind::Struct(ref vdata, _) => {\n+                            yield item_id.owner_id.def_id.local_def_index;\n+                            // Encode constructors which take a separate slot in value namespace.\n+                            if let Some(ctor_hir_id) = vdata.ctor_hir_id() {\n+                                yield tcx.hir().local_def_id(ctor_hir_id).local_def_index;\n+                            }\n+                        }\n+                        _ if tcx.def_key(item_id.owner_id.to_def_id()).get_opt_name().is_some() => {\n+                            yield item_id.owner_id.def_id.local_def_index;\n                         }\n                         _ => continue,\n                     }\n@@ -1359,6 +1327,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n         record!(self.tables.variant_data[def_id] <- data);\n+        self.tables.constness.set(def_id.index, hir::Constness::Const);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1394,6 +1363,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 };\n                 self.tables.asyncness.set(def_id.index, m_sig.header.asyncness);\n+                self.tables.constness.set(def_id.index, hir::Constness::NotConst);\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1418,6 +1388,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n+                // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n+                let constness = if self.tcx.is_const_fn_raw(def_id) {\n+                    hir::Constness::Const\n+                } else {\n+                    hir::Constness::NotConst\n+                };\n+                self.tables.constness.set(def_id.index, constness);\n             }\n             ty::AssocKind::Const | ty::AssocKind::Type => {}\n         }\n@@ -1555,6 +1532,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n+                self.tables.constness.set(def_id.index, sig.header.constness);\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 if macro_def.macro_rules {\n@@ -1563,7 +1541,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.def_id.def_id, m);\n+                return self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(..) => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1575,6 +1553,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n+                self.tables.constness.set(def_id.index, hir::Constness::Const);\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n@@ -1603,8 +1582,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 });\n             }\n-            hir::ItemKind::Impl(hir::Impl { defaultness, .. }) => {\n+            hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n+                self.tables.constness.set(def_id.index, *constness);\n \n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 if let Some(trait_ref) = trait_ref {\n@@ -1646,12 +1626,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => record_array!(self.tables.children[def_id] <-\n-                self.tcx.adt_def(def_id).variants().iter().map(|v| {\n-                    assert!(v.def_id.is_local());\n-                    v.def_id.index\n-                })\n-            ),\n+            hir::ItemKind::Enum(..) => {\n+                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                    for variant in tcx.adt_def(def_id).variants() {\n+                        yield variant.def_id.index;\n+                        // Encode constructors which take a separate slot in value namespace.\n+                        if let Some(ctor_def_id) = variant.ctor_def_id {\n+                            yield ctor_def_id.index;\n+                        }\n+                    }\n+                ))\n+            }\n             hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                 record_array!(self.tables.children[def_id] <-\n                     self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n@@ -1688,7 +1673,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // normally in the visitor walk.\n         match item.kind {\n             hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n                 for (i, variant) in def.variants().iter_enumerated() {\n                     self.encode_enum_variant_info(def, i);\n \n@@ -1698,7 +1683,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n@@ -1707,13 +1692,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n                 {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                for &item_def_id in\n+                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n                 {\n                     self.encode_info_for_trait_item(item_def_id);\n                 }\n@@ -1954,8 +1940,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             FxHashMap::default();\n \n         for id in tcx.hir().items() {\n-            if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-                if let Some(trait_ref) = tcx.impl_trait_ref(id.def_id) {\n+            if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+                if let Some(trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n@@ -1965,7 +1951,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     fx_hash_map\n                         .entry(trait_ref.def_id)\n                         .or_default()\n-                        .push((id.def_id.def_id.local_def_index, simplified_self_ty));\n+                        .push((id.owner_id.def_id.local_def_index, simplified_self_ty));\n                 }\n             }\n         }\n@@ -2106,12 +2092,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n         intravisit::walk_item(self, item);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(item.def_id.to_def_id(), item),\n+            _ => self.encode_info_for_item(item.owner_id.to_def_id(), item),\n         }\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n-        self.encode_info_for_foreign_item(ni.def_id.to_def_id(), ni);\n+        self.encode_info_for_foreign_item(ni.owner_id.to_def_id(), ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         intravisit::walk_generics(self, generics);\n@@ -2330,8 +2316,8 @@ pub fn provide(providers: &mut Providers) {\n \n             let mut traits = Vec::new();\n             for id in tcx.hir().items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::Trait | DefKind::TraitAlias) {\n-                    traits.push(id.def_id.to_def_id())\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Trait | DefKind::TraitAlias) {\n+                    traits.push(id.owner_id.to_def_id())\n                 }\n             }\n "}, {"sha": "f8aae86fe3dc3691b6484db95f49a0cfffc47c2d", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -77,7 +77,7 @@ macro_rules! arena_types {\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, rustc_middle::ty::Ty<'tcx>>\n                 >,\n             [] all_traits: Vec<rustc_hir::def_id::DefId>,\n-            [] privacy_access_levels: rustc_middle::middle::privacy::AccessLevels,\n+            [] effective_visibilities: rustc_middle::middle::privacy::EffectiveVisibilities,\n             [] foreign_module: rustc_session::cstore::ForeignModule,\n             [] foreign_modules: Vec<rustc_session::cstore::ForeignModule>,\n             [] upvars_mentioned: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n@@ -96,7 +96,7 @@ macro_rules! arena_types {\n             // since we need to allocate this type on both the `rustc_hir` arena\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n             [decode] asm_template: rustc_ast::InlineAsmTemplatePiece,\n-            [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n+            [decode] used_trait_imports: rustc_data_structures::unord::UnordSet<rustc_hir::def_id::LocalDefId>,\n             [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::def_id::LocalDefId>,\n             [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n "}, {"sha": "83a4d16d7a92578a40b5d3579a6132284a36e492", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -354,19 +354,19 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn item(self, id: ItemId) -> &'hir Item<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_item()\n     }\n \n     pub fn trait_item(self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_trait_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_trait_item()\n     }\n \n     pub fn impl_item(self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_impl_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_impl_item()\n     }\n \n     pub fn foreign_item(self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_foreign_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_foreign_item()\n     }\n \n     pub fn body(self, id: BodyId) -> &'hir Body<'hir> {\n@@ -1377,14 +1377,14 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_item(&mut self, item: &'hir Item<'hir>) {\n         if associated_body(Node::Item(item)).is_some() {\n-            self.body_owners.push(item.def_id.def_id);\n+            self.body_owners.push(item.owner_id.def_id);\n         }\n \n         self.items.push(item.item_id());\n \n         // Items that are modules are handled here instead of in visit_mod.\n         if let ItemKind::Mod(module) = &item.kind {\n-            self.submodules.push(item.def_id);\n+            self.submodules.push(item.owner_id);\n             // A module collector does not recurse inside nested modules.\n             if self.crate_collector {\n                 intravisit::walk_mod(self, module, item.hir_id());\n@@ -1413,7 +1413,7 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n         if associated_body(Node::TraitItem(item)).is_some() {\n-            self.body_owners.push(item.def_id.def_id);\n+            self.body_owners.push(item.owner_id.def_id);\n         }\n \n         self.trait_items.push(item.trait_item_id());\n@@ -1422,7 +1422,7 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n         if associated_body(Node::ImplItem(item)).is_some() {\n-            self.body_owners.push(item.def_id.def_id);\n+            self.body_owners.push(item.owner_id.def_id);\n         }\n \n         self.impl_items.push(item.impl_item_id());"}, {"sha": "1c6264ad036544e396a3f68016e4d47221f6068f", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -67,10 +67,10 @@ impl ModuleItems {\n     pub fn definitions(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n         self.items\n             .iter()\n-            .map(|id| id.def_id.def_id)\n-            .chain(self.trait_items.iter().map(|id| id.def_id.def_id))\n-            .chain(self.impl_items.iter().map(|id| id.def_id.def_id))\n-            .chain(self.foreign_items.iter().map(|id| id.def_id.def_id))\n+            .map(|id| id.owner_id.def_id)\n+            .chain(self.trait_items.iter().map(|id| id.owner_id.def_id))\n+            .chain(self.impl_items.iter().map(|id| id.owner_id.def_id))\n+            .chain(self.foreign_items.iter().map(|id| id.owner_id.def_id))\n     }\n \n     pub fn par_items(&self, f: impl Fn(ItemId) + Send + Sync) {"}, {"sha": "d3cf519b633c71db5860a291a17347e06ac07104", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -302,8 +302,10 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryOutlivesConstraint<'tcx> =\n-    (ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>, ConstraintCategory);\n+pub type QueryOutlivesConstraint<'tcx> = (\n+    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>,\n+    ConstraintCategory<'tcx>,\n+);\n \n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {"}, {"sha": "9c68c7504754a664e63a6bc324cada2cce139f64", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 110, "deletions": 109, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -9,120 +9,101 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::{DefId, LocalDefId};\n use std::hash::Hash;\n \n-/// Represents the levels of accessibility an item can have.\n+/// Represents the levels of effective visibility an item can have.\n ///\n-/// The variants are sorted in ascending order of accessibility.\n+/// The variants are sorted in ascending order of directness.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n-pub enum AccessLevel {\n-    /// Superset of `AccessLevel::Reachable` used to mark impl Trait items.\n-    ReachableFromImplTrait,\n-    /// Exported items + items participating in various kinds of public interfaces,\n-    /// but not directly nameable. For example, if function `fn f() -> T {...}` is\n-    /// public, then type `T` is reachable. Its values can be obtained by other crates\n-    /// even if the type itself is not nameable.\n+pub enum Level {\n+    /// Superset of `Reachable` including items leaked through return position `impl Trait`.\n+    ReachableThroughImplTrait,\n+    /// Item is either reexported, or leaked through any kind of interface.\n+    /// For example, if function `fn f() -> T {...}` is directly public, then type `T` is publicly\n+    /// reachable and its values can be obtained by other crates even if the type itself is not\n+    /// nameable.\n     Reachable,\n-    /// Public items + items accessible to other crates with the help of `pub use` re-exports.\n-    Exported,\n-    /// Items accessible to other crates directly, without the help of re-exports.\n-    Public,\n+    /// Item is accessible either directly, or with help of `use` reexports.\n+    Reexported,\n+    /// Item is directly accessible, without help of reexports.\n+    Direct,\n }\n \n-impl AccessLevel {\n-    pub fn all_levels() -> [AccessLevel; 4] {\n-        [\n-            AccessLevel::Public,\n-            AccessLevel::Exported,\n-            AccessLevel::Reachable,\n-            AccessLevel::ReachableFromImplTrait,\n-        ]\n+impl Level {\n+    pub fn all_levels() -> [Level; 4] {\n+        [Level::Direct, Level::Reexported, Level::Reachable, Level::ReachableThroughImplTrait]\n     }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, HashStable)]\n pub struct EffectiveVisibility {\n-    public: Visibility,\n-    exported: Visibility,\n+    direct: Visibility,\n+    reexported: Visibility,\n     reachable: Visibility,\n-    reachable_from_impl_trait: Visibility,\n+    reachable_through_impl_trait: Visibility,\n }\n \n impl EffectiveVisibility {\n-    pub fn get(&self, tag: AccessLevel) -> &Visibility {\n-        match tag {\n-            AccessLevel::Public => &self.public,\n-            AccessLevel::Exported => &self.exported,\n-            AccessLevel::Reachable => &self.reachable,\n-            AccessLevel::ReachableFromImplTrait => &self.reachable_from_impl_trait,\n+    pub fn at_level(&self, level: Level) -> &Visibility {\n+        match level {\n+            Level::Direct => &self.direct,\n+            Level::Reexported => &self.reexported,\n+            Level::Reachable => &self.reachable,\n+            Level::ReachableThroughImplTrait => &self.reachable_through_impl_trait,\n         }\n     }\n \n-    fn get_mut(&mut self, tag: AccessLevel) -> &mut Visibility {\n-        match tag {\n-            AccessLevel::Public => &mut self.public,\n-            AccessLevel::Exported => &mut self.exported,\n-            AccessLevel::Reachable => &mut self.reachable,\n-            AccessLevel::ReachableFromImplTrait => &mut self.reachable_from_impl_trait,\n+    fn at_level_mut(&mut self, level: Level) -> &mut Visibility {\n+        match level {\n+            Level::Direct => &mut self.direct,\n+            Level::Reexported => &mut self.reexported,\n+            Level::Reachable => &mut self.reachable,\n+            Level::ReachableThroughImplTrait => &mut self.reachable_through_impl_trait,\n         }\n     }\n \n-    pub fn is_public_at_level(&self, tag: AccessLevel) -> bool {\n-        self.get(tag).is_public()\n+    pub fn is_public_at_level(&self, level: Level) -> bool {\n+        self.at_level(level).is_public()\n     }\n \n-    fn update(&mut self, vis: Visibility, tag: AccessLevel, tree: impl DefIdTree) -> bool {\n-        let mut changed = false;\n-        for level in AccessLevel::all_levels() {\n-            if level <= tag {\n-                let current_effective_vis = self.get_mut(level);\n-                if *current_effective_vis != vis && vis.is_at_least(*current_effective_vis, tree) {\n-                    changed = true;\n-                    *current_effective_vis = vis;\n-                }\n-            }\n-        }\n-        changed\n-    }\n-\n-    fn from_vis(vis: Visibility) -> EffectiveVisibility {\n+    pub fn from_vis(vis: Visibility) -> EffectiveVisibility {\n         EffectiveVisibility {\n-            public: vis,\n-            exported: vis,\n+            direct: vis,\n+            reexported: vis,\n             reachable: vis,\n-            reachable_from_impl_trait: vis,\n+            reachable_through_impl_trait: vis,\n         }\n     }\n }\n \n-/// Holds a map of accessibility levels for reachable HIR nodes.\n+/// Holds a map of effective visibilities for reachable HIR nodes.\n #[derive(Debug, Clone)]\n-pub struct AccessLevels<Id = LocalDefId> {\n+pub struct EffectiveVisibilities<Id = LocalDefId> {\n     map: FxHashMap<Id, EffectiveVisibility>,\n }\n \n-impl<Id: Hash + Eq + Copy> AccessLevels<Id> {\n-    pub fn is_public_at_level(&self, id: Id, tag: AccessLevel) -> bool {\n-        self.get_effective_vis(id)\n-            .map_or(false, |effective_vis| effective_vis.is_public_at_level(tag))\n+impl<Id: Hash + Eq + Copy> EffectiveVisibilities<Id> {\n+    pub fn is_public_at_level(&self, id: Id, level: Level) -> bool {\n+        self.effective_vis(id)\n+            .map_or(false, |effective_vis| effective_vis.is_public_at_level(level))\n     }\n \n-    /// See `AccessLevel::Reachable`.\n+    /// See `Level::Reachable`.\n     pub fn is_reachable(&self, id: Id) -> bool {\n-        self.is_public_at_level(id, AccessLevel::Reachable)\n+        self.is_public_at_level(id, Level::Reachable)\n     }\n \n-    /// See `AccessLevel::Exported`.\n+    /// See `Level::Reexported`.\n     pub fn is_exported(&self, id: Id) -> bool {\n-        self.is_public_at_level(id, AccessLevel::Exported)\n+        self.is_public_at_level(id, Level::Reexported)\n     }\n \n-    /// See `AccessLevel::Public`.\n-    pub fn is_public(&self, id: Id) -> bool {\n-        self.is_public_at_level(id, AccessLevel::Public)\n+    /// See `Level::Direct`.\n+    pub fn is_directly_public(&self, id: Id) -> bool {\n+        self.is_public_at_level(id, Level::Direct)\n     }\n \n-    pub fn get_access_level(&self, id: Id) -> Option<AccessLevel> {\n-        self.get_effective_vis(id).and_then(|effective_vis| {\n-            for level in AccessLevel::all_levels() {\n+    pub fn public_at_level(&self, id: Id) -> Option<Level> {\n+        self.effective_vis(id).and_then(|effective_vis| {\n+            for level in Level::all_levels() {\n                 if effective_vis.is_public_at_level(level) {\n                     return Some(level);\n                 }\n@@ -131,38 +112,41 @@ impl<Id: Hash + Eq + Copy> AccessLevels<Id> {\n         })\n     }\n \n-    pub fn get_effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n         self.map.get(&id)\n     }\n \n     pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n         self.map.iter()\n     }\n \n-    pub fn map_id<OutId: Hash + Eq + Copy>(&self, f: impl Fn(Id) -> OutId) -> AccessLevels<OutId> {\n-        AccessLevels { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n+    pub fn map_id<OutId: Hash + Eq + Copy>(\n+        &self,\n+        f: impl Fn(Id) -> OutId,\n+    ) -> EffectiveVisibilities<OutId> {\n+        EffectiveVisibilities { map: self.map.iter().map(|(k, v)| (f(*k), *v)).collect() }\n     }\n \n-    pub fn set_access_level(\n+    pub fn set_public_at_level(\n         &mut self,\n         id: Id,\n         default_vis: impl FnOnce() -> Visibility,\n-        tag: AccessLevel,\n+        level: Level,\n     ) {\n         let mut effective_vis = self\n-            .get_effective_vis(id)\n+            .effective_vis(id)\n             .copied()\n             .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n-        for level in AccessLevel::all_levels() {\n-            if level <= tag {\n-                *effective_vis.get_mut(level) = Visibility::Public;\n+        for l in Level::all_levels() {\n+            if l <= level {\n+                *effective_vis.at_level_mut(l) = Visibility::Public;\n             }\n         }\n         self.map.insert(id, effective_vis);\n     }\n }\n \n-impl<Id: Hash + Eq + Copy + Into<DefId>> AccessLevels<Id> {\n+impl<Id: Hash + Eq + Copy + Into<DefId>> EffectiveVisibilities<Id> {\n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n@@ -171,47 +155,64 @@ impl<Id: Hash + Eq + Copy + Into<DefId>> AccessLevels<Id> {\n         nominal_vis: Visibility,\n         default_vis: impl FnOnce() -> Visibility,\n         parent_id: Id,\n-        tag: AccessLevel,\n+        level: Level,\n         tree: impl DefIdTree,\n-    ) -> Result<bool, ()> {\n+    ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self\n-            .get_effective_vis(id)\n-            .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n-        if let Some(inherited_effective_vis) = self.get_effective_vis(parent_id) {\n-            for level in AccessLevel::all_levels() {\n-                if tag >= level {\n-                    let inherited_effective_vis_at_level = *inherited_effective_vis.get(level);\n-                    let calculated_effective_vis =\n-                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n-                            inherited_effective_vis_at_level\n-                        } else {\n-                            nominal_vis\n-                        };\n-                    changed |= current_effective_vis.update(calculated_effective_vis, level, tree);\n-                }\n+        let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n+            if id.into().is_crate_root() {\n+                EffectiveVisibility::from_vis(Visibility::Public)\n+            } else {\n+                EffectiveVisibility::from_vis(default_vis())\n             }\n-        } else {\n-            if !id.into().is_crate_root() {\n-                return Err(());\n+        });\n+        if let Some(inherited_effective_vis) = self.effective_vis(parent_id) {\n+            let mut inherited_effective_vis_at_prev_level =\n+                *inherited_effective_vis.at_level(level);\n+            let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n+            for l in Level::all_levels() {\n+                if level >= l {\n+                    let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n+                    let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n+                    // effective visibility for id shouldn't be recalculated if\n+                    // inherited from parent_id effective visibility isn't changed at next level\n+                    if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n+                        && level != l)\n+                    {\n+                        calculated_effective_vis =\n+                            if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n+                                inherited_effective_vis_at_level\n+                            } else {\n+                                nominal_vis\n+                            };\n+                    }\n+                    // effective visibility can't be decreased at next update call for the\n+                    // same id\n+                    if *current_effective_vis_at_level != calculated_effective_vis\n+                        && calculated_effective_vis\n+                            .is_at_least(*current_effective_vis_at_level, tree)\n+                    {\n+                        changed = true;\n+                        *current_effective_vis_at_level = calculated_effective_vis;\n+                    }\n+                    inherited_effective_vis_at_prev_level = inherited_effective_vis_at_level;\n+                }\n             }\n-            changed |= current_effective_vis.update(Visibility::Public, AccessLevel::Public, tree);\n         }\n         self.map.insert(id, current_effective_vis);\n-        Ok(changed)\n+        changed\n     }\n }\n \n-impl<Id> Default for AccessLevels<Id> {\n+impl<Id> Default for EffectiveVisibilities<Id> {\n     fn default() -> Self {\n-        AccessLevels { map: Default::default() }\n+        EffectiveVisibilities { map: Default::default() }\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for AccessLevels {\n+impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let AccessLevels { ref map } = *self;\n+        let EffectiveVisibilities { ref map } = *self;\n         map.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "79db35a764a805464696c4d97f0c6c1acecfcd4e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -116,11 +116,6 @@ pub trait MirPass<'tcx> {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>);\n \n-    /// If this pass causes the MIR to enter a new phase, return that phase.\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        None\n-    }\n-\n     fn is_mir_dump_enabled(&self) -> bool {\n         true\n     }\n@@ -145,6 +140,35 @@ impl MirPhase {\n     }\n }\n \n+impl Display for MirPhase {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        match self {\n+            MirPhase::Built => write!(f, \"built\"),\n+            MirPhase::Analysis(p) => write!(f, \"analysis-{}\", p),\n+            MirPhase::Runtime(p) => write!(f, \"runtime-{}\", p),\n+        }\n+    }\n+}\n+\n+impl Display for AnalysisPhase {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AnalysisPhase::Initial => write!(f, \"initial\"),\n+            AnalysisPhase::PostCleanup => write!(f, \"post_cleanup\"),\n+        }\n+    }\n+}\n+\n+impl Display for RuntimePhase {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        match self {\n+            RuntimePhase::Initial => write!(f, \"initial\"),\n+            RuntimePhase::PostCleanup => write!(f, \"post_cleanup\"),\n+            RuntimePhase::Optimized => write!(f, \"optimized\"),\n+        }\n+    }\n+}\n+\n /// Where a specific `mir::Body` comes from.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable, TypeVisitable)]\n@@ -207,6 +231,9 @@ pub struct Body<'tcx> {\n     /// us to see the difference and forego optimization on the inlined promoted items.\n     pub phase: MirPhase,\n \n+    /// How many passses we have executed since starting the current phase. Used for debug output.\n+    pub pass_count: usize,\n+\n     pub source: MirSource<'tcx>,\n \n     /// A list of source scopes; these are referenced by statements\n@@ -292,6 +319,7 @@ impl<'tcx> Body<'tcx> {\n \n         let mut body = Body {\n             phase: MirPhase::Built,\n+            pass_count: 1,\n             source,\n             basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes,\n@@ -325,6 +353,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n         let mut body = Body {\n             phase: MirPhase::Built,\n+            pass_count: 1,\n             source: MirSource::item(CRATE_DEF_ID.to_def_id()),\n             basic_blocks: BasicBlocks::new(basic_blocks),\n             source_scopes: IndexVec::new(),\n@@ -2875,7 +2904,7 @@ fn pretty_print_const_value<'tcx>(\n /// `Location` represents the position of the start of the statement; or, if\n /// `statement_index` equals the number of statements, then the start of the\n /// terminator.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable)]\n pub struct Location {\n     /// The block that the location is within.\n     pub block: BasicBlock,"}, {"sha": "15a24aa4ace512f1b453902ddca2e34d2033abab", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => tcx.symbol_name(Instance::mono(tcx, def_id)),\n             MonoItem::GlobalAsm(item_id) => {\n-                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", item_id.def_id))\n+                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", item_id.owner_id))\n             }\n         }\n     }\n@@ -182,7 +182,7 @@ impl<'tcx> MonoItem<'tcx> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => def.def_id().as_local(),\n             MonoItem::Static(def_id) => def_id.as_local(),\n-            MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.def_id),\n+            MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.def_id),\n         }\n         .map(|def_id| tcx.def_span(def_id))\n     }\n@@ -373,7 +373,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         }\n                     }\n                     MonoItem::Static(def_id) => def_id.as_local().map(Idx::index),\n-                    MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.def_id.index()),\n+                    MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.def_id.index()),\n                 },\n                 item.symbol_name(tcx),\n             )"}, {"sha": "efd7357afc46c98f1b886a42e3b0b9217137ccce", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -15,7 +15,7 @@ use smallvec::SmallVec;\n use std::cell::Cell;\n use std::fmt::{self, Debug};\n \n-use super::{Field, Location, SourceInfo};\n+use super::{Field, SourceInfo};\n \n #[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable, Debug)]\n pub enum UnsafetyViolationKind {\n@@ -314,21 +314,21 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n     pub blame_span: Span,\n \n     // ... due to this reason.\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n }\n \n // Make sure this enum doesn't unintentionally grow\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(ConstraintCategory, 16);\n+rustc_data_structures::static_assert_size!(ConstraintCategory<'_>, 16);\n \n /// Outlives-constraints can be categorized to determine whether and why they\n /// are interesting (for error reporting). Order of variants indicates sort\n /// order of the category, thereby influencing diagnostic output.\n ///\n /// See also `rustc_const_eval::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n-pub enum ConstraintCategory {\n+#[derive(TyEncodable, TyDecodable, HashStable, Lift, TypeVisitable, TypeFoldable)]\n+pub enum ConstraintCategory<'tcx> {\n     Return(ReturnConstraint),\n     Yield,\n     UseAsConst,\n@@ -342,7 +342,7 @@ pub enum ConstraintCategory {\n     ClosureBounds,\n \n     /// Contains the function type if available.\n-    CallArgument(Location),\n+    CallArgument(Option<Ty<'tcx>>),\n     CopyBound,\n     SizedBound,\n     Assignment,\n@@ -368,10 +368,6 @@ pub enum ConstraintCategory {\n     Internal,\n }\n \n-TrivialTypeTraversalAndLiftImpls! {\n-    ConstraintCategory,\n-}\n-\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n #[derive(TyEncodable, TyDecodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum ReturnConstraint {"}, {"sha": "3d720f09b4ff7ca8d6285d857e65c99491586cb6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -23,7 +23,7 @@ rustc_queries! {\n         desc { \"triggering a delay span bug\" }\n     }\n \n-    query resolutions(_: ()) -> &'tcx ty::ResolverOutputs {\n+    query resolutions(_: ()) -> &'tcx ty::ResolverGlobalCtxt {\n         eval_always\n         no_hash\n         desc { \"getting the resolver outputs\" }\n@@ -912,7 +912,7 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n \n-    query used_trait_imports(key: LocalDefId) -> &'tcx FxHashSet<LocalDefId> {\n+    query used_trait_imports(key: LocalDefId) -> &'tcx UnordSet<LocalDefId> {\n         desc { |tcx| \"finding used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n@@ -1065,10 +1065,10 @@ rustc_queries! {\n         cache_on_disk_if { key.is_local() }\n     }\n \n-    /// Performs part of the privacy check and computes \"access levels\".\n-    query privacy_access_levels(_: ()) -> &'tcx AccessLevels {\n+    /// Performs part of the privacy check and computes effective visibilities.\n+    query effective_visibilities(_: ()) -> &'tcx EffectiveVisibilities {\n         eval_always\n-        desc { \"checking privacy access levels\" }\n+        desc { \"checking effective visibilities\" }\n     }\n     query check_private_in_public(_: ()) -> () {\n         eval_always"}, {"sha": "e73d44bbb36c38e7b21f41a50bfd3916befe55f6", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -185,7 +185,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         self\n     }\n \n-    pub fn to_constraint_category(&self) -> ConstraintCategory {\n+    pub fn to_constraint_category(&self) -> ConstraintCategory<'tcx> {\n         match self.code() {\n             MatchImpl(cause, _) => cause.to_constraint_category(),\n             AscribeUserTypeProvePredicate(predicate_span) => {"}, {"sha": "3d7e2a0839abc384f8fdf9c01140b4aed3be0f92", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -34,6 +34,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, RwLock, WorkerLocal};\n+use rustc_data_structures::unord::UnordSet;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n@@ -79,7 +80,7 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-use super::{ImplPolarity, RvalueScopes};\n+use super::{ImplPolarity, ResolverOutputs, RvalueScopes};\n \n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n@@ -531,7 +532,7 @@ pub struct TypeckResults<'tcx> {\n     /// This is used for warning unused imports. During type\n     /// checking, this `Lrc` should not be cloned: it must have a ref-count\n     /// of 1 so that we can insert things into the set mutably.\n-    pub used_trait_imports: Lrc<FxHashSet<LocalDefId>>,\n+    pub used_trait_imports: Lrc<UnordSet<LocalDefId>>,\n \n     /// If any errors occurred while type-checking this body,\n     /// this field will be set to `Some(ErrorGuaranteed)`.\n@@ -1067,10 +1068,9 @@ pub struct GlobalCtxt<'tcx> {\n     pub consts: CommonConsts<'tcx>,\n \n     definitions: RwLock<Definitions>,\n-    cstore: Box<CrateStoreDyn>,\n \n     /// Output of the resolver.\n-    pub(crate) untracked_resolutions: ty::ResolverOutputs,\n+    pub(crate) untracked_resolutions: ty::ResolverGlobalCtxt,\n     untracked_resolver_for_lowering: Steal<ty::ResolverAstLowering>,\n     /// The entire crate as AST. This field serves as the input for the hir_crate query,\n     /// which lowers it from AST to HIR. It must not be read or used by anything else.\n@@ -1233,10 +1233,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n-        definitions: Definitions,\n-        cstore: Box<CrateStoreDyn>,\n-        untracked_resolutions: ty::ResolverOutputs,\n-        untracked_resolver_for_lowering: ty::ResolverAstLowering,\n+        resolver_outputs: ResolverOutputs,\n         krate: Lrc<ast::Crate>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n@@ -1245,6 +1242,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         crate_name: &str,\n         output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n+        let ResolverOutputs {\n+            definitions,\n+            global_ctxt: untracked_resolutions,\n+            ast_lowering: untracked_resolver_for_lowering,\n+        } = resolver_outputs;\n         let data_layout = TargetDataLayout::parse(&s.target).unwrap_or_else(|err| {\n             s.emit_fatal(err);\n         });\n@@ -1253,7 +1255,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             &interners,\n             s,\n             &definitions,\n-            &*cstore,\n+            &*untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n             &untracked_resolutions.source_span,\n         );\n@@ -1268,7 +1270,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             interners,\n             dep_graph,\n             definitions: RwLock::new(definitions),\n-            cstore,\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n@@ -1369,7 +1370,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_key(id)\n         } else {\n-            self.cstore.def_key(id)\n+            self.untracked_resolutions.cstore.def_key(id)\n         }\n     }\n \n@@ -1383,7 +1384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_path(id)\n         } else {\n-            self.cstore.def_path(id)\n+            self.untracked_resolutions.cstore.def_path(id)\n         }\n     }\n \n@@ -1393,7 +1394,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.definitions_untracked().def_path_hash(def_id)\n         } else {\n-            self.cstore.def_path_hash(def_id)\n+            self.untracked_resolutions.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1402,7 +1403,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.cstore.stable_crate_id(crate_num)\n+            self.untracked_resolutions.cstore.stable_crate_id(crate_num)\n         }\n     }\n \n@@ -1413,7 +1414,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -1432,8 +1433,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cnum = self.cstore.stable_crate_id_to_crate_num(stable_crate_id);\n-            self.cstore.def_path_hash_to_def_id(cnum, hash)\n+            let cstore = &*self.untracked_resolutions.cstore;\n+            let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n+            cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n     }\n \n@@ -1445,7 +1447,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &self.cstore;\n+            let cstore = &*self.untracked_resolutions.cstore;\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1520,7 +1522,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n-        &*self.cstore\n+        &*self.untracked_resolutions.cstore\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n@@ -1546,7 +1548,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let hcx = StableHashingContext::new(\n             self.sess,\n             &*definitions,\n-            &*self.cstore,\n+            &*self.untracked_resolutions.cstore,\n             &self.untracked_resolutions.source_span,\n         );\n         f(hcx)\n@@ -2364,7 +2366,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             st,\n             self.sess,\n             &self.definitions.read(),\n-            &*self.cstore,\n+            &*self.untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n             &self.untracked_resolutions.source_span,\n         )"}, {"sha": "4e6cdb786025e0bcd8f78e2d213e7b6758487476", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -872,9 +872,9 @@ fn foo(&self) -> Self::T { String::new() }\n                             // FIXME: account for returning some type in a trait fn impl that has\n                             // an assoc type as a return type (#72076).\n                             if let hir::Defaultness::Default { has_value: true } =\n-                                self.impl_defaultness(item.id.def_id)\n+                                self.impl_defaultness(item.id.owner_id)\n                             {\n-                                if self.type_of(item.id.def_id) == found {\n+                                if self.type_of(item.id.owner_id) == found {\n                                     diag.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n@@ -894,7 +894,7 @@ fn foo(&self) -> Self::T { String::new() }\n             })) => {\n                 for item in &items[..] {\n                     if let hir::AssocItemKind::Type = item.kind {\n-                        if self.type_of(item.id.def_id) == found {\n+                        if self.type_of(item.id.owner_id) == found {\n                             diag.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }"}, {"sha": "3312f44c67b2a884319601a67df751396701b1f5", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -830,7 +830,7 @@ where\n                 } else {\n                     match mt {\n                         hir::Mutability::Not => {\n-                            if ty.is_freeze(tcx.at(DUMMY_SP), cx.param_env()) {\n+                            if ty.is_freeze(tcx, cx.param_env()) {\n                                 PointerKind::Frozen\n                             } else {\n                                 PointerKind::SharedMutable\n@@ -841,7 +841,7 @@ where\n                             // noalias, as another pointer to the structure can be obtained, that\n                             // is not based-on the original reference. We consider all !Unpin\n                             // types to be potentially self-referential here.\n-                            if ty.is_unpin(tcx.at(DUMMY_SP), cx.param_env()) {\n+                            if ty.is_unpin(tcx, cx.param_env()) {\n                                 PointerKind::UniqueBorrowed\n                             } else {\n                                 PointerKind::UniqueBorrowedPinned"}, {"sha": "a42d05706137c898077f6307d86697ee4db8ea4e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -17,7 +17,7 @@ pub use self::IntVarValue::*;\n pub use self::Variance::*;\n use crate::error::{OpaqueHiddenTypeMismatch, TypeMismatchReason};\n use crate::metadata::ModChild;\n-use crate::middle::privacy::AccessLevels;\n+use crate::middle::privacy::EffectiveVisibilities;\n use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n use crate::ty;\n@@ -38,11 +38,13 @@ use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, Span};\n@@ -142,16 +144,23 @@ mod sty;\n \n pub type RegisteredTools = FxHashSet<Ident>;\n \n-#[derive(Debug)]\n pub struct ResolverOutputs {\n+    pub definitions: Definitions,\n+    pub global_ctxt: ResolverGlobalCtxt,\n+    pub ast_lowering: ResolverAstLowering,\n+}\n+\n+#[derive(Debug)]\n+pub struct ResolverGlobalCtxt {\n+    pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n     pub has_pub_restricted: bool,\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     pub expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n     /// Reference span for definitions.\n     pub source_span: IndexVec<LocalDefId, Span>,\n-    pub access_levels: AccessLevels,\n+    pub effective_visibilities: EffectiveVisibilities,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n@@ -2595,7 +2604,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             && if self.features().collapse_debuginfo {\n                 span.in_macro_expansion_with_collapse_debuginfo()\n             } else {\n-                span.from_expansion()\n+                // Inlined spans should not be collapsed as that leads to all of the\n+                // inlined code being attributed to the inline callsite.\n+                span.from_expansion() && !span.is_inlined()\n             }\n     }\n "}, {"sha": "ef9aa236bacfce7435126c5fd8933d2917ba9e6a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -63,6 +63,7 @@ thread_local! {\n     static NO_TRIMMED_PATH: Cell<bool> = const { Cell::new(false) };\n     static NO_QUERIES: Cell<bool> = const { Cell::new(false) };\n     static NO_VISIBLE_PATH: Cell<bool> = const { Cell::new(false) };\n+    static NO_VERBOSE_CONSTANTS: Cell<bool> = const { Cell::new(false) };\n }\n \n macro_rules! define_helper {\n@@ -117,6 +118,9 @@ define_helper!(\n     /// Prevent selection of visible paths. `Display` impl of DefId will prefer\n     /// visible (public) reexports of types as paths.\n     fn with_no_visible_paths(NoVisibleGuard, NO_VISIBLE_PATH);\n+    /// Prevent verbose printing of constants. Verbose printing of constants is\n+    /// never desirable in some contexts like `std::any::type_name`.\n+    fn with_no_verbose_constants(NoVerboseConstantsGuard, NO_VERBOSE_CONSTANTS);\n );\n \n /// The \"region highlights\" are used to control region printing during\n@@ -759,7 +763,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Array(ty, sz) => {\n                 p!(\"[\", print(ty), \"; \");\n-                if self.tcx().sess.verbose() {\n+                if !NO_VERBOSE_CONSTANTS.with(|flag| flag.get()) && self.tcx().sess.verbose() {\n                     p!(write(\"{:?}\", sz));\n                 } else if let ty::ConstKind::Unevaluated(..) = sz.kind() {\n                     // Do not try to evaluate unevaluated constants. If we are const evaluating an\n@@ -1181,7 +1185,7 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        if self.tcx().sess.verbose() {\n+        if !NO_VERBOSE_CONSTANTS.with(|flag| flag.get()) && self.tcx().sess.verbose() {\n             p!(write(\"Const({:?}: {:?})\", ct.kind(), ct.ty()));\n             return Ok(self);\n         }\n@@ -1416,7 +1420,7 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        if self.tcx().sess.verbose() {\n+        if !NO_VERBOSE_CONSTANTS.with(|flag| flag.get()) && self.tcx().sess.verbose() {\n             p!(write(\"ValTree({:?}: \", valtree), print(ty), \")\");\n             return Ok(self);\n         }\n@@ -2736,7 +2740,7 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n     for id in hir.items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::Use) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Use) {\n             continue;\n         }\n \n@@ -2745,7 +2749,7 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n             continue;\n         }\n \n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);\n         collect_fn(&item.ident, ns, def_id);\n     }"}, {"sha": "ec90590ada2ec15430203b068b2248ca0352b3db", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -5,7 +5,7 @@ use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n-use crate::middle::privacy::AccessLevels;\n+use crate::middle::privacy::EffectiveVisibilities;\n use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n@@ -40,6 +40,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;"}, {"sha": "b25b4bd4fe363ad145507a327d05fc500cc72a05", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -574,8 +574,8 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n /// it.\n pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     relation: &mut R,\n-    a: ty::Const<'tcx>,\n-    b: ty::Const<'tcx>,\n+    mut a: ty::Const<'tcx>,\n+    mut b: ty::Const<'tcx>,\n ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n     debug!(\"{}.super_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n@@ -596,6 +596,17 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         );\n     }\n \n+    // HACK(const_generics): We still need to eagerly evaluate consts when\n+    // relating them because during `normalize_param_env_or_error`,\n+    // we may relate an evaluated constant in a obligation against\n+    // an unnormalized (i.e. unevaluated) const in the param-env.\n+    // FIXME(generic_const_exprs): Once we always lazily unify unevaluated constants\n+    // these `eval` calls can be removed.\n+    if !relation.tcx().features().generic_const_exprs {\n+        a = a.eval(tcx, relation.param_env());\n+        b = b.eval(tcx, relation.param_env());\n+    }\n+\n     // Currently, the values that can be unified are primitive types,\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n     // to structural-match types."}, {"sha": "f72e236eda1332cd4013315af28a120909cdfbfb", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2,7 +2,6 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::ty::layout::IntegerExt;\n-use crate::ty::query::TyCtxtAt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n     TypeVisitable,\n@@ -821,12 +820,8 @@ impl<'tcx> Ty<'tcx> {\n     /// does copies even when the type actually doesn't satisfy the\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n-    pub fn is_copy_modulo_regions(\n-        self,\n-        tcx_at: TyCtxtAt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        self.is_trivially_pure_clone_copy() || tcx_at.is_copy_raw(param_env.and(self))\n+    pub fn is_copy_modulo_regions(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_pure_clone_copy() || tcx.is_copy_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` have a size known at\n@@ -835,8 +830,8 @@ impl<'tcx> Ty<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_sized(tcx_at.tcx) || tcx_at.is_sized_raw(param_env.and(self))\n+    pub fn is_sized(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_sized(tcx) || tcx.is_sized_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` implement the `Freeze`\n@@ -846,8 +841,8 @@ impl<'tcx> Ty<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    pub fn is_freeze(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_freeze() || tcx_at.is_freeze_raw(param_env.and(self))\n+    pub fn is_freeze(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_freeze() || tcx.is_freeze_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Freeze`.\n@@ -886,8 +881,8 @@ impl<'tcx> Ty<'tcx> {\n     }\n \n     /// Checks whether values of this type `T` implement the `Unpin` trait.\n-    pub fn is_unpin(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_unpin() || tcx_at.is_unpin_raw(param_env.and(self))\n+    pub fn is_unpin(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_unpin() || tcx.is_unpin_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Unpin`."}, {"sha": "c8610af7038d7f2c2b089cfbf1658055bd2d8115", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -153,12 +153,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         if tcx.features().unsized_fn_params {\n             let ty = expr.ty;\n-            let span = expr.span;\n             let param_env = this.param_env;\n \n-            if !ty.is_sized(tcx.at(span), param_env) {\n+            if !ty.is_sized(tcx, param_env) {\n                 // !sized means !copy, so this is an unsized move\n-                assert!(!ty.is_copy_modulo_regions(tcx.at(span), param_env));\n+                assert!(!ty.is_copy_modulo_regions(tcx, param_env));\n \n                 // As described above, detect the case where we are passing a value of unsized\n                 // type, and that value is coming from the deref of a box."}, {"sha": "fb1ea9ed300ad4f8c87a02d6c32718c614ceca21", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                     };\n                     match borrow_kind {\n                         BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique => {\n-                            if !ty.is_freeze(self.tcx.at(pat.span), self.param_env) {\n+                            if !ty.is_freeze(self.tcx, self.param_env) {\n                                 self.requires_unsafe(pat.span, BorrowOfLayoutConstrainedField);\n                             }\n                         }\n@@ -457,9 +457,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 if visitor.found {\n                     match borrow_kind {\n                         BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique\n-                            if !self.thir[arg]\n-                                .ty\n-                                .is_freeze(self.tcx.at(self.thir[arg].span), self.param_env) =>\n+                            if !self.thir[arg].ty.is_freeze(self.tcx, self.param_env) =>\n                         {\n                             self.requires_unsafe(expr.span, BorrowOfLayoutConstrainedField)\n                         }"}, {"sha": "a9e5e438cf5f5c808e4e5fa6395d17df17fbb9ac", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -507,7 +507,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                                 _ => \"aren't\",\n                             },\n                         ),\n-                        \" else { todo!() }\".to_string(),\n+                        \" else { todo!() }\",\n                         Applicability::HasPlaceholders,\n                     );\n                 }\n@@ -1004,8 +1004,8 @@ fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n }\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n-fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId, span: Span) -> bool {\n-    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n+fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId) -> bool {\n+    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx, cx.param_env)\n }\n \n /// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n@@ -1031,7 +1031,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n \n     // Get the binding move, extract the mutability if by-ref.\n     let mut_outer = match typeck_results.extract_binding_mode(sess, pat.hir_id, pat.span) {\n-        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id, pat.span) => {\n+        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id) => {\n             // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n             let mut conflicts_ref = Vec::new();\n             sub.each_binding(|_, hir_id, span, _| {\n@@ -1070,7 +1070,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                 (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push((span, name)), // 2x `ref mut`.\n                 _ => conflicts_mut_ref.push((span, name)), // `ref` + `ref mut` in either direction.\n             },\n-            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id, span) => {\n+            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id) => {\n                 conflicts_move.push((span, name)) // `ref mut?` + by-move conflict.\n             }\n             Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine."}, {"sha": "ad12e011621173c7ebd6866e494dec164d136126", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -506,7 +506,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // convert the dereferenced constant to a pattern that is the sub-pattern of the\n                 // deref pattern.\n                 _ => {\n-                    if !pointee_ty.is_sized(tcx.at(span), param_env) {\n+                    if !pointee_ty.is_sized(tcx, param_env) {\n                         // `tcx.deref_mir_constant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n                         let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n@@ -534,7 +534,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n                 PatKind::Constant { value: cv }\n             }\n-            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx.at(span), param_env) => {\n+            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx, param_env) => {\n                 PatKind::Constant { value: cv }\n             }\n             // FIXME: these can have very surprising behaviour where optimization levels or other"}, {"sha": "2526522a25c8c882aa536d9864245aeb6c555c15", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -483,7 +483,12 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         // Use `Reveal::All` here because patterns are always monomorphic even if their function\n         // isn't.\n         let param_env_reveal_all = self.param_env.with_reveal_all_normalized(self.tcx);\n-        let substs = self.typeck_results.node_substs(id);\n+        // N.B. There is no guarantee that substs collected in typeck results are fully normalized,\n+        // so they need to be normalized in order to pass to `Instance::resolve`, which will ICE\n+        // if given unnormalized types.\n+        let substs = self\n+            .tcx\n+            .normalize_erasing_regions(param_env_reveal_all, self.typeck_results.node_substs(id));\n         let instance = match ty::Instance::resolve(self.tcx, param_env_reveal_all, def_id, substs) {\n             Ok(Some(i)) => i,\n             Ok(None) => {"}, {"sha": "f8f04214a2ca55a34255d458455c6ffa04b44479", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -312,7 +312,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n                             } else if !place\n                                 .ty(self.body, self.tcx)\n                                 .ty\n-                                .is_freeze(self.tcx.at(self.source_info.span), self.param_env)\n+                                .is_freeze(self.tcx, self.param_env)\n                             {\n                                 UnsafetyViolationDetails::BorrowOfLayoutConstrainedField\n                             } else {"}, {"sha": "4e4515888454b8a1038a583478ac845cbd868892", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -633,7 +633,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         if !rvalue\n             .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(self.ecx.tcx, self.param_env)\n+            .is_sized(*self.ecx.tcx, self.param_env)\n         {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here"}, {"sha": "479c4e577d4e3aad83e0098e3c18764cd654af67", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -500,7 +500,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         if !rvalue\n             .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(self.ecx.tcx, self.param_env)\n+            .is_sized(*self.ecx.tcx, self.param_env)\n         {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here"}, {"sha": "28b1c5a48099bc9d8c14d9b1456b263ea568f531", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -11,7 +11,6 @@ use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n use rustc_middle::ty::{self, DeducedParamAttrs, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n-use rustc_span::DUMMY_SP;\n \n /// A visitor that determines which arguments have been mutated. We can't use the mutability field\n /// on LocalDecl for this because it has no meaning post-optimization.\n@@ -232,7 +231,7 @@ pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [Ded\n         body.local_decls.iter().skip(1).take(body.arg_count).enumerate().map(\n             |(arg_index, local_decl)| DeducedParamAttrs {\n                 read_only: !deduce_read_only.mutable_args.contains(arg_index)\n-                    && local_decl.ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all()),\n+                    && local_decl.ty.is_freeze(tcx, ParamEnv::reveal_all()),\n             },\n         ),\n     );"}, {"sha": "5be2232547bd60e8eeb787845ba1529feb141b2e", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -71,7 +71,6 @@ mod inline;\n mod instcombine;\n mod lower_intrinsics;\n mod lower_slice_len;\n-mod marker;\n mod match_branches;\n mod multiple_return_terminators;\n mod normalize_array_len;\n@@ -303,6 +302,7 @@ fn mir_const<'tcx>(\n             &simplify::SimplifyCfg::new(\"initial\"),\n             &rustc_peek::SanityCheck, // Just a lint\n         ],\n+        None,\n     );\n     tcx.alloc_steal_mir(body)\n }\n@@ -342,6 +342,7 @@ fn mir_promoted<'tcx>(\n             &simplify::SimplifyCfg::new(\"promote-consts\"),\n             &coverage::InstrumentCoverage,\n         ],\n+        Some(MirPhase::Analysis(AnalysisPhase::Initial)),\n     );\n \n     let promoted = promote_pass.promoted_fragments.into_inner();\n@@ -409,10 +410,8 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n             pm::run_passes(\n                 tcx,\n                 &mut body,\n-                &[\n-                    &const_prop::ConstProp,\n-                    &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Optimized)),\n-                ],\n+                &[&const_prop::ConstProp],\n+                Some(MirPhase::Runtime(RuntimePhase::Optimized)),\n             );\n         }\n     }\n@@ -474,6 +473,7 @@ fn run_analysis_to_runtime_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>\n                 &remove_uninit_drops::RemoveUninitDrops,\n                 &simplify::SimplifyCfg::new(\"remove-false-edges\"),\n             ],\n+            None,\n         );\n         check_consts::post_drop_elaboration::check_live_drops(tcx, &body); // FIXME: make this a MIR lint\n     }\n@@ -498,10 +498,9 @@ fn run_analysis_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &cleanup_post_borrowck::CleanupNonCodegenStatements,\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n         &deref_separator::Derefer,\n-        &marker::PhaseChange(MirPhase::Analysis(AnalysisPhase::PostCleanup)),\n     ];\n \n-    pm::run_passes(tcx, body, passes);\n+    pm::run_passes(tcx, body, passes, Some(MirPhase::Analysis(AnalysisPhase::PostCleanup)));\n }\n \n /// Returns the sequence of passes that lowers analysis to runtime MIR.\n@@ -526,9 +525,8 @@ fn run_runtime_lowering_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // CTFE support for aggregates.\n         &deaggregator::Deaggregator,\n         &Lint(const_prop_lint::ConstProp),\n-        &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Initial)),\n     ];\n-    pm::run_passes_no_validate(tcx, body, passes);\n+    pm::run_passes_no_validate(tcx, body, passes, Some(MirPhase::Runtime(RuntimePhase::Initial)));\n }\n \n /// Returns the sequence of passes that do the initial cleanup of runtime MIR.\n@@ -537,10 +535,9 @@ fn run_runtime_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &elaborate_box_derefs::ElaborateBoxDerefs,\n         &lower_intrinsics::LowerIntrinsics,\n         &simplify::SimplifyCfg::new(\"elaborate-drops\"),\n-        &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::PostCleanup)),\n     ];\n \n-    pm::run_passes(tcx, body, passes);\n+    pm::run_passes(tcx, body, passes, Some(MirPhase::Runtime(RuntimePhase::PostCleanup)));\n }\n \n fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n@@ -591,10 +588,10 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n             &deduplicate_blocks::DeduplicateBlocks,\n             // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n             &add_call_guards::CriticalCallEdges,\n-            &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Optimized)),\n             // Dump the end result for testing and debugging purposes.\n             &dump_mir::Marker(\"PreCodegen\"),\n         ],\n+        Some(MirPhase::Runtime(RuntimePhase::Optimized)),\n     );\n }\n "}, {"sha": "06819fc1d37d483da63f99204788b29035ce45ba", "filename": "compiler/rustc_mir_transform/src/marker.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/compiler%2Frustc_mir_transform%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/compiler%2Frustc_mir_transform%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmarker.rs?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,20 +0,0 @@\n-use std::borrow::Cow;\n-\n-use crate::MirPass;\n-use rustc_middle::mir::{Body, MirPhase};\n-use rustc_middle::ty::TyCtxt;\n-\n-/// Changes the MIR phase without changing the MIR itself.\n-pub struct PhaseChange(pub MirPhase);\n-\n-impl<'tcx> MirPass<'tcx> for PhaseChange {\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        Some(self.0)\n-    }\n-\n-    fn name(&self) -> Cow<'_, str> {\n-        Cow::from(format!(\"PhaseChange-{:?}\", self.0))\n-    }\n-\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _body: &mut Body<'tcx>) {}\n-}"}, {"sha": "230c6a7cb4b00e438ca32ca439fea4b52930bc0d", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -66,10 +66,6 @@ where\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         self.1.run_pass(tcx, body)\n     }\n-\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        self.1.phase_change()\n-    }\n }\n \n /// Run the sequence of passes without validating the MIR after each pass. The MIR is still\n@@ -78,31 +74,35 @@ pub fn run_passes_no_validate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     passes: &[&dyn MirPass<'tcx>],\n+    phase_change: Option<MirPhase>,\n ) {\n-    run_passes_inner(tcx, body, passes, false);\n+    run_passes_inner(tcx, body, passes, phase_change, false);\n }\n \n-pub fn run_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, passes: &[&dyn MirPass<'tcx>]) {\n-    run_passes_inner(tcx, body, passes, true);\n+/// The optional `phase_change` is applied after executing all the passes, if present\n+pub fn run_passes<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    passes: &[&dyn MirPass<'tcx>],\n+    phase_change: Option<MirPhase>,\n+) {\n+    run_passes_inner(tcx, body, passes, phase_change, true);\n }\n \n fn run_passes_inner<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     passes: &[&dyn MirPass<'tcx>],\n+    phase_change: Option<MirPhase>,\n     validate_each: bool,\n ) {\n-    let start_phase = body.phase;\n-    let mut cnt = 0;\n-\n     let validate = validate_each & tcx.sess.opts.unstable_opts.validate_mir;\n     let overridden_passes = &tcx.sess.opts.unstable_opts.mir_enable_passes;\n     trace!(?overridden_passes);\n \n     for pass in passes {\n         let name = pass.name();\n \n-        // Gather information about what we should be doing for this pass\n         let overridden =\n             overridden_passes.iter().rev().find(|(s, _)| s == &*name).map(|(_name, polarity)| {\n                 trace!(\n@@ -112,55 +112,78 @@ fn run_passes_inner<'tcx>(\n                 );\n                 *polarity\n             });\n-        let is_enabled = overridden.unwrap_or_else(|| pass.is_enabled(&tcx.sess));\n-        let new_phase = pass.phase_change();\n-        let dump_enabled = (is_enabled && pass.is_mir_dump_enabled()) || new_phase.is_some();\n-        let validate = (validate && is_enabled)\n-            || new_phase == Some(MirPhase::Runtime(RuntimePhase::Optimized));\n+        if !overridden.unwrap_or_else(|| pass.is_enabled(&tcx.sess)) {\n+            continue;\n+        }\n+\n+        let dump_enabled = pass.is_mir_dump_enabled();\n \n         if dump_enabled {\n-            dump_mir(tcx, body, start_phase, &name, cnt, false);\n-        }\n-        if is_enabled {\n-            pass.run_pass(tcx, body);\n+            dump_mir_for_pass(tcx, body, &name, false);\n         }\n-        if dump_enabled {\n-            dump_mir(tcx, body, start_phase, &name, cnt, true);\n-            cnt += 1;\n+        if validate {\n+            validate_body(tcx, body, format!(\"before pass {}\", name));\n         }\n-        if let Some(new_phase) = pass.phase_change() {\n-            if body.phase >= new_phase {\n-                panic!(\"Invalid MIR phase transition from {:?} to {:?}\", body.phase, new_phase);\n-            }\n \n-            body.phase = new_phase;\n+        pass.run_pass(tcx, body);\n+\n+        if dump_enabled {\n+            dump_mir_for_pass(tcx, body, &name, true);\n         }\n         if validate {\n             validate_body(tcx, body, format!(\"after pass {}\", name));\n         }\n+\n+        body.pass_count += 1;\n+    }\n+\n+    if let Some(new_phase) = phase_change {\n+        if body.phase >= new_phase {\n+            panic!(\"Invalid MIR phase transition from {:?} to {:?}\", body.phase, new_phase);\n+        }\n+\n+        body.phase = new_phase;\n+\n+        dump_mir_for_phase_change(tcx, body);\n+        if validate || new_phase == MirPhase::Runtime(RuntimePhase::Optimized) {\n+            validate_body(tcx, body, format!(\"after phase change to {}\", new_phase));\n+        }\n+\n+        body.pass_count = 1;\n     }\n }\n \n pub fn validate_body<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, when: String) {\n     validate::Validator { when, mir_phase: body.phase }.run_pass(tcx, body);\n }\n \n-pub fn dump_mir<'tcx>(\n+pub fn dump_mir_for_pass<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    phase: MirPhase,\n     pass_name: &str,\n-    cnt: usize,\n     is_after: bool,\n ) {\n-    let phase_index = phase.phase_index();\n+    let phase_index = body.phase.phase_index();\n \n     mir::dump_mir(\n         tcx,\n-        Some(&format_args!(\"{:03}-{:03}\", phase_index, cnt)),\n+        Some(&format_args!(\"{:03}-{:03}\", phase_index, body.pass_count)),\n         pass_name,\n         if is_after { &\"after\" } else { &\"before\" },\n         body,\n         |_, _| Ok(()),\n     );\n }\n+\n+pub fn dump_mir_for_phase_change<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n+    let phase_index = body.phase.phase_index();\n+\n+    mir::dump_mir(\n+        tcx,\n+        Some(&format_args!(\"{:03}-000\", phase_index)),\n+        &format!(\"{}\", body.phase),\n+        &\"after\",\n+        body,\n+        |_, _| Ok(()),\n+    )\n+}"}, {"sha": "4e8798b7a55d2a58c9680fae5a8c4329e2289ba4", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -17,7 +17,7 @@ use std::iter;\n \n use crate::util::expand_aggregate;\n use crate::{\n-    abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, deref_separator, marker,\n+    abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, deref_separator,\n     pass_manager as pm, remove_noop_landing_pads, simplify,\n };\n use rustc_middle::mir::patch::MirPatch;\n@@ -97,8 +97,8 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n             &simplify::SimplifyCfg::new(\"make_shim\"),\n             &add_call_guards::CriticalCallEdges,\n             &abort_unwinding_calls::AbortUnwindingCalls,\n-            &marker::PhaseChange(MirPhase::Runtime(RuntimePhase::Optimized)),\n         ],\n+        Some(MirPhase::Runtime(RuntimePhase::Optimized)),\n     );\n \n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n@@ -312,7 +312,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let param_env = tcx.param_env(def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n-    let is_copy = self_ty.is_copy_modulo_regions(tcx.at(builder.span), param_env);\n+    let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env);\n \n     let dest = Place::return_place();\n     let src = tcx.mk_place_deref(Place::from(Local::new(1 + 0)));"}, {"sha": "a71218e6997576bbff139ecbac5716b2f017f570", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1067,7 +1067,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n-            if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            if ty.is_sized(tcx, param_env) {\n                 return false;\n             }\n             let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);\n@@ -1192,7 +1192,7 @@ struct RootCollector<'a, 'tcx> {\n \n impl<'v> RootCollector<'_, 'v> {\n     fn process_item(&mut self, id: hir::ItemId) {\n-        match self.tcx.def_kind(id.def_id) {\n+        match self.tcx.def_kind(id.owner_id) {\n             DefKind::Enum | DefKind::Struct | DefKind::Union => {\n                 let item = self.tcx.hir().item(id);\n                 match item.kind {\n@@ -1203,12 +1203,14 @@ impl<'v> RootCollector<'_, 'v> {\n                             if self.mode == MonoItemCollectionMode::Eager {\n                                 debug!(\n                                     \"RootCollector: ADT drop-glue for {}\",\n-                                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                                    self.tcx.def_path_str(item.owner_id.to_def_id())\n                                 );\n \n-                                let ty =\n-                                    Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n-                                        .ty(self.tcx, ty::ParamEnv::reveal_all());\n+                                let ty = Instance::new(\n+                                    item.owner_id.to_def_id(),\n+                                    InternalSubsts::empty(),\n+                                )\n+                                .ty(self.tcx, ty::ParamEnv::reveal_all());\n                                 visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                             }\n                         }\n@@ -1219,23 +1221,23 @@ impl<'v> RootCollector<'_, 'v> {\n             DefKind::GlobalAsm => {\n                 debug!(\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n-                    self.tcx.def_path_str(id.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.owner_id.to_def_id())\n                 );\n                 self.output.push(dummy_spanned(MonoItem::GlobalAsm(id)));\n             }\n             DefKind::Static(..) => {\n                 debug!(\n                     \"RootCollector: ItemKind::Static({})\",\n-                    self.tcx.def_path_str(id.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.owner_id.to_def_id())\n                 );\n-                self.output.push(dummy_spanned(MonoItem::Static(id.def_id.to_def_id())));\n+                self.output.push(dummy_spanned(MonoItem::Static(id.owner_id.to_def_id())));\n             }\n             DefKind::Const => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                if let Ok(val) = self.tcx.const_eval_poly(id.def_id.to_def_id()) {\n+                if let Ok(val) = self.tcx.const_eval_poly(id.owner_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n@@ -1246,15 +1248,15 @@ impl<'v> RootCollector<'_, 'v> {\n                 }\n             }\n             DefKind::Fn => {\n-                self.push_if_root(id.def_id.def_id);\n+                self.push_if_root(id.owner_id.def_id);\n             }\n             _ => {}\n         }\n     }\n \n     fn process_impl_item(&mut self, id: hir::ImplItemId) {\n-        if matches!(self.tcx.def_kind(id.def_id), DefKind::AssocFn) {\n-            self.push_if_root(id.def_id.def_id);\n+        if matches!(self.tcx.def_kind(id.owner_id), DefKind::AssocFn) {\n+            self.push_if_root(id.owner_id.def_id);\n         }\n     }\n \n@@ -1352,13 +1354,13 @@ fn create_mono_items_for_default_impls<'tcx>(\n \n             debug!(\n                 \"create_mono_items_for_default_impls(item={})\",\n-                tcx.def_path_str(item.def_id.to_def_id())\n+                tcx.def_path_str(item.owner_id.to_def_id())\n             );\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n+            if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n-                let overridden_methods = tcx.impl_item_implementor_ids(item.def_id);\n+                let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains_key(&method.def_id) {\n                         continue;"}, {"sha": "29009c48050e1b576e1c8ffe76c029f6378db6e5", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -319,7 +319,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.to_def_id()),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n     }\n }\n \n@@ -411,9 +411,9 @@ fn mono_item_visibility<'tcx>(\n             };\n         }\n         MonoItem::GlobalAsm(item_id) => {\n-            return if tcx.is_reachable_non_generic(item_id.def_id) {\n+            return if tcx.is_reachable_non_generic(item_id.owner_id) {\n                 *can_be_internalized = false;\n-                default_visibility(tcx, item_id.def_id.to_def_id(), false)\n+                default_visibility(tcx, item_id.owner_id.to_def_id(), false)\n             } else {\n                 Visibility::Hidden\n             };"}, {"sha": "a781748efc52af24aff8ed22f151cd16e7628a7e", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2112,6 +2112,8 @@ impl<'a> Parser<'a> {\n             // HACK: This is needed so we can detect whether we're inside a macro,\n             // where regular assumptions about what tokens can follow other tokens\n             // don't necessarily apply.\n+            && self.may_recover()\n+            // FIXME(Nilstrieb): Remove this check once `may_recover` actually stops recovery\n             && self.subparser_name.is_none()\n         {\n             // It is likely that the closure body is a block but where the"}, {"sha": "5fe29062b85b90b7d1c88755283e812ed10dcff8", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -115,6 +115,12 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     };\n }\n \n+#[derive(Clone, Copy)]\n+pub enum Recovery {\n+    Allowed,\n+    Forbidden,\n+}\n+\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n@@ -152,12 +158,15 @@ pub struct Parser<'a> {\n     /// This allows us to recover when the user forget to add braces around\n     /// multiple statements in the closure body.\n     pub current_closure: Option<ClosureSpans>,\n+    /// Whether the parser is allowed to do recovery.\n+    /// This is disabled when parsing macro arguments, see #103534\n+    pub recovery: Recovery,\n }\n \n-// This type is used a lot, e.g. it's cloned when matching many declarative macro rules. Make sure\n+// This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 328);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 336);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -483,6 +492,7 @@ impl<'a> Parser<'a> {\n                 inner_attr_ranges: Default::default(),\n             },\n             current_closure: None,\n+            recovery: Recovery::Allowed,\n         };\n \n         // Make parser point to the first token.\n@@ -491,6 +501,22 @@ impl<'a> Parser<'a> {\n         parser\n     }\n \n+    pub fn forbid_recovery(mut self) -> Self {\n+        self.recovery = Recovery::Forbidden;\n+        self\n+    }\n+\n+    /// Whether the parser is allowed to recover from broken code.\n+    ///\n+    /// If this returns false, recovering broken code into valid code (especially if this recovery does lookahead)\n+    /// is not allowed. All recovery done by the parser must be gated behind this check.\n+    ///\n+    /// Technically, this only needs to restrict eager recovery by doing lookahead at more tokens.\n+    /// But making the distinction is very subtle, and simply forbidding all recovery is a lot simpler to uphold.\n+    fn may_recover(&self) -> bool {\n+        matches!(self.recovery, Recovery::Allowed)\n+    }\n+\n     pub fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),"}, {"sha": "12753c6785c9aa5ecb2c5a9a78946c3b382cec47", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -553,39 +553,46 @@ impl<'a> Parser<'a> {\n         match stmt.kind {\n             // Expression without semicolon.\n             StmtKind::Expr(ref mut expr)\n-                if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) =>\n-            {\n+                if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) => {\n                 // Just check for errors and recover; do not eat semicolon yet.\n-                if let Err(mut e) =\n-                    self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)])\n-                {\n-                    if let TokenKind::DocComment(..) = self.token.kind {\n-                        if let Ok(snippet) = self.span_to_snippet(self.token.span) {\n-                            let sp = self.token.span;\n-                            let marker = &snippet[..3];\n-                            let (comment_marker, doc_comment_marker) = marker.split_at(2);\n-\n-                            e.span_suggestion(\n-                                sp.with_hi(sp.lo() + BytePos(marker.len() as u32)),\n-                                &format!(\n-                                    \"add a space before `{}` to use a regular comment\",\n-                                    doc_comment_marker,\n-                                ),\n-                                format!(\"{} {}\", comment_marker, doc_comment_marker),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                // `expect_one_of` returns PResult<'a, bool /* recovered */>\n+                let replace_with_err =\n+                    match self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)]) {\n+                    // Recover from parser, skip type error to avoid extra errors.\n+                    Ok(true) => true,\n+                    Err(mut e) => {\n+                        if let TokenKind::DocComment(..) = self.token.kind &&\n+                            let Ok(snippet) = self.span_to_snippet(self.token.span) {\n+                                let sp = self.token.span;\n+                                let marker = &snippet[..3];\n+                                let (comment_marker, doc_comment_marker) = marker.split_at(2);\n+\n+                                e.span_suggestion(\n+                                    sp.with_hi(sp.lo() + BytePos(marker.len() as u32)),\n+                                    &format!(\n+                                        \"add a space before `{}` to use a regular comment\",\n+                                        doc_comment_marker,\n+                                    ),\n+                                    format!(\"{} {}\", comment_marker, doc_comment_marker),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n                         }\n-                    }\n-                    if let Err(mut e) =\n-                        self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n-                    {\n-                        if recover.no() {\n-                            return Err(e);\n+\n+                        if let Err(mut e) =\n+                            self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n+                        {\n+                            if recover.no() {\n+                                return Err(e);\n+                            }\n+                            e.emit();\n+                            self.recover_stmt();\n                         }\n-                        e.emit();\n-                        self.recover_stmt();\n+                        true\n                     }\n-                    // Don't complain about type errors in body tail after parse error (#57383).\n+                    _ => false\n+                };\n+                if replace_with_err {\n+                    // We already emitted an error, so don't emit another type error\n                     let sp = expr.span.to(self.prev_token.span);\n                     *expr = self.mk_expr_err(sp);\n                 }"}, {"sha": "27a57adf964a30765ee67a9801b18e88d38e9ec6", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2062,7 +2062,7 @@ impl<'tcx> Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         // so this lets us continue to run them while maintaining backwards compatibility.\n         // In the long run, the checks should be harmonized.\n         if let ItemKind::Macro(ref macro_def, _) = item.kind {\n-            let def_id = item.def_id.to_def_id();\n+            let def_id = item.owner_id.to_def_id();\n             if macro_def.macro_rules && !self.tcx.has_attr(def_id, sym::macro_export) {\n                 check_non_exported_macro_for_invalid_attrs(self.tcx, item);\n             }"}, {"sha": "753d01f46cabdbec382c554d1278887171854841", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Node, PatKind, TyKind};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::middle::privacy::AccessLevel;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n@@ -280,8 +280,8 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     }\n \n     fn visit_node(&mut self, node: Node<'tcx>) {\n-        if let Node::ImplItem(hir::ImplItem { def_id, .. }) = node\n-            && self.should_ignore_item(def_id.to_def_id())\n+        if let Node::ImplItem(hir::ImplItem { owner_id, .. }) = node\n+            && self.should_ignore_item(owner_id.to_def_id())\n         {\n             return;\n         }\n@@ -293,7 +293,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         match node {\n             Node::Item(item) => match item.kind {\n                 hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                    let def = self.tcx.adt_def(item.def_id);\n+                    let def = self.tcx.adt_def(item.owner_id);\n                     self.repr_has_repr_c = def.repr().c();\n                     self.repr_has_repr_simd = def.repr().simd();\n \n@@ -306,7 +306,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n             Node::ImplItem(impl_item) => {\n-                let item = self.tcx.local_parent(impl_item.def_id.def_id);\n+                let item = self.tcx.local_parent(impl_item.owner_id.def_id);\n                 if self.tcx.impl_trait_ref(item).is_none() {\n                     //// If it's a type whose items are live, then it's live, too.\n                     //// This is done to handle the case where, for example, the static\n@@ -517,10 +517,10 @@ fn check_item<'tcx>(\n ) {\n     let allow_dead_code = has_allow_dead_code_or_lang_attr(tcx, id.hir_id());\n     if allow_dead_code {\n-        worklist.push(id.def_id.def_id);\n+        worklist.push(id.owner_id.def_id);\n     }\n \n-    match tcx.def_kind(id.def_id) {\n+    match tcx.def_kind(id.owner_id) {\n         DefKind::Enum => {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::Enum(ref enum_def, _) = item.kind {\n@@ -540,15 +540,15 @@ fn check_item<'tcx>(\n             }\n         }\n         DefKind::Impl => {\n-            let of_trait = tcx.impl_trait_ref(id.def_id);\n+            let of_trait = tcx.impl_trait_ref(id.owner_id);\n \n             if of_trait.is_some() {\n-                worklist.push(id.def_id.def_id);\n+                worklist.push(id.owner_id.def_id);\n             }\n \n             // get DefIds from another query\n             let local_def_ids = tcx\n-                .associated_item_def_ids(id.def_id)\n+                .associated_item_def_ids(id.owner_id)\n                 .iter()\n                 .filter_map(|def_id| def_id.as_local());\n \n@@ -566,25 +566,25 @@ fn check_item<'tcx>(\n             if let hir::ItemKind::Struct(ref variant_data, _) = item.kind\n                 && let Some(ctor_hir_id) = variant_data.ctor_hir_id()\n             {\n-                struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.def_id.def_id);\n+                struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.owner_id.def_id);\n             }\n         }\n         DefKind::GlobalAsm => {\n             // global_asm! is always live.\n-            worklist.push(id.def_id.def_id);\n+            worklist.push(id.owner_id.def_id);\n         }\n         _ => {}\n     }\n }\n \n fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, worklist: &mut Vec<LocalDefId>, id: hir::TraitItemId) {\n     use hir::TraitItemKind::{Const, Fn};\n-    if matches!(tcx.def_kind(id.def_id), DefKind::AssocConst | DefKind::AssocFn) {\n+    if matches!(tcx.def_kind(id.owner_id), DefKind::AssocConst | DefKind::AssocFn) {\n         let trait_item = tcx.hir().trait_item(id);\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n             && has_allow_dead_code_or_lang_attr(tcx, trait_item.hir_id())\n         {\n-            worklist.push(trait_item.def_id.def_id);\n+            worklist.push(trait_item.owner_id.def_id);\n         }\n     }\n }\n@@ -594,23 +594,23 @@ fn check_foreign_item<'tcx>(\n     worklist: &mut Vec<LocalDefId>,\n     id: hir::ForeignItemId,\n ) {\n-    if matches!(tcx.def_kind(id.def_id), DefKind::Static(_) | DefKind::Fn)\n+    if matches!(tcx.def_kind(id.owner_id), DefKind::Static(_) | DefKind::Fn)\n         && has_allow_dead_code_or_lang_attr(tcx, id.hir_id())\n     {\n-        worklist.push(id.def_id.def_id);\n+        worklist.push(id.owner_id.def_id);\n     }\n }\n \n fn create_and_seed_worklist<'tcx>(\n     tcx: TyCtxt<'tcx>,\n ) -> (Vec<LocalDefId>, FxHashMap<LocalDefId, LocalDefId>) {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n     // see `MarkSymbolVisitor::struct_constructors`\n     let mut struct_constructors = Default::default();\n-    let mut worklist = access_levels\n+    let mut worklist = effective_visibilities\n         .iter()\n         .filter_map(|(&id, effective_vis)| {\n-            effective_vis.is_public_at_level(AccessLevel::Reachable).then_some(id)\n+            effective_vis.is_public_at_level(Level::Reachable).then_some(id)\n         })\n         // Seed entry point\n         .chain(tcx.entry_fn(()).and_then(|(def_id, _)| def_id.as_local()))\n@@ -861,19 +861,19 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let module_items = tcx.hir_module_items(module);\n \n     for item in module_items.items() {\n-        if !live_symbols.contains(&item.def_id.def_id) {\n-            let parent = tcx.local_parent(item.def_id.def_id);\n+        if !live_symbols.contains(&item.owner_id.def_id) {\n+            let parent = tcx.local_parent(item.owner_id.def_id);\n             if parent != module && !live_symbols.contains(&parent) {\n                 // We already have diagnosed something.\n                 continue;\n             }\n-            visitor.check_definition(item.def_id.def_id);\n+            visitor.check_definition(item.owner_id.def_id);\n             continue;\n         }\n \n-        let def_kind = tcx.def_kind(item.def_id);\n+        let def_kind = tcx.def_kind(item.owner_id);\n         if let DefKind::Struct | DefKind::Union | DefKind::Enum = def_kind {\n-            let adt = tcx.adt_def(item.def_id);\n+            let adt = tcx.adt_def(item.owner_id);\n             let mut dead_variants = Vec::new();\n \n             for variant in adt.variants() {\n@@ -917,7 +917,7 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n             }\n \n             visitor.warn_dead_fields_and_variants(\n-                item.def_id.def_id,\n+                item.owner_id.def_id,\n                 \"constructed\",\n                 dead_variants,\n                 false,\n@@ -926,11 +926,11 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n     }\n \n     for impl_item in module_items.impl_items() {\n-        visitor.check_definition(impl_item.def_id.def_id);\n+        visitor.check_definition(impl_item.owner_id.def_id);\n     }\n \n     for foreign_item in module_items.foreign_items() {\n-        visitor.check_definition(foreign_item.def_id.def_id);\n+        visitor.check_definition(foreign_item.owner_id.def_id);\n     }\n \n     // We do not warn trait items."}, {"sha": "a72056e00b1e2feb610e17b36b5bf68273121982", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -73,19 +73,19 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> DiagnosticItems\n     let crate_items = tcx.hir_crate_items(());\n \n     for id in crate_items.items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     for id in crate_items.trait_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     for id in crate_items.impl_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     for id in crate_items.foreign_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     diagnostic_items"}, {"sha": "5885f45ae45db788642b311f7245a98e8d70fcd3", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -62,7 +62,7 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n     } else if ctxt.tcx.sess.contains_name(attrs, sym::rustc_main) {\n         EntryPointType::RustcMainAttr\n     } else {\n-        if let Some(name) = ctxt.tcx.opt_item_name(id.def_id.to_def_id())\n+        if let Some(name) = ctxt.tcx.opt_item_name(id.owner_id.to_def_id())\n             && name == sym::main {\n             if at_root {\n                 // This is a top-level function so can be `main`.\n@@ -82,15 +82,15 @@ fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Opti\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n-    let at_root = ctxt.tcx.opt_local_parent(id.def_id.def_id) == Some(CRATE_DEF_ID);\n+    let at_root = ctxt.tcx.opt_local_parent(id.owner_id.def_id) == Some(CRATE_DEF_ID);\n \n     match entry_point_type(ctxt, id, at_root) {\n         EntryPointType::None => {\n             if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n                 ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n             }\n         }\n-        _ if !matches!(ctxt.tcx.def_kind(id.def_id), DefKind::Fn) => {\n+        _ if !matches!(ctxt.tcx.def_kind(id.owner_id), DefKind::Fn) => {\n             for attr in [sym::start, sym::rustc_main] {\n                 if let Some(span) = attr_span_by_symbol(ctxt, id, attr) {\n                     ctxt.tcx.sess.emit_err(AttrOnlyInFunctions { span, attr });\n@@ -102,16 +102,16 @@ fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n             if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n                 ctxt.tcx.sess.emit_err(AttrOnlyOnRootMain { span, attr: sym::unix_sigpipe });\n             }\n-            ctxt.non_main_fns.push(ctxt.tcx.def_span(id.def_id));\n+            ctxt.non_main_fns.push(ctxt.tcx.def_span(id.owner_id));\n         }\n         EntryPointType::RustcMainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n+                ctxt.attr_main_fn = Some((id.owner_id.def_id, ctxt.tcx.def_span(id.owner_id)));\n             } else {\n                 ctxt.tcx.sess.emit_err(MultipleRustcMain {\n-                    span: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    span: ctxt.tcx.def_span(id.owner_id.to_def_id()),\n                     first: ctxt.attr_main_fn.unwrap().1,\n-                    additional: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    additional: ctxt.tcx.def_span(id.owner_id.to_def_id()),\n                 });\n             }\n         }\n@@ -120,11 +120,11 @@ fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n                 ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n             }\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n+                ctxt.start_fn = Some((id.owner_id.def_id, ctxt.tcx.def_span(id.owner_id)));\n             } else {\n                 ctxt.tcx.sess.emit_err(MultipleStartFunctions {\n-                    span: ctxt.tcx.def_span(id.def_id),\n-                    labeled: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    span: ctxt.tcx.def_span(id.owner_id),\n+                    labeled: ctxt.tcx.def_span(id.owner_id.to_def_id()),\n                     previous: ctxt.start_fn.unwrap().1,\n                 });\n             }"}, {"sha": "88bb39debb114640e660f41c4174f1538fc5d055", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_item(this, i));\n     }\n \n     fn visit_id(&mut self, hir_id: HirId) {\n@@ -148,16 +148,16 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n     fn visit_foreign_item(&mut self, i: &'hir hir::ForeignItem<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_foreign_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_foreign_item(this, i));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_trait_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_trait_item(this, i));\n     }\n \n     fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_impl_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_impl_item(this, i));\n     }\n }"}, {"sha": "df811be2a7e443b9e4ed59c4e5af6d27acd26b79", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -217,9 +217,9 @@ fn get_lang_items(tcx: TyCtxt<'_>, (): ()) -> LanguageItems {\n     let crate_items = tcx.hir_crate_items(());\n \n     for id in crate_items.items() {\n-        collector.check_for_lang(Target::from_def_kind(tcx.def_kind(id.def_id)), id.hir_id());\n+        collector.check_for_lang(Target::from_def_kind(tcx.def_kind(id.owner_id)), id.hir_id());\n \n-        if matches!(tcx.def_kind(id.def_id), DefKind::Enum) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Enum) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::Enum(def, ..) = &item.kind {\n                 for variant in def.variants {"}, {"sha": "5322baee7473a451f107903d9d46c45c42ece559", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -15,11 +15,11 @@ pub fn test_layout(tcx: TyCtxt<'_>) {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n         for id in tcx.hir().items() {\n             if matches!(\n-                tcx.def_kind(id.def_id),\n+                tcx.def_kind(id.owner_id),\n                 DefKind::TyAlias | DefKind::Enum | DefKind::Struct | DefKind::Union\n             ) {\n-                for attr in tcx.get_attrs(id.def_id.to_def_id(), sym::rustc_layout) {\n-                    dump_layout_of(tcx, id.def_id.def_id, attr);\n+                for attr in tcx.get_attrs(id.owner_id.to_def_id(), sym::rustc_layout) {\n+                    dump_layout_of(tcx, id.owner_id.def_id, attr);\n                 }\n             }\n         }"}, {"sha": "10d5fc5d6711018855962f03e0e856bce5ee1a87", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n-use rustc_middle::middle::privacy::{self, AccessLevel};\n+use rustc_middle::middle::privacy::{self, Level};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::CrateType;\n@@ -29,7 +29,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'_>, item: &hir::Item<'_>, attrs: &CodegenF\n     match item.kind {\n         hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => true,\n         hir::ItemKind::Impl { .. } | hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(item.def_id);\n+            let generics = tcx.generics_of(item.owner_id);\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -42,7 +42,7 @@ fn method_might_be_inlined(\n     impl_src: LocalDefId,\n ) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id().owner.to_def_id());\n-    let generics = tcx.generics_of(impl_item.def_id);\n+    let generics = tcx.generics_of(impl_item.owner_id);\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true;\n     }\n@@ -216,7 +216,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                         if item_might_be_inlined(\n                             self.tcx,\n                             &item,\n-                            self.tcx.codegen_fn_attrs(item.def_id),\n+                            self.tcx.codegen_fn_attrs(item.owner_id),\n                         ) {\n                             self.visit_nested_body(body);\n                         }\n@@ -303,13 +303,13 @@ fn check_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::ItemId,\n     worklist: &mut Vec<LocalDefId>,\n-    access_levels: &privacy::AccessLevels,\n+    effective_visibilities: &privacy::EffectiveVisibilities,\n ) {\n-    if has_custom_linkage(tcx, id.def_id.def_id) {\n-        worklist.push(id.def_id.def_id);\n+    if has_custom_linkage(tcx, id.owner_id.def_id) {\n+        worklist.push(id.owner_id.def_id);\n     }\n \n-    if !matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n+    if !matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n         return;\n     }\n \n@@ -318,8 +318,8 @@ fn check_item<'tcx>(\n     if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n         item.kind\n     {\n-        if !access_levels.is_reachable(item.def_id.def_id) {\n-            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id.def_id));\n+        if !effective_visibilities.is_reachable(item.owner_id.def_id) {\n+            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.owner_id.def_id));\n \n             let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n                 unreachable!();\n@@ -354,7 +354,7 @@ fn has_custom_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n }\n \n fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n-    let access_levels = &tcx.privacy_access_levels(());\n+    let effective_visibilities = &tcx.effective_visibilities(());\n \n     let any_library =\n         tcx.sess.crate_types().iter().any(|ty| {\n@@ -373,10 +373,10 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context.worklist = access_levels\n+    reachable_context.worklist = effective_visibilities\n         .iter()\n         .filter_map(|(&id, effective_vis)| {\n-            effective_vis.is_public_at_level(AccessLevel::ReachableFromImplTrait).then_some(id)\n+            effective_vis.is_public_at_level(Level::ReachableThroughImplTrait).then_some(id)\n         })\n         .collect::<Vec<_>>();\n \n@@ -399,12 +399,12 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            check_item(tcx, id, &mut reachable_context.worklist, access_levels);\n+            check_item(tcx, id, &mut reachable_context.worklist, effective_visibilities);\n         }\n \n         for id in crate_items.impl_items() {\n-            if has_custom_linkage(tcx, id.def_id.def_id) {\n-                reachable_context.worklist.push(id.def_id.def_id);\n+            if has_custom_linkage(tcx, id.owner_id.def_id) {\n+                reachable_context.worklist.push(id.owner_id.def_id);\n             }\n         }\n     }"}, {"sha": "78afa2f25f8e10c97b265ece1540c7876ec28e43", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{FieldDef, Item, ItemKind, TraitRef, Ty, TyKind, Variant};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::middle::stability::{AllowUnstable, DeprecationEntry, Index};\n use rustc_middle::ty::{query::Providers, TyCtxt};\n use rustc_session::lint;\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(\n-            i.def_id.def_id,\n+            i.owner_id.def_id,\n             i.span,\n             fn_sig,\n             kind,\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ti.def_id.def_id,\n+            ti.owner_id.def_id,\n             ti.span,\n             fn_sig,\n             AnnotationKind::Required,\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ii.def_id.def_id,\n+            ii.owner_id.def_id,\n             ii.span,\n             fn_sig,\n             kind,\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.annotate(\n-            i.def_id.def_id,\n+            i.owner_id.def_id,\n             i.span,\n             None,\n             AnnotationKind::Required,\n@@ -516,13 +516,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n struct MissingStabilityAnnotations<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'tcx AccessLevels,\n+    effective_visibilities: &'tcx EffectiveVisibilities,\n }\n \n impl<'tcx> MissingStabilityAnnotations<'tcx> {\n     fn check_missing_stability(&self, def_id: LocalDefId, span: Span) {\n         let stab = self.tcx.stability().local_stability(def_id);\n-        if !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(def_id) {\n+        if !self.tcx.sess.opts.test\n+            && stab.is_none()\n+            && self.effective_visibilities.is_reachable(def_id)\n+        {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n             self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n         }\n@@ -540,7 +543,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n             .lookup_stability(def_id)\n             .map_or(false, |stability| stability.level.is_stable());\n         let missing_const_stability_attribute = self.tcx.lookup_const_stability(def_id).is_none();\n-        let is_reachable = self.access_levels.is_reachable(def_id);\n+        let is_reachable = self.effective_visibilities.is_reachable(def_id);\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n@@ -566,25 +569,25 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n             hir::ItemKind::Impl(hir::Impl { of_trait: None, .. })\n                 | hir::ItemKind::ForeignMod { .. }\n         ) {\n-            self.check_missing_stability(i.def_id.def_id, i.span);\n+            self.check_missing_stability(i.owner_id.def_id, i.span);\n         }\n \n         // Ensure stable `const fn` have a const stability attribute.\n-        self.check_missing_const_stability(i.def_id.def_id, i.span);\n+        self.check_missing_const_stability(i.owner_id.def_id, i.span);\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.check_missing_stability(ti.def_id.def_id, ti.span);\n+        self.check_missing_stability(ti.owner_id.def_id, ti.span);\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let impl_def_id = self.tcx.hir().get_parent_item(ii.hir_id());\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.def_id.def_id, ii.span);\n-            self.check_missing_const_stability(ii.def_id.def_id, ii.span);\n+            self.check_missing_stability(ii.owner_id.def_id, ii.span);\n+            self.check_missing_const_stability(ii.owner_id.def_id, ii.span);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -603,7 +606,7 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.check_missing_stability(i.def_id.def_id, i.span);\n+        self.check_missing_stability(i.owner_id.def_id, i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n     // Note that we don't need to `check_missing_stability` for default generic parameters,\n@@ -709,7 +712,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     return;\n                 }\n \n-                let Some(cnum) = self.tcx.extern_mod_stmt_cnum(item.def_id.def_id) else {\n+                let Some(cnum) = self.tcx.extern_mod_stmt_cnum(item.owner_id.def_id) else {\n                     return;\n                 };\n                 let def_id = cnum.as_def_id();\n@@ -762,7 +765,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                 }\n \n                 for impl_item_ref in *items {\n-                    let impl_item = self.tcx.associated_item(impl_item_ref.id.def_id);\n+                    let impl_item = self.tcx.associated_item(impl_item_ref.id.owner_id);\n \n                     if let Some(def_id) = impl_item.trait_item_def_id {\n                         // Pass `None` to skip deprecation warnings.\n@@ -919,8 +922,8 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     let is_staged_api =\n         tcx.sess.opts.unstable_opts.force_unstable_if_unmarked || tcx.features().staged_api;\n     if is_staged_api {\n-        let access_levels = &tcx.privacy_access_levels(());\n-        let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n+        let effective_visibilities = &tcx.effective_visibilities(());\n+        let mut missing = MissingStabilityAnnotations { tcx, effective_visibilities };\n         missing.check_missing_stability(CRATE_DEF_ID, tcx.hir().span(CRATE_HIR_ID));\n         tcx.hir().walk_toplevel_module(&mut missing);\n         tcx.hir().visit_all_item_likes_in_crate(&mut missing);"}, {"sha": "959ee600c07096ce20ee923de37565f73b5cfdff", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -34,7 +34,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n                     items.missing.push(item);\n                 }\n             } else {\n-                let span = tcx.def_span(id.def_id);\n+                let span = tcx.def_span(id.owner_id);\n                 tcx.sess.emit_err(UnknownExternLangItem { span, lang_item });\n             }\n         }"}, {"sha": "865d6306bd349953271cc3788ed6948da6a859ac", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 126, "deletions": 115, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -23,7 +23,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::span_bug;\n use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst, Node as ACNode};\n use rustc_middle::ty::query::Providers;\n@@ -310,7 +310,7 @@ fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visib\n \n struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n+    effective_visibilities: &'a EffectiveVisibilities,\n     min: VL,\n }\n \n@@ -344,8 +344,12 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl(def_id: LocalDefId, tcx: TyCtxt<'_>, access_levels: &AccessLevels) -> Self {\n-        let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n+    fn of_impl(\n+        def_id: LocalDefId,\n+        tcx: TyCtxt<'_>,\n+        effective_visibilities: &EffectiveVisibilities,\n+    ) -> Self {\n+        let mut find = FindMin { tcx, effective_visibilities, min: Self::MAX };\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref);\n@@ -359,8 +363,8 @@ impl VisibilityLike for ty::Visibility {\n         min(find.tcx.local_visibility(def_id), find.min, find.tcx)\n     }\n }\n-impl VisibilityLike for Option<AccessLevel> {\n-    const MAX: Self = Some(AccessLevel::Public);\n+impl VisibilityLike for Option<Level> {\n+    const MAX: Self = Some(Level::Direct);\n     // Type inference is very smart sometimes.\n     // It can make an impl reachable even some components of its type or trait are unreachable.\n     // E.g. methods of `impl ReachableTrait<UnreachableTy> for ReachableTy<UnreachableTy> { ... }`\n@@ -372,7 +376,7 @@ impl VisibilityLike for Option<AccessLevel> {\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n-        cmp::min(find.access_levels.get_access_level(def_id), find.min)\n+        cmp::min(find.effective_visibilities.public_at_level(def_id), find.min)\n     }\n }\n \n@@ -383,8 +387,8 @@ impl VisibilityLike for Option<AccessLevel> {\n struct EmbargoVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    /// Accessibility levels for reachable nodes.\n-    access_levels: AccessLevels,\n+    /// Effective visibilities for reachable nodes.\n+    effective_visibilities: EffectiveVisibilities,\n     /// A set of pairs corresponding to modules, where the first module is\n     /// reachable via a macro that's defined in the second module. This cannot\n     /// be represented as reachable because it can't handle the following case:\n@@ -398,38 +402,34 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n-    /// Previous accessibility level; `None` means unreachable.\n-    prev_level: Option<AccessLevel>,\n+    /// Previous visibility level; `None` means unreachable.\n+    prev_level: Option<Level>,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    access_level: Option<AccessLevel>,\n+    level: Option<Level>,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n }\n \n impl<'tcx> EmbargoVisitor<'tcx> {\n-    fn get(&self, def_id: LocalDefId) -> Option<AccessLevel> {\n-        self.access_levels.get_access_level(def_id)\n+    fn get(&self, def_id: LocalDefId) -> Option<Level> {\n+        self.effective_visibilities.public_at_level(def_id)\n     }\n \n-    fn update_with_hir_id(\n-        &mut self,\n-        hir_id: hir::HirId,\n-        level: Option<AccessLevel>,\n-    ) -> Option<AccessLevel> {\n+    fn update_with_hir_id(&mut self, hir_id: hir::HirId, level: Option<Level>) -> Option<Level> {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         self.update(def_id, level)\n     }\n \n     /// Updates node level and returns the updated level.\n-    fn update(&mut self, def_id: LocalDefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+    fn update(&mut self, def_id: LocalDefId, level: Option<Level>) -> Option<Level> {\n         let old_level = self.get(def_id);\n-        // Accessibility levels can only grow.\n+        // Visibility levels can only grow.\n         if level > old_level {\n-            self.access_levels.set_access_level(\n+            self.effective_visibilities.set_public_at_level(\n                 def_id,\n                 || ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id)),\n                 level.unwrap(),\n@@ -444,10 +444,10 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        access_level: Option<AccessLevel>,\n+        level: Option<Level>,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n+            level: cmp::min(level, Some(Level::Reachable)),\n             item_def_id: def_id,\n             ev: self,\n         }\n@@ -505,9 +505,9 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update_macro_reachable_mod(&mut self, module_def_id: LocalDefId, defining_mod: LocalDefId) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n-            let def_kind = self.tcx.def_kind(item_id.def_id);\n-            let vis = self.tcx.local_visibility(item_id.def_id.def_id);\n-            self.update_macro_reachable_def(item_id.def_id.def_id, def_kind, vis, defining_mod);\n+            let def_kind = self.tcx.def_kind(item_id.owner_id);\n+            let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n+            self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_reexports(module_def_id) {\n             for export in exports {\n@@ -530,7 +530,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         vis: ty::Visibility,\n         module: LocalDefId,\n     ) {\n-        let level = Some(AccessLevel::Reachable);\n+        let level = Some(Level::Reachable);\n         if vis.is_public() {\n             self.update(def_id, level);\n         }\n@@ -627,14 +627,14 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                let impl_level = Option::<AccessLevel>::of_impl(\n-                    item.def_id.def_id,\n+                let impl_level = Option::<Level>::of_impl(\n+                    item.owner_id.def_id,\n                     self.tcx,\n-                    &self.access_levels,\n+                    &self.effective_visibilities,\n                 );\n-                self.update(item.def_id.def_id, impl_level)\n+                self.update(item.owner_id.def_id, impl_level)\n             }\n-            _ => self.get(item.def_id.def_id),\n+            _ => self.get(item.owner_id.def_id),\n         };\n \n         // Update levels of nested things.\n@@ -653,15 +653,15 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n                     if impl_.of_trait.is_some()\n-                        || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n+                        || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n                     {\n-                        self.update(impl_item_ref.id.def_id.def_id, item_level);\n+                        self.update(impl_item_ref.id.owner_id.def_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.def_id.def_id, item_level);\n+                    self.update(trait_item_ref.id.owner_id.def_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n@@ -677,12 +677,12 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.update_reachability_from_macro(item.def_id.def_id, macro_def);\n+                self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    if self.tcx.visibility(foreign_item.id.def_id).is_public() {\n-                        self.update(foreign_item.id.def_id.def_id, item_level);\n+                    if self.tcx.visibility(foreign_item.id.owner_id).is_public() {\n+                        self.update(foreign_item.id.owner_id.def_id, item_level);\n                     }\n                 }\n             }\n@@ -705,7 +705,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`.\n             hir::ItemKind::Mod(..) => {}\n-            // Handled in the access level of in rustc_resolve\n+            // Handled in `rustc_resolve`.\n             hir::ItemKind::Use(..) => {}\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n@@ -718,9 +718,8 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // FIXME: This is some serious pessimization intended to workaround deficiencies\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_level =\n-                        cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                    self.reach(item.def_id.def_id, exist_level).generics().predicates().ty();\n+                    let exist_level = cmp::max(item_level, Some(Level::ReachableThroughImplTrait));\n+                    self.reach(item.owner_id.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n@@ -729,20 +728,20 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates().ty();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let tcx = self.tcx;\n-                        let mut reach = self.reach(trait_item_ref.id.def_id.def_id, item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n-                            && !tcx.impl_defaultness(trait_item_ref.id.def_id).has_value()\n+                            && !tcx.impl_defaultness(trait_item_ref.id.owner_id).has_value()\n                         {\n                             // No type to visit.\n                         } else {\n@@ -753,22 +752,22 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level)\n+                    self.reach(item.owner_id.def_id, item_level)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_level = self.get(impl_item_ref.id.def_id.def_id);\n+                        let impl_item_level = self.get(impl_item_ref.id.owner_id.def_id);\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.def_id.def_id, impl_item_level)\n+                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -780,7 +779,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n                     let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n@@ -791,23 +790,23 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.reach(item.def_id.def_id, variant_level).ty();\n+                        self.reach(item.owner_id.def_id, variant_level).ty();\n                     }\n                     if let Some(hir_id) = variant.data.ctor_hir_id() {\n                         let ctor_def_id = self.tcx.hir().local_def_id(hir_id);\n                         let ctor_level = self.get(ctor_def_id);\n                         if ctor_level.is_some() {\n-                            self.reach(item.def_id.def_id, ctor_level).ty();\n+                            self.reach(item.owner_id.def_id, ctor_level).ty();\n                         }\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_level = self.get(foreign_item.id.def_id.def_id);\n+                    let foreign_item_level = self.get(foreign_item.id.owner_id.def_id);\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.def_id.def_id, foreign_item_level)\n+                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -817,7 +816,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n                         let def_id = self.tcx.hir().local_def_id(field.hir_id);\n                         let field_level = self.get(def_id);\n@@ -830,7 +829,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     let ctor_def_id = self.tcx.hir().local_def_id(hir_id);\n                     let ctor_level = self.get(ctor_def_id);\n                     if ctor_level.is_some() {\n-                        self.reach(item.def_id.def_id, ctor_level).ty();\n+                        self.reach(item.owner_id.def_id, ctor_level).ty();\n                     }\n                 }\n             }\n@@ -901,32 +900,32 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n         if let Some(def_id) = def_id.as_local() {\n-            if let (ty::Visibility::Public, _) | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n-                (self.tcx().visibility(def_id.to_def_id()), self.access_level)\n+            if let (ty::Visibility::Public, _) | (_, Some(Level::ReachableThroughImplTrait)) =\n+                (self.tcx().visibility(def_id.to_def_id()), self.level)\n             {\n-                self.ev.update(def_id, self.access_level);\n+                self.ev.update(def_id, self.level);\n             }\n         }\n         ControlFlow::CONTINUE\n     }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-/// Visitor, used for AccessLevels table checking\n+/// Visitor, used for EffectiveVisibilities table checking\n ////////////////////////////////////////////////////////////////////////////////\n pub struct TestReachabilityVisitor<'tcx, 'a> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n+    effective_visibilities: &'a EffectiveVisibilities,\n }\n \n impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n-    fn access_level_diagnostic(&mut self, def_id: LocalDefId) {\n+    fn effective_visibility_diagnostic(&mut self, def_id: LocalDefId) {\n         if self.tcx.has_attr(def_id.to_def_id(), sym::rustc_effective_visibility) {\n-            if let Some(effective_vis) = self.access_levels.get_effective_vis(def_id) {\n-                let mut error_msg = String::new();\n-                let span = self.tcx.def_span(def_id.to_def_id());\n-                for level in AccessLevel::all_levels() {\n-                    let vis_str = match effective_vis.get(level) {\n+            let mut error_msg = String::new();\n+            let span = self.tcx.def_span(def_id.to_def_id());\n+            if let Some(effective_vis) = self.effective_visibilities.effective_vis(def_id) {\n+                for level in Level::all_levels() {\n+                    let vis_str = match effective_vis.at_level(level) {\n                         ty::Visibility::Restricted(restricted_id) => {\n                             if restricted_id.is_top_level_module() {\n                                 \"pub(crate)\".to_string()\n@@ -938,50 +937,52 @@ impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n                         }\n                         ty::Visibility::Public => \"pub\".to_string(),\n                     };\n-                    if level != AccessLevel::Public {\n+                    if level != Level::Direct {\n                         error_msg.push_str(\", \");\n                     }\n                     error_msg.push_str(&format!(\"{:?}: {}\", level, vis_str));\n                 }\n-                self.tcx.sess.emit_err(ReportEffectiveVisibility { span, descr: error_msg });\n+            } else {\n+                error_msg.push_str(\"not in the table\");\n             }\n+            self.tcx.sess.emit_err(ReportEffectiveVisibility { span, descr: error_msg });\n         }\n     }\n }\n \n impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n \n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in def.variants.iter() {\n                     let variant_id = self.tcx.hir().local_def_id(variant.id);\n-                    self.access_level_diagnostic(variant_id);\n+                    self.effective_visibility_diagnostic(variant_id);\n                     for field in variant.data.fields() {\n                         let def_id = self.tcx.hir().local_def_id(field.hir_id);\n-                        self.access_level_diagnostic(def_id);\n+                        self.effective_visibility_diagnostic(def_id);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 for field in def.fields() {\n                     let def_id = self.tcx.hir().local_def_id(field.hir_id);\n-                    self.access_level_diagnostic(def_id);\n+                    self.effective_visibility_diagnostic(def_id);\n                 }\n             }\n             _ => {}\n         }\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n     }\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n     }\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n     }\n }\n \n@@ -1052,7 +1053,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n \n     fn visit_mod(&mut self, _m: &'tcx hir::Mod<'tcx>, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n-        // for each module in `privacy_access_levels`\n+        // for each module in `effective_visibilities`\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n@@ -1064,7 +1065,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.def_id.def_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.owner_id.def_id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1177,7 +1178,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     fn visit_mod(&mut self, _m: &'tcx hir::Mod<'tcx>, _s: Span, _n: hir::HirId) {\n         // Don't visit nested modules, since we run a separate visitor walk\n-        // for each module in `privacy_access_levels`\n+        // for each module in `effective_visibilities`\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n@@ -1367,7 +1368,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.def_id.def_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.owner_id.def_id);\n         let old_maybe_typeck_results = self.maybe_typeck_results.take();\n         intravisit::walk_item(self, item);\n         self.maybe_typeck_results = old_maybe_typeck_results;\n@@ -1402,7 +1403,7 @@ impl<'tcx> DefIdVisitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n+    effective_visibilities: &'a EffectiveVisibilities,\n     in_variant: bool,\n     // Set of errors produced by this obsolete visitor.\n     old_error_set: HirIdSet,\n@@ -1445,7 +1446,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn trait_is_public(&self, trait_id: LocalDefId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n         // traits are exported currently (see `EmbargoVisitor.exported_trait`).\n-        self.access_levels.is_public(trait_id)\n+        self.effective_visibilities.is_directly_public(trait_id)\n     }\n \n     fn check_generic_bound(&mut self, bound: &hir::GenericBound<'_>) {\n@@ -1457,7 +1458,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn item_is_public(&self, def_id: LocalDefId) -> bool {\n-        self.access_levels.is_reachable(def_id) || self.tcx.visibility(def_id).is_public()\n+        self.effective_visibilities.is_reachable(def_id) || self.tcx.visibility(def_id).is_public()\n     }\n }\n \n@@ -1511,7 +1512,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { .. } => {}\n \n             hir::ItemKind::Trait(.., bounds, _) => {\n-                if !self.trait_is_public(item.def_id.def_id) {\n+                if !self.trait_is_public(item.owner_id.def_id) {\n                     return;\n                 }\n \n@@ -1571,9 +1572,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     || impl_.items.iter().any(|impl_item_ref| {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n-                            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n-                                self.access_levels.is_reachable(impl_item_ref.id.def_id.def_id)\n-                            }\n+                            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => self\n+                                .effective_visibilities\n+                                .is_reachable(impl_item_ref.id.owner_id.def_id),\n                             hir::ImplItemKind::Type(_) => false,\n                         }\n                     });\n@@ -1592,7 +1593,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.kind {\n                                     hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..)\n-                                        if self.item_is_public(impl_item.def_id.def_id) =>\n+                                        if self.item_is_public(impl_item.owner_id.def_id) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1633,8 +1634,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n-                        if self.access_levels.is_reachable(impl_item_ref.id.def_id.def_id)\n-                            || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n+                        if self\n+                            .effective_visibilities\n+                            .is_reachable(impl_item_ref.id.owner_id.def_id)\n+                            || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n                         {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n@@ -1662,7 +1665,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::TyAlias(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(item.def_id.def_id) => {\n+            _ if !self.item_is_public(item.owner_id.def_id) => {\n                 return;\n             }\n \n@@ -1693,7 +1696,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        if self.access_levels.is_reachable(item.def_id.def_id) {\n+        if self.effective_visibilities.is_reachable(item.owner_id.def_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1708,7 +1711,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n-        if self.access_levels.is_reachable(self.tcx.hir().local_def_id(v.id)) {\n+        if self.effective_visibilities.is_reachable(self.tcx.hir().local_def_id(v.id)) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v);\n             self.in_variant = false;\n@@ -1930,7 +1933,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n \n     pub fn check_item(&mut self, id: ItemId) {\n         let tcx = self.tcx;\n-        let def_id = id.def_id.def_id;\n+        let def_id = id.owner_id.def_id;\n         let item_visibility = tcx.local_visibility(def_id);\n         let def_kind = tcx.def_kind(def_id);\n \n@@ -1946,17 +1949,17 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             DefKind::Trait => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Trait(.., trait_item_refs) = item.kind {\n-                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n+                    self.check(item.owner_id.def_id, item_visibility).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         self.check_assoc_item(\n-                            trait_item_ref.id.def_id.def_id,\n+                            trait_item_ref.id.owner_id.def_id,\n                             trait_item_ref.kind,\n                             item_visibility,\n                         );\n \n                         if let AssocItemKind::Type = trait_item_ref.kind {\n-                            self.check(trait_item_ref.id.def_id.def_id, item_visibility).bounds();\n+                            self.check(trait_item_ref.id.owner_id.def_id, item_visibility).bounds();\n                         }\n                     }\n                 }\n@@ -1967,7 +1970,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             DefKind::Enum => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Enum(ref def, _) = item.kind {\n-                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n+                    self.check(item.owner_id.def_id, item_visibility).generics().predicates();\n \n                     for variant in def.variants {\n                         for field in variant.data.fields() {\n@@ -1982,8 +1985,11 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n                     for foreign_item in items {\n-                        let vis = tcx.local_visibility(foreign_item.id.def_id.def_id);\n-                        self.check(foreign_item.id.def_id.def_id, vis).generics().predicates().ty();\n+                        let vis = tcx.local_visibility(foreign_item.id.owner_id.def_id);\n+                        self.check(foreign_item.id.owner_id.def_id, vis)\n+                            .generics()\n+                            .predicates()\n+                            .ty();\n                     }\n                 }\n             }\n@@ -1993,7 +1999,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 if let hir::ItemKind::Struct(ref struct_def, _)\n                 | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                 {\n-                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n+                    self.check(item.owner_id.def_id, item_visibility).generics().predicates();\n \n                     for field in struct_def.fields() {\n                         let def_id = tcx.hir().local_def_id(field.hir_id);\n@@ -2010,20 +2016,24 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Impl(ref impl_) = item.kind {\n                     let impl_vis =\n-                        ty::Visibility::of_impl(item.def_id.def_id, tcx, &Default::default());\n+                        ty::Visibility::of_impl(item.owner_id.def_id, tcx, &Default::default());\n                     // check that private components do not appear in the generics or predicates of inherent impls\n                     // this check is intentionally NOT performed for impls of traits, per #90586\n                     if impl_.of_trait.is_none() {\n-                        self.check(item.def_id.def_id, impl_vis).generics().predicates();\n+                        self.check(item.owner_id.def_id, impl_vis).generics().predicates();\n                     }\n                     for impl_item_ref in impl_.items {\n                         let impl_item_vis = if impl_.of_trait.is_none() {\n-                            min(tcx.local_visibility(impl_item_ref.id.def_id.def_id), impl_vis, tcx)\n+                            min(\n+                                tcx.local_visibility(impl_item_ref.id.owner_id.def_id),\n+                                impl_vis,\n+                                tcx,\n+                            )\n                         } else {\n                             impl_vis\n                         };\n                         self.check_assoc_item(\n-                            impl_item_ref.id.def_id.def_id,\n+                            impl_item_ref.id.owner_id.def_id,\n                             impl_item_ref.kind,\n                             impl_item_vis,\n                         );\n@@ -2038,7 +2048,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         visibility,\n-        privacy_access_levels,\n+        effective_visibilities,\n         check_private_in_public,\n         check_mod_privacy,\n         ..*providers\n@@ -2110,14 +2120,14 @@ fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n \n-fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n+fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n         tcx,\n-        access_levels: tcx.resolutions(()).access_levels.clone(),\n+        effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n-        prev_level: Some(AccessLevel::Public),\n+        prev_level: Some(Level::Direct),\n         changed: false,\n     };\n \n@@ -2130,18 +2140,19 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n         }\n     }\n \n-    let mut check_visitor = TestReachabilityVisitor { tcx, access_levels: &visitor.access_levels };\n+    let mut check_visitor =\n+        TestReachabilityVisitor { tcx, effective_visibilities: &visitor.effective_visibilities };\n     tcx.hir().visit_all_item_likes_in_crate(&mut check_visitor);\n \n-    tcx.arena.alloc(visitor.access_levels)\n+    tcx.arena.alloc(visitor.effective_visibilities)\n }\n \n fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n-    let access_levels = tcx.privacy_access_levels(());\n+    let effective_visibilities = tcx.effective_visibilities(());\n \n     let mut visitor = ObsoleteVisiblePrivateTypesVisitor {\n         tcx,\n-        access_levels,\n+        effective_visibilities,\n         in_variant: false,\n         old_error_set: Default::default(),\n     };"}, {"sha": "8b14ce210a20512a9247d76cd001d1bc05b4f95f", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,8 +1,9 @@\n use crate::QueryCtxt;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, RwLock};\n use rustc_data_structures::unhash::UnhashMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -792,7 +793,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashSet<LocalDefId> {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx UnordSet<LocalDefId> {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }"}, {"sha": "c40669ac95bee19193deb48ab4bcfb8012a51ca0", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "renamed", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -6,55 +6,54 @@ use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_middle::middle::privacy::AccessLevel;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::ty::{DefIdTree, Visibility};\n \n-pub struct AccessLevelsVisitor<'r, 'a> {\n+pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n     changed: bool,\n }\n \n-impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n-    /// Fills the `Resolver::access_levels` table with public & exported items\n+impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n+    /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n-    pub fn compute_access_levels<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n-        let mut visitor = AccessLevelsVisitor { r, changed: false };\n+    pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n+        let mut visitor = EffectiveVisibilitiesVisitor { r, changed: false };\n \n-        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, AccessLevel::Public);\n-        visitor.set_bindings_access_level(CRATE_DEF_ID);\n+        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, Level::Direct);\n+        visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n             visitor.reset();\n             visit::walk_crate(&mut visitor, krate);\n         }\n \n-        info!(\"resolve::access_levels: {:#?}\", r.access_levels);\n+        info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n     fn reset(&mut self) {\n         self.changed = false;\n     }\n \n-    /// Update the access level of the bindings in the given module accordingly. The module access\n-    /// level has to be Exported or Public.\n-    /// This will also follow `use` chains (see PrivacyVisitor::set_import_binding_access_level).\n-    fn set_bindings_access_level(&mut self, module_id: LocalDefId) {\n+    /// Update effective visibilities of bindings in the given module,\n+    /// including their whole reexport chains.\n+    fn set_bindings_effective_visibilities(&mut self, module_id: LocalDefId) {\n         assert!(self.r.module_map.contains_key(&&module_id.to_def_id()));\n         let module = self.r.get_module(module_id.to_def_id()).unwrap();\n         let resolutions = self.r.resolutions(module);\n \n         for (_, name_resolution) in resolutions.borrow().iter() {\n             if let Some(mut binding) = name_resolution.borrow().binding() && !binding.is_ambiguity() {\n-                // Set the given binding access level to `AccessLevel::Public` and\n-                // sets the rest of the `use` chain to `AccessLevel::Exported` until\n+                // Set the given effective visibility level to `Level::Direct` and\n+                // sets the rest of the `use` chain to `Level::Reexported` until\n                 // we hit the actual exported item.\n \n                 // FIXME: tag and is_public() condition should be removed, but assertions occur.\n-                let tag = if binding.is_import() { AccessLevel::Exported } else { AccessLevel::Public };\n+                let tag = if binding.is_import() { Level::Reexported } else { Level::Direct };\n                 if binding.vis.is_public() {\n                     let mut prev_parent_id = module_id;\n-                    let mut level = AccessLevel::Public;\n+                    let mut level = Level::Direct;\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n@@ -76,7 +75,7 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n                             update(additional_ids.1);\n                         }\n \n-                        level = AccessLevel::Exported;\n+                        level = Level::Reexported;\n                         prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n@@ -94,35 +93,35 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n         def_id: LocalDefId,\n         nominal_vis: Visibility,\n         parent_id: LocalDefId,\n-        tag: AccessLevel,\n+        tag: Level,\n     ) {\n-        let mut access_levels = std::mem::take(&mut self.r.access_levels);\n-        let module_id =\n-            self.r.get_nearest_non_block_module(def_id.to_def_id()).def_id().expect_local();\n-        let res = access_levels.update(\n+        let module_id = self\n+            .r\n+            .get_nearest_non_block_module(def_id.to_def_id())\n+            .nearest_parent_mod()\n+            .expect_local();\n+        if nominal_vis == Visibility::Restricted(module_id)\n+            || self.r.visibilities[&parent_id] == Visibility::Restricted(module_id)\n+        {\n+            return;\n+        }\n+        let mut effective_visibilities = std::mem::take(&mut self.r.effective_visibilities);\n+        self.changed |= effective_visibilities.update(\n             def_id,\n             nominal_vis,\n             || Visibility::Restricted(module_id),\n             parent_id,\n             tag,\n             &*self.r,\n         );\n-        if let Ok(changed) = res {\n-            self.changed |= changed;\n-        } else {\n-            self.r.session.delay_span_bug(\n-                self.r.opt_span(def_id.to_def_id()).unwrap(),\n-                \"Can't update effective visibility\",\n-            );\n-        }\n-        self.r.access_levels = access_levels;\n+        self.r.effective_visibilities = effective_visibilities;\n     }\n }\n \n-impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n+impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n     fn visit_item(&mut self, item: &'ast ast::Item) {\n         let def_id = self.r.local_def_id(item.id);\n-        // Set access level of nested items.\n+        // Update effective visibilities of nested items.\n         // If it's a mod, also make the visitor walk all of its items\n         match item.kind {\n             // Resolved in rustc_privacy when types are available\n@@ -136,29 +135,29 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n             // Foreign modules inherit level from parents.\n             ast::ItemKind::ForeignMod(..) => {\n                 let parent_id = self.r.local_parent(def_id);\n-                self.update(def_id, Visibility::Public, parent_id, AccessLevel::Public);\n+                self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n             }\n \n             // Only exported `macro_rules!` items are public, but they always are\n             ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n                 let parent_id = self.r.local_parent(def_id);\n                 let vis = self.r.visibilities[&def_id];\n-                self.update(def_id, vis, parent_id, AccessLevel::Public);\n+                self.update(def_id, vis, parent_id, Level::Direct);\n             }\n \n             ast::ItemKind::Mod(..) => {\n-                self.set_bindings_access_level(def_id);\n+                self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);\n             }\n \n             ast::ItemKind::Enum(EnumDef { ref variants }, _) => {\n-                self.set_bindings_access_level(def_id);\n+                self.set_bindings_effective_visibilities(def_id);\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n                     for field in variant.data.fields() {\n                         let field_def_id = self.r.local_def_id(field.id);\n                         let vis = self.r.visibilities[&field_def_id];\n-                        self.update(field_def_id, vis, variant_def_id, AccessLevel::Public);\n+                        self.update(field_def_id, vis, variant_def_id, Level::Direct);\n                     }\n                 }\n             }\n@@ -167,12 +166,12 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n                 for field in def.fields() {\n                     let field_def_id = self.r.local_def_id(field.id);\n                     let vis = self.r.visibilities[&field_def_id];\n-                    self.update(field_def_id, vis, def_id, AccessLevel::Public);\n+                    self.update(field_def_id, vis, def_id, Level::Direct);\n                 }\n             }\n \n             ast::ItemKind::Trait(..) => {\n-                self.set_bindings_access_level(def_id);\n+                self.set_bindings_effective_visibilities(def_id);\n             }\n \n             ast::ItemKind::ExternCrate(..)", "previous_filename": "compiler/rustc_resolve/src/access_levels.rs"}, {"sha": "00eb768ad18d4f79dbd914cb09cf12051adf9a3f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -30,6 +30,7 @@ use rustc_span::{BytePos, Span};\n use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n+use std::assert_matches::debug_assert_matches;\n use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, take};\n \n@@ -568,7 +569,7 @@ struct LateResolutionVisitor<'a, 'b, 'ast> {\n     /// They will be used to determine the correct lifetime for the fn return type.\n     /// The `LifetimeElisionCandidate` is used for diagnostics, to suggest introducing named\n     /// lifetimes.\n-    lifetime_elision_candidates: Option<FxIndexMap<LifetimeRes, LifetimeElisionCandidate>>,\n+    lifetime_elision_candidates: Option<Vec<(LifetimeRes, LifetimeElisionCandidate)>>,\n \n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n@@ -1802,7 +1803,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         match res {\n             LifetimeRes::Param { .. } | LifetimeRes::Fresh { .. } | LifetimeRes::Static => {\n                 if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n-                    candidates.insert(res, candidate);\n+                    candidates.push((res, candidate));\n                 }\n             }\n             LifetimeRes::Infer | LifetimeRes::Error | LifetimeRes::ElidedAnchor { .. } => {}\n@@ -1855,12 +1856,25 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         has_self: bool,\n         inputs: impl Iterator<Item = (Option<&'ast Pat>, &'ast Ty)>,\n     ) -> Result<LifetimeRes, (Vec<MissingLifetime>, Vec<ElisionFnParameter>)> {\n-        let outer_candidates =\n-            replace(&mut self.lifetime_elision_candidates, Some(Default::default()));\n+        enum Elision {\n+            /// We have not found any candidate.\n+            None,\n+            /// We have a candidate bound to `self`.\n+            Self_(LifetimeRes),\n+            /// We have a candidate bound to a parameter.\n+            Param(LifetimeRes),\n+            /// We failed elision.\n+            Err,\n+        }\n \n-        let mut elision_lifetime = None;\n-        let mut lifetime_count = 0;\n+        // Save elision state to reinstate it later.\n+        let outer_candidates = self.lifetime_elision_candidates.take();\n+\n+        // Result of elision.\n+        let mut elision_lifetime = Elision::None;\n+        // Information for diagnostics.\n         let mut parameter_info = Vec::new();\n+        let mut all_candidates = Vec::new();\n \n         let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n         for (index, (pat, ty)) in inputs.enumerate() {\n@@ -1870,61 +1884,82 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     this.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n                 }\n             });\n+\n+            // Record elision candidates only for this parameter.\n+            debug_assert_matches!(self.lifetime_elision_candidates, None);\n+            self.lifetime_elision_candidates = Some(Default::default());\n             self.visit_ty(ty);\n+            let local_candidates = self.lifetime_elision_candidates.take();\n \n-            if let Some(ref candidates) = self.lifetime_elision_candidates {\n-                let new_count = candidates.len();\n-                let local_count = new_count - lifetime_count;\n-                if local_count != 0 {\n+            if let Some(candidates) = local_candidates {\n+                let distinct: FxHashSet<_> = candidates.iter().map(|(res, _)| *res).collect();\n+                let lifetime_count = distinct.len();\n+                if lifetime_count != 0 {\n                     parameter_info.push(ElisionFnParameter {\n                         index,\n                         ident: if let Some(pat) = pat && let PatKind::Ident(_, ident, _) = pat.kind {\n                             Some(ident)\n                         } else {\n                             None\n                         },\n-                        lifetime_count: local_count,\n+                        lifetime_count,\n                         span: ty.span,\n                     });\n+                    all_candidates.extend(candidates.into_iter().filter_map(|(_, candidate)| {\n+                        match candidate {\n+                            LifetimeElisionCandidate::Ignore | LifetimeElisionCandidate::Named => {\n+                                None\n+                            }\n+                            LifetimeElisionCandidate::Missing(missing) => Some(missing),\n+                        }\n+                    }));\n+                }\n+                let mut distinct_iter = distinct.into_iter();\n+                if let Some(res) = distinct_iter.next() {\n+                    match elision_lifetime {\n+                        // We are the first parameter to bind lifetimes.\n+                        Elision::None => {\n+                            if distinct_iter.next().is_none() {\n+                                // We have a single lifetime => success.\n+                                elision_lifetime = Elision::Param(res)\n+                            } else {\n+                                // We have have multiple lifetimes => error.\n+                                elision_lifetime = Elision::Err;\n+                            }\n+                        }\n+                        // We have 2 parameters that bind lifetimes => error.\n+                        Elision::Param(_) => elision_lifetime = Elision::Err,\n+                        // `self` elision takes precedence over everything else.\n+                        Elision::Self_(_) | Elision::Err => {}\n+                    }\n                 }\n-                lifetime_count = new_count;\n             }\n \n             // Handle `self` specially.\n             if index == 0 && has_self {\n                 let self_lifetime = self.find_lifetime_for_self(ty);\n                 if let Set1::One(lifetime) = self_lifetime {\n-                    elision_lifetime = Some(lifetime);\n-                    self.lifetime_elision_candidates = None;\n+                    // We found `self` elision.\n+                    elision_lifetime = Elision::Self_(lifetime);\n                 } else {\n-                    self.lifetime_elision_candidates = Some(Default::default());\n-                    lifetime_count = 0;\n+                    // We do not have `self` elision: disregard the `Elision::Param` that we may\n+                    // have found.\n+                    elision_lifetime = Elision::None;\n                 }\n             }\n             debug!(\"(resolving function / closure) recorded parameter\");\n         }\n \n-        let all_candidates = replace(&mut self.lifetime_elision_candidates, outer_candidates);\n-        debug!(?all_candidates);\n+        // Reinstate elision state.\n+        debug_assert_matches!(self.lifetime_elision_candidates, None);\n+        self.lifetime_elision_candidates = outer_candidates;\n \n-        if let Some(res) = elision_lifetime {\n+        if let Elision::Param(res) | Elision::Self_(res) = elision_lifetime {\n             return Ok(res);\n         }\n \n-        // We do not have a `self` candidate, look at the full list.\n-        let all_candidates = all_candidates.unwrap();\n-        if all_candidates.len() == 1 {\n-            Ok(*all_candidates.first().unwrap().0)\n-        } else {\n-            let all_candidates = all_candidates\n-                .into_iter()\n-                .filter_map(|(_, candidate)| match candidate {\n-                    LifetimeElisionCandidate::Ignore | LifetimeElisionCandidate::Named => None,\n-                    LifetimeElisionCandidate::Missing(missing) => Some(missing),\n-                })\n-                .collect();\n-            Err((all_candidates, parameter_info))\n-        }\n+        // We do not have a candidate.\n+        Err((all_candidates, parameter_info))\n     }\n \n     /// List all the lifetimes that appear in the provided type.\n@@ -2394,7 +2429,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // Do not account for the parameters we just bound for function lifetime elision.\n         if let Some(ref mut candidates) = self.lifetime_elision_candidates {\n             for (_, res) in function_lifetime_rib.bindings.values() {\n-                candidates.remove(res);\n+                candidates.retain(|(r, _)| r != res);\n             }\n         }\n "}, {"sha": "7d5fe32ee2864a916cebf65a4557d49a0c7e4858", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -784,10 +784,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             return false;\n         }\n         err.code(rustc_errors::error_code!(E0411));\n-        err.span_label(\n-            span,\n-            \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n-        );\n+        err.span_label(span, \"`Self` is only available in impls, traits, and type definitions\");\n         if let Some(item_kind) = self.diagnostic_metadata.current_item {\n             err.span_label(\n                 item_kind.ident.span,"}, {"sha": "11b70a38da58d18abc8cbce6bb71fc1a5bafa7d2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -7,6 +7,7 @@\n //! Type-relative name resolution (methods, fields, associated items) happens in `rustc_hir_analysis`.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(if_let_guard)]\n@@ -40,11 +41,12 @@ use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::span_bug;\n-use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n+use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools};\n+use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, CrateStoreDyn, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n@@ -62,15 +64,15 @@ use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, PatternSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n-use crate::access_levels::AccessLevelsVisitor;\n+use crate::effective_visibilities::EffectiveVisibilitiesVisitor;\n \n type Res = def::Res<NodeId>;\n \n-mod access_levels;\n mod build_reduced_graph;\n mod check_unused;\n mod def_collector;\n mod diagnostics;\n+mod effective_visibilities;\n mod ident;\n mod imports;\n mod late;\n@@ -1029,7 +1031,7 @@ pub struct Resolver<'a> {\n     proc_macros: Vec<NodeId>,\n     confused_type_with_std_module: FxHashMap<Span, Span>,\n \n-    access_levels: AccessLevels,\n+    effective_visibilities: EffectiveVisibilities,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1333,7 +1335,7 @@ impl<'a> Resolver<'a> {\n             trait_impls: Default::default(),\n             proc_macros: Default::default(),\n             confused_type_with_std_module: Default::default(),\n-            access_levels: Default::default(),\n+            effective_visibilities: Default::default(),\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n@@ -1376,9 +1378,7 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n-    pub fn into_outputs(\n-        self,\n-    ) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs, ty::ResolverAstLowering) {\n+    pub fn into_outputs(self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions;\n         let cstore = Box::new(self.crate_loader.into_cstore());\n@@ -1393,13 +1393,14 @@ impl<'a> Resolver<'a> {\n         let glob_map = self.glob_map;\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n-        let access_levels = self.access_levels;\n-        let resolutions = ResolverOutputs {\n+        let effective_visibilities = self.effective_visibilities;\n+        let global_ctxt = ResolverGlobalCtxt {\n+            cstore,\n             source_span,\n             expn_that_defined,\n             visibilities,\n             has_pub_restricted,\n-            access_levels,\n+            effective_visibilities,\n             extern_crate_map,\n             reexport_map,\n             glob_map,\n@@ -1416,7 +1417,7 @@ impl<'a> Resolver<'a> {\n             confused_type_with_std_module,\n             registered_tools: self.registered_tools,\n         };\n-        let resolutions_lowering = ty::ResolverAstLowering {\n+        let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args,\n             partial_res_map: self.partial_res_map,\n             import_res_map: self.import_res_map,\n@@ -1429,16 +1430,15 @@ impl<'a> Resolver<'a> {\n             trait_map: self.trait_map,\n             builtin_macro_kinds: self.builtin_macro_kinds,\n         };\n-        (definitions, cstore, resolutions, resolutions_lowering)\n+        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n     }\n \n-    pub fn clone_outputs(\n-        &self,\n-    ) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs, ty::ResolverAstLowering) {\n+    pub fn clone_outputs(&self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions.clone();\n         let cstore = Box::new(self.cstore().clone());\n-        let resolutions = ResolverOutputs {\n+        let global_ctxt = ResolverGlobalCtxt {\n+            cstore,\n             source_span: self.source_span.clone(),\n             expn_that_defined: self.expn_that_defined.clone(),\n             visibilities: self.visibilities.clone(),\n@@ -1458,9 +1458,9 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n             registered_tools: self.registered_tools.clone(),\n-            access_levels: self.access_levels.clone(),\n+            effective_visibilities: self.effective_visibilities.clone(),\n         };\n-        let resolutions_lowering = ty::ResolverAstLowering {\n+        let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args.clone(),\n             partial_res_map: self.partial_res_map.clone(),\n             import_res_map: self.import_res_map.clone(),\n@@ -1473,7 +1473,7 @@ impl<'a> Resolver<'a> {\n             trait_map: self.trait_map.clone(),\n             builtin_macro_kinds: self.builtin_macro_kinds.clone(),\n         };\n-        (definitions, cstore, resolutions, resolutions_lowering)\n+        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n@@ -1521,8 +1521,8 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.session.time(\"resolve_crate\", || {\n             self.session.time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n-            self.session.time(\"resolve_access_levels\", || {\n-                AccessLevelsVisitor::compute_access_levels(self, krate)\n+            self.session.time(\"compute_effective_visibilities\", || {\n+                EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });\n             self.session.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n             self.session.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));"}, {"sha": "df5d992f66330efefe3bcbee717a4e972070c069", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -57,7 +57,7 @@ macro_rules! access_from {\n     ($save_ctxt:expr, $id:expr) => {\n         Access {\n             public: $save_ctxt.tcx.visibility($id).is_public(),\n-            reachable: $save_ctxt.access_levels.is_reachable($id),\n+            reachable: $save_ctxt.effective_visibilities.is_reachable($id),\n         }\n     };\n }\n@@ -345,14 +345,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         body: hir::BodyId,\n     ) {\n         let map = self.tcx.hir();\n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(body.params, &fn_data.qualname);\n                 v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id.def_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -373,10 +373,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) {\n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id.def_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -436,7 +436,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n \n         let kind = match item.kind {\n             hir::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -473,10 +473,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(item.ident.span);\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.def_id.def_id),\n+                &access_from!(self.save_ctxt, item.owner_id.def_id),\n                 Def {\n                     kind,\n-                    id: id_from_def_id(item.def_id.to_def_id()),\n+                    id: id_from_def_id(item.owner_id.to_def_id()),\n                     span,\n                     name,\n                     qualname: qualname.clone(),\n@@ -491,7 +491,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             );\n         }\n \n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             for field in def.fields() {\n                 v.process_struct_field_def(field, item.hir_id());\n                 v.visit_ty(&field.ty);\n@@ -513,7 +513,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -528,7 +528,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n+                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n                         let attrs = self.tcx.hir().attrs(variant.id);\n \n                         self.dumper.dump_def(\n@@ -566,7 +566,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n+                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n                         let attrs = self.tcx.hir().attrs(variant.id);\n \n                         self.dumper.dump_def(\n@@ -612,14 +612,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         let map = self.tcx.hir();\n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             v.visit_ty(&impl_.self_ty);\n             if let Some(trait_ref) = &impl_.of_trait {\n                 v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n             }\n             v.process_generic_params(&impl_.generics, \"\", item.hir_id());\n             for impl_item in impl_.items {\n-                v.process_impl_item(map.impl_item(impl_item.id), item.def_id.to_def_id());\n+                v.process_impl_item(map.impl_item(impl_item.id), item.owner_id.to_def_id());\n             }\n         });\n     }\n@@ -632,7 +632,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         methods: &'tcx [hir::TraitItemRef],\n     ) {\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n             val.push_str(&generic_params_to_string(generics.params));\n@@ -642,13 +642,13 @@ impl<'tcx> DumpVisitor<'tcx> {\n             val.push_str(&bounds_to_string(trait_refs));\n         }\n         if !self.span.filter_generated(item.ident.span) {\n-            let id = id_from_def_id(item.def_id.to_def_id());\n+            let id = id_from_def_id(item.owner_id.to_def_id());\n             let span = self.span_from_span(item.ident.span);\n             let children =\n-                methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n+                methods.iter().map(|i| id_from_def_id(i.id.owner_id.to_def_id())).collect();\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.def_id.def_id),\n+                &access_from!(self.save_ctxt, item.owner_id.def_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -692,7 +692,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                         kind: RelationKind::SuperTrait,\n                         span,\n                         from: id_from_def_id(id),\n-                        to: id_from_def_id(item.def_id.to_def_id()),\n+                        to: id_from_def_id(item.owner_id.to_def_id()),\n                     });\n                 }\n             }\n@@ -702,15 +702,15 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.process_generic_params(generics, &qualname, item.hir_id());\n         for method in methods {\n             let map = self.tcx.hir();\n-            self.process_trait_item(map.trait_item(method.id), item.def_id.to_def_id())\n+            self.process_trait_item(map.trait_item(method.id), item.owner_id.to_def_id())\n         }\n     }\n \n     // `item` is the module in question, represented as an( item.\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item.def_id.def_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item.owner_id.def_id), mod_data);\n         }\n     }\n \n@@ -981,7 +981,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = body.map(|b| self.tcx.hir().body(b).value);\n                 let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n                 self.process_assoc_const(\n-                    trait_item.def_id.def_id,\n+                    trait_item.owner_id.def_id,\n                     trait_item.ident,\n                     &ty,\n                     body,\n@@ -995,7 +995,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     body,\n-                    trait_item.def_id.def_id,\n+                    trait_item.owner_id.def_id,\n                     trait_item.ident,\n                     &trait_item.generics,\n                     trait_item.span,\n@@ -1005,11 +1005,11 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname =\n-                    format!(\"::{}\", self.tcx.def_path_str(trait_item.def_id.to_def_id()));\n+                    format!(\"::{}\", self.tcx.def_path_str(trait_item.owner_id.to_def_id()));\n \n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n-                    let id = id_from_def_id(trait_item.def_id.to_def_id());\n+                    let id = id_from_def_id(trait_item.owner_id.to_def_id());\n                     let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n \n                     self.dumper.dump_def(\n@@ -1051,7 +1051,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = self.tcx.hir().body(body);\n                 let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n                 self.process_assoc_const(\n-                    impl_item.def_id.def_id,\n+                    impl_item.owner_id.def_id,\n                     impl_item.ident,\n                     &ty,\n                     Some(&body.value),\n@@ -1063,7 +1063,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     Some(body),\n-                    impl_item.def_id.def_id,\n+                    impl_item.owner_id.def_id,\n                     impl_item.ident,\n                     &impl_item.generics,\n                     impl_item.span,\n@@ -1088,7 +1088,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         let filename = sm.span_to_filename(krate_mod.spans.inner_span);\n         let data_id = id_from_hir_id(id, &self.save_ctxt);\n         let children =\n-            krate_mod.item_ids.iter().map(|i| id_from_def_id(i.def_id.to_def_id())).collect();\n+            krate_mod.item_ids.iter().map(|i| id_from_def_id(i.owner_id.to_def_id())).collect();\n         let span = self.span_from_span(krate_mod.spans.inner_span);\n         let attrs = self.tcx.hir().attrs(id);\n \n@@ -1137,10 +1137,10 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+                    let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n                     let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n+                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n                     self.dumper.import(\n                         &access,\n                         Import {\n@@ -1158,16 +1158,16 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n                 // Make a comma-separated list of names of imported modules.\n-                let names = self.tcx.names_imported_by_glob_use(item.def_id.def_id);\n+                let names = self.tcx.names_imported_by_glob_use(item.owner_id.def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+                        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n                         let span = self.span_from_span(sub_span);\n-                        let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n+                        let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n                         self.dumper.import(\n                             &access,\n                             Import {\n@@ -1188,7 +1188,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n+                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n                     self.dumper.import(\n                         &Access { public: false, reachable: false },\n                         Import {\n@@ -1228,15 +1228,15 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 intravisit::walk_mod(self, m, item.hir_id());\n             }\n             hir::ItemKind::TyAlias(ty, ref generics) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n                 let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n-                    let id = id_from_def_id(item.def_id.to_def_id());\n+                    let id = id_from_def_id(item.owner_id.to_def_id());\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item.def_id.def_id),\n+                        &access_from!(self.save_ctxt, item.owner_id.def_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1324,7 +1324,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::TyKind::OpaqueDef(item_id, _, _) => {\n                 let item = self.tcx.hir().item(item_id);\n-                self.nest_typeck_results(item_id.def_id.def_id, |v| v.visit_item(item));\n+                self.nest_typeck_results(item_id.owner_id.def_id, |v| v.visit_item(item));\n             }\n             _ => intravisit::walk_ty(self, t),\n         }\n@@ -1431,7 +1431,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n \n         match item.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {"}, {"sha": "d0155c908a2b85893924a8e662a504579035e5af", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -26,7 +26,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Node;\n use rustc_hir_pretty::{enum_def_to_string, fn_to_string, ty_to_string};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::ty::{self, print::with_no_trimmed_paths, DefIdTree, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, Input, OutputType};\n@@ -54,7 +54,7 @@ use rls_data::{\n pub struct SaveContext<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    access_levels: &'tcx AccessLevels,\n+    effective_visibilities: &'tcx EffectiveVisibilities,\n     span_utils: SpanUtils<'tcx>,\n     config: Config,\n     impl_counter: Cell<u32>,\n@@ -141,7 +141,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_extern_item_data(&self, item: &hir::ForeignItem<'_>) -> Option<Data> {\n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n         let attrs = self.tcx.hir().attrs(item.hir_id());\n         match item.kind {\n@@ -205,7 +205,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let attrs = self.tcx.hir().attrs(item.hir_id());\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n@@ -297,7 +297,7 @@ impl<'tcx> SaveContext<'tcx> {\n                     children: m\n                         .item_ids\n                         .iter()\n-                        .map(|i| id_from_def_id(i.def_id.to_def_id()))\n+                        .map(|i| id_from_def_id(i.owner_id.to_def_id()))\n                         .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(attrs),\n@@ -363,7 +363,7 @@ impl<'tcx> SaveContext<'tcx> {\n                             parent: None,\n                             children: items\n                                 .iter()\n-                                .map(|i| id_from_def_id(i.id.def_id.to_def_id()))\n+                                .map(|i| id_from_def_id(i.id.owner_id.to_def_id()))\n                                 .collect(),\n                             docs: String::new(),\n                             sig: None,\n@@ -968,16 +968,16 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n             info!(\"Dumping crate {}\", cratename);\n \n             // Privacy checking must be done outside of type inference; use a\n-            // fallback in case the access levels couldn't have been correctly computed.\n-            let access_levels = match tcx.sess.compile_status() {\n-                Ok(..) => tcx.privacy_access_levels(()),\n-                Err(..) => tcx.arena.alloc(AccessLevels::default()),\n+            // fallback in case effective visibilities couldn't have been correctly computed.\n+            let effective_visibilities = match tcx.sess.compile_status() {\n+                Ok(..) => tcx.effective_visibilities(()),\n+                Err(..) => tcx.arena.alloc(EffectiveVisibilities::default()),\n             };\n \n             let save_ctxt = SaveContext {\n                 tcx,\n                 maybe_typeck_results: None,\n-                access_levels: &access_levels,\n+                effective_visibilities: &effective_visibilities,\n                 span_utils: SpanUtils::new(&tcx.sess),\n                 config: find_config(config),\n                 impl_counter: Cell::new(0),"}, {"sha": "83c51d213be35ed38ea2e1a5c175ab61db094df1", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -337,7 +337,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -359,7 +359,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"const \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -428,7 +428,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"mod \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -764,7 +764,7 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -780,7 +780,7 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n                 let mut text = \"type \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];"}, {"sha": "322c7104be425966930a74ff37dfb7d0219b14b5", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -558,7 +558,7 @@ impl Span {\n         self.data_untracked().is_dummy()\n     }\n \n-    /// Returns `true` if this span comes from a macro or desugaring.\n+    /// Returns `true` if this span comes from any kind of macro, desugaring or inlining.\n     #[inline]\n     pub fn from_expansion(self) -> bool {\n         self.ctxt() != SyntaxContext::root()\n@@ -571,6 +571,12 @@ impl Span {\n         matches!(outer_expn.kind, ExpnKind::Macro(..)) && outer_expn.collapse_debuginfo\n     }\n \n+    /// Returns `true` if this span comes from MIR inlining.\n+    pub fn is_inlined(self) -> bool {\n+        let outer_expn = self.ctxt().outer_expn_data();\n+        matches!(outer_expn.kind, ExpnKind::Inlined)\n+    }\n+\n     /// Returns `true` if `span` originates in a derive-macro's expansion.\n     pub fn in_derive_expansion(self) -> bool {\n         matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))"}, {"sha": "7f16da52b4439d587fb3e0659400e4cecc056a0d", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1901,6 +1901,13 @@ impl fmt::Display for Symbol {\n     }\n }\n \n+// takes advantage of `str::to_string` specialization\n+impl ToString for Symbol {\n+    fn to_string(&self) -> String {\n+        self.as_str().to_string()\n+    }\n+}\n+\n impl<S: Encoder> Encodable<S> for Symbol {\n     default fn encode(&self, s: &mut S) {\n         s.emit_str(self.as_str());"}, {"sha": "150459ce0f53181898bbdf09d1f793abbc0a5762", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -26,19 +26,19 @@ pub fn report_symbol_names(tcx: TyCtxt<'_>) {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n \n         for id in crate_items.trait_items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n \n         for id in crate_items.impl_items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n \n         for id in crate_items.foreign_items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n     })\n }"}, {"sha": "a335f8e06bc944b1258a42043ae036530ae40932", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -69,7 +69,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n \n         if !(param_env, ty).needs_infer() {\n-            return ty.is_copy_modulo_regions(self.tcx.at(span), param_env);\n+            return ty.is_copy_modulo_regions(self.tcx, param_env);\n         }\n \n         let copy_def_id = self.tcx.require_lang_item(LangItem::Copy, None);"}, {"sha": "1de85e2f288be7f82b5cd1bca7ae9dd4debaab7a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -192,12 +192,12 @@ pub fn is_const_evaluatable<'tcx>(\n         }\n         let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n         match concrete {\n-            Err(ErrorHandled::TooGeneric) => {\n-                Err(NotConstEvaluatable::Error(infcx.tcx.sess.delay_span_bug(\n-                    span,\n-                    format!(\"Missing value for constant, but no error reported?\"),\n-                )))\n-            }\n+            Err(ErrorHandled::TooGeneric) => Err(NotConstEvaluatable::Error(\n+                infcx\n+                    .tcx\n+                    .sess\n+                    .delay_span_bug(span, \"Missing value for constant, but no error reported?\"),\n+            )),\n             Err(ErrorHandled::Linted) => {\n                 let reported = infcx\n                     .tcx"}, {"sha": "8908fe230b0ebeee9de7da80ef350a111ed2ee5e", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -214,7 +214,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n         trait_ref, item, cause, pred\n     );\n     let (items, impl_def_id) = match item {\n-        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), def_id, .. }) => (impl_.items, *def_id),\n+        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), owner_id, .. }) => {\n+            (impl_.items, *owner_id)\n+        }\n         _ => return,\n     };\n     let fix_span =\n@@ -236,7 +238,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n                 && let Some(impl_item_span) = items\n                     .iter()\n-                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .find(|item| item.id.owner_id.to_def_id() == impl_item_id)\n                     .map(fix_span)\n             {\n                 cause.span = impl_item_span;\n@@ -251,7 +253,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&item_def_id)\n                 && let Some(impl_item_span) = items\n                     .iter()\n-                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .find(|item| item.id.owner_id.to_def_id() == impl_item_id)\n                     .map(fix_span)\n             {\n                 cause.span = impl_item_span;\n@@ -303,32 +305,6 @@ impl<'tcx> WfPredicates<'tcx> {\n         let obligations = if trait_pred.constness == ty::BoundConstness::NotConst {\n             self.nominal_obligations_without_const(trait_ref.def_id, trait_ref.substs)\n         } else {\n-            if !tcx.has_attr(trait_ref.def_id, rustc_span::sym::const_trait) {\n-                if let Some(item) = self.item &&\n-                   let hir::ItemKind::Impl(impl_) = item.kind &&\n-                   let Some(trait_) = &impl_.of_trait &&\n-                   let Some(def_id) = trait_.trait_def_id() &&\n-                   def_id == trait_ref.def_id\n-                {\n-                    let trait_name = tcx.item_name(def_id);\n-                    let mut err = tcx.sess.struct_span_err(\n-                        self.span,\n-                        &format!(\"const `impl` for trait `{trait_name}` which is not marked with `#[const_trait]`\"),\n-                    );\n-                    if def_id.is_local() {\n-                        let sp = tcx.def_span(def_id).shrink_to_lo();\n-                        err.span_suggestion(sp, &format!(\"mark `{trait_name}` as const\"), \"#[const_trait]\", rustc_errors::Applicability::MachineApplicable);\n-                    }\n-                    err.note(\"marking a trait with `#[const_trait]` ensures all default method bodies are `const`\");\n-                    err.note(\"adding a non-const method body in the future would be a breaking change\");\n-                    err.emit();\n-                } else {\n-                    tcx.sess.span_err(\n-                        self.span,\n-                        \"~const can only be applied to `#[const_trait]` traits\",\n-                    );\n-                }\n-            }\n             self.nominal_obligations(trait_ref.def_id, trait_ref.substs)\n         };\n "}, {"sha": "424b52309d3af8bcc58bf1a1164d9a4f18c0839c", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -17,10 +17,10 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.def_id.to_def_id()),\n+            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.owner_id.to_def_id()),\n         ),\n         hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n-            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.def_id.to_def_id()),\n+            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n         ),\n         hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n@@ -46,7 +46,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     match parent_item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n             if let Some(impl_item_ref) =\n-                impl_.items.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+                impl_.items.iter().find(|i| i.id.owner_id.to_def_id() == def_id)\n             {\n                 let assoc_item = associated_item_from_impl_item_ref(impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -56,7 +56,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) =\n-                trait_item_refs.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+                trait_item_refs.iter().find(|i| i.id.owner_id.to_def_id() == def_id)\n             {\n                 let assoc_item = associated_item_from_trait_item_ref(trait_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -75,7 +75,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n }\n \n fn associated_item_from_trait_item_ref(trait_item_ref: &hir::TraitItemRef) -> ty::AssocItem {\n-    let def_id = trait_item_ref.id.def_id;\n+    let owner_id = trait_item_ref.id.owner_id;\n     let (kind, has_self) = match trait_item_ref.kind {\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n@@ -85,15 +85,15 @@ fn associated_item_from_trait_item_ref(trait_item_ref: &hir::TraitItemRef) -> ty\n     ty::AssocItem {\n         name: trait_item_ref.ident.name,\n         kind,\n-        def_id: def_id.to_def_id(),\n-        trait_item_def_id: Some(def_id.to_def_id()),\n+        def_id: owner_id.to_def_id(),\n+        trait_item_def_id: Some(owner_id.to_def_id()),\n         container: ty::TraitContainer,\n         fn_has_self_parameter: has_self,\n     }\n }\n \n fn associated_item_from_impl_item_ref(impl_item_ref: &hir::ImplItemRef) -> ty::AssocItem {\n-    let def_id = impl_item_ref.id.def_id;\n+    let def_id = impl_item_ref.id.owner_id;\n     let (kind, has_self) = match impl_item_ref.kind {\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),"}, {"sha": "6436713b3881154043bf4288158472c3a2d28df5", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -4,7 +4,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::traits::CodegenObligationError;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Instance, TyCtxt, TypeVisitable};\n-use rustc_span::{sym, DUMMY_SP};\n+use rustc_span::sym;\n use rustc_trait_selection::traits;\n use traits::{translate_substs, Reveal};\n \n@@ -236,7 +236,7 @@ fn resolve_associated_item<'tcx>(\n                 if name == sym::clone {\n                     let self_ty = trait_ref.self_ty();\n \n-                    let is_copy = self_ty.is_copy_modulo_regions(tcx.at(DUMMY_SP), param_env);\n+                    let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env);\n                     match self_ty.kind() {\n                         _ if is_copy => (),\n                         ty::Generator(..)"}, {"sha": "52ba0eee97cd5e4d526383e09bf240c0a6d298b2", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -399,7 +399,7 @@ fn layout_of_uncached<'tcx>(\n             }\n \n             let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n-            if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            if pointee.is_sized(tcx, param_env) {\n                 return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n             }\n \n@@ -755,8 +755,7 @@ fn layout_of_uncached<'tcx>(\n                 } else {\n                     let param_env = tcx.param_env(def.did());\n                     let last_field = def.variant(v).fields.last().unwrap();\n-                    let always_sized =\n-                        tcx.type_of(last_field.did).is_sized(tcx.at(DUMMY_SP), param_env);\n+                    let always_sized = tcx.type_of(last_field.did).is_sized(tcx, param_env);\n                     if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n                 };\n "}, {"sha": "024dcd591bd77d68d321bb27a7016ee9b1b544e7", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -109,7 +109,7 @@ where\n \n             for component in components {\n                 match *component.kind() {\n-                    _ if component.is_copy_modulo_regions(tcx.at(DUMMY_SP), self.param_env) => (),\n+                    _ if component.is_copy_modulo_regions(tcx, self.param_env) => (),\n \n                     ty::Closure(_, substs) => {\n                         queue_type(self, substs.as_closure().tupled_upvars_ty());"}, {"sha": "3eebb4ace477fe867610edbc92070a628701fca4", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -137,10 +137,82 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     let local_did = def_id.as_local();\n     let hir_id = local_did.map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id));\n \n+    // FIXME(consts): This is not exactly in line with the constness query.\n+    let constness = match hir_id {\n+        Some(hir_id) => match tcx.hir().get(hir_id) {\n+            hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+                if tcx.is_const_default_method(def_id) =>\n+            {\n+                hir::Constness::Const\n+            }\n+\n+            hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(..), .. })\n+            | hir::Node::Item(hir::Item { kind: hir::ItemKind::Static(..), .. })\n+            | hir::Node::TraitItem(hir::TraitItem {\n+                kind: hir::TraitItemKind::Const(..), ..\n+            })\n+            | hir::Node::AnonConst(_)\n+            | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n+            | hir::Node::ImplItem(hir::ImplItem {\n+                kind:\n+                    hir::ImplItemKind::Fn(\n+                        hir::FnSig {\n+                            header: hir::FnHeader { constness: hir::Constness::Const, .. },\n+                            ..\n+                        },\n+                        ..,\n+                    ),\n+                ..\n+            }) => hir::Constness::Const,\n+\n+            hir::Node::ImplItem(hir::ImplItem {\n+                kind: hir::ImplItemKind::Type(..) | hir::ImplItemKind::Fn(..),\n+                ..\n+            }) => {\n+                let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n+                match tcx.hir().get(parent_hir_id) {\n+                    hir::Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n+                        ..\n+                    }) => *constness,\n+                    _ => span_bug!(\n+                        tcx.def_span(parent_hir_id.owner),\n+                        \"impl item's parent node is not an impl\",\n+                    ),\n+                }\n+            }\n+\n+            hir::Node::Item(hir::Item {\n+                kind:\n+                    hir::ItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n+                ..\n+            })\n+            | hir::Node::TraitItem(hir::TraitItem {\n+                kind:\n+                    hir::TraitItemKind::Fn(\n+                        hir::FnSig { header: hir::FnHeader { constness, .. }, .. },\n+                        ..,\n+                    ),\n+                ..\n+            })\n+            | hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n+                ..\n+            }) => *constness,\n+\n+            _ => hir::Constness::NotConst,\n+        },\n+        // FIXME(consts): It's suspicious that a param-env for a foreign item\n+        // will always have NotConst param-env, though we don't typically use\n+        // that param-env for anything meaningful right now, so it's likely\n+        // not an issue.\n+        None => hir::Constness::NotConst,\n+    };\n+\n     let unnormalized_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&predicates),\n         traits::Reveal::UserFacing,\n-        tcx.constness(def_id),\n+        constness,\n     );\n \n     let body_id ="}, {"sha": "006d813e5f9fa8c65334b135eb9e98db9e73046e", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1110,8 +1110,8 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Rc`s point to the same allocation\n-    /// (in a vein similar to [`ptr::eq`]).\n+    /// Returns `true` if the two `Rc`s point to the same allocation in a vein similar to\n+    /// [`ptr::eq`]. See [that function][`ptr::eq`] for caveats when comparing `dyn Trait` pointers.\n     ///\n     /// # Examples\n     ///\n@@ -2419,9 +2419,9 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n-    /// [`ptr::eq`]), or if both don't point to any allocation\n-    /// (because they were created with `Weak::new()`).\n+    /// Returns `true` if the two `Weak`s point to the same allocation similar to [`ptr::eq`], or if\n+    /// both don't point to any allocation (because they were created with `Weak::new()`). See [that\n+    /// function][`ptr::eq`] for caveats when comparing `dyn Trait` pointers.\n     ///\n     /// # Notes\n     ///"}, {"sha": "81cd770748854a9fd42e5ccebd4cd0f475d4d0b8", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1117,8 +1117,8 @@ impl<T: ?Sized> Arc<T> {\n         drop(Weak { ptr: self.ptr });\n     }\n \n-    /// Returns `true` if the two `Arc`s point to the same allocation\n-    /// (in a vein similar to [`ptr::eq`]).\n+    /// Returns `true` if the two `Arc`s point to the same allocation in a vein similar to\n+    /// [`ptr::eq`]. See [that function][`ptr::eq`] for caveats when comparing `dyn Trait` pointers.\n     ///\n     /// # Examples\n     ///\n@@ -2069,9 +2069,9 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n-    /// [`ptr::eq`]), or if both don't point to any allocation\n-    /// (because they were created with `Weak::new()`).\n+    /// Returns `true` if the two `Weak`s point to the same allocation similar to [`ptr::eq`], or if\n+    /// both don't point to any allocation (because they were created with `Weak::new()`). See [that\n+    /// function][`ptr::eq`] for caveats when comparing `dyn Trait` pointers.\n     ///\n     /// # Notes\n     ///"}, {"sha": "12a47f9fc76265ff866d649e1f44b14a51fb6b11", "filename": "library/core/src/async_iter/async_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fasync_iter%2Fasync_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fasync_iter%2Fasync_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fasync_iter%2Fasync_iter.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2,7 +2,7 @@ use crate::ops::DerefMut;\n use crate::pin::Pin;\n use crate::task::{Context, Poll};\n \n-/// An interface for dealing with asynchronous iterators.\n+/// A trait for dealing with asynchronous iterators.\n ///\n /// This is the main async iterator trait. For more about the concept of async iterators\n /// generally, please see the [module-level documentation]. In particular, you"}, {"sha": "e6a11218139d97c98eb9a0ba5f80bad413c7b24b", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1816,6 +1816,8 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n ///\n /// [`.get_mut()`]: `UnsafeCell::get_mut`\n ///\n+/// # Memory layout\n+///\n /// `UnsafeCell<T>` has the same in-memory representation as its inner type `T`. A consequence\n /// of this guarantee is that it is possible to convert between `T` and `UnsafeCell<T>`.\n /// Special care has to be taken when converting a nested `T` inside of an `Outer<T>` type\n@@ -1825,35 +1827,44 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// Therefore this is not a valid conversion, despite `NonNull<u8>` and `UnsafeCell<NonNull<u8>>>`\n /// having the same memory layout. This is because `UnsafeCell` disables niche optimizations in\n /// order to avoid its interior mutability property from spreading from `T` into the `Outer` type,\n-/// thus this can cause distortions in the type size in these cases. Furthermore, it is only valid\n-/// to obtain a `*mut T` pointer to the contents of a _shared_ `UnsafeCell<T>` through [`.get()`]\n-/// or [`.raw_get()`]. A `&mut T` reference can be obtained by either dereferencing this pointer or\n-/// by calling [`.get_mut()`] on an _exclusive_ `UnsafeCell<T>`, e.g.:\n+/// thus this can cause distortions in the type size in these cases.\n+///\n+/// Note that the only valid way to obtain a `*mut T` pointer to the contents of a\n+/// _shared_ `UnsafeCell<T>` is through [`.get()`]  or [`.raw_get()`]. A `&mut T` reference\n+/// can be obtained by either dereferencing this pointer or by calling [`.get_mut()`]\n+/// on an _exclusive_ `UnsafeCell<T>`. Even though `T` and `UnsafeCell<T>` have the\n+/// same memory layout, the following is not allowed and undefined behavior:\n+///\n+/// ```rust,no_run\n+/// # use std::cell::UnsafeCell;\n+/// unsafe fn not_allowed<T>(ptr: &UnsafeCell<T>) -> &mut T {\n+///   let t = ptr as *const UnsafeCell<T> as *mut T;\n+///   // This is undefined behavior, because the `*mut T` pointer\n+///   // was not obtained through `.get()` nor `.raw_get()`:\n+///   unsafe { &mut *t }\n+/// }\n+/// ```\n+///\n+/// Instead, do this:\n ///\n /// ```rust\n-/// use std::cell::UnsafeCell;\n+/// # use std::cell::UnsafeCell;\n+/// // Safety: the caller must ensure that there are no references that\n+/// // point to the *contents* of the `UnsafeCell`.\n+/// unsafe fn get_mut<T>(ptr: &UnsafeCell<T>) -> &mut T {\n+///   unsafe { &mut *ptr.get() }\n+/// }\n+/// ```\n ///\n-/// let mut x: UnsafeCell<u32> = UnsafeCell::new(5);\n-/// let shared: &UnsafeCell<u32> = &x;\n-/// // using `.get()` is okay:\n-/// unsafe {\n-///     // SAFETY: there exist no other references to the contents of `x`\n-///     let exclusive: &mut u32 = &mut *shared.get();\n-/// };\n-/// // using `.raw_get()` is also okay:\n-/// unsafe {\n-///     // SAFETY: there exist no other references to the contents of `x` in this scope\n-///     let exclusive: &mut u32 = &mut *UnsafeCell::raw_get(shared as *const _);\n-/// };\n-/// // using `.get_mut()` is always safe:\n-/// let exclusive: &mut u32 = x.get_mut();\n+/// Converting in the other direction from a `&mut T`\n+/// to an `&UnsafeCell<T>` is allowed:\n ///\n-/// // when we have exclusive access, we can convert it to a shared `&UnsafeCell`:\n-/// unsafe {\n-///     // SAFETY: `u32` has no niche, therefore it has the same layout as `UnsafeCell<u32>`\n-///     let shared: &UnsafeCell<u32> = &*(exclusive as *mut _ as *const UnsafeCell<u32>);\n-///     // SAFETY: there exist no other *active* references to the contents of `x` in this scope\n-///     let exclusive: &mut u32 = &mut *shared.get();\n+/// ```rust\n+/// # use std::cell::UnsafeCell;\n+/// fn get_shared<T>(ptr: &mut T) -> &UnsafeCell<T> {\n+///   let t = ptr as *mut T as *const UnsafeCell<T>;\n+///   // SAFETY: `T` and `UnsafeCell<T>` have the same memory layout\n+///   unsafe { &*t }\n /// }\n /// ```\n ///"}, {"sha": "78808d489b25ab61ef6575f88642801332c54f01", "filename": "library/core/src/error.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Ferror.md", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Ferror.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.md?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -46,7 +46,7 @@ These functions are equivalent, they either return the inner value if the\n `Result` is `Ok` or panic if the `Result` is `Err` printing the inner error\n as the source. The only difference between them is that with `expect` you\n provide a panic error message to be printed alongside the source, whereas\n-`unwrap` has a default message indicating only that you unwraped an `Err`.\n+`unwrap` has a default message indicating only that you unwrapped an `Err`.\n \n Of the two, `expect` is generally preferred since its `msg` field allows you\n to convey your intent and assumptions which makes tracking down the source"}, {"sha": "8923f548adf7234ce065ea8f80c0ea3675dee74b", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -221,9 +221,7 @@ impl CStr {\n     /// # Examples\n     ///\n     /// ```ignore (extern-declaration)\n-    /// # fn main() {\n-    /// use std::ffi::CStr;\n-    /// use std::os::raw::c_char;\n+    /// use std::ffi::{c_char, CStr};\n     ///\n     /// extern \"C\" {\n     ///     fn my_string() -> *const c_char;\n@@ -233,14 +231,26 @@ impl CStr {\n     ///     let slice = CStr::from_ptr(my_string());\n     ///     println!(\"string returned: {}\", slice.to_str().unwrap());\n     /// }\n-    /// # }\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(const_cstr_methods)]\n+    ///\n+    /// use std::ffi::{c_char, CStr};\n+    ///\n+    /// const HELLO_PTR: *const c_char = {\n+    ///     const BYTES: &[u8] = b\"Hello, world!\\0\";\n+    ///     BYTES.as_ptr().cast()\n+    /// };\n+    /// const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n     /// ```\n     ///\n     /// [valid]: core::ptr#safety\n     #[inline]\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n+    #[rustc_const_unstable(feature = \"const_cstr_methods\", issue = \"101719\")]\n+    pub const unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n         // SAFETY: The caller has provided a pointer that points to a valid C\n         // string with a NUL terminator of size less than `isize::MAX`, whose\n         // content remain valid and doesn't change for the lifetime of the\n@@ -252,13 +262,29 @@ impl CStr {\n         //\n         // The cast from c_char to u8 is ok because a c_char is always one byte.\n         unsafe {\n-            extern \"C\" {\n-                /// Provided by libc or compiler_builtins.\n-                fn strlen(s: *const c_char) -> usize;\n+            const fn strlen_ct(s: *const c_char) -> usize {\n+                let mut len = 0;\n+\n+                // SAFETY: Outer caller has provided a pointer to a valid C string.\n+                while unsafe { *s.add(len) } != 0 {\n+                    len += 1;\n+                }\n+\n+                len\n             }\n-            let len = strlen(ptr);\n-            let ptr = ptr as *const u8;\n-            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+\n+            fn strlen_rt(s: *const c_char) -> usize {\n+                extern \"C\" {\n+                    /// Provided by libc or compiler_builtins.\n+                    fn strlen(s: *const c_char) -> usize;\n+                }\n+\n+                // SAFETY: Outer caller has provided a pointer to a valid C string.\n+                unsafe { strlen(s) }\n+            }\n+\n+            let len = intrinsics::const_eval_select((ptr,), strlen_ct, strlen_rt);\n+            Self::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr.cast(), len + 1))\n         }\n     }\n "}, {"sha": "90cb797391a0839d7ad1fad357abbb477b8e05fa", "filename": "library/core/src/future/poll_fn.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Ffuture%2Fpoll_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Ffuture%2Fpoll_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fpoll_fn.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -5,7 +5,9 @@ use crate::task::{Context, Poll};\n \n /// Creates a future that wraps a function returning [`Poll`].\n ///\n-/// Polling the future delegates to the wrapped function.\n+/// Polling the future delegates to the wrapped function. If the returned future is pinned, then the\n+/// captured environment of the wrapped function is also pinned in-place, so as long as the closure\n+/// does not move out of its captures it can soundly create pinned references to them.\n ///\n /// # Examples\n ///\n@@ -41,7 +43,7 @@ pub struct PollFn<F> {\n }\n \n #[stable(feature = \"future_poll_fn\", since = \"1.64.0\")]\n-impl<F> Unpin for PollFn<F> {}\n+impl<F: Unpin> Unpin for PollFn<F> {}\n \n #[stable(feature = \"future_poll_fn\", since = \"1.64.0\")]\n impl<F> fmt::Debug for PollFn<F> {\n@@ -57,7 +59,8 @@ where\n {\n     type Output = T;\n \n-    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<T> {\n-        (&mut self.f)(cx)\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<T> {\n+        // SAFETY: We are not moving out of the pinned field.\n+        (unsafe { &mut self.get_unchecked_mut().f })(cx)\n     }\n }"}, {"sha": "3412d3730d01175de0d2febcaa1d6615f4a05ff2", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -101,7 +101,7 @@ pub const unsafe fn unreachable_unchecked() -> ! {\n     // SAFETY: the safety contract for `intrinsics::unreachable` must\n     // be upheld by the caller.\n     unsafe {\n-        intrinsics::assert_unsafe_precondition!(() => false);\n+        intrinsics::assert_unsafe_precondition!(\"hint::unreachable_unchecked must never be reached\", () => false);\n         intrinsics::unreachable()\n     }\n }"}, {"sha": "1dc79afe83fdba4593a0b667c8f4840646dc8c71", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2203,15 +2203,17 @@ extern \"rust-intrinsic\" {\n /// the occasional mistake, and this check should help them figure things out.\n #[allow_internal_unstable(const_eval_select)] // permit this to be called in stably-const fn\n macro_rules! assert_unsafe_precondition {\n-    ($([$($tt:tt)*])?($($i:ident:$ty:ty),*$(,)?) => $e:expr) => {\n+    ($name:expr, $([$($tt:tt)*])?($($i:ident:$ty:ty),*$(,)?) => $e:expr) => {\n         if cfg!(debug_assertions) {\n             // allow non_snake_case to allow capturing const generics\n             #[allow(non_snake_case)]\n             #[inline(always)]\n             fn runtime$(<$($tt)*>)?($($i:$ty),*) {\n                 if !$e {\n                     // don't unwind to reduce impact on code size\n-                    ::core::panicking::panic_str_nounwind(\"unsafe precondition violated\");\n+                    ::core::panicking::panic_str_nounwind(\n+                        concat!(\"unsafe precondition(s) violated: \", $name)\n+                    );\n                 }\n             }\n             #[allow(non_snake_case)]\n@@ -2229,6 +2231,16 @@ pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n     !ptr.is_null() && ptr.is_aligned()\n }\n \n+/// Checks whether an allocation of `len` instances of `T` exceeds\n+/// the maximum allowed allocation size.\n+pub(crate) fn is_valid_allocation_size<T>(len: usize) -> bool {\n+    let max_len = const {\n+        let size = crate::mem::size_of::<T>();\n+        if size == 0 { usize::MAX } else { isize::MAX as usize / size }\n+    };\n+    len <= max_len\n+}\n+\n /// Checks whether the regions of memory starting at `src` and `dst` of size\n /// `count * size_of::<T>()` do *not* overlap.\n pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {\n@@ -2340,7 +2352,10 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n     // SAFETY: the safety contract for `copy_nonoverlapping` must be\n     // upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T, dst: *mut T, count: usize) =>\n+        assert_unsafe_precondition!(\n+            \"ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n+            and the specified memory ranges do not overlap\",\n+            [T](src: *const T, dst: *mut T, count: usize) =>\n             is_aligned_and_not_null(src)\n                 && is_aligned_and_not_null(dst)\n                 && is_nonoverlapping(src, dst, count)\n@@ -2426,8 +2441,11 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n \n     // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T, dst: *mut T) =>\n-            is_aligned_and_not_null(src) && is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::copy requires that both pointer arguments are aligned aligned and non-null\",\n+            [T](src: *const T, dst: *mut T) =>\n+            is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)\n+        );\n         copy(src, dst, count)\n     }\n }\n@@ -2495,7 +2513,10 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n \n     // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write_bytes requires that the destination pointer is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         write_bytes(dst, val, count)\n     }\n }"}, {"sha": "83c7e8977e9f3e22e842bef6a0581afe7be174a9", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -14,7 +14,7 @@ use super::super::{\n \n fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n \n-/// An interface for dealing with iterators.\n+/// A trait for dealing with iterators.\n ///\n /// This is the main iterator trait. For more about the concept of iterators\n /// generally, please see the [module-level documentation]. In particular, you"}, {"sha": "659409557c9107213485fdb1acc1575d1b0ad9d8", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -192,6 +192,7 @@\n #![feature(extern_types)]\n #![feature(fundamental)]\n #![feature(if_let_guard)]\n+#![feature(inline_const)]\n #![feature(intra_doc_pointers)]\n #![feature(intrinsics)]\n #![feature(lang_items)]"}, {"sha": "ae4ebf444429545538b85c22ceef44087d7ea241", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -44,6 +44,12 @@ impl<T: ?Sized> !Send for *const T {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !Send for *mut T {}\n \n+// Most instances arise automatically, but this instance is needed to link up `T: Sync` with\n+// `&T: Send` (and it also removes the unsound default instance `T Send` -> `&T: Send` that would\n+// otherwise exist).\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync + ?Sized> Send for &T {}\n+\n /// Types with a constant size known at compile time.\n ///\n /// All type parameters have an implicit bound of `Sized`. The special syntax\n@@ -674,13 +680,6 @@ impl<T: ?Sized> StructuralPartialEq for PhantomData<T> {}\n #[unstable(feature = \"structural_match\", issue = \"31434\")]\n impl<T: ?Sized> StructuralEq for PhantomData<T> {}\n \n-mod impls {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe impl<T: Sync + ?Sized> Send for &T {}\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe impl<T: Send + ?Sized> Send for &mut T {}\n-}\n-\n /// Compiler-internal trait used to indicate the type of enum discriminants.\n ///\n /// This trait is automatically implemented for every type and does not add any"}, {"sha": "2e1a667097c015432277219bcb081d8050052ce2", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1004,7 +1004,7 @@ pub fn drop<T>(_x: T) {}\n /// ```\n #[inline]\n #[unstable(feature = \"mem_copy_fn\", issue = \"98262\")]\n-pub fn copy<T: Copy>(x: &T) -> T {\n+pub const fn copy<T: Copy>(x: &T) -> T {\n     *x\n }\n "}, {"sha": "6b6f3417f8ad5788ab7aebce12024111ed6665af", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -56,7 +56,10 @@ macro_rules! nonzero_integers {\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n                     // SAFETY: this is guaranteed to be safe by the caller.\n                     unsafe {\n-                        core::intrinsics::assert_unsafe_precondition!((n: $Int) => n != 0);\n+                        core::intrinsics::assert_unsafe_precondition!(\n+                            concat!(stringify!($Ty), \"::new_unchecked requires a non-zero argument\"),\n+                            (n: $Int) => n != 0\n+                        );\n                         Self(n)\n                     }\n                 }"}, {"sha": "3e06776d2c6fae5f569e6c41690b75d13b096dd6", "filename": "library/core/src/ops/index_range.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex_range.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -19,7 +19,12 @@ impl IndexRange {\n     #[inline]\n     pub const unsafe fn new_unchecked(start: usize, end: usize) -> Self {\n         // SAFETY: comparisons on usize are pure\n-        unsafe { assert_unsafe_precondition!((start: usize, end: usize) => start <= end) };\n+        unsafe {\n+            assert_unsafe_precondition!(\n+               \"IndexRange::new_unchecked requires `start <= end`\",\n+                (start: usize, end: usize) => start <= end\n+            )\n+        };\n         IndexRange { start, end }\n     }\n "}, {"sha": "1390e09dd96aec4c74b785ab6b26a8a0353812ac", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -76,7 +76,12 @@ impl Alignment {\n     #[inline]\n     pub const unsafe fn new_unchecked(align: usize) -> Self {\n         // SAFETY: Precondition passed to the caller.\n-        unsafe { assert_unsafe_precondition!((align: usize) => align.is_power_of_two()) };\n+        unsafe {\n+            assert_unsafe_precondition!(\n+               \"Alignment::new_unchecked requires a power of two\",\n+                (align: usize) => align.is_power_of_two()\n+            )\n+        };\n \n         // SAFETY: By precondition, this must be a power of two, and\n         // our variants encompass all possible powers of two."}, {"sha": "5a083227bb0efda119a32a6458b3d129affaace6", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -761,7 +761,10 @@ impl<T: ?Sized> *const T {\n         // SAFETY: The comparison has no side-effects, and the intrinsic\n         // does this check internally in the CTFE implementation.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: *const T, origin: *const T) => this >= origin)\n+            assert_unsafe_precondition!(\n+                \"ptr::sub_ptr requires `this >= origin`\",\n+                [T](this: *const T, origin: *const T) => this >= origin\n+            )\n         };\n \n         let pointee_size = mem::size_of::<T>();\n@@ -802,7 +805,7 @@ impl<T: ?Sized> *const T {\n \n     /// Returns whether two pointers are guaranteed to be inequal.\n     ///\n-    /// At runtime this function behaves like `Some(self == other)`.\n+    /// At runtime this function behaves like `Some(self != other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine inequality of two pointers, so this function may\n     /// spuriously return `None` for pointers that later actually turn out to have its inequality known."}, {"sha": "565c38d222a2c4339ceec5e77fc9d8a0adeae978", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -581,12 +581,21 @@ pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n /// Convert an address back to a pointer, picking up a previously 'exposed' provenance.\n ///\n /// This is equivalent to `addr as *const T`. The provenance of the returned pointer is that of *any*\n-/// pointer that was previously passed to [`expose_addr`][pointer::expose_addr] or a `ptr as usize`\n-/// cast. If there is no previously 'exposed' provenance that justifies the way this pointer will be\n-/// used, the program has undefined behavior. Note that there is no algorithm that decides which\n-/// provenance will be used. You can think of this as \"guessing\" the right provenance, and the guess\n-/// will be \"maximally in your favor\", in the sense that if there is any way to avoid undefined\n-/// behavior, then that is the guess that will be taken.\n+/// pointer that was previously exposed by passing it to [`expose_addr`][pointer::expose_addr],\n+/// or a `ptr as usize` cast. In addition, memory which is outside the control of the Rust abstract\n+/// machine (MMIO registers, for example) is always considered to be exposed, so long as this memory\n+/// is disjoint from memory that will be used by the abstract machine such as the stack, heap,\n+/// and statics.\n+///\n+/// If there is no 'exposed' provenance that justifies the way this pointer will be used,\n+/// the program has undefined behavior. In particular, the aliasing rules still apply: pointers\n+/// and references that have been invalidated due to aliasing accesses cannot be used any more,\n+/// even if they have been exposed!\n+///\n+/// Note that there is no algorithm that decides which provenance will be used. You can think of this\n+/// as \"guessing\" the right provenance, and the guess will be \"maximally in your favor\", in the sense\n+/// that if there is any way to avoid undefined behavior (while upholding all aliasing requirements),\n+/// then that is the guess that will be taken.\n ///\n /// On platforms with multiple address spaces, it is your responsibility to ensure that the\n /// address makes sense in the address space that this pointer will be used with.\n@@ -889,7 +898,10 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     // SAFETY: the caller must guarantee that `x` and `y` are\n     // valid for writes and properly aligned.\n     unsafe {\n-        assert_unsafe_precondition!([T](x: *mut T, y: *mut T, count: usize) =>\n+        assert_unsafe_precondition!(\n+            \"ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n+            and the specified memory ranges do not overlap\",\n+            [T](x: *mut T, y: *mut T, count: usize) =>\n             is_aligned_and_not_null(x)\n                 && is_aligned_and_not_null(y)\n                 && is_nonoverlapping(x, y, count)\n@@ -986,7 +998,10 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n     // and cannot overlap `src` since `dst` must point to a distinct\n     // allocated object.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::replace requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         mem::swap(&mut *dst, &mut src); // cannot overlap\n     }\n     src\n@@ -1117,7 +1132,10 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n     // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n     // to be properly initialized.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T) => is_aligned_and_not_null(src));\n+        assert_unsafe_precondition!(\n+            \"ptr::read requires that the pointer argument is aligned and non-null\",\n+            [T](src: *const T) => is_aligned_and_not_null(src)\n+        );\n         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n         tmp.assume_init()\n     }\n@@ -1311,7 +1329,10 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // `dst` cannot overlap `src` because the caller has mutable access\n     // to `dst` while `src` is owned by this function.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         copy_nonoverlapping(&src as *const T, dst, 1);\n         intrinsics::forget(src);\n     }\n@@ -1475,7 +1496,10 @@ pub const unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n     // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n     unsafe {\n-        assert_unsafe_precondition!([T](src: *const T) => is_aligned_and_not_null(src));\n+        assert_unsafe_precondition!(\n+            \"ptr::read_volatile requires that the pointer argument is aligned and non-null\",\n+            [T](src: *const T) => is_aligned_and_not_null(src)\n+        );\n         intrinsics::volatile_load(src)\n     }\n }\n@@ -1546,7 +1570,10 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n     // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n     unsafe {\n-        assert_unsafe_precondition!([T](dst: *mut T) => is_aligned_and_not_null(dst));\n+        assert_unsafe_precondition!(\n+            \"ptr::write_volatile requires that the pointer argument is aligned and non-null\",\n+            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n+        );\n         intrinsics::volatile_store(dst, src);\n     }\n }\n@@ -1733,6 +1760,12 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n /// by their address rather than comparing the values they point to\n /// (which is what the `PartialEq for &T` implementation does).\n ///\n+/// When comparing wide pointers, both the address and the metadata are tested for equality.\n+/// However, note that comparing trait object pointers (`*const dyn Trait`) is unrealiable: pointers\n+/// to values of the same underlying type can compare inequal (because vtables are duplicated in\n+/// multiple codegen units), and pointers to values of *different* underlying type can compare equal\n+/// (since identical vtables can be deduplicated within a codegen unit).\n+///\n /// # Examples\n ///\n /// ```\n@@ -1759,41 +1792,6 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n /// assert!(!std::ptr::eq(&a[..2], &a[..3]));\n /// assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n /// ```\n-///\n-/// Traits are also compared by their implementation:\n-///\n-/// ```\n-/// #[repr(transparent)]\n-/// struct Wrapper { member: i32 }\n-///\n-/// trait Trait {}\n-/// impl Trait for Wrapper {}\n-/// impl Trait for i32 {}\n-///\n-/// let wrapper = Wrapper { member: 10 };\n-///\n-/// // Pointers have equal addresses.\n-/// assert!(std::ptr::eq(\n-///     &wrapper as *const Wrapper as *const u8,\n-///     &wrapper.member as *const i32 as *const u8\n-/// ));\n-///\n-/// // Objects have equal addresses, but `Trait` has different implementations.\n-/// assert!(!std::ptr::eq(\n-///     &wrapper as &dyn Trait,\n-///     &wrapper.member as &dyn Trait,\n-/// ));\n-/// assert!(!std::ptr::eq(\n-///     &wrapper as &dyn Trait as *const dyn Trait,\n-///     &wrapper.member as &dyn Trait as *const dyn Trait,\n-/// ));\n-///\n-/// // Converting the reference to a `*const u8` compares by address.\n-/// assert!(std::ptr::eq(\n-///     &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n-///     &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n-/// ));\n-/// ```\n #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n #[inline]\n pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {"}, {"sha": "6764002bcd434e525fe8cc30d8f3a0f177107462", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -730,7 +730,7 @@ impl<T: ?Sized> *mut T {\n \n     /// Returns whether two pointers are guaranteed to be inequal.\n     ///\n-    /// At runtime this function behaves like `Some(self == other)`.\n+    /// At runtime this function behaves like `Some(self != other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine inequality of two pointers, so this function may\n     /// spuriously return `None` for pointers that later actually turn out to have its inequality known."}, {"sha": "c18264d13ebac78993f8cbc9ab9090ed521fe0be", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -197,7 +197,7 @@ impl<T: ?Sized> NonNull<T> {\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         // SAFETY: the caller must guarantee that `ptr` is non-null.\n         unsafe {\n-            assert_unsafe_precondition!([T: ?Sized](ptr: *mut T) => !ptr.is_null());\n+            assert_unsafe_precondition!(\"NonNull::new_unchecked requires that the pointer is non-null\", [T: ?Sized](ptr: *mut T) => !ptr.is_null());\n             NonNull { pointer: ptr as _ }\n         }\n     }"}, {"sha": "6d2f7330d5db55fd4b4a20dde265b8982351fb52", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -232,7 +232,10 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: usize, slice: *const [T]) => this < slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the index is within the slice\",\n+                [T](this: usize, slice: *const [T]) => this < slice.len()\n+            );\n             slice.as_ptr().add(self)\n         }\n     }\n@@ -242,7 +245,10 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n         let this = self;\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: usize, slice: *mut [T]) => this < slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the index is within the slice\",\n+                [T](this: usize, slice: *mut [T]) => this < slice.len()\n+            );\n             slice.as_mut_ptr().add(self)\n         }\n     }\n@@ -295,8 +301,10 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n         // so the call to `add` is safe.\n \n         unsafe {\n-            assert_unsafe_precondition!([T](end: usize, slice: *const [T]) =>\n-                end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the index is within the slice\",\n+                [T](end: usize, slice: *const [T]) => end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts(slice.as_ptr().add(self.start()), self.len())\n         }\n     }\n@@ -306,8 +314,10 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n         let end = self.end();\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](end: usize, slice: *mut [T]) =>\n-                end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the index is within the slice\",\n+                [T](end: usize, slice: *mut [T]) => end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start()), self.len())\n         }\n     }\n@@ -367,8 +377,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         // so the call to `add` is safe.\n \n         unsafe {\n-            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *const [T]) =>\n-            this.end >= this.start && this.end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked requires that the range is within the slice\",\n+                [T](this: ops::Range<usize>, slice: *const [T]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n         }\n     }\n@@ -378,8 +391,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n         let this = ops::Range { start: self.start, end: self.end };\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n-            assert_unsafe_precondition!([T](this: ops::Range<usize>, slice: *mut [T]) =>\n-                this.end >= this.start && this.end <= slice.len());\n+            assert_unsafe_precondition!(\n+                \"slice::get_unchecked_mut requires that the range is within the slice\",\n+                [T](this: ops::Range<usize>, slice: *mut [T]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n             ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n         }\n     }"}, {"sha": "4f1bb17344b2943f74c86996e8ac7edb4b8af358", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -653,7 +653,10 @@ impl<T> [T] {\n         let ptr = this.as_mut_ptr();\n         // SAFETY: caller has to guarantee that `a < self.len()` and `b < self.len()`\n         unsafe {\n-            assert_unsafe_precondition!([T](a: usize, b: usize, this: &mut [T]) => a < this.len() && b < this.len());\n+            assert_unsafe_precondition!(\n+                \"slice::swap_unchecked requires that the indices are within the slice\",\n+                [T](a: usize, b: usize, this: &mut [T]) => a < this.len() && b < this.len()\n+            );\n             ptr::swap(ptr.add(a), ptr.add(b));\n         }\n     }\n@@ -969,7 +972,10 @@ impl<T> [T] {\n         let this = self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n+            assert_unsafe_precondition!(\n+                \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n+                [T](this: &[T], N: usize) => N != 0 && this.len() % N == 0\n+            );\n             exact_div(self.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n@@ -1109,7 +1115,10 @@ impl<T> [T] {\n         let this = &*self;\n         // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n         let new_len = unsafe {\n-            assert_unsafe_precondition!([T](this: &[T], N: usize) => N != 0 && this.len() % N == 0);\n+            assert_unsafe_precondition!(\n+                \"slice::as_chunks_unchecked_mut requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n+                [T](this: &[T], N: usize) => N != 0 && this.len() % N == 0\n+            );\n             exact_div(this.len(), N)\n         };\n         // SAFETY: We cast a slice of `new_len * N` elements into\n@@ -1685,7 +1694,10 @@ impl<T> [T] {\n         // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n         // is fine.\n         unsafe {\n-            assert_unsafe_precondition!((mid: usize, len: usize) => mid <= len);\n+            assert_unsafe_precondition!(\n+                \"slice::split_at_mut_unchecked requires the index to be within the slice\",\n+                (mid: usize, len: usize) => mid <= len\n+            );\n             (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n         }\n     }"}, {"sha": "052fd34d0b6b7492ca91e0cee82a0c03bef3ea2f", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,7 +1,9 @@\n //! Free functions to create `&[T]` and `&mut [T]`.\n \n use crate::array;\n-use crate::intrinsics::{assert_unsafe_precondition, is_aligned_and_not_null};\n+use crate::intrinsics::{\n+    assert_unsafe_precondition, is_aligned_and_not_null, is_valid_allocation_size,\n+};\n use crate::ops::Range;\n use crate::ptr;\n \n@@ -90,9 +92,10 @@ use crate::ptr;\n pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n     unsafe {\n-        assert_unsafe_precondition!([T](data: *const T, len: usize) =>\n-            is_aligned_and_not_null(data)\n-                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+        assert_unsafe_precondition!(\n+            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n+            [T](data: *const T, len: usize) => is_aligned_and_not_null(data)\n+                && is_valid_allocation_size::<T>(len)\n         );\n         &*ptr::slice_from_raw_parts(data, len)\n     }\n@@ -134,9 +137,10 @@ pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T]\n pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n     unsafe {\n-        assert_unsafe_precondition!([T](data: *mut T, len: usize) =>\n-            is_aligned_and_not_null(data)\n-                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+        assert_unsafe_precondition!(\n+            \"slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n+            [T](data: *mut T, len: usize) => is_aligned_and_not_null(data)\n+                && is_valid_allocation_size::<T>(len)\n         );\n         &mut *ptr::slice_from_raw_parts_mut(data, len)\n     }"}, {"sha": "c6d42308596cb2f51ba91c7bc3485a16872413c1", "filename": "library/panic_unwind/src/emcc.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Femcc.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -47,7 +47,12 @@ static EXCEPTION_TYPE_INFO: TypeInfo = TypeInfo {\n     name: b\"rust_panic\\0\".as_ptr(),\n };\n \n+// NOTE(nbdd0121): The `canary` field will be part of stable ABI after `c_unwind` stabilization.\n+#[repr(C)]\n struct Exception {\n+    // See `gcc.rs` on why this is present. We already have a static here so just use it.\n+    canary: *const TypeInfo,\n+\n     // This is necessary because C++ code can capture our exception with\n     // std::exception_ptr and rethrow it multiple times, possibly even in\n     // another thread.\n@@ -70,27 +75,38 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let catch_data = &*(ptr as *mut CatchData);\n \n     let adjusted_ptr = __cxa_begin_catch(catch_data.ptr as *mut libc::c_void) as *mut Exception;\n-    let out = if catch_data.is_rust_panic {\n-        let was_caught = (*adjusted_ptr).caught.swap(true, Ordering::SeqCst);\n-        if was_caught {\n-            // Since cleanup() isn't allowed to panic, we just abort instead.\n-            intrinsics::abort();\n-        }\n-        (*adjusted_ptr).data.take().unwrap()\n-    } else {\n+    if !catch_data.is_rust_panic {\n         super::__rust_foreign_exception();\n-    };\n+    }\n+\n+    let canary = ptr::addr_of!((*adjusted_ptr).canary).read();\n+    if !ptr::eq(canary, &EXCEPTION_TYPE_INFO) {\n+        super::__rust_foreign_exception();\n+    }\n+\n+    let was_caught = (*adjusted_ptr).caught.swap(true, Ordering::SeqCst);\n+    if was_caught {\n+        // Since cleanup() isn't allowed to panic, we just abort instead.\n+        intrinsics::abort();\n+    }\n+    let out = (*adjusted_ptr).data.take().unwrap();\n     __cxa_end_catch();\n     out\n }\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n-    let sz = mem::size_of_val(&data);\n-    let exception = __cxa_allocate_exception(sz) as *mut Exception;\n+    let exception = __cxa_allocate_exception(mem::size_of::<Exception>()) as *mut Exception;\n     if exception.is_null() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    ptr::write(exception, Exception { caught: AtomicBool::new(false), data: Some(data) });\n+    ptr::write(\n+        exception,\n+        Exception {\n+            canary: &EXCEPTION_TYPE_INFO,\n+            caught: AtomicBool::new(false),\n+            data: Some(data),\n+        },\n+    );\n     __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, exception_cleanup);\n }\n "}, {"sha": "0b7a873a691cc020f70e693307e624f00dbaaef1", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -38,12 +38,23 @@\n \n use alloc::boxed::Box;\n use core::any::Any;\n+use core::ptr;\n \n use unwind as uw;\n \n+// In case where multiple copies of std exist in a single process,\n+// we use address of this static variable to distinguish an exception raised by\n+// this copy and some other copy (which needs to be treated as foreign exception).\n+static CANARY: u8 = 0;\n+\n+// NOTE(nbdd0121)\n+// Once `c_unwind` feature is stabilized, there will be ABI stability requirement\n+// on this struct. The first two field must be `_Unwind_Exception` and `canary`,\n+// as it may be accessed by a different version of the std with a different compiler.\n #[repr(C)]\n struct Exception {\n     _uwe: uw::_Unwind_Exception,\n+    canary: *const u8,\n     cause: Box<dyn Any + Send>,\n }\n \n@@ -54,6 +65,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n             exception_cleanup,\n             private: [0; uw::unwinder_private_data_size],\n         },\n+        canary: &CANARY,\n         cause: data,\n     });\n     let exception_param = Box::into_raw(exception) as *mut uw::_Unwind_Exception;\n@@ -75,10 +87,22 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     if (*exception).exception_class != rust_exception_class() {\n         uw::_Unwind_DeleteException(exception);\n         super::__rust_foreign_exception();\n-    } else {\n-        let exception = Box::from_raw(exception as *mut Exception);\n-        exception.cause\n     }\n+\n+    let exception = exception.cast::<Exception>();\n+    // Just access the canary field, avoid accessing the entire `Exception` as\n+    // it can be a foreign Rust exception.\n+    let canary = ptr::addr_of!((*exception).canary).read();\n+    if !ptr::eq(canary, &CANARY) {\n+        // A foreign Rust exception, treat it slightly differently from other\n+        // foreign exceptions, because call into `_Unwind_DeleteException` will\n+        // call into `__rust_drop_panic` which produces a confusing\n+        // \"Rust panic must be rethrown\" message.\n+        super::__rust_foreign_exception();\n+    }\n+\n+    let exception = Box::from_raw(exception as *mut Exception);\n+    exception.cause\n }\n \n // Rust's exception class identifier.  This is used by personality routines to"}, {"sha": "651115a8248ac50886c88de41fc1cabc71f66626", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -49,9 +49,15 @@\n use alloc::boxed::Box;\n use core::any::Any;\n use core::mem::{self, ManuallyDrop};\n+use core::ptr;\n use libc::{c_int, c_uint, c_void};\n \n+// NOTE(nbdd0121): The `canary` field will be part of stable ABI after `c_unwind` stabilization.\n+#[repr(C)]\n struct Exception {\n+    // See `gcc.rs` on why this is present. We already have a static here so just use it.\n+    canary: *const _TypeDescriptor,\n+\n     // This needs to be an Option because we catch the exception by reference\n     // and its destructor is executed by the C++ runtime. When we take the Box\n     // out of the exception, we need to leave the exception in a valid state\n@@ -235,7 +241,7 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n macro_rules! define_cleanup {\n     ($abi:tt $abi2:tt) => {\n         unsafe extern $abi fn exception_cleanup(e: *mut Exception) {\n-            if let Exception { data: Some(b) } = e.read() {\n+            if let Exception { data: Some(b), .. } = e.read() {\n                 drop(b);\n                 super::__rust_drop_panic();\n             }\n@@ -265,7 +271,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // The ManuallyDrop is needed here since we don't want Exception to be\n     // dropped when unwinding. Instead it will be dropped by exception_cleanup\n     // which is invoked by the C++ runtime.\n-    let mut exception = ManuallyDrop::new(Exception { data: Some(data) });\n+    let mut exception = ManuallyDrop::new(Exception { canary: &TYPE_DESCRIPTOR, data: Some(data) });\n     let throw_ptr = &mut exception as *mut _ as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n@@ -321,8 +327,12 @@ pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n     // __rust_try. This happens when a non-Rust foreign exception is caught.\n     if payload.is_null() {\n         super::__rust_foreign_exception();\n-    } else {\n-        let exception = &mut *(payload as *mut Exception);\n-        exception.data.take().unwrap()\n     }\n+    let exception = payload as *mut Exception;\n+    let canary = ptr::addr_of!((*exception).canary).read();\n+    if !ptr::eq(canary, &TYPE_DESCRIPTOR) {\n+        // A foreign Rust exception.\n+        super::__rust_foreign_exception();\n+    }\n+    (*exception).data.take().unwrap()\n }"}, {"sha": "708edc5de4751f0232f04ca98e1d7f6acbf3cc87", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -759,7 +759,7 @@ where\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n     /// in the `HashMap`. The collection may reserve more space to speculatively\n-    /// avoid frequent reallocations. After calling `reserve`,\n+    /// avoid frequent reallocations. After calling `try_reserve`,\n     /// capacity will be greater than or equal to `self.len() + additional` if\n     /// it returns `Ok(())`.\n     /// Does nothing if capacity is already sufficient."}, {"sha": "cee884145c7116fd3f695389b94a4ad3501475ca", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -462,7 +462,7 @@ where\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n     /// in the `HashSet`. The collection may reserve more space to speculatively\n-    /// avoid frequent reallocations. After calling `reserve`,\n+    /// avoid frequent reallocations. After calling `try_reserve`,\n     /// capacity will be greater than or equal to `self.len() + additional` if\n     /// it returns `Ok(())`.\n     /// Does nothing if capacity is already sufficient."}, {"sha": "dafcd876744128885014528a859afe93451f20da", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -275,7 +275,7 @@ impl f32 {\n     /// This result is not an element of the function's codomain, but it is the\n     /// closest floating point number in the real numbers and thus fulfills the\n     /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n-    /// approximatively.\n+    /// approximately.\n     ///\n     /// # Examples\n     ///"}, {"sha": "77048f9a28f2516f18c43fe550f4ba1bb095fc1e", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -275,7 +275,7 @@ impl f64 {\n     /// This result is not an element of the function's codomain, but it is the\n     /// closest floating point number in the real numbers and thus fulfills the\n     /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n-    /// approximatively.\n+    /// approximately.\n     ///\n     /// # Examples\n     ///"}, {"sha": "4592e9141600e600d876a07aabe2cb6d10e70114", "filename": "library/std/src/sync/mpsc/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fstream.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -114,7 +114,7 @@ impl<T> Packet<T> {\n         match self.queue.producer_addition().cnt.fetch_add(1, Ordering::SeqCst) {\n             // As described in the mod's doc comment, -1 == wakeup\n             -1 => UpWoke(self.take_to_wake()),\n-            // As as described before, SPSC queues must be >= -2\n+            // As described before, SPSC queues must be >= -2\n             -2 => UpSuccess,\n \n             // Be sure to preserve the disconnected state, and the return value"}, {"sha": "37a49f2d78acdb24179d078f4e84b32ed017a573", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,3 +1,6 @@\n+// miri has some special hacks here that make things unused.\n+#![cfg_attr(miri, allow(unused))]\n+\n use crate::os::unix::prelude::*;\n \n use crate::ffi::{CStr, OsStr, OsString};\n@@ -850,7 +853,6 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     )))]\n-    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n     }\n@@ -862,7 +864,6 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     ))]\n-    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         &self.name\n     }"}, {"sha": "c1d30dd9d521b318ed83cdf225df4ee918da1fcc", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -137,7 +137,9 @@ impl Thread {\n         unsafe {\n             // Available since glibc 2.12, musl 1.1.16, and uClibc 1.0.20.\n             let name = truncate_cstr(name, TASK_COMM_LEN);\n-            libc::pthread_setname_np(libc::pthread_self(), name.as_ptr());\n+            let res = libc::pthread_setname_np(libc::pthread_self(), name.as_ptr());\n+            // We have no good way of propagating errors here, but in debug-builds let's check that this actually worked.\n+            debug_assert_eq!(res, 0);\n         }\n     }\n \n@@ -152,19 +154,22 @@ impl Thread {\n     pub fn set_name(name: &CStr) {\n         unsafe {\n             let name = truncate_cstr(name, libc::MAXTHREADNAMESIZE);\n-            libc::pthread_setname_np(name.as_ptr());\n+            let res = libc::pthread_setname_np(name.as_ptr());\n+            // We have no good way of propagating errors here, but in debug-builds let's check that this actually worked.\n+            debug_assert_eq!(res, 0);\n         }\n     }\n \n     #[cfg(target_os = \"netbsd\")]\n     pub fn set_name(name: &CStr) {\n         unsafe {\n             let cname = CStr::from_bytes_with_nul_unchecked(b\"%s\\0\".as_slice());\n-            libc::pthread_setname_np(\n+            let res = libc::pthread_setname_np(\n                 libc::pthread_self(),\n                 cname.as_ptr(),\n                 name.as_ptr() as *mut libc::c_void,\n             );\n+            debug_assert_eq!(res, 0);\n         }\n     }\n \n@@ -177,9 +182,8 @@ impl Thread {\n         }\n \n         if let Some(f) = pthread_setname_np.get() {\n-            unsafe {\n-                f(libc::pthread_self(), name.as_ptr());\n-            }\n+            let res = unsafe { f(libc::pthread_self(), name.as_ptr()) };\n+            debug_assert_eq!(res, 0);\n         }\n     }\n "}, {"sha": "e6d3d46c9f90912dac5fe4250ee52aec99eff62c", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -362,7 +362,7 @@ impl IO_STATUS_BLOCK {\n \n pub type LPOVERLAPPED_COMPLETION_ROUTINE = unsafe extern \"system\" fn(\n     dwErrorCode: DWORD,\n-    dwNumberOfBytesTransfered: DWORD,\n+    dwNumberOfBytesTransferred: DWORD,\n     lpOverlapped: *mut OVERLAPPED,\n );\n "}, {"sha": "9f26acc45205cde3ac32ffcf38747a5c8e0e7f95", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -324,17 +324,18 @@ impl AnonPipe {\n         let mut async_result: Option<AsyncResult> = None;\n         struct AsyncResult {\n             error: u32,\n-            transfered: u32,\n+            transferred: u32,\n         }\n \n         // STEP 3: The callback.\n         unsafe extern \"system\" fn callback(\n             dwErrorCode: u32,\n-            dwNumberOfBytesTransfered: u32,\n+            dwNumberOfBytesTransferred: u32,\n             lpOverlapped: *mut c::OVERLAPPED,\n         ) {\n             // Set `async_result` using a pointer smuggled through `hEvent`.\n-            let result = AsyncResult { error: dwErrorCode, transfered: dwNumberOfBytesTransfered };\n+            let result =\n+                AsyncResult { error: dwErrorCode, transferred: dwNumberOfBytesTransferred };\n             *(*lpOverlapped).hEvent.cast::<Option<AsyncResult>>() = Some(result);\n         }\n \n@@ -365,7 +366,7 @@ impl AnonPipe {\n         // STEP 4: Return the result.\n         // `async_result` is always `Some` at this point\n         match result.error {\n-            c::ERROR_SUCCESS => Ok(result.transfered as usize),\n+            c::ERROR_SUCCESS => Ok(result.transferred as usize),\n             error => Err(io::Error::from_raw_os_error(error as _)),\n         }\n     }"}, {"sha": "141f16d17f0221bacf36984fa39f565710721053", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -20,6 +20,7 @@\n #![feature(is_terminal)]\n #![feature(staged_api)]\n #![feature(process_exitcode_internals)]\n+#![feature(panic_can_unwind)]\n #![feature(test)]\n \n // Public reexports\n@@ -54,6 +55,7 @@ use std::{\n     collections::VecDeque,\n     env, io,\n     io::prelude::Write,\n+    mem::ManuallyDrop,\n     panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n     process::{self, Command, Termination},\n     sync::mpsc::{channel, Sender},\n@@ -112,6 +114,29 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n             process::exit(ERROR_EXIT_CODE);\n         }\n     } else {\n+        if !opts.nocapture {\n+            // If we encounter a non-unwinding panic, flush any captured output from the current test,\n+            // and stop  capturing output to ensure that the non-unwinding panic message is visible.\n+            // We also acquire the locks for both output streams to prevent output from other threads\n+            // from interleaving with the panic message or appearing after it.\n+            let builtin_panic_hook = panic::take_hook();\n+            let hook = Box::new({\n+                move |info: &'_ PanicInfo<'_>| {\n+                    if !info.can_unwind() {\n+                        std::mem::forget(std::io::stderr().lock());\n+                        let mut stdout = ManuallyDrop::new(std::io::stdout().lock());\n+                        if let Some(captured) = io::set_output_capture(None) {\n+                            if let Ok(data) = captured.lock() {\n+                                let _ = stdout.write_all(&data);\n+                                let _ = stdout.flush();\n+                            }\n+                        }\n+                    }\n+                    builtin_panic_hook(info);\n+                }\n+            });\n+            panic::set_hook(hook);\n+        }\n         match console::run_tests_console(&opts, tests) {\n             Ok(true) => {}\n             Ok(false) => process::exit(ERROR_EXIT_CODE),"}, {"sha": "ea06caf9c3311e95a093a1a02567b5cab93c47dc", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 48, "deletions": 18, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -228,7 +228,7 @@ impl Step for TheBook {\n         }\n \n         // build the version info page and CSS\n-        builder.ensure(Standalone { compiler, target });\n+        let shared_assets = builder.ensure(SharedAssets { target });\n \n         // build the redirect pages\n         builder.info(&format!(\"Documenting book redirect pages ({})\", target));\n@@ -237,7 +237,7 @@ impl Step for TheBook {\n             let path = file.path();\n             let path = path.to_str().unwrap();\n \n-            invoke_rustdoc(builder, compiler, target, path);\n+            invoke_rustdoc(builder, compiler, &shared_assets, target, path);\n         }\n \n         if builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n@@ -251,6 +251,7 @@ impl Step for TheBook {\n fn invoke_rustdoc(\n     builder: &Builder<'_>,\n     compiler: Compiler,\n+    shared_assets: &SharedAssetsPaths,\n     target: TargetSelection,\n     markdown: &str,\n ) {\n@@ -260,7 +261,6 @@ fn invoke_rustdoc(\n \n     let header = builder.src.join(\"src/doc/redirect.inc\");\n     let footer = builder.src.join(\"src/doc/footer.inc\");\n-    let version_info = out.join(\"version_info.html\");\n \n     let mut cmd = builder.rustdoc_cmd(compiler);\n \n@@ -269,7 +269,7 @@ fn invoke_rustdoc(\n     cmd.arg(\"--html-after-content\")\n         .arg(&footer)\n         .arg(\"--html-before-content\")\n-        .arg(&version_info)\n+        .arg(&shared_assets.version_info)\n         .arg(\"--html-in-header\")\n         .arg(&header)\n         .arg(\"--markdown-no-toc\")\n@@ -300,7 +300,7 @@ impl Step for Standalone {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.path(\"src/doc\").default_condition(builder.config.docs)\n+        run.path(\"src/doc\").alias(\"standalone\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -325,21 +325,11 @@ impl Step for Standalone {\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n+        let version_info = builder.ensure(SharedAssets { target: self.target }).version_info;\n+\n         let favicon = builder.src.join(\"src/doc/favicon.inc\");\n         let footer = builder.src.join(\"src/doc/footer.inc\");\n         let full_toc = builder.src.join(\"src/doc/full-toc.inc\");\n-        t!(fs::copy(builder.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n-\n-        let version_input = builder.src.join(\"src/doc/version_info.html.template\");\n-        let version_info = out.join(\"version_info.html\");\n-\n-        if !builder.config.dry_run && !up_to_date(&version_input, &version_info) {\n-            let info = t!(fs::read_to_string(&version_input))\n-                .replace(\"VERSION\", &builder.rust_release())\n-                .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n-                .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n-            t!(fs::write(&version_info, &info));\n-        }\n \n         for file in t!(fs::read_dir(builder.src.join(\"src/doc\"))) {\n             let file = t!(file);\n@@ -401,6 +391,45 @@ impl Step for Standalone {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub struct SharedAssetsPaths {\n+    pub version_info: PathBuf,\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct SharedAssets {\n+    target: TargetSelection,\n+}\n+\n+impl Step for SharedAssets {\n+    type Output = SharedAssetsPaths;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        // Other tasks depend on this, no need to execute it on its own\n+        run.never()\n+    }\n+\n+    // Generate shared resources used by other pieces of documentation.\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let out = builder.doc_out(self.target);\n+\n+        let version_input = builder.src.join(\"src\").join(\"doc\").join(\"version_info.html.template\");\n+        let version_info = out.join(\"version_info.html\");\n+        if !builder.config.dry_run && !up_to_date(&version_input, &version_info) {\n+            let info = t!(fs::read_to_string(&version_input))\n+                .replace(\"VERSION\", &builder.rust_release())\n+                .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n+                .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n+            t!(fs::write(&version_info, &info));\n+        }\n+\n+        builder.copy(&builder.src.join(\"src\").join(\"doc\").join(\"rust.css\"), &out.join(\"rust.css\"));\n+\n+        SharedAssetsPaths { version_info }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub stage: u32,\n@@ -429,7 +458,8 @@ impl Step for Std {\n         let target = self.target;\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        t!(fs::copy(builder.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n+\n+        builder.ensure(SharedAssets { target: self.target });\n \n         let index_page = builder.src.join(\"src/doc/index.md\").into_os_string();\n         let mut extra_args = vec!["}, {"sha": "7edd3c12041436aaff4b1334228719fbe0c4324e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1418,7 +1418,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         }\n         let mut flags = if is_rustdoc { Vec::new() } else { vec![\"-Crpath\".to_string()] };\n         flags.push(format!(\"-Cdebuginfo={}\", builder.config.rust_debuginfo_level_tests));\n-        flags.push(builder.config.cmd.rustc_args().join(\" \"));\n+        flags.extend(builder.config.cmd.rustc_args().iter().map(|s| s.to_string()));\n \n         if let Some(linker) = builder.linker(target) {\n             cmd.arg(\"--linker\").arg(linker);\n@@ -1427,12 +1427,16 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         let mut hostflags = flags.clone();\n         hostflags.push(format!(\"-Lnative={}\", builder.test_helpers_out(compiler.host).display()));\n         hostflags.extend(builder.lld_flags(compiler.host));\n-        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n+        for flag in hostflags {\n+            cmd.arg(\"--host-rustcflags\").arg(flag);\n+        }\n \n         let mut targetflags = flags;\n         targetflags.push(format!(\"-Lnative={}\", builder.test_helpers_out(target).display()));\n         targetflags.extend(builder.lld_flags(target));\n-        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n+        for flag in targetflags {\n+            cmd.arg(\"--target-rustcflags\").arg(flag);\n+        }\n \n         cmd.arg(\"--python\").arg(builder.python());\n "}, {"sha": "d87384556106ddb65c09151f6753bf61bc62a67c", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -27,6 +27,10 @@ python3 \"$X_PY\" test --stage 2 src/tools/rustfmt\n python3 \"$X_PY\" test --stage 2 src/tools/miri\n # We natively run this script on x86_64-unknown-linux-gnu and x86_64-pc-windows-msvc.\n # Also cover some other targets (on both of these hosts) via cross-testing.\n-python3 \"$X_PY\" test --stage 2 src/tools/miri --target i686-pc-windows-msvc\n+#\n+# Currently disabled -- we end up pulling in a cross-compile of LLVM (maybe\n+# just overly eager sanity checks), but in any case this won't work when\n+# building LLVM as of this comment.\n+#python3 \"$X_PY\" test --stage 2 src/tools/miri --target i686-pc-windows-msvc\n #FIXME(https://github.com/rust-lang/rust/issues/103519): macOS testing is currently disabled\n # python3 \"$X_PY\" test --stage 2 src/tools/miri --target aarch64-apple-darwin"}, {"sha": "aa5ee485bd6bd80d205da7c82fcdd776f92fdd51", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1 +1 @@\n-Subproject commit f1e5ad844d0c61738006cdef26227beeb136948e\n+Subproject commit aa5ee485bd6bd80d205da7c82fcdd776f92fdd51"}, {"sha": "4ea7c5def38ac81df33a9e48e5637a82a5ac404d", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1 +1 @@\n-Subproject commit f6ed74f582bddcec73f753eafaab3749c4f7df61\n+Subproject commit 4ea7c5def38ac81df33a9e48e5637a82a5ac404d"}, {"sha": "03491f33375c5a2a1661c7fa4be671fe95ce1249", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1 +1 @@\n-Subproject commit 5e7b296d6c345addbd748f242aae28c42555c015\n+Subproject commit 03491f33375c5a2a1661c7fa4be671fe95ce1249"}, {"sha": "51a37ad19a15709d0601afbac6581f5aea6a45da", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1 +1 @@\n-Subproject commit 7518c3445dc02df0d196f5f84e568d633c5141fb\n+Subproject commit 51a37ad19a15709d0601afbac6581f5aea6a45da"}, {"sha": "e0bb782270e22821f416ac44a45d91236e985ffd", "filename": "src/doc/unstable-book/src/language-features/arbitrary-enum-discriminant.md", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md", "raw_url": "https://github.com/rust-lang/rust/raw/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md?ref=c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "patch": "@@ -1,37 +0,0 @@\n-# `arbitrary_enum_discriminant`\n-\n-The tracking issue for this feature is: [#60553]\n-\n-[#60553]: https://github.com/rust-lang/rust/issues/60553\n-\n-------------------------\n-\n-The `arbitrary_enum_discriminant` feature permits tuple-like and\n-struct-like enum variants with `#[repr(<int-type>)]` to have explicit discriminants.\n-\n-## Examples\n-\n-```rust\n-#![feature(arbitrary_enum_discriminant)]\n-\n-#[allow(dead_code)]\n-#[repr(u8)]\n-enum Enum {\n-    Unit = 3,\n-    Tuple(u16) = 2,\n-    Struct {\n-        a: u8,\n-        b: u16,\n-    } = 1,\n-}\n-\n-impl Enum {\n-    fn tag(&self) -> u8 {\n-        unsafe { *(self as *const Self as *const u8) }\n-    }\n-}\n-\n-assert_eq!(3, Enum::Unit.tag());\n-assert_eq!(2, Enum::Tuple(5).tag());\n-assert_eq!(1, Enum::Struct{a: 7, b: 11}.tag());\n-```"}, {"sha": "764a6d3aa48cf4eb5d917a4ac46ad6386f143556", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -148,7 +148,7 @@ where\n             })\n             .collect();\n         // We are only interested in case the type *doesn't* implement the Sized trait.\n-        if !ty.is_sized(tcx.at(rustc_span::DUMMY_SP), param_env) {\n+        if !ty.is_sized(tcx, param_env) {\n             // In case `#![no_core]` is used, `sized_trait` returns nothing.\n             if let Some(item) = tcx.lang_items().sized_trait().and_then(|sized_trait_did| {\n                 self.generate_for_trait(ty, sized_trait_did, param_env, item_def_id, &f, true)"}, {"sha": "8b63c3db3c335b3959df738a9bb286e9cd0d39af", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -20,7 +20,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n         for trait_def_id in cx.tcx.all_traits() {\n-            if !cx.cache.access_levels.is_public(trait_def_id)\n+            if !cx.cache.effective_visibilities.is_directly_public(trait_def_id)\n                 || cx.generated_synthetics.get(&(ty.0, trait_def_id)).is_some()\n             {\n                 continue;"}, {"sha": "b9f787729c14876976c2ed3a893d4d0ba9766c45", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -55,12 +55,39 @@ pub(crate) fn try_inline(\n     let mut ret = Vec::new();\n \n     debug!(\"attrs={:?}\", attrs);\n-    let attrs_clone = attrs;\n+\n+    let attrs_without_docs = attrs.map(|attrs| {\n+        attrs.into_iter().filter(|a| a.doc_str().is_none()).cloned().collect::<Vec<_>>()\n+    });\n+    // We need this ugly code because:\n+    //\n+    // ```\n+    // attrs_without_docs.map(|a| a.as_slice())\n+    // ```\n+    //\n+    // will fail because it returns a temporary slice and:\n+    //\n+    // ```\n+    // attrs_without_docs.map(|s| {\n+    //     vec = s.as_slice();\n+    //     vec\n+    // })\n+    // ```\n+    //\n+    // will fail because we're moving an uninitialized variable into a closure.\n+    let vec;\n+    let attrs_without_docs = match attrs_without_docs {\n+        Some(s) => {\n+            vec = s;\n+            Some(vec.as_slice())\n+        }\n+        None => None,\n+    };\n \n     let kind = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, ItemType::Trait);\n-            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n+            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n             clean::TraitItem(Box::new(build_external_trait(cx, did)))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -69,27 +96,27 @@ pub(crate) fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, ItemType::Struct);\n-            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n+            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, ItemType::Union);\n-            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n+            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, ItemType::Typedef);\n-            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n+            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n             clean::TypedefItem(build_type_alias(cx, did))\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, ItemType::Enum);\n-            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n+            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, ItemType::ForeignType);\n-            build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n+            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -123,7 +150,7 @@ pub(crate) fn try_inline(\n         _ => return None,\n     };\n \n-    let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs_clone);\n+    let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs);\n     cx.inlined.insert(did.into());\n     let mut item = clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n@@ -347,7 +374,7 @@ pub(crate) fn build_impl(\n     if !did.is_local() {\n         if let Some(traitref) = associated_trait {\n             let did = traitref.def_id;\n-            if !cx.cache.access_levels.is_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(did) {\n                 return;\n             }\n \n@@ -376,7 +403,7 @@ pub(crate) fn build_impl(\n     // reachable in rustdoc generated documentation\n     if !did.is_local() {\n         if let Some(did) = for_.def_id(&cx.cache) {\n-            if !cx.cache.access_levels.is_public(did) {\n+            if !cx.cache.effective_visibilities.is_directly_public(did) {\n                 return;\n             }\n "}, {"sha": "64a18757b26e5f166770913e93b732b00c012460", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 83, "deletions": 67, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -415,6 +415,16 @@ fn clean_projection<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     def_id: Option<DefId>,\n ) -> Type {\n+    if cx.tcx.def_kind(ty.item_def_id) == DefKind::ImplTraitPlaceholder {\n+        let bounds = cx\n+            .tcx\n+            .explicit_item_bounds(ty.item_def_id)\n+            .iter()\n+            .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, ty.substs))\n+            .collect::<Vec<_>>();\n+        return clean_middle_opaque_bounds(cx, bounds);\n+    }\n+\n     let trait_ = clean_trait_ref_with_bindings(cx, ty.trait_ref(cx.tcx), ThinVec::new());\n     let self_type = clean_middle_ty(ty.self_ty(), cx, None);\n     let self_def_id = if let Some(def_id) = def_id {\n@@ -1032,7 +1042,7 @@ fn clean_poly_trait_ref<'tcx>(\n }\n \n fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n-    let local_did = trait_item.def_id.to_def_id();\n+    let local_did = trait_item.owner_id.to_def_id();\n     cx.with_param_env(local_did, |cx| {\n         let inner = match trait_item.kind {\n             hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n@@ -1084,7 +1094,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n     impl_: &hir::ImplItem<'tcx>,\n     cx: &mut DocContext<'tcx>,\n ) -> Item {\n-    let local_did = impl_.def_id.to_def_id();\n+    let local_did = impl_.owner_id.to_def_id();\n     cx.with_param_env(local_did, |cx| {\n         let inner = match impl_.kind {\n             hir::ImplItemKind::Const(ty, expr) => {\n@@ -1093,7 +1103,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 let m = clean_function(cx, sig, impl_.generics, body);\n-                let defaultness = cx.tcx.impl_defaultness(impl_.def_id);\n+                let defaultness = cx.tcx.impl_defaultness(impl_.owner_id);\n                 MethodItem(m, Some(defaultness))\n             }\n             hir::ImplItemKind::Type(hir_ty) => {\n@@ -1110,7 +1120,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n         let mut what_rustc_thinks =\n             Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx);\n \n-        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.def_id.def_id));\n+        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.owner_id.def_id));\n \n         // Trait impl items always inherit the impl's visibility --\n         // we don't want to show `pub`.\n@@ -1421,7 +1431,7 @@ fn maybe_expand_private_type_alias<'tcx>(\n     let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n     // Substitute private type aliases\n     let def_id = def_id.as_local()?;\n-    let alias = if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n+    let alias = if !cx.cache.effective_visibilities.is_exported(def_id.to_def_id()) {\n         &cx.tcx.hir().expect_item(def_id).kind\n     } else {\n         return None;\n@@ -1720,59 +1730,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                 .iter()\n                 .map(|(bound, _)| EarlyBinder(*bound).subst(cx.tcx, substs))\n                 .collect::<Vec<_>>();\n-            let mut regions = vec![];\n-            let mut has_sized = false;\n-            let mut bounds = bounds\n-                .iter()\n-                .filter_map(|bound| {\n-                    let bound_predicate = bound.kind();\n-                    let trait_ref = match bound_predicate.skip_binder() {\n-                        ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n-                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n-                            if let Some(r) = clean_middle_region(reg) {\n-                                regions.push(GenericBound::Outlives(r));\n-                            }\n-                            return None;\n-                        }\n-                        _ => return None,\n-                    };\n-\n-                    if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n-                        if trait_ref.def_id() == sized {\n-                            has_sized = true;\n-                            return None;\n-                        }\n-                    }\n-\n-                    let bindings: ThinVec<_> = bounds\n-                        .iter()\n-                        .filter_map(|bound| {\n-                            if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder()\n-                            {\n-                                if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n-                                    Some(TypeBinding {\n-                                        assoc: projection_to_path_segment(proj.projection_ty, cx),\n-                                        kind: TypeBindingKind::Equality {\n-                                            term: clean_middle_term(proj.term, cx),\n-                                        },\n-                                    })\n-                                } else {\n-                                    None\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .collect();\n-\n-                    Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, bindings))\n-                })\n-                .collect::<Vec<_>>();\n-            bounds.extend(regions);\n-            if !has_sized && !bounds.is_empty() {\n-                bounds.insert(0, GenericBound::maybe_sized(cx));\n-            }\n-            ImplTrait(bounds)\n+            clean_middle_opaque_bounds(cx, bounds)\n         }\n \n         ty::Closure(..) => panic!(\"Closure\"),\n@@ -1785,6 +1743,64 @@ pub(crate) fn clean_middle_ty<'tcx>(\n     }\n }\n \n+fn clean_middle_opaque_bounds<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n+    bounds: Vec<ty::Predicate<'tcx>>,\n+) -> Type {\n+    let mut regions = vec![];\n+    let mut has_sized = false;\n+    let mut bounds = bounds\n+        .iter()\n+        .filter_map(|bound| {\n+            let bound_predicate = bound.kind();\n+            let trait_ref = match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                    if let Some(r) = clean_middle_region(reg) {\n+                        regions.push(GenericBound::Outlives(r));\n+                    }\n+                    return None;\n+                }\n+                _ => return None,\n+            };\n+\n+            if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n+                if trait_ref.def_id() == sized {\n+                    has_sized = true;\n+                    return None;\n+                }\n+            }\n+\n+            let bindings: ThinVec<_> = bounds\n+                .iter()\n+                .filter_map(|bound| {\n+                    if let ty::PredicateKind::Projection(proj) = bound.kind().skip_binder() {\n+                        if proj.projection_ty.trait_ref(cx.tcx) == trait_ref.skip_binder() {\n+                            Some(TypeBinding {\n+                                assoc: projection_to_path_segment(proj.projection_ty, cx),\n+                                kind: TypeBindingKind::Equality {\n+                                    term: clean_middle_term(proj.term, cx),\n+                                },\n+                            })\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n+\n+            Some(clean_poly_trait_ref_with_bindings(cx, trait_ref, bindings))\n+        })\n+        .collect::<Vec<_>>();\n+    bounds.extend(regions);\n+    if !has_sized && !bounds.is_empty() {\n+        bounds.insert(0, GenericBound::maybe_sized(cx));\n+    }\n+    ImplTrait(bounds)\n+}\n+\n pub(crate) fn clean_field<'tcx>(field: &hir::FieldDef<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n     let def_id = cx.tcx.hir().local_def_id(field.hir_id).to_def_id();\n     clean_field_with_def_id(def_id, field.ident.name, clean_ty(field.ty, cx), cx)\n@@ -1942,7 +1958,7 @@ fn clean_maybe_renamed_item<'tcx>(\n ) -> Vec<Item> {\n     use hir::ItemKind;\n \n-    let def_id = item.def_id.to_def_id();\n+    let def_id = item.owner_id.to_def_id();\n     let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n@@ -2084,11 +2100,11 @@ fn clean_extern_crate<'tcx>(\n     cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n-    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id.def_id).unwrap_or(LOCAL_CRATE);\n+    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.owner_id.def_id).unwrap_or(LOCAL_CRATE);\n     // this is the ID of the crate itself\n     let crate_def_id = cnum.as_def_id();\n     let attrs = cx.tcx.hir().attrs(krate.hir_id());\n-    let ty_vis = cx.tcx.visibility(krate.def_id);\n+    let ty_vis = cx.tcx.visibility(krate.owner_id);\n     let please_inline = ty_vis.is_public()\n         && attrs.iter().any(|a| {\n             a.has_name(sym::doc)\n@@ -2106,7 +2122,7 @@ fn clean_extern_crate<'tcx>(\n         if let Some(items) = inline::try_inline(\n             cx,\n             cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n-            Some(krate.def_id.to_def_id()),\n+            Some(krate.owner_id.to_def_id()),\n             res,\n             name,\n             Some(attrs),\n@@ -2142,11 +2158,11 @@ fn clean_use_statement<'tcx>(\n         return Vec::new();\n     }\n \n-    let visibility = cx.tcx.visibility(import.def_id);\n+    let visibility = cx.tcx.visibility(import.owner_id);\n     let attrs = cx.tcx.hir().attrs(import.hir_id());\n     let inline_attr = attrs.lists(sym::doc).get_word_attr(sym::inline);\n     let pub_underscore = visibility.is_public() && name == kw::Underscore;\n-    let current_mod = cx.tcx.parent_module_from_def_id(import.def_id.def_id);\n+    let current_mod = cx.tcx.parent_module_from_def_id(import.owner_id.def_id);\n \n     // The parent of the module in which this import resides. This\n     // is the same as `current_mod` if that's already the top\n@@ -2217,7 +2233,7 @@ fn clean_use_statement<'tcx>(\n         }\n         if !denied {\n             let mut visited = FxHashSet::default();\n-            let import_def_id = import.def_id.to_def_id();\n+            let import_def_id = import.owner_id.to_def_id();\n \n             if let Some(mut items) = inline::try_inline(\n                 cx,\n@@ -2240,15 +2256,15 @@ fn clean_use_statement<'tcx>(\n         Import::new_simple(name, resolve_use_source(cx, path), true)\n     };\n \n-    vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n+    vec![Item::from_def_id_and_parts(import.owner_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n fn clean_maybe_renamed_foreign_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::ForeignItem<'tcx>,\n     renamed: Option<Symbol>,\n ) -> Item {\n-    let def_id = item.def_id.to_def_id();\n+    let def_id = item.owner_id.to_def_id();\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n             hir::ForeignItemKind::Fn(decl, names, generics) => {"}, {"sha": "cd1f972dce8441b0b0c7407bc1a6b65522310ee2", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -240,13 +240,13 @@ impl ExternalCrate {\n                     let item = tcx.hir().item(id);\n                     match item.kind {\n                         hir::ItemKind::Mod(_) => {\n-                            as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                            as_keyword(Res::Def(DefKind::Mod, id.owner_id.to_def_id()))\n                         }\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if tcx.visibility(id.def_id).is_public() =>\n+                            if tcx.visibility(id.owner_id).is_public() =>\n                         {\n                             as_keyword(path.res.expect_non_local())\n-                                .map(|(_, prim)| (id.def_id.to_def_id(), prim))\n+                                .map(|(_, prim)| (id.owner_id.to_def_id(), prim))\n                         }\n                         _ => None,\n                     }\n@@ -308,14 +308,14 @@ impl ExternalCrate {\n                     let item = tcx.hir().item(id);\n                     match item.kind {\n                         hir::ItemKind::Mod(_) => {\n-                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                            as_primitive(Res::Def(DefKind::Mod, id.owner_id.to_def_id()))\n                         }\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if tcx.visibility(id.def_id).is_public() =>\n+                            if tcx.visibility(id.owner_id).is_public() =>\n                         {\n                             as_primitive(path.res.expect_non_local()).map(|(_, prim)| {\n                                 // Pretend the primitive is local.\n-                                (id.def_id.to_def_id(), prim)\n+                                (id.owner_id.to_def_id(), prim)\n                             })\n                         }\n                         _ => None,"}, {"sha": "3e5f42b7a80dc54ee4178682d5558bfa18452647", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n+use rustc_data_structures::unord::UnordSet;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n@@ -288,8 +289,7 @@ pub(crate) fn create_config(\n             providers.typeck_item_bodies = |_, _| {};\n             // hack so that `used_trait_imports` won't try to call typeck\n             providers.used_trait_imports = |_, _| {\n-                static EMPTY_SET: LazyLock<FxHashSet<LocalDefId>> =\n-                    LazyLock::new(FxHashSet::default);\n+                static EMPTY_SET: LazyLock<UnordSet<LocalDefId>> = LazyLock::new(UnordSet::default);\n                 &EMPTY_SET\n             };\n             // In case typeck does end up being called, don't ICE in case there were name resolution errors\n@@ -348,7 +348,7 @@ pub(crate) fn run_global_ctxt(\n \n     let auto_traits =\n         tcx.all_traits().filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id)).collect();\n-    let access_levels = tcx.privacy_access_levels(()).map_id(Into::into);\n+    let effective_visibilities = tcx.effective_visibilities(()).map_id(Into::into);\n \n     let mut ctxt = DocContext {\n         tcx,\n@@ -361,7 +361,7 @@ pub(crate) fn run_global_ctxt(\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits,\n-        cache: Cache::new(access_levels, render_options.document_private),\n+        cache: Cache::new(effective_visibilities, render_options.document_private),\n         inlined: FxHashSet::default(),\n         output_format,\n         render_options,"}, {"sha": "afe2264e8bf85dd5b62f37afae4f5785570f7430", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -2,7 +2,7 @@ use std::mem;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n \n@@ -77,8 +77,8 @@ pub(crate) struct Cache {\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub(crate) access_levels: AccessLevels<DefId>,\n+    // the effective visibilities from the privacy check pass.\n+    pub(crate) effective_visibilities: EffectiveVisibilities<DefId>,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n     pub(crate) crate_version: Option<String>,\n@@ -132,8 +132,11 @@ struct CacheBuilder<'a, 'tcx> {\n }\n \n impl Cache {\n-    pub(crate) fn new(access_levels: AccessLevels<DefId>, document_private: bool) -> Self {\n-        Cache { access_levels, document_private, ..Cache::default() }\n+    pub(crate) fn new(\n+        effective_visibilities: EffectiveVisibilities<DefId>,\n+        document_private: bool,\n+    ) -> Self {\n+        Cache { effective_visibilities, document_private, ..Cache::default() }\n     }\n \n     /// Populates the `Cache` with more data. The returned `Crate` will be missing some data that was\n@@ -381,7 +384,10 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     // paths map if there was already an entry present and we're\n                     // not a public item.\n                     if !self.cache.paths.contains_key(&item.item_id.expect_def_id())\n-                        || self.cache.access_levels.is_public(item.item_id.expect_def_id())\n+                        || self\n+                            .cache\n+                            .effective_visibilities\n+                            .is_directly_public(item.item_id.expect_def_id())\n                     {\n                         self.cache.paths.insert(\n                             item.item_id.expect_def_id(),"}, {"sha": "92e7f2739afbb4ef27dd43741b0e5f126449bdf3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -659,7 +659,7 @@ pub(crate) fn href_with_root_path(\n     }\n \n     if !did.is_local()\n-        && !cache.access_levels.is_public(did)\n+        && !cache.effective_visibilities.is_directly_public(did)\n         && !cache.document_private\n         && !cache.primitive_locations.values().any(|&id| id == did)\n     {"}, {"sha": "28136cc48d658f06ac0e803d785ef3cbfd1183dc", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -72,8 +72,12 @@ pub(crate) fn render_source_with_highlighting(\n     line_numbers: Buffer,\n     href_context: HrefContext<'_, '_, '_>,\n     decoration_info: DecorationInfo,\n+    extra: Option<&str>,\n ) {\n     write_header(out, \"\", Some(line_numbers), Tooltip::None);\n+    if let Some(extra) = extra {\n+        out.push_str(extra);\n+    }\n     write_code(out, src, Some(href_context), Some(decoration_info));\n     write_footer(out, None);\n }"}, {"sha": "27dea8ec0b312b87fdd4f0564f9c0b31928210b8", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1276,6 +1276,15 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n \n     if let Some((did, ty)) = decl.output.as_return().and_then(|t| Some((t.def_id(cx.cache())?, t)))\n     {\n+        // Box has pass-through impls for Read, Write, Iterator, and Future when the\n+        // boxed type implements one of those. We don't want to treat every Box return\n+        // as being notably an Iterator (etc), though, so we exempt it. Pin has the same\n+        // issue, with a pass-through impl for Future.\n+        if Some(did) == cx.tcx().lang_items().owned_box()\n+            || Some(did) == cx.tcx().lang_items().pin_type()\n+        {\n+            return \"\".to_string();\n+        }\n         if let Some(impls) = cx.cache().impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n@@ -2860,10 +2869,6 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n             write!(w, r#\"<span class=\"prev\">&pr;</span> <span class=\"next\">&sc;</span>\"#);\n         }\n \n-        if needs_expansion {\n-            write!(w, r#\"<span class=\"expand\">&varr;</span>\"#);\n-        }\n-\n         // Look for the example file in the source map if it exists, otherwise return a dummy span\n         let file_span = (|| {\n             let source_map = tcx.sess.source_map();\n@@ -2897,7 +2902,7 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n             cx,\n             &root_path,\n             highlight::DecorationInfo(decoration_info),\n-            sources::SourceContext::Embedded { offset: line_min },\n+            sources::SourceContext::Embedded { offset: line_min, needs_expansion },\n         );\n         write!(w, \"</div></div>\");\n "}, {"sha": "8a01c01049d6e771d3f89eef9af9783dcd41f193", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -258,7 +258,7 @@ where\n \n pub(crate) enum SourceContext {\n     Standalone,\n-    Embedded { offset: usize },\n+    Embedded { offset: usize, needs_expansion: bool },\n }\n \n /// Wrapper struct to render the source code of a file. This will do things like\n@@ -274,14 +274,18 @@ pub(crate) fn print_src(\n ) {\n     let lines = s.lines().count();\n     let mut line_numbers = Buffer::empty_from(buf);\n+    let extra;\n     line_numbers.write_str(\"<pre class=\\\"src-line-numbers\\\">\");\n     match source_context {\n         SourceContext::Standalone => {\n+            extra = None;\n             for line in 1..=lines {\n                 writeln!(line_numbers, \"<span id=\\\"{0}\\\">{0}</span>\", line)\n             }\n         }\n-        SourceContext::Embedded { offset } => {\n+        SourceContext::Embedded { offset, needs_expansion } => {\n+            extra =\n+                if needs_expansion { Some(r#\"<span class=\"expand\">&varr;</span>\"#) } else { None };\n             for line in 1..=lines {\n                 writeln!(line_numbers, \"<span>{0}</span>\", line + offset)\n             }\n@@ -297,5 +301,6 @@ pub(crate) fn print_src(\n         line_numbers,\n         highlight::HrefContext { context, file_span, root_path, current_href },\n         decoration_info,\n+        extra,\n     );\n }"}, {"sha": "330bdb45465c9297210efe40532ae1df442b4af7", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 59, "deletions": 80, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -292,10 +292,6 @@ p:last-child {\n \tmargin: 0;\n }\n \n-summary {\n-\toutline: none;\n-}\n-\n /* Fix some style changes due to normalize.css 8 */\n \n button {\n@@ -497,9 +493,7 @@ ul.block, .block li {\n .sidebar h2 {\n \toverflow-wrap: anywhere;\n \tpadding: 0;\n-\tmargin: 0;\n-\tmargin-top: 0.7rem;\n-\tmargin-bottom: 0.7rem;\n+\tmargin: 0.7rem 0;\n }\n \n .sidebar h3 {\n@@ -549,47 +543,46 @@ ul.block, .block li {\n \tmargin-bottom: 0px;\n }\n \n-pre.example-line-numbers {\n+.rustdoc .example-wrap > pre {\n+\tmargin: 0;\n+\tflex-grow: 1;\n+\toverflow-x: auto;\n+}\n+\n+.rustdoc .example-wrap > pre.example-line-numbers,\n+.rustdoc .example-wrap > pre.src-line-numbers {\n+\tflex-grow: 0;\n \toverflow: initial;\n+\ttext-align: right;\n+\t-webkit-user-select: none;\n+\t-moz-user-select: none;\n+\t-ms-user-select: none;\n+\tuser-select: none;\n+}\n+\n+.example-line-numbers {\n \tborder: 1px solid;\n \tpadding: 13px 8px;\n-\ttext-align: right;\n \tborder-top-left-radius: 5px;\n \tborder-bottom-left-radius: 5px;\n+\tborder-color: var(--example-line-numbers-border-color);\n }\n \n-.src-line-numbers {\n-\ttext-align: right;\n-}\n-.rustdoc:not(.source) .example-wrap > pre:not(.example-line-numbers) {\n-\twidth: 100%;\n-\toverflow-x: auto;\n+.src-line-numbers span {\n+\tcursor: pointer;\n+\tcolor: var(--src-line-numbers-span-color);\n }\n-\n-.rustdoc:not(.source) .example-wrap > pre.src-line-numbers {\n-\twidth: auto;\n-\toverflow-x: visible;\n+.src-line-numbers .line-highlighted {\n+\tbackground-color: var(--src-line-number-highlighted-background-color);\n }\n-\n-.rustdoc .example-wrap > pre {\n-\tmargin: 0;\n+.src-line-numbers :target {\n+\tbackground-color: transparent;\n }\n \n .search-loading {\n \ttext-align: center;\n }\n \n-.content > .example-wrap pre.src-line-numbers {\n-\tposition: relative;\n-\t-webkit-user-select: none;\n-\t-moz-user-select: none;\n-\t-ms-user-select: none;\n-\tuser-select: none;\n-}\n-.src-line-numbers span {\n-\tcursor: pointer;\n-}\n-\n .docblock-short {\n \toverflow-wrap: break-word;\n \toverflow-wrap: anywhere;\n@@ -688,13 +681,16 @@ nav.sub {\n \tdisplay: flex;\n \talign-items: center;\n }\n-nav.sub form {\n+.search-form {\n+\tposition: relative;\n+\tdisplay: flex;\n+\theight: 34px;\n \tflex-grow: 1;\n }\n .source nav.sub {\n \tmargin: 0 0 15px 0;\n }\n-.source nav.sub form {\n+.source .search-form {\n \tmargin-left: 32px;\n }\n \n@@ -785,11 +781,6 @@ table,\n \tpadding-right: 1.25rem;\n }\n \n-.search-container {\n-\tposition: relative;\n-\tdisplay: flex;\n-\theight: 34px;\n-}\n .search-results-title {\n \tmargin-top: 0;\n \twhite-space: nowrap;\n@@ -810,10 +801,8 @@ table,\n }\n #crate-search {\n \tmin-width: 115px;\n-\tpadding: 0;\n \t/* keep these two in sync with \"@-moz-document url-prefix()\" below */\n-\tpadding-left: 4px;\n-\tpadding-right: 23px;\n+\tpadding: 0 23px 0 4px;\n \t/* prevents the <select> from overflowing the containing div in case it's shrunk */\n \tmax-width: 100%;\n \t/* contents can overflow because of max-width limit, then show ellipsis */\n@@ -865,17 +854,12 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t   -webkit-appearance: textfield for search inputs. That\n \t   causes rounded corners and no border on iOS Safari. */\n \t-webkit-appearance: none;\n-\t/* Override Normalize.css: we have margins and do\n-\t not want to overflow - the `moz` attribute is necessary\n-\t until Firefox 29, too early to drop at this point */\n-\t-moz-box-sizing: border-box !important;\n-\tbox-sizing: border-box !important;\n \toutline: none;\n \tborder: 1px solid var(--border-color);\n \tborder-radius: 2px;\n \tpadding: 8px;\n \tfont-size: 1rem;\n-\twidth: 100%;\n+\tflex-grow: 1;\n \tbackground-color: var(--button-background-color);\n \tcolor: var(--search-color);\n }\n@@ -1302,7 +1286,7 @@ h3.variant {\n \tcontent: \"\\00a0\\00a0\\00a0\";\n }\n \n-.notable-traits .notable, .notable-traits .docblock {\n+.notable-traits .docblock {\n \tmargin: 0;\n }\n \n@@ -1538,6 +1522,8 @@ details.rustdoc-toggle > summary.hideme {\n \n details.rustdoc-toggle > summary {\n \tlist-style: none;\n+\t/* focus outline is shown on `::before` instead of this */\n+\toutline: none;\n }\n details.rustdoc-toggle > summary::-webkit-details-marker,\n details.rustdoc-toggle > summary::marker {\n@@ -1585,6 +1571,15 @@ details.rustdoc-toggle > summary:hover::before {\n \topacity: 1;\n }\n \n+details.rustdoc-toggle > summary:focus-visible::before {\n+\t/* The SVG is black, and gets turned white using a filter in the dark themes.\n+\t   Do the same with the outline.\n+\t   The dotted 1px style is copied from Firefox's focus ring style.\n+\t*/\n+\toutline: 1px dotted #000;\n+\toutline-offset: 1px;\n+}\n+\n details.rustdoc-toggle.top-doc > summary,\n details.rustdoc-toggle.top-doc > summary::before,\n details.rustdoc-toggle.non-exhaustive > summary,\n@@ -1720,7 +1715,6 @@ in storage.js\n \t\t/* Hide the sidebar offscreen while not in use. Doing this instead of display: none means\n \t\t   the sidebar stays visible for screen readers, which is useful for navigation. */\n \t\tleft: -1000px;\n-\t\tmargin-left: 0;\n \t\tmargin: 0;\n \t\tpadding: 0;\n \t\tz-index: 11;\n@@ -1773,9 +1767,7 @@ in storage.js\n \t.mobile-topbar .logo-container > img {\n \t\tmax-width: 35px;\n \t\tmax-height: 35px;\n-\t\tmargin-left: 20px;\n-\t\tmargin-top: 5px;\n-\t\tmargin-bottom: 5px;\n+\t\tmargin: 5px 0 5px 20px;\n \t}\n \n \t.mobile-topbar {\n@@ -1953,7 +1945,7 @@ in storage.js\n \t\tflex-direction: column;\n \t}\n \n-\tnav.sub form {\n+\t.search-form {\n \t\talign-self: stretch;\n \t}\n \n@@ -2024,49 +2016,36 @@ in storage.js\n \tpadding-bottom: 0;\n }\n \n-.scraped-example:not(.expanded) .code-wrapper pre.src-line-numbers {\n-\toverflow-x: hidden;\n-}\n-\n-.scraped-example .code-wrapper .prev {\n+.scraped-example .code-wrapper .next,\n+.scraped-example .code-wrapper .prev,\n+.scraped-example .code-wrapper .expand {\n \tposition: absolute;\n \ttop: 0.25em;\n-\tright: 2.25em;\n-\tz-index: 100;\n+\tz-index: 1;\n \tcursor: pointer;\n }\n-\n+.scraped-example .code-wrapper .prev {\n+\tright: 2.25em;\n+}\n .scraped-example .code-wrapper .next {\n-\tposition: absolute;\n-\ttop: 0.25em;\n \tright: 1.25em;\n-\tz-index: 100;\n-\tcursor: pointer;\n }\n-\n .scraped-example .code-wrapper .expand {\n-\tposition: absolute;\n-\ttop: 0.25em;\n \tright: 0.25em;\n-\tz-index: 100;\n-\tcursor: pointer;\n }\n \n-.scraped-example:not(.expanded) .code-wrapper:before {\n+.scraped-example:not(.expanded) .code-wrapper:before,\n+.scraped-example:not(.expanded) .code-wrapper:after {\n \tcontent: \" \";\n \twidth: 100%;\n \theight: 5px;\n \tposition: absolute;\n-\tz-index: 100;\n+\tz-index: 1;\n+}\n+.scraped-example:not(.expanded) .code-wrapper:before {\n \ttop: 0;\n }\n-\n .scraped-example:not(.expanded) .code-wrapper:after {\n-\tcontent: \" \";\n-\twidth: 100%;\n-\theight: 5px;\n-\tposition: absolute;\n-\tz-index: 100;\n \tbottom: 0;\n }\n "}, {"sha": "fdfdb3e196672560d05b7c55503d2e619e9357a8", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -55,6 +55,9 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--code-highlight-question-mark-color: #ff9011;\n \t--code-highlight-comment-color: #788797;\n \t--code-highlight-doc-comment-color: #a1ac88;\n+\t--example-line-numbers-border-color: none;\n+\t--src-line-numbers-span-color: #5c6773;\n+\t--src-line-number-highlighted-background-color: rgba(255, 236, 164, 0.06);\n }\n \n .slider {\n@@ -112,10 +115,8 @@ pre, .rustdoc.source .example-wrap {\n \tcolor: #ff7733;\n }\n \n-.src-line-numbers span { color: #5c6773; }\n .src-line-numbers .line-highlighted {\n \tcolor: #708090;\n-\tbackground-color: rgba(255, 236, 164, 0.06);\n \tpadding-right: 4px;\n \tborder-right: 1px solid #ffb44c;\n }\n@@ -170,13 +171,6 @@ details.rustdoc-toggle > summary::before {\n \tcolor: #788797;\n }\n \n-.src-line-numbers :target { background-color: transparent; }\n-\n-pre.example-line-numbers {\n-\tcolor: #5c67736e;\n-\tborder: none;\n-}\n-\n a.test-arrow {\n \tfont-size: 100%;\n \tcolor: #788797;"}, {"sha": "361d3d4a22597f985247b5f6ca56b67b3d242b04", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -50,6 +50,9 @@\n \t--code-highlight-question-mark-color: #ff9011;\n \t--code-highlight-comment-color: #8d8d8b;\n \t--code-highlight-doc-comment-color: #8ca375;\n+\t--example-line-numbers-border-color: #4a4949;\n+\t--src-line-numbers-span-color: #3b91e2;\n+\t--src-line-number-highlighted-background-color: #0a042f;\n }\n \n .slider {\n@@ -69,11 +72,6 @@ input:focus + .slider {\n \t\tdrop-shadow(0 -1px 0 #fff)\n }\n \n-.src-line-numbers span { color: #3B91E2; }\n-.src-line-numbers .line-highlighted {\n-\tbackground-color: #0a042f !important;\n-}\n-\n .content .item-info::before { color: #ccc; }\n \n body.source .example-wrap pre.rust a {\n@@ -95,12 +93,6 @@ details.rustdoc-toggle > summary::before {\n \tfilter: invert(69%) sepia(60%) saturate(6613%) hue-rotate(184deg) brightness(100%) contrast(91%);\n }\n \n-.src-line-numbers :target { background-color: transparent; }\n-\n-pre.example-line-numbers {\n-\tborder-color: #4a4949;\n-}\n-\n a.test-arrow {\n \tcolor: #dedede;\n \tbackground-color: rgba(78, 139, 202, 0.2);"}, {"sha": "5eb4bbcf834bbd3dde3f24a70d46fe11295c239b", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -50,6 +50,9 @@\n \t--code-highlight-question-mark-color: #ff9011;\n \t--code-highlight-comment-color: #8e908c;\n \t--code-highlight-doc-comment-color: #4d4d4c;\n+\t--example-line-numbers-border-color: #c7c7c7;\n+\t--src-line-numbers-span-color: #c67e2d;\n+\t--src-line-number-highlighted-background-color: #fdffd3;\n }\n \n .slider {\n@@ -68,11 +71,6 @@ input:focus + .slider {\n \t */\n }\n \n-.src-line-numbers span { color: #c67e2d; }\n-.src-line-numbers .line-highlighted {\n-\tbackground-color: #FDFFD3 !important;\n-}\n-\n .content .item-info::before { color: #ccc; }\n \n body.source .example-wrap pre.rust a {\n@@ -90,12 +88,6 @@ body.source .example-wrap pre.rust a {\n \tfilter: invert(44%) sepia(18%) saturate(23%) hue-rotate(317deg) brightness(96%) contrast(93%);\n }\n \n-.src-line-numbers :target { background-color: transparent; }\n-\n-pre.example-line-numbers {\n-\tborder-color: #c7c7c7;\n-}\n-\n a.test-arrow {\n \tcolor: #f5f5f5;\n \tbackground-color: rgba(78, 139, 202, 0.2);"}, {"sha": "33480fa41cf07767448a30d3d11af6e144715be9", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -932,7 +932,7 @@ function loadCss(cssFileName) {\n      * Hide all the popover menus.\n      */\n     window.hidePopoverMenus = function() {\n-        onEachLazy(document.querySelectorAll(\".search-container .popover\"), elem => {\n+        onEachLazy(document.querySelectorAll(\".search-form .popover\"), elem => {\n             elem.style.display = \"none\";\n         });\n     };"}, {"sha": "c3238691687899cc9dafea69e41bb2e095323b43", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -115,24 +115,22 @@ <h2></h2> {#- -#}\n                 </a> {#- -#}\n                 {%- endif -%}\n                 <form class=\"search-form\"> {#- -#}\n-                    <div class=\"search-container\"> {#- -#}\n-                        <span></span> {#- This empty span is a hacky fix for Safari - See #93184 -#}\n-                        <input {# -#}\n-                            class=\"search-input\" {# -#}\n-                            name=\"search\" {# -#}\n-                            autocomplete=\"off\" {# -#}\n-                            spellcheck=\"false\" {# -#}\n-                            placeholder=\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\" {# -#}\n-                            type=\"search\"> {#- -#}\n-                        <div id=\"help-button\" title=\"help\" tabindex=\"-1\"> {#- -#}\n-                            <a href=\"{{page.root_path|safe}}help.html\">?</a> {#- -#}\n-                        </div> {#- -#}\n-                        <div id=\"settings-menu\" tabindex=\"-1\"> {#- -#}\n-                            <a href=\"{{page.root_path|safe}}settings.html\" title=\"settings\"> {#- -#}\n-                                <img width=\"22\" height=\"22\" alt=\"Change settings\" {# -#}\n-                                 src=\"{{static_root_path|safe}}wheel{{page.resource_suffix}}.svg\"> {#- -#}\n-                            </a> {#- -#}\n-                        </div> {#- -#}\n+                    <span></span> {#- This empty span is a hacky fix for Safari - See #93184 -#}\n+                    <input {# -#}\n+                        class=\"search-input\" {# -#}\n+                        name=\"search\" {# -#}\n+                        autocomplete=\"off\" {# -#}\n+                        spellcheck=\"false\" {# -#}\n+                        placeholder=\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\" {# -#}\n+                        type=\"search\"> {#- -#}\n+                    <div id=\"help-button\" title=\"help\" tabindex=\"-1\"> {#- -#}\n+                        <a href=\"{{page.root_path|safe}}help.html\">?</a> {#- -#}\n+                    </div> {#- -#}\n+                    <div id=\"settings-menu\" tabindex=\"-1\"> {#- -#}\n+                        <a href=\"{{page.root_path|safe}}settings.html\" title=\"settings\"> {#- -#}\n+                            <img width=\"22\" height=\"22\" alt=\"Change settings\" {# -#}\n+                             src=\"{{static_root_path|safe}}wheel{{page.resource_suffix}}.svg\"> {#- -#}\n+                        </a> {#- -#}\n                     </div> {#- -#}\n                 </form> {#- -#}\n             </nav> {#- -#}"}, {"sha": "7740c6d5bbbb8b8b7d0b5d2a3e640164592a7921", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -56,7 +56,7 @@ impl crate::doctest::Tester for Tests {\n }\n \n pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if !cx.cache.access_levels.is_public(item.item_id.expect_def_id())\n+    if !cx.cache.effective_visibilities.is_directly_public(item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n             clean::StructFieldItem(_)\n@@ -130,7 +130,7 @@ pub(crate) fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item\n             );\n         }\n     } else if tests.found_tests > 0\n-        && !cx.cache.access_levels.is_exported(item.item_id.expect_def_id())\n+        && !cx.cache.effective_visibilities.is_exported(item.item_id.expect_def_id())\n     {\n         cx.tcx.struct_span_lint_hir(\n             crate::lint::PRIVATE_DOC_TESTS,"}, {"sha": "8aa0abd369cd504ef68c1990b0b44f076eef32ee", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1202,8 +1202,8 @@ impl LinkCollector<'_, '_> {\n                 item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n             })\n         {\n-            if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n-                && !self.cx.tcx.privacy_access_levels(()).is_exported(dst_id)\n+            if self.cx.tcx.effective_visibilities(()).is_exported(src_id)\n+                && !self.cx.tcx.effective_visibilities(()).is_exported(dst_id)\n             {\n                 privacy_error(self.cx, diag_info, path_str);\n             }"}, {"sha": "a89ed7c7ed4546082e8d407d784efe92f41396bd", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -184,7 +184,60 @@ fn extract_html_tag(\n                     }\n                     drop_tag(tags, tag_name, r, f);\n                 } else {\n-                    tags.push((tag_name, r));\n+                    let mut is_self_closing = false;\n+                    let mut quote_pos = None;\n+                    if c != '>' {\n+                        let mut quote = None;\n+                        let mut after_eq = false;\n+                        for (i, c) in text[pos..].char_indices() {\n+                            if !c.is_whitespace() {\n+                                if let Some(q) = quote {\n+                                    if c == q {\n+                                        quote = None;\n+                                        quote_pos = None;\n+                                        after_eq = false;\n+                                    }\n+                                } else if c == '>' {\n+                                    break;\n+                                } else if c == '/' && !after_eq {\n+                                    is_self_closing = true;\n+                                } else {\n+                                    if is_self_closing {\n+                                        is_self_closing = false;\n+                                    }\n+                                    if (c == '\"' || c == '\\'') && after_eq {\n+                                        quote = Some(c);\n+                                        quote_pos = Some(pos + i);\n+                                    } else if c == '=' {\n+                                        after_eq = true;\n+                                    }\n+                                }\n+                            } else if quote.is_none() {\n+                                after_eq = false;\n+                            }\n+                        }\n+                    }\n+                    if let Some(quote_pos) = quote_pos {\n+                        let qr = Range { start: quote_pos, end: quote_pos };\n+                        f(\n+                            &format!(\"unclosed quoted HTML attribute on tag `{}`\", tag_name),\n+                            &qr,\n+                            false,\n+                        );\n+                    }\n+                    if is_self_closing {\n+                        // https://html.spec.whatwg.org/#parse-error-non-void-html-element-start-tag-with-trailing-solidus\n+                        let valid = ALLOWED_UNCLOSED.contains(&&tag_name[..])\n+                            || tags.iter().take(pos + 1).any(|(at, _)| {\n+                                let at = at.to_lowercase();\n+                                at == \"svg\" || at == \"math\"\n+                            });\n+                        if !valid {\n+                            f(&format!(\"invalid self-closing HTML tag `{}`\", tag_name), &r, false);\n+                        }\n+                    } else {\n+                        tags.push((tag_name, r));\n+                    }\n                 }\n             }\n             break;"}, {"sha": "450f69e15d1affc8d63c1518503d1e05eea34749", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) ->\n     {\n         let mut stripper = Stripper {\n             retained: &mut retained,\n-            access_levels: &cx.cache.access_levels,\n+            effective_visibilities: &cx.cache.effective_visibilities,\n             update_retained: true,\n             is_json_output,\n         };"}, {"sha": "0089ce63d07ba0c801a401a205cd1a5e6c5665ea", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,15 +1,17 @@\n //! A collection of utility functions for the `strip_*` passes.\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_middle::middle::privacy::EffectiveVisibilities;\n+use rustc_span::symbol::sym;\n+\n use std::mem;\n \n-use crate::clean::{self, Item, ItemId, ItemIdSet};\n+use crate::clean::{self, Item, ItemId, ItemIdSet, NestedAttributesExt};\n use crate::fold::{strip_item, DocFolder};\n use crate::formats::cache::Cache;\n \n pub(crate) struct Stripper<'a> {\n     pub(crate) retained: &'a mut ItemIdSet,\n-    pub(crate) access_levels: &'a AccessLevels<DefId>,\n+    pub(crate) effective_visibilities: &'a EffectiveVisibilities<DefId>,\n     pub(crate) update_retained: bool,\n     pub(crate) is_json_output: bool,\n }\n@@ -20,13 +22,13 @@ pub(crate) struct Stripper<'a> {\n #[inline]\n fn is_item_reachable(\n     is_json_output: bool,\n-    access_levels: &AccessLevels<DefId>,\n+    effective_visibilities: &EffectiveVisibilities<DefId>,\n     item_id: ItemId,\n ) -> bool {\n     if is_json_output {\n-        access_levels.is_reachable(item_id.expect_def_id())\n+        effective_visibilities.is_reachable(item_id.expect_def_id())\n     } else {\n-        access_levels.is_exported(item_id.expect_def_id())\n+        effective_visibilities.is_exported(item_id.expect_def_id())\n     }\n }\n \n@@ -64,7 +66,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 let item_id = i.item_id;\n                 if item_id.is_local()\n-                    && !is_item_reachable(self.is_json_output, self.access_levels, item_id)\n+                    && !is_item_reachable(self.is_json_output, self.effective_visibilities, item_id)\n                 {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n@@ -151,6 +153,22 @@ pub(crate) struct ImplStripper<'a> {\n     pub(crate) document_private: bool,\n }\n \n+impl<'a> ImplStripper<'a> {\n+    #[inline]\n+    fn should_keep_impl(&self, item: &Item, for_def_id: DefId) -> bool {\n+        if !for_def_id.is_local() || self.retained.contains(&for_def_id.into()) {\n+            true\n+        } else if self.is_json_output {\n+            // If the \"for\" item is exported and the impl block isn't `#[doc(hidden)]`, then we\n+            // need to keep it.\n+            self.cache.effective_visibilities.is_exported(for_def_id)\n+                && !item.attrs.lists(sym::doc).has_word(sym::hidden)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = *i.kind {\n@@ -168,7 +186,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                         item_id.is_local()\n                             && !is_item_reachable(\n                                 self.is_json_output,\n-                                &self.cache.access_levels,\n+                                &self.cache.effective_visibilities,\n                                 item_id,\n                             )\n                     })\n@@ -178,23 +196,25 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                     return None;\n                 }\n             }\n+            // Because we don't inline in `maybe_inline_local` if the output format is JSON,\n+            // we need to make a special check for JSON output: we want to keep it unless it has\n+            // a `#[doc(hidden)]` attribute if the `for_` type is exported.\n             if let Some(did) = imp.for_.def_id(self.cache) {\n-                if did.is_local() && !imp.for_.is_assoc_ty() && !self.retained.contains(&did.into())\n-                {\n+                if !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did) {\n                     debug!(\"ImplStripper: impl item for stripped type; removing\");\n                     return None;\n                 }\n             }\n             if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) {\n-                if did.is_local() && !self.retained.contains(&did.into()) {\n+                if !self.should_keep_impl(&i, did) {\n                     debug!(\"ImplStripper: impl item for stripped trait; removing\");\n                     return None;\n                 }\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n                     if let Some(did) = typaram.def_id(self.cache) {\n-                        if did.is_local() && !self.retained.contains(&did.into()) {\n+                        if !self.should_keep_impl(&i, did) {\n                             debug!(\n                                 \"ImplStripper: stripped item in trait's generics; removing impl\"\n                             );"}, {"sha": "06dffce555f956579444c0cecb90ea956906966e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_middle::middle::privacy::AccessLevel;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::ty::{TyCtxt, Visibility};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -230,10 +230,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     } else {\n                         // All items need to be handled here in case someone wishes to link\n                         // to them with intra-doc links\n-                        self.cx.cache.access_levels.set_access_level(\n+                        self.cx.cache.effective_visibilities.set_public_at_level(\n                             did,\n                             || Visibility::Restricted(CRATE_DEF_ID),\n-                            AccessLevel::Public,\n+                            Level::Direct,\n                         );\n                     }\n                 }\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false,\n         };\n \n-        let is_private = !self.cx.cache.access_levels.is_public(res_did);\n+        let is_private = !self.cx.cache.effective_visibilities.is_directly_public(res_did);\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n@@ -295,11 +295,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n \n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let is_pub = self.cx.tcx.visibility(def_id).is_public();\n \n         if is_pub {\n-            self.store_path(item.def_id.to_def_id());\n+            self.store_path(item.owner_id.to_def_id());\n         }\n \n         match item.kind {\n@@ -360,7 +360,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // 3. We're inlining, since a reexport where inlining has been requested\n                 //    should be inlined even if it is also documented at the top level.\n \n-                let def_id = item.def_id.to_def_id();\n+                let def_id = item.owner_id.to_def_id();\n                 let is_macro_2_0 = !macro_def.macro_rules;\n                 let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n \n@@ -405,7 +405,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n-        if !self.inlining || self.cx.tcx.visibility(item.def_id).is_public() {\n+        if !self.inlining || self.cx.tcx.visibility(item.owner_id).is_public() {\n             om.foreigns.push((item, renamed));\n         }\n     }"}, {"sha": "70214e2adba463e7b34cee03e96c64d032dbd930", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_ID};\n-use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::ty::{TyCtxt, Visibility};\n \n // FIXME: this may not be exhaustive, but is sufficient for rustdocs current uses\n@@ -10,10 +10,10 @@ use rustc_middle::ty::{TyCtxt, Visibility};\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n pub(crate) struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    // Accessibility levels for reachable nodes\n-    access_levels: &'a mut AccessLevels<DefId>,\n-    // Previous accessibility level, None means unreachable\n-    prev_level: Option<AccessLevel>,\n+    // Effective visibilities for reachable nodes\n+    effective_visibilities: &'a mut EffectiveVisibilities<DefId>,\n+    // Previous level, None means unreachable\n+    prev_level: Option<Level>,\n     // Keeps track of already visited modules, in case a module re-exports its parent\n     visited_mods: FxHashSet<DefId>,\n }\n@@ -22,26 +22,26 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             tcx: cx.tcx,\n-            access_levels: &mut cx.cache.access_levels,\n-            prev_level: Some(AccessLevel::Public),\n+            effective_visibilities: &mut cx.cache.effective_visibilities,\n+            prev_level: Some(Level::Direct),\n             visited_mods: FxHashSet::default(),\n         }\n     }\n \n     pub(crate) fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = cnum.as_def_id();\n-        self.update(did, Some(AccessLevel::Public));\n+        self.update(did, Some(Level::Direct));\n         self.visit_mod(did);\n     }\n \n     // Updates node level and returns the updated level\n-    fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+    fn update(&mut self, did: DefId, level: Option<Level>) -> Option<Level> {\n         let is_hidden = self.tcx.is_doc_hidden(did);\n \n-        let old_level = self.access_levels.get_access_level(did);\n-        // Accessibility levels can only grow\n+        let old_level = self.effective_visibilities.public_at_level(did);\n+        // Visibility levels can only grow\n         if level > old_level && !is_hidden {\n-            self.access_levels.set_access_level(\n+            self.effective_visibilities.set_public_at_level(\n                 did,\n                 || Visibility::Restricted(CRATE_DEF_ID),\n                 level.unwrap(),"}, {"sha": "4bc91fc4030e228dcd86b20a544e2b5db4ed3807", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -51,6 +51,11 @@ pub struct ItemSummary {\n     pub crate_id: u32,\n     /// The list of path components for the fully qualified path of this item (e.g.\n     /// `[\"std\", \"io\", \"lazy\", \"Lazy\"]` for `std::io::lazy::Lazy`).\n+    ///\n+    /// Note that items can appear in multiple paths, and the one chosen is implementation\n+    /// defined. Currenty, this is the full path to where the item was defined. Eg\n+    /// [`String`] is currently `[\"alloc\", \"string\", \"String\"]` and [`HashMap`] is\n+    /// `[\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"]`, but this is subject to change.\n     pub path: Vec<String>,\n     /// Whether this item is a struct, trait, macro, etc.\n     pub kind: ItemKind,"}, {"sha": "19d83f0eee7c472b8b2339560cd029dfc2c4dbe4", "filename": "src/test/codegen/mir-inlined-line-numbers.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fcodegen%2Fmir-inlined-line-numbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fcodegen%2Fmir-inlined-line-numbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmir-inlined-line-numbers.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,25 @@\n+// compile-flags: -O -g\n+\n+#![crate_type = \"lib\"]\n+\n+#[inline(always)]\n+fn foo() {\n+    bar();\n+}\n+\n+#[inline(never)]\n+#[no_mangle]\n+fn bar() {\n+    panic!();\n+}\n+\n+#[no_mangle]\n+pub fn example() {\n+    foo();\n+}\n+\n+// CHECK-LABEL: @example\n+// CHECK:   tail call void @bar(), !dbg [[DBG_ID:![0-9]+]]\n+// CHECK: [[DBG_ID]] = !DILocation(line: 7,\n+// CHECK-SAME:                     inlinedAt: [[INLINE_ID:![0-9]+]])\n+// CHECK: [[INLINE_ID]] = !DILocation(line: 18,"}, {"sha": "50fca7f24e616d70b91028681ca0c901810987fc", "filename": "src/test/run-make-fulldeps/foreign-rust-exceptions/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2FMakefile?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,11 @@\n+# ignore-i686-pc-windows-gnu\n+\n+# This test doesn't work on 32-bit MinGW as cdylib has its own copy of unwinder\n+# so cross-DLL unwinding does not work.\n+\n+include ../tools.mk\n+\n+all:\n+\t$(RUSTC) bar.rs --crate-type=cdylib\n+\t$(RUSTC) foo.rs\n+\t$(call RUN,foo) 2>&1 | $(CGREP) \"Rust cannot catch foreign exceptions\""}, {"sha": "5f9efe323609b8d857fb90de218fcfb93e72ba42", "filename": "src/test/run-make-fulldeps/foreign-rust-exceptions/bar.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Fbar.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,7 @@\n+#![crate_type = \"cdylib\"]\n+#![feature(c_unwind)]\n+\n+#[no_mangle]\n+extern \"C-unwind\" fn panic() {\n+    panic!();\n+}"}, {"sha": "266987c5b6d63b117c1deeeb37535b917e52730e", "filename": "src/test/run-make-fulldeps/foreign-rust-exceptions/foo.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Ffoo.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,13 @@\n+#![feature(c_unwind)]\n+\n+#[cfg_attr(not(windows), link(name = \"bar\"))]\n+#[cfg_attr(windows, link(name = \"bar.dll\"))]\n+extern \"C-unwind\" {\n+    fn panic();\n+}\n+\n+fn main() {\n+    let _ = std::panic::catch_unwind(|| {\n+        unsafe { panic() };\n+    });\n+}"}, {"sha": "a6c60df83a63c7b9fb9e011ab40fc2a4210a8087", "filename": "src/test/run-make-fulldeps/obtain-borrowck/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -69,25 +69,25 @@ impl rustc_driver::Callbacks for CompilerCalls {\n \n             let crate_items = tcx.hir_crate_items(());\n             for id in crate_items.items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::Fn) {\n-                    bodies.push(id.def_id);\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Fn) {\n+                    bodies.push(id.owner_id);\n                 }\n             }\n \n             for id in crate_items.trait_items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::AssocFn) {\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::AssocFn) {\n                     let trait_item = hir.trait_item(id);\n                     if let rustc_hir::TraitItemKind::Fn(_, trait_fn) = &trait_item.kind {\n                         if let rustc_hir::TraitFn::Provided(_) = trait_fn {\n-                            bodies.push(trait_item.def_id);\n+                            bodies.push(trait_item.owner_id);\n                         }\n                     }\n                 }\n             }\n \n             for id in crate_items.impl_items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::AssocFn) {\n-                    bodies.push(id.def_id);\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::AssocFn) {\n+                    bodies.push(id.owner_id);\n                 }\n             }\n "}, {"sha": "efe0cb15f08a08bbd0543f937a5f534e4081c7be", "filename": "src/test/rustdoc-gui/notable-trait.goml", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fnotable-trait.goml?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -24,7 +24,23 @@ assert-position: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n     {\"x\": 951},\n )\n-\n+// The tooltip should be beside the `i`\n+click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\"\n+compare-elements-position-near: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    {\"y\": 2}\n+)\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    (\"x\")\n+)\n+// The docblock should be flush with the border.\n+assert-css: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']/*[@class='docblock']\",\n+    {\"margin-left\": \"0px\"}\n+)\n \n // Now only the `i` should be on the next line.\n size: (1055, 600)\n@@ -81,6 +97,27 @@ assert-position: (\n     \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n     {\"x\": 289},\n )\n+// The tooltip should be below `i`\n+compare-elements-position-near-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    {\"y\": 2}\n+)\n+compare-elements-position-false: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits']\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    (\"x\")\n+)\n+compare-elements-position-near: (\n+    \"//*[@id='method.create_an_iterator_from_read']/parent::*\",\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']\",\n+    {\"x\": 5}\n+)\n+// The docblock should be flush with the border.\n+assert-css: (\n+    \"//*[@id='method.create_an_iterator_from_read']//*[@class='notable-traits-tooltiptext force-tooltip']/*[@class='docblock']\",\n+    {\"margin-left\": \"0px\"}\n+)\n \n // Checking on very small mobile. The `i` should be on its own line.\n size: (365, 600)"}, {"sha": "a2dac2aa681d553058bb1c9397afa492d55533f4", "filename": "src/test/rustdoc-gui/source-code-page.goml", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsource-code-page.goml?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,5 +1,6 @@\n // Checks that the interactions with the source code pages are working as expected.\n goto: \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html\"\n+show-text: true\n // Check that we can click on the line number.\n click: \".src-line-numbers > span:nth-child(4)\" // This is the span for line 4.\n // Ensure that the page URL was updated.\n@@ -12,6 +13,48 @@ assert-attribute: (\".src-line-numbers > span:nth-child(4)\", {\"class\": \"line-high\n assert-attribute: (\".src-line-numbers > span:nth-child(5)\", {\"class\": \"line-highlighted\"})\n assert-attribute: (\".src-line-numbers > span:nth-child(6)\", {\"class\": \"line-highlighted\"})\n assert-attribute-false: (\".src-line-numbers > span:nth-child(7)\", {\"class\": \"line-highlighted\"})\n+\n+define-function: (\n+    \"check-colors\",\n+    (theme, color, background_color, highlight_color, highlight_background_color),\n+    [\n+        (\"local-storage\", {\"rustdoc-theme\": |theme|, \"rustdoc-use-system-theme\": \"false\"}),\n+        (\"reload\"),\n+        (\"assert-css\", (\n+            \".src-line-numbers > span:not(.line-highlighted)\",\n+            {\"color\": |color|, \"background-color\": |background_color|},\n+            ALL,\n+        )),\n+        (\"assert-css\", (\n+            \".src-line-numbers > span.line-highlighted\",\n+            {\"color\": |highlight_color|, \"background-color\": |highlight_background_color|},\n+            ALL,\n+        )),\n+    ],\n+)\n+\n+call-function: (\"check-colors\", {\n+    \"theme\": \"ayu\",\n+    \"color\": \"rgb(92, 103, 115)\",\n+    \"background_color\": \"rgba(0, 0, 0, 0)\",\n+    \"highlight_color\": \"rgb(112, 128, 144)\",\n+    \"highlight_background_color\": \"rgba(255, 236, 164, 0.06)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"dark\",\n+    \"color\": \"rgb(59, 145, 226)\",\n+    \"background_color\": \"rgba(0, 0, 0, 0)\",\n+    \"highlight_color\": \"rgb(59, 145, 226)\",\n+    \"highlight_background_color\": \"rgb(10, 4, 47)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"light\",\n+    \"color\": \"rgb(198, 126, 45)\",\n+    \"background_color\": \"rgba(0, 0, 0, 0)\",\n+    \"highlight_color\": \"rgb(198, 126, 45)\",\n+    \"highlight_background_color\": \"rgb(253, 255, 211)\",\n+})\n+\n // This is to ensure that the content is correctly align with the line numbers.\n compare-elements-position: (\"//*[@id='1']\", \".rust > code > span\", (\"y\"))\n \n@@ -20,7 +63,6 @@ assert-css: (\".src-line-numbers\", {\"text-align\": \"right\"})\n \n // Now let's check that clicking on something else than the line number doesn't\n // do anything (and certainly not add a `#NaN` to the URL!).\n-show-text: true\n goto: \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html\"\n // We use this assert-position to know where we will click.\n assert-position: (\"//*[@id='1']\", {\"x\": 104, \"y\": 112})"}, {"sha": "239b1a23b43d7e0e8c017cd8b5b2d40246c64861", "filename": "src/test/rustdoc-json/reexport/reexport_method_from_private_module.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-json%2Freexport%2Freexport_method_from_private_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-json%2Freexport%2Freexport_method_from_private_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Freexport_method_from_private_module.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/102583>.\n+\n+// @set impl_S = \"$.index[*][?(@.docs=='impl S')].id\"\n+// @has \"$.index[*][?(@.name=='S')].inner.impls[*]\" $impl_S\n+// @set is_present = \"$.index[*][?(@.name=='is_present')].id\"\n+// @is \"$.index[*][?(@.docs=='impl S')].inner.items[*]\" $is_present\n+// @!has \"$.index[*][?(@.name=='hidden_impl')]\"\n+// @!has \"$.index[*][?(@.name=='hidden_fn')]\"\n+\n+#![no_std]\n+\n+mod private_mod {\n+    pub struct S;\n+\n+    /// impl S\n+    impl S {\n+        pub fn is_present() {}\n+        #[doc(hidden)]\n+        pub fn hidden_fn() {}\n+    }\n+\n+    #[doc(hidden)]\n+    impl S {\n+        pub fn hidden_impl() {}\n+    }\n+}\n+\n+pub use private_mod::*;"}, {"sha": "d973a53cbc7cea9d5cddfa83438d3f0bbf3435af", "filename": "src/test/rustdoc-ui/invalid-html-self-closing-tag.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,70 @@\n+#![deny(rustdoc::invalid_html_tags)]\n+\n+/// <p/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct A;\n+\n+/// <p style/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct B;\n+\n+/// <p style=\"\"/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct C;\n+\n+/// <p style=\"x\"/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct D;\n+\n+/// <p style=\"x/></p>\n+//~^ ERROR unclosed quoted HTML attribute\n+pub struct E;\n+\n+/// <p style='x/></p>\n+//~^ ERROR unclosed quoted HTML attribute\n+pub struct F;\n+\n+/// <p style=\"x/\"></p>\n+pub struct G;\n+\n+/// <p style=\"x/\"/>\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct H;\n+\n+/// <p / >\n+//~^ ERROR invalid self-closing HTML tag `p`\n+pub struct I;\n+\n+/// <br/>\n+pub struct J;\n+\n+/// <a href=/></a>\n+pub struct K;\n+\n+/// <a href=//></a>\n+pub struct L;\n+\n+/// <a href=\"/\"/>\n+//~^ ERROR invalid self-closing HTML tag `a`\n+pub struct M;\n+\n+/// <a href=x />\n+//~^ ERROR invalid self-closing HTML tag `a`\n+pub struct N;\n+\n+/// <a href= />\n+//~^ ERROR invalid self-closing HTML tag `a`\n+pub struct O;\n+\n+/// <a href=x/></a>\n+pub struct P;\n+\n+/// <svg><rect width=1 height=1 /></svg>\n+pub struct Q;\n+\n+/// <svg><rect width=1 height=/></svg>\n+//~^ ERROR unclosed HTML tag `rect`\n+pub struct R;\n+\n+/// <svg / q>\n+pub struct S;"}, {"sha": "e45edfb43ff8e7f1c481014a85e5de3a0447a461", "filename": "src/test/rustdoc-ui/invalid-html-self-closing-tag.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-html-self-closing-tag.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,80 @@\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:3:5\n+   |\n+LL | /// <p/>\n+   |     ^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/invalid-html-self-closing-tag.rs:1:9\n+   |\n+LL | #![deny(rustdoc::invalid_html_tags)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:7:5\n+   |\n+LL | /// <p style/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:11:5\n+   |\n+LL | /// <p style=\"\"/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:15:5\n+   |\n+LL | /// <p style=\"x\"/>\n+   |     ^^\n+\n+error: unclosed quoted HTML attribute on tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:19:14\n+   |\n+LL | /// <p style=\"x/></p>\n+   |              ^\n+\n+error: unclosed quoted HTML attribute on tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:23:14\n+   |\n+LL | /// <p style='x/></p>\n+   |              ^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:30:5\n+   |\n+LL | /// <p style=\"x/\"/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `p`\n+  --> $DIR/invalid-html-self-closing-tag.rs:34:5\n+   |\n+LL | /// <p / >\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `a`\n+  --> $DIR/invalid-html-self-closing-tag.rs:47:5\n+   |\n+LL | /// <a href=\"/\"/>\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `a`\n+  --> $DIR/invalid-html-self-closing-tag.rs:51:5\n+   |\n+LL | /// <a href=x />\n+   |     ^^\n+\n+error: invalid self-closing HTML tag `a`\n+  --> $DIR/invalid-html-self-closing-tag.rs:55:5\n+   |\n+LL | /// <a href= />\n+   |     ^^\n+\n+error: unclosed HTML tag `rect`\n+  --> $DIR/invalid-html-self-closing-tag.rs:65:10\n+   |\n+LL | /// <svg><rect width=1 height=/></svg>\n+   |          ^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "a473e467473eb3fc4ea89f6661a4673b569b9d81", "filename": "src/test/rustdoc/async-trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fasync-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fasync-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-trait.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:async-trait-dep.rs\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+extern crate async_trait_dep;\n+\n+pub struct Oink {}\n+\n+// @has 'async_trait/struct.Oink.html' '//h4[@class=\"code-header\"]' \"async fn woof()\"\n+impl async_trait_dep::Meow for Oink {\n+    async fn woof() {\n+        todo!()\n+    }\n+}"}, {"sha": "10a55dd0260efaf2fddf675c92ce12cd5e27b75b", "filename": "src/test/rustdoc/auxiliary/async-trait-dep.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fasync-trait-dep.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,9 @@\n+// edition:2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+pub trait Meow {\n+    /// Who's a good dog?\n+    async fn woof();\n+}"}, {"sha": "3d722d5e0c2e2a59f74d40d3a469822647edde1b", "filename": "src/test/rustdoc/auxiliary/masked.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmasked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmasked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fmasked.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -8,3 +8,7 @@ pub trait MaskedTrait {\n impl MaskedTrait for String {\n     fn masked_method() {}\n }\n+\n+pub trait MaskedBlanketTrait {}\n+\n+impl<T> MaskedBlanketTrait for T {}"}, {"sha": "3400717eba1e616a2c23a49cd7c5122f4bcfc09d", "filename": "src/test/rustdoc/auxiliary/reexport-doc-aux.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fauxiliary%2Freexport-doc-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fauxiliary%2Freexport-doc-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Freexport-doc-aux.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,5 @@\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn foo() {}\n+}"}, {"sha": "3fb00c7db84115b3661fd87b6ac4a3e5f9305f7b", "filename": "src/test/rustdoc/doc-notable_trait_box_is_not_an_iterator.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fdoc-notable_trait_box_is_not_an_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fdoc-notable_trait_box_is_not_an_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-notable_trait_box_is_not_an_iterator.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,38 @@\n+#![feature(doc_notable_trait)]\n+#![feature(lang_items)]\n+#![feature(no_core)]\n+#![no_core]\n+#[lang = \"owned_box\"]\n+pub struct Box<T>;\n+\n+impl<T> Box<T> {\n+    pub fn new(x: T) -> Box<T> {\n+        Box\n+    }\n+}\n+\n+#[doc(notable_trait)]\n+pub trait FakeIterator {}\n+\n+impl<I: FakeIterator> FakeIterator for Box<I> {}\n+\n+#[lang = \"pin\"]\n+pub struct Pin<T>;\n+\n+impl<T> Pin<T> {\n+    pub fn new(x: T) -> Pin<T> {\n+        Pin\n+    }\n+}\n+\n+impl<I: FakeIterator> FakeIterator for Pin<I> {}\n+\n+// @!has doc_notable_trait_box_is_not_an_iterator/fn.foo.html '//*' 'Notable'\n+pub fn foo<T>(x: T) -> Box<T> {\n+    Box::new(x)\n+}\n+\n+// @!has doc_notable_trait_box_is_not_an_iterator/fn.bar.html '//*' 'Notable'\n+pub fn bar<T>(x: T) -> Pin<T> {\n+    Pin::new(x)\n+}"}, {"sha": "875c026fd058a48088a435b2aa6739c3c24f81fb", "filename": "src/test/rustdoc/masked.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fmasked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Fmasked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmasked.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -10,6 +10,7 @@ extern crate masked;\n // @!hasraw 'search-index.js' 'masked_method'\n \n // @!hasraw 'foo/struct.String.html' 'MaskedTrait'\n+// @!hasraw 'foo/struct.String.html' 'MaskedBlanketTrait'\n // @!hasraw 'foo/struct.String.html' 'masked_method'\n pub use std::string::String;\n "}, {"sha": "df2c889b4d57492ab64d2b3577c92b94c4d8460a", "filename": "src/test/rustdoc/reexport-doc.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Freexport-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Frustdoc%2Freexport-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freexport-doc.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,8 @@\n+// aux-build:reexport-doc-aux.rs\n+\n+extern crate reexport_doc_aux as dep;\n+\n+// @has 'reexport_doc/struct.Foo.html'\n+// @count - '//p' 'These are the docs for Foo.' 1\n+/// These are the docs for Foo.\n+pub use dep::Foo;"}, {"sha": "ca77e483d6ff8dd233fd2327e7aeb45a397f47a7", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -758,3 +758,41 @@ struct WithDocComment {\n     #[primary_span]\n     span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsGood {\n+    #[suggestion(code(\"foo\", \"bar\"))]\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsSingleItem {\n+    #[suggestion(code(\"foo\"))]\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsNoItem {\n+    #[suggestion(code())]\n+    //~^ ERROR expected at least one string literal for `code(...)`\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsInvalidItem {\n+    #[suggestion(code(foo))]\n+    //~^ ERROR `code(...)` must contain only string literals\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsInvalidLiteral {\n+    #[suggestion(code = 3)]\n+    //~^ ERROR `code = \"...\"`/`code(...)` must contain only string literals\n+    sub: Span,\n+}"}, {"sha": "859c272b6ba9c3a98f3381dc93093c50dd3be53b", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -573,6 +573,24 @@ LL |     #[subdiagnostic(eager)]\n    |\n    = help: eager subdiagnostics are not supported on lints\n \n+error: expected at least one string literal for `code(...)`\n+  --> $DIR/diagnostic-derive.rs:779:18\n+   |\n+LL |     #[suggestion(code())]\n+   |                  ^^^^^^\n+\n+error: `code(...)` must contain only string literals\n+  --> $DIR/diagnostic-derive.rs:787:23\n+   |\n+LL |     #[suggestion(code(foo))]\n+   |                       ^^^\n+\n+error: `code = \"...\"`/`code(...)` must contain only string literals\n+  --> $DIR/diagnostic-derive.rs:795:18\n+   |\n+LL |     #[suggestion(code = 3)]\n+   |                  ^^^^^^^^\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n@@ -647,7 +665,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 80 previous errors\n+error: aborting due to 83 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "efec85eb52c2ec90aaa71856264e86c3d4e4e5a5", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -661,3 +661,48 @@ enum BL {\n         span: Span,\n     }\n }\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BM {\n+    #[suggestion_part(code(\"foo\"))]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BN {\n+    #[suggestion_part(code(\"foo\", \"bar\"))]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BO {\n+    #[suggestion_part(code(3))]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BP {\n+    #[suggestion_part(code())]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BQ {\n+    #[suggestion_part(code = 3)]\n+    //~^ ERROR `code = \"...\"`/`code(...)` must contain only string literals\n+    span: Span,\n+    r#type: String,\n+}"}, {"sha": "a85a8711eaca4e983cedf5948977e848446224cd", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -415,6 +415,36 @@ error: `#[applicability]` has no effect if all `#[suggestion]`/`#[multipart_sugg\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:668:23\n+   |\n+LL |     #[suggestion_part(code(\"foo\"))]\n+   |                       ^^^^^^^^^^^\n+\n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:677:23\n+   |\n+LL |     #[suggestion_part(code(\"foo\", \"bar\"))]\n+   |                       ^^^^^^^^^^^^^^^^^^\n+\n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:686:23\n+   |\n+LL |     #[suggestion_part(code(3))]\n+   |                       ^^^^^^^\n+\n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:695:23\n+   |\n+LL |     #[suggestion_part(code())]\n+   |                       ^^^^^^\n+\n+error: `code = \"...\"`/`code(...)` must contain only string literals\n+  --> $DIR/subdiagnostic-derive.rs:704:23\n+   |\n+LL |     #[suggestion_part(code = 3)]\n+   |                       ^^^^^^^^\n+\n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n    |\n@@ -475,6 +505,6 @@ error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 67 previous errors\n+error: aborting due to 72 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "77841780f621655e91b0a9e098c5560efce79507", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.oneuse.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.oneuse.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -15,19 +15,19 @@ LL |     let a = bar(f, x);\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n-  --> $DIR/project-fn-ret-invariant.rs:40:13\n+  --> $DIR/project-fn-ret-invariant.rs:42:13\n    |\n LL | fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n    |        --  -- lifetime `'b` defined here\n    |        |\n    |        lifetime `'a` defined here\n-LL |     let f = foo; // <-- No consistent type can be inferred for `f` here.\n-LL |     let a = bar(f, x);\n+...\n+LL |     let b = bar(f, y);\n    |             ^^^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n-   = note: requirement occurs because of a function pointer to `foo`\n-   = note: the function `foo` is invariant over the parameter `'a`\n+   = note: requirement occurs because of the type `Type<'_>`, which makes the generic argument `'_` invariant\n+   = note: the struct `Type<'a>` is invariant over the parameter `'a`\n    = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n help: `'a` and `'b` must be the same: replace one with the other"}, {"sha": "e043379133ab041caef74535d315b2b630cac0a2", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -39,8 +39,8 @@ fn baz<'a, 'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n     let f = foo; // <-- No consistent type can be inferred for `f` here.\n     let a = bar(f, x);\n     //[oneuse]~^ ERROR lifetime may not live long enough\n-    //[oneuse]~| ERROR lifetime may not live long enough\n     let b = bar(f, y);\n+    //[oneuse]~^ ERROR lifetime may not live long enough\n     (a, b)\n }\n "}, {"sha": "a7b872fe4444aecd4317b3671d8c58125d1a7549", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -27,7 +27,7 @@ error: future cannot be sent between threads safely\n LL |     assert_send(non_sync_with_method_call());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ future returned by `non_sync_with_method_call` is not `Send`\n    |\n-   = help: the trait `Send` is not implemented for `dyn std::fmt::Write`\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `dyn std::fmt::Write`\n note: future is not `Send` as this value is used across an await\n   --> $DIR/async-fn-nonsend.rs:46:14\n    |"}, {"sha": "a6f928f3b1bac653f2f95d4156331b090b30f3dc", "filename": "src/test/ui/async-await/in-trait/async-associated-types.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,24 @@\n+// check-fail\n+// known-bug: #102682\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n+\n+trait MyTrait<'a, 'b, T> where Self: 'a, T: Debug + Sized + 'b {\n+    type MyAssoc;\n+\n+    async fn foo(&'a self, key: &'b T) -> Self::MyAssoc;\n+}\n+\n+impl<'a, 'b, T: Debug + Sized + 'b, U: 'a> MyTrait<'a, 'b, T> for U {\n+    type MyAssoc = (&'a U, &'b T);\n+\n+    async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+        (self, key)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0985150eee0decc8fa070500d0e94fa030e875e6", "filename": "src/test/ui/async-await/in-trait/async-associated-types.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,57 @@\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+  --> $DIR/async-associated-types.rs:19:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+   |                                           ^^^^^^^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined here...\n+  --> $DIR/async-associated-types.rs:16:6\n+   |\n+LL | impl<'a, 'b, T: Debug + Sized + 'b, U: 'a> MyTrait<'a, 'b, T> for U {\n+   |      ^^\n+note: ...so that the types are compatible\n+  --> $DIR/async-associated-types.rs:19:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+   |                                           ^^^^^^^^^^^^^^\n+   = note: expected `(&'a U, &'b T)`\n+              found `(&U, &T)`\n+   = note: but, the lifetime must be valid for the static lifetime...\n+note: ...so that the types are compatible\n+  --> $DIR/async-associated-types.rs:19:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+   |                                           ^^^^^^^^^^^^^^\n+   = note: expected `MyTrait<'static, 'static, T>`\n+              found `MyTrait<'_, '_, T>`\n+\n+error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'b` due to conflicting requirements\n+  --> $DIR/async-associated-types.rs:19:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+   |                                           ^^^^^^^^^^^^^^\n+   |\n+note: first, the lifetime cannot outlive the lifetime `'b` as defined here...\n+  --> $DIR/async-associated-types.rs:16:10\n+   |\n+LL | impl<'a, 'b, T: Debug + Sized + 'b, U: 'a> MyTrait<'a, 'b, T> for U {\n+   |          ^^\n+note: ...so that the types are compatible\n+  --> $DIR/async-associated-types.rs:19:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+   |                                           ^^^^^^^^^^^^^^\n+   = note: expected `(&'a U, &'b T)`\n+              found `(&U, &T)`\n+   = note: but, the lifetime must be valid for the static lifetime...\n+note: ...so that the types are compatible\n+  --> $DIR/async-associated-types.rs:19:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+   |                                           ^^^^^^^^^^^^^^\n+   = note: expected `MyTrait<'static, 'static, T>`\n+              found `MyTrait<'_, '_, T>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0495`."}, {"sha": "e546a0579c66f2f5774bd9b98b00943575b6a259", "filename": "src/test/ui/async-await/in-trait/async-associated-types2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types2.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![feature(type_alias_impl_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+\n+trait MyTrait {\n+    type Fut<'a>: Future<Output = i32>\n+    where\n+        Self: 'a;\n+\n+    fn foo<'a>(&'a self) -> Self::Fut<'a>;\n+}\n+\n+impl MyTrait for i32 {\n+    type Fut<'a> = impl Future<Output = i32> + 'a\n+    where\n+        Self: 'a;\n+\n+    fn foo<'a>(&'a self) -> Self::Fut<'a> {\n+        async {\n+            *self\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "38ba297189c691ad05b8c4328a00fea2347a551c", "filename": "src/test/ui/async-await/in-trait/async-example-desugared-boxed-in-trait.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,21 @@\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+trait MyTrait {\n+    fn foo(&self) -> Pin<Box<dyn Future<Output = i32> + '_>>;\n+}\n+\n+impl MyTrait for i32 {\n+    async fn foo(&self) -> i32 {\n+        //~^ ERROR method `foo` has an incompatible type for trait\n+        *self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "22d2928f2f5641801c4b858ccbe6217d4aa8d830", "filename": "src/test/ui/async-await/in-trait/async-example-desugared-boxed-in-trait.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,17 @@\n+error[E0053]: method `foo` has an incompatible type for trait\n+  --> $DIR/async-example-desugared-boxed-in-trait.rs:15:28\n+   |\n+LL |     async fn foo(&self) -> i32 {\n+   |                            ^^^ expected struct `Pin`, found opaque type\n+   |\n+note: type in trait\n+  --> $DIR/async-example-desugared-boxed-in-trait.rs:11:22\n+   |\n+LL |     fn foo(&self) -> Pin<Box<dyn Future<Output = i32> + '_>>;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected fn pointer `fn(&i32) -> Pin<Box<dyn Future<Output = i32>>>`\n+              found fn pointer `fn(&i32) -> impl Future<Output = i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "61d7e2520eab7a8cea7c3f8f97fd2a932aa4d5bd", "filename": "src/test/ui/async-await/in-trait/async-example-desugared-boxed.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+trait MyTrait {\n+    async fn foo(&self) -> i32;\n+}\n+\n+impl MyTrait for i32 {\n+    // This will break once a PR that implements #102745 is merged\n+    fn foo(&self) -> Pin<Box<dyn Future<Output = i32> + '_>> {\n+        Box::pin(async {\n+            *self\n+        })\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "feeda719e0306605bce7df6e8b8d74dff26c3972", "filename": "src/test/ui/async-await/in-trait/async-example-desugared-in-trait.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-in-trait.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+\n+trait MyTrait {\n+    fn foo(&self) -> impl Future<Output = i32> + '_;\n+}\n+\n+impl MyTrait for i32 {\n+    // This will break once a PR that implements #102745 is merged\n+    async fn foo(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1313c9edd861c213850af2725cadc84f52146fed", "filename": "src/test/ui/async-await/in-trait/async-example-desugared.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+\n+trait MyTrait {\n+    async fn foo(&self) -> i32;\n+}\n+\n+impl MyTrait for i32 {\n+    // This will break once a PR that implements #102745 is merged\n+    fn foo(&self) -> impl Future<Output = i32> + '_ {\n+        async {\n+            *self\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "abf94ef7450fcfceeaf672224213af3a32e78cd6", "filename": "src/test/ui/async-await/in-trait/async-example.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-example.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait MyTrait {\n+    async fn foo(&self) -> i32;\n+    async fn bar(&self) -> i32;\n+}\n+\n+impl MyTrait for i32 {\n+    async fn foo(&self) -> i32 {\n+        *self\n+    }\n+\n+    async fn bar(&self) -> i32 {\n+        self.foo().await\n+    }\n+}\n+\n+fn main() {\n+    let x = 5;\n+    // Calling from non-async context\n+    let _ = x.foo();\n+    let _ = x.bar();\n+    // Calling from async block in non-async context\n+    async {\n+        let _: i32 = x.foo().await;\n+        let _: i32 = x.bar().await;\n+    };\n+}"}, {"sha": "a73d55adfeced13a9f9d9becb8e16d500ef4ae09", "filename": "src/test/ui/async-await/in-trait/async-generics-and-bounds.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,21 @@\n+// check-fail\n+// known-bug: #102682\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+\n+trait MyTrait<T, U> {\n+    async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n+}\n+\n+impl<T, U> MyTrait<T, U> for (T, U) {\n+    async fn foo(&self) -> &(T, U) {\n+        self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5c8d64fc6cb4c858810b1ea013dc2b3a2cb5f855", "filename": "src/test/ui/async-await/in-trait/async-generics-and-bounds.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics-and-bounds.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,37 @@\n+error[E0311]: the parameter type `U` may not live long enough\n+  --> $DIR/async-generics-and-bounds.rs:12:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n+   |                            ^^^^^^^\n+   |\n+note: the parameter type `U` must be valid for the anonymous lifetime as defined here...\n+  --> $DIR/async-generics-and-bounds.rs:12:18\n+   |\n+LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n+   |                  ^\n+note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n+  --> $DIR/async-generics-and-bounds.rs:12:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n+   |                            ^^^^^^^\n+\n+error[E0311]: the parameter type `T` may not live long enough\n+  --> $DIR/async-generics-and-bounds.rs:12:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n+   |                            ^^^^^^^\n+   |\n+note: the parameter type `T` must be valid for the anonymous lifetime as defined here...\n+  --> $DIR/async-generics-and-bounds.rs:12:18\n+   |\n+LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n+   |                  ^\n+note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n+  --> $DIR/async-generics-and-bounds.rs:12:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U) where T: Debug + Sized, U: Hash;\n+   |                            ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0311`."}, {"sha": "67000e5770ee8c2c5fa4641103777a3c52a259d6", "filename": "src/test/ui/async-await/in-trait/async-generics.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,18 @@\n+// check-fail\n+// known-bug: #102682\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait MyTrait<T, U> {\n+    async fn foo(&self) -> &(T, U);\n+}\n+\n+impl<T, U> MyTrait<T, U> for (T, U) {\n+    async fn foo(&self) -> &(T, U) {\n+        self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6ae73d9e3a60175029633c5aac78ef88e8c281da", "filename": "src/test/ui/async-await/in-trait/async-generics.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-generics.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,37 @@\n+error[E0311]: the parameter type `U` may not live long enough\n+  --> $DIR/async-generics.rs:9:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U);\n+   |                            ^^^^^^^\n+   |\n+note: the parameter type `U` must be valid for the anonymous lifetime as defined here...\n+  --> $DIR/async-generics.rs:9:18\n+   |\n+LL |     async fn foo(&self) -> &(T, U);\n+   |                  ^\n+note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n+  --> $DIR/async-generics.rs:9:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U);\n+   |                            ^^^^^^^\n+\n+error[E0311]: the parameter type `T` may not live long enough\n+  --> $DIR/async-generics.rs:9:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U);\n+   |                            ^^^^^^^\n+   |\n+note: the parameter type `T` must be valid for the anonymous lifetime as defined here...\n+  --> $DIR/async-generics.rs:9:18\n+   |\n+LL |     async fn foo(&self) -> &(T, U);\n+   |                  ^\n+note: ...so that the reference type `&(T, U)` does not outlive the data it points at\n+  --> $DIR/async-generics.rs:9:28\n+   |\n+LL |     async fn foo(&self) -> &(T, U);\n+   |                            ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0311`."}, {"sha": "3f7448cecd157fa006043471198734e2d5c56184", "filename": "src/test/ui/async-await/in-trait/async-lifetimes-and-bounds.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,20 @@\n+// check-fail\n+// known-bug: #102682\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n+\n+trait MyTrait<'a, 'b, T> {\n+    async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T) where T: Debug + Sized;\n+}\n+\n+impl<'a, 'b, T, U> MyTrait<'a, 'b, T> for U {\n+    async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+        (self, key)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0f02420274333badbcbc3d84b3c0fd159a8bdcd6", "filename": "src/test/ui/async-await/in-trait/async-lifetimes-and-bounds.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes-and-bounds.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,23 @@\n+error[E0309]: the parameter type `Self` may not live long enough\n+  --> $DIR/async-lifetimes-and-bounds.rs:11:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T) where T: Debug + Sized;\n+   |                                           ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `Self: 'a`...\n+   = note: ...so that the reference type `&'a Self` does not outlive the data it points at\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/async-lifetimes-and-bounds.rs:11:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T) where T: Debug + Sized;\n+   |                                           ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'b T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | trait MyTrait<'a, 'b, T: 'b> {\n+   |                        ++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "acbac471cf7e8638e0a989e531c4f63b6ef5f519", "filename": "src/test/ui/async-await/in-trait/async-lifetimes.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,18 @@\n+// check-fail\n+// known-bug: #102682\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait MyTrait<'a, 'b, T> {\n+    async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T);\n+}\n+\n+impl<'a, 'b, T, U> MyTrait<'a, 'b, T> for U {\n+    async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n+        (self, key)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9a7d294bb17669f6de727d113abcc4c78903e990", "filename": "src/test/ui/async-await/in-trait/async-lifetimes.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-lifetimes.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,23 @@\n+error[E0309]: the parameter type `Self` may not live long enough\n+  --> $DIR/async-lifetimes.rs:9:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T);\n+   |                                           ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `Self: 'a`...\n+   = note: ...so that the reference type `&'a Self` does not outlive the data it points at\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/async-lifetimes.rs:9:43\n+   |\n+LL |     async fn foo(&'a self, key: &'b T) -> (&'a Self, &'b T);\n+   |                                           ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'b T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | trait MyTrait<'a, 'b, T: 'b> {\n+   |                        ++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "6839abd381c3f9b3126a4038eaa83f1eb90bd0ef", "filename": "src/test/ui/async-await/in-trait/async-recursive-generic.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,21 @@\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait MyTrait<T> {\n+    async fn foo_recursive(&self, n: usize) -> T;\n+}\n+\n+impl<T> MyTrait<T> for T where T: Copy {\n+    async fn foo_recursive(&self, n: usize) -> T {\n+        //~^ ERROR recursion in an `async fn` requires boxing\n+        if n > 0 {\n+            self.foo_recursive(n - 1).await\n+        } else {\n+            *self\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "cab173bdd5b7030a508a74d04ceb1baba74aa5dc", "filename": "src/test/ui/async-await/in-trait/async-recursive-generic.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,12 @@\n+error[E0733]: recursion in an `async fn` requires boxing\n+  --> $DIR/async-recursive-generic.rs:11:48\n+   |\n+LL |     async fn foo_recursive(&self, n: usize) -> T {\n+   |                                                ^ recursive `async fn`\n+   |\n+   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n+   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0733`."}, {"sha": "61119f8095bcc0edcf2d380b3b54f827c0d4b59a", "filename": "src/test/ui/async-await/in-trait/async-recursive.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,21 @@\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait MyTrait {\n+    async fn foo_recursive(&self, n: usize) -> i32;\n+}\n+\n+impl MyTrait for i32 {\n+    async fn foo_recursive(&self, n: usize) -> i32 {\n+        //~^ ERROR recursion in an `async fn` requires boxing\n+        if n > 0 {\n+            self.foo_recursive(n - 1).await\n+        } else {\n+            *self\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9feff37b3fe46772ccebb3d3c778dd70d325fc68", "filename": "src/test/ui/async-await/in-trait/async-recursive.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,12 @@\n+error[E0733]: recursion in an `async fn` requires boxing\n+  --> $DIR/async-recursive.rs:11:48\n+   |\n+LL |     async fn foo_recursive(&self, n: usize) -> i32 {\n+   |                                                ^^^ recursive `async fn`\n+   |\n+   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n+   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0733`."}, {"sha": "f94d32145a290297c1750035ba89297ecf8220eb", "filename": "src/test/ui/async-await/in-trait/fn-not-async-err.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,17 @@\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait MyTrait {\n+    async fn foo(&self) -> i32;\n+}\n+\n+impl MyTrait for i32 {\n+    fn foo(&self) -> i32 {\n+        //~^ ERROR: `i32` is not a future [E0277]\n+        *self\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "03321dc5b5af16a4ccbd9baa3f78fb005151201b", "filename": "src/test/ui/async-await/in-trait/fn-not-async-err.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: `i32` is not a future\n+  --> $DIR/fn-not-async-err.rs:11:22\n+   |\n+LL |     fn foo(&self) -> i32 {\n+   |                      ^^^ `i32` is not a future\n+   |\n+   = help: the trait `Future` is not implemented for `i32`\n+   = note: i32 must be a future or must implement `IntoFuture` to be awaited\n+note: required by a bound in `MyTrait::foo::{opaque#0}`\n+  --> $DIR/fn-not-async-err.rs:7:28\n+   |\n+LL |     async fn foo(&self) -> i32;\n+   |                            ^^^ required by this bound in `MyTrait::foo::{opaque#0}`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "594baa91ad8ba61c21eb6914ae4c0b24e5fedd0b", "filename": "src/test/ui/async-await/in-trait/fn-not-async-err2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,21 @@\n+// edition: 2021\n+\n+#![feature(async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+\n+trait MyTrait {\n+    async fn foo(&self) -> i32;\n+}\n+\n+impl MyTrait for i32 {\n+    fn foo(&self) -> impl Future<Output = i32> {\n+        //~^ ERROR `impl Trait` only allowed in function and inherent method return types, not in `impl` method return [E0562]\n+        async {\n+            *self\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f591f184772901e061a6928067e2484df9ce552c", "filename": "src/test/ui/async-await/in-trait/fn-not-async-err2.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,12 @@\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in `impl` method return\n+  --> $DIR/fn-not-async-err2.rs:13:22\n+   |\n+LL |     fn foo(&self) -> impl Future<Output = i32> {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = help: add `#![feature(return_position_impl_trait_in_trait)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0562`."}, {"sha": "b0d38687f01c46f598132c17cbc95378a83d5f43", "filename": "src/test/ui/async-await/issue-98634.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fissue-98634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fissue-98634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-98634.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,50 @@\n+// edition: 2021\n+\n+use std::{\n+    future::Future,\n+    pin::Pin,\n+    task::{Context, Poll, Waker},\n+};\n+\n+pub struct StructAsync<F: Fn() -> Pin<Box<dyn Future<Output = ()>>>> {\n+    pub callback: F,\n+}\n+\n+impl<F> Future for StructAsync<F>\n+where\n+    F: Fn() -> Pin<Box<dyn Future<Output = ()>>>,\n+{\n+    type Output = ();\n+\n+    fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Pending\n+    }\n+}\n+\n+async fn callback() {}\n+\n+struct Runtime;\n+\n+fn waker() -> &'static Waker {\n+    todo!()\n+}\n+\n+impl Runtime {\n+    #[track_caller]\n+    pub fn block_on<F: Future>(&self, mut future: F) -> F::Output {\n+        loop {\n+            unsafe {\n+                Pin::new_unchecked(&mut future).poll(&mut Context::from_waker(waker()));\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    Runtime.block_on(async {\n+        StructAsync { callback }.await;\n+        //~^ ERROR expected `fn() -> impl Future<Output = ()> {callback}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n+        //~| ERROR expected `fn() -> impl Future<Output = ()> {callback}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n+        //~| ERROR expected `fn() -> impl Future<Output = ()> {callback}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n+    });\n+}"}, {"sha": "5160e48d88afd2d22ed62275b3ecb3bdacf7432b", "filename": "src/test/ui/async-await/issue-98634.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fissue-98634.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fissue-98634.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-98634.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,60 @@\n+error[E0271]: expected `fn() -> impl Future<Output = ()> {callback}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n+  --> $DIR/issue-98634.rs:45:23\n+   |\n+LL |         StructAsync { callback }.await;\n+   |                       ^^^^^^^^ expected struct `Pin`, found opaque type\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/issue-98634.rs:24:21\n+   |\n+LL | async fn callback() {}\n+   |                     ^ checked the `Output` of this `async fn`, found opaque type\n+   = note:   expected struct `Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n+           found opaque type `impl Future<Output = ()>`\n+note: required by a bound in `StructAsync`\n+  --> $DIR/issue-98634.rs:9:35\n+   |\n+LL | pub struct StructAsync<F: Fn() -> Pin<Box<dyn Future<Output = ()>>>> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `StructAsync`\n+\n+error[E0271]: expected `fn() -> impl Future<Output = ()> {callback}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n+  --> $DIR/issue-98634.rs:45:9\n+   |\n+LL |         StructAsync { callback }.await;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Pin`, found opaque type\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/issue-98634.rs:24:21\n+   |\n+LL | async fn callback() {}\n+   |                     ^ checked the `Output` of this `async fn`, found opaque type\n+   = note:   expected struct `Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n+           found opaque type `impl Future<Output = ()>`\n+note: required by a bound in `StructAsync`\n+  --> $DIR/issue-98634.rs:9:35\n+   |\n+LL | pub struct StructAsync<F: Fn() -> Pin<Box<dyn Future<Output = ()>>>> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `StructAsync`\n+\n+error[E0271]: expected `fn() -> impl Future<Output = ()> {callback}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n+  --> $DIR/issue-98634.rs:45:33\n+   |\n+LL |         StructAsync { callback }.await;\n+   |                                 ^^^^^^ expected struct `Pin`, found opaque type\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/issue-98634.rs:24:21\n+   |\n+LL | async fn callback() {}\n+   |                     ^ checked the `Output` of this `async fn`, found opaque type\n+   = note:   expected struct `Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n+           found opaque type `impl Future<Output = ()>`\n+note: required by a bound in `StructAsync`\n+  --> $DIR/issue-98634.rs:9:35\n+   |\n+LL | pub struct StructAsync<F: Fn() -> Pin<Box<dyn Future<Output = ()>>>> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `StructAsync`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "aa947b6900366a6d0edb25288672f866d90eba51", "filename": "src/test/ui/async-await/issues/issue-72312.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-72312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-72312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-72312.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,23 +1,22 @@\n error[E0521]: borrowed data escapes outside of associated function\n-  --> $DIR/issue-72312.rs:12:24\n+  --> $DIR/issue-72312.rs:12:9\n    |\n LL |       pub async fn start(&self) {\n    |                          -----\n    |                          |\n    |                          `self` is a reference that is only valid in the associated function body\n    |                          let's call the lifetime of this reference `'1`\n ...\n-LL |           require_static(async move {\n-   |  ________________________^\n+LL | /         require_static(async move {\n LL | |\n LL | |\n LL | |\n LL | |             &self;\n LL | |         });\n-   | |         ^\n-   | |         |\n-   | |_________`self` escapes the associated function body here\n-   |           argument requires that `'1` must outlive `'static`\n+   | |          ^\n+   | |          |\n+   | |__________`self` escapes the associated function body here\n+   |            argument requires that `'1` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "ae4d0d5853ca687569c3800263494400d435061b", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -25,7 +25,7 @@ LL | |     (a, b)\n LL | | }\n    | |_^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+help: to declare that `impl Trait<'a>` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n    |                                                                                ++++"}, {"sha": "f1fa95f92469b49fd43ef8760929b703fd9260a5", "filename": "src/test/ui/borrowck/issue-103624.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fborrowck%2Fissue-103624.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fborrowck%2Fissue-103624.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-103624.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,31 @@\n+// edition:2021\n+\n+struct StructA {\n+    b: StructB,\n+}\n+\n+async fn spawn_blocking<T>(f: impl (Fn() -> T) + Send + Sync + 'static) -> T {\n+    todo!()\n+}\n+\n+impl StructA {\n+    async fn foo(&self) {\n+        let bar = self.b.bar().await;\n+        spawn_blocking(move || {\n+            //~^ ERROR borrowed data escapes outside of associated function\n+            self.b;\n+            //~^ ERROR cannot move out of `self.b`, as `self` is a captured variable in an `Fn` closure\n+        })\n+        .await;\n+    }\n+}\n+\n+struct StructB {}\n+\n+impl StructB {\n+    async fn bar(&self) -> Option<u8> {\n+        None\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e6a35dd8801afc280faa41643ee659e24dea0d38", "filename": "src/test/ui/borrowck/issue-103624.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fborrowck%2Fissue-103624.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fborrowck%2Fissue-103624.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-103624.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -0,0 +1,35 @@\n+error[E0507]: cannot move out of `self.b`, as `self` is a captured variable in an `Fn` closure\n+  --> $DIR/issue-103624.rs:16:13\n+   |\n+LL |     async fn foo(&self) {\n+   |                  ----- captured outer variable\n+LL |         let bar = self.b.bar().await;\n+LL |         spawn_blocking(move || {\n+   |                        ------- captured by this `Fn` closure\n+LL |\n+LL |             self.b;\n+   |             ^^^^^^ move occurs because `self.b` has type `StructB`, which does not implement the `Copy` trait\n+\n+error[E0521]: borrowed data escapes outside of associated function\n+  --> $DIR/issue-103624.rs:14:9\n+   |\n+LL |       async fn foo(&self) {\n+   |                    -----\n+   |                    |\n+   |                    `self` is a reference that is only valid in the associated function body\n+   |                    let's call the lifetime of this reference `'1`\n+LL |           let bar = self.b.bar().await;\n+LL | /         spawn_blocking(move || {\n+LL | |\n+LL | |             self.b;\n+LL | |\n+LL | |         })\n+   | |          ^\n+   | |          |\n+   | |__________`self` escapes the associated function body here\n+   |            argument requires that `'1` must outlive `'static`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0507, E0521.\n+For more information about an error, try `rustc --explain E0507`."}, {"sha": "1679793ee6834e0404fad5e3ee7d37dd9eb92a2f", "filename": "src/test/ui/cast/issue-88621.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fcast%2Fissue-88621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fcast%2Fissue-88621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fissue-88621.rs?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,5 +1,3 @@\n-#![feature(arbitrary_enum_discriminant)]\n-\n #[repr(u8)]\n enum Kind2 {\n     Foo() = 1,"}, {"sha": "886145c1bafee4b4d8afe3729087dd68fd2fc3e4", "filename": "src/test/ui/cast/issue-88621.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fcast%2Fissue-88621.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/962bf63dbfcb190bd752e2dbff7d133ab1101f5c/src%2Ftest%2Fui%2Fcast%2Fissue-88621.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fissue-88621.stderr?ref=962bf63dbfcb190bd752e2dbff7d133ab1101f5c", "patch": "@@ -1,5 +1,5 @@\n error[E0605]: non-primitive cast: `Kind2` as `u8`\n-  --> $DIR/issue-88621.rs:11:13\n+  --> $DIR/issue-88621.rs:9:13\n    |\n LL |     let _ = Kind2::Foo() as u8;\n    |             ^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object"}]}