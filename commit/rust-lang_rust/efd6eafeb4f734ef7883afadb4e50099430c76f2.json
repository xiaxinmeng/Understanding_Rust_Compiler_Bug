{"sha": "efd6eafeb4f734ef7883afadb4e50099430c76f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZDZlYWZlYjRmNzM0ZWY3ODgzYWZhZGI0ZTUwMDk5NDMwYzc2ZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-03T02:29:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-03T02:29:00Z"}, "message": "auto merge of #8174 : DaGenix/rust/digest-improvements, r=brson\n\nSame content as #8097, but bors had an issue with that pull request. Opening a new one.", "tree": {"sha": "e62b6513fa316f611de2bf6f7d6efdb85825b7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e62b6513fa316f611de2bf6f7d6efdb85825b7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efd6eafeb4f734ef7883afadb4e50099430c76f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efd6eafeb4f734ef7883afadb4e50099430c76f2", "html_url": "https://github.com/rust-lang/rust/commit/efd6eafeb4f734ef7883afadb4e50099430c76f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efd6eafeb4f734ef7883afadb4e50099430c76f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ddc72f69be4d0a2027ff598ad262ea2b2ca3812", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ddc72f69be4d0a2027ff598ad262ea2b2ca3812", "html_url": "https://github.com/rust-lang/rust/commit/3ddc72f69be4d0a2027ff598ad262ea2b2ca3812"}, {"sha": "1252472bb76da5aa082db00086cc27c0bbe9d723", "url": "https://api.github.com/repos/rust-lang/rust/commits/1252472bb76da5aa082db00086cc27c0bbe9d723", "html_url": "https://github.com/rust-lang/rust/commit/1252472bb76da5aa082db00086cc27c0bbe9d723"}], "stats": {"total": 1762, "additions": 912, "deletions": 850}, "files": [{"sha": "43e3b5c89af484a84f32d08572fcfa830fa5e635", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=efd6eafeb4f734ef7883afadb4e50099430c76f2", "patch": "@@ -0,0 +1,327 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::num::One;\n+use std::vec::bytes::{MutableByteVector, copy_memory};\n+\n+\n+/// Write a u64 into a vector, which must be 8 bytes long. The value is written in big-endian\n+/// format.\n+pub fn write_u64_be(dst: &mut[u8], input: u64) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be64;\n+    assert!(dst.len() == 8);\n+    unsafe {\n+        let x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_be64(input as i64);\n+    }\n+}\n+\n+/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n+/// format.\n+pub fn write_u32_be(dst: &mut[u8], input: u32) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() == 4);\n+    unsafe {\n+        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_be32(input as i32);\n+    }\n+}\n+\n+/// Read a vector of bytes into a vector of u64s. The values are read in big-endian format.\n+pub fn read_u64v_be(dst: &mut[u64], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be64;\n+    assert!(dst.len() * 8 == input.len());\n+    unsafe {\n+        let mut x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i64 = transmute(input.unsafe_ref(0));\n+        do dst.len().times() {\n+            *x = to_be64(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        }\n+    }\n+}\n+\n+/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n+pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() * 4 == input.len());\n+    unsafe {\n+        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        do dst.len().times() {\n+            *x = to_be32(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        }\n+    }\n+}\n+\n+\n+/// Returns true if adding the two parameters will result in integer overflow\n+pub fn will_add_overflow<T: Int + Unsigned>(x: T, y: T) -> bool {\n+    // This doesn't handle negative values! Don't copy this code elsewhere without considering if\n+    // negative values are important to you!\n+    let max: T = Bounded::max_value();\n+    return x > max - y;\n+}\n+\n+/// Shifts the second parameter and then adds it to the first. fails!() if there would be unsigned\n+/// integer overflow.\n+pub fn shift_add_check_overflow<T: Int + Unsigned + Clone>(x: T, mut y: T, shift: T) -> T {\n+    if y.leading_zeros() < shift {\n+        fail!(\"Could not add values - integer overflow.\");\n+    }\n+    y = y << shift;\n+\n+    if will_add_overflow(x.clone(), y.clone()) {\n+        fail!(\"Could not add values - integer overflow.\");\n+    }\n+\n+    return x + y;\n+}\n+\n+/// Shifts the second parameter and then adds it to the first, which is a tuple where the first\n+/// element is the high order value. fails!() if there would be unsigned integer overflow.\n+pub fn shift_add_check_overflow_tuple\n+        <T: Int + Unsigned + Clone>\n+        (x: (T, T), mut y: T, shift: T) -> (T, T) {\n+    if y.leading_zeros() < shift {\n+        fail!(\"Could not add values - integer overflow.\");\n+    }\n+    y = y << shift;\n+\n+    match x {\n+        (hi, low) => {\n+            let one: T = One::one();\n+            if will_add_overflow(low.clone(), y.clone()) {\n+                if will_add_overflow(hi.clone(), one.clone()) {\n+                    fail!(\"Could not add values - integer overflow.\");\n+                } else {\n+                    return (hi + one, low + y);\n+                }\n+            } else {\n+                return (hi, low + y);\n+            }\n+        }\n+    }\n+}\n+\n+\n+/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n+/// must be processed. The input() method takes care of processing and then clearing the buffer\n+/// automatically. However, other methods do not and require the caller to process the buffer. Any\n+/// method that modifies the buffer directory or provides the caller with bytes that can be modifies\n+/// results in those bytes being marked as used by the buffer.\n+pub trait FixedBuffer {\n+    /// Input a vector of bytes. If the buffer becomes full, proccess it with the provided\n+    /// function and then clear the buffer.\n+    fn input(&mut self, input: &[u8], func: &fn(&[u8]));\n+\n+    /// Reset the buffer.\n+    fn reset(&mut self);\n+\n+    /// Zero the buffer up until the specified index. The buffer position currently must not be\n+    /// greater than that index.\n+    fn zero_until(&mut self, idx: uint);\n+\n+    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n+    /// remaining in the buffer.\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n+\n+    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n+\n+    /// Get the current position of the buffer.\n+    fn position(&self) -> uint;\n+\n+    /// Get the number of bytes remaining in the buffer until it is full.\n+    fn remaining(&self) -> uint;\n+\n+    /// Get the size of the buffer\n+    fn size(&self) -> uint;\n+}\n+\n+macro_rules! impl_fixed_buffer( ($name:ident, $size:expr) => (\n+    impl FixedBuffer for $name {\n+        fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n+            let mut i = 0;\n+\n+            // FIXME: #6304 - This local variable shouldn't be necessary.\n+            let size = $size;\n+\n+            // If there is already data in the buffer, copy as much as we can into it and process\n+            // the data if the buffer becomes full.\n+            if self.buffer_idx != 0 {\n+                let buffer_remaining = size - self.buffer_idx;\n+                if input.len() >= buffer_remaining {\n+                        copy_memory(\n+                            self.buffer.mut_slice(self.buffer_idx, size),\n+                            input.slice_to(buffer_remaining),\n+                            buffer_remaining);\n+                    self.buffer_idx = 0;\n+                    func(self.buffer);\n+                    i += buffer_remaining;\n+                } else {\n+                    copy_memory(\n+                        self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n+                        input,\n+                        input.len());\n+                    self.buffer_idx += input.len();\n+                    return;\n+                }\n+            }\n+\n+            // While we have at least a full buffer size chunks's worth of data, process that data\n+            // without copying it into the buffer\n+            while input.len() - i >= size {\n+                func(input.slice(i, i + size));\n+                i += size;\n+            }\n+\n+            // Copy any input data into the buffer. At this point in the method, the ammount of\n+            // data left in the input vector will be less than the buffer size and the buffer will\n+            // be empty.\n+            let input_remaining = input.len() - i;\n+            copy_memory(\n+                self.buffer.mut_slice(0, input_remaining),\n+                input.slice_from(i),\n+                input.len() - i);\n+            self.buffer_idx += input_remaining;\n+        }\n+\n+        fn reset(&mut self) {\n+            self.buffer_idx = 0;\n+        }\n+\n+        fn zero_until(&mut self, idx: uint) {\n+            assert!(idx >= self.buffer_idx);\n+            self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n+            self.buffer_idx = idx;\n+        }\n+\n+        fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+            self.buffer_idx += len;\n+            return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n+        }\n+\n+        fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n+            assert!(self.buffer_idx == $size);\n+            self.buffer_idx = 0;\n+            return self.buffer.slice_to($size);\n+        }\n+\n+        fn position(&self) -> uint { self.buffer_idx }\n+\n+        fn remaining(&self) -> uint { $size - self.buffer_idx }\n+\n+        fn size(&self) -> uint { $size }\n+    }\n+))\n+\n+\n+/// A fixed size buffer of 64 bytes useful for cryptographic operations.\n+pub struct FixedBuffer64 {\n+    priv buffer: [u8, ..64],\n+    priv buffer_idx: uint,\n+}\n+\n+impl FixedBuffer64 {\n+    /// Create a new buffer\n+    pub fn new() -> FixedBuffer64 {\n+        return FixedBuffer64 {\n+            buffer: [0u8, ..64],\n+            buffer_idx: 0\n+        };\n+    }\n+}\n+\n+impl_fixed_buffer!(FixedBuffer64, 64)\n+\n+/// A fixed size buffer of 128 bytes useful for cryptographic operations.\n+pub struct FixedBuffer128 {\n+    priv buffer: [u8, ..128],\n+    priv buffer_idx: uint,\n+}\n+\n+impl FixedBuffer128 {\n+    /// Create a new buffer\n+    pub fn new() -> FixedBuffer128 {\n+        return FixedBuffer128 {\n+            buffer: [0u8, ..128],\n+            buffer_idx: 0\n+        };\n+    }\n+}\n+\n+impl_fixed_buffer!(FixedBuffer128, 128)\n+\n+\n+/// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n+/// struct.\n+pub trait StandardPadding {\n+    /// Add standard padding to the buffer. The buffer must not be full when this method is called\n+    /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n+    /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n+    /// filled with zeros again until only rem bytes are remaining.\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8]));\n+}\n+\n+impl <T: FixedBuffer> StandardPadding for T {\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8])) {\n+        let size = self.size();\n+\n+        self.next(1)[0] = 128;\n+\n+        if self.remaining() < rem {\n+            self.zero_until(size);\n+            func(self.full_buffer());\n+        }\n+\n+        self.zero_until(size - rem);\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use std::rand::IsaacRng;\n+    use std::rand::RngUtil;\n+    use std::vec;\n+\n+    use digest::Digest;\n+\n+    /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n+    /// correct.\n+    pub fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n+        let total_size = 1000000;\n+        let buffer = vec::from_elem(blocksize * 2, 'a' as u8);\n+        let mut rng = IsaacRng::new_unseeded();\n+        let mut count = 0;\n+\n+        digest.reset();\n+\n+        while count < total_size {\n+            let next: uint = rng.gen_uint_range(0, 2 * blocksize + 1);\n+            let remaining = total_size - count;\n+            let size = if next > remaining { remaining } else { next };\n+            digest.input(buffer.slice_to(size));\n+            count += size;\n+        }\n+\n+        let result_str = digest.result_str();\n+\n+        assert!(expected == result_str);\n+    }\n+}"}, {"sha": "217573a4135b04be9fad37885c7df52db1081352", "filename": "src/libextra/crypto/digest.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=efd6eafeb4f734ef7883afadb4e50099430c76f2", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use std::uint;\n use std::vec;\n \n+\n /**\n  * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n  * family of digest functions.\n@@ -28,6 +28,10 @@ pub trait Digest {\n \n     /**\n      * Retrieve the digest result. This method may be called multiple times.\n+     *\n+     * # Arguments\n+     *\n+     * * out - the vector to hold the result. Must be large enough to contain output_bits().\n      */\n     fn result(&mut self, out: &mut [u8]);\n \n@@ -41,47 +45,37 @@ pub trait Digest {\n      * Get the output size in bits.\n      */\n     fn output_bits(&self) -> uint;\n-}\n-\n-fn to_hex(rr: &[u8]) -> ~str {\n-    let mut s = ~\"\";\n-    foreach b in rr.iter() {\n-        let hex = uint::to_str_radix(*b as uint, 16u);\n-        if hex.len() == 1 {\n-            s.push_char('0');\n-        }\n-        s.push_str(hex);\n-    }\n-    return s;\n-}\n \n-/// Contains utility methods for Digests.\n-/// FIXME: #7339: Convert to default methods when issues with them are resolved.\n-pub trait DigestUtil {\n     /**\n      * Convenience functon that feeds a string into a digest\n      *\n      * # Arguments\n      *\n      * * in The string to feed into the digest\n      */\n-    fn input_str(&mut self, input: &str);\n+    fn input_str(&mut self, input: &str) {\n+        self.input(input.as_bytes());\n+    }\n \n     /**\n      * Convenience functon that retrieves the result of a digest as a\n      * ~str in hexadecimal format.\n      */\n-    fn result_str(&mut self) -> ~str;\n-}\n-\n-impl<D: Digest> DigestUtil for D {\n-    fn input_str(&mut self, input: &str) {\n-        self.input(input.as_bytes());\n-    }\n-\n     fn result_str(&mut self) -> ~str {\n         let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n         self.result(buf);\n         return to_hex(buf);\n     }\n }\n+\n+fn to_hex(rr: &[u8]) -> ~str {\n+    let mut s = ~\"\";\n+    foreach b in rr.iter() {\n+        let hex = uint::to_str_radix(*b as uint, 16u);\n+        if hex.len() == 1 {\n+            s.push_char('0');\n+        }\n+        s.push_str(hex);\n+    }\n+    return s;\n+}"}, {"sha": "86a89d79f1addb4bc34139af41c116e670782d22", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 48, "deletions": 123, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=efd6eafeb4f734ef7883afadb4e50099430c76f2", "patch": "@@ -23,6 +23,8 @@\n  */\n \n \n+use cryptoutil::{write_u32_be, read_u32v_be, shift_add_check_overflow, FixedBuffer, FixedBuffer64,\n+    StandardPadding};\n use digest::Digest;\n \n /*\n@@ -33,7 +35,6 @@ use digest::Digest;\n \n // Some unexported constants\n static DIGEST_BUF_LEN: uint = 5u;\n-static MSG_BLOCK_LEN: uint = 64u;\n static WORK_BUF_LEN: uint = 80u;\n static K0: u32 = 0x5A827999u32;\n static K1: u32 = 0x6ED9EBA1u32;\n@@ -43,58 +44,38 @@ static K3: u32 = 0xCA62C1D6u32;\n /// Structure representing the state of a Sha1 computation\n pub struct Sha1 {\n     priv h: [u32, ..DIGEST_BUF_LEN],\n-    priv len_low: u32,\n-    priv len_high: u32,\n-    priv msg_block: [u8, ..MSG_BLOCK_LEN],\n-    priv msg_block_idx: uint,\n+    priv length_bits: u64,\n+    priv buffer: FixedBuffer64,\n     priv computed: bool,\n-    priv work_buf: [u32, ..WORK_BUF_LEN]\n }\n \n fn add_input(st: &mut Sha1, msg: &[u8]) {\n     assert!((!st.computed));\n-    foreach element in msg.iter() {\n-        st.msg_block[st.msg_block_idx] = *element;\n-        st.msg_block_idx += 1;\n-        st.len_low += 8;\n-        if st.len_low == 0 {\n-            st.len_high += 1;\n-            if st.len_high == 0 {\n-                // FIXME: Need better failure mode (#2346)\n-                fail!();\n-            }\n-        }\n-        if st.msg_block_idx == MSG_BLOCK_LEN { process_msg_block(st); }\n-    }\n+    // Assumes that msg.len() can be converted to u64 without overflow\n+    st.length_bits = shift_add_check_overflow(st.length_bits, msg.len() as u64, 3);\n+    st.buffer.input(msg, |d: &[u8]| { process_msg_block(d, &mut st.h); });\n }\n \n-fn process_msg_block(st: &mut Sha1) {\n+fn process_msg_block(data: &[u8], h: &mut [u32, ..DIGEST_BUF_LEN]) {\n     let mut t: int; // Loop counter\n-    let mut w = st.work_buf;\n+\n+    let mut w = [0u32, ..WORK_BUF_LEN];\n \n     // Initialize the first 16 words of the vector w\n-    t = 0;\n-    while t < 16 {\n-        let mut tmp;\n-        tmp = (st.msg_block[t * 4] as u32) << 24u32;\n-        tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n-        tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n-        tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n-        w[t] = tmp;\n-        t += 1;\n-    }\n+    read_u32v_be(w.mut_slice(0, 16), data);\n \n     // Initialize the rest of vector w\n+    t = 16;\n     while t < 80 {\n         let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n         w[t] = circular_shift(1, val);\n         t += 1;\n     }\n-    let mut a = st.h[0];\n-    let mut b = st.h[1];\n-    let mut c = st.h[2];\n-    let mut d = st.h[3];\n-    let mut e = st.h[4];\n+    let mut a = h[0];\n+    let mut b = h[1];\n+    let mut c = h[2];\n+    let mut d = h[3];\n+    let mut e = h[4];\n     let mut temp: u32;\n     t = 0;\n     while t < 20 {\n@@ -135,86 +116,42 @@ fn process_msg_block(st: &mut Sha1) {\n         a = temp;\n         t += 1;\n     }\n-    st.h[0] = st.h[0] + a;\n-    st.h[1] = st.h[1] + b;\n-    st.h[2] = st.h[2] + c;\n-    st.h[3] = st.h[3] + d;\n-    st.h[4] = st.h[4] + e;\n-    st.msg_block_idx = 0;\n+    h[0] += a;\n+    h[1] += b;\n+    h[2] += c;\n+    h[3] += d;\n+    h[4] += e;\n }\n \n fn circular_shift(bits: u32, word: u32) -> u32 {\n     return word << bits | word >> 32u32 - bits;\n }\n \n fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n-    if !st.computed { pad_msg(st); st.computed = true; }\n-    let mut i = 0;\n-    foreach ptr_hpart in st.h.mut_iter() {\n-        let hpart = *ptr_hpart;\n-        rs[i]   = (hpart >> 24u32 & 0xFFu32) as u8;\n-        rs[i+1] = (hpart >> 16u32 & 0xFFu32) as u8;\n-        rs[i+2] = (hpart >> 8u32 & 0xFFu32) as u8;\n-        rs[i+3] = (hpart & 0xFFu32) as u8;\n-        i += 4;\n-    }\n-}\n+    if !st.computed {\n+        st.buffer.standard_padding(8, |d: &[u8]| { process_msg_block(d, &mut st.h) });\n+        write_u32_be(st.buffer.next(4), (st.length_bits >> 32) as u32 );\n+        write_u32_be(st.buffer.next(4), st.length_bits as u32);\n+        process_msg_block(st.buffer.full_buffer(), &mut st.h);\n \n-/*\n- * According to the standard, the message must be padded to an even\n- * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n- * represent the length of the original message.  All bits in between\n- * should be 0.  This function will pad the message according to those\n- * rules by filling the msg_block vector accordingly.  It will also\n- * call process_msg_block() appropriately.  When it returns, it\n- * can be assumed that the message digest has been computed.\n- */\n-fn pad_msg(st: &mut Sha1) {\n-    /*\n-     * Check to see if the current message block is too small to hold\n-     * the initial padding bits and length.  If so, we will pad the\n-     * block, process it, and then continue padding into a second block.\n-     */\n-    if st.msg_block_idx > 55 {\n-        st.msg_block[st.msg_block_idx] = 0x80;\n-        st.msg_block_idx += 1;\n-        while st.msg_block_idx < MSG_BLOCK_LEN {\n-            st.msg_block[st.msg_block_idx] = 0;\n-            st.msg_block_idx += 1;\n-        }\n-        process_msg_block(st);\n-    } else {\n-        st.msg_block[st.msg_block_idx] = 0x80;\n-        st.msg_block_idx += 1;\n-    }\n-    while st.msg_block_idx < 56 {\n-        st.msg_block[st.msg_block_idx] = 0u8;\n-        st.msg_block_idx += 1;\n+        st.computed = true;\n     }\n \n-    // Store the message length as the last 8 octets\n-    st.msg_block[56] = (st.len_high >> 24u32 & 0xFFu32) as u8;\n-    st.msg_block[57] = (st.len_high >> 16u32 & 0xFFu32) as u8;\n-    st.msg_block[58] = (st.len_high >> 8u32 & 0xFFu32) as u8;\n-    st.msg_block[59] = (st.len_high & 0xFFu32) as u8;\n-    st.msg_block[60] = (st.len_low >> 24u32 & 0xFFu32) as u8;\n-    st.msg_block[61] = (st.len_low >> 16u32 & 0xFFu32) as u8;\n-    st.msg_block[62] = (st.len_low >> 8u32 & 0xFFu32) as u8;\n-    st.msg_block[63] = (st.len_low & 0xFFu32) as u8;\n-    process_msg_block(st);\n+    write_u32_be(rs.mut_slice(0, 4), st.h[0]);\n+    write_u32_be(rs.mut_slice(4, 8), st.h[1]);\n+    write_u32_be(rs.mut_slice(8, 12), st.h[2]);\n+    write_u32_be(rs.mut_slice(12, 16), st.h[3]);\n+    write_u32_be(rs.mut_slice(16, 20), st.h[4]);\n }\n \n impl Sha1 {\n     /// Construct a `sha` object\n     pub fn new() -> Sha1 {\n         let mut st = Sha1 {\n             h: [0u32, ..DIGEST_BUF_LEN],\n-            len_low: 0u32,\n-            len_high: 0u32,\n-            msg_block: [0u8, ..MSG_BLOCK_LEN],\n-            msg_block_idx: 0,\n+            length_bits: 0u64,\n+            buffer: FixedBuffer64::new(),\n             computed: false,\n-            work_buf: [0u32, ..WORK_BUF_LEN]\n         };\n         st.reset();\n         return st;\n@@ -223,14 +160,13 @@ impl Sha1 {\n \n impl Digest for Sha1 {\n     pub fn reset(&mut self) {\n-        self.len_low = 0;\n-        self.len_high = 0;\n-        self.msg_block_idx = 0;\n+        self.length_bits = 0;\n         self.h[0] = 0x67452301u32;\n         self.h[1] = 0xEFCDAB89u32;\n         self.h[2] = 0x98BADCFEu32;\n         self.h[3] = 0x10325476u32;\n         self.h[4] = 0xC3D2E1F0u32;\n+        self.buffer.reset();\n         self.computed = false;\n     }\n     pub fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n@@ -240,8 +176,8 @@ impl Digest for Sha1 {\n \n #[cfg(test)]\n mod tests {\n-\n-    use digest::{Digest, DigestUtil};\n+    use cryptoutil::test::test_digest_1million_random;\n+    use digest::Digest;\n     use sha1::Sha1;\n \n     #[deriving(Clone)]\n@@ -253,15 +189,6 @@ mod tests {\n \n     #[test]\n     fn test() {\n-        fn a_million_letter_a() -> ~str {\n-            let mut i = 0;\n-            let mut rs = ~\"\";\n-            while i < 100000 {\n-                rs.push_str(\"aaaaaaaaaa\");\n-                i += 1;\n-            }\n-            return rs;\n-        }\n         // Test messages from FIPS 180-1\n \n         let fips_180_1_tests = ~[\n@@ -289,17 +216,6 @@ mod tests {\n                 ],\n                 output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n             },\n-            Test {\n-                input: a_million_letter_a(),\n-                output: ~[\n-                    0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n-                ],\n-                output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n-            },\n         ];\n         // Examples from wikipedia\n \n@@ -366,6 +282,15 @@ mod tests {\n             sh.reset();\n         }\n     }\n+\n+    #[test]\n+    fn test_1million_random_sha1() {\n+        let mut sh = Sha1::new();\n+        test_digest_1million_random(\n+            &mut sh,\n+            64,\n+            \"34aa973cd4c4daa4f61eeb2bdbad27316534016f\");\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "d92a4be43c388122bae1bf456f760d5eb61096bb", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 514, "deletions": 699, "changes": 1213, "blob_url": "https://github.com/rust-lang/rust/blob/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=efd6eafeb4f734ef7883afadb4e50099430c76f2", "patch": "@@ -8,47 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::uint;\n+\n+use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, shift_add_check_overflow,\n+    shift_add_check_overflow_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n use digest::Digest;\n \n-// BitCounter is a specialized structure intended simply for counting the\n-// number of bits that have been processed by the SHA-2 512 family of functions.\n-// It does very little overflow checking since such checking is not necessary\n-// for how it is used. A more generic structure would have to do this checking.\n-// So, don't copy this structure and use it elsewhere!\n-struct BitCounter {\n-    high_bit_count: u64,\n-    low_byte_count: u64\n-}\n \n-impl BitCounter {\n-    fn add_bytes(&mut self, bytes: uint) {\n-        self.low_byte_count += bytes as u64;\n-        if(self.low_byte_count > 0x1fffffffffffffffu64) {\n-            self.high_bit_count += (self.low_byte_count >> 61);\n-            self.low_byte_count &= 0x1fffffffffffffffu64;\n-        }\n-    }\n+// Sha-512 and Sha-256 use basically the same calculations which are implemented by these macros.\n+// Inlining the calculations seems to result in better generated code.\n+macro_rules! schedule_round( ($t:expr) => (\n+        W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n+    )\n+)\n \n-    fn reset(&mut self) {\n-        self.low_byte_count = 0;\n-        self.high_bit_count = 0;\n-    }\n-\n-    fn get_low_bit_count(&self) -> u64 {\n-        self.low_byte_count << 3\n-    }\n+macro_rules! sha2_round(\n+    ($A:ident, $B:ident, $C:ident, $D:ident,\n+     $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n+        {\n+            $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n+            $D += $H;\n+            $H += sum0($A) + maj($A, $B, $C);\n+        }\n+    )\n+)\n \n-    fn get_high_bit_count(&self) -> u64 {\n-        self.high_bit_count\n-    }\n-}\n \n-// A structure that represents that state of a digest computation\n-// for the SHA-2 512 family of digest functions\n-struct Engine512 {\n-    input_buffer: [u8, ..8],\n-    input_buffer_idx: uint,\n-    bit_counter: BitCounter,\n+// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n+// functions\n+struct Engine512State {\n     H0: u64,\n     H1: u64,\n     H2: u64,\n@@ -57,91 +45,34 @@ struct Engine512 {\n     H5: u64,\n     H6: u64,\n     H7: u64,\n-    W: [u64, ..80],\n-    W_idx: uint,\n-    finished: bool,\n-}\n-\n-// Convert a [u8] to a u64 in big-endian format\n-fn to_u64(input: &[u8]) -> u64 {\n-    (input[0] as u64) << 56 |\n-    (input[1] as u64) << 48 |\n-    (input[2] as u64) << 40 |\n-    (input[3] as u64) << 32 |\n-    (input[4] as u64) << 24 |\n-    (input[5] as u64) << 16 |\n-    (input[6] as u64) << 8 |\n-    (input[7] as u64)\n-}\n-\n-// Convert a u64 to a [u8] in big endian format\n-fn from_u64(input: u64, out: &mut [u8]) {\n-    out[0] = (input >> 56) as u8;\n-    out[1] = (input >> 48) as u8;\n-    out[2] = (input >> 40) as u8;\n-    out[3] = (input >> 32) as u8;\n-    out[4] = (input >> 24) as u8;\n-    out[5] = (input >> 16) as u8;\n-    out[6] = (input >> 8) as u8;\n-    out[7] = input as u8;\n }\n \n-impl Engine512 {\n-    fn input_byte(&mut self, input: u8) {\n-        assert!(!self.finished)\n-\n-        self.input_buffer[self.input_buffer_idx] = input;\n-        self.input_buffer_idx += 1;\n-\n-        if (self.input_buffer_idx == 8) {\n-            self.input_buffer_idx = 0;\n-            let w = to_u64(self.input_buffer);\n-            self.process_word(w);\n-        }\n-\n-        self.bit_counter.add_bytes(1);\n-    }\n-\n-    fn input_vec(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n-\n-        let mut i = 0;\n-\n-        while i < input.len() && self.input_buffer_idx != 0 {\n-            self.input_byte(input[i]);\n-            i += 1;\n-        }\n-\n-        while input.len() - i >= 8 {\n-            let w = to_u64(input.slice(i, i + 8));\n-            self.process_word(w);\n-            self.bit_counter.add_bytes(8);\n-            i += 8;\n-        }\n-\n-        while i < input.len() {\n-            self.input_byte(input[i]);\n-            i += 1;\n-        }\n-    }\n-\n-    fn reset(&mut self) {\n-        self.bit_counter.reset();\n-        self.finished = false;\n-        self.input_buffer_idx = 0;\n-        self.W_idx = 0;\n-    }\n-\n-    fn process_word(&mut self, input: u64) {\n-        self.W[self.W_idx] = input;\n-        self.W_idx += 1;\n-        if (self.W_idx == 16) {\n-            self.W_idx = 0;\n-            self.process_block();\n-        }\n-    }\n-\n-    fn process_block(&mut self) {\n+impl Engine512State {\n+    fn new(h: &[u64, ..8]) -> Engine512State {\n+        return Engine512State {\n+            H0: h[0],\n+            H1: h[1],\n+            H2: h[2],\n+            H3: h[3],\n+            H4: h[4],\n+            H5: h[5],\n+            H6: h[6],\n+            H7: h[7]\n+        };\n+    }\n+\n+    fn reset(&mut self, h: &[u64, ..8]) {\n+        self.H0 = h[0];\n+        self.H1 = h[1];\n+        self.H2 = h[2];\n+        self.H3 = h[3];\n+        self.H4 = h[4];\n+        self.H5 = h[5];\n+        self.H6 = h[6];\n+        self.H7 = h[7];\n+    }\n+\n+    fn process_block(&mut self, data: &[u8]) {\n         fn ch(x: u64, y: u64, z: u64) -> u64 {\n             ((x & y) ^ ((!x) & z))\n         }\n@@ -166,11 +97,6 @@ impl Engine512 {\n             ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n         }\n \n-        foreach t in range(16u, 80) {\n-            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n-                self.W[t - 16];\n-        }\n-\n         let mut a = self.H0;\n         let mut b = self.H1;\n         let mut c = self.H2;\n@@ -180,47 +106,41 @@ impl Engine512 {\n         let mut g = self.H6;\n         let mut h = self.H7;\n \n-        let mut t = 0;\n-        foreach _ in range(0u, 10) {\n-            h += sum1(e) + ch(e, f, g) + K64[t] + self.W[t];\n-            d += h;\n-            h += sum0(a) + maj(a, b, c);\n-            t += 1;\n-\n-            g += sum1(d) + ch(d, e, f) + K64[t] + self.W[t];\n-            c += g;\n-            g += sum0(h) + maj(h, a, b);\n-            t += 1;\n-\n-            f += sum1(c) + ch(c, d, e) + K64[t] + self.W[t];\n-            b += f;\n-            f += sum0(g) + maj(g, h, a);\n-            t += 1;\n-\n-            e += sum1(b) + ch(b, c, d) + K64[t] + self.W[t];\n-            a += e;\n-            e += sum0(f) + maj(f, g, h);\n-            t += 1;\n-\n-            d += sum1(a) + ch(a, b, c) + K64[t] + self.W[t];\n-            h += d;\n-            d += sum0(e) + maj(e, f, g);\n-            t += 1;\n-\n-            c += sum1(h) + ch(h, a, b) + K64[t] + self.W[t];\n-            g += c;\n-            c += sum0(d) + maj(d, e, f);\n-            t += 1;\n-\n-            b += sum1(g) + ch(g, h, a) + K64[t] + self.W[t];\n-            f += b;\n-            b += sum0(c) + maj(c, d, e);\n-            t += 1;\n-\n-            a += sum1(f) + ch(f, g, h) + K64[t] + self.W[t];\n-            e += a;\n-            a += sum0(b) + maj(b, c, d);\n-            t += 1;\n+        let mut W = [0u64, ..80];\n+\n+        read_u64v_be(W.mut_slice(0, 16), data);\n+\n+        // Putting the message schedule inside the same loop as the round calculations allows for\n+        // the compiler to generate better code.\n+        for uint::range_step(0, 64, 8) |t| {\n+            schedule_round!(t + 16);\n+            schedule_round!(t + 17);\n+            schedule_round!(t + 18);\n+            schedule_round!(t + 19);\n+            schedule_round!(t + 20);\n+            schedule_round!(t + 21);\n+            schedule_round!(t + 22);\n+            schedule_round!(t + 23);\n+\n+            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n+        }\n+\n+        for uint::range_step(64, 80, 8) |t| {\n+            sha2_round!(a, b, c, d, e, f, g, h, K64, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K64, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K64, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K64, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K64, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K64, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K64, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K64, t + 7);\n         }\n \n         self.H0 += a;\n@@ -232,199 +152,322 @@ impl Engine512 {\n         self.H6 += g;\n         self.H7 += h;\n     }\n+}\n \n-    fn finish(&mut self) {\n-        if (self.finished) {\n-            return;\n+// Constants necessary for SHA-2 512 family of digests.\n+static K64: [u64, ..80] = [\n+    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,\n+    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,\n+    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n+    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,\n+    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,\n+    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n+    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,\n+    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,\n+    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n+    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,\n+    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,\n+    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n+    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,\n+    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,\n+    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n+    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,\n+    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,\n+    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n+    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,\n+    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817\n+];\n+\n+\n+// A structure that keeps track of the state of the Sha-512 operation and contains the logic\n+// necessary to perform the final calculations.\n+struct Engine512 {\n+    length_bits: (u64, u64),\n+    buffer: FixedBuffer128,\n+    state: Engine512State,\n+    finished: bool,\n+}\n+\n+impl Engine512 {\n+    fn new(h: &[u64, ..8]) -> Engine512 {\n+        return Engine512 {\n+            length_bits: (0, 0),\n+            buffer: FixedBuffer128::new(),\n+            state: Engine512State::new(h),\n+            finished: false\n         }\n+    }\n \n-        // must get message length before padding is added\n-        let high_bit_count = self.bit_counter.get_high_bit_count();\n-        let low_bit_count = self.bit_counter.get_low_bit_count();\n+    fn reset(&mut self, h: &[u64, ..8]) {\n+        self.length_bits = (0, 0);\n+        self.buffer.reset();\n+        self.state.reset(h);\n+        self.finished = false;\n+    }\n \n-        // add padding\n-        self.input_byte(128u8);\n+    fn input(&mut self, input: &[u8]) {\n+        assert!(!self.finished)\n+        // Assumes that input.len() can be converted to u64 without overflow\n+        self.length_bits = shift_add_check_overflow_tuple(self.length_bits, input.len() as u64, 3);\n+        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n+    }\n \n-        while self.input_buffer_idx != 0 {\n-            self.input_byte(0u8);\n+    fn finish(&mut self) {\n+        if self.finished {\n+            return;\n         }\n \n-        // add length\n-        if (self.W_idx > 14) {\n-            foreach _ in range(self.W_idx, 16) {\n-                self.process_word(0);\n+        self.buffer.standard_padding(16, |input: &[u8]| { self.state.process_block(input) });\n+        match self.length_bits {\n+            (hi, low) => {\n+                write_u64_be(self.buffer.next(8), hi);\n+                write_u64_be(self.buffer.next(8), low);\n             }\n         }\n+        self.state.process_block(self.buffer.full_buffer());\n \n-        while self.W_idx < 14 {\n-            self.process_word(0);\n-        }\n+        self.finished = true;\n+    }\n+}\n \n-        self.process_word(high_bit_count);\n-        self.process_word(low_bit_count);\n \n-        self.finished = true;\n+struct Sha512 {\n+    priv engine: Engine512\n+}\n+\n+impl Sha512 {\n+    /**\n+     * Construct an new instance of a SHA-512 digest.\n+     */\n+    pub fn new() -> Sha512 {\n+        return Sha512 {\n+            engine: Engine512::new(&H512)\n+        };\n     }\n+}\n \n-    fn result_512(&mut self, out: &mut [u8]) {\n-        self.finish();\n-\n-        from_u64(self.H0, out.mut_slice(0, 8));\n-        from_u64(self.H1, out.mut_slice(8, 16));\n-        from_u64(self.H2, out.mut_slice(16, 24));\n-        from_u64(self.H3, out.mut_slice(24, 32));\n-        from_u64(self.H4, out.mut_slice(32, 40));\n-        from_u64(self.H5, out.mut_slice(40, 48));\n-        from_u64(self.H6, out.mut_slice(48, 56));\n-        from_u64(self.H7, out.mut_slice(56, 64));\n+impl Digest for Sha512 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input(d);\n     }\n \n-    fn result_384(&mut self, out: &mut [u8]) {\n-        self.finish();\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.finish();\n \n-        from_u64(self.H0, out.mut_slice(0, 8));\n-        from_u64(self.H1, out.mut_slice(8, 16));\n-        from_u64(self.H2, out.mut_slice(16, 24));\n-        from_u64(self.H3, out.mut_slice(24, 32));\n-        from_u64(self.H4, out.mut_slice(32, 40));\n-        from_u64(self.H5, out.mut_slice(40, 48));\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n+        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n+        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n+        write_u64_be(out.mut_slice(48, 56), self.engine.state.H6);\n+        write_u64_be(out.mut_slice(56, 64), self.engine.state.H7);\n     }\n \n-    fn result_256(&mut self, out: &mut [u8]) {\n-        self.finish();\n+    fn reset(&mut self) {\n+        self.engine.reset(&H512);\n+    }\n+\n+    fn output_bits(&self) -> uint { 512 }\n+}\n+\n+static H512: [u64, ..8] = [\n+    0x6a09e667f3bcc908,\n+    0xbb67ae8584caa73b,\n+    0x3c6ef372fe94f82b,\n+    0xa54ff53a5f1d36f1,\n+    0x510e527fade682d1,\n+    0x9b05688c2b3e6c1f,\n+    0x1f83d9abfb41bd6b,\n+    0x5be0cd19137e2179\n+];\n+\n+\n+struct Sha384 {\n+    priv engine: Engine512\n+}\n+\n+impl Sha384 {\n+    /**\n+     * Construct an new instance of a SHA-384 digest.\n+     */\n+    pub fn new() -> Sha384 {\n+        Sha384 {\n+            engine: Engine512::new(&H384)\n+        }\n+    }\n+}\n \n-        from_u64(self.H0, out.mut_slice(0, 8));\n-        from_u64(self.H1, out.mut_slice(8, 16));\n-        from_u64(self.H2, out.mut_slice(16, 24));\n-        from_u64(self.H3, out.mut_slice(24, 32));\n+impl Digest for Sha384 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input(d);\n     }\n \n-    fn result_224(&mut self, out: &mut [u8]) {\n-        self.finish();\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.finish();\n \n-        from_u64(self.H0, out.mut_slice(0, 8));\n-        from_u64(self.H1, out.mut_slice(8, 16));\n-        from_u64(self.H2, out.mut_slice(16, 24));\n-        from_u32((self.H3 >> 32) as u32, out.mut_slice(24, 28));\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n+        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n+        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset(&H384);\n     }\n+\n+    fn output_bits(&self) -> uint { 384 }\n }\n \n-// Constants necessary for SHA-2 512 family of digests.\n-static K64: [u64, ..80] = [\n-    0x428a2f98d728ae22u64, 0x7137449123ef65cdu64, 0xb5c0fbcfec4d3b2fu64, 0xe9b5dba58189dbbcu64,\n-    0x3956c25bf348b538u64, 0x59f111f1b605d019u64, 0x923f82a4af194f9bu64, 0xab1c5ed5da6d8118u64,\n-    0xd807aa98a3030242u64, 0x12835b0145706fbeu64, 0x243185be4ee4b28cu64, 0x550c7dc3d5ffb4e2u64,\n-    0x72be5d74f27b896fu64, 0x80deb1fe3b1696b1u64, 0x9bdc06a725c71235u64, 0xc19bf174cf692694u64,\n-    0xe49b69c19ef14ad2u64, 0xefbe4786384f25e3u64, 0x0fc19dc68b8cd5b5u64, 0x240ca1cc77ac9c65u64,\n-    0x2de92c6f592b0275u64, 0x4a7484aa6ea6e483u64, 0x5cb0a9dcbd41fbd4u64, 0x76f988da831153b5u64,\n-    0x983e5152ee66dfabu64, 0xa831c66d2db43210u64, 0xb00327c898fb213fu64, 0xbf597fc7beef0ee4u64,\n-    0xc6e00bf33da88fc2u64, 0xd5a79147930aa725u64, 0x06ca6351e003826fu64, 0x142929670a0e6e70u64,\n-    0x27b70a8546d22ffcu64, 0x2e1b21385c26c926u64, 0x4d2c6dfc5ac42aedu64, 0x53380d139d95b3dfu64,\n-    0x650a73548baf63deu64, 0x766a0abb3c77b2a8u64, 0x81c2c92e47edaee6u64, 0x92722c851482353bu64,\n-    0xa2bfe8a14cf10364u64, 0xa81a664bbc423001u64, 0xc24b8b70d0f89791u64, 0xc76c51a30654be30u64,\n-    0xd192e819d6ef5218u64, 0xd69906245565a910u64, 0xf40e35855771202au64, 0x106aa07032bbd1b8u64,\n-    0x19a4c116b8d2d0c8u64, 0x1e376c085141ab53u64, 0x2748774cdf8eeb99u64, 0x34b0bcb5e19b48a8u64,\n-    0x391c0cb3c5c95a63u64, 0x4ed8aa4ae3418acbu64, 0x5b9cca4f7763e373u64, 0x682e6ff3d6b2b8a3u64,\n-    0x748f82ee5defb2fcu64, 0x78a5636f43172f60u64, 0x84c87814a1f0ab72u64, 0x8cc702081a6439ecu64,\n-    0x90befffa23631e28u64, 0xa4506cebde82bde9u64, 0xbef9a3f7b2c67915u64, 0xc67178f2e372532bu64,\n-    0xca273eceea26619cu64, 0xd186b8c721c0c207u64, 0xeada7dd6cde0eb1eu64, 0xf57d4f7fee6ed178u64,\n-    0x06f067aa72176fbau64, 0x0a637dc5a2c898a6u64, 0x113f9804bef90daeu64, 0x1b710b35131c471bu64,\n-    0x28db77f523047d84u64, 0x32caab7b40c72493u64, 0x3c9ebe0a15c9bebcu64, 0x431d67c49c100d4cu64,\n-    0x4cc5d4becb3e42b6u64, 0x597f299cfc657e2au64, 0x5fcb6fab3ad6faecu64, 0x6c44198c4a475817u64\n+static H384: [u64, ..8] = [\n+    0xcbbb9d5dc1059ed8,\n+    0x629a292a367cd507,\n+    0x9159015a3070dd17,\n+    0x152fecd8f70e5939,\n+    0x67332667ffc00b31,\n+    0x8eb44a8768581511,\n+    0xdb0c2e0d64f98fa7,\n+    0x47b5481dbefa4fa4\n ];\n \n-// A structure that represents that state of a digest computation\n-// for the SHA-2 256 family of digest functions\n-struct Engine256 {\n-    input_buffer: [u8, ..4],\n-    input_buffer_idx: uint,\n-    length_bytes: u64,\n-    H0: u32,\n-    H1: u32,\n-    H2: u32,\n-    H3: u32,\n-    H4: u32,\n-    H5: u32,\n-    H6: u32,\n-    H7: u32,\n-    W: [u32, ..64],\n-    W_idx: uint,\n-    finished: bool\n-}\n \n-// Convert a [u8] to a u32 in big endian format\n-fn to_u32(input: &[u8]) -> u32 {\n-    (input[0] as u32) << 24 |\n-    (input[1] as u32) << 16 |\n-    (input[2] as u32) << 8 |\n-    (input[3] as u32)\n+struct Sha512Trunc256 {\n+    priv engine: Engine512\n }\n \n-// Convert a u32 to a [u8] in big endian format\n-fn from_u32(input: u32, out: &mut [u8]) {\n-    out[0] = (input >> 24) as u8;\n-    out[1] = (input >> 16) as u8;\n-    out[2] = (input >> 8) as u8;\n-    out[3] = input as u8;\n+impl Sha512Trunc256 {\n+    /**\n+     * Construct an new instance of a SHA-512/256 digest.\n+     */\n+    pub fn new() -> Sha512Trunc256 {\n+        Sha512Trunc256 {\n+            engine: Engine512::new(&H512_TRUNC_256)\n+        }\n+    }\n }\n \n-impl Engine256 {\n-    fn input_byte(&mut self, input: u8) {\n-        assert!(!self.finished)\n+impl Digest for Sha512Trunc256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input(d);\n+    }\n \n-        self.input_buffer[self.input_buffer_idx] = input;\n-        self.input_buffer_idx += 1;\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.finish();\n \n-        if (self.input_buffer_idx == 4) {\n-            self.input_buffer_idx = 0;\n-            let w = to_u32(self.input_buffer);\n-            self.process_word(w);\n-        }\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n+    }\n \n-        self.length_bytes += 1;\n+    fn reset(&mut self) {\n+        self.engine.reset(&H512_TRUNC_256);\n     }\n \n-    fn input_vec(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n+    fn output_bits(&self) -> uint { 256 }\n+}\n \n-        let mut i = 0;\n+static H512_TRUNC_256: [u64, ..8] = [\n+    0x22312194fc2bf72c,\n+    0x9f555fa3c84c64c2,\n+    0x2393b86b6f53b151,\n+    0x963877195940eabd,\n+    0x96283ee2a88effe3,\n+    0xbe5e1e2553863992,\n+    0x2b0199fc2c85b8aa,\n+    0x0eb72ddc81c52ca2\n+];\n \n-        while i < input.len() && self.input_buffer_idx != 0 {\n-            self.input_byte(input[i]);\n-            i += 1;\n-        }\n \n-        while input.len() - i >= 4 {\n-            let w = to_u32(input.slice(i, i + 4));\n-            self.process_word(w);\n-            self.length_bytes += 4;\n-            i += 4;\n-        }\n+struct Sha512Trunc224 {\n+    priv engine: Engine512\n+}\n \n-        while i < input.len() {\n-            self.input_byte(input[i]);\n-            i += 1;\n+impl Sha512Trunc224 {\n+    /**\n+     * Construct an new instance of a SHA-512/224 digest.\n+     */\n+    pub fn new() -> Sha512Trunc224 {\n+        Sha512Trunc224 {\n+            engine: Engine512::new(&H512_TRUNC_224)\n         }\n+    }\n+}\n \n+impl Digest for Sha512Trunc224 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input(d);\n     }\n \n-    fn reset(&mut self) {\n-        self.length_bytes = 0;\n-        self.finished = false;\n-        self.input_buffer_idx = 0;\n-        self.W_idx = 0;\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.finish();\n+\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u32_be(out.mut_slice(24, 28), (self.engine.state.H3 >> 32) as u32);\n     }\n \n-    fn process_word(&mut self, input: u32) {\n-        self.W[self.W_idx] = input;\n-        self.W_idx += 1;\n-        if (self.W_idx == 16) {\n-            self.W_idx = 0;\n-            self.process_block();\n-        }\n+    fn reset(&mut self) {\n+        self.engine.reset(&H512_TRUNC_224);\n     }\n \n-    fn process_block(&mut self) {\n+    fn output_bits(&self) -> uint { 224 }\n+}\n+\n+static H512_TRUNC_224: [u64, ..8] = [\n+    0x8c3d37c819544da2,\n+    0x73e1996689dcd4d6,\n+    0x1dfab7ae32ff9c82,\n+    0x679dd514582f9fcf,\n+    0x0f6d2b697bd44da8,\n+    0x77e36f7304c48942,\n+    0x3f9d85a86a1d36c8,\n+    0x1112e6ad91d692a1,\n+];\n+\n+\n+// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n+// functions\n+struct Engine256State {\n+    H0: u32,\n+    H1: u32,\n+    H2: u32,\n+    H3: u32,\n+    H4: u32,\n+    H5: u32,\n+    H6: u32,\n+    H7: u32,\n+}\n+\n+impl Engine256State {\n+    fn new(h: &[u32, ..8]) -> Engine256State {\n+        return Engine256State {\n+            H0: h[0],\n+            H1: h[1],\n+            H2: h[2],\n+            H3: h[3],\n+            H4: h[4],\n+            H5: h[5],\n+            H6: h[6],\n+            H7: h[7]\n+        };\n+    }\n+\n+    fn reset(&mut self, h: &[u32, ..8]) {\n+        self.H0 = h[0];\n+        self.H1 = h[1];\n+        self.H2 = h[2];\n+        self.H3 = h[3];\n+        self.H4 = h[4];\n+        self.H5 = h[5];\n+        self.H6 = h[6];\n+        self.H7 = h[7];\n+    }\n+\n+    fn process_block(&mut self, data: &[u8]) {\n         fn ch(x: u32, y: u32, z: u32) -> u32 {\n             ((x & y) ^ ((!x) & z))\n         }\n@@ -449,11 +492,6 @@ impl Engine256 {\n             ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n         }\n \n-        foreach t in range(16u, 64) {\n-            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n-                self.W[t - 16];\n-        }\n-\n         let mut a = self.H0;\n         let mut b = self.H1;\n         let mut c = self.H2;\n@@ -463,47 +501,41 @@ impl Engine256 {\n         let mut g = self.H6;\n         let mut h = self.H7;\n \n-        let mut t = 0;\n-        foreach _ in range(0u, 8) {\n-            h += sum1(e) + ch(e, f, g) + K32[t] + self.W[t];\n-            d += h;\n-            h += sum0(a) + maj(a, b, c);\n-            t += 1;\n-\n-            g += sum1(d) + ch(d, e, f) + K32[t] + self.W[t];\n-            c += g;\n-            g += sum0(h) + maj(h, a, b);\n-            t += 1;\n-\n-            f += sum1(c) + ch(c, d, e) + K32[t] + self.W[t];\n-            b += f;\n-            f += sum0(g) + maj(g, h, a);\n-            t += 1;\n-\n-            e += sum1(b) + ch(b, c, d) + K32[t] + self.W[t];\n-            a += e;\n-            e += sum0(f) + maj(f, g, h);\n-            t += 1;\n-\n-            d += sum1(a) + ch(a, b, c) + K32[t] + self.W[t];\n-            h += d;\n-            d += sum0(e) + maj(e, f, g);\n-            t += 1;\n-\n-            c += sum1(h) + ch(h, a, b) + K32[t] + self.W[t];\n-            g += c;\n-            c += sum0(d) + maj(d, e, f);\n-            t += 1;\n-\n-            b += sum1(g) + ch(g, h, a) + K32[t] + self.W[t];\n-            f += b;\n-            b += sum0(c) + maj(c, d, e);\n-            t += 1;\n-\n-            a += sum1(f) + ch(f, g, h) + K32[t] + self.W[t];\n-            e += a;\n-            a += sum0(b) + maj(b, c, d);\n-            t += 1;\n+        let mut W = [0u32, ..64];\n+\n+        read_u32v_be(W.mut_slice(0, 16), data);\n+\n+        // Putting the message schedule inside the same loop as the round calculations allows for\n+        // the compiler to generate better code.\n+        for uint::range_step(0, 48, 8) |t| {\n+            schedule_round!(t + 16);\n+            schedule_round!(t + 17);\n+            schedule_round!(t + 18);\n+            schedule_round!(t + 19);\n+            schedule_round!(t + 20);\n+            schedule_round!(t + 21);\n+            schedule_round!(t + 22);\n+            schedule_round!(t + 23);\n+\n+            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n+        }\n+\n+        for uint::range_step(48, 64, 8) |t| {\n+            sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n+            sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n+            sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n+            sha2_round!(f, g, h, a, b, c, d, e, K32, t + 3);\n+            sha2_round!(e, f, g, h, a, b, c, d, K32, t + 4);\n+            sha2_round!(d, e, f, g, h, a, b, c, K32, t + 5);\n+            sha2_round!(c, d, e, f, g, h, a, b, K32, t + 6);\n+            sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n         self.H0 += a;\n@@ -515,418 +547,182 @@ impl Engine256 {\n         self.H6 += g;\n         self.H7 += h;\n     }\n+}\n \n-    fn finish(&mut self) {\n-        if (self.finished) {\n-            return;\n-        }\n-\n-        // must get length before adding padding\n-        let bit_length = self.length_bytes << 3;\n-\n-        // add padding\n-        self.input_byte(128u8);\n+static K32: [u32, ..64] = [\n+    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n+    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n+    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n+    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n+    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n+    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n+    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n+    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n+    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n+    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n+    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n+    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n+    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n+    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n+    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n+    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n+];\n \n-        while self.input_buffer_idx != 0 {\n-            self.input_byte(0u8);\n-        }\n \n-        // add length\n-        if (self.W_idx > 14) {\n-            foreach _ in range(self.W_idx, 16) {\n-                self.process_word(0);\n-            }\n-        }\n+// A structure that keeps track of the state of the Sha-256 operation and contains the logic\n+// necessary to perform the final calculations.\n+struct Engine256 {\n+    length_bits: u64,\n+    buffer: FixedBuffer64,\n+    state: Engine256State,\n+    finished: bool,\n+}\n \n-        while self.W_idx < 14 {\n-            self.process_word(0);\n+impl Engine256 {\n+    fn new(h: &[u32, ..8]) -> Engine256 {\n+        return Engine256 {\n+            length_bits: 0,\n+            buffer: FixedBuffer64::new(),\n+            state: Engine256State::new(h),\n+            finished: false\n         }\n-\n-        self.process_word((bit_length >> 32) as u32);\n-        self.process_word(bit_length as u32);\n-\n-        self.finished = true;\n     }\n \n-    fn result_256(&mut self, out: &mut [u8]) {\n-        self.finish();\n-\n-        from_u32(self.H0, out.mut_slice(0, 4));\n-        from_u32(self.H1, out.mut_slice(4, 8));\n-        from_u32(self.H2, out.mut_slice(8, 12));\n-        from_u32(self.H3, out.mut_slice(12, 16));\n-        from_u32(self.H4, out.mut_slice(16, 20));\n-        from_u32(self.H5, out.mut_slice(20, 24));\n-        from_u32(self.H6, out.mut_slice(24, 28));\n-        from_u32(self.H7, out.mut_slice(28, 32));\n+    fn reset(&mut self, h: &[u32, ..8]) {\n+        self.length_bits = 0;\n+        self.buffer.reset();\n+        self.state.reset(h);\n+        self.finished = false;\n     }\n \n-    fn result_224(&mut self, out: &mut [u8]) {\n-        self.finish();\n-\n-        from_u32(self.H0, out.mut_slice(0, 4));\n-        from_u32(self.H1, out.mut_slice(4, 8));\n-        from_u32(self.H2, out.mut_slice(8, 12));\n-        from_u32(self.H3, out.mut_slice(12, 16));\n-        from_u32(self.H4, out.mut_slice(16, 20));\n-        from_u32(self.H5, out.mut_slice(20, 24));\n-        from_u32(self.H6, out.mut_slice(24, 28));\n+    fn input(&mut self, input: &[u8]) {\n+        assert!(!self.finished)\n+        // Assumes that input.len() can be converted to u64 without overflow\n+        self.length_bits = shift_add_check_overflow(self.length_bits, input.len() as u64, 3);\n+        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n     }\n-}\n-\n-static K32: [u32, ..64] = [\n-    0x428a2f98u32, 0x71374491u32, 0xb5c0fbcfu32, 0xe9b5dba5u32,\n-    0x3956c25bu32, 0x59f111f1u32, 0x923f82a4u32, 0xab1c5ed5u32,\n-    0xd807aa98u32, 0x12835b01u32, 0x243185beu32, 0x550c7dc3u32,\n-    0x72be5d74u32, 0x80deb1feu32, 0x9bdc06a7u32, 0xc19bf174u32,\n-    0xe49b69c1u32, 0xefbe4786u32, 0x0fc19dc6u32, 0x240ca1ccu32,\n-    0x2de92c6fu32, 0x4a7484aau32, 0x5cb0a9dcu32, 0x76f988dau32,\n-    0x983e5152u32, 0xa831c66du32, 0xb00327c8u32, 0xbf597fc7u32,\n-    0xc6e00bf3u32, 0xd5a79147u32, 0x06ca6351u32, 0x14292967u32,\n-    0x27b70a85u32, 0x2e1b2138u32, 0x4d2c6dfcu32, 0x53380d13u32,\n-    0x650a7354u32, 0x766a0abbu32, 0x81c2c92eu32, 0x92722c85u32,\n-    0xa2bfe8a1u32, 0xa81a664bu32, 0xc24b8b70u32, 0xc76c51a3u32,\n-    0xd192e819u32, 0xd6990624u32, 0xf40e3585u32, 0x106aa070u32,\n-    0x19a4c116u32, 0x1e376c08u32, 0x2748774cu32, 0x34b0bcb5u32,\n-    0x391c0cb3u32, 0x4ed8aa4au32, 0x5b9cca4fu32, 0x682e6ff3u32,\n-    0x748f82eeu32, 0x78a5636fu32, 0x84c87814u32, 0x8cc70208u32,\n-    0x90befffau32, 0xa4506cebu32, 0xbef9a3f7u32, 0xc67178f2u32\n-];\n \n-struct Sha512 {\n-    priv engine: Engine512\n-}\n+    fn finish(&mut self) {\n+        if self.finished {\n+            return;\n+        }\n \n-struct Sha384 {\n-    priv engine: Engine512\n-}\n+        self.buffer.standard_padding(8, |input: &[u8]| { self.state.process_block(input) });\n+        write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n+        write_u32_be(self.buffer.next(4), self.length_bits as u32);\n+        self.state.process_block(self.buffer.full_buffer());\n \n-struct Sha512Trunc256 {\n-    priv engine: Engine512\n+        self.finished = true;\n+    }\n }\n \n-struct Sha512Trunc224 {\n-    priv engine: Engine512\n-}\n \n struct Sha256 {\n     priv engine: Engine256\n }\n \n-struct Sha224 {\n-    priv engine: Engine256\n-}\n-\n-impl Sha512 {\n-    /**\n-     * Construct an new instance of a SHA-512 digest.\n-     */\n-    pub fn new() -> Sha512 {\n-        Sha512 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0x6a09e667f3bcc908u64,\n-                H1: 0xbb67ae8584caa73bu64,\n-                H2: 0x3c6ef372fe94f82bu64,\n-                H3: 0xa54ff53a5f1d36f1u64,\n-                H4: 0x510e527fade682d1u64,\n-                H5: 0x9b05688c2b3e6c1fu64,\n-                H6: 0x1f83d9abfb41bd6bu64,\n-                H7: 0x5be0cd19137e2179u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n-        }\n-    }\n-}\n-\n-impl Sha384 {\n-    /**\n-     * Construct an new instance of a SHA-384 digest.\n-     */\n-    pub fn new() -> Sha384 {\n-        Sha384 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0xcbbb9d5dc1059ed8u64,\n-                H1: 0x629a292a367cd507u64,\n-                H2: 0x9159015a3070dd17u64,\n-                H3: 0x152fecd8f70e5939u64,\n-                H4: 0x67332667ffc00b31u64,\n-                H5: 0x8eb44a8768581511u64,\n-                H6: 0xdb0c2e0d64f98fa7u64,\n-                H7: 0x47b5481dbefa4fa4u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n-        }\n-    }\n-}\n-\n-impl Sha512Trunc256 {\n-    /**\n-     * Construct an new instance of a SHA-512/256 digest.\n-     */\n-    pub fn new() -> Sha512Trunc256 {\n-        Sha512Trunc256 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0x22312194fc2bf72cu64,\n-                H1: 0x9f555fa3c84c64c2u64,\n-                H2: 0x2393b86b6f53b151u64,\n-                H3: 0x963877195940eabdu64,\n-                H4: 0x96283ee2a88effe3u64,\n-                H5: 0xbe5e1e2553863992u64,\n-                H6: 0x2b0199fc2c85b8aau64,\n-                H7: 0x0eb72ddc81c52ca2u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n-        }\n-    }\n-}\n-\n-impl Sha512Trunc224 {\n-    /**\n-     * Construct an new instance of a SHA-512/224 digest.\n-     */\n-    pub fn new() -> Sha512Trunc224 {\n-        Sha512Trunc224 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0x8c3d37c819544da2u64,\n-                H1: 0x73e1996689dcd4d6u64,\n-                H2: 0x1dfab7ae32ff9c82u64,\n-                H3: 0x679dd514582f9fcfu64,\n-                H4: 0x0f6d2b697bd44da8u64,\n-                H5: 0x77e36f7304c48942u64,\n-                H6: 0x3f9d85a86a1d36c8u64,\n-                H7: 0x1112e6ad91d692a1u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n-        }\n-    }\n-}\n-\n impl Sha256 {\n     /**\n      * Construct an new instance of a SHA-256 digest.\n      */\n     pub fn new() -> Sha256 {\n         Sha256 {\n-            engine: Engine256 {\n-                input_buffer: [0u8, ..4],\n-                input_buffer_idx: 0,\n-                length_bytes: 0,\n-                H0: 0x6a09e667u32,\n-                H1: 0xbb67ae85u32,\n-                H2: 0x3c6ef372u32,\n-                H3: 0xa54ff53au32,\n-                H4: 0x510e527fu32,\n-                H5: 0x9b05688cu32,\n-                H6: 0x1f83d9abu32,\n-                H7: 0x5be0cd19u32,\n-                W: [0u32, ..64],\n-                W_idx: 0,\n-                finished: false,\n-            }\n-        }\n-    }\n-}\n-\n-impl Sha224 {\n-    /**\n-     * Construct an new instance of a SHA-224 digest.\n-     */\n-    pub fn new() -> Sha224 {\n-        Sha224 {\n-            engine: Engine256 {\n-                input_buffer: [0u8, ..4],\n-                input_buffer_idx: 0,\n-                length_bytes: 0,\n-                H0: 0xc1059ed8u32,\n-                H1: 0x367cd507u32,\n-                H2: 0x3070dd17u32,\n-                H3: 0xf70e5939u32,\n-                H4: 0xffc00b31u32,\n-                H5: 0x68581511u32,\n-                H6: 0x64f98fa7u32,\n-                H7: 0xbefa4fa4u32,\n-                W: [0u32, ..64],\n-                W_idx: 0,\n-                finished: false,\n-            }\n+            engine: Engine256::new(&H256)\n         }\n     }\n }\n \n-impl Digest for Sha512 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.result_512(out)\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x6a09e667f3bcc908u64;\n-        self.engine.H1 = 0xbb67ae8584caa73bu64;\n-        self.engine.H2 = 0x3c6ef372fe94f82bu64;\n-        self.engine.H3 = 0xa54ff53a5f1d36f1u64;\n-        self.engine.H4 = 0x510e527fade682d1u64;\n-        self.engine.H5 = 0x9b05688c2b3e6c1fu64;\n-        self.engine.H6 = 0x1f83d9abfb41bd6bu64;\n-        self.engine.H7 = 0x5be0cd19137e2179u64;\n-    }\n-\n-    fn output_bits(&self) -> uint { 512 }\n-}\n-\n-impl Digest for Sha384 {\n+impl Digest for Sha256 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n-        self.engine.result_384(out)\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0xcbbb9d5dc1059ed8u64;\n-        self.engine.H1 = 0x629a292a367cd507u64;\n-        self.engine.H2 = 0x9159015a3070dd17u64;\n-        self.engine.H3 = 0x152fecd8f70e5939u64;\n-        self.engine.H4 = 0x67332667ffc00b31u64;\n-        self.engine.H5 = 0x8eb44a8768581511u64;\n-        self.engine.H6 = 0xdb0c2e0d64f98fa7u64;\n-        self.engine.H7 = 0x47b5481dbefa4fa4u64;\n-    }\n-\n-    fn output_bits(&self) -> uint { 384 }\n-}\n+        self.engine.finish();\n \n-impl Digest for Sha512Trunc256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.result_256(out)\n+        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n+        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n+        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n+        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n+        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n+        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n+        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n+        write_u32_be(out.mut_slice(28, 32), self.engine.state.H7);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x22312194fc2bf72cu64;\n-        self.engine.H1 = 0x9f555fa3c84c64c2u64;\n-        self.engine.H2 = 0x2393b86b6f53b151u64;\n-        self.engine.H3 = 0x963877195940eabdu64;\n-        self.engine.H4 = 0x96283ee2a88effe3u64;\n-        self.engine.H5 = 0xbe5e1e2553863992u64;\n-        self.engine.H6 = 0x2b0199fc2c85b8aau64;\n-        self.engine.H7 = 0x0eb72ddc81c52ca2u64;\n+        self.engine.reset(&H256);\n     }\n \n     fn output_bits(&self) -> uint { 256 }\n }\n \n-impl Digest for Sha512Trunc224 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.result_224(out)\n-    }\n+static H256: [u32, ..8] = [\n+    0x6a09e667,\n+    0xbb67ae85,\n+    0x3c6ef372,\n+    0xa54ff53a,\n+    0x510e527f,\n+    0x9b05688c,\n+    0x1f83d9ab,\n+    0x5be0cd19\n+];\n \n-    fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x8c3d37c819544da2u64;\n-        self.engine.H1 = 0x73e1996689dcd4d6u64;\n-        self.engine.H2 = 0x1dfab7ae32ff9c82u64;\n-        self.engine.H3 = 0x679dd514582f9fcfu64;\n-        self.engine.H4 = 0x0f6d2b697bd44da8u64;\n-        self.engine.H5 = 0x77e36f7304c48942u64;\n-        self.engine.H6 = 0x3f9d85a86a1d36c8u64;\n-        self.engine.H7 = 0x1112e6ad91d692a1u64;\n-    }\n \n-    fn output_bits(&self) -> uint { 224 }\n+struct Sha224 {\n+    priv engine: Engine256\n }\n \n-impl Digest for Sha256 {\n-    fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n-    }\n-\n-    fn result(&mut self, out: &mut [u8]) {\n-        self.engine.result_256(out)\n-    }\n-\n-    fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x6a09e667u32;\n-        self.engine.H1 = 0xbb67ae85u32;\n-        self.engine.H2 = 0x3c6ef372u32;\n-        self.engine.H3 = 0xa54ff53au32;\n-        self.engine.H4 = 0x510e527fu32;\n-        self.engine.H5 = 0x9b05688cu32;\n-        self.engine.H6 = 0x1f83d9abu32;\n-        self.engine.H7 = 0x5be0cd19u32;\n+impl Sha224 {\n+    /**\n+     * Construct an new instance of a SHA-224 digest.\n+     */\n+    pub fn new() -> Sha224 {\n+        Sha224 {\n+            engine: Engine256::new(&H224)\n+        }\n     }\n-\n-    fn output_bits(&self) -> uint { 256 }\n }\n \n impl Digest for Sha224 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n-        self.engine.result_224(out)\n+        self.engine.finish();\n+        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n+        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n+        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n+        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n+        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n+        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n+        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0xc1059ed8u32;\n-        self.engine.H1 = 0x367cd507u32;\n-        self.engine.H2 = 0x3070dd17u32;\n-        self.engine.H3 = 0xf70e5939u32;\n-        self.engine.H4 = 0xffc00b31u32;\n-        self.engine.H5 = 0x68581511u32;\n-        self.engine.H6 = 0x64f98fa7u32;\n-        self.engine.H7 = 0xbefa4fa4u32;\n+        self.engine.reset(&H224);\n     }\n \n     fn output_bits(&self) -> uint { 224 }\n }\n \n+static H224: [u32, ..8] = [\n+    0xc1059ed8,\n+    0x367cd507,\n+    0x3070dd17,\n+    0xf70e5939,\n+    0xffc00b31,\n+    0x68581511,\n+    0x64f98fa7,\n+    0xbefa4fa4\n+];\n+\n \n #[cfg(test)]\n mod tests {\n-    use digest::{Digest, DigestUtil};\n+    use cryptoutil::test::test_digest_1million_random;\n+    use digest::Digest;\n     use sha2::{Sha512, Sha384, Sha512Trunc256, Sha512Trunc224, Sha256, Sha224};\n \n     struct Test {\n@@ -1117,6 +913,25 @@ mod tests {\n \n         test_hash(sh, tests);\n     }\n+\n+    #[test]\n+    fn test_1million_random_sha512() {\n+        let mut sh = Sha512::new();\n+        test_digest_1million_random(\n+            &mut sh,\n+            128,\n+            \"e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb\" +\n+            \"de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b\");\n+        }\n+\n+    #[test]\n+    fn test_1million_random_sha256() {\n+        let mut sh = Sha256::new();\n+        test_digest_1million_random(\n+            &mut sh,\n+            64,\n+            \"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0\");\n+    }\n }\n \n "}, {"sha": "e6134bb340cd8c45b708ab71d6f3539b45b4061d", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=efd6eafeb4f734ef7883afadb4e50099430c76f2", "patch": "@@ -67,6 +67,8 @@ pub mod dlist;\n pub mod treemap;\n \n // Crypto\n+#[path=\"crypto/cryptoutil.rs\"]\n+mod cryptoutil;\n #[path=\"crypto/digest.rs\"]\n pub mod digest;\n #[path=\"crypto/sha1.rs\"]"}, {"sha": "d28407a984a019b8f4bb9183a8e93f38c59dd808", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd6eafeb4f734ef7883afadb4e50099430c76f2/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=efd6eafeb4f734ef7883afadb4e50099430c76f2", "patch": "@@ -10,8 +10,7 @@\n \n #[allow(missing_doc)];\n \n-\n-use digest::DigestUtil;\n+use digest::Digest;\n use json;\n use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};"}]}