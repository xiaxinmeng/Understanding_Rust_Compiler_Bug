{"sha": "405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "node_id": "C_kwDOAAsO6NoAKDQwNWU0OGYxYWMwMjk3ZmRlMWZkYzQ5ZWE0NWIwYmE1YWNjOTc3YmQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-07T19:43:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-07T19:43:18Z"}, "message": "Rollup merge of #101936 - IntQuant:issue-100717-infer-4, r=compiler-errors\n\nMigrating rustc_infer to session diagnostics (part 3)\n\n``@rustbot`` label +A-translation\nr? rust-lang/diagnostics\ncc https://github.com/rust-lang/rust/issues/100717\n\nSeems like a part of static_impl_trait.rs emits suggestions in a loop, and note.rs needs to have two instances of the same subdiagnostic, so these will need to wait until we have eager translation/list support.\nOther than that, there is only error_reporting/mod.rs left to migrate.", "tree": {"sha": "d6a8b05c9156523031f3303421bb5a7e3fdd9cee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6a8b05c9156523031f3303421bb5a7e3fdd9cee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjuctWCRBK7hj4Ov3rIwAAOogIAEpvu6uj5GY0fwm3rk0MP82O\nL0u50b7OjbI2wOCjh0hDn560q3KDpM0He5mNoAvJH3fvASEnGm3ssCpx9y0wUWJ4\nkhXn2VCmMDO1M5jJsSCFlLrwdJIhzv4hNN0XTkt6EfvcobnJFeVcn7dl1gqo9+nm\neYBJbegApIhZsxLSp3fsDM618LfJlfQ0zh52jq28WK8GOhxbquVAYZtrB2sULiFQ\nyHbHt/kODML8I/eZVQBkhAAgilTamYYfJXBb2d8NN5q7xeew4Nnb3t8bybybpJ70\nn5EEplbT8lPfZCz6JzpvjYt13Pog68vD9zSz+dwOQnCfB7tYjifINN6DNaDRu/s=\n=lCwI\n-----END PGP SIGNATURE-----\n", "payload": "tree d6a8b05c9156523031f3303421bb5a7e3fdd9cee\nparent b1691f6413a4afd7529ab309965123cc63e82021\nparent 0c50e1f146efc594eb84146c598d577c9f8a27d2\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673120598 +0100\ncommitter GitHub <noreply@github.com> 1673120598 +0100\n\nRollup merge of #101936 - IntQuant:issue-100717-infer-4, r=compiler-errors\n\nMigrating rustc_infer to session diagnostics (part 3)\n\n``@rustbot`` label +A-translation\nr? rust-lang/diagnostics\ncc https://github.com/rust-lang/rust/issues/100717\n\nSeems like a part of static_impl_trait.rs emits suggestions in a loop, and note.rs needs to have two instances of the same subdiagnostic, so these will need to wait until we have eager translation/list support.\nOther than that, there is only error_reporting/mod.rs left to migrate.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "html_url": "https://github.com/rust-lang/rust/commit/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1691f6413a4afd7529ab309965123cc63e82021", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1691f6413a4afd7529ab309965123cc63e82021", "html_url": "https://github.com/rust-lang/rust/commit/b1691f6413a4afd7529ab309965123cc63e82021"}, {"sha": "0c50e1f146efc594eb84146c598d577c9f8a27d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c50e1f146efc594eb84146c598d577c9f8a27d2", "html_url": "https://github.com/rust-lang/rust/commit/0c50e1f146efc594eb84146c598d577c9f8a27d2"}], "stats": {"total": 1136, "additions": 810, "deletions": 326}, "files": [{"sha": "52babec4f9ea74b730646cd28f79771f66ac7c5b", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "patch": "@@ -172,3 +172,142 @@ infer_msl_unmet_req = because this has an unmet lifetime requirement\n infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n infer_suggest_add_let_for_letchains = consider adding `let`\n+\n+infer_explicit_lifetime_required_with_ident = explicit lifetime required in the type of `{$simple_ident}`\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_with_param_type = explicit lifetime required in parameter type\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_sugg_with_ident = add explicit lifetime `{$named}` to the type of `{$simple_ident}`\n+\n+infer_explicit_lifetime_required_sugg_with_param_type = add explicit lifetime `{$named}` to type\n+\n+infer_actual_impl_expl_expected_signature_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n+infer_actual_impl_expl_expected_passive_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_passive_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n+infer_actual_impl_expl_expected_other_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`\n+\n+infer_actual_impl_expl_but_actually_implements_trait = ...but it actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+infer_actual_impl_expl_but_actually_implemented_for_ty = ...but `{$trait_path}` is actually implemented for the type `{$ty}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+infer_actual_impl_expl_but_actually_ty_implements = ...but `{$ty}` actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+\n+infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n+    .label_satisfy = doesn't satisfy where-clause\n+    .label_where = due to a where-clause on `{$def_id}`...\n+    .label_dup = implementation of `{$trait_def_id}` is not general enough\n+\n+infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signature\n+    .found = found `{$found}`\n+    .expected = expected `{$expected}`\n+    .expected_found = expected `{$expected}`\n+               {\"   \"}found `{$found}`\n+\n+infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+infer_tid_consider_borrowing = consider borrowing this type parameter in the trait\n+infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+\n+infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s 'static` requirement\n+infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n+infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+\n+infer_but_calling_introduces = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$lifetime_kind ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{assoc_item}` introduces an implicit `'static` lifetime requirement\n+    .label1 = {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }\n+    .label2 = ...is used and required to live as long as `'static` here because of an implicit lifetime bound on the {$has_impl_path ->\n+        [named] `impl` of `{$impl_path}`\n+        *[anon] inherent `impl`\n+    }\n+\n+infer_but_needs_to_satisfy = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but it needs to satisfy a `'static` lifetime requirement\n+    .influencer = this data with {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }...\n+    .require = {$spans_empty ->\n+        *[true] ...is used and required to live as long as `'static` here\n+        [false] ...and is required to live as long as `'static` here\n+    }\n+    .used_here = ...is used here...\n+    .introduced_by_bound = 'static` lifetime requirement introduced by this bound\n+\n+infer_more_targeted = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{$ident}` introduces an implicit `'static` lifetime requirement\n+\n+infer_ril_introduced_here = `'static` requirement introduced here\n+infer_ril_introduced_by = requirement introduced by this return type\n+infer_ril_because_of = because of this returned expression\n+infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type"}, {"sha": "033a1842edb25c57c95ea20d97c910be67a82c3e", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 416, "deletions": 5, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "patch": "@@ -1,15 +1,18 @@\n use hir::GenericParamKind;\n use rustc_errors::{\n     fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n-    MultiSpan, SubdiagnosticMessage,\n+    IntoDiagnosticArg, MultiSpan, SubdiagnosticMessage,\n };\n use rustc_hir as hir;\n-use rustc_hir::{FnRetTy, Ty};\n+use rustc_hir::FnRetTy;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_middle::ty::{Region, TyCtxt};\n+use rustc_middle::ty::print::TraitRefPrintOnlyTraitPath;\n+use rustc_middle::ty::{Binder, FnSig, Region, Ty, TyCtxt};\n use rustc_span::symbol::kw;\n+use rustc_span::Symbol;\n use rustc_span::{symbol::Ident, BytePos, Span};\n \n+use crate::infer::error_reporting::nice_region_error::placeholder_error::Highlighted;\n use crate::infer::error_reporting::{\n     need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n     ObligationCauseAsDiagArg,\n@@ -357,8 +360,8 @@ impl AddToDiagnostic for LifetimeMismatchLabels {\n pub struct AddLifetimeParamsSuggestion<'a> {\n     pub tcx: TyCtxt<'a>,\n     pub sub: Region<'a>,\n-    pub ty_sup: &'a Ty<'a>,\n-    pub ty_sub: &'a Ty<'a>,\n+    pub ty_sup: &'a hir::Ty<'a>,\n+    pub ty_sub: &'a hir::Ty<'a>,\n     pub add_note: bool,\n }\n \n@@ -520,3 +523,411 @@ pub struct MismatchedStaticLifetime<'a> {\n     #[subdiagnostic]\n     pub implicit_static_lifetimes: Vec<ImplicitStaticLifetimeSubdiag>,\n }\n+\n+#[derive(Diagnostic)]\n+pub enum ExplicitLifetimeRequired<'a> {\n+    #[diag(infer_explicit_lifetime_required_with_ident, code = \"E0621\")]\n+    WithIdent {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        simple_ident: Ident,\n+        named: String,\n+        #[suggestion(\n+            infer_explicit_lifetime_required_sugg_with_ident,\n+            code = \"{new_ty}\",\n+            applicability = \"unspecified\"\n+        )]\n+        new_ty_span: Span,\n+        #[skip_arg]\n+        new_ty: Ty<'a>,\n+    },\n+    #[diag(infer_explicit_lifetime_required_with_param_type, code = \"E0621\")]\n+    WithParamType {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        named: String,\n+        #[suggestion(\n+            infer_explicit_lifetime_required_sugg_with_param_type,\n+            code = \"{new_ty}\",\n+            applicability = \"unspecified\"\n+        )]\n+        new_ty_span: Span,\n+        #[skip_arg]\n+        new_ty: Ty<'a>,\n+    },\n+}\n+\n+pub enum TyOrSig<'tcx> {\n+    Ty(Highlighted<'tcx, Ty<'tcx>>),\n+    ClosureSig(Highlighted<'tcx, Binder<'tcx, FnSig<'tcx>>>),\n+}\n+\n+impl IntoDiagnosticArg for TyOrSig<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        match self {\n+            TyOrSig::Ty(ty) => ty.into_diagnostic_arg(),\n+            TyOrSig::ClosureSig(sig) => sig.into_diagnostic_arg(),\n+        }\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ActualImplExplNotes<'tcx> {\n+    #[note(infer_actual_impl_expl_expected_signature_two)]\n+    ExpectedSignatureTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_any)]\n+    ExpectedSignatureAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_some)]\n+    ExpectedSignatureSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_nothing)]\n+    ExpectedSignatureNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_two)]\n+    ExpectedPassiveTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_any)]\n+    ExpectedPassiveAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_some)]\n+    ExpectedPassiveSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_nothing)]\n+    ExpectedPassiveNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_two)]\n+    ExpectedOtherTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_any)]\n+    ExpectedOtherAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_some)]\n+    ExpectedOtherSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_nothing)]\n+    ExpectedOtherNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_implements_trait)]\n+    ButActuallyImplementsTrait {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_implemented_for_ty)]\n+    ButActuallyImplementedForTy {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+        ty: String,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_ty_implements)]\n+    ButActuallyTyImplements {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+        ty: String,\n+    },\n+}\n+\n+pub enum ActualImplExpectedKind {\n+    Signature,\n+    Passive,\n+    Other,\n+}\n+\n+pub enum ActualImplExpectedLifetimeKind {\n+    Two,\n+    Any,\n+    Some,\n+    Nothing,\n+}\n+\n+impl<'tcx> ActualImplExplNotes<'tcx> {\n+    pub fn new_expected(\n+        kind: ActualImplExpectedKind,\n+        lt_kind: ActualImplExpectedLifetimeKind,\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    ) -> Self {\n+        match (kind, lt_kind) {\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedSignatureTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedSignatureAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedSignatureSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedSignatureNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedPassiveTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedPassiveAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedPassiveSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedPassiveNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedOtherTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedOtherAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedOtherSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedOtherNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_trait_placeholder_mismatch)]\n+pub struct TraitPlaceholderMismatch<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(label_satisfy)]\n+    pub satisfy_span: Option<Span>,\n+    #[label(label_where)]\n+    pub where_span: Option<Span>,\n+    #[label(label_dup)]\n+    pub dup_span: Option<Span>,\n+    pub def_id: String,\n+    pub trait_def_id: String,\n+\n+    #[subdiagnostic]\n+    pub actual_impl_expl_notes: Vec<ActualImplExplNotes<'tcx>>,\n+}\n+\n+pub struct ConsiderBorrowingParamHelp {\n+    pub spans: Vec<Span>,\n+}\n+\n+impl AddToDiagnostic for ConsiderBorrowingParamHelp {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let mut type_param_span: MultiSpan = self.spans.clone().into();\n+        for &span in &self.spans {\n+            // Seems like we can't call f() here as Into<DiagnosticMessage> is required\n+            type_param_span.push_span_label(span, fluent::infer_tid_consider_borrowing);\n+        }\n+        let msg = f(diag, fluent::infer_tid_param_help.into());\n+        diag.span_help(type_param_span, msg);\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(infer_tid_rel_help)]\n+pub struct RelationshipHelp;\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_trait_impl_diff)]\n+pub struct TraitImplDiff {\n+    #[primary_span]\n+    #[label(found)]\n+    pub sp: Span,\n+    #[label(expected)]\n+    pub trait_sp: Span,\n+    #[note(expected_found)]\n+    pub note: (),\n+    #[subdiagnostic]\n+    pub param_help: ConsiderBorrowingParamHelp,\n+    #[subdiagnostic]\n+    // Seems like subdiagnostics are always pushed to the end, so this one\n+    // also has to be a subdiagnostic to maintain order.\n+    pub rel_help: Option<RelationshipHelp>,\n+    pub expected: String,\n+    pub found: String,\n+}\n+\n+pub struct DynTraitConstraintSuggestion {\n+    pub span: Span,\n+    pub ident: Ident,\n+}\n+\n+impl AddToDiagnostic for DynTraitConstraintSuggestion {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let mut multi_span: MultiSpan = vec![self.span].into();\n+        multi_span.push_span_label(self.span, fluent::infer_dtcs_has_lifetime_req_label);\n+        multi_span.push_span_label(self.ident.span, fluent::infer_dtcs_introduces_requirement);\n+        let msg = f(diag, fluent::infer_dtcs_has_req_note.into());\n+        diag.span_note(multi_span, msg);\n+        let msg = f(diag, fluent::infer_dtcs_suggestion.into());\n+        diag.span_suggestion_verbose(\n+            self.span.shrink_to_hi(),\n+            msg,\n+            \" + '_\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_but_calling_introduces, code = \"E0772\")]\n+pub struct ButCallingIntroduces {\n+    #[label(label1)]\n+    pub param_ty_span: Span,\n+    #[primary_span]\n+    #[label(label2)]\n+    pub cause_span: Span,\n+\n+    pub has_param_name: bool,\n+    pub param_name: String,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+    pub assoc_item: Symbol,\n+    pub has_impl_path: bool,\n+    pub impl_path: String,\n+}\n+\n+pub struct ReqIntroducedLocations {\n+    pub span: MultiSpan,\n+    pub spans: Vec<Span>,\n+    pub fn_decl_span: Span,\n+    pub cause_span: Span,\n+    pub add_label: bool,\n+}\n+\n+impl AddToDiagnostic for ReqIntroducedLocations {\n+    fn add_to_diagnostic_with<F>(mut self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        for sp in self.spans {\n+            self.span.push_span_label(sp, fluent::infer_ril_introduced_here);\n+        }\n+\n+        if self.add_label {\n+            self.span.push_span_label(self.fn_decl_span, fluent::infer_ril_introduced_by);\n+        }\n+        self.span.push_span_label(self.cause_span, fluent::infer_ril_because_of);\n+        let msg = f(diag, fluent::infer_ril_static_introduced_by.into());\n+        diag.span_note(self.span, msg);\n+    }\n+}\n+\n+pub struct MoreTargeted {\n+    pub ident: Symbol,\n+}\n+\n+impl AddToDiagnostic for MoreTargeted {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.code(rustc_errors::error_code!(E0772));\n+        diag.set_primary_message(fluent::infer_more_targeted);\n+        diag.set_arg(\"ident\", self.ident);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_but_needs_to_satisfy, code = \"E0759\")]\n+pub struct ButNeedsToSatisfy {\n+    #[primary_span]\n+    pub sp: Span,\n+    #[label(influencer)]\n+    pub influencer_point: Span,\n+    #[label(used_here)]\n+    pub spans: Vec<Span>,\n+    #[label(require)]\n+    pub require_span_as_label: Option<Span>,\n+    #[note(require)]\n+    pub require_span_as_note: Option<Span>,\n+    #[note(introduced_by_bound)]\n+    pub bound: Option<Span>,\n+\n+    #[subdiagnostic]\n+    pub req_introduces_loc: Option<ReqIntroducedLocations>,\n+\n+    pub spans_empty: bool,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+}"}, {"sha": "59fb74eb54378f0c1e836c33214251659871d701", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "patch": "@@ -9,7 +9,7 @@ mod different_lifetimes;\n pub mod find_anon_type;\n mod mismatched_static_lifetime;\n mod named_anon_conflict;\n-mod placeholder_error;\n+pub(crate) mod placeholder_error;\n mod placeholder_relation;\n mod static_impl_trait;\n mod trait_impl_difference;"}, {"sha": "4e13ec90228d66c8b451cb885b17ed794094e258", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "patch": "@@ -1,8 +1,11 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n-use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use crate::{\n+    errors::ExplicitLifetimeRequired,\n+    infer::error_reporting::nice_region_error::find_anon_type::find_anon_type,\n+};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_middle::ty;\n use rustc_span::symbol::kw;\n \n@@ -86,31 +89,17 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         {\n             return None;\n         }\n-\n-        let (error_var, span_label_var) = match param.pat.simple_ident() {\n-            Some(simple_ident) => (\n-                format!(\"the type of `{}`\", simple_ident),\n-                format!(\"the type of `{}`\", simple_ident),\n-            ),\n-            None => (\"parameter type\".to_owned(), \"type\".to_owned()),\n+        let named = named.to_string();\n+        let err = match param.pat.simple_ident() {\n+            Some(simple_ident) => ExplicitLifetimeRequired::WithIdent {\n+                span,\n+                simple_ident,\n+                named,\n+                new_ty_span,\n+                new_ty,\n+            },\n+            None => ExplicitLifetimeRequired::WithParamType { span, named, new_ty_span, new_ty },\n         };\n-\n-        let mut diag = struct_span_err!(\n-            self.tcx().sess,\n-            span,\n-            E0621,\n-            \"explicit lifetime required in {}\",\n-            error_var\n-        );\n-\n-        diag.span_label(span, format!(\"lifetime `{}` required\", named));\n-        diag.span_suggestion(\n-            new_ty_span,\n-            &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n-            new_ty,\n-            Applicability::Unspecified,\n-        );\n-\n-        Some(diag)\n+        Some(self.tcx().sess.parse_sess.create_err(err))\n     }\n }"}, {"sha": "202f39521e967d7283fbfe8b747ccb94788878ed", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 155, "deletions": 156, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "patch": "@@ -1,18 +1,58 @@\n+use crate::errors::{\n+    ActualImplExpectedKind, ActualImplExpectedLifetimeKind, ActualImplExplNotes,\n+    TraitPlaceholderMismatch, TyOrSig,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, RePlaceholder, ReVar, Region, TyCtxt};\n \n-use std::fmt::{self, Write};\n+use std::fmt;\n+\n+// HACK(eddyb) maybe move this in a more central location.\n+#[derive(Copy, Clone)]\n+pub struct Highlighted<'tcx, T> {\n+    tcx: TyCtxt<'tcx>,\n+    highlight: RegionHighlightMode<'tcx>,\n+    value: T,\n+}\n+\n+impl<'tcx, T> IntoDiagnosticArg for Highlighted<'tcx, T>\n+where\n+    T: for<'a> Print<'tcx, FmtPrinter<'a, 'tcx>, Error = fmt::Error, Output = FmtPrinter<'a, 'tcx>>,\n+{\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        rustc_errors::DiagnosticArgValue::Str(self.to_string().into())\n+    }\n+}\n+\n+impl<'tcx, T> Highlighted<'tcx, T> {\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'tcx, U> {\n+        Highlighted { tcx: self.tcx, highlight: self.highlight, value: f(self.value) }\n+    }\n+}\n+\n+impl<'tcx, T> fmt::Display for Highlighted<'tcx, T>\n+where\n+    T: for<'a> Print<'tcx, FmtPrinter<'a, 'tcx>, Error = fmt::Error, Output = FmtPrinter<'a, 'tcx>>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n+        printer.region_highlight_mode = self.highlight;\n+\n+        let s = self.value.print(printer)?.into_buffer();\n+        f.write_str(&s)\n+    }\n+}\n \n impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n@@ -205,26 +245,21 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_substs: SubstsRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let span = cause.span();\n-        let msg = format!(\n-            \"implementation of `{}` is not general enough\",\n-            self.tcx().def_path_str(trait_def_id),\n-        );\n-        let mut err = self.tcx().sess.struct_span_err(span, &msg);\n-\n-        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id)\n-        | ObligationCauseCode::ExprItemObligation(def_id, ..) =\n-            *cause.code()\n-        {\n-            err.span_label(span, \"doesn't satisfy where-clause\");\n-            err.span_label(\n-                self.tcx().def_span(def_id),\n-                &format!(\"due to a where-clause on `{}`...\", self.tcx().def_path_str(def_id)),\n-            );\n-            true\n-        } else {\n-            err.span_label(span, &msg);\n-            false\n-        };\n+\n+        let (leading_ellipsis, satisfy_span, where_span, dup_span, def_id) =\n+            if let ObligationCauseCode::ItemObligation(def_id)\n+            | ObligationCauseCode::ExprItemObligation(def_id, ..) = *cause.code()\n+            {\n+                (\n+                    true,\n+                    Some(span),\n+                    Some(self.tcx().def_span(def_id)),\n+                    None,\n+                    self.tcx().def_path_str(def_id),\n+                )\n+            } else {\n+                (false, None, None, Some(span), String::new())\n+            };\n \n         let expected_trait_ref = self\n             .cx\n@@ -284,8 +319,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             ?expected_self_ty_has_vid,\n         );\n \n-        self.explain_actual_impl_that_was_found(\n-            &mut err,\n+        let actual_impl_expl_notes = self.explain_actual_impl_that_was_found(\n             sub_placeholder,\n             sup_placeholder,\n             has_sub,\n@@ -299,7 +333,15 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             leading_ellipsis,\n         );\n \n-        err\n+        self.tcx().sess.create_err(TraitPlaceholderMismatch {\n+            span,\n+            satisfy_span,\n+            where_span,\n+            dup_span,\n+            def_id,\n+            trait_def_id: self.tcx().def_path_str(trait_def_id),\n+            actual_impl_expl_notes,\n+        })\n     }\n \n     /// Add notes with details about the expected and actual trait refs, with attention to cases\n@@ -309,7 +351,6 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// due to the number of combinations we have to deal with.\n     fn explain_actual_impl_that_was_found(\n         &self,\n-        err: &mut Diagnostic,\n         sub_placeholder: Option<Region<'tcx>>,\n         sup_placeholder: Option<Region<'tcx>>,\n         has_sub: Option<usize>,\n@@ -321,39 +362,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n         leading_ellipsis: bool,\n-    ) {\n-        // HACK(eddyb) maybe move this in a more central location.\n-        #[derive(Copy, Clone)]\n-        struct Highlighted<'tcx, T> {\n-            tcx: TyCtxt<'tcx>,\n-            highlight: RegionHighlightMode<'tcx>,\n-            value: T,\n-        }\n-\n-        impl<'tcx, T> Highlighted<'tcx, T> {\n-            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'tcx, U> {\n-                Highlighted { tcx: self.tcx, highlight: self.highlight, value: f(self.value) }\n-            }\n-        }\n-\n-        impl<'tcx, T> fmt::Display for Highlighted<'tcx, T>\n-        where\n-            T: for<'a> Print<\n-                'tcx,\n-                FmtPrinter<'a, 'tcx>,\n-                Error = fmt::Error,\n-                Output = FmtPrinter<'a, 'tcx>,\n-            >,\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n-                printer.region_highlight_mode = self.highlight;\n-\n-                let s = self.value.print(printer)?.into_buffer();\n-                f.write_str(&s)\n-            }\n-        }\n-\n+    ) -> Vec<ActualImplExplNotes<'tcx>> {\n         // The weird thing here with the `maybe_highlighting_region` calls and the\n         // the match inside is meant to be like this:\n         //\n@@ -380,120 +389,110 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n         expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n         expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n-        err.note(&{\n-            let passive_voice = match (has_sub, has_sup) {\n-                (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n-                (None, None) => {\n-                    expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n-                    match expected_has_vid {\n-                        Some(_) => true,\n-                        None => any_self_ty_has_vid,\n-                    }\n-                }\n-            };\n \n-            let mut note = if same_self_type {\n-                let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n-                self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-\n-                if self_ty.value.is_closure()\n-                    && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n-                {\n-                    let closure_sig = self_ty.map(|closure| {\n-                        if let ty::Closure(_, substs) = closure.kind() {\n-                            self.tcx().signature_unclosure(\n-                                substs.as_closure().sig(),\n-                                rustc_hir::Unsafety::Normal,\n-                            )\n-                        } else {\n-                            bug!(\"type is not longer closure\");\n-                        }\n-                    });\n-\n-                    format!(\n-                        \"{}closure with signature `{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        closure_sig,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n-                } else {\n-                    format!(\n-                        \"{}`{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        self_ty,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n+        let passive_voice = match (has_sub, has_sup) {\n+            (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n+            (None, None) => {\n+                expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n+                match expected_has_vid {\n+                    Some(_) => true,\n+                    None => any_self_ty_has_vid,\n                 }\n-            } else if passive_voice {\n-                format!(\n-                    \"{}`{}` would have to be implemented for the type `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n+            }\n+        };\n+\n+        let (kind, ty_or_sig, trait_path) = if same_self_type {\n+            let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n+            self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+\n+            if self_ty.value.is_closure() && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n+            {\n+                let closure_sig = self_ty.map(|closure| {\n+                    if let ty::Closure(_, substs) = closure.kind() {\n+                        self.tcx().signature_unclosure(\n+                            substs.as_closure().sig(),\n+                            rustc_hir::Unsafety::Normal,\n+                        )\n+                    } else {\n+                        bug!(\"type is not longer closure\");\n+                    }\n+                });\n+                (\n+                    ActualImplExpectedKind::Signature,\n+                    TyOrSig::ClosureSig(closure_sig),\n                     expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n-                format!(\n-                    \"{}`{}` must implement `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                (\n+                    ActualImplExpectedKind::Other,\n+                    TyOrSig::Ty(self_ty),\n                     expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n                 )\n-            };\n+            }\n+        } else if passive_voice {\n+            (\n+                ActualImplExpectedKind::Passive,\n+                TyOrSig::Ty(expected_trait_ref.map(|tr| tr.self_ty())),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+            )\n+        } else {\n+            (\n+                ActualImplExpectedKind::Other,\n+                TyOrSig::Ty(expected_trait_ref.map(|tr| tr.self_ty())),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+            )\n+        };\n \n-            match (has_sub, has_sup) {\n-                (Some(n1), Some(n2)) => {\n-                    let _ = write!(\n-                        note,\n-                        \", for any two lifetimes `'{}` and `'{}`...\",\n-                        std::cmp::min(n1, n2),\n-                        std::cmp::max(n1, n2),\n-                    );\n-                }\n-                (Some(n), _) | (_, Some(n)) => {\n-                    let _ = write!(note, \", for any lifetime `'{}`...\", n,);\n-                }\n-                (None, None) => {\n-                    if let Some(n) = expected_has_vid {\n-                        let _ = write!(note, \", for some specific lifetime `'{}`...\", n,);\n-                    }\n+        let (lt_kind, lifetime_1, lifetime_2) = match (has_sub, has_sup) {\n+            (Some(n1), Some(n2)) => {\n+                (ActualImplExpectedLifetimeKind::Two, std::cmp::min(n1, n2), std::cmp::max(n1, n2))\n+            }\n+            (Some(n), _) | (_, Some(n)) => (ActualImplExpectedLifetimeKind::Any, n, 0),\n+            (None, None) => {\n+                if let Some(n) = expected_has_vid {\n+                    (ActualImplExpectedLifetimeKind::Some, n, 0)\n+                } else {\n+                    (ActualImplExpectedLifetimeKind::Nothing, 0, 0)\n                 }\n             }\n+        };\n \n-            note\n-        });\n+        let note_1 = ActualImplExplNotes::new_expected(\n+            kind,\n+            lt_kind,\n+            leading_ellipsis,\n+            ty_or_sig,\n+            trait_path,\n+            lifetime_1,\n+            lifetime_2,\n+        );\n \n         let mut actual_trait_ref = highlight_trait_ref(actual_trait_ref);\n         actual_trait_ref.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-        err.note(&{\n-            let passive_voice = match actual_has_vid {\n-                Some(_) => any_self_ty_has_vid,\n-                None => true,\n-            };\n \n-            let mut note = if same_self_type {\n-                format!(\n-                    \"...but it actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            } else if passive_voice {\n-                format!(\n-                    \"...but `{}` is actually implemented for the type `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                )\n-            } else {\n-                format!(\n-                    \"...but `{}` actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            };\n+        let passive_voice = match actual_has_vid {\n+            Some(_) => any_self_ty_has_vid,\n+            None => true,\n+        };\n \n-            if let Some(n) = actual_has_vid {\n-                let _ = write!(note, \", for some specific lifetime `'{}`\", n);\n+        let trait_path = actual_trait_ref.map(|tr| tr.print_only_trait_path());\n+        let ty = actual_trait_ref.map(|tr| tr.self_ty()).to_string();\n+        let has_lifetime = actual_has_vid.is_some();\n+        let lifetime = actual_has_vid.unwrap_or_default();\n+\n+        let note_2 = if same_self_type {\n+            ActualImplExplNotes::ButActuallyImplementsTrait { trait_path, has_lifetime, lifetime }\n+        } else if passive_voice {\n+            ActualImplExplNotes::ButActuallyImplementedForTy {\n+                trait_path,\n+                ty,\n+                has_lifetime,\n+                lifetime,\n             }\n+        } else {\n+            ActualImplExplNotes::ButActuallyTyImplements { trait_path, ty, has_lifetime, lifetime }\n+        };\n \n-            note\n-        });\n+        vec![note_1, note_2]\n     }\n }"}, {"sha": "fb0f09198ccc185330064cb2b7df525d1048f26c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 70, "deletions": 110, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "patch": "@@ -1,11 +1,15 @@\n //! Error Reporting for static impl Traits.\n \n+use crate::errors::{\n+    ButCallingIntroduces, ButNeedsToSatisfy, DynTraitConstraintSuggestion, MoreTargeted,\n+    ReqIntroducedLocations,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{AddToDiagnostic, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n@@ -53,46 +57,32 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     }\n \n                     let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-                    let lifetime = if sup_r.has_name() {\n-                        format!(\"lifetime `{}`\", sup_r)\n-                    } else {\n-                        \"an anonymous lifetime `'_`\".to_string()\n+                    let simple_ident = param.param.pat.simple_ident();\n+\n+                    let (has_impl_path, impl_path) = match ctxt.assoc_item.container {\n+                        AssocItemContainer::TraitContainer => {\n+                            let id = ctxt.assoc_item.container_id(tcx);\n+                            (true, tcx.def_path_str(id))\n+                        }\n+                        AssocItemContainer::ImplContainer => (false, String::new()),\n                     };\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        cause.span,\n-                        E0772,\n-                        \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                         requirement\",\n-                        param\n-                            .param\n-                            .pat\n-                            .simple_ident()\n-                            .map(|s| format!(\"`{}`\", s))\n-                            .unwrap_or_else(|| \"`fn` parameter\".to_string()),\n-                        lifetime,\n-                        ctxt.assoc_item.name,\n-                    );\n-                    err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n-                    err.span_label(\n-                        cause.span,\n-                        &format!(\n-                            \"...is used and required to live as long as `'static` here \\\n-                             because of an implicit lifetime bound on the {}\",\n-                            match ctxt.assoc_item.container {\n-                                AssocItemContainer::TraitContainer => {\n-                                    let id = ctxt.assoc_item.container_id(tcx);\n-                                    format!(\"`impl` of `{}`\", tcx.def_path_str(id))\n-                                }\n-                                AssocItemContainer::ImplContainer => \"inherent `impl`\".to_string(),\n-                            },\n-                        ),\n-                    );\n+\n+                    let mut err = self.tcx().sess.create_err(ButCallingIntroduces {\n+                        param_ty_span: param.param_ty_span,\n+                        cause_span: cause.span,\n+                        has_param_name: simple_ident.is_some(),\n+                        param_name: simple_ident.map(|x| x.to_string()).unwrap_or_default(),\n+                        has_lifetime: sup_r.has_name(),\n+                        lifetime: sup_r.to_string(),\n+                        assoc_item: ctxt.assoc_item.name,\n+                        has_impl_path,\n+                        impl_path,\n+                    });\n                     if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n                         let reported = err.emit();\n                         return Some(reported);\n                     } else {\n-                        err.cancel();\n+                        err.cancel()\n                     }\n                 }\n                 return None;\n@@ -108,25 +98,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sp = var_origin.span();\n         let return_sp = sub_origin.span();\n         let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-        let (lifetime_name, lifetime) = if sup_r.has_name() {\n-            (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n-        } else {\n-            (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-        };\n-        let param_name = param\n-            .param\n-            .pat\n-            .simple_ident()\n-            .map(|s| format!(\"`{}`\", s))\n-            .unwrap_or_else(|| \"`fn` parameter\".to_string());\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            sp,\n-            E0759,\n-            \"{} has {} but it needs to satisfy a `'static` lifetime requirement\",\n-            param_name,\n-            lifetime,\n-        );\n+        let lifetime_name = if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n \n         let (mention_influencer, influencer_point) =\n             if sup_origin.span().overlaps(param.param_ty_span) {\n@@ -145,7 +117,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             } else {\n                 (!sup_origin.span().overlaps(return_sp), param.param_ty_span)\n             };\n-        err.span_label(influencer_point, &format!(\"this data with {}...\", lifetime));\n \n         debug!(\"try_report_static_impl_trait: param_info={:?}\", param);\n \n@@ -159,65 +130,70 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         spans.dedup_by_key(|span| (span.lo(), span.hi()));\n \n         // We try to make the output have fewer overlapping spans if possible.\n-        let require_msg = if spans.is_empty() {\n-            \"...is used and required to live as long as `'static` here\"\n-        } else {\n-            \"...and is required to live as long as `'static` here\"\n-        };\n         let require_span =\n             if sup_origin.span().overlaps(return_sp) { sup_origin.span() } else { return_sp };\n \n-        for span in &spans {\n-            err.span_label(*span, \"...is used here...\");\n-        }\n-\n-        if spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp) {\n-            // If any of the \"captured here\" labels appears on the same line or after\n-            // `require_span`, we put it on a note to ensure the text flows by appearing\n-            // always at the end.\n-            err.span_note(require_span, require_msg);\n+        let spans_empty = spans.is_empty();\n+        let require_as_note = spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp);\n+        let bound = if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n+            Some(*bound)\n         } else {\n-            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n-            err.span_label(require_span, require_msg);\n-        }\n+            None\n+        };\n+\n+        let mut subdiag = None;\n \n-        if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n-            err.span_note(*bound, \"`'static` lifetime requirement introduced by this bound\");\n-        }\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = sub_origin {\n             if let ObligationCauseCode::ReturnValue(hir_id)\n             | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n                 if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id.into()) {\n                     let mut span: MultiSpan = fn_decl.output.span().into();\n+                    let mut spans = Vec::new();\n                     let mut add_label = true;\n                     if let hir::FnRetTy::Return(ty) = fn_decl.output {\n                         let mut v = StaticLifetimeVisitor(vec![], tcx.hir());\n                         v.visit_ty(ty);\n                         if !v.0.is_empty() {\n                             span = v.0.clone().into();\n-                            for sp in v.0 {\n-                                span.push_span_label(sp, \"`'static` requirement introduced here\");\n-                            }\n+                            spans = v.0;\n                             add_label = false;\n                         }\n                     }\n-                    if add_label {\n-                        span.push_span_label(\n-                            fn_decl.output.span(),\n-                            \"requirement introduced by this return type\",\n-                        );\n-                    }\n-                    span.push_span_label(cause.span, \"because of this returned expression\");\n-                    err.span_note(\n+                    let fn_decl_span = fn_decl.output.span();\n+\n+                    subdiag = Some(ReqIntroducedLocations {\n                         span,\n-                        \"`'static` lifetime requirement introduced by the return type\",\n-                    );\n+                        spans,\n+                        fn_decl_span,\n+                        cause_span: cause.span,\n+                        add_label,\n+                    });\n                 }\n             }\n         }\n \n+        let diag = ButNeedsToSatisfy {\n+            sp,\n+            influencer_point,\n+            spans: spans.clone(),\n+            // If any of the \"captured here\" labels appears on the same line or after\n+            // `require_span`, we put it on a note to ensure the text flows by appearing\n+            // always at the end.\n+            require_span_as_note: require_as_note.then_some(require_span),\n+            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n+            require_span_as_label: (!require_as_note).then_some(require_span),\n+            req_introduces_loc: subdiag,\n+\n+            has_lifetime: sup_r.has_name(),\n+            lifetime: sup_r.to_string(),\n+            spans_empty,\n+            bound,\n+        };\n+\n+        let mut err = self.tcx().sess.create_err(diag);\n+\n         let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n \n         let mut override_error_code = None;\n@@ -251,12 +227,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {\n             // Provide a more targeted error code and description.\n-            err.code(rustc_errors::error_code!(E0772));\n-            err.set_primary_message(&format!(\n-                \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                requirement\",\n-                param_name, lifetime, ident,\n-            ));\n+            let retarget_subdiag = MoreTargeted { ident };\n+            retarget_subdiag.add_to_diagnostic(&mut err);\n         }\n \n         let arg = match param.param.pat.simple_ident() {\n@@ -551,21 +523,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut traits = vec![];\n             let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n             hir_v.visit_ty(&self_ty);\n-            for span in &traits {\n-                let mut multi_span: MultiSpan = vec![*span].into();\n-                multi_span\n-                    .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n-                multi_span.push_span_label(\n-                    ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\",\n-                );\n-                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"consider relaxing the implicit `'static` requirement\",\n-                    \" + '_\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+            for &span in &traits {\n+                let subdiag = DynTraitConstraintSuggestion { span, ident };\n+                subdiag.add_to_diagnostic(err);\n                 suggested = true;\n             }\n         }"}, {"sha": "17c887a132aaf598b3f6584e8d8d87619a3f742a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405e48f1ac0297fde1fdc49ea45b0ba5acc977bd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=405e48f1ac0297fde1fdc49ea45b0ba5acc977bd", "patch": "@@ -1,10 +1,11 @@\n //! Error Reporting for `impl` items that do not match the obligations from their `trait`.\n \n+use crate::errors::{ConsiderBorrowingParamHelp, RelationshipHelp, TraitImplDiff};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::Subtype;\n use crate::traits::ObligationCauseCode::CompareImplItemObligation;\n-use rustc_errors::{ErrorGuaranteed, MultiSpan};\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n@@ -51,10 +52,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         trait_def_id: DefId,\n     ) -> ErrorGuaranteed {\n         let trait_sp = self.tcx().def_span(trait_def_id);\n-        let mut err = self\n-            .tcx()\n-            .sess\n-            .struct_span_err(sp, \"`impl` item signature doesn't match `trait` item signature\");\n \n         // Mark all unnamed regions in the type with a number.\n         // This diagnostic is called in response to lifetime errors, so be informative.\n@@ -91,9 +88,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let found =\n             self.cx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n \n-        err.span_label(sp, &format!(\"found `{}`\", found));\n-        err.span_label(trait_sp, &format!(\"expected `{}`\", expected));\n-\n         // Get the span of all the used type parameters in the method.\n         let assoc_item = self.tcx().associated_item(trait_def_id);\n         let mut visitor = TypeParamSpanVisitor { tcx: self.tcx(), types: vec![] };\n@@ -110,26 +104,18 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        let mut type_param_span: MultiSpan = visitor.types.to_vec().into();\n-        for &span in &visitor.types {\n-            type_param_span\n-                .push_span_label(span, \"consider borrowing this type parameter in the trait\");\n-        }\n \n-        err.note(&format!(\"expected `{}`\\n   found `{}`\", expected, found));\n-\n-        err.span_help(\n-            type_param_span,\n-            \"the lifetime requirements from the `impl` do not correspond to the requirements in \\\n-             the `trait`\",\n-        );\n-        if visitor.types.is_empty() {\n-            err.help(\n-                \"verify the lifetime relationships in the `trait` and `impl` between the `self` \\\n-                 argument, the other inputs and its output\",\n-            );\n-        }\n-        err.emit()\n+        let diag = TraitImplDiff {\n+            sp,\n+            trait_sp,\n+            note: (),\n+            param_help: ConsiderBorrowingParamHelp { spans: visitor.types.to_vec() },\n+            rel_help: visitor.types.is_empty().then_some(RelationshipHelp),\n+            expected,\n+            found,\n+        };\n+\n+        self.tcx().sess.emit_err(diag)\n     }\n }\n "}]}