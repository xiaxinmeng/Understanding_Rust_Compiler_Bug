{"sha": "04681898f09dad23b2d282a541e1a3b181bed33e", "node_id": "C_kwDOAAsO6NoAKDA0NjgxODk4ZjA5ZGFkMjNiMmQyODJhNTQxZTFhM2IxODFiZWQzM2U", "commit": {"author": {"name": "Orson Peters", "email": "orsonpeters@gmail.com", "date": "2021-09-07T16:46:49Z"}, "committer": {"name": "Urgau", "email": "urgau@numericable.fr", "date": "2022-08-15T10:32:53Z"}, "message": "Added next_up and next_down for f32/f64.", "tree": {"sha": "0f119d948a262c6aeb7718cb25ab7b34284c9532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f119d948a262c6aeb7718cb25ab7b34284c9532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04681898f09dad23b2d282a541e1a3b181bed33e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04681898f09dad23b2d282a541e1a3b181bed33e", "html_url": "https://github.com/rust-lang/rust/commit/04681898f09dad23b2d282a541e1a3b181bed33e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04681898f09dad23b2d282a541e1a3b181bed33e/comments", "author": {"login": "orlp", "id": 202547, "node_id": "MDQ6VXNlcjIwMjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/202547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orlp", "html_url": "https://github.com/orlp", "followers_url": "https://api.github.com/users/orlp/followers", "following_url": "https://api.github.com/users/orlp/following{/other_user}", "gists_url": "https://api.github.com/users/orlp/gists{/gist_id}", "starred_url": "https://api.github.com/users/orlp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orlp/subscriptions", "organizations_url": "https://api.github.com/users/orlp/orgs", "repos_url": "https://api.github.com/users/orlp/repos", "events_url": "https://api.github.com/users/orlp/events{/privacy}", "received_events_url": "https://api.github.com/users/orlp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ce76091c7cef21692a15dce1f0a4c415d245be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce76091c7cef21692a15dce1f0a4c415d245be4", "html_url": "https://github.com/rust-lang/rust/commit/6ce76091c7cef21692a15dce1f0a4c415d245be4"}], "stats": {"total": 323, "additions": 323, "deletions": 0}, "files": [{"sha": "7c38d830636de851dbdcc7ad51b2f45315412df4", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=04681898f09dad23b2d282a541e1a3b181bed33e", "patch": "@@ -678,6 +678,104 @@ impl f32 {\n         unsafe { mem::transmute::<f32, u32>(self) & 0x8000_0000 != 0 }\n     }\n \n+    /// Returns the least number greater than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f32`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`NEG_INFINITY`], this returns [`MIN`];\n+    ///  - if `self` is `-TINY`, this returns -0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `TINY`;\n+    ///  - if `self` is [`MAX`] or [`INFINITY`], this returns [`INFINITY`];\n+    ///  - otherwise the unique least value greater than `self` is returned.\n+    ///\n+    /// The identity `x.next_up() == -(-x).next_down()` holds for all `x`. When `x`\n+    /// is finite `x == x.next_up().next_down()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// // f32::EPSILON is the difference between 1.0 and the next number up.\n+    /// assert_eq!(1.0f32.next_up(), 1.0 + f32::EPSILON);\n+    /// // But not for most numbers.\n+    /// assert!(0.1f32.next_up() < 0.1 + f32::EPSILON);\n+    /// assert_eq!(16777216f32.next_up(), 16777218.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"none\")]\n+    pub const fn next_up(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const TINY_BITS: u32 = 0x1; // Smallest positive f32.\n+        const CLEAR_SIGN_MASK: u32 = 0x7fff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            TINY_BITS\n+        } else if bits == abs {\n+            bits + 1\n+        } else {\n+            bits - 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n+    /// Returns the greatest number less than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f32`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`INFINITY`], this returns [`MAX`];\n+    ///  - if `self` is `TINY`, this returns 0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `-TINY`;\n+    ///  - if `self` is [`MIN`] or [`NEG_INFINITY`], this returns [`NEG_INFINITY`];\n+    ///  - otherwise the unique greatest value less than `self` is returned.\n+    ///\n+    /// The identity `x.next_down() == -(-x).next_up()` holds for all `x`. When `x`\n+    /// is finite `x == x.next_down().next_up()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// let x = 1.0f32;\n+    /// // Clamp value into range [0, 1).\n+    /// let clamped = x.clamp(0.0, 1.0f32.next_down());\n+    /// assert!(clamped < 1.0);\n+    /// assert_eq!(clamped.next_up(), 1.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"none\")]\n+    pub const fn next_down(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const NEG_TINY_BITS: u32 = 0x8000_0001; // Smallest (in magnitude) negative f32.\n+        const CLEAR_SIGN_MASK: u32 = 0x7fff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::NEG_INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            NEG_TINY_BITS\n+        } else if bits == abs {\n+            bits - 1\n+        } else {\n+            bits + 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}, {"sha": "8146f0075316f8650cd72b56f8bab33acbefd9f8", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=04681898f09dad23b2d282a541e1a3b181bed33e", "patch": "@@ -688,6 +688,104 @@ impl f64 {\n         self.is_sign_negative()\n     }\n \n+    /// Returns the least number greater than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f64`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`NEG_INFINITY`], this returns [`MIN`];\n+    ///  - if `self` is `-TINY`, this returns -0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `TINY`;\n+    ///  - if `self` is [`MAX`] or [`INFINITY`], this returns [`INFINITY`];\n+    ///  - otherwise the unique least value greater than `self` is returned.\n+    ///\n+    /// The identity `x.next_up() == -(-x).next_down()` holds for all `x`. When `x`\n+    /// is finite `x == x.next_up().next_down()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// // f64::EPSILON is the difference between 1.0 and the next number up.\n+    /// assert_eq!(1.0f64.next_up(), 1.0 + f64::EPSILON);\n+    /// // But not for most numbers.\n+    /// assert!(0.1f64.next_up() < 0.1 + f64::EPSILON);\n+    /// assert_eq!(9007199254740992f64.next_up(), 9007199254740994.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"none\")]\n+    pub const fn next_up(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const TINY_BITS: u64 = 0x1; // Smallest positive f64.\n+        const CLEAR_SIGN_MASK: u64 = 0x7fff_ffff_ffff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            TINY_BITS\n+        } else if bits == abs {\n+            bits + 1\n+        } else {\n+            bits - 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n+    /// Returns the greatest number less than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f64`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`INFINITY`], this returns [`MAX`];\n+    ///  - if `self` is `TINY`, this returns 0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `-TINY`;\n+    ///  - if `self` is [`MIN`] or [`NEG_INFINITY`], this returns [`NEG_INFINITY`];\n+    ///  - otherwise the unique greatest value less than `self` is returned.\n+    ///\n+    /// The identity `x.next_down() == -(-x).next_up()` holds for all `x`. When `x`\n+    /// is finite `x == x.next_down().next_up()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// let x = 1.0f64;\n+    /// // Clamp value into range [0, 1).\n+    /// let clamped = x.clamp(0.0, 1.0f64.next_down());\n+    /// assert!(clamped < 1.0);\n+    /// assert_eq!(clamped.next_up(), 1.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"none\")]\n+    pub const fn next_down(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const NEG_TINY_BITS: u64 = 0x8000_0000_0000_0001; // Smallest (in magnitude) negative f64.\n+        const CLEAR_SIGN_MASK: u64 = 0x7fff_ffff_ffff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::NEG_INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            NEG_TINY_BITS\n+        } else if bits == abs {\n+            bits - 1\n+        } else {\n+            bits + 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}, {"sha": "19de0cf6c751ba9b454f197173a8609aeaaebe57", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=04681898f09dad23b2d282a541e1a3b181bed33e", "patch": "@@ -299,6 +299,69 @@ fn test_is_sign_negative() {\n     assert!((-f32::NAN).is_sign_negative());\n }\n \n+#[test]\n+fn test_next_up() {\n+    let tiny = f32::from_bits(1);\n+    let tiny_up = f32::from_bits(2);\n+    let max_down = f32::from_bits(0x7f7f_fffe);\n+    let largest_subnormal = f32::from_bits(0x007f_ffff);\n+    let smallest_normal = f32::from_bits(0x0080_0000);\n+\n+    // Check that NaNs roundtrip.\n+    let nan0 = f32::NAN.to_bits();\n+    let nan1 = f32::NAN.to_bits() ^ 0x002a_aaaa;\n+    let nan2 = f32::NAN.to_bits() ^ 0x0055_5555;\n+    assert_eq!(f32::from_bits(nan0).next_up().to_bits(), nan0);\n+    assert_eq!(f32::from_bits(nan1).next_up().to_bits(), nan1);\n+    assert_eq!(f32::from_bits(nan2).next_up().to_bits(), nan2);\n+\n+    assert_eq!(f32::NEG_INFINITY.next_up(), f32::MIN);\n+    assert_eq!(f32::MIN.next_up(), -max_down);\n+    assert_eq!((-1.0 - f32::EPSILON).next_up(), -1.0);\n+    assert_eq!((-smallest_normal).next_up(), -largest_subnormal);\n+    assert_eq!((-tiny_up).next_up(), -tiny);\n+    assert_eq!((-tiny).next_up().to_bits(), (-0.0f32).to_bits());\n+    assert_eq!((-0.0f32).next_up(), tiny);\n+    assert_eq!(0.0f32.next_up(), tiny);\n+    assert_eq!(tiny.next_up(), tiny_up);\n+    assert_eq!(largest_subnormal.next_up(), smallest_normal);\n+    assert_eq!(1.0f32.next_up(), 1.0 + f32::EPSILON);\n+    assert_eq!(f32::MAX.next_up(), f32::INFINITY);\n+    assert_eq!(f32::INFINITY.next_up(), f32::INFINITY);\n+}\n+\n+#[test]\n+fn test_next_down() {\n+    let tiny = f32::from_bits(1);\n+    let tiny_up = f32::from_bits(2);\n+    let max_down = f32::from_bits(0x7f7f_fffe);\n+    let largest_subnormal = f32::from_bits(0x007f_ffff);\n+    let smallest_normal = f32::from_bits(0x0080_0000);\n+\n+    // Check that NaNs roundtrip.\n+    let nan0 = f32::NAN.to_bits();\n+    let nan1 = f32::NAN.to_bits() ^ 0x002a_aaaa;\n+    let nan2 = f32::NAN.to_bits() ^ 0x0055_5555;\n+    assert_eq!(f32::from_bits(nan0).next_down().to_bits(), nan0);\n+    assert_eq!(f32::from_bits(nan1).next_down().to_bits(), nan1);\n+    assert_eq!(f32::from_bits(nan2).next_down().to_bits(), nan2);\n+\n+    assert_eq!(f32::NEG_INFINITY.next_down(), f32::NEG_INFINITY);\n+    assert_eq!(f32::MIN.next_down(), f32::NEG_INFINITY);\n+    assert_eq!((-max_down).next_down(), f32::MIN);\n+    assert_eq!((-1.0f32).next_down(), -1.0 - f32::EPSILON);\n+    assert_eq!((-largest_subnormal).next_down(), -smallest_normal);\n+    assert_eq!((-tiny).next_down(), -tiny_up);\n+    assert_eq!((-0.0f32).next_down(), -tiny);\n+    assert_eq!((0.0f32).next_down(), -tiny);\n+    assert_eq!(tiny.next_down().to_bits(), 0.0f32.to_bits());\n+    assert_eq!(tiny_up.next_down(), tiny);\n+    assert_eq!(smallest_normal.next_down(), largest_subnormal);\n+    assert_eq!((1.0 + f32::EPSILON).next_down(), 1.0f32);\n+    assert_eq!(f32::MAX.next_down(), max_down);\n+    assert_eq!(f32::INFINITY.next_down(), f32::MAX);\n+}\n+\n #[test]\n fn test_mul_add() {\n     let nan: f32 = f32::NAN;"}, {"sha": "8e172cf4963d2db52741b77e4cf36366a70d2adb", "filename": "library/std/src/f64/tests.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=04681898f09dad23b2d282a541e1a3b181bed33e", "patch": "@@ -289,6 +289,69 @@ fn test_is_sign_negative() {\n     assert!((-f64::NAN).is_sign_negative());\n }\n \n+#[test]\n+fn test_next_up() {\n+    let tiny = f64::from_bits(1);\n+    let tiny_up = f64::from_bits(2);\n+    let max_down = f64::from_bits(0x7fef_ffff_ffff_fffe);\n+    let largest_subnormal = f64::from_bits(0x000f_ffff_ffff_ffff);\n+    let smallest_normal = f64::from_bits(0x0010_0000_0000_0000);\n+\n+    // Check that NaNs roundtrip.\n+    let nan0 = f64::NAN.to_bits();\n+    let nan1 = f64::NAN.to_bits() ^ 0x000a_aaaa_aaaa_aaaa;\n+    let nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+    assert_eq!(f64::from_bits(nan0).next_up().to_bits(), nan0);\n+    assert_eq!(f64::from_bits(nan1).next_up().to_bits(), nan1);\n+    assert_eq!(f64::from_bits(nan2).next_up().to_bits(), nan2);\n+\n+    assert_eq!(f64::NEG_INFINITY.next_up(), f64::MIN);\n+    assert_eq!(f64::MIN.next_up(), -max_down);\n+    assert_eq!((-1.0 - f64::EPSILON).next_up(), -1.0);\n+    assert_eq!((-smallest_normal).next_up(), -largest_subnormal);\n+    assert_eq!((-tiny_up).next_up(), -tiny);\n+    assert_eq!((-tiny).next_up().to_bits(), (-0.0f64).to_bits());\n+    assert_eq!((-0.0f64).next_up(), tiny);\n+    assert_eq!(0.0f64.next_up(), tiny);\n+    assert_eq!(tiny.next_up(), tiny_up);\n+    assert_eq!(largest_subnormal.next_up(), smallest_normal);\n+    assert_eq!(1.0f64.next_up(), 1.0 + f64::EPSILON);\n+    assert_eq!(f64::MAX.next_up(), f64::INFINITY);\n+    assert_eq!(f64::INFINITY.next_up(), f64::INFINITY);\n+}\n+\n+#[test]\n+fn test_next_down() {\n+    let tiny = f64::from_bits(1);\n+    let tiny_up = f64::from_bits(2);\n+    let max_down = f64::from_bits(0x7fef_ffff_ffff_fffe);\n+    let largest_subnormal = f64::from_bits(0x000f_ffff_ffff_ffff);\n+    let smallest_normal = f64::from_bits(0x0010_0000_0000_0000);\n+\n+    // Check that NaNs roundtrip.\n+    let nan0 = f64::NAN.to_bits();\n+    let nan1 = f64::NAN.to_bits() ^ 0x000a_aaaa_aaaa_aaaa;\n+    let nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+    assert_eq!(f64::from_bits(nan0).next_down().to_bits(), nan0);\n+    assert_eq!(f64::from_bits(nan1).next_down().to_bits(), nan1);\n+    assert_eq!(f64::from_bits(nan2).next_down().to_bits(), nan2);\n+\n+    assert_eq!(f64::NEG_INFINITY.next_down(), f64::NEG_INFINITY);\n+    assert_eq!(f64::MIN.next_down(), f64::NEG_INFINITY);\n+    assert_eq!((-max_down).next_down(), f64::MIN);\n+    assert_eq!((-1.0f64).next_down(), -1.0 - f64::EPSILON);\n+    assert_eq!((-largest_subnormal).next_down(), -smallest_normal);\n+    assert_eq!((-tiny).next_down(), -tiny_up);\n+    assert_eq!((-0.0f64).next_down(), -tiny);\n+    assert_eq!((0.0f64).next_down(), -tiny);\n+    assert_eq!(tiny.next_down().to_bits(), 0.0f64.to_bits());\n+    assert_eq!(tiny_up.next_down(), tiny);\n+    assert_eq!(smallest_normal.next_down(), largest_subnormal);\n+    assert_eq!((1.0 + f64::EPSILON).next_down(), 1.0f64);\n+    assert_eq!(f64::MAX.next_down(), max_down);\n+    assert_eq!(f64::INFINITY.next_down(), f64::MAX);\n+}\n+\n #[test]\n fn test_mul_add() {\n     let nan: f64 = f64::NAN;"}, {"sha": "e0473f746e54d5086179b376700da7eea097afa1", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04681898f09dad23b2d282a541e1a3b181bed33e/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=04681898f09dad23b2d282a541e1a3b181bed33e", "patch": "@@ -273,6 +273,7 @@\n #![feature(exclusive_wrapper)]\n #![feature(extend_one)]\n #![feature(float_minimum_maximum)]\n+#![feature(float_next_up_down)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]"}]}