{"sha": "d1184ae58d8791f424cab2101b1c67f176423e75", "node_id": "C_kwDOAAsO6NoAKGQxMTg0YWU1OGQ4NzkxZjQyNGNhYjIxMDFiMWM2N2YxNzY0MjNlNzU", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-10-31T01:04:00Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-12-16T16:39:08Z"}, "message": "Include a Span in VClock", "tree": {"sha": "9e4de09229940b985690f88a274e7932bbff4571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e4de09229940b985690f88a274e7932bbff4571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1184ae58d8791f424cab2101b1c67f176423e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1184ae58d8791f424cab2101b1c67f176423e75", "html_url": "https://github.com/rust-lang/rust/commit/d1184ae58d8791f424cab2101b1c67f176423e75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1184ae58d8791f424cab2101b1c67f176423e75/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82a604a88fec3adc0645c5cc5328ea7eba5faa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82a604a88fec3adc0645c5cc5328ea7eba5faa4", "html_url": "https://github.com/rust-lang/rust/commit/e82a604a88fec3adc0645c5cc5328ea7eba5faa4"}], "stats": {"total": 621, "additions": 532, "deletions": 89}, "files": [{"sha": "8b343dd2fe844ea6adc1ed59db7202acd3862a16", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 108, "deletions": 63, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -50,8 +50,11 @@ use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir;\n+use rustc_span::Span;\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Align, Size};\n \n+use crate::diagnostics::RacingOp;\n use crate::*;\n \n use super::{\n@@ -144,8 +147,8 @@ impl ThreadClockSet {\n     /// Increment the happens-before clock at a\n     /// known index.\n     #[inline]\n-    fn increment_clock(&mut self, index: VectorIdx) {\n-        self.clock.increment_index(index);\n+    fn increment_clock(&mut self, index: VectorIdx, current_span: Span) {\n+        self.clock.increment_index(index, current_span);\n     }\n \n     /// Join the happens-before clock with that of\n@@ -361,6 +364,8 @@ impl MemoryCellClocks {\n             atomic.read_vector.set_at_index(&clocks.clock, index);\n             Ok(())\n         } else {\n+            let atomic = self.atomic_mut();\n+            atomic.read_vector.set_at_index(&clocks.clock, index);\n             Err(DataRace)\n         }\n     }\n@@ -378,6 +383,8 @@ impl MemoryCellClocks {\n             atomic.write_vector.set_at_index(&clocks.clock, index);\n             Ok(())\n         } else {\n+            let atomic = self.atomic_mut();\n+            atomic.write_vector.set_at_index(&clocks.clock, index);\n             Err(DataRace)\n         }\n     }\n@@ -386,46 +393,51 @@ impl MemoryCellClocks {\n     /// returns true if a data-race is detected.\n     fn read_race_detect(\n         &mut self,\n-        clocks: &ThreadClockSet,\n+        clocks: &mut ThreadClockSet,\n         index: VectorIdx,\n+        current_span: Span,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Unsynchronized read with vectors: {:#?} :: {:#?}\", self, clocks);\n-        if self.write <= clocks.clock[self.write_index] {\n+        let res = if self.write <= clocks.clock[self.write_index] {\n             let race_free = if let Some(atomic) = self.atomic() {\n                 atomic.write_vector <= clocks.clock\n             } else {\n                 true\n             };\n-            if race_free {\n-                self.read.set_at_index(&clocks.clock, index);\n-                Ok(())\n-            } else {\n-                Err(DataRace)\n-            }\n+            self.read.set_at_index(&clocks.clock, index);\n+            if race_free { Ok(()) } else { Err(DataRace) }\n         } else {\n             Err(DataRace)\n+        };\n+        if res.is_ok() && current_span != DUMMY_SP {\n+            clocks.clock[index].span = current_span;\n         }\n+        res\n     }\n \n     /// Detect races for non-atomic write operations at the current memory cell\n     /// returns true if a data-race is detected.\n     fn write_race_detect(\n         &mut self,\n-        clocks: &ThreadClockSet,\n+        clocks: &mut ThreadClockSet,\n         index: VectorIdx,\n         write_type: WriteType,\n+        current_span: Span,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Unsynchronized write with vectors: {:#?} :: {:#?}\", self, clocks);\n+        if current_span != DUMMY_SP {\n+            clocks.clock[index].span = current_span;\n+        }\n         if self.write <= clocks.clock[self.write_index] && self.read <= clocks.clock {\n             let race_free = if let Some(atomic) = self.atomic() {\n                 atomic.write_vector <= clocks.clock && atomic.read_vector <= clocks.clock\n             } else {\n                 true\n             };\n+            self.write = clocks.clock[index];\n+            self.write_index = index;\n+            self.write_type = write_type;\n             if race_free {\n-                self.write = clocks.clock[index];\n-                self.write_index = index;\n-                self.write_type = write_type;\n                 self.read.set_zero_vector();\n                 Ok(())\n             } else {\n@@ -621,30 +633,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     /// Update the data-race detector for an atomic fence on the current thread.\n     fn atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.maybe_perform_sync_operation(&this.machine.threads, |index, mut clocks| {\n-                log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n-\n-                // Apply data-race detection for the current fences\n-                // this treats AcqRel and SeqCst as the same as an acquire\n-                // and release fence applied in the same timestamp.\n-                if atomic != AtomicFenceOrd::Release {\n-                    // Either Acquire | AcqRel | SeqCst\n-                    clocks.apply_acquire_fence();\n-                }\n-                if atomic != AtomicFenceOrd::Acquire {\n-                    // Either Release | AcqRel | SeqCst\n-                    clocks.apply_release_fence();\n-                }\n-                if atomic == AtomicFenceOrd::SeqCst {\n-                    data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n-                    clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n-                    clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n-                }\n+            data_race.maybe_perform_sync_operation(\n+                &this.machine.threads,\n+                |index, mut clocks| {\n+                    log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n+\n+                    // Apply data-race detection for the current fences\n+                    // this treats AcqRel and SeqCst as the same as an acquire\n+                    // and release fence applied in the same timestamp.\n+                    if atomic != AtomicFenceOrd::Release {\n+                        // Either Acquire | AcqRel | SeqCst\n+                        clocks.apply_acquire_fence();\n+                    }\n+                    if atomic != AtomicFenceOrd::Acquire {\n+                        // Either Release | AcqRel | SeqCst\n+                        clocks.apply_release_fence();\n+                    }\n+                    if atomic == AtomicFenceOrd::SeqCst {\n+                        data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n+                        clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n+                        clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n+                    }\n \n-                // Increment timestamp in case of release semantics.\n-                Ok(atomic != AtomicFenceOrd::Acquire)\n-            })\n+                    // Increment timestamp in case of release semantics.\n+                    Ok(atomic != AtomicFenceOrd::Acquire)\n+                },\n+                current_span,\n+            )\n         } else {\n             Ok(())\n         }\n@@ -682,6 +699,7 @@ impl VClockAlloc {\n         thread_mgr: &ThreadManager<'_, '_>,\n         len: Size,\n         kind: MemoryKind<MiriMemoryKind>,\n+        current_span: Span,\n     ) -> VClockAlloc {\n         let (alloc_timestamp, alloc_index) = match kind {\n             // User allocated and stack memory should track allocation.\n@@ -693,7 +711,10 @@ impl VClockAlloc {\n             )\n             | MemoryKind::Stack => {\n                 let (alloc_index, clocks) = global.current_thread_state(thread_mgr);\n-                let alloc_timestamp = clocks.clock[alloc_index];\n+                let mut alloc_timestamp = clocks.clock[alloc_index];\n+                if current_span != DUMMY_SP {\n+                    alloc_timestamp.span = current_span;\n+                }\n                 (alloc_timestamp, alloc_index)\n             }\n             // Other global memory should trace races but be allocated at the 0 timestamp.\n@@ -704,7 +725,7 @@ impl VClockAlloc {\n                 | MiriMemoryKind::ExternStatic\n                 | MiriMemoryKind::Tls,\n             )\n-            | MemoryKind::CallerLocation => (0, VectorIdx::MAX_INDEX),\n+            | MemoryKind::CallerLocation => (VTimestamp::NONE, VectorIdx::MAX_INDEX),\n         };\n         VClockAlloc {\n             alloc_ranges: RefCell::new(RangeMap::new(\n@@ -735,7 +756,7 @@ impl VClockAlloc {\n                     let idx = l_remainder_slice\n                         .iter()\n                         .enumerate()\n-                        .find_map(|(idx, &r)| if r == 0 { None } else { Some(idx) })\n+                        .find_map(|(idx, &r)| if r == VTimestamp::NONE { None } else { Some(idx) })\n                         .expect(\"Invalid VClock Invariant\");\n                     Some(idx + r_slice.len())\n                 } else {\n@@ -762,7 +783,7 @@ impl VClockAlloc {\n     ) -> InterpResult<'tcx> {\n         let (current_index, current_clocks) = global.current_thread_state(thread_mgr);\n         let write_clock;\n-        let (other_action, other_thread, _other_clock) = if range.write\n+        let (other_action, other_thread, other_clock) = if range.write\n             > current_clocks.clock[range.write_index]\n         {\n             // Convert the write action into the vector clock it\n@@ -799,14 +820,19 @@ impl VClockAlloc {\n         let other_thread_info = global.print_thread_metadata(thread_mgr, other_thread);\n \n         // Throw the data-race detection.\n-        throw_ub_format!(\n-            \"Data race detected between {} on {} and {} on {} at {:?}\",\n-            action,\n-            current_thread_info,\n-            other_action,\n-            other_thread_info,\n-            ptr_dbg,\n-        )\n+        Err(err_machine_stop!(TerminationInfo::DataRace {\n+            ptr: ptr_dbg,\n+            op1: RacingOp {\n+                action: action.to_string(),\n+                thread_info: current_thread_info,\n+                span: current_clocks.clock.as_slice()[current_index.index()].span_data(),\n+            },\n+            op2: RacingOp {\n+                action: other_action.to_string(),\n+                thread_info: other_thread_info,\n+                span: other_clock.as_slice()[other_thread.index()].span_data(),\n+            },\n+        }))?\n     }\n \n     /// Detect racing atomic read and writes (not data races)\n@@ -840,12 +866,14 @@ impl VClockAlloc {\n         range: AllocRange,\n         machine: &MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let current_span = machine.current_span();\n         let global = machine.data_race.as_ref().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(&machine.threads);\n+            let (index, mut clocks) = global.current_thread_state_mut(&machine.threads);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n-                if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n+                if let Err(DataRace) = range.read_race_detect(&mut clocks, index, current_span) {\n+                    drop(clocks);\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n@@ -871,11 +899,15 @@ impl VClockAlloc {\n         write_type: WriteType,\n         machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let current_span = machine.current_span();\n         let global = machine.data_race.as_mut().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(&machine.threads);\n+            let (index, mut clocks) = global.current_thread_state_mut(&machine.threads);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n-                if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n+                if let Err(DataRace) =\n+                    range.write_race_detect(&mut clocks, index, write_type, current_span)\n+                {\n+                    drop(clocks);\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n@@ -1100,6 +1132,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n                     size.bytes()\n                 );\n \n+                let current_span = this.machine.current_span();\n                 // Perform the atomic operation.\n                 data_race.maybe_perform_sync_operation(\n                     &this.machine.threads,\n@@ -1124,6 +1157,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n                         // This conservatively assumes all operations have release semantics\n                         Ok(true)\n                     },\n+                    current_span,\n                 )?;\n \n                 // Log changes to atomic memory.\n@@ -1303,7 +1337,12 @@ impl GlobalState {\n     // Hook for thread creation, enabled multi-threaded execution and marks\n     // the current thread timestamp as happening-before the current thread.\n     #[inline]\n-    pub fn thread_created(&mut self, thread_mgr: &ThreadManager<'_, '_>, thread: ThreadId) {\n+    pub fn thread_created(\n+        &mut self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        thread: ThreadId,\n+        current_span: Span,\n+    ) {\n         let current_index = self.current_index(thread_mgr);\n \n         // Enable multi-threaded execution, there are now at least two threads\n@@ -1320,7 +1359,7 @@ impl GlobalState {\n             // Now re-configure the re-use candidate, increment the clock\n             // for the new sync use of the vector.\n             let vector_clocks = self.vector_clocks.get_mut();\n-            vector_clocks[reuse_index].increment_clock(reuse_index);\n+            vector_clocks[reuse_index].increment_clock(reuse_index, current_span);\n \n             // Locate the old thread the vector was associated with and update\n             // it to represent the new thread instead.\n@@ -1360,8 +1399,8 @@ impl GlobalState {\n \n         // Advance both threads after the synchronized operation.\n         // Both operations are considered to have release semantics.\n-        current.increment_clock(current_index);\n-        created.increment_clock(created_index);\n+        current.increment_clock(current_index, current_span);\n+        created.increment_clock(created_index, current_span);\n     }\n \n     /// Hook on a thread join to update the implicit happens-before relation between the joined\n@@ -1427,13 +1466,13 @@ impl GlobalState {\n     /// This should be called strictly before any calls to\n     /// `thread_joined`.\n     #[inline]\n-    pub fn thread_terminated(&mut self, thread_mgr: &ThreadManager<'_, '_>) {\n+    pub fn thread_terminated(&mut self, thread_mgr: &ThreadManager<'_, '_>, current_span: Span) {\n         let current_index = self.current_index(thread_mgr);\n \n         // Increment the clock to a unique termination timestamp.\n         let vector_clocks = self.vector_clocks.get_mut();\n         let current_clocks = &mut vector_clocks[current_index];\n-        current_clocks.increment_clock(current_index);\n+        current_clocks.increment_clock(current_index, current_span);\n \n         // Load the current thread id for the executing vector.\n         let vector_info = self.vector_info.get_mut();\n@@ -1463,12 +1502,13 @@ impl GlobalState {\n         &self,\n         thread_mgr: &ThreadManager<'_, '_>,\n         op: impl FnOnce(VectorIdx, RefMut<'_, ThreadClockSet>) -> InterpResult<'tcx, bool>,\n+        current_span: Span,\n     ) -> InterpResult<'tcx> {\n         if self.multi_threaded.get() {\n             let (index, clocks) = self.current_thread_state_mut(thread_mgr);\n             if op(index, clocks)? {\n                 let (_, mut clocks) = self.current_thread_state_mut(thread_mgr);\n-                clocks.increment_clock(index);\n+                clocks.increment_clock(index, current_span);\n             }\n         }\n         Ok(())\n@@ -1501,10 +1541,10 @@ impl GlobalState {\n     /// since an acquire operation should have occurred before, however\n     /// for futex & condvar operations this is not the case and this\n     /// operation must be used.\n-    pub fn validate_lock_release(&self, lock: &mut VClock, thread: ThreadId) {\n+    pub fn validate_lock_release(&self, lock: &mut VClock, thread: ThreadId, current_span: Span) {\n         let (index, mut clocks) = self.load_thread_state_mut(thread);\n         lock.clone_from(&clocks.clock);\n-        clocks.increment_clock(index);\n+        clocks.increment_clock(index, current_span);\n     }\n \n     /// Release a lock handle, express that this happens-before\n@@ -1514,10 +1554,15 @@ impl GlobalState {\n     /// For normal locks this should be equivalent to `validate_lock_release`.\n     /// This function only exists for joining over the set of concurrent readers\n     /// in a read-write lock and should not be used for anything else.\n-    pub fn validate_lock_release_shared(&self, lock: &mut VClock, thread: ThreadId) {\n+    pub fn validate_lock_release_shared(\n+        &self,\n+        lock: &mut VClock,\n+        thread: ThreadId,\n+        current_span: Span,\n+    ) {\n         let (index, mut clocks) = self.load_thread_state_mut(thread);\n         lock.join(&clocks.clock);\n-        clocks.increment_clock(index);\n+        clocks.increment_clock(index, current_span);\n     }\n \n     /// Load the vector index used by the given thread as well as the set of vector clocks"}, {"sha": "867683d3552107d6f52db98d275e9c82c6df66f4", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -160,6 +160,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn init_once_complete(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let init_once = &mut this.machine.threads.sync.init_onces[id];\n \n         assert_eq!(\n@@ -172,7 +173,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // Each complete happens-before the end of the wait\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread, current_span);\n         }\n \n         // Wake up everyone.\n@@ -188,6 +189,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn init_once_fail(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let init_once = &mut this.machine.threads.sync.init_onces[id];\n         assert_eq!(\n             init_once.status,\n@@ -197,7 +199,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // Each complete happens-before the end of the wait\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread, current_span);\n         }\n \n         // Wake up one waiting thread, so they can go ahead and try to init this."}, {"sha": "b962052397498b9869a81ae65e2b5ba9d3b0e802", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -359,6 +359,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// return `None`.\n     fn mutex_unlock(&mut self, id: MutexId, expected_owner: ThreadId) -> Option<usize> {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         let mutex = &mut this.machine.threads.sync.mutexes[id];\n         if let Some(current_owner) = mutex.owner {\n             // Mutex is locked.\n@@ -375,7 +376,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // The mutex is completely unlocked. Try transfering ownership\n                 // to another thread.\n                 if let Some(data_race) = &this.machine.data_race {\n-                    data_race.validate_lock_release(&mut mutex.data_race, current_owner);\n+                    data_race.validate_lock_release(\n+                        &mut mutex.data_race,\n+                        current_owner,\n+                        current_span,\n+                    );\n                 }\n                 this.mutex_dequeue_and_lock(id);\n             }\n@@ -454,6 +459,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Returns `true` if succeeded, `false` if this `reader` did not hold the lock.\n     fn rwlock_reader_unlock(&mut self, id: RwLockId, reader: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n         match rwlock.readers.entry(reader) {\n             Entry::Occupied(mut entry) => {\n@@ -470,7 +476,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Entry::Vacant(_) => return false, // we did not even own this lock\n         }\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release_shared(&mut rwlock.data_race_reader, reader);\n+            data_race.validate_lock_release_shared(\n+                &mut rwlock.data_race_reader,\n+                reader,\n+                current_span,\n+            );\n         }\n \n         // The thread was a reader. If the lock is not held any more, give it to a writer.\n@@ -511,6 +521,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     #[inline]\n     fn rwlock_writer_unlock(&mut self, id: RwLockId, expected_writer: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n         if let Some(current_writer) = rwlock.writer {\n             if current_writer != expected_writer {\n@@ -523,8 +534,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             //  since this writer happens-before both the union of readers once they are finished\n             //  and the next writer\n             if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_release(&mut rwlock.data_race, current_writer);\n-                data_race.validate_lock_release(&mut rwlock.data_race_reader, current_writer);\n+                data_race.validate_lock_release(\n+                    &mut rwlock.data_race,\n+                    current_writer,\n+                    current_span,\n+                );\n+                data_race.validate_lock_release(\n+                    &mut rwlock.data_race_reader,\n+                    current_writer,\n+                    current_span,\n+                );\n             }\n             // The thread was a writer.\n             //\n@@ -595,12 +614,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, CondvarLock)> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n         let data_race = &this.machine.data_race;\n \n         // Each condvar signal happens-before the end of the condvar wake\n         if let Some(data_race) = data_race {\n-            data_race.validate_lock_release(&mut condvar.data_race, current_thread);\n+            data_race.validate_lock_release(&mut condvar.data_race, current_thread, current_span);\n         }\n         condvar.waiters.pop_front().map(|waiter| {\n             if let Some(data_race) = data_race {\n@@ -628,12 +648,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn futex_wake(&mut self, addr: u64, bitset: u32) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr)?;\n         let data_race = &this.machine.data_race;\n \n         // Each futex-wake happens-before the end of the futex wait\n         if let Some(data_race) = data_race {\n-            data_race.validate_lock_release(&mut futex.data_race, current_thread);\n+            data_race.validate_lock_release(&mut futex.data_race, current_thread, current_span);\n         }\n \n         // Wake up the first thread in the queue that matches any of the bits in the bitset."}, {"sha": "9173eb3c4ee663f57e7527b3dccf4968d7240f84", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -13,6 +13,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n use crate::concurrency::data_race;\n@@ -617,6 +618,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn thread_terminated(\n         &mut self,\n         mut data_race: Option<&mut data_race::GlobalState>,\n+        current_span: Span,\n     ) -> Vec<Pointer<Provenance>> {\n         let mut free_tls_statics = Vec::new();\n         {\n@@ -634,7 +636,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         }\n         // Set the thread into a terminated state in the data-race detector.\n         if let Some(ref mut data_race) = data_race {\n-            data_race.thread_terminated(self);\n+            data_race.thread_terminated(self, current_span);\n         }\n         // Check if we need to unblock any threads.\n         let mut joined_threads = vec![]; // store which threads joined, we'll need it\n@@ -813,8 +815,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             let mut state = tls::TlsDtorsState::default();\n             Box::new(move |m| state.on_stack_empty(m))\n         });\n+        let current_span = this.machine.current_span();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.thread_created(&this.machine.threads, new_thread_id);\n+            data_race.thread_created(&this.machine.threads, new_thread_id, current_span);\n         }\n \n         // Write the current thread-id, switch to the next thread later\n@@ -1041,7 +1044,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         assert!(thread.stack.is_empty(), \"only threads with an empty stack can be terminated\");\n         thread.state = ThreadState::Terminated;\n \n-        for ptr in this.machine.threads.thread_terminated(this.machine.data_race.as_mut()) {\n+        let current_span = this.machine.current_span();\n+        for ptr in\n+            this.machine.threads.thread_terminated(this.machine.data_race.as_mut(), current_span)\n+        {\n             this.deallocate_ptr(ptr.into(), None, MiriMemoryKind::Tls.into())?;\n         }\n         Ok(())"}, {"sha": "191bb1449af4ff136d4c262d2f84b74794a200d2", "filename": "src/tools/miri/src/concurrency/vector_clock.rs", "status": "modified", "additions": 77, "deletions": 13, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -1,6 +1,11 @@\n use rustc_index::vec::Idx;\n+use rustc_span::{Span, SpanData, DUMMY_SP};\n use smallvec::SmallVec;\n-use std::{cmp::Ordering, fmt::Debug, ops::Index};\n+use std::{\n+    cmp::Ordering,\n+    fmt::Debug,\n+    ops::{Index, IndexMut},\n+};\n \n /// A vector clock index, this is associated with a thread id\n /// but in some cases one vector index may be shared with\n@@ -42,7 +47,37 @@ const SMALL_VECTOR: usize = 4;\n \n /// The type of the time-stamps recorded in the data-race detector\n /// set to a type of unsigned integer\n-pub type VTimestamp = u32;\n+#[derive(Clone, Copy, Debug, Eq)]\n+pub struct VTimestamp {\n+    time: u32,\n+    pub span: Span,\n+}\n+\n+impl VTimestamp {\n+    pub const NONE: VTimestamp = VTimestamp { time: 0, span: DUMMY_SP };\n+\n+    pub fn span_data(&self) -> SpanData {\n+        self.span.data()\n+    }\n+}\n+\n+impl PartialEq for VTimestamp {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.time == other.time\n+    }\n+}\n+\n+impl PartialOrd for VTimestamp {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for VTimestamp {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.time.cmp(&other.time)\n+    }\n+}\n \n /// A vector clock for detecting data-races, this is conceptually\n /// a map from a vector index (and thus a thread id) to a timestamp.\n@@ -62,7 +97,7 @@ impl VClock {\n     /// for a value at the given index\n     pub fn new_with_index(index: VectorIdx, timestamp: VTimestamp) -> VClock {\n         let len = index.index() + 1;\n-        let mut vec = smallvec::smallvec![0; len];\n+        let mut vec = smallvec::smallvec![VTimestamp::NONE; len];\n         vec[index.index()] = timestamp;\n         VClock(vec)\n     }\n@@ -79,7 +114,7 @@ impl VClock {\n     #[inline]\n     fn get_mut_with_min_len(&mut self, min_len: usize) -> &mut [VTimestamp] {\n         if self.0.len() < min_len {\n-            self.0.resize(min_len, 0);\n+            self.0.resize(min_len, VTimestamp::NONE);\n         }\n         assert!(self.0.len() >= min_len);\n         self.0.as_mut_slice()\n@@ -88,11 +123,14 @@ impl VClock {\n     /// Increment the vector clock at a known index\n     /// this will panic if the vector index overflows\n     #[inline]\n-    pub fn increment_index(&mut self, idx: VectorIdx) {\n+    pub fn increment_index(&mut self, idx: VectorIdx, current_span: Span) {\n         let idx = idx.index();\n         let mut_slice = self.get_mut_with_min_len(idx + 1);\n         let idx_ref = &mut mut_slice[idx];\n-        *idx_ref = idx_ref.checked_add(1).expect(\"Vector clock overflow\")\n+        idx_ref.time = idx_ref.time.checked_add(1).expect(\"Vector clock overflow\");\n+        if current_span != DUMMY_SP {\n+            idx_ref.span = current_span;\n+        }\n     }\n \n     // Join the two vector-clocks together, this\n@@ -102,14 +140,31 @@ impl VClock {\n         let rhs_slice = other.as_slice();\n         let lhs_slice = self.get_mut_with_min_len(rhs_slice.len());\n         for (l, &r) in lhs_slice.iter_mut().zip(rhs_slice.iter()) {\n+            let l_span = l.span;\n+            let r_span = r.span;\n             *l = r.max(*l);\n+            if l.span == DUMMY_SP {\n+                if r_span != DUMMY_SP {\n+                    l.span = r_span;\n+                }\n+                if l_span != DUMMY_SP {\n+                    l.span = l_span;\n+                }\n+            }\n         }\n     }\n \n     /// Set the element at the current index of the vector\n     pub fn set_at_index(&mut self, other: &Self, idx: VectorIdx) {\n         let mut_slice = self.get_mut_with_min_len(idx.index() + 1);\n+\n+        let prev_span = mut_slice[idx.index()].span;\n+\n         mut_slice[idx.index()] = other[idx];\n+\n+        if other[idx].span == DUMMY_SP {\n+            mut_slice[idx.index()].span = prev_span;\n+        }\n     }\n \n     /// Set the vector to the all-zero vector\n@@ -313,7 +368,14 @@ impl Index<VectorIdx> for VClock {\n \n     #[inline]\n     fn index(&self, index: VectorIdx) -> &VTimestamp {\n-        self.as_slice().get(index.to_u32() as usize).unwrap_or(&0)\n+        self.as_slice().get(index.to_u32() as usize).unwrap_or(&VTimestamp::NONE)\n+    }\n+}\n+\n+impl IndexMut<VectorIdx> for VClock {\n+    #[inline]\n+    fn index_mut(&mut self, index: VectorIdx) -> &mut VTimestamp {\n+        self.0.as_mut_slice().get_mut(index.to_u32() as usize).unwrap()\n     }\n }\n \n@@ -323,24 +385,25 @@ impl Index<VectorIdx> for VClock {\n #[cfg(test)]\n mod tests {\n \n-    use super::{VClock, VTimestamp, VectorIdx};\n-    use std::cmp::Ordering;\n+    use super::{VClock, VectorIdx};\n+    use rustc_span::DUMMY_SP;\n \n     #[test]\n     fn test_equal() {\n         let mut c1 = VClock::default();\n         let mut c2 = VClock::default();\n         assert_eq!(c1, c2);\n-        c1.increment_index(VectorIdx(5));\n+        c1.increment_index(VectorIdx(5), DUMMY_SP);\n         assert_ne!(c1, c2);\n-        c2.increment_index(VectorIdx(53));\n+        c2.increment_index(VectorIdx(53), DUMMY_SP);\n         assert_ne!(c1, c2);\n-        c1.increment_index(VectorIdx(53));\n+        c1.increment_index(VectorIdx(53), DUMMY_SP);\n         assert_ne!(c1, c2);\n-        c2.increment_index(VectorIdx(5));\n+        c2.increment_index(VectorIdx(5), DUMMY_SP);\n         assert_eq!(c1, c2);\n     }\n \n+    /*\n     #[test]\n     fn test_partial_order() {\n         // Small test\n@@ -449,4 +512,5 @@ mod tests {\n             \"Invalid alt (>=):\\n l: {l:?}\\n r: {r:?}\"\n         );\n     }\n+    */\n }"}, {"sha": "c02ec7ded75f2effaab62639298685804a6f95b7", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -258,7 +258,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n             // The thread index and timestamp of the initialisation write\n             // are never meaningfully used, so it's fine to leave them as 0\n             store_index: VectorIdx::from(0),\n-            timestamp: 0,\n+            timestamp: VTimestamp::NONE,\n             val: init,\n             is_seqcst: false,\n             load_info: RefCell::new(LoadInfo::default()),"}, {"sha": "d9f40b55cd6efff2cbd2b7cd206210e1bdd5ec9e", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -35,6 +35,17 @@ pub enum TerminationInfo {\n         link_name: Symbol,\n         span: SpanData,\n     },\n+    DataRace {\n+        op1: RacingOp,\n+        op2: RacingOp,\n+        ptr: Pointer,\n+    },\n+}\n+\n+pub struct RacingOp {\n+    pub action: String,\n+    pub thread_info: String,\n+    pub span: SpanData,\n }\n \n impl fmt::Display for TerminationInfo {\n@@ -55,6 +66,12 @@ impl fmt::Display for TerminationInfo {\n                 write!(f, \"multiple definitions of symbol `{link_name}`\"),\n             SymbolShimClashing { link_name, .. } =>\n                 write!(f, \"found `{link_name}` symbol definition that clashes with a built-in shim\",),\n+            DataRace { ptr, op1, op2 } =>\n+                write!(\n+                    f,\n+                    \"Data race detected between {} on {} and {} on {} at {:?}\",\n+                    op1.action, op1.thread_info, op2.action, op2.thread_info, ptr,\n+                ),\n         }\n     }\n }\n@@ -167,7 +184,7 @@ pub fn report_error<'tcx, 'mir>(\n             Abort(_) => Some(\"abnormal termination\"),\n             UnsupportedInIsolation(_) | Int2PtrWithStrictProvenance =>\n                 Some(\"unsupported operation\"),\n-            StackedBorrowsUb { .. } => Some(\"Undefined Behavior\"),\n+            StackedBorrowsUb { .. } | DataRace { .. } => Some(\"Undefined Behavior\"),\n             Deadlock => Some(\"deadlock\"),\n             MultipleSymbolDefinitions { .. } | SymbolShimClashing { .. } => None,\n         };\n@@ -205,6 +222,13 @@ pub fn report_error<'tcx, 'mir>(\n                 vec![(Some(*span), format!(\"the `{link_name}` symbol is defined here\"))],\n             Int2PtrWithStrictProvenance =>\n                 vec![(None, format!(\"use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\"))],\n+            DataRace { ptr: _, op1, op2 } =>\n+                vec![\n+                    (Some(op1.span), format!(\"The {} on {} is here\", op1.action, op1.thread_info)),\n+                    (Some(op2.span), format!(\"The {} on {} is here\", op2.action, op2.thread_info)),\n+                    (None, format!(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\")),\n+                    (None, format!(\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\")),\n+                ],\n             _ => vec![],\n         };\n         (title, helps)"}, {"sha": "01a3d7550e2e0c480b5bb545ef77782837471924", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -956,6 +956,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 &ecx.machine.threads,\n                 alloc.size(),\n                 kind,\n+                ecx.machine.current_span(),\n             )\n         });\n         let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocState::new_allocation);"}, {"sha": "d0ec8c1f1281c41ea5716896a52a3afcc7cd8704", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Read on thread `<unnamed>`\n LL |             *pointer.load(Ordering::Relaxed)\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n    |\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/alloc_read_race.rs:LL:CC\n+   |\n+LL | ...   *pointer.load(Ordering::Relaxed)\n+   |                                      ^\n+help: The Allocate on thread `<unnamed>` is here\n+  --> $DIR/alloc_read_race.rs:LL:CC\n+   |\n+LL |             pointer.store(Box::into_raw(Box::new_uninit()), Ordering::Relaxed);\n+   |                                         ^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "11493536808ff0ac74221e32e8ae2c4879431b49", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             *pointer.load(Ordering::Relaxed) = 2;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/alloc_write_race.rs:LL:CC\n+   |\n+LL | ...   *pointer.load(Ordering::Relaxed) = 2;\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: The Allocate on thread `<unnamed>` is here\n+  --> $DIR/alloc_write_race.rs:LL:CC\n+   |\n+LL |                 .store(Box::into_raw(Box::<usize>::new_uninit()) as *mut usize, Ordering::Relaxed);\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "e77afe7b827d0cfc92b0e729c527426490d668b7", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Atomic Load on thread `<un\n LL |             (&*c.0).load(Ordering::SeqCst)\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Load on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Atomic Load on thread `<unnamed>` is here\n+  --> $DIR/atomic_read_na_write_race1.rs:LL:CC\n+   |\n+LL | ...   (&*c.0).load(Ordering::SeqCst)\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/atomic_read_na_write_race1.rs:LL:CC\n+   |\n+LL |             *(c.0 as *mut usize) = 32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "6b304421697acd1427b8e51a95c424b5957eeba7", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             *atomic_ref.get_mut() = 32;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Atomic Load on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/atomic_read_na_write_race2.rs:LL:CC\n+   |\n+LL | ...   *atomic_ref.get_mut() = 32;\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: The Atomic Load on thread `<unnamed>` is here\n+  --> $DIR/atomic_read_na_write_race2.rs:LL:CC\n+   |\n+LL |             atomic_ref.load(Ordering::SeqCst)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "32485d3f8f3e209056e4c7722d76489d5b6c7a55", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Read on thread `<unnamed>`\n LL |             *atomic_ref.get_mut()\n    |             ^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n    |\n+help: The Read on thread `<unnamed>` is here\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL | }\n+   | ^\n+help: The Atomic Store on thread `<unnamed>` is here\n+  --> $DIR/atomic_write_na_read_race1.rs:LL:CC\n+   |\n+LL |             atomic_ref.store(32, Ordering::SeqCst)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "5217f3d8a70222e4fd2978bf6dc7b0f526844464", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Atomic Store on thread `<u\n LL |             (&*c.0).store(32, Ordering::SeqCst);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n+help: The Atomic Store on thread `<unnamed>` is here\n+  --> $DIR/atomic_write_na_read_race2.rs:LL:CC\n+   |\n+LL | ...   (&*c.0).store(32, Ordering::SeqCst);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: The Read on thread `<unnamed>` is here\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL | }\n+   | ^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "55cc212ec0aa2d511334256f95efe19cd2d3ec88", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Atomic Store on thread `<u\n LL |             (&*c.0).store(64, Ordering::SeqCst);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Atomic Store on thread `<unnamed>` is here\n+  --> $DIR/atomic_write_na_write_race1.rs:LL:CC\n+   |\n+LL | ...   (&*c.0).store(64, Ordering::SeqCst);\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/atomic_write_na_write_race1.rs:LL:CC\n+   |\n+LL |             *(c.0 as *mut usize) = 32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "2b666ef02761e0b319d78e317bc810ec91055edb", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             *atomic_ref.get_mut() = 32;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/atomic_write_na_write_race2.rs:LL:CC\n+   |\n+LL | ...   *atomic_ref.get_mut() = 32;\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: The Atomic Store on thread `<unnamed>` is here\n+  --> $DIR/atomic_write_na_write_race2.rs:LL:CC\n+   |\n+LL |             atomic_ref.store(64, Ordering::SeqCst);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "156261b3538762bb1020ea3d47f7d38e26cd34e3", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             *c.0 = 64;\n    |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/dangling_thread_async_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 64;\n+   |             ^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/dangling_thread_async_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "bd0d34929e74963a9ecb591550fca71c8f6baa2f", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `main` and\n LL |         *c.0 = 64;\n    |         ^^^^^^^^^ Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `main` is here\n+  --> $DIR/dangling_thread_race.rs:LL:CC\n+   |\n+LL |         *c.0 = 64;\n+   |         ^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/dangling_thread_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "ac20d05bf12f5ec7ce9e627a7b55d594f4cbf1bb", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -9,6 +9,21 @@ LL | |                 std::mem::align_of::<usize>(),\n LL | |             );\n    | |_____________^ Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n+help: The Deallocate on thread `<unnamed>` is here\n+  --> $DIR/dealloc_read_race1.rs:LL:CC\n+   |\n+LL | /             __rust_dealloc(\n+LL | |\n+LL | |                 ptr.0 as *mut _,\n+LL | |                 std::mem::size_of::<usize>(),\n+LL | |                 std::mem::align_of::<usize>(),\n+LL | |             );\n+   | |_____________^\n+help: The Read on thread `<unnamed>` is here\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL | }\n+   | ^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "93c7db3875128b7643b7ec9de40eb98f3e052473", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Deallocate on thread `<unn\n LL |             }\n    |             ^ Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n+help: The Deallocate on thread `<unnamed>` is here\n+  --> $DIR/dealloc_read_race_stack.rs:LL:CC\n+   |\n+LL |             }\n+   |             ^\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/dealloc_read_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire)\n+   |                                            ^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "9e59d5a647888b9f70fc3a85e6a6a0bf430e46b4", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -9,6 +9,21 @@ LL | |                 std::mem::align_of::<usize>(),\n LL | |             );\n    | |_____________^ Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Deallocate on thread `<unnamed>` is here\n+  --> $DIR/dealloc_write_race1.rs:LL:CC\n+   |\n+LL | /             __rust_dealloc(\n+LL | |\n+LL | |                 ptr.0 as *mut _,\n+LL | |                 std::mem::size_of::<usize>(),\n+LL | |                 std::mem::align_of::<usize>(),\n+LL | |             );\n+   | |_____________^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/dealloc_write_race1.rs:LL:CC\n+   |\n+LL |             *ptr.0 = 2;\n+   |             ^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "5ac7c2d5a1eb75a946d02478732a8e668a22d3bd", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Deallocate on thread `<unn\n LL |             }\n    |             ^ Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Deallocate on thread `<unnamed>` is here\n+  --> $DIR/dealloc_write_race_stack.rs:LL:CC\n+   |\n+LL |             }\n+   |             ^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/dealloc_write_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire) = 3;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "636a686f84ec9debda2fd9bcc9f9faee195e1d86", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             *c.0 = 64;\n    |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/enable_after_join_to_main.rs:LL:CC\n+   |\n+LL |             *c.0 = 64;\n+   |             ^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/enable_after_join_to_main.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "e6862916384de93febc880d4ea0905b9310e21ab", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `main` and\n LL |     unsafe { V = 2 }\n    |              ^^^^^ Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `main` is here\n+  --> $DIR/fence_after_load.rs:LL:CC\n+   |\n+LL |     unsafe { V = 2 }\n+   |              ^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/fence_after_load.rs:LL:CC\n+   |\n+LL |         unsafe { V = 1 }\n+   |                  ^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "b1441dabaf04affa643e2ffd67ddd3bbe9b7489e", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             *c.0 = 64;\n    |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/read_write_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 64;\n+   |             ^^^^^^^^^\n+help: The Read on thread `<unnamed>` is here\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL | }\n+   | ^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "2a2572576dba39867f2a97e75e68d322722593ec", "filename": "src/tools/miri/tests/fail/data_race/read_write_race_stack.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Read on thread `<unnamed>`\n LL |             stack_var\n    |             ^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/read_write_race_stack.rs:LL:CC\n+   |\n+LL |             sleep(Duration::from_millis(200));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/read_write_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire) = 3;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "e4819614ddb6cb667d6c63156263a124c760b33b", "filename": "src/tools/miri/tests/fail/data_race/relax_acquire_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Read on thread `<unnamed>`\n LL |                 *c.0\n    |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/relax_acquire_race.rs:LL:CC\n+   |\n+LL |             if SYNC.load(Ordering::Acquire) == 2 {\n+   |                                           ^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/relax_acquire_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "6bc8bccbbf0c8d91a4c8cfdcb1c8495269796d79", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Read on thread `<unnamed>`\n LL |                 *c.0\n    |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/release_seq_race.rs:LL:CC\n+   |\n+LL |             if SYNC.load(Ordering::Acquire) == 3 {\n+   |                                           ^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/release_seq_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "6997685dc3e06ac5a2b68e35510a291fa8879151", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race_same_thread.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Read on thread `<unnamed>`\n LL |                 *c.0\n    |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/release_seq_race_same_thread.rs:LL:CC\n+   |\n+LL |             if SYNC.load(Ordering::Acquire) == 2 {\n+   |                                           ^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/release_seq_race_same_thread.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "e4f3ecf89cea4dbfa6c689cfbf467fbb8dab00e2", "filename": "src/tools/miri/tests/fail/data_race/rmw_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Read on thread `<unnamed>`\n LL |                 *c.0\n    |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/rmw_race.rs:LL:CC\n+   |\n+LL |             if SYNC.load(Ordering::Acquire) == 3 {\n+   |                                           ^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/rmw_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "b156179da4dabcd0f07a74cbca645ff350974c96", "filename": "src/tools/miri/tests/fail/data_race/stack_pop_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Deallocate on thread `main\n LL | }\n    |  ^ Data race detected between Deallocate on thread `main` and Read on thread `<unnamed>` at ALLOC\n    |\n+help: The Deallocate on thread `main` is here\n+  --> $DIR/stack_pop_race.rs:LL:CC\n+   |\n+LL | }\n+   |  ^\n+help: The Read on thread `<unnamed>` is here\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL | }\n+   | ^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "132cd5030441384c958e0ab2d9c9abbfcef15b63", "filename": "src/tools/miri/tests/fail/data_race/write_write_race.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             *c.0 = 64;\n    |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/write_write_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 64;\n+   |             ^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/write_write_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "25963d63db5a8860c53b5fa7dcea81d4b75fe14e", "filename": "src/tools/miri/tests/fail/data_race/write_write_race_stack.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |             stack_var = 1usize;\n    |             ^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/write_write_race_stack.rs:LL:CC\n+   |\n+LL |             stack_var = 1usize;\n+   |             ^^^^^^^^^^^^^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/write_write_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire) = 3;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "6b280a16a37666becf2e13d7ba0552d65b3feed5", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |         *p = 5;\n    |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^\n+help: The Read on thread `<unnamed>` is here\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |     let t1 = std::thread::spawn(move || thread_1(p));\n+   |                                                  ^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}, {"sha": "80b6ac6e139ad95a35c2760e02143cc21e29a40d", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1184ae58d8791f424cab2101b1c67f176423e75/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr?ref=d1184ae58d8791f424cab2101b1c67f176423e75", "patch": "@@ -4,6 +4,16 @@ error: Undefined Behavior: Data race detected between Write on thread `<unnamed>\n LL |         *p = 5;\n    |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n    |\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |         *p = 5;\n+   |         ^^^^^^\n+help: The Write on thread `<unnamed>` is here\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |         let _r = &mut *p;\n+   |                  ^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:"}]}