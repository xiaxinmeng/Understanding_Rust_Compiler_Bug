{"sha": "50e96414d29782e6ae9bad2185d9401ea527af2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZTk2NDE0ZDI5NzgyZTZhZTliYWQyMTg1ZDk0MDFlYTUyN2FmMmU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-26T06:07:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-26T06:07:34Z"}, "message": "Fix register-use bugs in sweep pass, factor sweep pass out and call twice for separate sever/free phases.", "tree": {"sha": "2cdee0e37a1c9ba5010135ba489e32b57ddc10ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cdee0e37a1c9ba5010135ba489e32b57ddc10ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50e96414d29782e6ae9bad2185d9401ea527af2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50e96414d29782e6ae9bad2185d9401ea527af2e", "html_url": "https://github.com/rust-lang/rust/commit/50e96414d29782e6ae9bad2185d9401ea527af2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50e96414d29782e6ae9bad2185d9401ea527af2e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90eaaf666b640433d20d5a1320637e8027924297", "url": "https://api.github.com/repos/rust-lang/rust/commits/90eaaf666b640433d20d5a1320637e8027924297", "html_url": "https://github.com/rust-lang/rust/commit/90eaaf666b640433d20d5a1320637e8027924297"}], "stats": {"total": 130, "additions": 73, "deletions": 57}, "files": [{"sha": "267dc6578a8f1632adde348296b3e9bd98ae99f8", "filename": "src/boot/be/x86.ml", "status": "modified", "additions": 73, "deletions": 57, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/50e96414d29782e6ae9bad2185d9401ea527af2e/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/50e96414d29782e6ae9bad2185d9401ea527af2e/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=50e96414d29782e6ae9bad2185d9401ea527af2e", "patch": "@@ -745,7 +745,7 @@ let crawl_stack_calling_glue\n     : unit =\n \n   let fp_n = word_n (Il.Hreg ebp) in\n-  let edx_n = word_n (Il.Hreg edx) in\n+  let edi_n = word_n (Il.Hreg edi) in\n   let emit = Il.emit e in\n   let mov dst src = emit (Il.umov dst src) in\n   let push x = emit (Il.Push x) in\n@@ -763,16 +763,16 @@ let crawl_stack_calling_glue\n     mark repeat_jmp_fix;\n \n     mov (rc esi) (c (fp_n (-1)));       (* esi <- crate ptr             *)\n-    mov (rc edx) (c (fp_n (-2)));       (* edx <- frame glue functions. *)\n-    emit (Il.cmp (ro edx) (immi 0L));\n+    mov (rc edi) (c (fp_n (-2)));       (* edi <- frame glue functions. *)\n+    emit (Il.cmp (ro edi) (immi 0L));\n \n     emit\n       (Il.jmp Il.JE\n          (codefix skip_jmp_fix));       (* if struct* is nonzero        *)\n-    add edx esi;                        (* add crate ptr to disp.       *)\n+    add edi esi;                        (* add crate ptr to disp.       *)\n     mov\n       (rc ecx)\n-      (c (edx_n glue_field));           (* ecx <-  glue                 *)\n+      (c (edi_n glue_field));           (* ecx <-  glue                 *)\n     emit (Il.cmp (ro ecx) (immi 0L));\n \n     emit\n@@ -789,11 +789,11 @@ let crawl_stack_calling_glue\n     pop (rc eax);\n \n     mark skip_jmp_fix;\n-    mov (rc edx) (c (fp_n 3));          (* load next fp (callee-saves[3]) *)\n-    emit (Il.cmp (ro edx) (immi 0L));\n+    mov (rc edi) (c (fp_n 3));          (* load next fp (callee-saves[3]) *)\n+    emit (Il.cmp (ro edi) (immi 0L));\n     emit (Il.jmp Il.JE\n             (codefix exit_jmp_fix));    (* if nonzero                     *)\n-    mov (rc ebp) (ro edx);              (* move to next frame             *)\n+    mov (rc ebp) (ro edi);              (* move to next frame             *)\n     emit (Il.jmp Il.JMP\n             (codefix repeat_jmp_fix));  (* loop                           *)\n \n@@ -802,8 +802,10 @@ let crawl_stack_calling_glue\n     pop (rc ebp);                       (* restore ebp                    *)\n ;;\n \n-let gc_glue\n+let sweep_gc_chain\n     (e:Il.emitter)\n+    (glue_field:int)\n+    (clear_mark:bool)\n     : unit =\n \n   let emit = Il.emit e in\n@@ -812,68 +814,40 @@ let gc_glue\n   let pop x = emit (Il.Pop x) in\n   let band x y = emit (Il.binary Il.AND x (c x) y) in\n   let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n-  let edx_n = word_n (Il.Hreg edx) in\n+  let edi_n = word_n (Il.Hreg edi) in\n   let ecx_n = word_n (Il.Hreg ecx) in\n   let codefix fix = Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy)) in\n   let mark fix = Il.emit_full e (Some fix) [] Il.Dead in\n   let repeat_jmp_fix = new_fixup \"repeat jump\" in\n   let skip_jmp_fix = new_fixup \"skip jump\" in\n   let exit_jmp_fix = new_fixup \"exit jump\" in\n \n-    mov (rc edx) (c task_ptr);            (* switch back to rust stack    *)\n-    mov\n-      (rc esp)\n-      (c (edx_n Abi.task_field_rust_sp));\n-\n-    (* Mark pass. *)\n-    save_callee_saves e;\n-    push (ro eax);\n-    crawl_stack_calling_glue e Abi.frame_glue_fns_field_mark;\n-\n-    (* Sweep pass. *)\n-    mov (rc edx) (c task_ptr);\n-    mov (rc edx) (c (edx_n Abi.task_field_gc_alloc_chain));\n+    mov (rc edi) (c task_ptr);\n+    mov (rc edi) (c (edi_n Abi.task_field_gc_alloc_chain));\n     mark repeat_jmp_fix;\n-    emit (Il.cmp (ro edx) (immi 0L));\n+    emit (Il.cmp (ro edi) (immi 0L));\n     emit (Il.jmp Il.JE\n             (codefix exit_jmp_fix));            (* if nonzero             *)\n     mov (rc ecx)                                (* Load GC ctrl word      *)\n-      (c (edx_n Abi.exterior_gc_slot_field_ctrl));\n+      (c (edi_n Abi.exterior_gc_slot_field_ctrl));\n     mov (rc eax) (ro ecx);\n     band (rc eax) (immi 1L);                    (* Extract mark to eax.   *)\n     band                                        (* Clear mark in ecx.     *)\n       (rc ecx)\n       (immi 0xfffffffffffffffeL);\n-    mov\n-      ((edx_n Abi.exterior_gc_slot_field_ctrl)) (* Write-back cleared.    *)\n-      (ro ecx);\n+\n+    if clear_mark\n+    then\n+      mov                                       (* Write-back cleared.    *)\n+        ((edi_n Abi.exterior_gc_slot_field_ctrl))\n+        (ro ecx);\n \n     emit (Il.cmp (ro eax) (immi 0L));\n     emit\n       (Il.jmp Il.JNE\n          (codefix skip_jmp_fix));               (* if unmarked (garbage)  *)\n \n-    (* FIXME: this path is all wrong\n-     *\n-     * It actually needs to walk in two full passes over the chain:\n-     *\n-     *    - In pass #1, it goes through and disposes of all mutable exterior\n-     *      slots in each record. That is, rc-- the referent, and then\n-     *      null-out.  If the rc-- gets to zero, that just means the mutable\n-     *      is part of the garbage set currently being collected. But a\n-     *      mutable may be live-and-outside; this detaches the garbage set\n-     *      from the non-garbage set within the mutable heap.\n-     *\n-     *    - In pass #2, run the normal free-glue. This winds up doing the\n-     *      immutables only, since all the mutables were nulled out in pass\n-     *      #1. This is where you do the unlinking from the double-linked\n-     *      chain mentioned above.\n-     *\n-     * So .. this will still take a little more doing.\n-     *\n-     *)\n-\n-    push (ro edx);                              (* Push gc_val to drop.   *)\n+    push (ro edi);                              (* Push gc_val.           *)\n \n     (* NB: ecx is a type descriptor now. *)\n \n@@ -885,21 +859,63 @@ let gc_glue\n     push (immi 0L);                             (* Push null outptr.      *)\n \n     mov (rc eax)                                (* Load glue tydesc-off.  *)\n-      (c (ecx_n Abi.tydesc_field_free_glue));\n+      (c (ecx_n glue_field));\n     add eax ecx;                                (* Add to tydesc*         *)\n     emit (Il.call (rc eax)\n-            (reg_codeptr (h eax)));             (* Call free glue.        *)\n+            (reg_codeptr (h eax)));             (* Call glue.             *)\n     pop (rc eax);\n     pop (rc eax);\n     pop (rc eax);\n     pop (rc eax);\n \n     mark skip_jmp_fix;\n-    mov (rc edx)                                (* Advance down chain     *)\n-      (c (edx_n Abi.exterior_gc_slot_field_next));\n+    mov (rc edi)                                (* Advance down chain     *)\n+      (c (edi_n Abi.exterior_gc_slot_field_next));\n     emit (Il.jmp Il.JMP\n             (codefix repeat_jmp_fix));          (* loop                   *)\n     mark exit_jmp_fix;\n+;;\n+\n+\n+\n+let gc_glue\n+    (e:Il.emitter)\n+    : unit =\n+\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let push x = emit (Il.Push x) in\n+  let pop x = emit (Il.Pop x) in\n+  let edi_n = word_n (Il.Hreg edi) in\n+\n+    mov (rc edi) (c task_ptr);            (* switch back to rust stack    *)\n+    mov\n+      (rc esp)\n+      (c (edi_n Abi.task_field_rust_sp));\n+\n+    (* Mark pass. *)\n+    save_callee_saves e;\n+    push (ro eax);\n+    crawl_stack_calling_glue e Abi.frame_glue_fns_field_mark;\n+\n+    (* The sweep pass has two sub-passes over the GC chain:\n+     *\n+     *    - In pass #1, 'severing', we goes through and disposes of all\n+     *      mutable exterior slots in each record. That is, rc-- the referent,\n+     *      and then null-out.  If the rc-- gets to zero, that just means the\n+     *      mutable is part of the garbage set currently being collected. But\n+     *      a mutable may be live-and-outside; this detaches the garbage set\n+     *      from the non-garbage set within the mutable heap.\n+     *\n+     *    - In pass #2, 'freeing', we run the normal free-glue. This winds up\n+     *      running drop-glue on the zero-reference-reaching immutables only,\n+     *      since all the mutables were nulled out in pass #1. This is where\n+     *      you do the unlinking from the double-linked chain and call free(),\n+     *      also.\n+     *\n+     *)\n+    sweep_gc_chain e Abi.tydesc_field_sever_glue false;\n+    sweep_gc_chain e Abi.tydesc_field_free_glue true;\n \n     pop (rc eax);\n     restore_callee_saves e;\n@@ -915,20 +931,20 @@ let unwind_glue\n \n   let emit = Il.emit e in\n   let mov dst src = emit (Il.umov dst src) in\n-  let edx_n = word_n (Il.Hreg edx) in\n+  let edi_n = word_n (Il.Hreg edi) in\n \n-    mov (rc edx) (c task_ptr);          (* switch back to rust stack    *)\n+    mov (rc edi) (c task_ptr);          (* switch back to rust stack    *)\n     mov\n       (rc esp)\n-      (c (edx_n Abi.task_field_rust_sp));\n+      (c (edi_n Abi.task_field_rust_sp));\n \n     crawl_stack_calling_glue e Abi.frame_glue_fns_field_drop;\n     let callee =\n       Abi.load_fixup_codeptr\n         e (h eax) exit_task_fixup false nabi.nabi_indirect\n     in\n       emit_c_call\n-        e (rc eax) (h edx) (h ecx) nabi false callee [| (c task_ptr) |];\n+        e (rc eax) (h edi) (h ecx) nabi false callee [| (c task_ptr) |];\n ;;\n \n "}]}