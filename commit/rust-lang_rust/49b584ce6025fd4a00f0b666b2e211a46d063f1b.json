{"sha": "49b584ce6025fd4a00f0b666b2e211a46d063f1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YjU4NGNlNjAyNWZkNGEwMGYwYjY2NmIyZTIxMWE0NmQwNjNmMWI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-19T23:15:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-19T23:15:15Z"}, "message": "Rollup merge of #48834 - ysiraichi:suggest-remove-ref, r=estebank\n\nSuggest removing `&`s\n\nThis implements the error message discussed in #47744.\nWe check whether removing each `&` yields a type that satisfies the requested obligation.\nAlso, it was created a new `NodeId` field in `ObligationCause` in order to iterate through the `&`s. The way it's implemented now, it iterates through the obligation snippet and counts the number of `&`.\n\nr? @estebank", "tree": {"sha": "4ec94794bd2d0afed8586fded5955167f840fc0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ec94794bd2d0afed8586fded5955167f840fc0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49b584ce6025fd4a00f0b666b2e211a46d063f1b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJasESDCRBK7hj4Ov3rIwAAdHIIAEp0ssOr0nta8OwbqNVgYDvb\nxEtsJ0bVqA+WWTuIxUF4AqSgcT3uhrCzB3eGAgMztJYNQs6t5zEySa+PKpwnRfSZ\nbcs83uF99B9qo3FR0Le2mZ2pzWOxRZq+lAqUIWlbQAlGk9dCkFfqKaxSySMQMqku\nkvDtZ2zohoyKIxqGs04m4Qnbf53cXUjFuy8y8C9jodRY22m9bSk/oypdD/IYtuSJ\nzLxQE9ufVAdF8Bcx2ZwtQ7MVuak7LXq3BunMcuEIGbwEpZr5wwiW6vzqG74raOtu\nLQjfp1Vp/HlI//O5Q8GkXwNf82DmoXdNZVxlR1AEQ//FQPa1JFNdWezCX/NeGpI=\n=AIRP\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ec94794bd2d0afed8586fded5955167f840fc0e\nparent 5d5f5a08b8d93d63e360bf409c9463e6282a38c6\nparent 736ba433ac2f0d2f6604a64f744f86a311a56be4\nauthor kennytm <kennytm@gmail.com> 1521501315 +0800\ncommitter GitHub <noreply@github.com> 1521501315 +0800\n\nRollup merge of #48834 - ysiraichi:suggest-remove-ref, r=estebank\n\nSuggest removing `&`s\n\nThis implements the error message discussed in #47744.\nWe check whether removing each `&` yields a type that satisfies the requested obligation.\nAlso, it was created a new `NodeId` field in `ObligationCause` in order to iterate through the `&`s. The way it's implemented now, it iterates through the obligation snippet and counts the number of `&`.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49b584ce6025fd4a00f0b666b2e211a46d063f1b", "html_url": "https://github.com/rust-lang/rust/commit/49b584ce6025fd4a00f0b666b2e211a46d063f1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49b584ce6025fd4a00f0b666b2e211a46d063f1b/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d5f5a08b8d93d63e360bf409c9463e6282a38c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d5f5a08b8d93d63e360bf409c9463e6282a38c6", "html_url": "https://github.com/rust-lang/rust/commit/5d5f5a08b8d93d63e360bf409c9463e6282a38c6"}, {"sha": "736ba433ac2f0d2f6604a64f744f86a311a56be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/736ba433ac2f0d2f6604a64f744f86a311a56be4", "html_url": "https://github.com/rust-lang/rust/commit/736ba433ac2f0d2f6604a64f744f86a311a56be4"}], "stats": {"total": 251, "additions": 205, "deletions": 46}, "files": [{"sha": "ab3c619dcdcd0a42e209d72d6a8603855c1cc2d7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -606,6 +606,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n \n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n@@ -844,6 +845,54 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n+    /// suggest removing these references until we reach a type that implements the trait.\n+    fn suggest_remove_reference(&self,\n+                                obligation: &PredicateObligation<'tcx>,\n+                                err: &mut DiagnosticBuilder<'tcx>,\n+                                trait_ref: &ty::Binder<ty::TraitRef<'tcx>>) {\n+        let ty::Binder(trait_ref) = trait_ref;\n+        let span = obligation.cause.span;\n+\n+        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+            let refs_number = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .take_while(|c| *c == '&')\n+                .count();\n+\n+            let mut trait_type = trait_ref.self_ty();\n+            let mut selcx = SelectionContext::new(self);\n+\n+            for refs_remaining in 0..refs_number {\n+                if let ty::TypeVariants::TyRef(_, ty::TypeAndMut{ ty: t_type, mutbl: _ }) =\n+                    trait_type.sty {\n+\n+                    trait_type = t_type;\n+\n+                    let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n+                    let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n+                    let new_obligation = Obligation::new(ObligationCause::dummy(),\n+                                                         obligation.param_env,\n+                                                         new_trait_ref.to_predicate());\n+\n+                    if selcx.evaluate_obligation(&new_obligation) {\n+                        let sp = self.tcx.sess.codemap()\n+                            .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+\n+                        let remove_refs = refs_remaining + 1;\n+                        let format_str = format!(\"consider removing {} leading `&`-references\",\n+                                                 remove_refs);\n+\n+                        err.span_suggestion_short(sp, &format_str, String::from(\"\"));\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to"}, {"sha": "73924c4270e669706b2fc027bff54c3fb4a9bce6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -597,21 +597,6 @@ impl CodeMap {\n         self.span_to_source(sp, |src, start_index, _| src[..start_index].to_string())\n     }\n \n-    /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n-    pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n-        match self.span_to_snippet(sp) {\n-            Ok(snippet) => {\n-                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n-                if !snippet.is_empty() && !snippet.contains('\\n') {\n-                    sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n-                } else {\n-                    sp\n-                }\n-            }\n-            _ => sp,\n-        }\n-    }\n-\n     /// Extend the given `Span` to just after the previous occurrence of `c`. Return the same span\n     /// if no character could be found or if an error occurred while retrieving the code snippet.\n     pub fn span_extend_to_prev_char(&self, sp: Span, c: char) -> Span {\n@@ -646,55 +631,74 @@ impl CodeMap {\n         sp\n     }\n \n+    /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n+    pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n+        match self.span_to_snippet(sp) {\n+            Ok(snippet) => {\n+                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n+                if !snippet.is_empty() && !snippet.contains('\\n') {\n+                    sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n+                } else {\n+                    sp\n+                }\n+            }\n+            _ => sp,\n+        }\n+    }\n+\n+    /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n+    /// `c`.\n+    pub fn span_through_char(&self, sp: Span, c: char) -> Span {\n+        if let Ok(snippet) = self.span_to_snippet(sp) {\n+            if let Some(offset) = snippet.find(c) {\n+                return sp.with_hi(BytePos(sp.lo().0 + (offset + c.len_utf8()) as u32));\n+            }\n+        }\n+        sp\n+    }\n+\n     /// Given a `Span`, get a new `Span` covering the first token and all its trailing whitespace or\n     /// the original `Span`.\n     ///\n     /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let \"` will be returned.\n     pub fn span_until_non_whitespace(&self, sp: Span) -> Span {\n-        if let Ok(snippet) = self.span_to_snippet(sp) {\n-            let mut offset = 0;\n-            // get the bytes width of all the non-whitespace characters\n-            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n-                offset += c.len_utf8();\n-            }\n-            // get the bytes width of all the whitespace characters after that\n-            for c in snippet[offset..].chars().take_while(|c| c.is_whitespace()) {\n-                offset += c.len_utf8();\n+        let mut whitespace_found = false;\n+\n+        self.span_take_while(sp, |c| {\n+            if !whitespace_found && c.is_whitespace() {\n+                whitespace_found = true;\n             }\n-            if offset > 1 {\n-                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n+\n+            if whitespace_found && !c.is_whitespace() {\n+                false\n+            } else {\n+                true\n             }\n-        }\n-        sp\n+        })\n     }\n \n     /// Given a `Span`, get a new `Span` covering the first token without its trailing whitespace or\n     /// the original `Span` in case of error.\n     ///\n     /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let\"` will be returned.\n     pub fn span_until_whitespace(&self, sp: Span) -> Span {\n-        if let Ok(snippet) = self.span_to_snippet(sp) {\n-            let mut offset = 0;\n-            // Get the bytes width of all the non-whitespace characters\n-            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n-                offset += c.len_utf8();\n-            }\n-            if offset > 1 {\n-                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n-            }\n-        }\n-        sp\n+        self.span_take_while(sp, |c| !c.is_whitespace())\n     }\n \n-    /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n-    /// `c`.\n-    pub fn span_through_char(&self, sp: Span, c: char) -> Span {\n+    /// Given a `Span`, get a shorter one until `predicate` yields false.\n+    pub fn span_take_while<P>(&self, sp: Span, predicate: P) -> Span\n+        where P: for <'r> FnMut(&'r char) -> bool\n+    {\n         if let Ok(snippet) = self.span_to_snippet(sp) {\n-            if let Some(offset) = snippet.find(c) {\n-                return sp.with_hi(BytePos(sp.lo().0 + (offset + c.len_utf8()) as u32));\n-            }\n+            let offset = snippet.chars()\n+                .take_while(predicate)\n+                .map(|c| c.len_utf8())\n+                .sum::<usize>();\n+\n+            sp.with_hi(BytePos(sp.lo().0 + (offset as u32)))\n+        } else {\n+            sp\n         }\n-        sp\n     }\n \n     pub fn def_span(&self, sp: Span) -> Span {"}, {"sha": "0f19c48337b1e351554c184ebbe7f0a6ba3c0494", "filename": "src/test/ui/suggest-remove-refs-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.rs?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![0, 1, 2, 3];\n+\n+    for (i, n) in &v.iter().enumerate() {\n+        //~^ ERROR the trait bound\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "c47b4d283d7cda5195b9edc6087ca8931276e4cc", "filename": "src/test/ui/suggest-remove-refs-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.stderr?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>: std::iter::Iterator` is not satisfied\n+  --> $DIR/suggest-remove-refs-1.rs:14:19\n+   |\n+LL |     for (i, n) in &v.iter().enumerate() {\n+   |                   -^^^^^^^^^^^^^^^^^^^^\n+   |                   |\n+   |                   `&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |                   help: consider removing 1 leading `&`-references\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required by `std::iter::IntoIterator::into_iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c427f697ae1efe297f6b0aa8fba5f7f9a74d4887", "filename": "src/test/ui/suggest-remove-refs-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.rs?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![0, 1, 2, 3];\n+\n+    for (i, n) in & & & & &v.iter().enumerate() {\n+        //~^ ERROR the trait bound\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "fdd654ea3923f9019a2ecc204be1e0f610ab0d64", "filename": "src/test/ui/suggest-remove-refs-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.stderr?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>: std::iter::Iterator` is not satisfied\n+  --> $DIR/suggest-remove-refs-2.rs:14:19\n+   |\n+LL |     for (i, n) in & & & & &v.iter().enumerate() {\n+   |                   ---------^^^^^^^^^^^^^^^^^^^^\n+   |                   |\n+   |                   `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |                   help: consider removing 5 leading `&`-references\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required by `std::iter::IntoIterator::into_iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f54ae30caebca921c40229dec68cca855fa352e4", "filename": "src/test/ui/suggest-remove-refs-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.rs?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![0, 1, 2, 3];\n+\n+    for (i, n) in & & &\n+        & &v\n+        .iter()\n+        .enumerate() {\n+        //~^^^^ ERROR the trait bound\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "b0920a0fa523ee2b1850db901d036b29689c8955", "filename": "src/test/ui/suggest-remove-refs-3.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49b584ce6025fd4a00f0b666b2e211a46d063f1b/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.stderr?ref=49b584ce6025fd4a00f0b666b2e211a46d063f1b", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>: std::iter::Iterator` is not satisfied\n+  --> $DIR/suggest-remove-refs-3.rs:14:19\n+   |\n+LL |        for (i, n) in & & &\n+   |   ___________________^\n+   |  |___________________|\n+   | ||\n+LL | ||         & &v\n+   | ||___________- help: consider removing 5 leading `&`-references\n+LL | |          .iter()\n+LL | |          .enumerate() {\n+   | |_____________________^ `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required by `std::iter::IntoIterator::into_iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}