{"sha": "f974617bdafa2e5205c1e852fe3ce61f29e2c026", "node_id": "C_kwDOAAsO6NoAKGY5NzQ2MTdiZGFmYTJlNTIwNWMxZTg1MmZlM2NlNjFmMjllMmMwMjY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-25T12:19:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-08-26T01:12:36Z"}, "message": "Move `ArgAbi::pad_i32` into `PassMode::Cast`.\n\nBecause it's only needed for that variant. This shrinks the types and\nclarifies the logic.", "tree": {"sha": "f24cb767d9601190bb23aeedc065b8e21871cac9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f24cb767d9601190bb23aeedc065b8e21871cac9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f974617bdafa2e5205c1e852fe3ce61f29e2c026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f974617bdafa2e5205c1e852fe3ce61f29e2c026", "html_url": "https://github.com/rust-lang/rust/commit/f974617bdafa2e5205c1e852fe3ce61f29e2c026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f974617bdafa2e5205c1e852fe3ce61f29e2c026/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b853e8a6194637751bffbcfdd5bb51c7bfecdff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b853e8a6194637751bffbcfdd5bb51c7bfecdff5", "html_url": "https://github.com/rust-lang/rust/commit/b853e8a6194637751bffbcfdd5bb51c7bfecdff5"}], "stats": {"total": 168, "additions": 80, "deletions": 88}, "files": [{"sha": "165f15bb3f1225a4e3326639d4dbea9c61c9b333", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -100,7 +100,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(ref cast) => cast_target_to_abi_params(cast),\n+            PassMode::Cast(ref cast, pad_i32) => {\n+                assert!(!pad_i32, \"padding support not yet implemented\");\n+                cast_target_to_abi_params(cast)\n+            }\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     // Abi requires aligning struct size to pointer size\n@@ -145,7 +148,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(ref cast) => {\n+            PassMode::Cast(ref cast, _) => {\n                 (None, cast_target_to_abi_params(cast).into_iter().collect())\n             }\n             PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n@@ -226,7 +229,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(ref cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Cast(ref cast, _) => to_casted_value(fx, arg, cast),\n         PassMode::Indirect { .. } => {\n             if is_owned {\n                 match arg.force_stack(fx) {\n@@ -284,7 +287,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n-        PassMode::Cast(ref cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n         }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {"}, {"sha": "aaa1418767a357680ef3b2cd5b2ad8a2d970c015", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -13,7 +13,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -75,7 +75,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => (None, None),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => (None, None),\n     };\n \n     let call_inst = f(fx, return_ptr);\n@@ -92,7 +92,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n             ret_place\n                 .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n-        PassMode::Cast(ref cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let results =\n                 fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n             let result =\n@@ -131,7 +131,7 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n-        PassMode::Cast(ref cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx);\n             let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);"}, {"sha": "848c34211ff616c09c9bf2f8a62b535442646fbf", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -117,19 +117,14 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             match self.ret.mode {\n                 PassMode::Ignore => cx.type_void(),\n                 PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_gcc_type(cx),\n-                PassMode::Cast(ref cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, _) => cast.gcc_type(cx),\n                 PassMode::Indirect { .. } => {\n                     argument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                     cx.type_void()\n                 }\n             };\n \n         for arg in self.args.iter() {\n-            // add padding\n-            if arg.pad_i32 {\n-                argument_tys.push(Reg::i32().gcc_type(cx));\n-            }\n-\n             let arg_ty = match arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_gcc_type(cx),\n@@ -141,7 +136,13 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                     unimplemented!();\n                 }\n-                PassMode::Cast(ref cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, pad_i32) => {\n+                    // add padding\n+                    if pad_i32 {\n+                        argument_tys.push(Reg::i32().gcc_type(cx));\n+                    }\n+                    cast.gcc_type(cx)\n+                }\n                 PassMode::Indirect { extra_attrs: None, on_stack: true, .. } => {\n                     on_stack_param_indices.insert(argument_tys.len());\n                     arg.memory_ty(cx)"}, {"sha": "352fe7568eff0011fb84110c95be011cd83603a9", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 sym::volatile_load | sym::unaligned_volatile_load => {\n                     let tp_ty = substs.type_at(0);\n                     let mut ptr = args[0].immediate();\n-                    if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n+                    if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                         ptr = self.pointercast(ptr, self.type_ptr_to(ty.gcc_type(self)));\n                     }\n                     let load = self.volatile_load(ptr.get_type(), ptr);\n@@ -320,7 +320,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.gcc_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);\n@@ -416,7 +416,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n         }\n-        else if let PassMode::Cast(ref cast) = self.mode {\n+        else if let PassMode::Cast(ref cast, _) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -481,7 +481,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             },\n-            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(_) => {\n+            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(..) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             },"}, {"sha": "0ce161d7e756cfbc2960375df513f12bd917733f", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -213,7 +213,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n-        } else if let PassMode::Cast(cast) = &self.mode {\n+        } else if let PassMode::Cast(cast, _) = &self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -283,7 +283,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             }\n             PassMode::Direct(_)\n             | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ }\n-            | PassMode::Cast(_) => {\n+            | PassMode::Cast(..) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             }\n@@ -336,19 +336,14 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         let llreturn_ty = match &self.ret.mode {\n             PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_llvm_type(cx),\n-            PassMode::Cast(cast) => cast.llvm_type(cx),\n+            PassMode::Cast(cast, _) => cast.llvm_type(cx),\n             PassMode::Indirect { .. } => {\n                 llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                 cx.type_void()\n             }\n         };\n \n         for arg in args {\n-            // add padding\n-            if arg.pad_i32 {\n-                llargument_tys.push(Reg::i32().llvm_type(cx));\n-            }\n-\n             let llarg_ty = match &arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n@@ -364,7 +359,13 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n-                PassMode::Cast(cast) => cast.llvm_type(cx),\n+                PassMode::Cast(cast, pad_i32) => {\n+                    // add padding\n+                    if *pad_i32 {\n+                        llargument_tys.push(Reg::i32().llvm_type(cx));\n+                    }\n+                    cast.llvm_type(cx)\n+                }\n                 PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n                     cx.type_ptr_to(arg.memory_ty(cx))\n                 }\n@@ -434,15 +435,12 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 let sret = llvm::CreateStructRetAttr(cx.llcx, self.ret.layout.llvm_type(cx));\n                 attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n-            PassMode::Cast(cast) => {\n+            PassMode::Cast(cast, _) => {\n                 cast.attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n             }\n             _ => {}\n         }\n         for arg in self.args.iter() {\n-            if arg.pad_i32 {\n-                apply(&ArgAttributes::new());\n-            }\n             match &arg.mode {\n                 PassMode::Ignore => {}\n                 PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n@@ -463,7 +461,10 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     apply(a);\n                     apply(b);\n                 }\n-                PassMode::Cast(cast) => {\n+                PassMode::Cast(cast, pad_i32) => {\n+                    if *pad_i32 {\n+                        apply(&ArgAttributes::new());\n+                    }\n                     apply(&cast.attrs);\n                 }\n             }\n@@ -496,7 +497,7 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 let sret = llvm::CreateStructRetAttr(bx.cx.llcx, self.ret.layout.llvm_type(bx));\n                 attributes::apply_to_callsite(callsite, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n-            PassMode::Cast(cast) => {\n+            PassMode::Cast(cast, _) => {\n                 cast.attrs.apply_attrs_to_callsite(\n                     llvm::AttributePlace::ReturnValue,\n                     &bx.cx,\n@@ -516,9 +517,6 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             }\n         }\n         for arg in self.args.iter() {\n-            if arg.pad_i32 {\n-                apply(bx.cx, &ArgAttributes::new());\n-            }\n             match &arg.mode {\n                 PassMode::Ignore => {}\n                 PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n@@ -542,7 +540,10 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     apply(bx.cx, a);\n                     apply(bx.cx, b);\n                 }\n-                PassMode::Cast(cast) => {\n+                PassMode::Cast(cast, pad_i32) => {\n+                    if *pad_i32 {\n+                        apply(bx.cx, &ArgAttributes::new());\n+                    }\n                     apply(bx.cx, &cast.attrs);\n                 }\n             }"}, {"sha": "f4227fbd8fa3b9528ee224afb7f7ab6923071827", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -161,7 +161,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n                 let ptr = args[0].immediate();\n-                let load = if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n+                let load = if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                     let llty = ty.llvm_type(self);\n                     let ptr = self.pointercast(ptr, self.type_ptr_to(llty));\n                     self.volatile_load(llty, ptr)\n@@ -374,7 +374,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.llvm_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);"}, {"sha": "5c67d3b6431fd5f346438bde0fe17ecb19904f72", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -339,7 +339,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            PassMode::Cast(cast_ty) => {\n+            PassMode::Cast(cast_ty, _) => {\n                 let op = match self.locals[mir::RETURN_PLACE] {\n                     LocalRef::Operand(Some(op)) => op,\n                     LocalRef::Operand(None) => bug!(\"use of return before def\"),\n@@ -1158,39 +1158,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         llargs: &mut Vec<Bx::Value>,\n         arg: &ArgAbi<'tcx, Ty<'tcx>>,\n     ) {\n-        // Fill padding with undef value, where applicable.\n-        if arg.pad_i32 {\n-            llargs.push(bx.const_undef(bx.reg_backend_type(&Reg::i32())))\n-        }\n-\n-        if arg.is_ignore() {\n-            return;\n-        }\n-\n-        if let PassMode::Pair(..) = arg.mode {\n-            match op.val {\n+        match arg.mode {\n+            PassMode::Ignore => return,\n+            PassMode::Cast(_, true) => {\n+                // Fill padding with undef value, where applicable.\n+                llargs.push(bx.const_undef(bx.reg_backend_type(&Reg::i32())));\n+            }\n+            PassMode::Pair(..) => match op.val {\n                 Pair(a, b) => {\n                     llargs.push(a);\n                     llargs.push(b);\n                     return;\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for pair argument\", op),\n-            }\n-        } else if arg.is_unsized_indirect() {\n-            match op.val {\n+            },\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => match op.val {\n                 Ref(a, Some(b), _) => {\n                     llargs.push(a);\n                     llargs.push(b);\n                     return;\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for unsized indirect argument\", op),\n-            }\n+            },\n+            _ => {}\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => match arg.mode {\n-                PassMode::Indirect { .. } | PassMode::Cast(_) => {\n+                PassMode::Indirect { .. } | PassMode::Cast(..) => {\n                     let scratch = PlaceRef::alloca(bx, arg.layout);\n                     op.val.store(bx, scratch);\n                     (scratch.llval, scratch.align, true)\n@@ -1222,7 +1218,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if let PassMode::Cast(ty) = &arg.mode {\n+            if let PassMode::Cast(ty, _) = &arg.mode {\n                 let llty = bx.cast_backend_type(ty);\n                 let addr = bx.pointercast(llval, bx.type_ptr_to(llty));\n                 llval = bx.load(llty, addr, align.min(arg.layout.align.abi));\n@@ -1622,7 +1618,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n-                let op = if let PassMode::Cast(_) = ret_abi.mode {\n+                let op = if let PassMode::Cast(..) = ret_abi.mode {\n                     let tmp = PlaceRef::alloca(bx, ret_abi.layout);\n                     tmp.storage_live(bx);\n                     bx.store_arg(&ret_abi, llval, tmp);"}, {"sha": "16aad07194da8afa048c5fcf94a02a6caa5d134b", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -597,7 +597,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = &fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(ty));\n                 let ptr = bx.pointercast(result.llval, ptr_llty);\n                 bx.store(llval, ptr, result.align);"}, {"sha": "c70c2bd9f741d7e4d4e0eab1e35497dc98683aa7", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -283,7 +283,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 for i in 0..tupled_arg_tys.len() {\n                     let arg = &fx.fn_abi.args[idx];\n                     idx += 1;\n-                    if arg.pad_i32 {\n+                    if let PassMode::Cast(_, true) = arg.mode {\n                         llarg_idx += 1;\n                     }\n                     let pr_field = place.project_field(bx, i);\n@@ -309,7 +309,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n             let arg = &fx.fn_abi.args[idx];\n             idx += 1;\n-            if arg.pad_i32 {\n+            if let PassMode::Cast(_, true) = arg.mode {\n                 llarg_idx += 1;\n             }\n "}, {"sha": "35b1fefd2865800f2058e0aa75daa8314216d755", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -215,8 +215,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 _ => false,\n             }\n         };\n-        // Padding must be fully equal.\n-        let pad_compat = || caller_abi.pad_i32 == callee_abi.pad_i32;\n         // When comparing the PassMode, we have to be smart about comparing the attributes.\n         let arg_attr_compat = |a1: &ArgAttributes, a2: &ArgAttributes| {\n             // There's only one regular attribute that matters for the call ABI: InReg.\n@@ -239,7 +237,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (PassMode::Pair(a1, b1), PassMode::Pair(a2, b2)) => {\n                 arg_attr_compat(a1, a2) && arg_attr_compat(b1, b2)\n             }\n-            (PassMode::Cast(c1), PassMode::Cast(c2)) => c1 == c2,\n+            (PassMode::Cast(c1, pad1), PassMode::Cast(c2, pad2)) => c1 == c2 && pad1 == pad2,\n             (\n                 PassMode::Indirect { attrs: a1, extra_attrs: None, on_stack: s1 },\n                 PassMode::Indirect { attrs: a2, extra_attrs: None, on_stack: s2 },\n@@ -251,7 +249,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => false,\n         };\n \n-        if layout_compat() && pad_compat() && mode_compat() {\n+        if layout_compat() && mode_compat() {\n             return true;\n         }\n         trace!("}, {"sha": "edcd1bab8b4b0606f5f6695bf262693f080c123c", "filename": "compiler/rustc_target/src/abi/call/mips.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -22,10 +22,8 @@ where\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform { unit: Reg::i32(), total: size });\n-        if !offset.is_aligned(align) {\n-            arg.pad_with_i32();\n-        }\n+        let pad_i32 = !offset.is_aligned(align);\n+        arg.cast_to_and_pad_i32(Uniform { unit: Reg::i32(), total: size }, pad_i32);\n     } else {\n         arg.extend_integer_width_to(32);\n     }"}, {"sha": "d2eb804d004804185f81c27bd64022f7acfa13ca", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -40,9 +40,10 @@ pub enum PassMode {\n     ///\n     /// The argument has a layout abi of `ScalarPair`.\n     Pair(ArgAttributes, ArgAttributes),\n-    /// Pass the argument after casting it, to either\n-    /// a single uniform or a pair of registers.\n-    Cast(Box<CastTarget>),\n+    /// Pass the argument after casting it, to either a single uniform or a\n+    /// pair of registers. The bool indicates if a `Reg::i32()` dummy argument\n+    /// is emitted before the real argument.\n+    Cast(Box<CastTarget>, bool),\n     /// Pass the argument indirectly via a hidden pointer.\n     /// The `extra_attrs` value, if any, is for the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n@@ -463,10 +464,6 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct ArgAbi<'a, Ty> {\n     pub layout: TyAndLayout<'a, Ty>,\n-\n-    /// Dummy argument, which is emitted before the real argument.\n-    pub pad_i32: bool,\n-\n     pub mode: PassMode,\n }\n \n@@ -486,7 +483,7 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n             Abi::Vector { .. } => PassMode::Direct(ArgAttributes::new()),\n             Abi::Aggregate { .. } => PassMode::Direct(ArgAttributes::new()),\n         };\n-        ArgAbi { layout, pad_i32: false, mode }\n+        ArgAbi { layout, mode }\n     }\n \n     fn indirect_pass_mode(layout: &TyAndLayout<'a, Ty>) -> PassMode {\n@@ -548,11 +545,11 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n-        self.mode = PassMode::Cast(Box::new(target.into()));\n+        self.mode = PassMode::Cast(Box::new(target.into()), false);\n     }\n \n-    pub fn pad_with_i32(&mut self) {\n-        self.pad_i32 = true;\n+    pub fn cast_to_and_pad_i32<T: Into<CastTarget>>(&mut self, target: T, pad_i32: bool) {\n+        self.mode = PassMode::Cast(Box::new(target.into()), pad_i32);\n     }\n \n     pub fn is_indirect(&self) -> bool {\n@@ -737,6 +734,6 @@ mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(ArgAbi<'_, usize>, 64);\n-    static_assert_size!(FnAbi<'_, usize>, 88);\n+    static_assert_size!(ArgAbi<'_, usize>, 56);\n+    static_assert_size!(FnAbi<'_, usize>, 80);\n }"}, {"sha": "edcd1bab8b4b0606f5f6695bf262693f080c123c", "filename": "compiler/rustc_target/src/abi/call/sparc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -22,10 +22,8 @@ where\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform { unit: Reg::i32(), total: size });\n-        if !offset.is_aligned(align) {\n-            arg.pad_with_i32();\n-        }\n+        let pad_i32 = !offset.is_aligned(align);\n+        arg.cast_to_and_pad_i32(Uniform { unit: Reg::i32(), total: size }, pad_i32);\n     } else {\n         arg.extend_integer_width_to(32);\n     }"}, {"sha": "7c26335dcf4cde4c1641ddd0f747bacfb88f1adb", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f974617bdafa2e5205c1e852fe3ce61f29e2c026/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=f974617bdafa2e5205c1e852fe3ce61f29e2c026", "patch": "@@ -81,7 +81,7 @@ where\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..)\n                 | PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ }\n-                | PassMode::Cast(_) => {\n+                | PassMode::Cast(..) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }\n             };"}]}