{"sha": "44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "node_id": "C_kwDOAAsO6NoAKDQ0NTY4MDA3ZDFmM2Q1MWI4NGFkNThkMmRkZWRhMmJhZGQzYWVlYTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T12:59:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T12:59:39Z"}, "message": "Auto merge of #14128 - Veykril:parser, r=Veykril\n\ninternal: Improve parser recovery for delimited lists\n\nCloses https://github.com/rust-lang/rust-analyzer/issues/11188, https://github.com/rust-lang/rust-analyzer/issues/10410, https://github.com/rust-lang/rust-analyzer/issues/10173\n\nShould probably be merged after the stable release as this might get the parser stuck if I missed something", "tree": {"sha": "c33883537d49a35b9d818b5b312cfa974e2c33bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c33883537d49a35b9d818b5b312cfa974e2c33bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "html_url": "https://github.com/rust-lang/rust/commit/44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88b3d9f6f43a5e18a3caea1c71db64bf235d97d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b3d9f6f43a5e18a3caea1c71db64bf235d97d8", "html_url": "https://github.com/rust-lang/rust/commit/88b3d9f6f43a5e18a3caea1c71db64bf235d97d8"}, {"sha": "4f6b5f41d49141a3907bfef2a81108a141d340a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f6b5f41d49141a3907bfef2a81108a141d340a8", "html_url": "https://github.com/rust-lang/rust/commit/4f6b5f41d49141a3907bfef2a81108a141d340a8"}], "stats": {"total": 1180, "additions": 815, "deletions": 365}, "files": [{"sha": "6ce455424af5f7106f8fdb1caca1c898093bc220", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1174,6 +1174,7 @@ dependencies = [\n  \"limit\",\n  \"rustc-ap-rustc_lexer\",\n  \"sourcegen\",\n+ \"stdx\",\n ]\n \n [[package]]"}, {"sha": "7a3e8c3b05c911037963737f4d48b19aae9b0b03", "filename": "crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1476,7 +1476,7 @@ macro_rules! m {\n /* parse error: expected identifier */\n /* parse error: expected SEMICOLON */\n /* parse error: expected SEMICOLON */\n-/* parse error: expected expression */\n+/* parse error: expected expression, item or let statement */\n fn f() {\n     K::(C(\"0\"));\n }"}, {"sha": "8358a46f0a9142f7db24a5ea143f6553ce6d0cf5", "filename": "crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -830,8 +830,7 @@ macro_rules! rgb_color {\n /* parse error: expected COMMA */\n /* parse error: expected R_ANGLE */\n /* parse error: expected SEMICOLON */\n-/* parse error: expected SEMICOLON */\n-/* parse error: expected expression */\n+/* parse error: expected expression, item or let statement */\n pub fn new() {\n     let _ = 0as u32<<(8+8);\n }\n@@ -848,21 +847,21 @@ pub fn new() {\n //     BLOCK_EXPR@10..31\n //       STMT_LIST@10..31\n //         L_CURLY@10..11 \"{\"\n-//         LET_STMT@11..27\n+//         LET_STMT@11..28\n //           LET_KW@11..14 \"let\"\n //           WILDCARD_PAT@14..15\n //             UNDERSCORE@14..15 \"_\"\n //           EQ@15..16 \"=\"\n-//           CAST_EXPR@16..27\n+//           CAST_EXPR@16..28\n //             LITERAL@16..17\n //               INT_NUMBER@16..17 \"0\"\n //             AS_KW@17..19 \"as\"\n-//             PATH_TYPE@19..27\n-//               PATH@19..27\n-//                 PATH_SEGMENT@19..27\n+//             PATH_TYPE@19..28\n+//               PATH@19..28\n+//                 PATH_SEGMENT@19..28\n //                   NAME_REF@19..22\n //                     IDENT@19..22 \"u32\"\n-//                   GENERIC_ARG_LIST@22..27\n+//                   GENERIC_ARG_LIST@22..28\n //                     L_ANGLE@22..23 \"<\"\n //                     TYPE_ARG@23..27\n //                       DYN_TRAIT_TYPE@23..27\n@@ -877,9 +876,9 @@ pub fn new() {\n //                                     ERROR@25..26\n //                                       INT_NUMBER@25..26 \"8\"\n //                           PLUS@26..27 \"+\"\n-//         EXPR_STMT@27..28\n-//           LITERAL@27..28\n-//             INT_NUMBER@27..28 \"8\"\n+//                     CONST_ARG@27..28\n+//                       LITERAL@27..28\n+//                         INT_NUMBER@27..28 \"8\"\n //         ERROR@28..29\n //           R_PAREN@28..29 \")\"\n //         SEMICOLON@29..30 \";\""}, {"sha": "b5eb253d03e2090213fd14f968afdb36540dc23d", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -668,8 +668,15 @@ fn classify_name_ref(\n     };\n     let after_if_expr = |node: SyntaxNode| {\n         let prev_expr = (|| {\n+            let node = match node.parent().and_then(ast::ExprStmt::cast) {\n+                Some(stmt) => stmt.syntax().clone(),\n+                None => node,\n+            };\n             let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-            ast::ExprStmt::cast(prev_sibling)?.expr()\n+\n+            ast::ExprStmt::cast(prev_sibling.clone())\n+                .and_then(|it| it.expr())\n+                .or_else(|| ast::Expr::cast(prev_sibling))\n         })();\n         matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n     };"}, {"sha": "c1c6a689eb18a29a2e3e10e339dcb300ac0f99be", "filename": "crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -745,3 +745,255 @@ fn return_value_no_block() {\n         r#\"fn f() -> i32 { match () { () => return $0 } }\"#,\n     );\n }\n+\n+#[test]\n+fn else_completion_after_if() {\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} $0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} el$0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 { let x = 92; } }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}"}, {"sha": "cb71c7b2bdef3ff6a87e8c0d19afafff2de57a91", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -2,13 +2,20 @@\n \n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list_no_kw, completion_list_with_trigger_character};\n+use crate::tests::{\n+    check_edit, completion_list, completion_list_no_kw, completion_list_with_trigger_character,\n+};\n \n-fn check(ra_fixture: &str, expect: Expect) {\n+fn check_no_kw(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list_no_kw(ra_fixture);\n     expect.assert_eq(&actual)\n }\n \n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n pub(crate) fn check_with_trigger_character(\n     ra_fixture: &str,\n     trigger_character: Option<char>,\n@@ -59,7 +66,7 @@ fn _alpha() {}\n \n #[test]\n fn completes_prelude() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn foo() { let x: $0 }\n@@ -81,7 +88,7 @@ pub mod prelude {\n \n #[test]\n fn completes_prelude_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn f() {$0}\n@@ -110,7 +117,7 @@ mod macros {\n \n #[test]\n fn completes_std_prelude_if_core_is_defined() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:core,std\n fn foo() { let x: $0 }\n@@ -140,7 +147,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n fn f() {\n@@ -168,7 +175,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden_in_assoc_item_list() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n struct S;\n@@ -195,7 +202,7 @@ pub mod prelude {\n \n #[test]\n fn associated_item_visibility() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib new_source_root:library\n pub struct S;\n@@ -222,7 +229,7 @@ fn foo() { let _ = lib::S::$0 }\n \n #[test]\n fn completes_union_associated_method() {\n-    check(\n+    check_no_kw(\n         r#\"\n union U {};\n impl U { fn m() { } }\n@@ -237,7 +244,7 @@ fn foo() { let _ = U::$0 }\n \n #[test]\n fn completes_trait_associated_method_1() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -251,7 +258,7 @@ fn foo() { let _ = Trait::$0 }\n \n #[test]\n fn completes_trait_associated_method_2() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -268,7 +275,7 @@ fn foo() { let _ = S::$0 }\n \n #[test]\n fn completes_trait_associated_method_3() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -285,7 +292,7 @@ fn foo() { let _ = <S as Trait>::$0 }\n \n #[test]\n fn completes_ty_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -318,7 +325,7 @@ fn foo<T: Sub>() { T::$0 }\n \n #[test]\n fn completes_self_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -358,7 +365,7 @@ impl<T> Sub for Wrap<T> {\n \n #[test]\n fn completes_type_alias() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct S;\n impl S { fn foo() {} }\n@@ -376,7 +383,7 @@ fn main() { T::$0; }\n \n #[test]\n fn completes_qualified_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n #[macro_export]\n macro_rules! foo { () => {} }\n@@ -392,7 +399,7 @@ fn main() { let _ = crate::$0 }\n \n #[test]\n fn does_not_complete_non_fn_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -403,7 +410,7 @@ fn f() {m::$0}\n \"#,\n         expect![[r#\"\"#]],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -418,7 +425,7 @@ fn f() {m::$0}\n \n #[test]\n fn completes_reexported_items_under_correct_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -475,7 +482,7 @@ mod p {\n \n #[test]\n fn completes_in_simple_macro_call() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n fn main() { m!(self::f$0); }\n@@ -490,7 +497,7 @@ fn foo() {}\n \n #[test]\n fn function_mod_share_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -508,7 +515,7 @@ mod m {\n \n #[test]\n fn completes_hashmap_new() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct RandomState;\n struct HashMap<K, V, S = RandomState> {}\n@@ -529,7 +536,7 @@ fn foo() {\n #[test]\n fn completes_variant_through_self() {\n     cov_mark::check!(completes_variant_through_self);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar,\n@@ -552,7 +559,7 @@ impl Foo {\n \n #[test]\n fn completes_non_exhaustive_variant_within_the_defining_crate() {\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     #[non_exhaustive]\n@@ -570,7 +577,7 @@ fn foo(self) {\n             \"#]],\n     );\n \n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:e\n fn foo(self) {\n@@ -593,7 +600,7 @@ enum Foo {\n #[test]\n fn completes_primitive_assoc_const() {\n     cov_mark::check!(completes_primitive_assoc_const);\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:core\n fn f() {\n@@ -618,7 +625,7 @@ impl u8 {\n #[test]\n fn completes_variant_through_alias() {\n     cov_mark::check!(completes_variant_through_alias);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar\n@@ -636,7 +643,7 @@ fn main() {\n \n #[test]\n fn respects_doc_hidden2() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:dep\n fn f() {\n@@ -665,7 +672,7 @@ pub mod m {}\n \n #[test]\n fn type_anchor_empty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -688,7 +695,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -715,7 +722,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type_trait() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -741,7 +748,7 @@ fn bar() -> Bar {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -775,7 +782,7 @@ fn main() {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_recursive_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -815,7 +822,7 @@ fn main() {\n \n #[test]\n fn completes_const_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_const {\n@@ -847,7 +854,7 @@ fn main() {\n \n #[test]\n fn completes_locals_from_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n \n macro_rules! x {\n@@ -875,7 +882,7 @@ fn main() {\n \n #[test]\n fn regression_12644() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! __rust_force_expr {\n     ($e:expr) => {\n@@ -974,7 +981,7 @@ fn foo { crate:::$0 }\n \"#,\n         expect![\"\"],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo { crate::::$0 }\n \"#,"}, {"sha": "2b6b60547b355e9bb41f6f381f479f8101ddbbc4", "filename": "crates/ide-db/src/active_parameter.rs", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Factive_parameter.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -2,9 +2,10 @@\n \n use either::Either;\n use hir::{Semantics, Type};\n+use parser::T;\n use syntax::{\n     ast::{self, HasArgList, HasName},\n-    AstNode, SyntaxToken,\n+    match_ast, AstNode, NodeOrToken, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -58,21 +59,86 @@ pub fn callable_for_node(\n     calling_node: &ast::CallableExpr,\n     token: &SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {\n-    let callable = match &calling_node {\n+    let callable = match calling_node {\n         ast::CallableExpr::Call(call) => {\n             let expr = call.expr()?;\n             sema.type_of_expr(&expr)?.adjusted().as_callable(sema.db)\n         }\n         ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),\n     }?;\n     let active_param = if let Some(arg_list) = calling_node.arg_list() {\n-        let param = arg_list\n-            .args()\n-            .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-            .count();\n-        Some(param)\n+        Some(\n+            arg_list\n+                .syntax()\n+                .children_with_tokens()\n+                .filter_map(NodeOrToken::into_token)\n+                .filter(|t| t.kind() == T![,])\n+                .take_while(|t| t.text_range().start() <= token.text_range().start())\n+                .count(),\n+        )\n     } else {\n         None\n     };\n     Some((callable, active_param))\n }\n+\n+pub fn generic_def_for_node(\n+    sema: &Semantics<'_, RootDatabase>,\n+    generic_arg_list: &ast::GenericArgList,\n+    token: &SyntaxToken,\n+) -> Option<(hir::GenericDef, usize, bool)> {\n+    let parent = generic_arg_list.syntax().parent()?;\n+    let def = match_ast! {\n+        match parent {\n+            ast::PathSegment(ps) => {\n+                let res = sema.resolve_path(&ps.parent_path())?;\n+                let generic_def: hir::GenericDef = match res {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n+                    hir::PathResolution::BuiltinAttr(_)\n+                    | hir::PathResolution::ToolModule(_)\n+                    | hir::PathResolution::Local(_)\n+                    | hir::PathResolution::TypeParam(_)\n+                    | hir::PathResolution::ConstParam(_)\n+                    | hir::PathResolution::SelfType(_)\n+                    | hir::PathResolution::DeriveHelper(_) => return None,\n+                };\n+\n+                generic_def\n+            },\n+            ast::AssocTypeArg(_) => {\n+                // FIXME: We don't record the resolutions for this anywhere atm\n+                return None;\n+            },\n+            ast::MethodCallExpr(mcall) => {\n+                // recv.method::<$0>()\n+                let method = sema.resolve_method_call(&mcall)?;\n+                method.into()\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let active_param = generic_arg_list\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n+        .count();\n+\n+    let first_arg_is_non_lifetime = generic_arg_list\n+        .generic_args()\n+        .next()\n+        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n+\n+    Some((def, active_param, first_arg_is_non_lifetime))\n+}"}, {"sha": "f70ca55a508d2b8045e841aa668b2a422342560b", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 49, "deletions": 75, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -7,12 +7,16 @@ use either::Either;\n use hir::{\n     AssocItem, GenericParam, HasAttrs, HirDisplay, ModuleDef, PathResolution, Semantics, Trait,\n };\n-use ide_db::{active_parameter::callable_for_node, base_db::FilePosition, FxIndexMap};\n+use ide_db::{\n+    active_parameter::{callable_for_node, generic_def_for_node},\n+    base_db::FilePosition,\n+    FxIndexMap,\n+};\n use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxKind, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -105,10 +109,10 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n         // Stop at multi-line expressions, since the signature of the outer call is not very\n         // helpful inside them.\n         if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            if expr.syntax().text().contains_char('\\n')\n-                && expr.syntax().kind() != SyntaxKind::RECORD_EXPR\n+            if !matches!(expr, ast::Expr::RecordExpr(..))\n+                && expr.syntax().text().contains_char('\\n')\n             {\n-                return None;\n+                break;\n             }\n         }\n     }\n@@ -122,18 +126,16 @@ fn signature_help_for_call(\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     // Find the calling expression and its NameRef\n-    let mut node = arg_list.syntax().parent()?;\n+    let mut nodes = arg_list.syntax().ancestors().skip(1);\n     let calling_node = loop {\n-        if let Some(callable) = ast::CallableExpr::cast(node.clone()) {\n-            if callable\n+        if let Some(callable) = ast::CallableExpr::cast(nodes.next()?) {\n+            let inside_callable = callable\n                 .arg_list()\n-                .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n-            {\n+                .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()));\n+            if inside_callable {\n                 break callable;\n             }\n         }\n-\n-        node = node.parent()?;\n     };\n \n     let (callable, active_parameter) = callable_for_node(sema, &calling_node, &token)?;\n@@ -216,59 +218,11 @@ fn signature_help_for_call(\n \n fn signature_help_for_generics(\n     sema: &Semantics<'_, RootDatabase>,\n-    garg_list: ast::GenericArgList,\n+    arg_list: ast::GenericArgList,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = garg_list\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::GenericArgList::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let mut active_parameter = arg_list\n-        .generic_args()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-        .count();\n-\n-    let first_arg_is_non_lifetime = arg_list\n-        .generic_args()\n-        .next()\n-        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n-\n-    let mut generics_def = if let Some(path) =\n-        arg_list.syntax().ancestors().find_map(ast::Path::cast)\n-    {\n-        let res = sema.resolve_path(&path)?;\n-        let generic_def: hir::GenericDef = match res {\n-            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n-            hir::PathResolution::BuiltinAttr(_)\n-            | hir::PathResolution::ToolModule(_)\n-            | hir::PathResolution::Local(_)\n-            | hir::PathResolution::TypeParam(_)\n-            | hir::PathResolution::ConstParam(_)\n-            | hir::PathResolution::SelfType(_)\n-            | hir::PathResolution::DeriveHelper(_) => return None,\n-        };\n-\n-        generic_def\n-    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n-    {\n-        // recv.method::<$0>()\n-        let method = sema.resolve_method_call(&method_call)?;\n-        method.into()\n-    } else {\n-        return None;\n-    };\n-\n+    let (mut generics_def, mut active_parameter, first_arg_is_non_lifetime) =\n+        generic_def_for_node(sema, &arg_list, &token)?;\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n@@ -307,9 +261,9 @@ fn signature_help_for_generics(\n             // eg. `None::<u8>`\n             // We'll use the signature of the enum, but include the docs of the variant.\n             res.doc = it.docs(db).map(|it| it.into());\n-            let it = it.parent_enum(db);\n-            format_to!(res.signature, \"enum {}\", it.name(db));\n-            generics_def = it.into();\n+            let enum_ = it.parent_enum(db);\n+            format_to!(res.signature, \"enum {}\", enum_.name(db));\n+            generics_def = enum_.into();\n         }\n         // These don't have generic args that can be specified\n         hir::GenericDef::Impl(_) | hir::GenericDef::Const(_) => return None,\n@@ -388,16 +342,13 @@ fn signature_help_for_record_lit(\n     record: ast::RecordExpr,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = record\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::RecordExpr::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let active_parameter = arg_list\n+    let active_parameter = record\n         .record_expr_field_list()?\n-        .fields()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n         .count();\n \n     let mut res = SignatureHelp {\n@@ -1594,4 +1545,27 @@ impl S {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_enum_in_nested_method_in_lambda() {\n+        check(\n+            r#\"\n+enum A {\n+    A,\n+    B\n+}\n+\n+fn bar(_: A) { }\n+\n+fn main() {\n+    let foo = Foo;\n+    std::thread::spawn(move || { bar(A:$0) } );\n+}\n+\"#,\n+            expect![[r#\"\n+                fn bar(_: A)\n+                       ^^^^\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "fc9b5d3ba4cd79303f3254b2306d20190e825ba7", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1126,5 +1126,5 @@ fn benchmark_syntax_highlighting_parser() {\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))\n             .count()\n     };\n-    assert_eq!(hash, 1609);\n+    assert_eq!(hash, 1608);\n }"}, {"sha": "6e962abd75477aa09bf20ea94f3f18d9afe4e2f1", "filename": "crates/parser/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2FCargo.toml?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -20,4 +20,5 @@ limit.workspace = true\n [dev-dependencies]\n expect-test = \"1.4.0\"\n \n+stdx.workspace = true\n sourcegen.workspace = true"}, {"sha": "15ec9e167e025534ffb2ceb63830a96f10aaaa72", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -200,6 +200,8 @@ impl BlockLike {\n     }\n }\n \n+const VISIBILITY_FIRST: TokenSet = TokenSet::new(&[T![pub], T![crate]]);\n+\n fn opt_visibility(p: &mut Parser<'_>, in_tuple_field: bool) -> bool {\n     match p.current() {\n         T![pub] => {\n@@ -340,3 +342,31 @@ fn error_block(p: &mut Parser<'_>, message: &str) {\n     p.eat(T!['}']);\n     m.complete(p, ERROR);\n }\n+\n+/// The `parser` passed this is required to at least consume one token if it returns `true`.\n+/// If the `parser` returns false, parsing will stop.\n+fn delimited(\n+    p: &mut Parser<'_>,\n+    bra: SyntaxKind,\n+    ket: SyntaxKind,\n+    delim: SyntaxKind,\n+    first_set: TokenSet,\n+    mut parser: impl FnMut(&mut Parser<'_>) -> bool,\n+) {\n+    p.bump(bra);\n+    while !p.at(ket) && !p.at(EOF) {\n+        if !parser(p) {\n+            break;\n+        }\n+        if !p.at(delim) {\n+            if p.at_ts(first_set) {\n+                p.error(format!(\"expected {:?}\", delim));\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(delim);\n+        }\n+    }\n+    p.expect(ket);\n+}"}, {"sha": "4ecaa6e6a85e9a507780f24ebc075947ff0f753f", "filename": "crates/parser/src/grammar/attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1,5 +1,7 @@\n use super::*;\n \n+pub(super) const ATTRIBUTE_FIRST: TokenSet = TokenSet::new(&[T![#]]);\n+\n pub(super) fn inner_attrs(p: &mut Parser<'_>) {\n     while p.at(T![#]) && p.nth(1) == T![!] {\n         attr(p, true);"}, {"sha": "4b080102a2c3de1659e67d51b0ee472c5c770eb0", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1,5 +1,7 @@\n mod atom;\n \n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n pub(crate) use self::atom::{block_expr, match_arm_list};\n@@ -68,6 +70,12 @@ pub(super) fn stmt(p: &mut Parser<'_>, semicolon: Semicolon) {\n         Err(m) => m,\n     };\n \n+    if !p.at_ts(EXPR_FIRST) {\n+        p.err_and_bump(\"expected expression, item or let statement\");\n+        m.abandon(p);\n+        return;\n+    }\n+\n     if let Some((cm, blocklike)) = expr_stmt(p, Some(m)) {\n         if !(p.at(T!['}']) || (semicolon != Semicolon::Required && p.at(EOF))) {\n             // test no_semi_after_block\n@@ -227,6 +235,12 @@ fn expr_bp(\n         attributes::outer_attrs(p);\n         m\n     });\n+\n+    if !p.at_ts(EXPR_FIRST) {\n+        p.err_recover(\"expected expression\", atom::EXPR_RECOVERY_SET);\n+        m.abandon(p);\n+        return None;\n+    }\n     let mut lhs = match lhs(p, r) {\n         Some((lhs, blocklike)) => {\n             let lhs = lhs.extend_to(p, m);\n@@ -551,23 +565,20 @@ fn cast_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     m.complete(p, CAST_EXPR)\n }\n \n+// test_err arg_list_recovery\n+// fn main() {\n+//     foo(bar::);\n+//     foo(bar:);\n+//     foo(bar+);\n+// }\n fn arg_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump(T!['(']);\n-    while !p.at(T![')']) && !p.at(EOF) {\n-        // test arg_with_attr\n-        // fn main() {\n-        //     foo(#[attr] 92)\n-        // }\n-        if !expr(p) {\n-            break;\n-        }\n-        if !p.at(T![')']) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.eat(T![')']);\n+    // test arg_with_attr\n+    // fn main() {\n+    //     foo(#[attr] 92)\n+    // }\n+    delimited(p, T!['('], T![')'], T![,], EXPR_FIRST.union(ATTRIBUTE_FIRST), expr);\n     m.complete(p, ARG_LIST);\n }\n "}, {"sha": "efc2603835e8f4edd524cfb07d720b241081c5da", "filename": "crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -40,26 +40,28 @@ pub(super) const ATOM_EXPR_FIRST: TokenSet =\n         T!['{'],\n         T!['['],\n         T![|],\n-        T![move],\n+        T![async],\n         T![box],\n+        T![break],\n+        T![const],\n+        T![continue],\n+        T![do],\n+        T![for],\n         T![if],\n-        T![while],\n+        T![let],\n+        T![loop],\n         T![match],\n-        T![unsafe],\n+        T![move],\n         T![return],\n-        T![yield],\n-        T![do],\n-        T![break],\n-        T![continue],\n-        T![async],\n+        T![static],\n         T![try],\n-        T![const],\n-        T![loop],\n-        T![for],\n+        T![unsafe],\n+        T![while],\n+        T![yield],\n         LIFETIME_IDENT,\n     ]));\n \n-const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T![let]]);\n+pub(super) const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T![')'], T![']']]);\n \n pub(super) fn atom_expr(\n     p: &mut Parser<'_>,\n@@ -116,7 +118,7 @@ pub(super) fn atom_expr(\n                     // fn main() {\n                     //     'loop: impl\n                     // }\n-                    p.error(\"expected a loop\");\n+                    p.error(\"expected a loop or block\");\n                     m.complete(p, ERROR);\n                     return None;\n                 }\n@@ -157,7 +159,7 @@ pub(super) fn atom_expr(\n         T![for] => for_expr(p, None),\n \n         _ => {\n-            p.err_recover(\"expected expression\", EXPR_RECOVERY_SET);\n+            p.err_and_bump(\"expected expression\");\n             return None;\n         }\n     };"}, {"sha": "919d9b91ebab5dede8a8f5b3fce37348e8874338", "filename": "crates/parser/src/grammar/generic_args.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -5,27 +5,35 @@ pub(super) fn opt_generic_arg_list(p: &mut Parser<'_>, colon_colon_required: boo\n     if p.at(T![::]) && p.nth(2) == T![<] {\n         m = p.start();\n         p.bump(T![::]);\n-        p.bump(T![<]);\n     } else if !colon_colon_required && p.at(T![<]) && p.nth(1) != T![=] {\n         m = p.start();\n-        p.bump(T![<]);\n     } else {\n         return;\n     }\n \n-    while !p.at(EOF) && !p.at(T![>]) {\n-        generic_arg(p);\n-        if !p.at(T![>]) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.expect(T![>]);\n+    delimited(p, T![<], T![>], T![,], GENERIC_ARG_FIRST, generic_arg);\n     m.complete(p, GENERIC_ARG_LIST);\n }\n \n+const GENERIC_ARG_FIRST: TokenSet = TokenSet::new(&[\n+    LIFETIME_IDENT,\n+    IDENT,\n+    T!['{'],\n+    T![true],\n+    T![false],\n+    T![-],\n+    INT_NUMBER,\n+    FLOAT_NUMBER,\n+    CHAR,\n+    BYTE,\n+    STRING,\n+    BYTE_STRING,\n+])\n+.union(types::TYPE_FIRST);\n+\n // test generic_arg\n // type T = S<i32>;\n-fn generic_arg(p: &mut Parser<'_>) {\n+fn generic_arg(p: &mut Parser<'_>) -> bool {\n     match p.current() {\n         LIFETIME_IDENT => lifetime_arg(p),\n         T!['{'] | T![true] | T![false] | T![-] => const_arg(p),\n@@ -68,8 +76,10 @@ fn generic_arg(p: &mut Parser<'_>) {\n                 }\n             }\n         }\n-        _ => type_arg(p),\n+        _ if p.at_ts(types::TYPE_FIRST) => type_arg(p),\n+        _ => return false,\n     }\n+    true\n }\n \n // test lifetime_arg"}, {"sha": "7fcf938babdb1ef22f30bca1dc8674b69f60e592", "filename": "crates/parser/src/grammar/generic_params.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n pub(super) fn opt_generic_param_list(p: &mut Parser<'_>) {\n@@ -11,32 +13,31 @@ pub(super) fn opt_generic_param_list(p: &mut Parser<'_>) {\n fn generic_param_list(p: &mut Parser<'_>) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n-    p.bump(T![<]);\n+    delimited(p, T![<], T![>], T![,], GENERIC_PARAM_FIRST.union(ATTRIBUTE_FIRST), |p| {\n+        // test generic_param_attribute\n+        // fn foo<#[lt_attr] 'a, #[t_attr] T>() {}\n+        let m = p.start();\n+        attributes::outer_attrs(p);\n+        generic_param(p, m)\n+    });\n \n-    while !p.at(EOF) && !p.at(T![>]) {\n-        generic_param(p);\n-        if !p.at(T![>]) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.expect(T![>]);\n     m.complete(p, GENERIC_PARAM_LIST);\n }\n \n-fn generic_param(p: &mut Parser<'_>) {\n-    let m = p.start();\n-    // test generic_param_attribute\n-    // fn foo<#[lt_attr] 'a, #[t_attr] T>() {}\n-    attributes::outer_attrs(p);\n+const GENERIC_PARAM_FIRST: TokenSet = TokenSet::new(&[IDENT, LIFETIME_IDENT, T![const]]);\n+\n+fn generic_param(p: &mut Parser<'_>, m: Marker) -> bool {\n     match p.current() {\n         LIFETIME_IDENT => lifetime_param(p, m),\n         IDENT => type_param(p, m),\n         T![const] => const_param(p, m),\n         _ => {\n             m.abandon(p);\n-            p.err_and_bump(\"expected type parameter\");\n+            p.err_and_bump(\"expected generic parameter\");\n+            return false;\n         }\n     }\n+    true\n }\n \n // test lifetime_param"}, {"sha": "17f41b8e13a40d1c3e88e35724eadce199e652e9", "filename": "crates/parser/src/grammar/items/adt.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n // test struct_item\n@@ -141,28 +143,31 @@ pub(crate) fn record_field_list(p: &mut Parser<'_>) {\n     }\n }\n \n+const TUPLE_FIELD_FIRST: TokenSet =\n+    types::TYPE_FIRST.union(ATTRIBUTE_FIRST).union(VISIBILITY_FIRST);\n+\n fn tuple_field_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump(T!['(']);\n-    while !p.at(T![')']) && !p.at(EOF) {\n+    delimited(p, T!['('], T![')'], T![,], TUPLE_FIELD_FIRST, |p| {\n         let m = p.start();\n         // test tuple_field_attrs\n         // struct S (#[attr] f32);\n         attributes::outer_attrs(p);\n-        opt_visibility(p, true);\n+        let has_vis = opt_visibility(p, true);\n         if !p.at_ts(types::TYPE_FIRST) {\n             p.error(\"expected a type\");\n-            m.complete(p, ERROR);\n-            break;\n+            if has_vis {\n+                m.complete(p, ERROR);\n+            } else {\n+                m.abandon(p);\n+            }\n+            return false;\n         }\n         types::type_(p);\n         m.complete(p, TUPLE_FIELD);\n+        true\n+    });\n \n-        if !p.at(T![')']) {\n-            p.expect(T![,]);\n-        }\n-    }\n-    p.expect(T![')']);\n     m.complete(p, TUPLE_FIELD_LIST);\n }"}, {"sha": "74eae9151a2650cb934ec94e8fbff9d8e378feac", "filename": "crates/parser/src/grammar/params.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n // test param_list\n@@ -66,14 +68,20 @@ fn list_(p: &mut Parser<'_>, flavor: Flavor) {\n             }\n         };\n \n-        if !p.at_ts(PARAM_FIRST) {\n+        if !p.at_ts(PARAM_FIRST.union(ATTRIBUTE_FIRST)) {\n             p.error(\"expected value parameter\");\n             m.abandon(p);\n             break;\n         }\n         param(p, m, flavor);\n-        if !p.at(ket) {\n-            p.expect(T![,]);\n+        if !p.at(T![,]) {\n+            if p.at_ts(PARAM_FIRST.union(ATTRIBUTE_FIRST)) {\n+                p.error(\"expected `,`\");\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(T![,]);\n         }\n     }\n "}, {"sha": "1064ae9970c99cd36b0893d180dec8ceaff02e13", "filename": "crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -67,6 +67,10 @@ fn path_for_qualifier(\n     }\n }\n \n+const EXPR_PATH_SEGMENT_RECOVERY_SET: TokenSet =\n+    items::ITEM_RECOVERY_SET.union(TokenSet::new(&[T![')'], T![,], T![let]]));\n+const TYPE_PATH_SEGMENT_RECOVERY_SET: TokenSet = types::TYPE_RECOVERY_SET;\n+\n fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n     let m = p.start();\n     // test qual_paths\n@@ -102,7 +106,12 @@ fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n                 m.complete(p, NAME_REF);\n             }\n             _ => {\n-                p.err_recover(\"expected identifier\", items::ITEM_RECOVERY_SET);\n+                let recover_set = match mode {\n+                    Mode::Use => items::ITEM_RECOVERY_SET,\n+                    Mode::Type => TYPE_PATH_SEGMENT_RECOVERY_SET,\n+                    Mode::Expr => EXPR_PATH_SEGMENT_RECOVERY_SET,\n+                };\n+                p.err_recover(\"expected identifier\", recover_set);\n                 if empty {\n                     // test_err empty_segment\n                     // use crate::;"}, {"sha": "7d0b156c5a06ae9cc61fe753bf4823e26f404e0e", "filename": "crates/parser/src/grammar/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -17,8 +17,9 @@ pub(super) const TYPE_FIRST: TokenSet = paths::PATH_FIRST.union(TokenSet::new(&[\n     T![Self],\n ]));\n \n-const TYPE_RECOVERY_SET: TokenSet = TokenSet::new(&[\n+pub(super) const TYPE_RECOVERY_SET: TokenSet = TokenSet::new(&[\n     T![')'],\n+    T![>],\n     T![,],\n     // test_err struct_field_recover\n     // struct S { f pub g: () }"}, {"sha": "2fec765bd7871f2c2edc9ce06e54e660c3ce29a1", "filename": "crates/parser/src/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftests.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -15,6 +15,7 @@ use crate::{LexedStr, TopEntryPoint};\n #[test]\n fn lex_ok() {\n     for case in TestCase::list(\"lexer/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let actual = lex(&case.text);\n         expect_file![case.rast].assert_eq(&actual)\n     }\n@@ -23,6 +24,7 @@ fn lex_ok() {\n #[test]\n fn lex_err() {\n     for case in TestCase::list(\"lexer/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let actual = lex(&case.text);\n         expect_file![case.rast].assert_eq(&actual)\n     }\n@@ -46,6 +48,7 @@ fn lex(text: &str) -> String {\n #[test]\n fn parse_ok() {\n     for case in TestCase::list(\"parser/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n@@ -55,6 +58,7 @@ fn parse_ok() {\n #[test]\n fn parse_inline_ok() {\n     for case in TestCase::list(\"parser/inline/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n@@ -64,6 +68,7 @@ fn parse_inline_ok() {\n #[test]\n fn parse_err() {\n     for case in TestCase::list(\"parser/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)\n@@ -73,6 +78,7 @@ fn parse_err() {\n #[test]\n fn parse_inline_err() {\n     for case in TestCase::list(\"parser/inline/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)"}, {"sha": "49dd9e293b8feb1f75ca48333920828ba31b6c40", "filename": "crates/parser/src/tests/top_entries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -65,7 +65,7 @@ fn macro_stmt() {\n             MACRO_STMTS\n               ERROR\n                 SHEBANG \"#!/usr/bin/rust\"\n-            error 0: expected expression\n+            error 0: expected expression, item or let statement\n         \"##]],\n     );\n     check("}, {"sha": "cdc01863ab04cd3e178006865f572fcc66b08416", "filename": "crates/parser/test_data/parser/err/0009_broken_struct_type_parameter.rast", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -44,8 +44,7 @@ SOURCE_FILE\n       IDENT \"T\"\n     SEMICOLON \";\"\n   WHITESPACE \"\\n\"\n-error 9: expected type parameter\n-error 11: expected COMMA\n+error 9: expected generic parameter\n error 11: expected R_ANGLE\n error 11: expected `;`, `{`, or `(`\n error 12: expected an item"}, {"sha": "b485c71ab394f2699599bf8dca47d98f952ce376", "filename": "crates/parser/test_data/parser/err/0013_invalid_type.rast", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -43,17 +43,14 @@ SOURCE_FILE\n                                     IDENT \"Box\"\n                                   GENERIC_ARG_LIST\n                                     L_ANGLE \"<\"\n-                                    TYPE_ARG\n-                                      ERROR\n-                                        AT \"@\"\n-      WHITESPACE \" \"\n-      TUPLE_FIELD\n-        PATH_TYPE\n-          PATH\n-            PATH_SEGMENT\n-              NAME_REF\n-                IDENT \"Any\"\n-      ERROR\n+  ERROR\n+    AT \"@\"\n+  WHITESPACE \" \"\n+  MACRO_CALL\n+    PATH\n+      PATH_SEGMENT\n+        NAME_REF\n+          IDENT \"Any\"\n   ERROR\n     R_ANGLE \">\"\n   ERROR\n@@ -69,17 +66,14 @@ SOURCE_FILE\n   ERROR\n     SEMICOLON \";\"\n   WHITESPACE \"\\n\\n\"\n-error 67: expected type\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 72: expected COMMA\n-error 72: expected a type\n-error 72: expected R_PAREN\n+error 67: expected R_ANGLE\n+error 67: expected R_ANGLE\n+error 67: expected R_ANGLE\n+error 67: expected R_PAREN\n+error 67: expected SEMICOLON\n+error 67: expected an item\n+error 72: expected BANG\n+error 72: expected `{`, `[`, `(`\n error 72: expected SEMICOLON\n error 72: expected an item\n error 73: expected an item"}, {"sha": "d97fc6c72091d8ff88a2aac7799bcfba150c35ce", "filename": "crates/parser/test_data/parser/err/0022_bad_exprs.rast", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -145,27 +145,29 @@ SOURCE_FILE\n error 16: expected expression\n error 17: expected R_BRACK\n error 17: expected SEMICOLON\n-error 17: expected expression\n+error 17: expected expression, item or let statement\n error 25: expected a name\n error 26: expected `;`, `{`, or `(`\n error 30: expected pattern\n error 31: expected SEMICOLON\n error 53: expected expression\n+error 54: expected R_PAREN\n error 54: expected SEMICOLON\n-error 54: expected expression\n+error 54: expected expression, item or let statement\n error 60: expected type\n error 60: expected `{`\n-error 60: expected expression\n+error 60: expected expression, item or let statement\n error 65: expected pattern\n error 65: expected SEMICOLON\n-error 65: expected expression\n+error 65: expected expression, item or let statement\n error 92: expected expression\n+error 93: expected R_PAREN\n error 93: expected SEMICOLON\n-error 93: expected expression\n-error 95: expected expression\n-error 96: expected expression\n+error 93: expected expression, item or let statement\n+error 95: expected expression, item or let statement\n+error 96: expected expression, item or let statement\n error 103: expected a name\n error 104: expected `{`\n error 108: expected pattern\n error 108: expected SEMICOLON\n-error 108: expected expression\n+error 108: expected expression, item or let statement"}, {"sha": "f0dbc9b1027fa9221576974820bd80ebf7cd12f5", "filename": "crates/parser/test_data/parser/err/0024_many_type_parens.rast", "status": "modified", "additions": 98, "deletions": 113, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -168,75 +168,21 @@ SOURCE_FILE\n                       L_PAREN \"(\"\n                       ERROR\n                         QUESTION \"?\"\n-        EXPR_STMT\n-          PATH_EXPR\n-            PATH\n-              PATH_SEGMENT\n-                NAME_REF\n-                  IDENT \"Sized\"\n+                  TYPE_ARG\n+                    PATH_TYPE\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"Sized\"\n         ERROR\n           R_PAREN \")\"\n         WHITESPACE \" \"\n         ERROR\n           PLUS \"+\"\n         WHITESPACE \" \"\n-        TUPLE_EXPR\n-          L_PAREN \"(\"\n-          CLOSURE_EXPR\n-            FOR_KW \"for\"\n-            GENERIC_PARAM_LIST\n-              L_ANGLE \"<\"\n-              LIFETIME_PARAM\n-                LIFETIME\n-                  LIFETIME_IDENT \"'a\"\n-              R_ANGLE \">\"\n-          WHITESPACE \" \"\n-          BIN_EXPR\n-            BIN_EXPR\n-              BIN_EXPR\n-                BIN_EXPR\n-                  PATH_EXPR\n-                    PATH\n-                      PATH_SEGMENT\n-                        NAME_REF\n-                          IDENT \"Trait\"\n-                  L_ANGLE \"<\"\n-                  ERROR\n-                    LIFETIME_IDENT \"'a\"\n-                R_ANGLE \">\"\n-                ERROR\n-                  R_PAREN \")\"\n-              WHITESPACE \" \"\n-              PLUS \"+\"\n-              WHITESPACE \" \"\n-              PAREN_EXPR\n-                L_PAREN \"(\"\n-                PATH_EXPR\n-                  PATH\n-                    PATH_SEGMENT\n-                      NAME_REF\n-                        IDENT \"Copy\"\n-                R_PAREN \")\"\n-            R_ANGLE \">\"\n-            ERROR\n-              SEMICOLON \";\"\n-          WHITESPACE \"\\n    \"\n-          LET_EXPR\n-            LET_KW \"let\"\n-            WHITESPACE \" \"\n-            WILDCARD_PAT\n-              UNDERSCORE \"_\"\n-            ERROR\n-              COLON \":\"\n-          WHITESPACE \" \"\n+        EXPR_STMT\n           BIN_EXPR\n             BIN_EXPR\n-              PATH_EXPR\n-                PATH\n-                  PATH_SEGMENT\n-                    NAME_REF\n-                      IDENT \"Box\"\n-              L_ANGLE \"<\"\n               TUPLE_EXPR\n                 L_PAREN \"(\"\n                 CLOSURE_EXPR\n@@ -250,78 +196,117 @@ SOURCE_FILE\n                 WHITESPACE \" \"\n                 BIN_EXPR\n                   BIN_EXPR\n-                    BIN_EXPR\n-                      BIN_EXPR\n-                        PATH_EXPR\n-                          PATH\n-                            PATH_SEGMENT\n-                              NAME_REF\n-                                IDENT \"Trait\"\n-                        L_ANGLE \"<\"\n-                        ERROR\n-                          LIFETIME_IDENT \"'a\"\n-                      R_ANGLE \">\"\n-                      ERROR\n-                        R_PAREN \")\"\n-                    WHITESPACE \" \"\n-                    PLUS \"+\"\n-                    WHITESPACE \" \"\n-                    PAREN_EXPR\n-                      L_PAREN \"(\"\n-                      PATH_EXPR\n-                        PATH\n-                          PATH_SEGMENT\n-                            NAME_REF\n-                              IDENT \"Copy\"\n-                      R_PAREN \")\"\n-                  WHITESPACE \" \"\n-                  PLUS \"+\"\n-                  WHITESPACE \" \"\n-                  PAREN_EXPR\n-                    L_PAREN \"(\"\n+                    PATH_EXPR\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"Trait\"\n+                    L_ANGLE \"<\"\n                     ERROR\n-                      QUESTION \"?\"\n+                      LIFETIME_IDENT \"'a\"\n+                  R_ANGLE \">\"\n+                R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              PAREN_EXPR\n+                L_PAREN \"(\"\n                 PATH_EXPR\n                   PATH\n                     PATH_SEGMENT\n                       NAME_REF\n-                        IDENT \"Sized\"\n+                        IDENT \"Copy\"\n                 R_PAREN \")\"\n             R_ANGLE \">\"\n             ERROR\n               SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          WILDCARD_PAT\n+            UNDERSCORE \"_\"\n+          COLON \":\"\n+          WHITESPACE \" \"\n+          DYN_TRAIT_TYPE\n+            TYPE_BOUND_LIST\n+              TYPE_BOUND\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Box\"\n+                      GENERIC_ARG_LIST\n+                        L_ANGLE \"<\"\n+                        TYPE_ARG\n+                          PAREN_TYPE\n+                            L_PAREN \"(\"\n+                            FOR_TYPE\n+                              FOR_KW \"for\"\n+                              GENERIC_PARAM_LIST\n+                                L_ANGLE \"<\"\n+                                LIFETIME_PARAM\n+                                  LIFETIME\n+                                    LIFETIME_IDENT \"'a\"\n+                                R_ANGLE \">\"\n+                              WHITESPACE \" \"\n+                              PATH_TYPE\n+                                PATH\n+                                  PATH_SEGMENT\n+                                    NAME_REF\n+                                      IDENT \"Trait\"\n+                                    GENERIC_ARG_LIST\n+                                      L_ANGLE \"<\"\n+                                      LIFETIME_ARG\n+                                        LIFETIME\n+                                          LIFETIME_IDENT \"'a\"\n+                                      R_ANGLE \">\"\n+                            R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              TYPE_BOUND\n+                L_PAREN \"(\"\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Copy\"\n+                R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              TYPE_BOUND\n+                L_PAREN \"(\"\n+                QUESTION \"?\"\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Sized\"\n+                R_PAREN \")\"\n+        ERROR\n+          R_ANGLE \">\"\n+        SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n-error 88: expected COMMA\n error 88: expected R_ANGLE\n error 121: expected SEMICOLON\n-error 121: expected expression\n+error 121: expected expression, item or let statement\n error 140: expected type\n error 141: expected R_PAREN\n error 141: expected COMMA\n-error 141: expected R_ANGLE\n-error 141: expected SEMICOLON\n+error 146: expected R_ANGLE\n error 146: expected SEMICOLON\n-error 146: expected expression\n-error 148: expected expression\n+error 146: expected expression, item or let statement\n+error 148: expected expression, item or let statement\n error 158: expected `|`\n error 158: expected COMMA\n error 165: expected expression\n error 168: expected expression\n error 179: expected expression\n-error 180: expected COMMA\n-error 190: expected EQ\n-error 190: expected expression\n-error 191: expected COMMA\n-error 204: expected `|`\n-error 204: expected COMMA\n-error 211: expected expression\n-error 214: expected expression\n-error 228: expected expression\n-error 229: expected R_PAREN\n-error 229: expected COMMA\n-error 236: expected expression\n-error 237: expected COMMA\n-error 237: expected expression\n-error 237: expected R_PAREN\n+error 180: expected SEMICOLON\n+error 215: expected R_ANGLE\n+error 235: expected SEMICOLON\n+error 235: expected expression, item or let statement"}, {"sha": "b6bc0088374fb8860fdb08064963877993c932ca", "filename": "crates/parser/test_data/parser/err/0025_nope.rast", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -156,8 +156,7 @@ SOURCE_FILE\n                             PATH_SEGMENT\n                               NAME_REF\n                                 IDENT \"i32\"\n-                      WHITESPACE \" \"\n-                      ERROR\n+                  WHITESPACE \" \"\n                   ERROR\n                     L_CURLY \"{\"\n                     R_CURLY \"}\"\n@@ -199,10 +198,8 @@ error 95: expected type\n error 95: expected COMMA\n error 96: expected field\n error 98: expected field declaration\n+error 371: expected R_PAREN\n error 371: expected COMMA\n-error 372: expected a type\n-error 372: expected R_PAREN\n-error 372: expected COMMA\n error 372: expected enum variant\n error 374: expected enum variant\n error 494: expected pattern"}, {"sha": "1cdc6e6e7192736c39e4e56ea6d69fe2dd2ed121", "filename": "crates/parser/test_data/parser/err/0042_weird_blocks.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -72,4 +72,4 @@ SOURCE_FILE\n error 24: expected existential, fn, trait or impl\n error 41: expected existential, fn, trait or impl\n error 56: expected a block\n-error 75: expected a loop\n+error 75: expected a loop or block"}, {"sha": "207a5c24dffd4840cdfcb6a721faf7aa974923f7", "filename": "crates/parser/test_data/parser/err/0048_double_fish.rast", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -12,7 +12,7 @@ SOURCE_FILE\n       STMT_LIST\n         L_CURLY \"{\"\n         WHITESPACE \"\\n    \"\n-        EXPR_STMT\n+        BIN_EXPR\n           PATH_EXPR\n             PATH\n               PATH_SEGMENT\n@@ -41,13 +41,14 @@ SOURCE_FILE\n                         COLON2 \"::\"\n                         ERROR\n                           L_ANGLE \"<\"\n-        BIN_EXPR\n-          PATH_EXPR\n-            PATH\n-              PATH_SEGMENT\n-                NAME_REF\n-                  IDENT \"nope\"\n-          SHR \">>\"\n+                  TYPE_ARG\n+                    PATH_TYPE\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"nope\"\n+                  R_ANGLE \">\"\n+          R_ANGLE \">\"\n           ERROR\n             SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n@@ -114,8 +115,6 @@ SOURCE_FILE\n   WHITESPACE \"\\n\"\n error 30: expected identifier\n error 31: expected COMMA\n-error 31: expected R_ANGLE\n-error 31: expected SEMICOLON\n error 37: expected expression\n error 75: expected identifier\n error 76: expected SEMICOLON"}, {"sha": "ea5203fb96e00bdc8abd84730af2f941176e947f", "filename": "crates/parser/test_data/parser/inline/err/0002_misplaced_label_err.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -23,6 +23,6 @@ SOURCE_FILE\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n-error 22: expected a loop\n+error 22: expected a loop or block\n error 27: expected type\n error 27: expected `{`"}, {"sha": "5d0fe859c2965290238f1b16d5586b981ba4d646", "filename": "crates/parser/test_data/parser/inline/err/0015_arg_list_recovery.rast", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -0,0 +1,77 @@\n+SOURCE_FILE\n+  FN\n+    FN_KW \"fn\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"main\"\n+    PARAM_LIST\n+      L_PAREN \"(\"\n+      R_PAREN \")\"\n+    WHITESPACE \" \"\n+    BLOCK_EXPR\n+      STMT_LIST\n+        L_CURLY \"{\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              PATH_EXPR\n+                PATH\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"bar\"\n+                  COLON2 \"::\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              PATH_EXPR\n+                PATH\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"bar\"\n+              ERROR\n+                COLON \":\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              BIN_EXPR\n+                PATH_EXPR\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"bar\"\n+                PLUS \"+\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n\"\n+        R_CURLY \"}\"\n+  WHITESPACE \"\\n\"\n+error 25: expected identifier\n+error 39: expected COMMA\n+error 39: expected expression\n+error 55: expected expression"}, {"sha": "0e7ac9cc3075533cb4836f00fafd6a4230ae066a", "filename": "crates/parser/test_data/parser/inline/err/0015_arg_list_recovery.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    foo(bar::);\n+    foo(bar:);\n+    foo(bar+);\n+}"}, {"sha": "ea50ad35d74db1f480aad1619dcd450ce43beaf5", "filename": "crates/parser/test_data/parser/inline/err/0015_missing_fn_param_type.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/44568007d1f3d51b84ad58d2ddeda2badd3aeea5/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast?ref=44568007d1f3d51b84ad58d2ddeda2badd3aeea5", "patch": "@@ -49,5 +49,5 @@ SOURCE_FILE\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n error 6: missing type for function parameter\n-error 6: expected COMMA\n+error 6: expected `,`\n error 16: missing type for function parameter"}]}