{"sha": "ac60872077608c4382aab39495e15c9f226630dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNjA4NzIwNzc2MDhjNDM4MmFhYjM5NDk1ZTE1YzlmMjI2NjMwZGQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-04T23:21:10Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:33Z"}, "message": "rustc_trans: generate LLVM pointee types based on alignment.", "tree": {"sha": "1caebac5b5d46ed3c4723cf27c8bfd6f53518292", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1caebac5b5d46ed3c4723cf27c8bfd6f53518292"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac60872077608c4382aab39495e15c9f226630dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac60872077608c4382aab39495e15c9f226630dd", "html_url": "https://github.com/rust-lang/rust/commit/ac60872077608c4382aab39495e15c9f226630dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac60872077608c4382aab39495e15c9f226630dd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8d5d0c30c32c20163e45c3c1521add198b63afc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d5d0c30c32c20163e45c3c1521add198b63afc", "html_url": "https://github.com/rust-lang/rust/commit/f8d5d0c30c32c20163e45c3c1521add198b63afc"}], "stats": {"total": 264, "additions": 191, "deletions": 73}, "files": [{"sha": "54e648c6d4a575c9422c7935a1675b4f50172be5", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 24, "deletions": 70, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=ac60872077608c4382aab39495e15c9f226630dd", "patch": "@@ -32,13 +32,11 @@ use cabi_nvptx64;\n use cabi_hexagon;\n use mir::lvalue::LvalueRef;\n use type_::Type;\n-use type_of::LayoutLlvmExt;\n+use type_of::{LayoutLlvmExt, PointerKind};\n \n-use rustc::hir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, Size, TyLayout};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n-use rustc_back::PanicStrategy;\n \n use libc::c_uint;\n use std::{cmp, iter};\n@@ -514,22 +512,6 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         self.kind = ArgKind::Ignore;\n     }\n \n-    fn safe_pointee(&mut self, layout: TyLayout) {\n-        match self.layout.abi {\n-            layout::Abi::Scalar(layout::Scalar {\n-                value: layout::Pointer,\n-                ref valid_range\n-            }) => {\n-                if valid_range.start > 0 {\n-                    self.attrs.set(ArgAttribute::NonNull);\n-                }\n-                self.attrs.pointee_size = layout.size;\n-                self.attrs.pointee_align = Some(layout.align);\n-            }\n-            _ => bug!(\"ArgType::safe_pointee({:#?}): not a pointer\", self.layout)\n-        }\n-    }\n-\n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n         if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n@@ -754,78 +736,50 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n         // Handle safe Rust thin and fat pointers.\n         let adjust_for_rust_type = |arg: &mut ArgType<'tcx>, is_return: bool| {\n-            // We only handle thin pointers here.\n             match arg.layout.abi {\n-                layout::Abi::Scalar(layout::Scalar { value: layout::Pointer, .. }) => {}\n-                _ => return\n-            }\n-\n-            let mut ty = arg.layout.ty;\n-\n-            // FIXME(eddyb) detect more nested cases than `Option<&T>` here.\n-            match arg.layout.variants {\n-                layout::Variants::NicheFilling { dataful_variant, .. } => {\n-                    let variant = arg.layout.for_variant(ccx, dataful_variant);\n-                    for i in 0..variant.fields.count() {\n-                        let field = variant.field(ccx, i);\n-                        match field.abi {\n-                            layout::Abi::Scalar(layout::Scalar { value: layout::Pointer, .. }) => {\n-                                // We found the pointer field, use its type.\n-                                ty = field.ty;\n-                                break;\n-                            }\n-                            _ => {}\n-                        }\n+                layout::Abi::Scalar(layout::Scalar {\n+                    value: layout::Pointer,\n+                    ref valid_range\n+                }) => {\n+                    if valid_range.start > 0 && valid_range.start < valid_range.end {\n+                        arg.attrs.set(ArgAttribute::NonNull);\n                     }\n                 }\n                 _ => {}\n             }\n \n-            match ty.sty {\n-                // `Box` pointer parameters never alias because ownership is transferred\n-                ty::TyAdt(def, _) if def.is_box() => {\n-                    arg.attrs.set(ArgAttribute::NoAlias);\n+            if let Some(pointee) = arg.layout.pointee_info(ccx) {\n+                if let Some(kind) = pointee.safe {\n+                    arg.attrs.pointee_size = pointee.size;\n+                    arg.attrs.pointee_align = Some(pointee.align);\n \n-                    arg.safe_pointee(ccx.layout_of(ty.boxed_ty()));\n-                }\n+                    // HACK(eddyb) LLVM inserts `llvm.assume` calls when inlining functions\n+                    // with align attributes, and those calls later block optimizations.\n+                    if !is_return {\n+                        arg.attrs.pointee_align = None;\n+                    }\n \n-                ty::TyRef(_, mt) => {\n+                    // `Box` pointer parameters never alias because ownership is transferred\n                     // `&mut` pointer parameters never alias other parameters,\n                     // or mutable global data\n                     //\n                     // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n                     // and can be marked as both `readonly` and `noalias`, as\n                     // LLVM's definition of `noalias` is based solely on memory\n                     // dependencies rather than pointer equality\n-                    let is_freeze = ccx.shared().type_is_freeze(mt.ty);\n-\n-                    let no_alias_is_safe =\n-                        if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n-                           ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n-                            // Mutable refrences or immutable shared references\n-                            mt.mutbl == hir::MutMutable || is_freeze\n-                        } else {\n-                            // Only immutable shared references\n-                            mt.mutbl != hir::MutMutable && is_freeze\n-                        };\n-\n-                    if no_alias_is_safe {\n+                    let no_alias = match kind {\n+                        PointerKind::Shared => false,\n+                        PointerKind::Frozen | PointerKind::UniqueOwned => true,\n+                        PointerKind::UniqueBorrowed => !is_return\n+                    };\n+                    if no_alias {\n                         arg.attrs.set(ArgAttribute::NoAlias);\n                     }\n \n-                    if mt.mutbl == hir::MutImmutable && is_freeze && !is_return {\n+                    if kind == PointerKind::Frozen && !is_return {\n                         arg.attrs.set(ArgAttribute::ReadOnly);\n                     }\n-\n-                    arg.safe_pointee(ccx.layout_of(mt.ty));\n                 }\n-                _ => {}\n-            }\n-\n-            // HACK(eddyb) LLVM inserts `llvm.assume` calls when inlining functions\n-            // with align attributes, and those calls later block optimizations.\n-            if !is_return {\n-                arg.attrs.pointee_align = None;\n             }\n         };\n "}, {"sha": "d768b14a82efda10608da2972af58ca1706723f7", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=ac60872077608c4382aab39495e15c9f226630dd", "patch": "@@ -24,6 +24,7 @@ use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n use type_::Type;\n+use type_of::PointeeInfo;\n \n use rustc_data_structures::base_n;\n use rustc::middle::trans::Stats;\n@@ -102,6 +103,7 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n \n     lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n     scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    pointee_infos: RefCell<FxHashMap<Ty<'tcx>, Option<PointeeInfo>>>,\n     isize_ty: Type,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n@@ -378,6 +380,7 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n                 scalar_lltypes: RefCell::new(FxHashMap()),\n+                pointee_infos: RefCell::new(FxHashMap()),\n                 isize_ty: Type::from_ref(ptr::null_mut()),\n                 dbg_cx,\n                 eh_personality: Cell::new(None),\n@@ -513,6 +516,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().scalar_lltypes\n     }\n \n+    pub fn pointee_infos<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Option<PointeeInfo>>> {\n+        &self.local().pointee_infos\n+    }\n+\n     pub fn stats<'a>(&'a self) -> &'a RefCell<Stats> {\n         &self.local().stats\n     }"}, {"sha": "02224858b4692acb515d90e186cf794d0da1fc2b", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=ac60872077608c4382aab39495e15c9f226630dd", "patch": "@@ -17,7 +17,7 @@ use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n use context::CrateContext;\n \n use syntax::ast;\n-use rustc::ty::layout;\n+use rustc::ty::layout::{self, Align};\n \n use std::ffi::CString;\n use std::fmt;\n@@ -275,4 +275,15 @@ impl Type {\n             I128 => Type::i128(cx),\n         }\n     }\n+\n+    /// Return a LLVM type that has at most the required alignment,\n+    /// as a conservative approximation for unknown pointee types.\n+    pub fn pointee_for_abi_align(ccx: &CrateContext, align: Align) -> Type {\n+        if let Some(ity) = layout::Integer::for_abi_align(ccx, align) {\n+            Type::from_integer(ccx, ity)\n+        } else {\n+            // FIXME(eddyb) We could find a better approximation here.\n+            Type::i8(ccx)\n+        }\n+    }\n }"}, {"sha": "529ad51ba8ea3a6676cb4a8fd6b133da26da5782", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 148, "deletions": 2, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac60872077608c4382aab39495e15c9f226630dd/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=ac60872077608c4382aab39495e15c9f226630dd", "patch": "@@ -10,8 +10,10 @@\n \n use abi::FnType;\n use common::*;\n+use rustc::hir;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, HasDataLayout, Align, LayoutOf, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n+use rustc_back::PanicStrategy;\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n@@ -148,12 +150,35 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum PointerKind {\n+    /// Most general case, we know no restrictions to tell LLVM.\n+    Shared,\n+\n+    /// `&T` where `T` contains no `UnsafeCell`, is `noalias` and `readonly`.\n+    Frozen,\n+\n+    /// `&mut T`, when we know `noalias` is safe for LLVM.\n+    UniqueBorrowed,\n+\n+    /// `Box<T>`, unlike `UniqueBorrowed`, it also has `noalias` on returns.\n+    UniqueOwned\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PointeeInfo {\n+    pub size: Size,\n+    pub align: Align,\n+    pub safe: Option<PointerKind>,\n+}\n+\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn over_align(&self) -> Option<Align>;\n     fn llvm_field_index(&self, index: usize) -> u64;\n+    fn pointee_info<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<PointeeInfo>;\n }\n \n impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n@@ -202,7 +227,14 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                             let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                             FnType::new(ccx, sig, &[]).llvm_type(ccx)\n                         }\n-                        _ => Type::i8(ccx)\n+                        _ => {\n+                            // If we know the alignment, pick something better than i8.\n+                            if let Some(pointee) = self.pointee_info(ccx) {\n+                                Type::pointee_for_abi_align(ccx, pointee.align)\n+                            } else {\n+                                Type::i8(ccx)\n+                            }\n+                        }\n                     };\n                     pointee.ptr_to()\n                 }\n@@ -285,4 +317,118 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n         }\n     }\n+\n+    fn pointee_info<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<PointeeInfo> {\n+        // We only handle thin pointers here.\n+        match self.abi {\n+            layout::Abi::Scalar(layout::Scalar { value: layout::Pointer, .. }) => {}\n+            _ => return None\n+        }\n+\n+        if let Some(&pointee) = ccx.pointee_infos().borrow().get(&self.ty) {\n+            return pointee;\n+        }\n+\n+        let mut result = None;\n+        match self.ty.sty {\n+            ty::TyRawPtr(mt) => {\n+                let (size, align) = ccx.size_and_align_of(mt.ty);\n+                result = Some(PointeeInfo {\n+                    size,\n+                    align,\n+                    safe: None\n+                });\n+            }\n+\n+            ty::TyRef(_, mt) => {\n+                let (size, align) = ccx.size_and_align_of(mt.ty);\n+\n+                let kind = match mt.mutbl {\n+                    hir::MutImmutable => if ccx.shared().type_is_freeze(mt.ty) {\n+                        PointerKind::Frozen\n+                    } else {\n+                        PointerKind::Shared\n+                    },\n+                    hir::MutMutable => {\n+                        if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n+                           ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n+                            PointerKind::UniqueBorrowed\n+                        } else {\n+                            PointerKind::Shared\n+                        }\n+                    }\n+                };\n+\n+                result = Some(PointeeInfo {\n+                    size,\n+                    align,\n+                    safe: Some(kind)\n+                });\n+            }\n+\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                let (size, align) = ccx.size_and_align_of(self.ty.boxed_ty());\n+                result = Some(PointeeInfo {\n+                    size,\n+                    align,\n+                    safe: Some(PointerKind::UniqueOwned)\n+                });\n+            }\n+\n+            _ => {\n+                let mut data_variant = match self.variants {\n+                    layout::Variants::NicheFilling { dataful_variant, .. } => {\n+                        // Only the niche itself is always initialized,\n+                        // so only check for a pointer at its offset.\n+                        //\n+                        // If the niche is a pointer, it's either valid\n+                        // (according to its type), or null (which the\n+                        // niche field's scalar validity range encodes).\n+                        // This allows using `dereferenceable_or_null`\n+                        // for e.g. `Option<&T>`, and this will continue\n+                        // to work as long as we don't start using more\n+                        // niches than just null (e.g. the first page\n+                        // of the address space, or unaligned pointers).\n+                        if self.fields.offset(0).bytes() == 0 {\n+                            Some(self.for_variant(ccx, dataful_variant))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => Some(*self)\n+                };\n+\n+                if let Some(variant) = data_variant {\n+                    // We're not interested in any unions.\n+                    if let layout::FieldPlacement::Union(_) = variant.fields {\n+                        data_variant = None;\n+                    }\n+                }\n+\n+                if let Some(variant) = data_variant {\n+                    for i in 0..variant.fields.count() {\n+                        let field = variant.field(ccx, i);\n+                        if field.size == self.size {\n+                            // We found the pointer field, use its information.\n+                            result = field.pointee_info(ccx);\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                if let ty::TyAdt(def, _) = self.ty.sty {\n+                    if Some(def.did) == ccx.tcx().lang_items().non_zero() {\n+                        // FIXME(eddyb) Don't treat NonZero<*T> as\n+                        // as containing &T in ty::layout.\n+                        if let Some(ref mut pointee) = result {\n+                            pointee.safe = None;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        ccx.pointee_infos().borrow_mut().insert(self.ty, result);\n+        result\n+    }\n }"}]}