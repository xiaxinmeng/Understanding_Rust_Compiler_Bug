{"sha": "af7c0303105fd84cb6a83c4fe69c26cd9da75157", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmN2MwMzAzMTA1ZmQ4NGNiNmE4M2M0ZmU2OWMyNmNkOWRhNzUxNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-30T05:56:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-30T05:56:44Z"}, "message": "auto merge of #14511 : Sawyer47/rust/osrng-rename, r=alexcrichton\n\nAccording to Rust's style guide acronyms in type names should be\r\nCamelCase.\r\n\r\n[breaking-change]", "tree": {"sha": "748a9b7444542cbf2a7c65ef233e17e16448f6b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748a9b7444542cbf2a7c65ef233e17e16448f6b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af7c0303105fd84cb6a83c4fe69c26cd9da75157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af7c0303105fd84cb6a83c4fe69c26cd9da75157", "html_url": "https://github.com/rust-lang/rust/commit/af7c0303105fd84cb6a83c4fe69c26cd9da75157", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af7c0303105fd84cb6a83c4fe69c26cd9da75157/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0b0f16c3f28577cdbe9c090a016e2d117efe9f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0b0f16c3f28577cdbe9c090a016e2d117efe9f0", "html_url": "https://github.com/rust-lang/rust/commit/d0b0f16c3f28577cdbe9c090a016e2d117efe9f0"}, {"sha": "aa7b215f04962b307b86b2160da4899a64ea35a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa7b215f04962b307b86b2160da4899a64ea35a0", "html_url": "https://github.com/rust-lang/rust/commit/aa7b215f04962b307b86b2160da4899a64ea35a0"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "6dc6ccb79018061f1e1e394ef3323b844cfb6855", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=af7c0303105fd84cb6a83c4fe69c26cd9da75157", "patch": "@@ -977,8 +977,8 @@ impl ClosureConverter for UnsafeTaskReceiver {\n // worry there.\n #[cfg(windows)]\n fn new_sched_rng() -> XorShiftRng {\n-    use std::rand::OSRng;\n-    match OSRng::new() {\n+    use std::rand::OsRng;\n+    match OsRng::new() {\n         Ok(mut r) => r.gen(),\n         Err(e) => {\n             rtabort!(\"sched: failed to create seeded RNG: {}\", e)"}, {"sha": "83b86e1e15804674854b1b0268291cb9e6ef74da", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=af7c0303105fd84cb6a83c4fe69c26cd9da75157", "patch": "@@ -24,7 +24,7 @@ static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n ///\n /// The ISAAC algorithm is generally accepted as suitable for\n /// cryptographic purposes, but this implementation has not be\n-/// verified as such. Prefer a generator like `OSRng` that defers to\n+/// verified as such. Prefer a generator like `OsRng` that defers to\n /// the operating system for cases that need high security.\n ///\n /// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number\n@@ -231,7 +231,7 @@ static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n ///\n /// The ISAAC algorithm is generally accepted as suitable for\n /// cryptographic purposes, but this implementation has not be\n-/// verified as such. Prefer a generator like `OSRng` that defers to\n+/// verified as such. Prefer a generator like `OsRng` that defers to\n /// the operating system for cases that need high security.\n ///\n /// [1]: Bob Jenkins, [*ISAAC: A fast cryptographic random number"}, {"sha": "353ac4cfed1af357c4a03cf1753369400c6dc91a", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=af7c0303105fd84cb6a83c4fe69c26cd9da75157", "patch": "@@ -333,7 +333,7 @@ pub trait SeedableRng<Seed>: Rng {\n ///\n /// The Xorshift algorithm is not suitable for cryptographic purposes\n /// but is very fast. If you do not know for sure that it fits your\n-/// requirements, use a more secure one such as `IsaacRng` or `OSRng`.\n+/// requirements, use a more secure one such as `IsaacRng` or `OsRng`.\n ///\n /// [1]: Marsaglia, George (July 2003). [\"Xorshift\n /// RNGs\"](http://www.jstatsoft.org/v08/i14/paper). *Journal of"}, {"sha": "61a2ffd383d0a9869b1b36b3957957380524333e", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=af7c0303105fd84cb6a83c4fe69c26cd9da75157", "patch": "@@ -32,7 +32,7 @@ after generating 32 KiB of random data.\n # Cryptographic security\n \n An application that requires an entropy source for cryptographic purposes\n-must use `OSRng`, which reads randomness from the source that the operating\n+must use `OsRng`, which reads randomness from the source that the operating\n system provides (e.g. `/dev/urandom` on Unixes or `CryptGenRandom()` on Windows).\n The other random number generators provided by this module are not suitable\n for such purposes.\n@@ -91,7 +91,7 @@ use IsaacWordRng = core_rand::Isaac64Rng;\n pub use core_rand::{Rand, Rng, SeedableRng, Open01, Closed01};\n pub use core_rand::{XorShiftRng, IsaacRng, Isaac64Rng};\n pub use core_rand::{distributions, reseeding};\n-pub use rand::os::OSRng;\n+pub use rand::os::OsRng;\n \n pub mod os;\n pub mod reader;\n@@ -113,7 +113,7 @@ impl StdRng {\n     /// Reading the randomness from the OS may fail, and any error is\n     /// propagated via the `IoResult` return value.\n     pub fn new() -> IoResult<StdRng> {\n-        OSRng::new().map(|mut r| StdRng { rng: r.gen() })\n+        OsRng::new().map(|mut r| StdRng { rng: r.gen() })\n     }\n }\n \n@@ -151,7 +151,7 @@ impl<'a> SeedableRng<&'a [uint]> for StdRng {\n /// This will read randomness from the operating system to seed the\n /// generator.\n pub fn weak_rng() -> XorShiftRng {\n-    match OSRng::new() {\n+    match OsRng::new() {\n         Ok(mut r) => r.gen(),\n         Err(e) => fail!(\"weak_rng: failed to create seeded RNG: {}\", e)\n     }\n@@ -467,12 +467,12 @@ mod bench {\n \n     use self::test::Bencher;\n     use super::{XorShiftRng, StdRng, IsaacRng, Isaac64Rng, Rng, RAND_BENCH_N};\n-    use super::{OSRng, weak_rng};\n+    use super::{OsRng, weak_rng};\n     use mem::size_of;\n \n     #[bench]\n     fn rand_xorshift(b: &mut Bencher) {\n-        let mut rng: XorShiftRng = OSRng::new().unwrap().gen();\n+        let mut rng: XorShiftRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n@@ -483,7 +483,7 @@ mod bench {\n \n     #[bench]\n     fn rand_isaac(b: &mut Bencher) {\n-        let mut rng: IsaacRng = OSRng::new().unwrap().gen();\n+        let mut rng: IsaacRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n@@ -494,7 +494,7 @@ mod bench {\n \n     #[bench]\n     fn rand_isaac64(b: &mut Bencher) {\n-        let mut rng: Isaac64Rng = OSRng::new().unwrap().gen();\n+        let mut rng: Isaac64Rng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();"}, {"sha": "3a6c0124ee09d0d7ffe9081d7f51f2b1a551d81b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af7c0303105fd84cb6a83c4fe69c26cd9da75157/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=af7c0303105fd84cb6a83c4fe69c26cd9da75157", "patch": "@@ -11,7 +11,7 @@\n //! Interfaces to the operating system provided random number\n //! generators.\n \n-pub use self::imp::OSRng;\n+pub use self::imp::OsRng;\n \n #[cfg(unix)]\n mod imp {\n@@ -31,21 +31,21 @@ mod imp {\n     ///\n     /// This does not block.\n     #[cfg(unix)]\n-    pub struct OSRng {\n+    pub struct OsRng {\n         inner: ReaderRng<File>\n     }\n \n-    impl OSRng {\n-        /// Create a new `OSRng`.\n-        pub fn new() -> IoResult<OSRng> {\n+    impl OsRng {\n+        /// Create a new `OsRng`.\n+        pub fn new() -> IoResult<OsRng> {\n             let reader = try!(File::open(&Path::new(\"/dev/urandom\")));\n             let reader_rng = ReaderRng::new(reader);\n \n-            Ok(OSRng { inner: reader_rng })\n+            Ok(OsRng { inner: reader_rng })\n         }\n     }\n \n-    impl Rng for OSRng {\n+    impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n             self.inner.next_u32()\n         }\n@@ -84,7 +84,7 @@ mod imp {\n     ///   service provider with the `PROV_RSA_FULL` type.\n     ///\n     /// This does not block.\n-    pub struct OSRng {\n+    pub struct OsRng {\n         hcryptprov: HCRYPTPROV\n     }\n \n@@ -105,9 +105,9 @@ mod imp {\n         fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;\n     }\n \n-    impl OSRng {\n-        /// Create a new `OSRng`.\n-        pub fn new() -> IoResult<OSRng> {\n+    impl OsRng {\n+        /// Create a new `OsRng`.\n+        pub fn new() -> IoResult<OsRng> {\n             let mut hcp = 0;\n             let mut ret = unsafe {\n                 CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n@@ -154,12 +154,12 @@ mod imp {\n             if ret == 0 {\n                 Err(IoError::last_error())\n             } else {\n-                Ok(OSRng { hcryptprov: hcp })\n+                Ok(OsRng { hcryptprov: hcp })\n             }\n         }\n     }\n \n-    impl Rng for OSRng {\n+    impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n             let mut v = [0u8, .. 4];\n             self.fill_bytes(v);\n@@ -181,7 +181,7 @@ mod imp {\n         }\n     }\n \n-    impl Drop for OSRng {\n+    impl Drop for OsRng {\n         fn drop(&mut self) {\n             let ret = unsafe {\n                 CryptReleaseContext(self.hcryptprov, 0)\n@@ -197,13 +197,13 @@ mod imp {\n mod test {\n     use prelude::*;\n \n-    use super::OSRng;\n+    use super::OsRng;\n     use rand::Rng;\n     use task;\n \n     #[test]\n     fn test_os_rng() {\n-        let mut r = OSRng::new().unwrap();\n+        let mut r = OsRng::new().unwrap();\n \n         r.next_u32();\n         r.next_u64();\n@@ -225,7 +225,7 @@ mod test {\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n-                let mut r = OSRng::new().unwrap();\n+                let mut r = OsRng::new().unwrap();\n                 task::deschedule();\n                 let mut v = [0u8, .. 1000];\n "}]}