{"sha": "9836742d6a5bd610074d2d944d472b0dfed3991b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MzY3NDJkNmE1YmQ2MTAwNzRkMmQ5NDRkNDcyYjBkZmVkMzk5MWI=", "commit": {"author": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2015-01-29T12:41:48Z"}, "committer": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2015-01-30T04:22:19Z"}, "message": "Add a few missing stability markers.", "tree": {"sha": "075af61f6d06959326449dd896048a200a39303c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/075af61f6d06959326449dd896048a200a39303c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9836742d6a5bd610074d2d944d472b0dfed3991b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9836742d6a5bd610074d2d944d472b0dfed3991b", "html_url": "https://github.com/rust-lang/rust/commit/9836742d6a5bd610074d2d944d472b0dfed3991b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9836742d6a5bd610074d2d944d472b0dfed3991b/comments", "author": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52c74e63dacd49017b19330e0cbecbac0a3fe62e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c74e63dacd49017b19330e0cbecbac0a3fe62e", "html_url": "https://github.com/rust-lang/rust/commit/52c74e63dacd49017b19330e0cbecbac0a3fe62e"}], "stats": {"total": 38, "additions": 38, "deletions": 0}, "files": [{"sha": "945dd8bb8e6221494cf587777d7858abb2644ef8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9836742d6a5bd610074d2d944d472b0dfed3991b", "patch": "@@ -46,6 +46,7 @@ use super::table::BucketState::{\n use super::state::HashState;\n \n const INITIAL_LOG2_CAP: uint = 5;\n+#[unstable(feature = \"std_misc\")]\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n \n /// The default behavior of HashMap implements a load factor of 90.9%.\n@@ -1596,6 +1597,8 @@ impl Default for RandomState {\n /// typically declare an ability to explicitly hash into this particular type,\n /// but rather in a `H: hash::Writer` type parameter.\n #[allow(missing_copy_implementations)]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n pub struct Hasher { inner: SipHasher }\n \n impl hash::Writer for Hasher {"}, {"sha": "79e01304fb8c0807a9bf5face1810a69f6a24861", "filename": "src/libstd/collections/hash/state.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=9836742d6a5bd610074d2d944d472b0dfed3991b", "patch": "@@ -24,6 +24,7 @@ use hash;\n /// algorithm can implement the `Default` trait and create hash maps with the\n /// `DefaultState` structure. This state is 0-sized and will simply delegate\n /// to `Default` when asked to create a hasher.\n+#[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n pub trait HashState {\n     type Hasher: hash::Hasher;\n \n@@ -35,6 +36,7 @@ pub trait HashState {\n /// default trait.\n ///\n /// This struct has is 0-sized and does not need construction.\n+#[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n pub struct DefaultState<H>;\n \n impl<H: Default + hash::Hasher> HashState for DefaultState<H> {"}, {"sha": "76b8d736aad544dfcac4cee7c941362de4ec344e", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=9836742d6a5bd610074d2d944d472b0dfed3991b", "patch": "@@ -45,19 +45,22 @@ macro_rules! try_opt {\n \n /// ISO 8601 time duration with nanosecond precision.\n /// This also allows for the negative duration; see individual methods for details.\n+#[unstable(feature = \"std_misc\")]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub struct Duration {\n     secs: i64,\n     nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n }\n \n /// The minimum possible `Duration`: `i64::MIN` milliseconds.\n+#[unstable(feature = \"std_misc\")]\n pub const MIN: Duration = Duration {\n     secs: i64::MIN / MILLIS_PER_SEC - 1,\n     nanos: NANOS_PER_SEC + (i64::MIN % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n };\n \n /// The maximum possible `Duration`: `i64::MAX` milliseconds.\n+#[unstable(feature = \"std_misc\")]\n pub const MAX: Duration = Duration {\n     secs: i64::MAX / MILLIS_PER_SEC,\n     nanos: (i64::MAX % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n@@ -68,6 +71,7 @@ impl Duration {\n     /// Equivalent to `Duration::seconds(weeks * 7 * 24 * 60 * 60), with overflow checks.\n     /// Panics when the duration is out of bounds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn weeks(weeks: i64) -> Duration {\n         let secs = weeks.checked_mul(SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n         Duration::seconds(secs)\n@@ -77,6 +81,7 @@ impl Duration {\n     /// Equivalent to `Duration::seconds(days * 24 * 60 * 60)` with overflow checks.\n     /// Panics when the duration is out of bounds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn days(days: i64) -> Duration {\n         let secs = days.checked_mul(SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n         Duration::seconds(secs)\n@@ -86,6 +91,7 @@ impl Duration {\n     /// Equivalent to `Duration::seconds(hours * 60 * 60)` with overflow checks.\n     /// Panics when the duration is out of bounds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn hours(hours: i64) -> Duration {\n         let secs = hours.checked_mul(SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n         Duration::seconds(secs)\n@@ -95,6 +101,7 @@ impl Duration {\n     /// Equivalent to `Duration::seconds(minutes * 60)` with overflow checks.\n     /// Panics when the duration is out of bounds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn minutes(minutes: i64) -> Duration {\n         let secs = minutes.checked_mul(SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n         Duration::seconds(secs)\n@@ -104,6 +111,7 @@ impl Duration {\n     /// Panics when the duration is more than `i64::MAX` milliseconds\n     /// or less than `i64::MIN` milliseconds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn seconds(seconds: i64) -> Duration {\n         let d = Duration { secs: seconds, nanos: 0 };\n         if d < MIN || d > MAX {\n@@ -114,6 +122,7 @@ impl Duration {\n \n     /// Makes a new `Duration` with given number of milliseconds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn milliseconds(milliseconds: i64) -> Duration {\n         let (secs, millis) = div_mod_floor_64(milliseconds, MILLIS_PER_SEC);\n         let nanos = millis as i32 * NANOS_PER_MILLI;\n@@ -122,6 +131,7 @@ impl Duration {\n \n     /// Makes a new `Duration` with given number of microseconds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn microseconds(microseconds: i64) -> Duration {\n         let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);\n         let nanos = micros as i32 * NANOS_PER_MICRO;\n@@ -130,13 +140,15 @@ impl Duration {\n \n     /// Makes a new `Duration` with given number of nanoseconds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn nanoseconds(nanos: i64) -> Duration {\n         let (secs, nanos) = div_mod_floor_64(nanos, NANOS_PER_SEC as i64);\n         Duration { secs: secs, nanos: nanos as i32 }\n     }\n \n     /// Runs a closure, returning the duration of time it took to run the\n     /// closure.\n+    #[unstable(feature = \"std_misc\")]\n     pub fn span<F>(f: F) -> Duration where F: FnOnce() {\n         let before = super::precise_time_ns();\n         f();\n@@ -145,28 +157,33 @@ impl Duration {\n \n     /// Returns the total number of whole weeks in the duration.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_weeks(&self) -> i64 {\n         self.num_days() / 7\n     }\n \n     /// Returns the total number of whole days in the duration.\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_days(&self) -> i64 {\n         self.num_seconds() / SECS_PER_DAY\n     }\n \n     /// Returns the total number of whole hours in the duration.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_hours(&self) -> i64 {\n         self.num_seconds() / SECS_PER_HOUR\n     }\n \n     /// Returns the total number of whole minutes in the duration.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_minutes(&self) -> i64 {\n         self.num_seconds() / SECS_PER_MINUTE\n     }\n \n     /// Returns the total number of whole seconds in the duration.\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_seconds(&self) -> i64 {\n         // If secs is negative, nanos should be subtracted from the duration.\n         if self.secs < 0 && self.nanos > 0 {\n@@ -188,6 +205,7 @@ impl Duration {\n     }\n \n     /// Returns the total number of whole milliseconds in the duration,\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_milliseconds(&self) -> i64 {\n         // A proper Duration will not overflow, because MIN and MAX are defined\n         // such that the range is exactly i64 milliseconds.\n@@ -198,6 +216,7 @@ impl Duration {\n \n     /// Returns the total number of whole microseconds in the duration,\n     /// or `None` on overflow (exceeding 2^63 microseconds in either direction).\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_microseconds(&self) -> Option<i64> {\n         let secs_part = try_opt!(self.num_seconds().checked_mul(MICROS_PER_SEC));\n         let nanos_part = self.nanos_mod_sec() / NANOS_PER_MICRO;\n@@ -206,13 +225,15 @@ impl Duration {\n \n     /// Returns the total number of whole nanoseconds in the duration,\n     /// or `None` on overflow (exceeding 2^63 nanoseconds in either direction).\n+    #[unstable(feature = \"std_misc\")]\n     pub fn num_nanoseconds(&self) -> Option<i64> {\n         let secs_part = try_opt!(self.num_seconds().checked_mul(NANOS_PER_SEC as i64));\n         let nanos_part = self.nanos_mod_sec();\n         secs_part.checked_add(nanos_part as i64)\n     }\n \n     /// Add two durations, returning `None` if overflow occured.\n+    #[unstable(feature = \"std_misc\")]\n     pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n         let mut secs = try_opt!(self.secs.checked_add(rhs.secs));\n         let mut nanos = self.nanos + rhs.nanos;\n@@ -227,6 +248,7 @@ impl Duration {\n     }\n \n     /// Subtract two durations, returning `None` if overflow occured.\n+    #[unstable(feature = \"std_misc\")]\n     pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n         let mut secs = try_opt!(self.secs.checked_sub(rhs.secs));\n         let mut nanos = self.nanos - rhs.nanos;\n@@ -242,25 +264,30 @@ impl Duration {\n \n     /// The minimum possible `Duration`: `i64::MIN` milliseconds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn min_value() -> Duration { MIN }\n \n     /// The maximum possible `Duration`: `i64::MAX` milliseconds.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn max_value() -> Duration { MAX }\n \n     /// A duration where the stored seconds and nanoseconds are equal to zero.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn zero() -> Duration {\n         Duration { secs: 0, nanos: 0 }\n     }\n \n     /// Returns `true` if the duration equals `Duration::zero()`.\n     #[inline]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn is_zero(&self) -> bool {\n         self.secs == 0 && self.nanos == 0\n     }\n }\n \n+#[unstable(feature = \"std_misc\")]\n impl Neg for Duration {\n     type Output = Duration;\n \n@@ -274,6 +301,7 @@ impl Neg for Duration {\n     }\n }\n \n+#[unstable(feature = \"std_misc\")]\n impl Add for Duration {\n     type Output = Duration;\n \n@@ -288,6 +316,7 @@ impl Add for Duration {\n     }\n }\n \n+#[unstable(feature = \"std_misc\")]\n impl Sub for Duration {\n     type Output = Duration;\n \n@@ -302,6 +331,7 @@ impl Sub for Duration {\n     }\n }\n \n+#[unstable(feature = \"std_misc\")]\n impl Mul<i32> for Duration {\n     type Output = Duration;\n \n@@ -314,6 +344,7 @@ impl Mul<i32> for Duration {\n     }\n }\n \n+#[unstable(feature = \"std_misc\")]\n impl Div<i32> for Duration {\n     type Output = Duration;\n "}, {"sha": "4d9bb8050d31ea83f4199aff715821d7110ef5b8", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9836742d6a5bd610074d2d944d472b0dfed3991b/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=9836742d6a5bd610074d2d944d472b0dfed3991b", "patch": "@@ -10,6 +10,8 @@\n \n //! Temporal quantification.\n \n+#![unstable(feature = \"std_misc\")]\n+\n use sys::time::SteadyTime;\n \n pub use self::duration::Duration;"}]}