{"sha": "3bbd61d67421192c898956e6f6ada615d90aa4ee", "node_id": "C_kwDOAAsO6NoAKDNiYmQ2MWQ2NzQyMTE5MmM4OTg5NTZlNmY2YWRhNjE1ZDkwYWE0ZWU", "commit": {"author": {"name": "Terry Sun", "email": "terrynsun@gmail.com", "date": "2021-10-27T17:46:25Z"}, "committer": {"name": "Terry Sun", "email": "terrynsun@gmail.com", "date": "2021-10-27T17:46:25Z"}, "message": "fixup! delay to_string() until assist is called", "tree": {"sha": "c2b37dab5152a0cb314cec2d749c369d653819fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2b37dab5152a0cb314cec2d749c369d653819fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bbd61d67421192c898956e6f6ada615d90aa4ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bbd61d67421192c898956e6f6ada615d90aa4ee", "html_url": "https://github.com/rust-lang/rust/commit/3bbd61d67421192c898956e6f6ada615d90aa4ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bbd61d67421192c898956e6f6ada615d90aa4ee/comments", "author": {"login": "terrynsun", "id": 2858750, "node_id": "MDQ6VXNlcjI4NTg3NTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2858750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/terrynsun", "html_url": "https://github.com/terrynsun", "followers_url": "https://api.github.com/users/terrynsun/followers", "following_url": "https://api.github.com/users/terrynsun/following{/other_user}", "gists_url": "https://api.github.com/users/terrynsun/gists{/gist_id}", "starred_url": "https://api.github.com/users/terrynsun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/terrynsun/subscriptions", "organizations_url": "https://api.github.com/users/terrynsun/orgs", "repos_url": "https://api.github.com/users/terrynsun/repos", "events_url": "https://api.github.com/users/terrynsun/events{/privacy}", "received_events_url": "https://api.github.com/users/terrynsun/received_events", "type": "User", "site_admin": false}, "committer": {"login": "terrynsun", "id": 2858750, "node_id": "MDQ6VXNlcjI4NTg3NTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2858750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/terrynsun", "html_url": "https://github.com/terrynsun", "followers_url": "https://api.github.com/users/terrynsun/followers", "following_url": "https://api.github.com/users/terrynsun/following{/other_user}", "gists_url": "https://api.github.com/users/terrynsun/gists{/gist_id}", "starred_url": "https://api.github.com/users/terrynsun/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/terrynsun/subscriptions", "organizations_url": "https://api.github.com/users/terrynsun/orgs", "repos_url": "https://api.github.com/users/terrynsun/repos", "events_url": "https://api.github.com/users/terrynsun/events{/privacy}", "received_events_url": "https://api.github.com/users/terrynsun/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6abdbdd0c97149fb69a32a1c063dfe01dbc740d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1", "html_url": "https://github.com/rust-lang/rust/commit/6abdbdd0c97149fb69a32a1c063dfe01dbc740d1"}], "stats": {"total": 58, "additions": 24, "deletions": 34}, "files": [{"sha": "46e03e20da0978293583cd46953284634e122887", "filename": "crates/ide_assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3bbd61d67421192c898956e6f6ada615d90aa4ee/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbd61d67421192c898956e6f6ada615d90aa4ee/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=3bbd61d67421192c898956e6f6ada615d90aa4ee", "patch": "@@ -1,5 +1,5 @@\n use syntax::{\n-    ast::{Expr, GenericArg, GenericArgList},\n+    ast::{Expr, GenericArg},\n     ast::{LetStmt, Type::InferType},\n     AstNode, TextRange,\n };\n@@ -34,15 +34,13 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n     let initializer = let_stmt.initializer()?;\n \n-    let (turbofish_range, turbofish_type) = match &initializer {\n+    let generic_args = match &initializer {\n         Expr::MethodCallExpr(ce) => {\n-            let generic_args = ce.generic_arg_list()?;\n-            (turbofish_range(&generic_args)?, turbofish_type(&generic_args)?)\n+            ce.generic_arg_list()?\n         }\n         Expr::CallExpr(ce) => {\n             if let Expr::PathExpr(pe) = ce.expr()? {\n-                let generic_args = pe.path()?.segment()?.generic_arg_list()?;\n-                (turbofish_range(&generic_args)?, turbofish_type(&generic_args)?)\n+                pe.path()?.segment()?.generic_arg_list()?\n             } else {\n                 cov_mark::hit!(not_applicable_if_non_path_function_call);\n                 return None;\n@@ -54,6 +52,23 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n         }\n     };\n \n+    // Find range of ::<_>\n+    let colon2 = generic_args.coloncolon_token()?;\n+    let r_angle = generic_args.r_angle_token()?;\n+    let turbofish_range = TextRange::new(colon2.text_range().start(), r_angle.text_range().end());\n+\n+    let turbofish_args: Vec<GenericArg> = generic_args.generic_args().into_iter().collect();\n+\n+    // Find type of ::<_>\n+    if turbofish_args.len() != 1 {\n+        cov_mark::hit!(not_applicable_if_not_single_arg);\n+        return None;\n+    }\n+\n+    // An improvement would be to check that this is correctly part of the return value of the\n+    // function call, or sub in the actual return type.\n+    let turbofish_type = &turbofish_args[0];\n+\n     let initializer_start = initializer.syntax().text_range().start();\n     if ctx.offset() > turbofish_range.end() || ctx.offset() < initializer_start {\n         cov_mark::hit!(not_applicable_outside_turbofish);\n@@ -67,7 +82,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n         return acc.add(\n             AssistId(\"replace_turbofish_with_explicit_type\", AssistKind::RefactorRewrite),\n-            format!(\"Replace turbofish with explicit type `: <{}>`\", turbofish_type),\n+            \"Replace turbofish with explicit type\",\n             TextRange::new(initializer_start, turbofish_range.end()),\n             |builder| {\n                 builder.insert(ident_range.end(), format!(\": {}\", turbofish_type));\n@@ -82,10 +97,10 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n         return acc.add(\n             AssistId(\"replace_turbofish_with_explicit_type\", AssistKind::RefactorRewrite),\n-            format!(\"Replace `_` with turbofish type `{}`\", turbofish_type),\n+            \"Replace `_` with turbofish type\",\n             turbofish_range,\n             |builder| {\n-                builder.replace(underscore_range, turbofish_type);\n+                builder.replace(underscore_range, turbofish_type.to_string());\n                 builder.delete(turbofish_range);\n             },\n         );\n@@ -94,31 +109,6 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n     None\n }\n \n-/// Returns the type of the turbofish as a String.\n-/// Returns None if there are 0 or >1 arguments.\n-fn turbofish_type(generic_args: &GenericArgList) -> Option<String> {\n-    let turbofish_args: Vec<GenericArg> = generic_args.generic_args().into_iter().collect();\n-\n-    if turbofish_args.len() != 1 {\n-        cov_mark::hit!(not_applicable_if_not_single_arg);\n-        return None;\n-    }\n-\n-    // An improvement would be to check that this is correctly part of the return value of the\n-    // function call, or sub in the actual return type.\n-    let turbofish_type = turbofish_args[0].to_string();\n-\n-    Some(turbofish_type)\n-}\n-\n-/// Returns the TextRange of the whole turbofish expression, and the generic argument as a String.\n-fn turbofish_range(generic_args: &GenericArgList) -> Option<TextRange> {\n-    let colon2 = generic_args.coloncolon_token()?;\n-    let r_angle = generic_args.r_angle_token()?;\n-\n-    Some(TextRange::new(colon2.text_range().start(), r_angle.text_range().end()))\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}]}