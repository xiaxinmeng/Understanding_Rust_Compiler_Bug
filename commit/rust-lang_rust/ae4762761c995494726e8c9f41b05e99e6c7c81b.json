{"sha": "ae4762761c995494726e8c9f41b05e99e6c7c81b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNDc2Mjc2MWM5OTU0OTQ3MjZlOGM5ZjQxYjA1ZTk5ZTZjN2M4MWI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-05T10:14:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-06T12:21:27Z"}, "message": "Merge core::num::Float and std::num::FloatMath.\n\n`FloatMath` no longer exists and all functionality from both traits is\navailable under `Float`. Change from\n\n    use std::num::{Float, FloatMath};\n\nto\n\n    use std::num::Float;\n\n[breaking-change]", "tree": {"sha": "5661aad98d93e56e853a4c37871e46690d1eb492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5661aad98d93e56e853a4c37871e46690d1eb492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae4762761c995494726e8c9f41b05e99e6c7c81b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae4762761c995494726e8c9f41b05e99e6c7c81b", "html_url": "https://github.com/rust-lang/rust/commit/ae4762761c995494726e8c9f41b05e99e6c7c81b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae4762761c995494726e8c9f41b05e99e6c7c81b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1291fc76e097d92680da83cb58912018dbf82266", "url": "https://api.github.com/repos/rust-lang/rust/commits/1291fc76e097d92680da83cb58912018dbf82266", "html_url": "https://github.com/rust-lang/rust/commit/1291fc76e097d92680da83cb58912018dbf82266"}], "stats": {"total": 479, "additions": 443, "deletions": 36}, "files": [{"sha": "ec18f23b41478d23ed0e089825a48a3a90f1728c", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 125, "deletions": 11, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ae4762761c995494726e8c9f41b05e99e6c7c81b", "patch": "@@ -19,12 +19,14 @@ use prelude::v1::*;\n \n use intrinsics;\n use libc::c_int;\n-use num::{Float, FloatMath};\n+use num::{Float, FpCategory};\n use num::strconv;\n use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n use num::strconv::SignFormat::SignNeg;\n \n+use core::num;\n+\n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n@@ -72,7 +74,119 @@ mod cmath {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl FloatMath for f32 {\n+impl Float for f32 {\n+    #[inline]\n+    fn nan() -> f32 { num::Float::nan() }\n+    #[inline]\n+    fn infinity() -> f32 { num::Float::infinity() }\n+    #[inline]\n+    fn neg_infinity() -> f32 { num::Float::neg_infinity() }\n+    #[inline]\n+    fn zero() -> f32 { num::Float::zero() }\n+    #[inline]\n+    fn neg_zero() -> f32 { num::Float::neg_zero() }\n+    #[inline]\n+    fn one() -> f32 { num::Float::one() }\n+\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn mantissa_digits(unused_self: Option<f32>) -> uint {\n+        num::Float::mantissa_digits(unused_self)\n+    }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn epsilon() -> f32 { num::Float::epsilon() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_value() -> f32 { num::Float::min_value() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_value() -> f32 { num::Float::max_value() }\n+\n+    #[inline]\n+    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n+    #[inline]\n+    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n+    #[inline]\n+    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n+    #[inline]\n+    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n+    #[inline]\n+    fn classify(self) -> FpCategory { num::Float::classify(self) }\n+\n+    #[inline]\n+    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n+\n+    #[inline]\n+    fn floor(self) -> f32 { num::Float::floor(self) }\n+    #[inline]\n+    fn ceil(self) -> f32 { num::Float::ceil(self) }\n+    #[inline]\n+    fn round(self) -> f32 { num::Float::round(self) }\n+    #[inline]\n+    fn trunc(self) -> f32 { num::Float::trunc(self) }\n+    #[inline]\n+    fn fract(self) -> f32 { num::Float::fract(self) }\n+\n+    #[inline]\n+    fn abs(self) -> f32 { num::Float::abs(self) }\n+    #[inline]\n+    fn signum(self) -> f32 { num::Float::signum(self) }\n+    #[inline]\n+    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n+    #[inline]\n+    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n+\n+    #[inline]\n+    fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n+    #[inline]\n+    fn recip(self) -> f32 { num::Float::recip(self) }\n+\n+    #[inline]\n+    fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n+    #[inline]\n+    fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n+\n+    #[inline]\n+    fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n+    #[inline]\n+    fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n+\n+    #[inline]\n+    fn exp(self) -> f32 { num::Float::exp(self) }\n+    #[inline]\n+    fn exp2(self) -> f32 { num::Float::exp(self) }\n+    #[inline]\n+    fn ln(self) -> f32 { num::Float::ln(self) }\n+    #[inline]\n+    fn log(self, base: f32) -> f32 { num::Float::log(self, base) }\n+    #[inline]\n+    fn log2(self) -> f32 { num::Float::log2(self) }\n+    #[inline]\n+    fn log10(self) -> f32 { num::Float::log10(self) }\n+    #[inline]\n+    fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n+    #[inline]\n+    fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n+\n     /// Constructs a floating point number by multiplying `x` by 2 raised to the\n     /// power of `exp`\n     #[inline]\n@@ -639,18 +753,18 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(FloatMath::ldexp(1f32, -123), f1);\n-        assert_eq!(FloatMath::ldexp(1f32, -111), f2);\n+        assert_eq!(Float::ldexp(1f32, -123), f1);\n+        assert_eq!(Float::ldexp(1f32, -111), f2);\n \n-        assert_eq!(FloatMath::ldexp(0f32, -123), 0f32);\n-        assert_eq!(FloatMath::ldexp(-0f32, -123), -0f32);\n+        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n+        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n \n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n         let nan: f32 = Float::nan();\n-        assert_eq!(FloatMath::ldexp(inf, -123), inf);\n-        assert_eq!(FloatMath::ldexp(neg_inf, -123), neg_inf);\n-        assert!(FloatMath::ldexp(nan, -123).is_nan());\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -663,8 +777,8 @@ mod tests {\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));\n         assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!(FloatMath::ldexp(x1, exp1), f1);\n-        assert_eq!(FloatMath::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));"}, {"sha": "a0513709b866b1ae269b1eb924857af82ebf7817", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 128, "deletions": 13, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=ae4762761c995494726e8c9f41b05e99e6c7c81b", "patch": "@@ -18,12 +18,14 @@ use prelude::v1::*;\n \n use intrinsics;\n use libc::c_int;\n-use num::{Float, FloatMath};\n+use num::{Float, FpCategory};\n use num::strconv;\n use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n use num::strconv::SignFormat::SignNeg;\n \n+use core::num;\n+\n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n@@ -80,9 +82,122 @@ mod cmath {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl FloatMath for f64 {\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n-    /// power of `exp`\n+impl Float for f64 {\n+    // inlined methods from `num::Float`\n+    #[inline]\n+    fn nan() -> f64 { num::Float::nan() }\n+    #[inline]\n+    fn infinity() -> f64 { num::Float::infinity() }\n+    #[inline]\n+    fn neg_infinity() -> f64 { num::Float::neg_infinity() }\n+    #[inline]\n+    fn zero() -> f64 { num::Float::zero() }\n+    #[inline]\n+    fn neg_zero() -> f64 { num::Float::neg_zero() }\n+    #[inline]\n+    fn one() -> f64 { num::Float::one() }\n+\n+\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn mantissa_digits(unused_self: Option<f64>) -> uint {\n+        num::Float::mantissa_digits(unused_self)\n+    }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn epsilon() -> f64 { num::Float::epsilon() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_value() -> f64 { num::Float::min_value() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_value() -> f64 { num::Float::max_value() }\n+\n+    #[inline]\n+    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n+    #[inline]\n+    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n+    #[inline]\n+    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n+    #[inline]\n+    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n+    #[inline]\n+    fn classify(self) -> FpCategory { num::Float::classify(self) }\n+\n+    #[inline]\n+    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n+\n+    #[inline]\n+    fn floor(self) -> f64 { num::Float::floor(self) }\n+    #[inline]\n+    fn ceil(self) -> f64 { num::Float::ceil(self) }\n+    #[inline]\n+    fn round(self) -> f64 { num::Float::round(self) }\n+    #[inline]\n+    fn trunc(self) -> f64 { num::Float::trunc(self) }\n+    #[inline]\n+    fn fract(self) -> f64 { num::Float::fract(self) }\n+\n+    #[inline]\n+    fn abs(self) -> f64 { num::Float::abs(self) }\n+    #[inline]\n+    fn signum(self) -> f64 { num::Float::signum(self) }\n+    #[inline]\n+    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n+    #[inline]\n+    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n+\n+    #[inline]\n+    fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n+    #[inline]\n+    fn recip(self) -> f64 { num::Float::recip(self) }\n+\n+    #[inline]\n+    fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n+    #[inline]\n+    fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n+\n+    #[inline]\n+    fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n+    #[inline]\n+    fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n+\n+    #[inline]\n+    fn exp(self) -> f64 { num::Float::exp(self) }\n+    #[inline]\n+    fn exp2(self) -> f64 { num::Float::exp(self) }\n+    #[inline]\n+    fn ln(self) -> f64 { num::Float::ln(self) }\n+    #[inline]\n+    fn log(self, base: f64) -> f64 { num::Float::log(self, base) }\n+    #[inline]\n+    fn log2(self) -> f64 { num::Float::log2(self) }\n+    #[inline]\n+    fn log10(self) -> f64 { num::Float::log10(self) }\n+\n+    #[inline]\n+    fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n+    #[inline]\n+    fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n+\n     #[inline]\n     fn ldexp(x: f64, exp: int) -> f64 {\n         unsafe { cmath::ldexp(x, exp as c_int) }\n@@ -640,18 +755,18 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(FloatMath::ldexp(1f64, -123), f1);\n-        assert_eq!(FloatMath::ldexp(1f64, -111), f2);\n+        assert_eq!(Float::ldexp(1f64, -123), f1);\n+        assert_eq!(Float::ldexp(1f64, -111), f2);\n \n-        assert_eq!(FloatMath::ldexp(0f64, -123), 0f64);\n-        assert_eq!(FloatMath::ldexp(-0f64, -123), -0f64);\n+        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n+        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n \n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n         let nan: f64 = Float::nan();\n-        assert_eq!(FloatMath::ldexp(inf, -123), inf);\n-        assert_eq!(FloatMath::ldexp(neg_inf, -123), neg_inf);\n-        assert!(FloatMath::ldexp(nan, -123).is_nan());\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -664,8 +779,8 @@ mod tests {\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));\n         assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!(FloatMath::ldexp(x1, exp1), f1);\n-        assert_eq!(FloatMath::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));"}, {"sha": "504bc75c2644d64397fe43a23ff6f2d78dd7b454", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 184, "deletions": 6, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ae4762761c995494726e8c9f41b05e99e6c7c81b", "patch": "@@ -16,25 +16,203 @@\n #![stable]\n #![allow(missing_docs)]\n \n-#[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt::Show;\n-#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n-#[cfg(test)] use kinds::Copy;\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+\n+use kinds::Copy;\n+use clone::Clone;\n+use cmp::{PartialOrd, PartialEq};\n \n pub use core::num::{Int, SignedInt, UnsignedInt};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n pub use core::num::{FromStrRadix, from_str_radix};\n-pub use core::num::{FpCategory, Float};\n+pub use core::num::{FpCategory};\n+\n+use option::Option;\n \n #[experimental = \"may be removed or relocated\"]\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers.\n-#[unstable = \"may be altered to inline the Float trait\"]\n-pub trait FloatMath: Float {\n+pub trait Float\n+    : Copy + Clone\n+    + NumCast\n+    + PartialOrd\n+    + PartialEq\n+    + Neg<Output=Self>\n+    + Add<Output=Self>\n+    + Sub<Output=Self>\n+    + Mul<Output=Self>\n+    + Div<Output=Self>\n+    + Rem<Output=Self>\n+{\n+    // inlined methods from `num::Float`\n+    /// Returns the NaN value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn nan() -> Self;\n+    /// Returns the infinite value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn infinity() -> Self;\n+    /// Returns the negative infinite value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn neg_infinity() -> Self;\n+    /// Returns the `0` value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn zero() -> Self;\n+    /// Returns -0.0.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn neg_zero() -> Self;\n+    /// Returns the `1` value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn one() -> Self;\n+\n+    // FIXME (#5527): These should be associated constants\n+\n+    /// Returns the number of binary digits of mantissa that this type supports.\n+    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n+    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the number of base-10 digits of precision that this type supports.\n+    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n+    fn digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n+    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n+    fn epsilon() -> Self;\n+    /// Returns the minimum binary exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n+    fn min_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum binary exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n+    fn max_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the minimum base-10 exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n+    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum base-10 exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n+    fn max_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the smallest finite value that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\"]\n+    fn min_value() -> Self;\n+    /// Returns the smallest normalized positive number that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_POS_VALUE` or `std::f64::MIN_POS_VALUE` as appropriate\"]\n+    fn min_pos_value(unused_self: Option<Self>) -> Self;\n+    /// Returns the largest finite value that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\"]\n+    fn max_value() -> Self;\n+\n+    /// Returns true if this value is NaN and false otherwise.\n+    #[stable]\n+    fn is_nan(self) -> bool;\n+    /// Returns true if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    #[stable]\n+    fn is_infinite(self) -> bool;\n+    /// Returns true if this number is neither infinite nor NaN.\n+    #[stable]\n+    fn is_finite(self) -> bool;\n+    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n+    #[stable]\n+    fn is_normal(self) -> bool;\n+    /// Returns the category that this number falls into.\n+    #[stable]\n+    fn classify(self) -> FpCategory;\n+\n+    /// Returns the mantissa, exponent and sign as integers, respectively.\n+    #[stable]\n+    fn integer_decode(self) -> (u64, i16, i8);\n+\n+    /// Return the largest integer less than or equal to a number.\n+    #[unstable = \"TODO\"]\n+    fn floor(self) -> Self;\n+    /// Return the smallest integer greater than or equal to a number.\n+    #[unstable = \"TODO\"]\n+    fn ceil(self) -> Self;\n+    /// Return the nearest integer to a number. Round half-way cases away from\n+    /// `0.0`.\n+    #[unstable = \"TODO\"]\n+    fn round(self) -> Self;\n+    /// Return the integer part of a number.\n+    #[unstable = \"TODO\"]\n+    fn trunc(self) -> Self;\n+    /// Return the fractional part of a number.\n+    #[unstable = \"TODO\"]\n+    fn fract(self) -> Self;\n+\n+    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n+    /// number is `Float::nan()`.\n+    #[unstable = \"TODO\"]\n+    fn abs(self) -> Self;\n+    /// Returns a number that represents the sign of `self`.\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n+    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n+    /// - `Float::nan()` if the number is `Float::nan()`\n+    #[stable]\n+    fn signum(self) -> Self;\n+    /// Returns `true` if `self` is positive, including `+0.0` and\n+    /// `Float::infinity()`.\n+    #[stable]\n+    fn is_positive(self) -> bool;\n+    /// Returns `true` if `self` is negative, including `-0.0` and\n+    /// `Float::neg_infinity()`.\n+    #[stable]\n+    fn is_negative(self) -> bool;\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    #[stable]\n+    fn mul_add(self, a: Self, b: Self) -> Self;\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    #[stable]\n+    fn recip(self) -> Self;\n+\n+    /// Raise a number to an integer power.\n+    ///\n+    /// Using this function is generally faster than using `powf`\n+    #[unstable = \"TODO\"]\n+    fn powi(self, n: i32) -> Self;\n+    /// Raise a number to a floating point power.\n+    #[unstable = \"TODO\"]\n+    fn powf(self, n: Self) -> Self;\n+\n+    /// Take the square root of a number.\n+    ///\n+    /// Returns NaN if `self` is a negative number.\n+    #[unstable = \"TODO\"]\n+    fn sqrt(self) -> Self;\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    #[unstable = \"TODO\"]\n+    fn rsqrt(self) -> Self;\n+\n+    /// Returns `e^(self)`, (the exponential function).\n+    #[unstable = \"TODO\"]\n+    fn exp(self) -> Self;\n+    /// Returns 2 raised to the power of the number, `2^(self)`.\n+    #[unstable = \"TODO\"]\n+    fn exp2(self) -> Self;\n+    /// Returns the natural logarithm of the number.\n+    #[unstable = \"TODO\"]\n+    fn ln(self) -> Self;\n+    /// Returns the logarithm of the number with respect to an arbitrary base.\n+    #[unstable = \"TODO\"]\n+    fn log(self, base: Self) -> Self;\n+    /// Returns the base 2 logarithm of the number.\n+    #[unstable = \"TODO\"]\n+    fn log2(self) -> Self;\n+    /// Returns the base 10 logarithm of the number.\n+    #[unstable = \"TODO\"]\n+    fn log10(self) -> Self;\n+\n+    /// Convert radians to degrees.\n+    #[unstable = \"TODO\"]\n+    fn to_degrees(self) -> Self;\n+    /// Convert degrees to radians.\n+    #[unstable = \"TODO\"]\n+    fn to_radians(self) -> Self;\n+\n     /// Constructs a floating point number created by multiplying `x` by 2\n     /// raised to the power of `exp`.\n     fn ldexp(x: Self, exp: int) -> Self;"}, {"sha": "c417fd94e22eb953a9cd73955cbb63a729f8c52a", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ae4762761c995494726e8c9f41b05e99e6c7c81b", "patch": "@@ -69,7 +69,7 @@ use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::iter::repeat;\n-use std::num::{Float, FloatMath, Int};\n+use std::num::{Float, Int};\n use std::os;\n use std::str::FromStr;\n use std::sync::mpsc::{channel, Sender};"}, {"sha": "bdc05a50301d54bf0c9f5e1e85b7b1f7998200ab", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=ae4762761c995494726e8c9f41b05e99e6c7c81b", "patch": "@@ -17,7 +17,7 @@ use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n use std::mem;\n-use std::num::{Float, FloatMath, FromPrimitive};\n+use std::num::{Float, FromPrimitive};\n \n fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -39,7 +39,7 @@ fn local_sort<T: Float>(v: &mut [T]) {\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: FloatMath + FromPrimitive> {\n+pub trait Stats <T: Float + FromPrimitive> {\n \n     /// Sum of the samples.\n     ///\n@@ -144,7 +144,7 @@ pub struct Summary<T> {\n     pub iqr: T,\n }\n \n-impl<T: FloatMath + FromPrimitive> Summary<T> {\n+impl<T: Float + FromPrimitive> Summary<T> {\n     /// Construct a new summary of a sample set.\n     pub fn new(samples: &[T]) -> Summary<T> {\n         Summary {\n@@ -164,7 +164,7 @@ impl<T: FloatMath + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<T: FloatMath + FromPrimitive> Stats<T> for [T] {\n+impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     // FIXME #11059 handle NaN, inf and overflow\n     fn sum(&self) -> T {\n         let mut partials = vec![];"}, {"sha": "3c7efb0336a012f525b07363b21dccd5a829d96d", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae4762761c995494726e8c9f41b05e99e6c7c81b/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=ae4762761c995494726e8c9f41b05e99e6c7c81b", "patch": "@@ -13,7 +13,7 @@\n // ignore-lexer-test FIXME #15679\n \n use std::f32::consts::PI;\n-use std::num::{Float, FloatMath};\n+use std::num::Float;\n use std::rand::{Rng, StdRng};\n \n struct Vec2 {"}]}