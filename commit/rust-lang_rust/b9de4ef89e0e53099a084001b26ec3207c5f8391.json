{"sha": "b9de4ef89e0e53099a084001b26ec3207c5f8391", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZGU0ZWY4OWUwZTUzMDk5YTA4NDAwMWIyNmVjMzIwN2M1ZjgzOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-03T15:17:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-03T15:17:31Z"}, "message": "Auto merge of #64127 - Centril:rollup-dfgb9h8, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #64049 (Emit a single error on if expr with expectation and no else clause)\n - #64056 (Account for arbitrary self types in E0599)\n - #64058 (librustc_errors: Extract sugg/subst handling into method)\n - #64071 (use just one name when parameters and fields are the same)\n - #64104 (Emit error on intrinsic to fn ptr casts)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a5ebb43454b05a252c93cd59c2ceacc7fd4ec32e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5ebb43454b05a252c93cd59c2ceacc7fd4ec32e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9de4ef89e0e53099a084001b26ec3207c5f8391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9de4ef89e0e53099a084001b26ec3207c5f8391", "html_url": "https://github.com/rust-lang/rust/commit/b9de4ef89e0e53099a084001b26ec3207c5f8391", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9de4ef89e0e53099a084001b26ec3207c5f8391/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "815dec9db156284b4f57a4ec34182ffc89218242", "url": "https://api.github.com/repos/rust-lang/rust/commits/815dec9db156284b4f57a4ec34182ffc89218242", "html_url": "https://github.com/rust-lang/rust/commit/815dec9db156284b4f57a4ec34182ffc89218242"}, {"sha": "24e3b1d0d3cfb5fddc91105bb261413566e8b701", "url": "https://api.github.com/repos/rust-lang/rust/commits/24e3b1d0d3cfb5fddc91105bb261413566e8b701", "html_url": "https://github.com/rust-lang/rust/commit/24e3b1d0d3cfb5fddc91105bb261413566e8b701"}], "stats": {"total": 414, "additions": 269, "deletions": 145}, "files": [{"sha": "e684ccfeeb7ed7babc8c4a602c333de5ccc87626", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -1636,6 +1636,9 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n                     Error0644(\"closure/generator type that references itself\")\n                 }\n+                TypeError::IntrinsicCast => {\n+                    Error0308(\"cannot coerce intrinsics to function pointers\")\n+                }\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }"}, {"sha": "17c9e520bcea284c2d385eb71649003555f70f60", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -2402,6 +2402,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_generic_adt(def_id, ty)\n     }\n \n+    #[inline]\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(item, None);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n     #[inline]\n     pub fn mk_maybe_uninit(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem, None);"}, {"sha": "fe8f94ab1d314bdcb1e3a2a2870a228b7b295c99", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -46,6 +46,8 @@ pub enum TypeError<'tcx> {\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n \n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n+\n+    IntrinsicCast,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -179,6 +181,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             ConstMismatch(ref values) => {\n                 write!(f, \"expected `{}`, found `{}`\", values.expected, values.found)\n             }\n+            IntrinsicCast => {\n+                write!(f, \"cannot coerce intrinsics to function pointers\")\n+            }\n         }\n     }\n }"}, {"sha": "ec7cf1a13c5964f81b47fa94aff9e807a12db82c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -748,6 +748,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n+            IntrinsicCast => IntrinsicCast,\n         })\n     }\n }\n@@ -1338,6 +1339,7 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::Sorts)(x),\n         (ty::error::TypeError::ExistentialMismatch)(x),\n         (ty::error::TypeError::ConstMismatch)(x),\n+        (ty::error::TypeError::IntrinsicCast),\n     }\n }\n "}, {"sha": "3bed5d81dc514fcac7c3c96c16ff2e9d8c83ecd1", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -30,10 +30,8 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n-        let primary_span = db.span.clone();\n         let children = db.children.clone();\n-        // FIXME(#59346): Collect suggestions (see emitter.rs)\n-        let suggestions: &[_] = &[];\n+        let (primary_span, suggestions) = self.primary_span_formatted(&db);\n \n         // FIXME(#59346): Add `fix_multispans_in_std_macros` function from emitter.rs\n "}, {"sha": "a298f9958f2d1258be61208a043e4dabe1fa644a", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -191,16 +191,25 @@ pub trait Emitter {\n     fn should_show_explain(&self) -> bool {\n         true\n     }\n-}\n \n-impl Emitter for EmitterWriter {\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+    /// Formats the substitutions of the primary_span\n+    ///\n+    /// The are a lot of conditions to this method, but in short:\n+    ///\n+    /// * If the current `Diagnostic` has only one visible `CodeSuggestion`,\n+    ///   we format the `help` suggestion depending on the content of the\n+    ///   substitutions. In that case, we return the modified span only.\n+    ///\n+    /// * If the current `Diagnostic` has multiple suggestions,\n+    ///   we return the original `primary_span` and the original suggestions.\n+    fn primary_span_formatted<'a>(\n+        &mut self,\n+        db: &'a DiagnosticBuilder<'_>\n+    ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = db.span.clone();\n-        let mut children = db.children.clone();\n-        let mut suggestions: &[_] = &[];\n-\n         if let Some((sugg, rest)) = db.suggestions.split_first() {\n             if rest.is_empty() &&\n+               // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n                sugg.substitutions.len() == 1 &&\n                // don't display multipart suggestions as labels\n@@ -216,21 +225,34 @@ impl Emitter for EmitterWriter {\n             {\n                 let substitution = &sugg.substitutions[0].parts[0].snippet.trim();\n                 let msg = if substitution.len() == 0 || sugg.style.hide_inline() {\n-                    // This substitution is only removal or we explicitly don't want to show the\n-                    // code inline, don't show it\n+                    // This substitution is only removal OR we explicitly don't want to show the\n+                    // code inline (`hide_inline`). Therefore, we don't show the substitution.\n                     format!(\"help: {}\", sugg.msg)\n                 } else {\n+                    // Show the default suggestion text with the substitution\n                     format!(\"help: {}: `{}`\", sugg.msg, substitution)\n                 };\n                 primary_span.push_span_label(sugg.substitutions[0].parts[0].span, msg);\n+\n+                // We return only the modified primary_span\n+                (primary_span, &[])\n             } else {\n                 // if there are multiple suggestions, print them all in full\n                 // to be consistent. We could try to figure out if we can\n                 // make one (or the first one) inline, but that would give\n                 // undue importance to a semi-random suggestion\n-                suggestions = &db.suggestions;\n+                (primary_span, &db.suggestions)\n             }\n+        } else {\n+            (primary_span, &db.suggestions)\n         }\n+    }\n+}\n+\n+impl Emitter for EmitterWriter {\n+    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+        let mut children = db.children.clone();\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n         self.fix_multispans_in_std_macros(&mut primary_span,\n                                           &mut children,"}, {"sha": "7427ae9ce8de36efaf5ebed3bbae7e66a2efc215", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -112,19 +112,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             self.diverges.set(pats_diverge);\n-            let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n+            let arm_ty = if source_if && if_no_else && i != 0 && self.if_fallback_coercion(\n+                expr.span,\n+                &arms[0].body,\n+                &mut coercion,\n+            ) {\n+                tcx.types.err\n+            } else {\n+                // Only call this if this is not an `if` expr with an expected type and no `else`\n+                // clause to avoid duplicated type errors. (#60254)\n+                self.check_expr_with_expectation(&arm.body, expected)\n+            };\n             all_arms_diverge &= self.diverges.get();\n-\n-            let span = expr.span;\n-\n             if source_if {\n                 let then_expr = &arms[0].body;\n                 match (i, if_no_else) {\n-                    (0, _) => coercion.coerce(self, &self.misc(span), &arm.body, arm_ty),\n-                    (_, true) => self.if_fallback_coercion(span, then_expr, &mut coercion),\n+                    (0, _) => coercion.coerce(self, &self.misc(expr.span), &arm.body, arm_ty),\n+                    (_, true) => {} // Handled above to avoid duplicated type errors (#60254).\n                     (_, _) => {\n                         let then_ty = prior_arm_ty.unwrap();\n-                        let cause = self.if_cause(span, then_expr, &arm.body, then_ty, arm_ty);\n+                        let cause = self.if_cause(expr.span, then_expr, &arm.body, then_ty, arm_ty);\n                         coercion.coerce(self, &cause, &arm.body, arm_ty);\n                     }\n                 }\n@@ -139,7 +146,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n                     0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n-                    _ => (span, ObligationCauseCode::MatchExpressionArm {\n+                    _ => (expr.span, ObligationCauseCode::MatchExpressionArm {\n                         arm_span,\n                         source: match_src,\n                         prior_arms: other_arms.clone(),\n@@ -180,16 +187,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Handle the fallback arm of a desugared if(-let) like a missing else.\n+    ///\n+    /// Returns `true` if there was an error forcing the coercion to the `()` type.\n     fn if_fallback_coercion(\n         &self,\n         span: Span,\n         then_expr: &'tcx hir::Expr,\n         coercion: &mut CoerceMany<'tcx, '_, rustc::hir::Arm>,\n-    ) {\n+    ) -> bool {\n         // If this `if` expr is the parent's function return expr,\n         // the cause of the type coercion is the return type, point at it. (#25228)\n         let ret_reason = self.maybe_get_coercion_reason(then_expr.hir_id, span);\n         let cause = self.cause(span, ObligationCauseCode::IfExpressionWithNoElse);\n+        let mut error = false;\n         coercion.coerce_forced_unit(self, &cause, &mut |err| {\n             if let Some((span, msg)) = &ret_reason {\n                 err.span_label(*span, msg.as_str());\n@@ -200,7 +210,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             err.note(\"`if` expressions without `else` evaluate to `()`\");\n             err.help(\"consider adding an `else` block that evaluates to the expected type\");\n+            error = true;\n         }, ret_reason.is_none());\n+        error\n     }\n \n     fn maybe_get_coercion_reason(&self, hir_id: hir::HirId, span: Span) -> Option<(Span, String)> {"}, {"sha": "c216cc92b1e58867ad0c41913276eb3091975d06", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -40,6 +40,7 @@ use rustc::ty::{self, Ty, TypeFoldable, TypeAndMut};\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n+use rustc::ty::error::TypeError;\n use rustc::middle::lang_items;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -461,6 +462,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                              self.expr_ty,\n                                              fcx.tcx.mk_fn_ptr(f),\n                                              AllowTwoPhase::No);\n+                    if let Err(TypeError::IntrinsicCast) = res {\n+                        return Err(CastError::IllegalCast);\n+                    }\n                     if res.is_err() {\n                         return Err(CastError::NonScalar);\n                     }"}, {"sha": "f2e1a6e29d6fca09344839e42f75ea9c9581716f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -70,6 +70,7 @@ use std::ops::Deref;\n use syntax::feature_gate;\n use syntax::symbol::sym;\n use syntax_pos;\n+use rustc_target::spec::abi::Abi;\n \n struct Coerce<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -689,6 +690,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         match b.sty {\n             ty::FnPtr(_) => {\n                 let a_sig = a.fn_sig(self.tcx);\n+                // Intrinsics are not coercible to function pointers\n+                if a_sig.abi() == Abi::RustIntrinsic ||\n+                   a_sig.abi() == Abi::PlatformIntrinsic {\n+                   return Err(TypeError::IntrinsicCast);\n+                }\n                 let InferOk { value: a_sig, mut obligations } =\n                     self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n "}, {"sha": "fbaa9904d8303c0386954e2de62a0e31ab5bebc6", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 68, "deletions": 20, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -12,7 +12,7 @@ use crate::check::fatally_break_rust;\n use crate::check::report_unexpected_variant_res;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n-use crate::check::method::SelfSource;\n+use crate::check::method::{probe, SelfSource, MethodError};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n@@ -29,6 +29,7 @@ use rustc::hir::def::{CtorKind, Res, DefKind};\n use rustc::hir::ptr::P;\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::middle::lang_items;\n use rustc::mir::interpret::GlobalId;\n use rustc::ty;\n use rustc::ty::adjustment::{\n@@ -775,35 +776,80 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n-        let method = match self.lookup_method(rcvr_t,\n-                                              segment,\n-                                              span,\n-                                              expr,\n-                                              rcvr) {\n+        let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr) {\n             Ok(method) => {\n                 self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n                 if segment.ident.name != kw::Invalid {\n-                    self.report_method_error(span,\n-                                             rcvr_t,\n-                                             segment.ident,\n-                                             SelfSource::MethodCall(rcvr),\n-                                             error,\n-                                             Some(args));\n+                    self.report_extended_method_error(segment, span, args, rcvr_t, error);\n                 }\n                 Err(())\n             }\n         };\n \n         // Call the generic checker.\n-        self.check_method_argument_types(span,\n-                                         expr.span,\n-                                         method,\n-                                         &args[1..],\n-                                         DontTupleArguments,\n-                                         expected)\n+        self.check_method_argument_types(\n+            span,\n+            expr.span,\n+            method,\n+            &args[1..],\n+            DontTupleArguments,\n+            expected,\n+        )\n+    }\n+\n+    fn report_extended_method_error(\n+        &self,\n+        segment: &hir::PathSegment,\n+        span: Span,\n+        args: &'tcx [hir::Expr],\n+        rcvr_t: Ty<'tcx>,\n+        error: MethodError<'tcx>\n+    ) {\n+        let rcvr = &args[0];\n+        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n+            if let Ok(pick) = self.lookup_probe(\n+                span,\n+                segment.ident,\n+                new_rcvr_t,\n+                rcvr,\n+                probe::ProbeScope::AllTraits,\n+            ) {\n+                err.span_label(\n+                    pick.item.ident.span,\n+                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                );\n+            }\n+        };\n+\n+        if let Some(mut err) = self.report_method_error(\n+            span,\n+            rcvr_t,\n+            segment.ident,\n+            SelfSource::MethodCall(rcvr),\n+            error,\n+            Some(args),\n+        ) {\n+            if let ty::Adt(..) = rcvr_t.sty {\n+                // Try alternative arbitrary self types that could fulfill this call.\n+                // FIXME: probe for all types that *could* be arbitrary self-types, not\n+                // just this whitelist.\n+                let box_rcvr_t = self.tcx.mk_box(rcvr_t);\n+                try_alt_rcvr(&mut err, box_rcvr_t);\n+                let pin_rcvr_t = self.tcx.mk_lang_item(\n+                    rcvr_t,\n+                    lang_items::PinTypeLangItem,\n+                );\n+                try_alt_rcvr(&mut err, pin_rcvr_t);\n+                let arc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Arc);\n+                try_alt_rcvr(&mut err, arc_rcvr_t);\n+                let rc_rcvr_t = self.tcx.mk_lang_item(rcvr_t, lang_items::Rc);\n+                try_alt_rcvr(&mut err, rc_rcvr_t);\n+            }\n+            err.emit();\n+        }\n     }\n \n     fn check_expr_cast(\n@@ -1466,8 +1512,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let struct_variant_def = def.non_enum_variant();\n             let field_names = self.available_field_names(struct_variant_def);\n             if !field_names.is_empty() {\n-                err.note(&format!(\"available fields are: {}\",\n-                                    self.name_series_display(field_names)));\n+                err.note(&format!(\n+                    \"available fields are: {}\",\n+                    self.name_series_display(field_names),\n+                ));\n             }\n         }\n     }"}, {"sha": "1509c0f8a219601d66cc51f8d021f2c6f0c56a48", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(result.callee)\n     }\n \n-    fn lookup_probe(\n+    pub fn lookup_probe(\n         &self,\n         span: Span,\n         method_name: ast::Ident,"}, {"sha": "72e6f5971596092ab92b2fa39819ee86265089eb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -69,12 +69,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         source: SelfSource<'b>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr]>,\n-    ) {\n+    ) -> Option<DiagnosticBuilder<'_>> {\n         let orig_span = span;\n         let mut span = span;\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n-            return;\n+            return None;\n         }\n \n         let print_disambiguation_help = |\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => {}\n                         }\n                         err.emit();\n-                        return;\n+                        return None;\n                     } else {\n                         span = item_name.span;\n                         let mut err = struct_span_err!(\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                err.emit();\n+                return Some(err);\n             }\n \n             MethodError::Ambiguity(sources) => {\n@@ -573,6 +573,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 bug!(\"no return type expectations but got BadReturnType\")\n             }\n         }\n+        None\n     }\n \n     fn suggest_use_candidates(&self,"}, {"sha": "16903304a142782a8d4f51a86174491ab0ac2b88", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -3580,7 +3580,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     SelfSource::QPath(qself),\n                     error,\n                     None,\n-                );\n+                ).map(|mut e| e.emit());\n             }\n             result\n         });"}, {"sha": "826371be35f45a1af6cbef189268f8614f35ca39", "filename": "src/test/ui/if/if-without-else-as-fn-expr.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fif%2Fif-without-else-as-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fif%2Fif-without-else-as-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-without-else-as-fn-expr.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -3,15 +3,13 @@ fn foo(bar: usize) -> usize {\n         return 3;\n     }\n     //~^^^ ERROR if may be missing an else clause\n-    //~| ERROR mismatched types [E0308]\n }\n \n fn foo2(bar: usize) -> usize {\n     let x: usize = if bar % 5 == 0 {\n         return 3;\n     };\n     //~^^^ ERROR if may be missing an else clause\n-    //~| ERROR mismatched types [E0308]\n     x\n }\n \n@@ -20,23 +18,20 @@ fn foo3(bar: usize) -> usize {\n         3\n     }\n     //~^^^ ERROR if may be missing an else clause\n-    //~| ERROR mismatched types [E0308]\n }\n \n fn foo_let(bar: usize) -> usize {\n     if let 0 = 1 {\n         return 3;\n     }\n     //~^^^ ERROR if may be missing an else clause\n-    //~| ERROR mismatched types [E0308]\n }\n \n fn foo2_let(bar: usize) -> usize {\n     let x: usize = if let 0 = 1 {\n         return 3;\n     };\n     //~^^^ ERROR if may be missing an else clause\n-    //~| ERROR mismatched types [E0308]\n     x\n }\n \n@@ -45,7 +40,6 @@ fn foo3_let(bar: usize) -> usize {\n         3\n     }\n     //~^^^ ERROR if may be missing an else clause\n-    //~| ERROR mismatched types [E0308]\n }\n \n // FIXME(60254): deduplicate first error in favor of second."}, {"sha": "b49c2aa6319df94b873e7f45411e206137095c30", "filename": "src/test/ui/if/if-without-else-as-fn-expr.stderr", "status": "modified", "additions": 7, "deletions": 76, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fif%2Fif-without-else-as-fn-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fif%2Fif-without-else-as-fn-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-without-else-as-fn-expr.stderr?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -1,14 +1,3 @@\n-error[E0308]: mismatched types\n-  --> $DIR/if-without-else-as-fn-expr.rs:2:5\n-   |\n-LL | /     if bar % 5 == 0 {\n-LL | |         return 3;\n-LL | |     }\n-   | |_____^ expected usize, found ()\n-   |\n-   = note: expected type `usize`\n-              found type `()`\n-\n error[E0317]: if may be missing an else clause\n   --> $DIR/if-without-else-as-fn-expr.rs:2:5\n    |\n@@ -24,20 +13,8 @@ LL | |     }\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n \n-error[E0308]: mismatched types\n-  --> $DIR/if-without-else-as-fn-expr.rs:10:20\n-   |\n-LL |       let x: usize = if bar % 5 == 0 {\n-   |  ____________________^\n-LL | |         return 3;\n-LL | |     };\n-   | |_____^ expected usize, found ()\n-   |\n-   = note: expected type `usize`\n-              found type `()`\n-\n error[E0317]: if may be missing an else clause\n-  --> $DIR/if-without-else-as-fn-expr.rs:10:20\n+  --> $DIR/if-without-else-as-fn-expr.rs:9:20\n    |\n LL |       let x: usize = if bar % 5 == 0 {\n    |  _________-__________^\n@@ -52,19 +29,8 @@ LL | |     };\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n \n-error[E0308]: mismatched types\n-  --> $DIR/if-without-else-as-fn-expr.rs:19:5\n-   |\n-LL | /     if bar % 5 == 0 {\n-LL | |         3\n-LL | |     }\n-   | |_____^ expected usize, found ()\n-   |\n-   = note: expected type `usize`\n-              found type `()`\n-\n error[E0317]: if may be missing an else clause\n-  --> $DIR/if-without-else-as-fn-expr.rs:19:5\n+  --> $DIR/if-without-else-as-fn-expr.rs:17:5\n    |\n LL |   fn foo3(bar: usize) -> usize {\n    |                          ----- expected `usize` because of this return type\n@@ -78,19 +44,8 @@ LL | |     }\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n \n-error[E0308]: mismatched types\n-  --> $DIR/if-without-else-as-fn-expr.rs:27:5\n-   |\n-LL | /     if let 0 = 1 {\n-LL | |         return 3;\n-LL | |     }\n-   | |_____^ expected usize, found ()\n-   |\n-   = note: expected type `usize`\n-              found type `()`\n-\n error[E0317]: if may be missing an else clause\n-  --> $DIR/if-without-else-as-fn-expr.rs:27:5\n+  --> $DIR/if-without-else-as-fn-expr.rs:24:5\n    |\n LL |   fn foo_let(bar: usize) -> usize {\n    |                             ----- expected `usize` because of this return type\n@@ -104,20 +59,8 @@ LL | |     }\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n \n-error[E0308]: mismatched types\n-  --> $DIR/if-without-else-as-fn-expr.rs:35:20\n-   |\n-LL |       let x: usize = if let 0 = 1 {\n-   |  ____________________^\n-LL | |         return 3;\n-LL | |     };\n-   | |_____^ expected usize, found ()\n-   |\n-   = note: expected type `usize`\n-              found type `()`\n-\n error[E0317]: if may be missing an else clause\n-  --> $DIR/if-without-else-as-fn-expr.rs:35:20\n+  --> $DIR/if-without-else-as-fn-expr.rs:31:20\n    |\n LL |       let x: usize = if let 0 = 1 {\n    |  _________-__________^\n@@ -132,19 +75,8 @@ LL | |     };\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n \n-error[E0308]: mismatched types\n-  --> $DIR/if-without-else-as-fn-expr.rs:44:5\n-   |\n-LL | /     if let 0 = 1 {\n-LL | |         3\n-LL | |     }\n-   | |_____^ expected usize, found ()\n-   |\n-   = note: expected type `usize`\n-              found type `()`\n-\n error[E0317]: if may be missing an else clause\n-  --> $DIR/if-without-else-as-fn-expr.rs:44:5\n+  --> $DIR/if-without-else-as-fn-expr.rs:39:5\n    |\n LL |   fn foo3_let(bar: usize) -> usize {\n    |                              ----- expected `usize` because of this return type\n@@ -158,7 +90,6 @@ LL | |     }\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0308, E0317.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0317`."}, {"sha": "002b60f9f258dd41ee32f038363a4bb9efbe0db5", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -49,6 +49,14 @@ LL | use foo::Bar;\n error[E0599]: no method named `method` found for type `std::rc::Rc<&mut std::boxed::Box<&char>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:32:43\n    |\n+LL |         fn method(&self) {}\n+   |            ------\n+   |            |\n+   |            the method is available for `std::boxed::Box<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+   |            the method is available for `std::pin::Pin<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+   |            the method is available for `std::sync::Arc<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+   |            the method is available for `std::rc::Rc<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+...\n LL |     std::rc::Rc::new(&mut Box::new(&'a')).method();\n    |                                           ^^^^^^\n    |"}, {"sha": "f0f1dc6c28667758f4655f1fb856dc32aac97348", "filename": "src/test/ui/issues/issue-50577.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fissues%2Fissue-50577.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fissues%2Fissue-50577.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50577.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -2,6 +2,5 @@ fn main() {\n     enum Foo {\n         Drop = assert_eq!(1, 1)\n         //~^ ERROR if may be missing an else clause\n-        //~| ERROR mismatched types [E0308]\n     }\n }"}, {"sha": "0c3ba2ea4f94dabe1d95ab15c10e7ad590f6cefb", "filename": "src/test/ui/issues/issue-50577.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fissues%2Fissue-50577.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fissues%2Fissue-50577.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50577.stderr?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -1,13 +1,3 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-50577.rs:3:16\n-   |\n-LL |         Drop = assert_eq!(1, 1)\n-   |                ^^^^^^^^^^^^^^^^ expected isize, found ()\n-   |\n-   = note: expected type `isize`\n-              found type `()`\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n error[E0317]: if may be missing an else clause\n   --> $DIR/issue-50577.rs:3:16\n    |\n@@ -23,7 +13,6 @@ LL |         Drop = assert_eq!(1, 1)\n    = help: consider adding an `else` block that evaluates to the expected type\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0317.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0317`."}, {"sha": "09baa059e55679f5bbaa9d3a76c9db8b8d6f1996", "filename": "src/test/ui/reify-intrinsic.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Freify-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Freify-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freify-intrinsic.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -0,0 +1,15 @@\n+// check-fail\n+\n+#![feature(intrinsics)]\n+\n+fn a() {\n+    let _: unsafe extern \"rust-intrinsic\" fn(isize) -> usize = std::mem::transmute;\n+    //~^ ERROR cannot coerce\n+}\n+\n+fn b() {\n+    let _ = std::mem::transmute as unsafe extern \"rust-intrinsic\" fn(isize) -> usize;\n+    //~^ ERROR casting\n+}\n+\n+fn main() {}"}, {"sha": "4a1bd77cf7ee9839082c83da371dd9b180666c32", "filename": "src/test/ui/reify-intrinsic.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Freify-intrinsic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freify-intrinsic.stderr?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: cannot coerce intrinsics to function pointers\n+  --> $DIR/reify-intrinsic.rs:6:64\n+   |\n+LL |     let _: unsafe extern \"rust-intrinsic\" fn(isize) -> usize = std::mem::transmute;\n+   |                                                                ^^^^^^^^^^^^^^^^^^^\n+   |                                                                |\n+   |                                                                cannot coerce intrinsics to function pointers\n+   |                                                                help: use parentheses to call this function: `std::mem::transmute(...)`\n+   |\n+   = note: expected type `unsafe extern \"rust-intrinsic\" fn(isize) -> usize`\n+              found type `unsafe extern \"rust-intrinsic\" fn(_) -> _ {std::intrinsics::transmute::<_, _>}`\n+\n+error[E0606]: casting `unsafe extern \"rust-intrinsic\" fn(_) -> _ {std::intrinsics::transmute::<_, _>}` as `unsafe extern \"rust-intrinsic\" fn(isize) -> usize` is invalid\n+  --> $DIR/reify-intrinsic.rs:11:13\n+   |\n+LL |     let _ = std::mem::transmute as unsafe extern \"rust-intrinsic\" fn(isize) -> usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0606.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "0f7deeacad29278c31be5a36d1e6ceaefafb9d73", "filename": "src/test/ui/self/point-at-arbitrary-self-type-method.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -0,0 +1,9 @@\n+struct A;\n+\n+impl A {\n+    fn foo(self: Box<Self>) {}\n+}\n+\n+fn main() {\n+    A.foo(); //~ ERROR E0599\n+}"}, {"sha": "06dad7caa6735eb99a9bf19f1e578ae2f0008dcb", "filename": "src/test/ui/self/point-at-arbitrary-self-type-method.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: no method named `foo` found for type `A` in the current scope\n+  --> $DIR/point-at-arbitrary-self-type-method.rs:8:7\n+   |\n+LL | struct A;\n+   | --------- method `foo` not found for this\n+...\n+LL |     fn foo(self: Box<Self>) {}\n+   |        --- the method is available for `std::boxed::Box<A>` here\n+...\n+LL |     A.foo();\n+   |       ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "53d992771186f152d30e9e422902a4ec728b04d7", "filename": "src/test/ui/self/point-at-arbitrary-self-type-trait-method.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -0,0 +1,10 @@\n+trait B { fn foo(self: Box<Self>); }\n+struct A;\n+\n+impl B for A {\n+    fn foo(self: Box<Self>) {}\n+}\n+\n+fn main() {\n+    A.foo() //~ ERROR E0599\n+}"}, {"sha": "90cd3b807458014d8acc1d724c1d92775e439f09", "filename": "src/test/ui/self/point-at-arbitrary-self-type-trait-method.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -0,0 +1,18 @@\n+error[E0599]: no method named `foo` found for type `A` in the current scope\n+  --> $DIR/point-at-arbitrary-self-type-trait-method.rs:9:7\n+   |\n+LL | trait B { fn foo(self: Box<Self>); }\n+   |              --- the method is available for `std::boxed::Box<A>` here\n+LL | struct A;\n+   | --------- method `foo` not found for this\n+...\n+LL |     A.foo()\n+   |       ^^^\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the following trait defines an item `foo`, perhaps you need to implement it:\n+           candidate #1: `B`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "ce2919c8e77417c9eb0e000b62709679bc14c3b7", "filename": "src/test/ui/traits/trait-item-privacy.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -17,6 +17,13 @@ error[E0599]: no method named `b` found for type `S` in the current scope\n LL | struct S;\n    | --------- method `b` not found for this\n ...\n+LL |         fn b(&self) { }\n+   |            -\n+   |            |\n+   |            the method is available for `std::boxed::Box<S>` here\n+   |            the method is available for `std::sync::Arc<S>` here\n+   |            the method is available for `std::rc::Rc<S>` here\n+...\n LL |     S.b();\n    |       ^\n    |"}, {"sha": "467b7771c152eaea290ea808ba8c2cef0f106914", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9de4ef89e0e53099a084001b26ec3207c5f8391/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=b9de4ef89e0e53099a084001b26ec3207c5f8391", "patch": "@@ -335,7 +335,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n-        target: target,\n+        target,\n         host: opt_str2(matches.opt_str(\"host\")),\n         cdb,\n         gdb,\n@@ -345,7 +345,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         lldb_native_rust,\n         llvm_version: matches.opt_str(\"llvm-version\"),\n         system_llvm: matches.opt_present(\"system-llvm\"),\n-        android_cross_path: android_cross_path,\n+        android_cross_path,\n         adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n         adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n         adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")"}]}