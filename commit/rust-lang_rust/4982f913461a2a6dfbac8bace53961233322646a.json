{"sha": "4982f913461a2a6dfbac8bace53961233322646a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ODJmOTEzNDYxYTJhNmRmYmFjOGJhY2U1Mzk2MTIzMzMyMjY0NmE=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-03-07T23:35:01Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-03-14T20:49:12Z"}, "message": "fix FIXME(#6449) in #[derive(PartialOrd, Ord)]\n\nThis replaces some `if`s with `match`es. This was originally not possible\nbecause using a global path in a match statement caused a \"non-constant\npath in constant expr\" ICE. The issue is long since closed, though you still\nhit it (as an error now, not an ICE) if you try to generate match patterns\nusing pat_lit(expr_path). But it works when constructing the patterns more\ncarefully.", "tree": {"sha": "81bf96f174bb70d35e57a673c8e7b749db67b3ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81bf96f174bb70d35e57a673c8e7b749db67b3ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4982f913461a2a6dfbac8bace53961233322646a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4982f913461a2a6dfbac8bace53961233322646a", "html_url": "https://github.com/rust-lang/rust/commit/4982f913461a2a6dfbac8bace53961233322646a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4982f913461a2a6dfbac8bace53961233322646a/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d19f1b629918a556709e6b89a1929305db6449dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d19f1b629918a556709e6b89a1929305db6449dc", "html_url": "https://github.com/rust-lang/rust/commit/d19f1b629918a556709e6b89a1929305db6449dc"}], "stats": {"total": 103, "additions": 48, "deletions": 55}, "files": [{"sha": "f4082e0b123bf7b0ac3ee7acebb305055a663c82", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4982f913461a2a6dfbac8bace53961233322646a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982f913461a2a6dfbac8bace53961233322646a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=4982f913461a2a6dfbac8bace53961233322646a", "patch": "@@ -73,36 +73,31 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n     /*\n     Builds:\n \n-    let __test = ::std::cmp::Ord::cmp(&self_field1, &other_field1);\n-    if other == ::std::cmp::Ordering::Equal {\n-        let __test = ::std::cmp::Ord::cmp(&self_field2, &other_field2);\n-        if __test == ::std::cmp::Ordering::Equal {\n-            ...\n-        } else {\n-            __test\n-        }\n-    } else {\n-        __test\n+    match ::std::cmp::Ord::cmp(&self_field1, &other_field1) {\n+        ::std::cmp::Ordering::Equal =>\n+            match ::std::cmp::Ord::cmp(&self_field2, &other_field2) {\n+                ::std::cmp::Ordering::Equal => {\n+                    ...\n+                }\n+                __test => __test\n+            },\n+        __test => __test\n     }\n-\n-    FIXME #6449: These `if`s could/should be `match`es.\n     */\n     cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n         |cx, span, old, self_f, other_fs| {\n-            // let __test = new;\n-            // if __test == ::std::cmp::Ordering::Equal {\n-            //    old\n-            // } else {\n-            //    __test\n+            // match new {\n+            //     ::std::cmp::Ordering::Equal => old,\n+            //     __test => __test\n             // }\n \n             let new = {\n                 let other_f = match (other_fs.len(), other_fs.get(0)) {\n                     (1, Some(o_f)) => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n                 };\n \n                 let args = vec![\n@@ -113,20 +108,21 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n                 cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n-            let assign = cx.stmt_let(span, false, test_id, new);\n+            let eq_arm = cx.arm(span,\n+                                vec![cx.pat_enum(span,\n+                                                 equals_path.clone(),\n+                                                 vec![])],\n+                                old);\n+            let neq_arm = cx.arm(span,\n+                                 vec![cx.pat_ident(span, test_id)],\n+                                 cx.expr_ident(span, test_id));\n \n-            let cond = cx.expr_binary(span, BinOpKind::Eq,\n-                                      cx.expr_ident(span, test_id),\n-                                      cx.expr_path(equals_path.clone()));\n-            let if_ = cx.expr_if(span,\n-                                 cond,\n-                                 old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n+            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         cx.expr_path(equals_path.clone()),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derives(Ord)`\")\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n             } else {\n                 ordering_collapsed(cx, span, tag_tuple)\n             }"}, {"sha": "3353addebc971e748dd998c66329ff8416641f93", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4982f913461a2a6dfbac8bace53961233322646a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982f913461a2a6dfbac8bace53961233322646a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=4982f913461a2a6dfbac8bace53961233322646a", "patch": "@@ -110,38 +110,33 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n     let test_id = cx.ident_of(\"__test\");\n     let ordering = cx.path_global(span,\n                                   cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n-    let ordering = cx.expr_path(ordering);\n-    let equals_expr = cx.expr_some(span, ordering);\n+    let ordering_expr = cx.expr_path(ordering.clone());\n+    let equals_expr = cx.expr_some(span, ordering_expr);\n \n     let partial_cmp_path = cx.std_path(&[\"cmp\", \"PartialOrd\", \"partial_cmp\"]);\n \n     /*\n     Builds:\n \n-    let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1);\n-    if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n-        let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2);\n-        if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n-            ...\n-        } else {\n-            __test\n-        }\n-    } else {\n-        __test\n+    match ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1) {\n+        ::std::option::Option::Some(::std::cmp::Ordering::Equal) =>\n+            match ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2) {\n+                ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n+                    ...\n+                }\n+                __test => __test\n+            },\n+        __test => __test\n     }\n-\n-    FIXME #6449: These `if`s could/should be `match`es.\n     */\n     cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n         |cx, span, old, self_f, other_fs| {\n-            // let __test = new;\n-            // if __test == Some(::std::cmp::Ordering::Equal) {\n-            //    old\n-            // } else {\n-            //    __test\n+            // match new {\n+            //     Some(::std::cmp::Ordering::Equal) => old,\n+            //     __test => __test\n             // }\n \n             let new = {\n@@ -158,15 +153,17 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n                 cx.expr_call_global(span, partial_cmp_path.clone(), args)\n             };\n \n-            let assign = cx.stmt_let(span, false, test_id, new);\n-\n-            let cond = cx.expr_binary(span, BinOpKind::Eq,\n-                                      cx.expr_ident(span, test_id),\n-                                      equals_expr.clone());\n-            let if_ = cx.expr_if(span,\n-                                 cond,\n-                                 old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n+            let eq_arm = cx.arm(span,\n+                                vec![cx.pat_some(span,\n+                                                 cx.pat_enum(span,\n+                                                             ordering.clone(),\n+                                                             vec![]))],\n+                                old);\n+            let neq_arm = cx.arm(span,\n+                                 vec![cx.pat_ident(span, test_id)],\n+                                 cx.expr_ident(span, test_id));\n+\n+            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         equals_expr.clone(),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {"}]}