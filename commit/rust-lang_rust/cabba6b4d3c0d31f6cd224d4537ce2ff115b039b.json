{"sha": "cabba6b4d3c0d31f6cd224d4537ce2ff115b039b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYmJhNmI0ZDNjMGQzMWY2Y2QyMjRkNDUzN2NlMmZmMTE1YjAzOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-12T20:10:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-12T20:10:55Z"}, "message": "auto merge of #9136 : thestinger/rust/ptr, r=alexcrichton\n\nThis is mostly for consistency, as you can now compare raw pointers in\r\nconstant expressions or without the standard library.\r\n\r\nIt also reduces the number of `ptrtoint` instructions in the IR, making\r\ntracking down culprits of what's usually an anti-pattern easier.", "tree": {"sha": "4061452a7e4b01eaacbd92cfe8213730e9295360", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4061452a7e4b01eaacbd92cfe8213730e9295360"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b", "html_url": "https://github.com/rust-lang/rust/commit/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6be8d353bc25e160bc988e91744571547d12cab", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6be8d353bc25e160bc988e91744571547d12cab", "html_url": "https://github.com/rust-lang/rust/commit/a6be8d353bc25e160bc988e91744571547d12cab"}, {"sha": "b7435cf44783c9ab6cf16bc387299ed9891ae90d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7435cf44783c9ab6cf16bc387299ed9891ae90d", "html_url": "https://github.com/rust-lang/rust/commit/b7435cf44783c9ab6cf16bc387299ed9891ae90d"}], "stats": {"total": 73, "additions": 68, "deletions": 5}, "files": [{"sha": "e4b459bc34b344fa213564d356394da77cc0fa1a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cabba6b4d3c0d31f6cd224d4537ce2ff115b039b", "patch": "@@ -4267,6 +4267,7 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     static tycat_int: int = 3;\n     static tycat_float: int = 4;\n     static tycat_bot: int = 5;\n+    static tycat_raw_ptr: int = 6;\n \n     static opcat_add: int = 0;\n     static opcat_sub: int = 1;\n@@ -4310,6 +4311,7 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n           ty_float(_) | ty_infer(FloatVar(_)) => tycat_float,\n           ty_bot => tycat_bot,\n+          ty_ptr(_) => tycat_raw_ptr,\n           _ => tycat_other\n         }\n     }\n@@ -4324,7 +4326,8 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     /*char*/    [f, f, f, f,     t,   t,  f,   f],\n     /*int*/     [t, t, t, t,     t,   t,  t,   f],\n     /*float*/   [t, t, t, f,     t,   t,  f,   f],\n-    /*bot*/     [t, t, t, t,     f,   f,  t,   t]];\n+    /*bot*/     [t, t, t, t,     f,   f,  t,   t],\n+    /*raw ptr*/ [f, f, f, f,     t,   t,  f,   f]];\n \n     return tbl[tycat(cx, ty)][opcat(op)];\n }"}, {"sha": "6e90e2a1070b59aea6aeb383f74262a666eb5ade", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cabba6b4d3c0d31f6cd224d4537ce2ff115b039b/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=cabba6b4d3c0d31f6cd224d4537ce2ff115b039b", "patch": "@@ -383,7 +383,7 @@ impl<T> RawPtr<T> for *mut T {\n }\n \n // Equality for pointers\n-#[cfg(not(test))]\n+#[cfg(stage0, not(test))]\n impl<T> Eq for *T {\n     #[inline]\n     fn eq(&self, other: &*T) -> bool {\n@@ -393,7 +393,17 @@ impl<T> Eq for *T {\n     fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n }\n \n-#[cfg(not(test))]\n+#[cfg(not(stage0), not(test))]\n+impl<T> Eq for *T {\n+    #[inline]\n+    fn eq(&self, other: &*T) -> bool {\n+        *self == *other\n+    }\n+    #[inline]\n+    fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n+}\n+\n+#[cfg(stage0, not(test))]\n impl<T> Eq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -403,6 +413,16 @@ impl<T> Eq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n+#[cfg(not(stage0), not(test))]\n+impl<T> Eq for *mut T {\n+    #[inline]\n+    fn eq(&self, other: &*mut T) -> bool {\n+        *self == *other\n+    }\n+    #[inline]\n+    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n+}\n+\n // Equivalence for pointers\n #[cfg(not(test))]\n impl<T> Equiv<*mut T> for *T {\n@@ -460,7 +480,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[cfg(not(test))]\n+#[cfg(stage0, not(test))]\n impl<T> Ord for *T {\n     #[inline]\n     fn lt(&self, other: &*T) -> bool {\n@@ -480,7 +500,27 @@ impl<T> Ord for *T {\n     }\n }\n \n-#[cfg(not(test))]\n+#[cfg(not(stage0), not(test))]\n+impl<T> Ord for *T {\n+    #[inline]\n+    fn lt(&self, other: &*T) -> bool {\n+        *self < *other\n+    }\n+    #[inline]\n+    fn le(&self, other: &*T) -> bool {\n+        *self <= *other\n+    }\n+    #[inline]\n+    fn ge(&self, other: &*T) -> bool {\n+        *self >= *other\n+    }\n+    #[inline]\n+    fn gt(&self, other: &*T) -> bool {\n+        *self > *other\n+    }\n+}\n+\n+#[cfg(stage0, not(test))]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn lt(&self, other: &*mut T) -> bool {\n@@ -500,6 +540,26 @@ impl<T> Ord for *mut T {\n     }\n }\n \n+#[cfg(not(stage0), not(test))]\n+impl<T> Ord for *mut T {\n+    #[inline]\n+    fn lt(&self, other: &*mut T) -> bool {\n+        *self < *other\n+    }\n+    #[inline]\n+    fn le(&self, other: &*mut T) -> bool {\n+        *self <= *other\n+    }\n+    #[inline]\n+    fn ge(&self, other: &*mut T) -> bool {\n+        *self >= *other\n+    }\n+    #[inline]\n+    fn gt(&self, other: &*mut T) -> bool {\n+        *self > *other\n+    }\n+}\n+\n #[cfg(test)]\n pub mod ptr_tests {\n     use super::*;"}]}