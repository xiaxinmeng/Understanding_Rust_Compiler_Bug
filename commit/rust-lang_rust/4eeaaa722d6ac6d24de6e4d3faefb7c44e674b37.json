{"sha": "4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZWFhYTcyMmQ2YWM2ZDI0ZGU2ZTRkM2ZhZWZiN2M0NGU2NzRiMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-30T03:38:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-30T03:38:54Z"}, "message": "Auto merge of #63124 - Centril:rollup-onohtqt, r=Centril\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #61965 (Remove mentions of removed `offset_to` method from `align_offset` docs)\n - #62928 (Syntax: Recover on `for ( $pat in $expr ) $block`)\n - #63000 (Impl Debug for Chars)\n - #63083 (Make generic parameters always use modern hygiene)\n - #63087 (Add very simple edition check to tidy.)\n - #63093 (Properly check the defining scope of existential types)\n - #63096 (Add tests for some `existential_type` ICEs)\n - #63099 (vxworks: Remove Linux-specific comments.)\n - #63106 (ci: Skip installing SWIG/xz on OSX )\n - #63108 (Add links to None in Option doc)\n - #63109 (std: Fix a failing `fs` test on Windows)\n - #63111 (Add syntactic and semantic tests for rest patterns, i.e. `..`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ed3ee28acaee8ae750947dd3a224d9d1801e713d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed3ee28acaee8ae750947dd3a224d9d1801e713d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "html_url": "https://github.com/rust-lang/rust/commit/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b88a9eba8abbac87eddcb2998beea09589c2c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b88a9eba8abbac87eddcb2998beea09589c2c9", "html_url": "https://github.com/rust-lang/rust/commit/04b88a9eba8abbac87eddcb2998beea09589c2c9"}, {"sha": "91c10f8839156b3c3001271be17995806fb74e06", "url": "https://api.github.com/repos/rust-lang/rust/commits/91c10f8839156b3c3001271be17995806fb74e06", "html_url": "https://github.com/rust-lang/rust/commit/91c10f8839156b3c3001271be17995806fb74e06"}], "stats": {"total": 1289, "additions": 1042, "deletions": 247}, "files": [{"sha": "ca32888b74c34ce0ea2f3e7b4993ad78312a7828", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -62,17 +62,6 @@ steps:\n - template: install-sccache.yml\n - template: install-clang.yml\n \n-# Install some dependencies needed to build LLDB/Clang, currently only needed\n-# during the `dist` target\n-- bash: |\n-    set -e\n-    brew update\n-    brew install xz\n-    brew install swig@3\n-    brew link --force swig@3\n-  displayName: Install build dependencies (OSX)\n-  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'), eq(variables['SCRIPT'],'./x.py dist'))\n-\n # Switch to XCode 9.3 on OSX since it seems to be the last version that supports\n # i686-apple-darwin. We'll eventually want to upgrade this and it will probably\n # force us to drop i686-apple-darwin, but let's keep the wheels turning for now."}, {"sha": "c5198ca39fedf33788c6cd76b59afbbef42a2173", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -1108,6 +1108,16 @@ fn test_iterator_last() {\n     assert_eq!(it.last(), Some('m'));\n }\n \n+#[test]\n+fn test_chars_debug() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let c = s.chars();\n+    assert_eq!(\n+        format!(\"{:?}\", c),\n+        r#\"Chars(['\u0e28', '\u0e44', '\u0e17', '\u0e22', '\u4e2d', '\u534e', 'V', 'i', '\u1ec7', 't', ' ', 'N', 'a', 'm'])\"#\n+    );\n+}\n+\n #[test]\n fn test_bytesator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";"}, {"sha": "7713e5761d4bd03c886ef98fe4e712aa6e4322e2", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -8,7 +8,7 @@\n //! * Initial values\n //! * Return values for functions that are not defined\n //!   over their entire input range (partial functions)\n-//! * Return value for otherwise reporting simple errors, where `None` is\n+//! * Return value for otherwise reporting simple errors, where [`None`] is\n //!   returned on error\n //! * Optional struct fields\n //! * Struct fields that can be loaned or \"taken\"\n@@ -752,7 +752,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns `None`.\n+    /// Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns [`None`].\n     ///\n     /// [`Some`]: #variant.Some\n     /// [`None`]: #variant.None"}, {"sha": "a1f96905dc99b269b8eb2139caca613f9391d3f0", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -1609,7 +1609,7 @@ impl<T: ?Sized> *const T {\n     /// `usize::max_value()`.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n-    /// used with the `offset` or `offset_to` methods.\n+    /// used with the `add` method.\n     ///\n     /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n     /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n@@ -2410,7 +2410,7 @@ impl<T: ?Sized> *mut T {\n     /// `usize::max_value()`.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n-    /// used with the `offset` or `offset_to` methods.\n+    /// used with the `add` method.\n     ///\n     /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n     /// beyond the allocation that the pointer points into. It is up to the caller to ensure that"}, {"sha": "4faf9ff4d2ee2ca7eb2db4dd58bd5c0072929837", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -464,7 +464,7 @@ Section: Iterators\n ///\n /// [`chars`]: ../../std/primitive.str.html#method.chars\n /// [`str`]: ../../std/primitive.str.html\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n@@ -600,6 +600,16 @@ impl<'a> Iterator for Chars<'a> {\n     }\n }\n \n+#[stable(feature = \"chars_debug_impl\", since = \"1.38.0\")]\n+impl fmt::Debug for Chars<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Chars(\")?;\n+        f.debug_list().entries(self.clone()).finish()?;\n+        write!(f, \")\")?;\n+        Ok(())\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]"}, {"sha": "73a76ebcb74f412e95b6212a7f00ec9e2f32181e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -1189,11 +1189,7 @@ pub fn may_define_existential_type(\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    trace!(\n-        \"may_define_existential_type(def={:?}, opaque_node={:?})\",\n-        tcx.hir().get(hir_id),\n-        tcx.hir().get(opaque_hir_id)\n-    );\n+\n \n     // Named existential types can be defined by any siblings or children of siblings.\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n@@ -1202,5 +1198,12 @@ pub fn may_define_existential_type(\n         hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n     // Syntactically, we are allowed to define the concrete type if:\n-    hir_id == scope\n+    let res = hir_id == scope;\n+    trace!(\n+        \"may_define_existential_type(def={:?}, opaque_node={:?}) = {}\",\n+        tcx.hir().get(hir_id),\n+        tcx.hir().get(opaque_hir_id),\n+        res\n+    );\n+    res\n }"}, {"sha": "f6c62d191fa629ea6c82cb191c85588ca5606730", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -2568,7 +2568,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let lifetimes: Vec<_> = params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => Some((param, param.name)),\n+                GenericParamKind::Lifetime { .. } => Some((param, param.name.modern())),\n                 _ => None,\n             })\n             .collect();"}, {"sha": "c8dd8282fd0f9055dcd95a6c4ed1a6fdbd4dbbd5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -869,8 +869,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         debug!(\"(resolving function) entering function\");\n         let rib_kind = match function_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n-            FnKind::Method(..) => AssocItemRibKind,\n-            FnKind::Closure(_) => NormalRibKind,\n+            FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n         };\n \n         // Create a value rib for the function.\n@@ -2307,21 +2306,32 @@ impl<'a> Resolver<'a> {\n         if ident.name == kw::Invalid {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n-        ident.span = if ident.name == kw::SelfUpper {\n+        let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n-            ident.span.with_ctxt(SyntaxContext::empty())\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::empty());\n+            (empty_span, empty_span)\n         } else if ns == TypeNS {\n-            ident.span.modern()\n+            let modern_span = ident.span.modern();\n+            (modern_span, modern_span)\n         } else {\n-            ident.span.modern_and_legacy()\n+            (ident.span.modern_and_legacy(), ident.span.modern())\n         };\n+        ident.span = general_span;\n+        let modern_ident = Ident { span: modern_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n         let record_used = record_used_id.is_some();\n         let mut module = self.graph_root;\n         for i in (0 .. self.ribs[ns].len()).rev() {\n             debug!(\"walk rib\\n{:?}\", self.ribs[ns][i].bindings);\n-            if let Some(res) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n+            // Use the rib kind to determine whether we are resolving parameters\n+            // (modern hygiene) or local variables (legacy hygiene).\n+            let rib_ident = if let AssocItemRibKind | ItemRibKind = self.ribs[ns][i].kind {\n+                modern_ident\n+            } else {\n+                ident\n+            };\n+            if let Some(res) = self.ribs[ns][i].bindings.get(&rib_ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Res(\n                     self.validate_res_from_ribs(ns, i, res, record_used, path_span),\n@@ -2357,7 +2367,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident.span = ident.span.modern();\n+        ident = modern_ident;\n         let mut poisoned = None;\n         loop {\n             let opt_module = if let Some(node_id) = record_used_id {"}, {"sha": "395e266ae46aab57677899dc51d93ad87472fe10", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -1664,6 +1664,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n         fn visit_item(&mut self, it: &'tcx Item) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n@@ -1672,6 +1673,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The existential type itself or its children are not within its reveal scope.\n             if def_id != self.def_id {\n@@ -1680,6 +1682,7 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n@@ -1703,9 +1706,23 @@ fn find_existential_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     } else {\n         debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n-            Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n-            Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n-            Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n+            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // ```\n+            // fn foo() {\n+            //     existential type Blah: Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            // ```\n+            //\n+            // requires us to explicitly process `foo()` in order\n+            // to notice the defining usage of `Blah`.\n+            Node::Item(ref it) => locator.visit_item(it),\n+            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n+            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n             other => bug!(\n                 \"{:?} is not a valid scope for an existential type item\",\n                 other"}, {"sha": "f7c32a5c20d3d0aacd8562170fc7a8749806730f", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -3316,11 +3316,11 @@ mod tests {\n         fs::create_dir_all(&d).unwrap();\n         File::create(&f).unwrap();\n         if cfg!(not(windows)) {\n-            symlink_dir(\"../d/e\", &c).unwrap();\n+            symlink_file(\"../d/e\", &c).unwrap();\n             symlink_file(\"../f\", &e).unwrap();\n         }\n         if cfg!(windows) {\n-            symlink_dir(r\"..\\d\\e\", &c).unwrap();\n+            symlink_file(r\"..\\d\\e\", &c).unwrap();\n             symlink_file(r\"..\\f\", &e).unwrap();\n         }\n "}, {"sha": "d537d2258fda79318915d0646021776fd76cd807", "filename": "src/libstd/sys/vxworks/fs.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Ffs.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -287,22 +287,7 @@ impl File {\n         let fd = cvt_r(|| unsafe {\n             open(path.as_ptr(), flags, opts.mode as c_int)\n         })?;\n-        let fd = FileDesc::new(fd);\n-        // Currently the standard library supports Linux 2.6.18 which did not\n-        // have the O_CLOEXEC flag (passed above). If we're running on an older\n-        // Linux kernel then the flag is just ignored by the OS. After we open\n-        // the first file, we check whether it has CLOEXEC set. If it doesn't,\n-        // we will explicitly ask for a CLOEXEC fd for every further file we\n-        // open, if it does, we will skip that step.\n-        //\n-        // The CLOEXEC flag, however, is supported on versions of macOS/BSD/etc\n-        // that we support, so we only do this on Linux currently.\n-        fn ensure_cloexec(_: &FileDesc) -> io::Result<()> {\n-            Ok(())\n-        }\n-\n-        ensure_cloexec(&fd)?;\n-        Ok(File(fd))\n+        Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {"}, {"sha": "56962e11dcf95a4c646e13827f6732bf1c86b0de", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -141,10 +141,6 @@ impl Socket {\n \n     pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n                   -> io::Result<Socket> {\n-        // Unfortunately the only known way right now to accept a socket and\n-        // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n-        // Linux. This was added in 2.6.28, however, and because we support\n-        // 2.6.18 we must detect this support dynamically.\n         let fd = cvt_r(|| unsafe {\n             libc::accept(self.0.raw(), storage, len)\n         })?;"}, {"sha": "e09dbe6e99ba8898bc71f29294b721fd1b0d25df", "filename": "src/libstd/sys/vxworks/pipe.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fpipe.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -11,11 +11,6 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     static INVALID: AtomicBool = AtomicBool::new(false);\n \n     let mut fds = [0; 2];\n-\n-    // Unfortunately the only known way right now to create atomically set the\n-    // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n-    // 2.6.27, however, and because we support 2.6.18 we must detect this\n-    // support dynamically.\n     cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n \n     let fd0 = FileDesc::new(fds[0]);"}, {"sha": "9eb6aa303b06bc4fda94e50fb4938449cd89245a", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 81, "deletions": 37, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -14,7 +14,7 @@ use crate::ThinVec;\n use crate::util::parser::AssocOp;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_data_structures::fx::FxHashSet;\n-use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan, SpanSnippetError};\n use log::{debug, trace};\n use std::mem;\n \n@@ -199,6 +199,10 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n+    crate fn span_to_snippet(&self, span: Span) -> Result<String, SpanSnippetError> {\n+        self.sess.source_map().span_to_snippet(span)\n+    }\n+\n     crate fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n         let mut err = self.struct_span_err(\n             self.token.span,\n@@ -549,8 +553,10 @@ impl<'a> Parser<'a> {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n                 let op_span = op.span.to(self.token.span);\n-                let mut err = self.diagnostic().struct_span_err(op_span,\n-                    \"chained comparison operators require parentheses\");\n+                let mut err = self.struct_span_err(\n+                    op_span,\n+                    \"chained comparison operators require parentheses\",\n+                );\n                 if op.node == BinOpKind::Lt &&\n                     *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n                     *outer_op == AssocOp::Greater  // even in a case like the following:\n@@ -717,8 +723,6 @@ impl<'a> Parser<'a> {\n         path.span = ty_span.to(self.prev_span);\n \n         let ty_str = self\n-            .sess\n-            .source_map()\n             .span_to_snippet(ty_span)\n             .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n         self.diagnostic()\n@@ -889,7 +893,7 @@ impl<'a> Parser<'a> {\n             err.span_label(await_sp, \"while parsing this incorrect await expression\");\n             err\n         })?;\n-        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n+        let expr_str = self.span_to_snippet(expr.span)\n             .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n         let suggestion = format!(\"{}.await{}\", expr_str, if is_question { \"?\" } else { \"\" });\n         let sp = lo.to(expr.span);\n@@ -923,6 +927,48 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Recover a situation like `for ( $pat in $expr )`\n+    /// and suggest writing `for $pat in $expr` instead.\n+    ///\n+    /// This should be called before parsing the `$block`.\n+    crate fn recover_parens_around_for_head(\n+        &mut self,\n+        pat: P<Pat>,\n+        expr: &Expr,\n+        begin_paren: Option<Span>,\n+    ) -> P<Pat> {\n+        match (&self.token.kind, begin_paren) {\n+            (token::CloseDelim(token::Paren), Some(begin_par_sp)) => {\n+                self.bump();\n+\n+                let pat_str = self\n+                    // Remove the `(` from the span of the pattern:\n+                    .span_to_snippet(pat.span.trim_start(begin_par_sp).unwrap())\n+                    .unwrap_or_else(|_| pprust::pat_to_string(&pat));\n+\n+                self.struct_span_err(self.prev_span, \"unexpected closing `)`\")\n+                    .span_label(begin_par_sp, \"opening `(`\")\n+                    .span_suggestion(\n+                        begin_par_sp.to(self.prev_span),\n+                        \"remove parenthesis in `for` loop\",\n+                        format!(\"{} in {}\", pat_str, pprust::expr_to_string(&expr)),\n+                        // With e.g. `for (x) in y)` this would replace `(x) in y)`\n+                        // with `x) in y)` which is syntactically invalid.\n+                        // However, this is prevented before we get here.\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+\n+                // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint.\n+                pat.and_then(|pat| match pat.node {\n+                    PatKind::Paren(pat) => pat,\n+                    _ => P(pat),\n+                })\n+            }\n+            _ => pat,\n+        }\n+    }\n+\n     crate fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n         self.token.is_ident() &&\n             if let ast::ExprKind::Path(..) = node { true } else { false } &&\n@@ -1105,17 +1151,14 @@ impl<'a> Parser<'a> {\n     crate fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n         if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n-            let mut err = self.sess.span_diagnostic.struct_span_err(\n-                self.prev_span,\n-                \"expected iterable, found keyword `in`\",\n-            );\n-            err.span_suggestion_short(\n-                in_span.until(self.prev_span),\n-                \"remove the duplicated `in`\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.struct_span_err(self.prev_span, \"expected iterable, found keyword `in`\")\n+                .span_suggestion_short(\n+                    in_span.until(self.prev_span),\n+                    \"remove the duplicated `in`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n         }\n     }\n \n@@ -1128,12 +1171,12 @@ impl<'a> Parser<'a> {\n \n     crate fn eat_incorrect_doc_comment_for_arg_type(&mut self) {\n         if let token::DocComment(_) = self.token.kind {\n-            let mut err = self.diagnostic().struct_span_err(\n+            self.struct_span_err(\n                 self.token.span,\n                 \"documentation comments cannot be applied to a function parameter's type\",\n-            );\n-            err.span_label(self.token.span, \"doc comments are not allowed here\");\n-            err.emit();\n+            )\n+            .span_label(self.token.span, \"doc comments are not allowed here\")\n+            .emit();\n             self.bump();\n         } else if self.token == token::Pound && self.look_ahead(1, |t| {\n             *t == token::OpenDelim(token::Bracket)\n@@ -1145,12 +1188,12 @@ impl<'a> Parser<'a> {\n             }\n             let sp = lo.to(self.token.span);\n             self.bump();\n-            let mut err = self.diagnostic().struct_span_err(\n+            self.struct_span_err(\n                 sp,\n                 \"attributes cannot be applied to a function parameter's type\",\n-            );\n-            err.span_label(sp, \"attributes are not allowed here\");\n-            err.emit();\n+            )\n+            .span_label(sp, \"attributes are not allowed here\")\n+            .emit();\n         }\n     }\n \n@@ -1206,18 +1249,19 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        let mut err = self.diagnostic().struct_span_err_with_code(\n-            pat.span,\n-            \"patterns aren't allowed in methods without bodies\",\n-            DiagnosticId::Error(\"E0642\".into()),\n-        );\n-        err.span_suggestion_short(\n-            pat.span,\n-            \"give this argument a name or use an underscore to ignore it\",\n-            \"_\".to_owned(),\n-            Applicability::MachineApplicable,\n-        );\n-        err.emit();\n+        self.diagnostic()\n+            .struct_span_err_with_code(\n+                pat.span,\n+                \"patterns aren't allowed in methods without bodies\",\n+                DiagnosticId::Error(\"E0642\".into()),\n+            )\n+            .span_suggestion_short(\n+                pat.span,\n+                \"give this argument a name or use an underscore to ignore it\",\n+                \"_\".to_owned(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n \n         // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n         let pat = P(Pat {"}, {"sha": "fb5ff7e8f9862f8acf4b982cd4943b1de4307c79", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 136, "deletions": 125, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -2329,19 +2329,19 @@ impl<'a> Parser<'a> {\n             // This is a struct literal, but we don't can't accept them here\n             let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n-                let mut err = self.diagnostic().struct_span_err(\n+                self.struct_span_err(\n                     expr.span,\n                     \"struct literals are not allowed here\",\n-                );\n-                err.multipart_suggestion(\n+                )\n+                .multipart_suggestion(\n                     \"surround the struct literal with parentheses\",\n                     vec![\n                         (lo.shrink_to_lo(), \"(\".to_string()),\n                         (expr.span.shrink_to_hi(), \")\".to_string()),\n                     ],\n                     Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                )\n+                .emit();\n             }\n             return Some(expr);\n         }\n@@ -2370,18 +2370,18 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 if self.token == token::Comma {\n-                    let mut err = self.sess.span_diagnostic.mut_span_err(\n+                    self.struct_span_err(\n                         exp_span.to(self.prev_span),\n                         \"cannot use a comma after the base struct\",\n-                    );\n-                    err.span_suggestion_short(\n+                    )\n+                    .span_suggestion_short(\n                         self.token.span,\n                         \"remove this comma\",\n                         String::new(),\n                         Applicability::MachineApplicable\n-                    );\n-                    err.note(\"the base struct must always be the last field\");\n-                    err.emit();\n+                    )\n+                    .note(\"the base struct must always be the last field\")\n+                    .emit();\n                     self.recover_stmt();\n                 }\n                 break;\n@@ -2736,15 +2736,14 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span_of_tilde = lo;\n-                let mut err = self.diagnostic()\n-                    .struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\");\n-                err.span_suggestion_short(\n-                    span_of_tilde,\n-                    \"use `!` to perform bitwise negation\",\n-                    \"!\".to_owned(),\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                self.struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\")\n+                    .span_suggestion_short(\n+                        span_of_tilde,\n+                        \"use `!` to perform bitwise negation\",\n+                        \"!\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n                 (lo.to(span), self.mk_unary(UnOp::Not, e))\n             }\n             token::BinOp(token::Minus) => {\n@@ -2792,21 +2791,20 @@ impl<'a> Parser<'a> {\n                 if cannot_continue_expr {\n                     self.bump();\n                     // Emit the error ...\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(self.token.span,\n-                                         &format!(\"unexpected {} after identifier\",\n-                                                  self.this_token_descr()));\n-                    // span the `not` plus trailing whitespace to avoid\n-                    // trailing whitespace after the `!` in our suggestion\n-                    let to_replace = self.sess.source_map()\n-                        .span_until_non_whitespace(lo.to(self.token.span));\n-                    err.span_suggestion_short(\n-                        to_replace,\n+                    self.struct_span_err(\n+                        self.token.span,\n+                        &format!(\"unexpected {} after identifier\",self.this_token_descr())\n+                    )\n+                    .span_suggestion_short(\n+                        // Span the `not` plus trailing whitespace to avoid\n+                        // trailing whitespace after the `!` in our suggestion\n+                        self.sess.source_map()\n+                            .span_until_non_whitespace(lo.to(self.token.span)),\n                         \"use `!` to perform logical negation\",\n                         \"!\".to_owned(),\n                         Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+                    )\n+                    .emit();\n                     // \u2014and recover! (just as if we were in the block\n                     // for the `token::Not` arm)\n                     let e = self.parse_prefix_expr(None);\n@@ -2884,7 +2882,7 @@ impl<'a> Parser<'a> {\n                 // We've found an expression that would be parsed as a statement, but the next\n                 // token implies this should be parsed as an expression.\n                 // For example: `if let Some(x) = x { x } else { 0 } / 2`\n-                let mut err = self.sess.span_diagnostic.struct_span_err(self.token.span, &format!(\n+                let mut err = self.struct_span_err(self.token.span, &format!(\n                     \"expected expression, found `{}`\",\n                     pprust::token_to_string(&self.token),\n                 ));\n@@ -3072,28 +3070,29 @@ impl<'a> Parser<'a> {\n                         // in AST and continue parsing.\n                         let msg = format!(\"`<` is interpreted as a start of generic \\\n                                            arguments for `{}`, not a {}\", path, op_noun);\n-                        let mut err =\n-                            self.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n                         let span_after_type = parser_snapshot_after_type.token.span;\n-                        err.span_label(self.look_ahead(1, |t| t.span).to(span_after_type),\n-                                       \"interpreted as generic arguments\");\n-                        err.span_label(self.token.span, format!(\"not interpreted as {}\", op_noun));\n-\n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,\n                             node: TyKind::Path(None, path),\n                             id: ast::DUMMY_NODE_ID\n                         }));\n \n-                        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n-                                                .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"try {} the cast value\", op_verb),\n-                            format!(\"({})\", expr_str),\n-                            Applicability::MachineApplicable\n-                        );\n-                        err.emit();\n+                        let expr_str = self.span_to_snippet(expr.span)\n+                            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n+\n+                        self.struct_span_err(self.token.span, &msg)\n+                            .span_label(\n+                                self.look_ahead(1, |t| t.span).to(span_after_type),\n+                                \"interpreted as generic arguments\"\n+                            )\n+                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n+                            .span_suggestion(\n+                                expr.span,\n+                                &format!(\"try {} the cast value\", op_verb),\n+                                format!(\"({})\", expr_str),\n+                                Applicability::MachineApplicable\n+                            )\n+                            .emit();\n \n                         Ok(expr)\n                     }\n@@ -3276,26 +3275,40 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    fn parse_for_expr(&mut self, opt_label: Option<Label>,\n-                          span_lo: Span,\n-                          mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_for_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n+        // Record whether we are about to parse `for (`.\n+        // This is used below for recovery in case of `for ( $stuff ) $block`\n+        // in which case we will suggest `for $stuff $block`.\n+        let begin_paren = match self.token.kind {\n+            token::OpenDelim(token::Paren) => Some(self.token.span),\n+            _ => None,\n+        };\n+\n         let pat = self.parse_top_level_pat()?;\n         if !self.eat_keyword(kw::In) {\n             let in_span = self.prev_span.between(self.token.span);\n-            let mut err = self.sess.span_diagnostic\n-                .struct_span_err(in_span, \"missing `in` in `for` loop\");\n-            err.span_suggestion_short(\n-                in_span, \"try adding `in` here\", \" in \".into(),\n-                // has been misleading, at least in the past (closed Issue #48492)\n-                Applicability::MaybeIncorrect\n-            );\n-            err.emit();\n+            self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n+                .span_suggestion_short(\n+                    in_span,\n+                    \"try adding `in` here\", \" in \".into(),\n+                    // has been misleading, at least in the past (closed Issue #48492)\n+                    Applicability::MaybeIncorrect\n+                )\n+                .emit();\n         }\n         let in_span = self.prev_span;\n         self.check_for_for_in_in_typo(in_span);\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+\n+        let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n+\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n@@ -3522,15 +3535,14 @@ impl<'a> Parser<'a> {\n             pats.push(self.parse_top_level_pat()?);\n \n             if self.token == token::OrOr {\n-                let mut err = self.struct_span_err(self.token.span,\n-                                                   \"unexpected token `||` after pattern\");\n-                err.span_suggestion(\n-                    self.token.span,\n-                    \"use a single `|` to specify multiple patterns\",\n-                    \"|\".to_owned(),\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\")\n+                    .span_suggestion(\n+                        self.token.span,\n+                        \"use a single `|` to specify multiple patterns\",\n+                        \"|\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n                 self.bump();\n             } else if self.eat(&token::BinOp(token::Or)) {\n                 // This is a No-op. Continue the loop to parse the next\n@@ -3627,15 +3639,14 @@ impl<'a> Parser<'a> {\n \n                 if self.token == token::DotDotDot { // Issue #46718\n                     // Accept `...` as if it were `..` to avoid further errors\n-                    let mut err = self.struct_span_err(self.token.span,\n-                                                       \"expected field pattern, found `...`\");\n-                    err.span_suggestion(\n-                        self.token.span,\n-                        \"to omit remaining fields, use one fewer `.`\",\n-                        \"..\".to_owned(),\n-                        Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+                        .span_suggestion(\n+                            self.token.span,\n+                            \"to omit remaining fields, use one fewer `.`\",\n+                            \"..\".to_owned(),\n+                            Applicability::MachineApplicable\n+                        )\n+                        .emit();\n                 }\n                 self.bump();  // `..` || `...`\n \n@@ -3788,7 +3799,7 @@ impl<'a> Parser<'a> {\n             let seq_span = pat.span.to(self.prev_span);\n             let mut err = self.struct_span_err(comma_span,\n                                                \"unexpected `,` in pattern\");\n-            if let Ok(seq_snippet) = self.sess.source_map().span_to_snippet(seq_span) {\n+            if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n                 err.span_suggestion(\n                     seq_span,\n                     \"try adding parentheses to match on a tuple..\",\n@@ -4137,7 +4148,7 @@ impl<'a> Parser<'a> {\n                     let parser_snapshot_after_type = self.clone();\n                     mem::replace(self, parser_snapshot_before_type);\n \n-                    let snippet = self.sess.source_map().span_to_snippet(pat.span).unwrap();\n+                    let snippet = self.span_to_snippet(pat.span).unwrap();\n                     err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n                     (Some((parser_snapshot_after_type, colon_sp, err)), None)\n                 }\n@@ -4557,7 +4568,7 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Semi) {\n                         stmt_span = stmt_span.with_hi(self.prev_span.hi());\n                     }\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(stmt_span) {\n+                    if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n                         e.span_suggestion(\n                             stmt_span,\n                             \"try placing this code inside a block\",\n@@ -4730,7 +4741,7 @@ impl<'a> Parser<'a> {\n                             lo.to(self.prev_span),\n                             \"parenthesized lifetime bounds are not supported\"\n                         );\n-                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(inner_span) {\n+                        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n                             err.span_suggestion_short(\n                                 lo.to(self.prev_span),\n                                 \"remove the parentheses\",\n@@ -4788,7 +4799,7 @@ impl<'a> Parser<'a> {\n                 let mut new_bound_list = String::new();\n                 if !bounds.is_empty() {\n                     let mut snippets = bounds.iter().map(|bound| bound.span())\n-                        .map(|span| self.sess.source_map().span_to_snippet(span));\n+                        .map(|span| self.span_to_snippet(span));\n                     while let Some(Ok(snippet)) = snippets.next() {\n                         new_bound_list.push_str(\" + \");\n                         new_bound_list.push_str(&snippet);\n@@ -5853,15 +5864,16 @@ impl<'a> Parser<'a> {\n                 if let token::DocComment(_) = self.token.kind {\n                     if self.look_ahead(1,\n                     |tok| tok == &token::CloseDelim(token::Brace)) {\n-                        let mut err = self.diagnostic().struct_span_err_with_code(\n+                        self.diagnostic().struct_span_err_with_code(\n                             self.token.span,\n                             \"found a documentation comment that doesn't document anything\",\n                             DiagnosticId::Error(\"E0584\".into()),\n-                        );\n-                        err.help(\"doc comments must come before what they document, maybe a \\\n+                        )\n+                        .help(\n+                            \"doc comments must come before what they document, maybe a \\\n                             comment was intended with `//`?\",\n-                        );\n-                        err.emit();\n+                        )\n+                        .emit();\n                         self.bump();\n                         continue;\n                     }\n@@ -6305,12 +6317,15 @@ impl<'a> Parser<'a> {\n                 let sp = path.span;\n                 let help_msg = format!(\"make this visible only to module `{}` with `in`\", path);\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                let mut err = struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg);\n-                err.help(suggestion);\n-                err.span_suggestion(\n-                    sp, &help_msg, format!(\"in {}\", path), Applicability::MachineApplicable\n-                );\n-                err.emit();  // emit diagnostic, but continue with public visibility\n+                struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg)\n+                    .help(suggestion)\n+                    .span_suggestion(\n+                        sp,\n+                        &help_msg,\n+                        format!(\"in {}\", path),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();  // emit diagnostic, but continue with public visibility\n             }\n         }\n \n@@ -6744,14 +6759,10 @@ impl<'a> Parser<'a> {\n             }\n             ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n \n-            let mut err = self.struct_span_err(fixed_name_sp, error_msg);\n-            err.span_label(fixed_name_sp, \"dash-separated idents are not valid\");\n-            err.multipart_suggestion(\n-                suggestion_msg,\n-                replacement,\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.struct_span_err(fixed_name_sp, error_msg)\n+                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n+                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n+                .emit();\n         }\n         Ok(ident)\n     }\n@@ -6906,14 +6917,14 @@ impl<'a> Parser<'a> {\n             if !self.eat(&token::Comma) {\n                 if self.token.is_ident() && !self.token.is_reserved_ident() {\n                     let sp = self.sess.source_map().next_point(self.prev_span);\n-                    let mut err = self.struct_span_err(sp, \"missing comma\");\n-                    err.span_suggestion_short(\n-                        sp,\n-                        \"missing comma\",\n-                        \",\".to_owned(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.emit();\n+                    self.struct_span_err(sp, \"missing comma\")\n+                        .span_suggestion_short(\n+                            sp,\n+                            \"missing comma\",\n+                            \",\".to_owned(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n                 } else {\n                     break;\n                 }\n@@ -6952,15 +6963,16 @@ impl<'a> Parser<'a> {\n                     Some(abi) => Ok(Some(abi)),\n                     None => {\n                         let prev_span = self.prev_span;\n-                        let mut err = struct_span_err!(\n+                        struct_span_err!(\n                             self.sess.span_diagnostic,\n                             prev_span,\n                             E0703,\n                             \"invalid ABI: found `{}`\",\n-                            symbol);\n-                        err.span_label(prev_span, \"invalid ABI\");\n-                        err.help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")));\n-                        err.emit();\n+                            symbol\n+                        )\n+                        .span_label(prev_span, \"invalid ABI\")\n+                        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+                        .emit();\n                         Ok(None)\n                     }\n                 }\n@@ -7130,16 +7142,15 @@ impl<'a> Parser<'a> {\n             // CONST ITEM\n             if self.eat_keyword(kw::Mut) {\n                 let prev_span = self.prev_span;\n-                let mut err = self.diagnostic()\n-                    .struct_span_err(prev_span, \"const globals cannot be mutable\");\n-                err.span_label(prev_span, \"cannot be mutable\");\n-                err.span_suggestion(\n-                    const_span,\n-                    \"you might want to declare a static instead\",\n-                    \"static\".to_owned(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n+                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n+                    .span_label(prev_span, \"cannot be mutable\")\n+                    .span_suggestion(\n+                        const_span,\n+                        \"you might want to declare a static instead\",\n+                        \"static\".to_owned(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n             let prev_span = self.prev_span;\n@@ -7407,7 +7418,7 @@ impl<'a> Parser<'a> {\n                         sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n                     );\n                 } else {\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(ident_sp) {\n+                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n                         err.span_suggestion(\n                             full_sp,\n                             \"if you meant to call a macro, try\","}, {"sha": "73fdee71f0c0ba6a2f265be059a5f4736306975e", "filename": "src/test/run-make/thumb-none-qemu/example/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Frun-make%2Fthumb-none-qemu%2Fexample%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Frun-make%2Fthumb-none-qemu%2Fexample%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fthumb-none-qemu%2Fexample%2FCargo.toml?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -2,7 +2,7 @@\n name = \"example\"\n version = \"0.1.0\"\n authors = [\"Hideki Sekine <sekineh@me.com>\"]\n-# edition = \"2018\"\n+edition = \"2018\"\n \n [dependencies]\n cortex-m = \"0.5.4\""}, {"sha": "4a08419a07e14e885ff57b0cf767cd66d58f6739", "filename": "src/test/run-make/thumb-none-qemu/example/src/main.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Frun-make%2Fthumb-none-qemu%2Fexample%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Frun-make%2Fthumb-none-qemu%2Fexample%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fthumb-none-qemu%2Fexample%2Fsrc%2Fmain.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -1,16 +1,14 @@\n // #![feature(stdsimd)]\n #![no_main]\n #![no_std]\n-\n-extern crate cortex_m;\n-\n-extern crate cortex_m_rt as rt;\n-extern crate cortex_m_semihosting as semihosting;\n-extern crate panic_halt;\n-\n use core::fmt::Write;\n use cortex_m::asm;\n-use rt::entry;\n+use cortex_m_rt::entry;\n+use cortex_m_semihosting as semihosting;\n+\n+//FIXME: This imports the provided #[panic_handler].\n+#[allow(rust_2018_idioms)]\n+extern crate panic_halt;\n \n entry!(main);\n \n@@ -22,7 +20,7 @@ fn main() -> ! {\n \n         // write something through semihosting interface\n         let mut hstdout = semihosting::hio::hstdout().unwrap();\n-        write!(hstdout, \"x = {}\\n\", x);\n+        let _ = write!(hstdout, \"x = {}\\n\", x);\n \n         // exit from qemu\n         semihosting::debug::exit(semihosting::debug::EXIT_SUCCESS);"}, {"sha": "b2bbc1f1549985e135fe1a6713fba5806edd97a7", "filename": "src/test/ui/existential-type/issue-52843-closure-constrain.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,12 @@\n+// Checks to ensure that we properly detect when a closure constrains an existential type\n+#![feature(existential_type)]\n+\n+use std::fmt::Debug;\n+\n+fn main() {\n+    existential type Existential: Debug;\n+    fn _unused() -> Existential { String::new() }\n+    //~^ ERROR: concrete type differs from previous defining existential type use\n+    let null = || -> Existential { 0 };\n+    println!(\"{:?}\", null());\n+}"}, {"sha": "424d65a193c92de7c77729ce454df3ab4ca3c5c9", "filename": "src/test/ui/existential-type/issue-52843-closure-constrain.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential-type%2Fissue-52843-closure-constrain.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,20 @@\n+error: concrete type differs from previous defining existential type use\n+  --> $DIR/issue-52843-closure-constrain.rs:8:5\n+   |\n+LL |     fn _unused() -> Existential { String::new() }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, got `std::string::String`\n+   |\n+note: previous use here\n+  --> $DIR/issue-52843-closure-constrain.rs:6:1\n+   |\n+LL | / fn main() {\n+LL | |     existential type Existential: Debug;\n+LL | |     fn _unused() -> Existential { String::new() }\n+LL | |\n+LL | |     let null = || -> Existential { 0 };\n+LL | |     println!(\"{:?}\", null());\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}, {"sha": "c2cf0eeed3d9e6fc08fe65039bc87d2e09769713", "filename": "src/test/ui/existential_types/existential_type-pass.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential_type-pass.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "previous_filename": "src/test/ui/existential_type.rs"}, {"sha": "d964f2b74ff6984c0ed2862538a285b13dd167e4", "filename": "src/test/ui/existential_types/issue-53678-generator-and-const-fn.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-53678-generator-and-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-53678-generator-and-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-53678-generator-and-const-fn.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+#![feature(const_fn, generators, generator_trait, existential_type)]\n+\n+use std::ops::Generator;\n+\n+existential type GenOnce<Y, R>: Generator<Yield = Y, Return = R>;\n+\n+const fn const_generator<Y, R>(yielding: Y, returning: R) -> GenOnce<Y, R> {\n+    move || {\n+        yield yielding;\n+\n+        return returning;\n+    }\n+}\n+\n+const FOO: GenOnce<usize, usize> = const_generator(10, 100);\n+\n+fn main() {}"}, {"sha": "f038648ec2149e851bc551a3370626b4f2f91025", "filename": "src/test/ui/existential_types/issue-58887.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-58887.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-58887.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-58887.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "previous_filename": "src/test/ui/existential-type/issue-58887.rs"}, {"sha": "800f4b7e059fbd8d02807bec810c5e0a3ae2f46e", "filename": "src/test/ui/existential_types/issue-58887.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-58887.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-58887.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-58887.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "previous_filename": "src/test/ui/existential-type/issue-58887.stderr"}, {"sha": "f9def11d1932dec2e6ea56f3fdb98389061176bd", "filename": "src/test/ui/existential_types/issue-60371.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60371.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "previous_filename": "src/test/ui/existential-type/issue-60371.rs"}, {"sha": "092cb31f97d5bba93313458a1dbda32a65c72000", "filename": "src/test/ui/existential_types/issue-60371.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60371.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "previous_filename": "src/test/ui/existential-type/issue-60371.stderr"}, {"sha": "52162c491b5c8dc3e1cec2656bd71a66538a94cb", "filename": "src/test/ui/existential_types/issue-60407.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60407.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+#![feature(existential_type)]\n+\n+existential type Debuggable: core::fmt::Debug;\n+\n+static mut TEST: Option<Debuggable> = None;\n+\n+fn main() {\n+    unsafe { TEST = Some(foo()) }\n+}\n+\n+fn foo() -> Debuggable {\n+    0u32\n+}"}, {"sha": "cb3914ddd1deb3b6e318f3c03739b2033bad0150", "filename": "src/test/ui/existential_types/issue-60564.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60564.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,26 @@\n+#![feature(existential_type)]\n+\n+trait IterBits {\n+    type BitsIter: Iterator<Item = u8>;\n+    fn iter_bits(self, n: u8) -> Self::BitsIter;\n+}\n+\n+existential type IterBitsIter<T, E, I>: std::iter::Iterator<Item = I>;\n+//~^ ERROR could not find defining uses\n+\n+impl<T, E> IterBits for T\n+where\n+    T: std::ops::Shr<Output = T>\n+        + std::ops::BitAnd<T, Output = T>\n+        + std::convert::From<u8>\n+        + std::convert::TryInto<u8, Error = E>,\n+    E: std::fmt::Debug,\n+{\n+    type BitsIter = IterBitsIter<T, E, u8>;\n+    fn iter_bits(self, n: u8) -> Self::BitsIter {\n+    //~^ ERROR type parameter `E` is part of concrete type but not used\n+        (0u8..n)\n+            .rev()\n+            .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+    }\n+}"}, {"sha": "d8480b521570afa72222dd7a7860d15bbce5d596", "filename": "src/test/ui/existential_types/issue-60564.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fissue-60564.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,25 @@\n+error[E0601]: `main` function not found in crate `issue_60564`\n+   |\n+   = note: consider adding a `main` function to `$DIR/issue-60564.rs`\n+\n+error: type parameter `E` is part of concrete type but not used in parameter list for existential type\n+  --> $DIR/issue-60564.rs:20:49\n+   |\n+LL |       fn iter_bits(self, n: u8) -> Self::BitsIter {\n+   |  _________________________________________________^\n+LL | |\n+LL | |         (0u8..n)\n+LL | |             .rev()\n+LL | |             .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+LL | |     }\n+   | |_____^\n+\n+error: could not find defining uses\n+  --> $DIR/issue-60564.rs:8:1\n+   |\n+LL | existential type IterBitsIter<T, E, I>: std::iter::Iterator<Item = I>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "e7312b51dbcb8be2d664c84a25599cd6c5e0e284", "filename": "src/test/ui/hygiene/duplicate_lifetimes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,19 @@\n+// Ensure that lifetime parameter names are modernized before we check for\n+// duplicates.\n+\n+#![feature(decl_macro, rustc_attrs)]\n+\n+#[rustc_macro_transparency = \"semitransparent\"]\n+macro m($a:lifetime) {\n+    fn g<$a, 'a>() {} //~ ERROR lifetime name `'a` declared twice\n+}\n+\n+#[rustc_macro_transparency = \"transparent\"]\n+macro n($a:lifetime) {\n+    fn h<$a, 'a>() {} //~ ERROR lifetime name `'a` declared twice\n+}\n+\n+m!('a);\n+n!('a);\n+\n+fn main() {}"}, {"sha": "7aaea6ff24e390284f4bdbbc2ea1057db41b73aa", "filename": "src/test/ui/hygiene/duplicate_lifetimes.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,27 @@\n+error[E0263]: lifetime name `'a` declared twice in the same scope\n+  --> $DIR/duplicate_lifetimes.rs:8:14\n+   |\n+LL |     fn g<$a, 'a>() {}\n+   |              ^^ declared twice\n+...\n+LL | m!('a);\n+   | -------\n+   | |  |\n+   | |  previous declaration here\n+   | in this macro invocation\n+\n+error[E0263]: lifetime name `'a` declared twice in the same scope\n+  --> $DIR/duplicate_lifetimes.rs:13:14\n+   |\n+LL |     fn h<$a, 'a>() {}\n+   |              ^^ declared twice\n+...\n+LL | n!('a);\n+   | -------\n+   | |  |\n+   | |  previous declaration here\n+   | in this macro invocation\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0263`."}, {"sha": "9dc5adfce478af719383a10fcef9557a308c4a4c", "filename": "src/test/ui/hygiene/generic_params.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fgeneric_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fgeneric_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgeneric_params.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,104 @@\n+// Ensure that generic parameters always have modern hygiene.\n+\n+// check-pass\n+// ignore-pretty pretty-printing is unhygienic\n+\n+#![feature(decl_macro, rustc_attrs, const_generics)]\n+\n+mod type_params {\n+    macro m($T:ident) {\n+        fn f<$T: Clone, T: PartialEq>(t1: $T, t2: T) -> ($T, bool) {\n+            (t1.clone(), t2 == t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    macro n($T:ident) {\n+        fn g<$T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+        fn h<T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"transparent\"]\n+    macro p($T:ident) {\n+        fn j<$T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+        fn k<T: Clone>(t1: $T, t2: T) -> (T, $T) {\n+            (t1.clone(), t2.clone())\n+        }\n+    }\n+\n+    m!(T);\n+    n!(T);\n+    p!(T);\n+}\n+\n+mod lifetime_params {\n+    macro m($a:lifetime) {\n+        fn f<'b, 'c, $a: 'b, 'a: 'c>(t1: &$a(), t2: &'a ()) -> (&'b (), &'c ()) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    macro n($a:lifetime) {\n+        fn g<$a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+        fn h<'a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"transparent\"]\n+    macro p($a:lifetime) {\n+        fn j<$a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+        fn k<'a>(t1: &$a(), t2: &'a ()) -> (&'a (), &$a ()) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    m!('a);\n+    n!('a);\n+    p!('a);\n+}\n+\n+mod const_params {\n+    macro m($C:ident) {\n+        fn f<const $C: usize, const C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); $C], [(); C]) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    macro n($C:ident) {\n+        fn g<const $C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+        fn h<const C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    #[rustc_macro_transparency = \"transparent\"]\n+    macro p($C:ident) {\n+        fn j<const $C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+        fn k<const C: usize>(t1: [(); $C], t2: [(); C]) -> ([(); C], [(); $C]) {\n+            (t1, t2)\n+        }\n+    }\n+\n+    m!(C);\n+    n!(C);\n+    p!(C);\n+}\n+\n+fn main() {}"}, {"sha": "ecd228a5db5c80abed211d881d20d219e3026e18", "filename": "src/test/ui/hygiene/generic_params.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fgeneric_params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fgeneric_params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgeneric_params.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/generic_params.rs:6:37\n+   |\n+LL | #![feature(decl_macro, rustc_attrs, const_generics)]\n+   |                                     ^^^^^^^^^^^^^^\n+"}, {"sha": "dcfb42287d5cba417446cee0a1f7611e722612b0", "filename": "src/test/ui/hygiene/issue-61574-const-parameters.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fissue-61574-const-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fissue-61574-const-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fissue-61574-const-parameters.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,32 @@\n+// A more comprehensive test that const parameters have correctly implemented\n+// hygiene\n+\n+// check-pass\n+\n+#![feature(const_generics)]\n+\n+use std::ops::Add;\n+\n+struct VectorLike<T, const SIZE: usize>([T; {SIZE}]);\n+\n+macro_rules! impl_operator_overload {\n+    ($trait_ident:ident, $method_ident:ident) => {\n+\n+        impl<T, const SIZE: usize> $trait_ident for VectorLike<T, {SIZE}>\n+        where\n+            T: $trait_ident,\n+        {\n+            type Output = VectorLike<T, {SIZE}>;\n+\n+            fn $method_ident(self, _: VectorLike<T, {SIZE}>) -> VectorLike<T, {SIZE}> {\n+                let _ = SIZE;\n+                unimplemented!()\n+            }\n+        }\n+\n+    }\n+}\n+\n+impl_operator_overload!(Add, add);\n+\n+fn main() {}"}, {"sha": "302b5fde8879c69180c11e9403714de7725dcce2", "filename": "src/test/ui/hygiene/issue-61574-const-parameters.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fissue-61574-const-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fhygiene%2Fissue-61574-const-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fissue-61574-const-parameters.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-61574-const-parameters.rs:6:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "b296bfe59888721d8c0a1404d414e30f5c55c828", "filename": "src/test/ui/hygiene/ty_params.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04b88a9eba8abbac87eddcb2998beea09589c2c9/src%2Ftest%2Fui%2Fhygiene%2Fty_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b88a9eba8abbac87eddcb2998beea09589c2c9/src%2Ftest%2Fui%2Fhygiene%2Fty_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fty_params.rs?ref=04b88a9eba8abbac87eddcb2998beea09589c2c9", "patch": "@@ -1,14 +0,0 @@\n-// check-pass\n-// ignore-pretty pretty-printing is unhygienic\n-\n-#![feature(decl_macro)]\n-\n-macro m($T:ident) {\n-    fn f<T, $T>(t: T, t2: $T) -> (T, $T) {\n-        (t, t2)\n-    }\n-}\n-\n-m!(T);\n-\n-fn main() {}"}, {"sha": "e6c59fcf22dea3a04b8101970db9a995b9a78df8", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,15 @@\n+// Here we test that the parser is able to recover in a situation like\n+// `for ( $pat in $expr )` since that is familiar syntax in other languages.\n+// Instead we suggest that the user writes `for $pat in $expr`.\n+\n+#![deny(unused)] // Make sure we don't trigger `unused_parens`.\n+\n+fn main() {\n+    let vec = vec![1, 2, 3];\n+\n+    for ( elem in vec ) {\n+        //~^ ERROR expected one of `)`, `,`, or `@`, found `in`\n+        //~| ERROR unexpected closing `)`\n+        const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "c160e646c28b34821efdebbe8201008a8eaafca1", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,27 @@\n+error: expected one of `)`, `,`, or `@`, found `in`\n+  --> $DIR/recover-for-loop-parens-around-head.rs:10:16\n+   |\n+LL |     for ( elem in vec ) {\n+   |                ^^ expected one of `)`, `,`, or `@` here\n+\n+error: unexpected closing `)`\n+  --> $DIR/recover-for-loop-parens-around-head.rs:10:23\n+   |\n+LL |     for ( elem in vec ) {\n+   |         --------------^\n+   |         |\n+   |         opening `(`\n+   |         help: remove parenthesis in `for` loop: `elem in vec`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-for-loop-parens-around-head.rs:13:38\n+   |\n+LL |         const RECOVERY_WITNESS: () = 0;\n+   |                                      ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "36a45a3ccdc4b04257e422a426d404c2c478550f", "filename": "src/test/ui/pattern/rest-pat-semantic-disallowed.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,82 @@\n+// Here we test that rest patterns, i.e. `..`, are not allowed\n+// outside of slice (+ ident patterns witin those), tuple,\n+// and tuple struct patterns and that duplicates are caught in these contexts.\n+\n+#![feature(slice_patterns, box_patterns)]\n+\n+fn main() {}\n+\n+macro_rules! mk_pat {\n+    () => { .. } //~ ERROR `..` patterns are not allowed here\n+}\n+\n+fn rest_patterns() {\n+    let mk_pat!();\n+\n+    // Top level:\n+    fn foo(..: u8) {} //~ ERROR `..` patterns are not allowed here\n+    let ..;  //~ ERROR `..` patterns are not allowed here\n+\n+    // Box patterns:\n+    let box ..;  //~ ERROR `..` patterns are not allowed here\n+\n+    // In or-patterns:\n+    match 1 {\n+        1 | .. => {} //~ ERROR `..` patterns are not allowed here\n+    }\n+\n+    // Ref patterns:\n+    let &..; //~ ERROR `..` patterns are not allowed here\n+    let &mut ..; //~ ERROR `..` patterns are not allowed here\n+\n+    // Ident patterns:\n+    let x @ ..; //~ ERROR `..` patterns are not allowed here\n+    let ref x @ ..; //~ ERROR `..` patterns are not allowed here\n+    let ref mut x @ ..; //~ ERROR `..` patterns are not allowed here\n+\n+    // Tuple:\n+    let (..): (u8,); // OK.\n+    let (..,): (u8,); // OK.\n+    let (\n+        ..,\n+        .., //~ ERROR `..` can only be used once per tuple pattern\n+        .. //~ ERROR `..` can only be used once per tuple pattern\n+    ): (u8, u8, u8);\n+    let (\n+        ..,\n+        x,\n+        .. //~ ERROR `..` can only be used once per tuple pattern\n+    ): (u8, u8, u8);\n+\n+    struct A(u8, u8, u8);\n+\n+    // Tuple struct (same idea as for tuple patterns):\n+    let A(..); // OK.\n+    let A(..,); // OK.\n+    let A(\n+        ..,\n+        .., //~ ERROR `..` can only be used once per tuple struct pattern\n+        .. //~ ERROR `..` can only be used once per tuple struct pattern\n+    );\n+    let A(\n+        ..,\n+        x,\n+        .. //~ ERROR `..` can only be used once per tuple struct pattern\n+    );\n+\n+    // Array/Slice:\n+    let [..]: &[u8]; // OK.\n+    let [..,]: &[u8]; // OK.\n+    let [\n+        ..,\n+        .., //~ ERROR `..` can only be used once per slice pattern\n+        .. //~ ERROR `..` can only be used once per slice pattern\n+    ]: &[u8];\n+    let [\n+        ..,\n+        ref x @ .., //~ ERROR `..` can only be used once per slice pattern\n+        ref mut y @ .., //~ ERROR `..` can only be used once per slice pattern\n+        (ref z @ ..), //~ ERROR `..` patterns are not allowed here\n+        .. //~ ERROR `..` can only be used once per slice pattern\n+    ]: &[u8];\n+}"}, {"sha": "826f76b356cf1684dec31bbb005166d9fdac2832", "filename": "src/test/ui/pattern/rest-pat-semantic-disallowed.stderr", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-semantic-disallowed.stderr?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,188 @@\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:10:13\n+   |\n+LL |     () => { .. }\n+   |             ^^\n+...\n+LL |     let mk_pat!();\n+   |         --------- in this macro invocation\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:18:9\n+   |\n+LL |     let ..;\n+   |         ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:21:13\n+   |\n+LL |     let box ..;\n+   |             ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:25:13\n+   |\n+LL |         1 | .. => {}\n+   |             ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:29:10\n+   |\n+LL |     let &..;\n+   |          ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:30:14\n+   |\n+LL |     let &mut ..;\n+   |              ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:33:13\n+   |\n+LL |     let x @ ..;\n+   |             ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:34:17\n+   |\n+LL |     let ref x @ ..;\n+   |                 ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:35:21\n+   |\n+LL |     let ref mut x @ ..;\n+   |                     ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` can only be used once per tuple pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:42:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ..,\n+   |         ^^ can only be used once per tuple pattern\n+\n+error: `..` can only be used once per tuple pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:43:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ..,\n+LL |         ..\n+   |         ^^ can only be used once per tuple pattern\n+\n+error: `..` can only be used once per tuple pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:48:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         x,\n+LL |         ..\n+   |         ^^ can only be used once per tuple pattern\n+\n+error: `..` can only be used once per tuple struct pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:58:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ..,\n+   |         ^^ can only be used once per tuple struct pattern\n+\n+error: `..` can only be used once per tuple struct pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:59:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ..,\n+LL |         ..\n+   |         ^^ can only be used once per tuple struct pattern\n+\n+error: `..` can only be used once per tuple struct pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:64:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         x,\n+LL |         ..\n+   |         ^^ can only be used once per tuple struct pattern\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:72:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ..,\n+   |         ^^ can only be used once per slice pattern\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:73:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ..,\n+LL |         ..\n+   |         ^^ can only be used once per slice pattern\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:77:17\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ref x @ ..,\n+   |                 ^^ can only be used once per slice pattern\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:78:21\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+LL |         ref x @ ..,\n+LL |         ref mut y @ ..,\n+   |                     ^^ can only be used once per slice pattern\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:79:18\n+   |\n+LL |         (ref z @ ..),\n+   |                  ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/rest-pat-semantic-disallowed.rs:80:9\n+   |\n+LL |         ..,\n+   |         -- previously used here\n+...\n+LL |         ..\n+   |         ^^ can only be used once per slice pattern\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/rest-pat-semantic-disallowed.rs:17:12\n+   |\n+LL |     fn foo(..: u8) {}\n+   |            ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: aborting due to 22 previous errors\n+"}, {"sha": "9656a0b5de9ce1afa46a4590e271f6e51ec3c5c5", "filename": "src/test/ui/pattern/rest-pat-syntactic.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,70 @@\n+// Here we test that `..` is allowed in all pattern locations *syntactically*.\n+// The semantic test is in `rest-pat-semantic-disallowed.rs`.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+macro_rules! accept_pat {\n+    ($p:pat) => {}\n+}\n+\n+accept_pat!(..);\n+\n+#[cfg(FALSE)]\n+fn rest_patterns() {\n+    // Top level:\n+    fn foo(..: u8) {}\n+    let ..;\n+\n+    // Box patterns:\n+    let box ..;\n+\n+    // In or-patterns:\n+    match x {\n+        .. | .. => {}\n+    }\n+\n+    // Ref patterns:\n+    let &..;\n+    let &mut ..;\n+\n+    // Ident patterns:\n+    let x @ ..;\n+    let ref x @ ..;\n+    let ref mut x @ ..;\n+\n+    // Tuple:\n+    let (..); // This is interpreted as a tuple pattern, not a parenthesis one.\n+    let (..,); // Allowing trailing comma.\n+    let (.., .., ..); // Duplicates also.\n+    let (.., P, ..); // Including with things in between.\n+\n+    // Tuple struct (same idea as for tuple patterns):\n+    let A(..);\n+    let A(..,);\n+    let A(.., .., ..);\n+    let A(.., P, ..);\n+\n+    // Array/Slice (like with tuple patterns):\n+    let [..];\n+    let [..,];\n+    let [.., .., ..];\n+    let [.., P, ..];\n+\n+    // Random walk to guard against special casing:\n+    match x {\n+        .. |\n+        [\n+            (\n+                box ..,\n+                &(..),\n+                &mut ..,\n+                x @ ..\n+            ),\n+            ref x @ ..,\n+        ] |\n+        ref mut x @ ..\n+        => {}\n+    }\n+}"}, {"sha": "ef7dc812af9d4f4681cfa6160ea0a52aafe6793a", "filename": "src/tools/rustc-std-workspace-alloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Frustc-std-workspace-alloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Frustc-std-workspace-alloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-std-workspace-alloc%2FCargo.toml?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -6,6 +6,7 @@ license = 'MIT OR Apache-2.0'\n description = \"\"\"\n Hack for the compiler's own build system\n \"\"\"\n+edition = \"2018\"\n \n [lib]\n path = \"lib.rs\""}, {"sha": "4a2e49fd1c3c77938fb242503008c04c7ecc9cd6", "filename": "src/tools/tidy/src/edition.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Ftidy%2Fsrc%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Ftidy%2Fsrc%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fedition.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -0,0 +1,45 @@\n+//! Tidy check to ensure that crate `edition` is '2018'\n+//!\n+\n+use std::path::Path;\n+\n+fn filter_dirs(path: &Path) -> bool {\n+    // FIXME: just use super::filter_dirs after the submodules are updated.\n+    if super::filter_dirs(path) {\n+        return true;\n+    }\n+    let skip = [\n+        \"src/doc/book/second-edition\",\n+        \"src/doc/book/2018-edition\",\n+        \"src/doc/book/ci/stable-check\",\n+        \"src/doc/reference/stable-check\",\n+    ];\n+    skip.iter().any(|p| path.ends_with(p))\n+}\n+\n+fn is_edition_2018(mut line: &str) -> bool {\n+    line = line.trim();\n+    line == \"edition = \\\"2018\\\"\" || line == \"edition = \\'2018\\'\"\n+}\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    super::walk(\n+        path,\n+        &mut |path| filter_dirs(path) || path.ends_with(\"src/test\"),\n+        &mut |entry, contents| {\n+            let file = entry.path();\n+            let filename = file.file_name().unwrap();\n+            if filename != \"Cargo.toml\" {\n+                return;\n+            }\n+            let has_edition = contents.lines().any(is_edition_2018);\n+            if !has_edition {\n+                tidy_error!(\n+                    bad,\n+                    \"{} doesn't have `edition = \\\"2018\\\"` on a separate line\",\n+                    file.display()\n+                );\n+            }\n+        },\n+    );\n+}"}, {"sha": "e01184e3658b525da78e97feeafe87661e3f0f81", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -34,6 +34,7 @@ pub mod style;\n pub mod errors;\n pub mod features;\n pub mod cargo;\n+pub mod edition;\n pub mod pal;\n pub mod deps;\n pub mod extdeps;"}, {"sha": "5deac52f08b5eeb5108c0a2d3499512aeac56aba", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=4eeaaa722d6ac6d24de6e4d3faefb7c44e674b37", "patch": "@@ -22,6 +22,7 @@ fn main() {\n     style::check(&path, &mut bad);\n     errors::check(&path, &mut bad);\n     cargo::check(&path, &mut bad);\n+    edition::check(&path, &mut bad);\n     let collected = features::check(&path, &mut bad, verbose);\n     pal::check(&path, &mut bad);\n     unstable_book::check(&path, collected, &mut bad);"}]}