{"sha": "438c40efa109d7a4d83efa066c19cb95dad9ed94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzOGM0MGVmYTEwOWQ3YTRkODNlZmEwNjZjMTljYjk1ZGFkOWVkOTQ=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-08-18T20:39:33Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-08-19T04:46:47Z"}, "message": "Allow reallocation to different alignment", "tree": {"sha": "264f37242cd348f83cf3f1b6573b6c561b179672", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/264f37242cd348f83cf3f1b6573b6c561b179672"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/438c40efa109d7a4d83efa066c19cb95dad9ed94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/438c40efa109d7a4d83efa066c19cb95dad9ed94", "html_url": "https://github.com/rust-lang/rust/commit/438c40efa109d7a4d83efa066c19cb95dad9ed94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/438c40efa109d7a4d83efa066c19cb95dad9ed94/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be97d13ffc41961c018c313e909f76ba3bbdc958", "url": "https://api.github.com/repos/rust-lang/rust/commits/be97d13ffc41961c018c313e909f76ba3bbdc958", "html_url": "https://github.com/rust-lang/rust/commit/be97d13ffc41961c018c313e909f76ba3bbdc958"}], "stats": {"total": 343, "additions": 180, "deletions": 163}, "files": [{"sha": "e325bb4b3efa80995d42c3a1508182ac531d43fd", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=438c40efa109d7a4d83efa066c19cb95dad9ed94", "patch": "@@ -3,7 +3,7 @@\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics::{self, min_align_of_val, size_of_val};\n-use core::ptr::{NonNull, Unique};\n+use core::ptr::{self, NonNull, Unique};\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n@@ -180,36 +180,45 @@ impl Global {\n     unsafe fn grow_impl(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n         zeroed: bool,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n-            new_size >= layout.size(),\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n+            new_layout.size() >= old_layout.size(),\n+            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n         );\n \n-        match layout.size() {\n-            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-            0 => unsafe {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-                self.alloc_impl(new_layout, zeroed)\n-            },\n+        match old_layout.size() {\n+            0 => self.alloc_impl(new_layout, zeroed),\n \n             // SAFETY: `new_size` is non-zero as `old_size` is greater than or equal to `new_size`\n             // as required by safety conditions. Other conditions must be upheld by the caller\n-            old_size => unsafe {\n-                // `realloc` probably checks for `new_size >= size` or something similar.\n-                intrinsics::assume(new_size >= layout.size());\n+            old_size if old_layout.align() == new_layout.align() => unsafe {\n+                let new_size = new_layout.size();\n+\n+                // `realloc` probably checks for `new_size >= old_layout.size()` or something similar.\n+                intrinsics::assume(new_size >= old_layout.size());\n \n-                let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let raw_ptr = realloc(ptr.as_ptr(), old_layout, new_size);\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n                 if zeroed {\n                     raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n                 }\n                 Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n             },\n+\n+            // SAFETY: because `new_layout.size()` must be greater than or equal to `old_size`,\n+            // both the old and new memory allocation are valid for reads and writes for `old_size`\n+            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n+            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n+            // for `dealloc` must be upheld by the caller.\n+            old_size => unsafe {\n+                let new_ptr = self.alloc_impl(new_layout, zeroed)?;\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);\n+                self.dealloc(ptr, old_layout);\n+                Ok(new_ptr)\n+            },\n         }\n     }\n }\n@@ -239,52 +248,64 @@ unsafe impl AllocRef for Global {\n     unsafe fn grow(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: all conditions must be upheld by the caller\n-        unsafe { self.grow_impl(ptr, layout, new_size, false) }\n+        unsafe { self.grow_impl(ptr, old_layout, new_layout, false) }\n     }\n \n     #[inline]\n     unsafe fn grow_zeroed(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: all conditions must be upheld by the caller\n-        unsafe { self.grow_impl(ptr, layout, new_size, true) }\n+        unsafe { self.grow_impl(ptr, old_layout, new_layout, true) }\n     }\n \n     #[inline]\n     unsafe fn shrink(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n-            new_size <= layout.size(),\n-            \"`new_size` must be smaller than or equal to `layout.size()`\"\n+            new_layout.size() <= old_layout.size(),\n+            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n         );\n \n-        match new_size {\n+        match new_layout.size() {\n             // SAFETY: conditions must be upheld by the caller\n             0 => unsafe {\n-                self.dealloc(ptr, layout);\n-                Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0))\n+                self.dealloc(ptr, old_layout);\n+                Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n             },\n \n             // SAFETY: `new_size` is non-zero. Other conditions must be upheld by the caller\n-            new_size => unsafe {\n-                // `realloc` probably checks for `new_size <= size` or something similar.\n-                intrinsics::assume(new_size <= layout.size());\n+            new_size if old_layout.align() == new_layout.align() => unsafe {\n+                // `realloc` probably checks for `new_size <= old_layout.size()` or something similar.\n+                intrinsics::assume(new_size <= old_layout.size());\n \n-                let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let raw_ptr = realloc(ptr.as_ptr(), old_layout, new_size);\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n                 Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n             },\n+\n+            // SAFETY: because `new_size` must be smaller than or equal to `old_layout.size()`,\n+            // both the old and new memory allocation are valid for reads and writes for `new_size`\n+            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n+            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n+            // for `dealloc` must be upheld by the caller.\n+            new_size => unsafe {\n+                let new_ptr = self.alloc(new_layout)?;\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n+                self.dealloc(ptr, old_layout);\n+                Ok(new_ptr)\n+            },\n         }\n     }\n }\n@@ -297,7 +318,7 @@ unsafe impl AllocRef for Global {\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n     match Global.alloc(layout) {\n-        Ok(ptr) => ptr.as_non_null_ptr().as_ptr(),\n+        Ok(ptr) => ptr.as_mut_ptr(),\n         Err(_) => handle_alloc_error(layout),\n     }\n }"}, {"sha": "e00cb361c0019f8400365ee51115f6fef44a98aa", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=438c40efa109d7a4d83efa066c19cb95dad9ed94", "patch": "@@ -465,8 +465,9 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         let new_size = amount * mem::size_of::<T>();\n \n         let ptr = unsafe {\n-            self.alloc.shrink(ptr, layout, new_size).map_err(|_| TryReserveError::AllocError {\n-                layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n+            let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+            self.alloc.shrink(ptr, layout, new_layout).map_err(|_| TryReserveError::AllocError {\n+                layout: new_layout,\n                 non_exhaustive: (),\n             })?\n         };\n@@ -493,14 +494,12 @@ where\n     alloc_guard(new_layout.size())?;\n \n     let memory = if let Some((ptr, old_layout)) = current_memory {\n-        debug_assert_eq!(old_layout.align(), new_layout.align());\n-        unsafe { alloc.grow(ptr, old_layout, new_layout.size()) }\n+        unsafe { alloc.grow(ptr, old_layout, new_layout) }\n     } else {\n         alloc.alloc(new_layout)\n-    }\n-    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n+    };\n \n-    Ok(memory)\n+    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })\n }\n \n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {"}, {"sha": "c1fda2fce641fead20d505a0e293dfb4d10d9b01", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 61, "deletions": 79, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=438c40efa109d7a4d83efa066c19cb95dad9ed94", "patch": "@@ -147,9 +147,8 @@ pub unsafe trait AllocRef {\n     /// Attempts to extend the memory block.\n     ///\n     /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n-    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n-    /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n-    /// allocation referenced by `ptr` to fit the new layout.\n+    /// memory. The pointer is suitable for holding data described by `new_layout`. To accomplish\n+    /// this, the allocator may extend the allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n     /// transferred to this allocator. The memory may or may not have been freed, and should be\n@@ -163,11 +162,9 @@ pub unsafe trait AllocRef {\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n-    /// * `new_size` must be greater than or equal to `layout.size()`, and\n-    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n-    ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator.\n+    /// * `old_layout` must [*fit*] that block of memory (The `new_layout` argument need not fit it.).\n+    /// * `new_layout.size()` must be greater than or equal to `old_layout.size()`.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -188,28 +185,24 @@ pub unsafe trait AllocRef {\n     unsafe fn grow(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n+            new_layout.size() >= old_layout.size(),\n+            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n         );\n \n-        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n         let new_ptr = self.alloc(new_layout)?;\n \n-        // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n-        // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n-        // allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n-        // `copy_nonoverlapping` is safe.\n-        // The safety contract for `dealloc` must be upheld by the caller.\n+        // SAFETY: because `new_layout.size()` must be greater than or equal to\n+        // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n+        // writes for `old_layout.size()` bytes. Also, because the old allocation wasn't yet\n+        // deallocated, it cannot overlap `new_ptr`. Thus, the call to `copy_nonoverlapping` is\n+        // safe. The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), size);\n-            self.dealloc(ptr, layout);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_layout.size());\n+            self.dealloc(ptr, old_layout);\n         }\n \n         Ok(new_ptr)\n@@ -220,21 +213,19 @@ pub unsafe trait AllocRef {\n     ///\n     /// The memory block will contain the following contents after a successful call to\n     /// `grow_zeroed`:\n-    ///   * Bytes `0..layout.size()` are preserved from the original allocation.\n-    ///   * Bytes `layout.size()..old_size` will either be preserved or zeroed, depending on the\n-    ///     allocator implementation. `old_size` refers to the size of the memory block prior to\n-    ///     the `grow_zeroed` call, which may be larger than the size that was originally requested\n-    ///     when it was allocated.\n+    ///   * Bytes `0..old_layout.size()` are preserved from the original allocation.\n+    ///   * Bytes `old_layout.size()..old_size` will either be preserved or zeroed, depending on\n+    ///     the allocator implementation. `old_size` refers to the size of the memory block prior\n+    ///     to the `grow_zeroed` call, which may be larger than the size that was originally\n+    ///     requested when it was allocated.\n     ///   * Bytes `old_size..new_size` are zeroed. `new_size` refers to the size of the memory\n-    ///     block returned by the `grow` call.\n+    ///     block returned by the `grow_zeroed` call.\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n-    /// * `new_size` must be greater than or equal to `layout.size()`, and\n-    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n-    ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator.\n+    /// * `old_layout` must [*fit*] that block of memory (The `new_layout` argument need not fit it.).\n+    /// * `new_layout.size()` must be greater than or equal to `old_layout.size()`.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -255,28 +246,24 @@ pub unsafe trait AllocRef {\n     unsafe fn grow_zeroed(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size >= size,\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n+            new_layout.size() >= old_layout.size(),\n+            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n         );\n \n-        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n         let new_ptr = self.alloc_zeroed(new_layout)?;\n \n-        // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n-        // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n-        // allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n-        // `copy_nonoverlapping` is safe.\n-        // The safety contract for `dealloc` must be upheld by the caller.\n+        // SAFETY: because `new_layout.size()` must be greater than or equal to\n+        // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n+        // writes for `old_layout.size()` bytes. Also, because the old allocation wasn't yet\n+        // deallocated, it cannot overlap `new_ptr`. Thus, the call to `copy_nonoverlapping` is\n+        // safe. The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), size);\n-            self.dealloc(ptr, layout);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_layout.size());\n+            self.dealloc(ptr, old_layout);\n         }\n \n         Ok(new_ptr)\n@@ -285,9 +272,8 @@ pub unsafe trait AllocRef {\n     /// Attempts to shrink the memory block.\n     ///\n     /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n-    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n-    /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n-    /// allocation referenced by `ptr` to fit the new layout.\n+    /// memory. The pointer is suitable for holding data described by `new_layout`. To accomplish\n+    /// this, the allocator may shrink the allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n     /// transferred to this allocator. The memory may or may not have been freed, and should be\n@@ -301,9 +287,9 @@ pub unsafe trait AllocRef {\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n-    /// * `new_size` must be smaller than or equal to `layout.size()`.\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator.\n+    /// * `old_layout` must [*fit*] that block of memory (The `new_layout` argument need not fit it.).\n+    /// * `new_layout.size()` must be smaller than or equal to `old_layout.size()`.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -324,28 +310,24 @@ pub unsafe trait AllocRef {\n     unsafe fn shrink(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n-        let size = layout.size();\n         debug_assert!(\n-            new_size <= size,\n-            \"`new_size` must be smaller than or equal to `layout.size()`\"\n+            new_layout.size() <= old_layout.size(),\n+            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n         );\n \n-        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n         let new_ptr = self.alloc(new_layout)?;\n \n-        // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n-        // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n-        // old allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n-        // `copy_nonoverlapping` is safe.\n-        // The safety contract for `dealloc` must be upheld by the caller.\n+        // SAFETY: because `new_layout.size()` must be lower than or equal to\n+        // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n+        // writes for `new_layout.size()` bytes. Also, because the old allocation wasn't yet\n+        // deallocated, it cannot overlap `new_ptr`. Thus, the call to `copy_nonoverlapping` is\n+        // safe. The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), size);\n-            self.dealloc(ptr, layout);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_layout.size());\n+            self.dealloc(ptr, old_layout);\n         }\n \n         Ok(new_ptr)\n@@ -385,32 +367,32 @@ where\n     unsafe fn grow(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).grow(ptr, layout, new_size) }\n+        unsafe { (**self).grow(ptr, old_layout, new_layout) }\n     }\n \n     #[inline]\n     unsafe fn grow_zeroed(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).grow_zeroed(ptr, layout, new_size) }\n+        unsafe { (**self).grow_zeroed(ptr, old_layout, new_layout) }\n     }\n \n     #[inline]\n     unsafe fn shrink(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n-        unsafe { (**self).shrink(ptr, layout, new_size) }\n+        unsafe { (**self).shrink(ptr, old_layout, new_layout) }\n     }\n }"}, {"sha": "64d8edf33bd3bcf393e9d94e028f3ea07849a8e0", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 53, "deletions": 32, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/438c40efa109d7a4d83efa066c19cb95dad9ed94/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=438c40efa109d7a4d83efa066c19cb95dad9ed94", "patch": "@@ -154,36 +154,45 @@ impl System {\n     unsafe fn grow_impl(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n         zeroed: bool,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n-            new_size >= layout.size(),\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n+            new_layout.size() >= old_layout.size(),\n+            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n         );\n \n-        match layout.size() {\n-            // SAFETY: the caller must ensure that the `new_size` does not overflow.\n-            // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n-            0 => unsafe {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-                self.alloc_impl(new_layout, zeroed)\n-            },\n+        match old_layout.size() {\n+            0 => self.alloc_impl(new_layout, zeroed),\n \n             // SAFETY: `new_size` is non-zero as `old_size` is greater than or equal to `new_size`\n             // as required by safety conditions. Other conditions must be upheld by the caller\n-            old_size => unsafe {\n-                // `realloc` probably checks for `new_size >= size` or something similar.\n-                intrinsics::assume(new_size >= layout.size());\n+            old_size if old_layout.align() == new_layout.align() => unsafe {\n+                let new_size = new_layout.size();\n+\n+                // `realloc` probably checks for `new_size >= old_layout.size()` or something similar.\n+                intrinsics::assume(new_size >= old_layout.size());\n \n-                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n                 if zeroed {\n                     raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n                 }\n                 Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n             },\n+\n+            // SAFETY: because `new_layout.size()` must be greater than or equal to `old_size`,\n+            // both the old and new memory allocation are valid for reads and writes for `old_size`\n+            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n+            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n+            // for `dealloc` must be upheld by the caller.\n+            old_size => unsafe {\n+                let new_ptr = self.alloc_impl(new_layout, zeroed)?;\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_size);\n+                self.dealloc(ptr, old_layout);\n+                Ok(new_ptr)\n+            },\n         }\n     }\n }\n@@ -215,52 +224,64 @@ unsafe impl AllocRef for System {\n     unsafe fn grow(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: all conditions must be upheld by the caller\n-        unsafe { self.grow_impl(ptr, layout, new_size, false) }\n+        unsafe { self.grow_impl(ptr, old_layout, new_layout, false) }\n     }\n \n     #[inline]\n     unsafe fn grow_zeroed(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: all conditions must be upheld by the caller\n-        unsafe { self.grow_impl(ptr, layout, new_size, true) }\n+        unsafe { self.grow_impl(ptr, old_layout, new_layout, true) }\n     }\n \n     #[inline]\n     unsafe fn shrink(\n         &mut self,\n         ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n+        old_layout: Layout,\n+        new_layout: Layout,\n     ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n-            new_size <= layout.size(),\n-            \"`new_size` must be smaller than or equal to `layout.size()`\"\n+            new_layout.size() <= old_layout.size(),\n+            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n         );\n \n-        match new_size {\n+        match new_layout.size() {\n             // SAFETY: conditions must be upheld by the caller\n             0 => unsafe {\n-                self.dealloc(ptr, layout);\n-                Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0))\n+                self.dealloc(ptr, old_layout);\n+                Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n             },\n \n             // SAFETY: `new_size` is non-zero. Other conditions must be upheld by the caller\n-            new_size => unsafe {\n-                // `realloc` probably checks for `new_size <= size` or something similar.\n-                intrinsics::assume(new_size <= layout.size());\n+            new_size if old_layout.align() == new_layout.align() => unsafe {\n+                // `realloc` probably checks for `new_size <= old_layout.size()` or something similar.\n+                intrinsics::assume(new_size <= old_layout.size());\n \n-                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                let raw_ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size);\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n                 Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n             },\n+\n+            // SAFETY: because `new_size` must be smaller than or equal to `old_layout.size()`,\n+            // both the old and new memory allocation are valid for reads and writes for `new_size`\n+            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n+            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n+            // for `dealloc` must be upheld by the caller.\n+            new_size => unsafe {\n+                let new_ptr = self.alloc(new_layout)?;\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n+                self.dealloc(ptr, old_layout);\n+                Ok(new_ptr)\n+            },\n         }\n     }\n }"}, {"sha": "2e07fdcbe830cd8074492028bd8ed67da90f1549", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/438c40efa109d7a4d83efa066c19cb95dad9ed94/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/438c40efa109d7a4d83efa066c19cb95dad9ed94/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=438c40efa109d7a4d83efa066c19cb95dad9ed94", "patch": "@@ -48,7 +48,7 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?}) = {:?}\", layout, ptr);\n         }\n \n-        ptr.as_non_null_ptr().as_ptr()\n+        ptr.as_mut_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n@@ -65,23 +65,17 @@ unsafe fn test_triangle() -> bool {\n         }\n \n         let memory = if new.size() > old.size() {\n-            Global.grow(\n-                NonNull::new_unchecked(ptr),\n-                old,\n-                new.size(),\n-            )\n+            Global.grow(NonNull::new_unchecked(ptr), old, new)\n         } else {\n-            Global.shrink(NonNull::new_unchecked(ptr), old, new.size())\n+            Global.shrink(NonNull::new_unchecked(ptr), old, new)\n         };\n \n-        let ptr = memory.unwrap_or_else(|_| {\n-            handle_alloc_error(Layout::from_size_align_unchecked(new.size(), old.align()))\n-        });\n+        let ptr = memory.unwrap_or_else(|_| handle_alloc_error(new));\n \n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, ptr);\n         }\n-        ptr.as_non_null_ptr().as_ptr()\n+        ptr.as_mut_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize {"}]}