{"sha": "d9afd2bb38eed6f82b2b3b862b83125a44f69044", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YWZkMmJiMzhlZWQ2ZjgyYjJiM2I4NjJiODMxMjVhNDRmNjkwNDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-23T14:30:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:22Z"}, "message": "introduce new subtyping", "tree": {"sha": "a7bfbc0c7bdd435796f6bfb343da97a43ccf474f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7bfbc0c7bdd435796f6bfb343da97a43ccf474f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9afd2bb38eed6f82b2b3b862b83125a44f69044", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9afd2bb38eed6f82b2b3b862b83125a44f69044", "html_url": "https://github.com/rust-lang/rust/commit/d9afd2bb38eed6f82b2b3b862b83125a44f69044", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9afd2bb38eed6f82b2b3b862b83125a44f69044/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b913df06f26dde04cbc218874fdd893a5c59c67f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b913df06f26dde04cbc218874fdd893a5c59c67f", "html_url": "https://github.com/rust-lang/rust/commit/b913df06f26dde04cbc218874fdd893a5c59c67f"}], "stats": {"total": 1137, "additions": 1016, "deletions": 121}, "files": [{"sha": "1721d1dd0e9c578e436b1ae6a621083c888df68e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -39,7 +39,6 @@ pub struct DepGraph {\n     fingerprints: Lrc<Lock<IndexVec<DepNodeIndex, Fingerprint>>>\n }\n \n-\n newtype_index!(DepNodeIndex);\n \n impl DepNodeIndex {"}, {"sha": "cb4e1ab65e7590995546a5f711e0b365f7d0718e", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -617,6 +617,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"leak_check: skol_map={:?}\",\n                skol_map);\n \n+        // If the user gave `-Zno-leak-check`, then skip the leak\n+        // check completely. This is wildly unsound and also not\n+        // unlikely to cause an ICE or two. It is intended for use\n+        // only during a transition period, in which the MIR typeck\n+        // uses the \"universe-style\" check, and the rest of typeck\n+        // uses the more conservative leak check.  Since the leak\n+        // check is more conservative, we can't test the\n+        // universe-style check without disabling it.\n+        if self.tcx.sess.opts.debugging_opts.no_leak_check {\n+            return Ok(());\n+        }\n+\n         let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n         for (&skol_br, &skol) in skol_map {\n             // The inputs to a skolemized variable can only"}, {"sha": "0b84c6a0aa77abdee3a7fc4cf09290036d10e9c9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -377,13 +377,16 @@ pub enum NLLRegionVariableOrigin {\n     // elsewhere. This origin indices we've got one of those.\n     FreeRegion,\n \n+    BoundRegion(ty::UniverseIndex),\n+\n     Existential,\n }\n \n impl NLLRegionVariableOrigin {\n     pub fn is_universal(self) -> bool {\n         match self {\n             NLLRegionVariableOrigin::FreeRegion => true,\n+            NLLRegionVariableOrigin::BoundRegion(..) => true,\n             NLLRegionVariableOrigin::Existential => false,\n         }\n     }\n@@ -1394,6 +1397,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn universe(&self) -> ty::UniverseIndex {\n         self.universe.get()\n     }\n+\n+    /// Create and return a new subunivese of the current universe;\n+    /// update `self.universe` to that new subuniverse. At present,\n+    /// used only in the NLL subtyping code, which uses the new\n+    /// universe-based scheme instead of the more limited leak-check\n+    /// scheme.\n+    pub fn create_subuniverse(&self) -> ty::UniverseIndex {\n+        let u = self.universe.get().subuniverse();\n+        self.universe.set(u);\n+        u\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "54d9e24bbc0e237134ff86936435643b41ab18a2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -1353,6 +1353,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"generate build artifacts that are compatible with linker-based LTO.\"),\n     no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n           \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n+    no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n+        \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "d23bd2e51fbd57444ec783979ce3cfbac4abf5bd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -1481,14 +1481,27 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// type name in a non-zero universe is a skolemized type -- an\n /// idealized representative of \"types in general\" that we use for\n /// checking generic functions.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UniverseIndex(u32);\n \n impl UniverseIndex {\n     /// The root universe, where things that the user defined are\n     /// visible.\n     pub const ROOT: Self = UniverseIndex(0);\n \n+    /// The \"max universe\" -- this isn't really a valid universe, but\n+    /// it's useful sometimes as a \"starting value\" when you are\n+    /// taking the minimum of a (non-empty!) set of universes.\n+    pub const MAX: Self = UniverseIndex(::std::u32::MAX);\n+\n+    /// Creates a universe index from the given integer.  Not to be\n+    /// used lightly lest you pick a bad value. But sometimes we\n+    /// convert universe indicies into integers and back for various\n+    /// reasons.\n+    pub fn from_u32(index: u32) -> Self {\n+        UniverseIndex(index)\n+    }\n+\n     /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n     /// So, for example, suppose we have this type in universe `U`:\n     ///\n@@ -1504,6 +1517,11 @@ impl UniverseIndex {\n         UniverseIndex(self.0.checked_add(1).unwrap())\n     }\n \n+    /// True if the names in this universe are a subset of the names in `other`.\n+    pub fn is_subset_of(self, other: UniverseIndex) -> bool {\n+        self.0 <= other.0\n+    }\n+\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n@@ -1513,6 +1531,12 @@ impl UniverseIndex {\n     }\n }\n \n+impl fmt::Debug for UniverseIndex {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"U{}\", self.as_u32())\n+    }\n+}\n+\n impl From<u32> for UniverseIndex {\n     fn from(index: u32) -> Self {\n         UniverseIndex(index)"}, {"sha": "88b34c767324c2d55b38ffb6fd344f5ea388b489", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -13,6 +13,7 @@\n //! state of region inference. This code handles emitting the region\n //! context internal state.\n \n+use rustc::infer::NLLRegionVariableOrigin;\n use std::io::{self, Write};\n use super::{OutlivesConstraint, RegionInferenceContext};\n \n@@ -27,8 +28,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         writeln!(out, \"| Free Region Mapping\")?;\n \n         for region in self.regions() {\n-            if self.definitions[region].origin.is_universal() {\n-                let classification = self.universal_regions\n+            if let NLLRegionVariableOrigin::FreeRegion = self.definitions[region].origin {\n+                let classification = self\n+                    .universal_regions\n                     .region_classification(region)\n                     .unwrap();\n                 let outlived_by = self.universal_regions.regions_outlived_by(region);\n@@ -49,9 +51,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for region in self.regions() {\n             writeln!(\n                 out,\n-                \"| {r:rw$} | {v}\",\n+                \"| {r:rw$} | {ui:4?} | {v}\",\n                 r = format!(\"{:?}\", region),\n                 rw = REGION_WIDTH,\n+                ui = self.region_universe(region),\n                 v = self.region_value_str(region),\n             )?;\n         }"}, {"sha": "4472488a773494ee239361635a5c75b7e3c7865b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -401,16 +401,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     // `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         // Find all paths\n-        let (_path, r) = self\n-            .find_constraint_paths_between_regions(fr1, |r| {\n+        let (_path, r) =\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n                 self.liveness_constraints.contains(r, elem)\n-            })\n-            .unwrap();\n+            }).unwrap();\n         r\n     }\n \n     // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n-    crate fn find_outlives_blame_span(&self, mir: &Mir<'tcx>, fr1: RegionVid, fr2: RegionVid) -> Span {\n+    crate fn find_outlives_blame_span(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        fr1: RegionVid,\n+        fr2: RegionVid,\n+    ) -> Span {\n         let (_, span, _) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n         span\n     }"}, {"sha": "2ab72f655352fd67d5d620397c26ad4994966d11", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 202, "deletions": 28, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -13,7 +13,7 @@ use borrow_check::nll::constraints::graph::ConstraintGraph;\n use borrow_check::nll::constraints::{\n     ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n-use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n@@ -37,7 +37,7 @@ mod dump_mir;\n mod error_reporting;\n mod graphviz;\n pub mod values;\n-use self::values::{RegionValueElements, RegionValues, LivenessValues};\n+use self::values::{LivenessValues, RegionValueElements, RegionValues};\n \n use super::ToRegionVid;\n \n@@ -66,6 +66,11 @@ pub struct RegionInferenceContext<'tcx> {\n     /// of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n+    /// Contains the minimum universe of any variable within the same\n+    /// SCC. We will ensure that no SCC contains values that are not\n+    /// visible from this index.\n+    scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n+\n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n@@ -85,6 +90,12 @@ struct RegionDefinition<'tcx> {\n     /// info.)\n     origin: NLLRegionVariableOrigin,\n \n+    /// Which universe is this region variable defined in? This is\n+    /// most often `ty::UniverseIndex::ROOT`, but when we encounter\n+    /// forall-quantifiers like `for<'a> { 'a = 'b }`, we would create\n+    /// the variable for `'a` in a subuniverse.\n+    universe: ty::UniverseIndex,\n+\n     /// If this is 'static or an early-bound region, then this is\n     /// `Some(X)` where `X` is the name of the region.\n     external_name: Option<ty::Region<'tcx>>,\n@@ -207,39 +218,71 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n             .into_iter()\n-            .map(|info| RegionDefinition::new(info.origin))\n+            .map(|info| RegionDefinition::new(info.universe, info.origin))\n             .collect();\n \n+        // Compute the max universe used anywhere amongst the regions.\n+        let max_universe = definitions\n+            .iter()\n+            .map(|d| d.universe)\n+            .max()\n+            .unwrap_or(ty::UniverseIndex::ROOT);\n+\n         let constraints = Rc::new(outlives_constraints); // freeze constraints\n         let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph));\n \n-        let mut scc_values = RegionValues::new(\n-            elements,\n-            universal_regions.len(),\n-        );\n+        let mut scc_values = RegionValues::new(elements, universal_regions.len(), max_universe);\n \n         for region in liveness_constraints.rows() {\n             let scc = constraint_sccs.scc(region);\n             scc_values.merge_liveness(scc, region, &liveness_constraints);\n         }\n \n+        let scc_universes = Self::compute_scc_universes(&constraint_sccs, &definitions);\n+\n         let mut result = Self {\n             definitions,\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n+            scc_universes,\n             scc_values,\n             type_tests,\n             universal_regions,\n         };\n \n-        result.init_universal_regions();\n+        result.init_free_and_bound_regions();\n \n         result\n     }\n \n+    /// Each SCC is the combination of many region variables which\n+    /// have been equated. Therefore, we can associate a universe with\n+    /// each SCC which is minimum of all the universes of its\n+    /// constituent regions -- this is because whatever value the SCC\n+    /// takes on must be a value that each of the regions within the\n+    /// SCC could have as well. This implies that the SCC must have\n+    /// the minimum, or narrowest, universe.\n+    fn compute_scc_universes(\n+        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    ) -> IndexVec<ConstraintSccIndex, ty::UniverseIndex> {\n+        let num_sccs = constraints_scc.num_sccs();\n+        let mut scc_universes = IndexVec::from_elem_n(ty::UniverseIndex::MAX, num_sccs);\n+\n+        for (region_vid, region_definition) in definitions.iter_enumerated() {\n+            let scc = constraints_scc.scc(region_vid);\n+            let scc_universe = &mut scc_universes[scc];\n+            *scc_universe = ::std::cmp::min(*scc_universe, region_definition.universe);\n+        }\n+\n+        debug!(\"compute_scc_universes: scc_universe = {:#?}\", scc_universes);\n+\n+        scc_universes\n+    }\n+\n     /// Initializes the region variables for each universally\n     /// quantified region (lifetime parameter). The first N variables\n     /// always correspond to the regions appearing in the function\n@@ -260,7 +303,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and (b) any universally quantified regions that it outlives,\n     /// which in this case is just itself. R1 (`'b`) in contrast also\n     /// outlives `'a` and hence contains R0 and R1.\n-    fn init_universal_regions(&mut self) {\n+    fn init_free_and_bound_regions(&mut self) {\n         // Update the names (if any)\n         for (external_name, variable) in self.universal_regions.named_universal_regions() {\n             debug!(\n@@ -271,22 +314,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.definitions[variable].external_name = Some(external_name);\n         }\n \n-        // For each universally quantified region X:\n-        let universal_regions = self.universal_regions.clone();\n-        for variable in universal_regions.universal_regions() {\n-            // These should be free-region variables.\n-            assert!(match self.definitions[variable].origin {\n-                NLLRegionVariableOrigin::FreeRegion => true,\n-                NLLRegionVariableOrigin::Existential => false,\n-            });\n+        for variable in self.definitions.indices() {\n+            match self.definitions[variable].origin {\n+                NLLRegionVariableOrigin::FreeRegion => {\n+                    // For each free, universally quantified region X:\n \n-            // Add all nodes in the CFG to liveness constraints\n-            let variable_scc = self.constraint_sccs.scc(variable);\n-            self.liveness_constraints.add_all_points(variable);\n-            self.scc_values.add_all_points(variable_scc);\n+                    // Add all nodes in the CFG to liveness constraints\n+                    let variable_scc = self.constraint_sccs.scc(variable);\n+                    self.liveness_constraints.add_all_points(variable);\n+                    self.scc_values.add_all_points(variable_scc);\n \n-            // Add `end(X)` into the set for X.\n-            self.add_element_to_scc_of(variable, variable);\n+                    // Add `end(X)` into the set for X.\n+                    self.add_element_to_scc_of(variable, variable);\n+                }\n+\n+                NLLRegionVariableOrigin::BoundRegion(ui) => {\n+                    // Each placeholder region X outlives its\n+                    // associated universe but nothing else.\n+                    self.add_element_to_scc_of(variable, ui);\n+                }\n+\n+                NLLRegionVariableOrigin::Existential => {\n+                    // For existential, regions, nothing to do.\n+                }\n+            }\n         }\n     }\n \n@@ -317,6 +368,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.region_value_str(scc)\n     }\n \n+    /// Returns access to the value of `r` for debugging purposes.\n+    crate fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_universes[scc]\n+    }\n+\n     /// Adds `elem` to the value of the SCC in which `v` appears.\n     fn add_element_to_scc_of(&mut self, v: RegionVid, elem: impl ToElementIndex) {\n         debug!(\"add_live_element({:?}, {:?})\", v, elem);\n@@ -431,8 +488,32 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // ...compute the value of `B`...\n             self.propagate_constraint_sccs_if_new(scc_b, visited);\n \n-            // ...and add elements from `B` into `A`.\n-            self.scc_values.add_region(scc_a, scc_b);\n+            // ...and add elements from `B` into `A`. One complication\n+            // arises because of universes: If `B` contains something\n+            // that `A` cannot name, then `A` can only contain `B` if\n+            // it outlives static.\n+            if self.universe_compatible(scc_b, scc_a) {\n+                // `A` can name everything that is in `B`, so just\n+                // merge the bits.\n+                self.scc_values.add_region(scc_a, scc_b);\n+            } else {\n+                // Otherwise, the only way for `A` to outlive `B`\n+                // is for it to outlive static. This is actually stricter\n+                // than necessary: ideally, we'd support bounds like `for<'a: 'b`>`\n+                // that might then allow us to approximate `'a` with `'b` and not\n+                // `'static`. But it will have to do for now.\n+                //\n+                // The code here is a bit hacky: we grab the current\n+                // value of the SCC in which `'static` appears, but\n+                // this value may not be fully computed yet. That's ok\n+                // though: it will contain the base liveness values,\n+                // which include (a) the static free region element\n+                // and (b) all the points in the CFG, so it is \"good\n+                // enough\" to bring it in here for our purposes.\n+                let fr_static = self.universal_regions.fr_static;\n+                let scc_static = constraint_sccs.scc(fr_static);\n+                self.scc_values.add_region(scc_a, scc_static);\n+            }\n         }\n \n         debug!(\n@@ -442,6 +523,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n     }\n \n+    /// True if all the elements in the value of `scc_b` are nameable\n+    /// in `scc_a`. Used during constraint propagation, and only once\n+    /// the value of `scc_b` has been computed.\n+    fn universe_compatible(&self, scc_b: ConstraintSccIndex, scc_a: ConstraintSccIndex) -> bool {\n+        let universe_a = self.scc_universes[scc_a];\n+\n+        // Quick check: if scc_b's declared universe is a subset of\n+        // scc_a's declared univese (typically, both are ROOT), then\n+        // it cannot contain any problematic universe elements.\n+        if self.scc_universes[scc_b].is_subset_of(universe_a) {\n+            return true;\n+        }\n+\n+        // Otherwise, we have to iterate over the universe elements in\n+        // B's value, and check whether all of them are nameable\n+        // from universe_a\n+        self.scc_values\n+            .subuniverses_contained_in(scc_b)\n+            .all(|u| u.is_subset_of(universe_a))\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:\n@@ -785,8 +887,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        self.scc_values\n-            .contains_points(sup_region_scc, sub_region_scc)\n+        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -830,6 +931,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     );\n                 }\n \n+                NLLRegionVariableOrigin::BoundRegion(universe) => {\n+                    self.check_bound_universal_region(infcx, mir, mir_def_id, fr, universe);\n+                }\n+\n                 NLLRegionVariableOrigin::Existential => {\n                     // nothing to check here\n                 }\n@@ -858,6 +963,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n \n+        // Because this free region must be in the ROOT universe, we\n+        // know it cannot contain any bound universes.\n+        assert!(self.scc_universes[longer_fr_scc] == ty::UniverseIndex::ROOT);\n+        debug_assert!(\n+            self.scc_values\n+                .subuniverses_contained_in(longer_fr_scc)\n+                .next()\n+                .is_none()\n+        );\n+\n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n@@ -910,10 +1025,68 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         }\n     }\n+\n+    fn check_bound_universal_region<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        _mir_def_id: DefId,\n+        longer_fr: RegionVid,\n+        universe: ty::UniverseIndex,\n+    ) {\n+        debug!(\"check_bound_universal_region(fr={:?})\", longer_fr);\n+\n+        let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n+\n+        // If we have some bound universal region `'a`, then the only\n+        // elements it can contain is itself -- we don't know anything\n+        // else about it!\n+        let error_element = match {\n+            self.scc_values\n+                .elements_contained_in(longer_fr_scc)\n+                .find(|element| match element {\n+                    RegionElement::Location(_) => true,\n+                    RegionElement::RootUniversalRegion(_) => true,\n+                    RegionElement::SubUniversalRegion(ui) => *ui != universe,\n+                })\n+        } {\n+            Some(v) => v,\n+            None => return,\n+        };\n+\n+        // Find the region that introduced this `error_element`.\n+        let error_region = match error_element {\n+            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n+            RegionElement::RootUniversalRegion(r) => r,\n+            RegionElement::SubUniversalRegion(error_ui) => self\n+                .definitions\n+                .iter_enumerated()\n+                .filter_map(|(r, definition)| match definition.origin {\n+                    NLLRegionVariableOrigin::BoundRegion(ui) if error_ui == ui => Some(r),\n+                    _ => None,\n+                })\n+                .next()\n+                .unwrap(),\n+        };\n+\n+        // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n+        let span = self.find_outlives_blame_span(mir, longer_fr, error_region);\n+\n+        // Obviously, this error message is far from satisfactory.\n+        // At present, though, it only appears in unit tests --\n+        // the AST-based checker uses a more conservative check,\n+        // so to even see this error, one must pass in a special\n+        // flag.\n+        let mut diag = infcx\n+            .tcx\n+            .sess\n+            .struct_span_err(span, &format!(\"higher-ranked subtype error\"));\n+        diag.emit();\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {\n-    fn new(rv_origin: RegionVariableOrigin) -> Self {\n+    fn new(universe: ty::UniverseIndex, rv_origin: RegionVariableOrigin) -> Self {\n         // Create a new region definition. Note that, for free\n         // regions, the `external_name` field gets updated later in\n         // `init_universal_regions`.\n@@ -925,6 +1098,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n \n         Self {\n             origin,\n+            universe,\n             external_name: None,\n         }\n     }"}, {"sha": "2d7cbfce1a31bfdc370dc71d3893d1f605ebc1e5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 95, "deletions": 67, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -9,15 +9,14 @@\n // except according to those terms.\n \n use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::ty::RegionVid;\n+use rustc::ty::{self, RegionVid};\n use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n use std::rc::Rc;\n \n-/// Maps between the various kinds of elements of a region value to\n-/// the internal indices that w use.\n+/// Maps between a `Location` and a `PointIndex` (and vice versa).\n crate struct RegionValueElements {\n     /// For each basic block, how many points are contained within?\n     statements_before_block: IndexVec<BasicBlock, usize>,\n@@ -98,6 +97,12 @@ impl RegionValueElements {\n /// graph. Constructed efficiently from `RegionValueElements`.\n newtype_index!(PointIndex { DEBUG_FORMAT = \"PointIndex({})\" });\n \n+/// A single integer representing a (non-zero) `UniverseIndex`.\n+/// Computed just by subtracting one from `UniverseIndex`; this is\n+/// because the `0` value for `UniverseIndex` represents the root\n+/// universe, and we don't need/want a bit for that one.\n+newtype_index!(PlaceholderIndex { DEBUG_FORMAT = \"PointIndex({})\" });\n+\n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -108,6 +113,10 @@ crate enum RegionElement {\n     /// A universally quantified region from the root universe (e.g.,\n     /// a lifetime parameter).\n     RootUniversalRegion(RegionVid),\n+\n+    /// A subuniverse from a subuniverse (e.g., instantiated from a\n+    /// `for<'a> fn(&'a u32)` type).\n+    SubUniversalRegion(ty::UniverseIndex),\n }\n \n /// When we initially compute liveness, we use a bit matrix storing\n@@ -135,11 +144,7 @@ impl<N: Idx> LivenessValues<N> {\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    crate fn add_element(\n-        &mut self,\n-        row: N,\n-        location: Location,\n-    ) -> bool {\n+    crate fn add_element(&mut self, row: N, location: Location) -> bool {\n         debug!(\"LivenessValues::add(r={:?}, location={:?})\", row, location);\n         let index = self.elements.point_from_location(location);\n         self.points.add(row, index)\n@@ -164,20 +169,38 @@ impl<N: Idx> LivenessValues<N> {\n                 .into_iter()\n                 .flat_map(|set| set.iter())\n                 .map(|p| self.elements.to_location(p))\n-                .map(RegionElement::Location)\n+                .map(RegionElement::Location),\n         )\n     }\n }\n \n-/// Stores the values for a set of regions. These are stored in a\n-/// compact `SparseBitMatrix` representation, with one row per region\n-/// variable. The columns consist of either universal regions or\n-/// points in the CFG.\n+/// Stores the full values for a set of regions (in contrast to\n+/// `LivenessValues`, which only stores those points in the where a\n+/// region is live). The full value for a region may contain points in\n+/// the CFG, but also free regions as well as bound universe\n+/// placeholders.\n+///\n+/// Example:\n+///\n+/// ```rust\n+/// fn foo(x: &'a u32) -> &'a u32 {\n+///    let y: &'0 u32 = x; // let's call this `'0`\n+///    y\n+/// }\n+/// ```\n+///\n+/// Here, the variable `'0` would contain the free region `'a`,\n+/// because (since it is returned) it must live for at least `'a`. But\n+/// it would also contain various points from within the function.\n #[derive(Clone)]\n crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     points: SparseBitMatrix<N, PointIndex>,\n     free_regions: SparseBitMatrix<N, RegionVid>,\n+\n+    /// Placeholders represent bound regions -- so something like `'a`\n+    /// in for<'a> fn(&'a u32)`.\n+    placeholders: SparseBitMatrix<N, PlaceholderIndex>,\n }\n \n impl<N: Idx> RegionValues<N> {\n@@ -187,21 +210,20 @@ impl<N: Idx> RegionValues<N> {\n     crate fn new(\n         elements: &Rc<RegionValueElements>,\n         num_universal_regions: usize,\n+        max_universe: ty::UniverseIndex,\n     ) -> Self {\n+        let num_placeholders = max_universe.as_usize();\n         Self {\n             elements: elements.clone(),\n             points: SparseBitMatrix::new(elements.num_points),\n             free_regions: SparseBitMatrix::new(num_universal_regions),\n+            placeholders: SparseBitMatrix::new(num_placeholders),\n         }\n     }\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    crate fn add_element(\n-        &mut self,\n-        r: N,\n-        elem: impl ToElementIndex,\n-    ) -> bool {\n+    crate fn add_element(&mut self, r: N, elem: impl ToElementIndex) -> bool {\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n         elem.add_to_row(self, r)\n     }\n@@ -214,16 +236,13 @@ impl<N: Idx> RegionValues<N> {\n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n     /// r_from`).\n     crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n-        self.points.merge(r_from, r_to) | self.free_regions.merge(r_from, r_to)\n-        // FIXME universes?\n+        self.points.merge(r_from, r_to)\n+            | self.free_regions.merge(r_from, r_to)\n+            | self.placeholders.merge(r_from, r_to)\n     }\n \n     /// True if the region `r` contains the given element.\n-    crate fn contains(\n-        &self,\n-        r: N,\n-        elem: impl ToElementIndex,\n-    ) -> bool {\n+    crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n         elem.contained_in_row(self, r)\n     }\n \n@@ -255,10 +274,7 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns the locations contained within a given region `r`.\n-    crate fn locations_outlived_by<'a>(\n-        &'a self,\n-        r: N,\n-    ) -> impl Iterator<Item = Location> + 'a {\n+    crate fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n         self.points\n             .row(r)\n             .into_iter()\n@@ -277,19 +293,32 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn elements_contained_in<'a>(\n+    crate fn subuniverses_contained_in<'a>(\n         &'a self,\n         r: N,\n-    ) -> impl Iterator<Item = RegionElement> + 'a {\n-        let points_iter = self\n-            .locations_outlived_by(r)\n-            .map(RegionElement::Location);\n+    ) -> impl Iterator<Item = ty::UniverseIndex> + 'a {\n+        self.placeholders\n+            .row(r)\n+            .into_iter()\n+            .flat_map(|set| set.iter())\n+            .map(|p| ty::UniverseIndex::from_u32((p.index() + 1) as u32))\n+    }\n+\n+    /// Returns all the elements contained in a given region's value.\n+    crate fn elements_contained_in<'a>(&'a self, r: N) -> impl Iterator<Item = RegionElement> + 'a {\n+        let points_iter = self.locations_outlived_by(r).map(RegionElement::Location);\n \n         let free_regions_iter = self\n             .universal_regions_outlived_by(r)\n             .map(RegionElement::RootUniversalRegion);\n \n-        points_iter.chain(free_regions_iter)\n+        let subuniverses_iter = self\n+            .subuniverses_contained_in(r)\n+            .map(RegionElement::SubUniversalRegion);\n+\n+        points_iter\n+            .chain(free_regions_iter)\n+            .chain(subuniverses_iter)\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n@@ -299,58 +328,46 @@ impl<N: Idx> RegionValues<N> {\n }\n \n crate trait ToElementIndex: Debug + Copy {\n-    fn add_to_row<N: Idx>(\n-        self,\n-        values: &mut RegionValues<N>,\n-        row: N,\n-    ) -> bool;\n-\n-    fn contained_in_row<N: Idx>(\n-        self,\n-        values: &RegionValues<N>,\n-        row: N,\n-    ) -> bool;\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool;\n+\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool;\n }\n \n impl ToElementIndex for Location {\n-    fn add_to_row<N: Idx>(\n-        self,\n-        values: &mut RegionValues<N>,\n-        row: N,\n-    ) -> bool {\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n         let index = values.elements.point_from_location(self);\n         values.points.add(row, index)\n     }\n \n-    fn contained_in_row<N: Idx>(\n-        self,\n-        values: &RegionValues<N>,\n-        row: N,\n-    ) -> bool {\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n         let index = values.elements.point_from_location(self);\n         values.points.contains(row, index)\n     }\n }\n \n impl ToElementIndex for RegionVid {\n-    fn add_to_row<N: Idx>(\n-        self,\n-        values: &mut RegionValues<N>,\n-        row: N,\n-    ) -> bool {\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n         values.free_regions.add(row, self)\n     }\n \n-    fn contained_in_row<N: Idx>(\n-        self,\n-        values: &RegionValues<N>,\n-        row: N,\n-    ) -> bool {\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n         values.free_regions.contains(row, self)\n     }\n }\n \n-crate fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String {\n+impl ToElementIndex for ty::UniverseIndex {\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n+        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        values.placeholders.add(row, index)\n+    }\n+\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n+        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        values.placeholders.contains(row, index)\n+    }\n+}\n+\n+fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String {\n     let mut result = String::new();\n     result.push_str(\"{\");\n \n@@ -394,6 +411,17 @@ crate fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) ->\n                 push_sep(&mut result);\n                 result.push_str(&format!(\"{:?}\", fr));\n             }\n+\n+            RegionElement::SubUniversalRegion(ur) => {\n+                if let Some((location1, location2)) = open_location {\n+                    push_sep(&mut result);\n+                    push_location_range(&mut result, location1, location2);\n+                    open_location = None;\n+                }\n+\n+                push_sep(&mut result);\n+                result.push_str(&format!(\"{:?}\", ur));\n+            }\n         }\n     }\n "}, {"sha": "b67de34593f80b3607cdf8ce1dc9431825b90ddb", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -35,7 +35,7 @@ use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants, RegionVid};\n+use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -73,6 +73,7 @@ macro_rules! span_mirbug_and_err {\n mod constraint_conversion;\n mod input_output;\n mod liveness;\n+mod relate_tys;\n \n /// Type checks the given `mir` in the context of the inference\n /// context `infcx`. Returns any region constraints that have yet to\n@@ -796,16 +797,38 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n-        let param_env = self.param_env;\n-        self.fully_perform_op(\n+        relate_tys::sub_types(\n+            self.infcx,\n+            sub,\n+            sup,\n             locations,\n-            param_env.and(type_op::subtype::Subtype::new(sub, sup)),\n+            self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n \n     fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n-        let param_env = self.param_env;\n-        self.fully_perform_op(locations, param_env.and(type_op::eq::Eq::new(b, a)))\n+        relate_tys::eq_types(\n+            self.infcx,\n+            a,\n+            b,\n+            locations,\n+            self.borrowck_context.as_mut().map(|x| &mut **x),\n+        )\n+    }\n+\n+    fn eq_canonical_type_and_type(\n+        &mut self,\n+        a: CanonicalTy<'tcx>,\n+        b: Ty<'tcx>,\n+        locations: Locations,\n+    ) -> Fallible<()> {\n+        relate_tys::eq_canonical_type_and_type(\n+            self.infcx,\n+            a,\n+            b,\n+            locations,\n+            self.borrowck_context.as_mut().map(|x| &mut **x),\n+        )\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -877,20 +900,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::UserAssertTy(ref c_ty, ref local) => {\n-                let local_ty = mir.local_decls()[*local].ty;\n-                let (ty, _) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(stmt.source_info.span, c_ty);\n-                debug!(\n-                    \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n-                    ty, local_ty\n-                );\n-                if let Err(terr) = self.eq_types(ty, local_ty, Locations::All) {\n+            StatementKind::UserAssertTy(c_ty, local) => {\n+                let local_ty = mir.local_decls()[local].ty;\n+                if let Err(terr) = self.eq_canonical_type_and_type(c_ty, local_ty, Locations::All) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n                         \"bad type assert ({:?} = {:?}): {:?}\",\n-                        ty,\n+                        c_ty,\n                         local_ty,\n                         terr\n                     );"}, {"sha": "095e3cb6296002e3dc3c4de30c51564354aa92e5", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -0,0 +1,510 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::constraints::OutlivesConstraint;\n+use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::ToRegionVid;\n+use rustc::infer::canonical::{Canonical, CanonicalVarInfos};\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::traits::query::Fallible;\n+use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n+use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::mem;\n+\n+pub(super) fn sub_types<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+    locations: Locations,\n+    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n+) -> Fallible<()> {\n+    debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n+    TypeRelating::new(\n+        infcx,\n+        ty::Variance::Covariant,\n+        locations,\n+        borrowck_context,\n+        ty::Slice::empty(),\n+    ).relate(&a, &b)?;\n+    Ok(())\n+}\n+\n+pub(super) fn eq_types<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+    locations: Locations,\n+    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n+) -> Fallible<()> {\n+    debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n+    TypeRelating::new(\n+        infcx,\n+        ty::Variance::Invariant,\n+        locations,\n+        borrowck_context,\n+        ty::Slice::empty(),\n+    ).relate(&a, &b)?;\n+    Ok(())\n+}\n+\n+pub(super) fn eq_canonical_type_and_type<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    a: CanonicalTy<'tcx>,\n+    b: Ty<'tcx>,\n+    locations: Locations,\n+    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n+) -> Fallible<()> {\n+    debug!(\n+        \"eq_canonical_type_and_type(a={:?}, b={:?}, locations={:?})\",\n+        a, b, locations\n+    );\n+    let Canonical {\n+        variables: a_variables,\n+        value: a_value,\n+    } = a;\n+    TypeRelating::new(\n+        infcx,\n+        ty::Variance::Invariant,\n+        locations,\n+        borrowck_context,\n+        a_variables,\n+    ).relate(&a_value, &b)?;\n+    Ok(())\n+}\n+\n+struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+\n+    /// How are we relating `a` and `b`?\n+    ///\n+    /// - covariant means `a <: b`\n+    /// - contravariant means `b <: a`\n+    /// - invariant means `a == b\n+    /// - bivariant means that it doesn't matter\n+    ambient_variance: ty::Variance,\n+\n+    /// When we pass through a set of binders (e.g., when looking into\n+    /// a `fn` type), we push a new bound region scope onto here.  This\n+    /// will contain the instantiated region for each region in those\n+    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n+    /// use the debruijn index `d` to find the right scope, and then\n+    /// bound region name `br` to find the specific instantiation from\n+    /// within that scope. See `replace_bound_region`.\n+    ///\n+    /// This field stores the instantiations for late-bound regions in\n+    /// the `a` type.\n+    a_scopes: Vec<BoundRegionScope>,\n+\n+    /// Same as `a_scopes`, but for the `b` type.\n+    b_scopes: Vec<BoundRegionScope>,\n+\n+    /// Where (and why) is this relation taking place?\n+    locations: Locations,\n+\n+    /// This will be `Some` when we are running the type check as part\n+    /// of NLL, and `None` if we are running a \"sanity check\".\n+    borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n+\n+    /// As we execute, the type on the LHS *may* come from a canonical\n+    /// source. In that case, we will sometimes find a constraint like\n+    /// `?0 = B`, where `B` is a type from the RHS. The first time we\n+    /// find that, we simply record `B` (and the list of scopes that\n+    /// tells us how to *interpret* `B`). The next time we encounter\n+    /// `?0`, then, we can read this value out and use it.\n+    ///\n+    /// One problem: these variables may be in some other universe,\n+    /// how can we enforce that? I guess I could add some kind of\n+    /// \"minimum universe constraint\" that we can feed to the NLL checker.\n+    /// --> also, we know this doesn't happen\n+    canonical_var_values: IndexVec<CanonicalVar, Option<ScopesAndKind<'tcx>>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ScopesAndKind<'tcx> {\n+    scopes: Vec<BoundRegionScope>,\n+    kind: Kind<'tcx>,\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+struct BoundRegionScope {\n+    map: FxHashMap<ty::BoundRegion, RegionVid>,\n+}\n+\n+#[derive(Copy, Clone)]\n+struct UniversallyQuantified(bool);\n+\n+impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        ambient_variance: ty::Variance,\n+        locations: Locations,\n+        borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n+        canonical_var_infos: CanonicalVarInfos<'tcx>,\n+    ) -> Self {\n+        let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n+        Self {\n+            infcx,\n+            ambient_variance,\n+            borrowck_context,\n+            locations,\n+            canonical_var_values,\n+            a_scopes: vec![],\n+            b_scopes: vec![],\n+        }\n+    }\n+\n+    fn ambient_covariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Covariant | ty::Variance::Invariant => true,\n+            ty::Variance::Contravariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn ambient_contravariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Contravariant | ty::Variance::Invariant => true,\n+            ty::Variance::Covariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn create_scope(\n+        &mut self,\n+        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> BoundRegionScope {\n+        let mut scope = BoundRegionScope::default();\n+        value.skip_binder().visit_with(&mut ScopeInstantiator {\n+            infcx: self.infcx,\n+            target_index: ty::INNERMOST,\n+            universally_quantified,\n+            bound_region_scope: &mut scope,\n+        });\n+        scope\n+    }\n+\n+    fn replace_bound_region(\n+        &self,\n+        universal_regions: &UniversalRegions<'tcx>,\n+        r: ty::Region<'tcx>,\n+        scopes: &[BoundRegionScope],\n+    ) -> RegionVid {\n+        match r {\n+            ty::ReLateBound(debruijn, br) => {\n+                // The debruijn index is a \"reverse index\" into the\n+                // scopes listing. So when we have INNERMOST (0), we\n+                // want the *last* scope pushed, and so forth.\n+                let debruijn_index = debruijn.index() - ty::INNERMOST.index();\n+                let scope = &scopes[scopes.len() - debruijn_index - 1];\n+\n+                // Find this bound region in that scope to map to a\n+                // particular region.\n+                scope.map[br]\n+            }\n+\n+            ty::ReVar(v) => *v,\n+\n+            _ => universal_regions.to_region_vid(r),\n+        }\n+    }\n+\n+    fn push_outlives(&mut self, sup: RegionVid, sub: RegionVid) {\n+        debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n+\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            borrowck_context\n+                .constraints\n+                .outlives_constraints\n+                .push(OutlivesConstraint {\n+                    sup,\n+                    sub,\n+                    locations: self.locations,\n+                });\n+\n+            // FIXME all facts!\n+        }\n+    }\n+\n+    fn equate_var(\n+        &mut self,\n+        var: CanonicalVar,\n+        b_kind: Kind<'tcx>,\n+    ) -> RelateResult<'tcx, Kind<'tcx>> {\n+        debug!(\"equate_var(var={:?}, b_kind={:?})\", var, b_kind);\n+\n+        // We only encounter canonical variables when equating.\n+        assert_eq!(self.ambient_variance, ty::Variance::Invariant);\n+\n+        // The canonical variable already had a value. Equate that\n+        // value with `b`.\n+        let old_value = self.canonical_var_values[var].clone();\n+        if let Some(ScopesAndKind { scopes, kind }) = old_value {\n+            debug!(\"equate_var: installing kind={:?} scopes={:?}\", kind, scopes);\n+            let old_a_scopes = mem::replace(&mut self.a_scopes, scopes);\n+            let result = self.relate(&kind, &b_kind);\n+            self.a_scopes = old_a_scopes;\n+            debug!(\"equate_var: complete, result = {:?}\", result);\n+            return result;\n+        }\n+\n+        // Not yet. Capture the value from the RHS and carry on.\n+        self.canonical_var_values[var] = Some(ScopesAndKind {\n+            scopes: self.b_scopes.clone(),\n+            kind: b_kind,\n+        });\n+        debug!(\n+            \"equate_var: capturing value {:?}\",\n+            self.canonical_var_values[var]\n+        );\n+\n+        // FIXME -- technically, we should add some sort of\n+        // assertion that this value can be named in the universe\n+        // of the canonical variable. But in practice these\n+        // canonical variables only arise presently in cases where\n+        // they are in the root universe and the main typeck has\n+        // ensured there are no universe errors. So we just kind\n+        // of over look this right now.\n+        Ok(b_kind)\n+    }\n+}\n+\n+impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n+    for TypeRelating<'cx, 'bccx, 'gcx, 'tcx>\n+{\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::subtype\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        // Watch out for the case that we are matching a `?T` against the\n+        // right-hand side.\n+        if let ty::TyInfer(ty::CanonicalTy(var)) = a.sty {\n+            self.equate_var(var, b.into())?;\n+            Ok(a)\n+        } else {\n+            debug!(\n+                \"tys(a={:?}, b={:?}, variance={:?})\",\n+                a, b, self.ambient_variance\n+            );\n+\n+            relate::super_relate_tys(self, a, b)\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        if let Some(&mut BorrowCheckContext {\n+            universal_regions, ..\n+        }) = self.borrowck_context\n+        {\n+            if let ty::ReCanonical(var) = a {\n+                self.equate_var(*var, b.into())?;\n+                return Ok(a);\n+            }\n+\n+            debug!(\n+                \"regions(a={:?}, b={:?}, variance={:?})\",\n+                a, b, self.ambient_variance\n+            );\n+\n+            let v_a = self.replace_bound_region(universal_regions, a, &self.a_scopes);\n+            let v_b = self.replace_bound_region(universal_regions, b, &self.b_scopes);\n+\n+            debug!(\"regions: v_a = {:?}\", v_a);\n+            debug!(\"regions: v_b = {:?}\", v_b);\n+\n+            if self.ambient_covariance() {\n+                // Covariance: a <= b. Hence, `b: a`.\n+                self.push_outlives(v_b, v_a);\n+            }\n+\n+            if self.ambient_contravariance() {\n+                // Contravariant: b <= a. Hence, `a: b`.\n+                self.push_outlives(v_a, v_b);\n+            }\n+        }\n+\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        // We want that\n+        //\n+        // ```\n+        // for<'a> fn(&'a u32) -> &'a u32 <:\n+        //   fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // but not\n+        //\n+        // ```\n+        // fn(&'a u32) -> &'a u32 <:\n+        //   for<'b> fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // We therefore proceed as follows:\n+        //\n+        // - Instantiate binders on `b` universally, yielding a universe U1.\n+        // - Instantiate binders on `a` existentially in U1.\n+\n+        debug!(\n+            \"binders({:?}: {:?}, ambient_variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n+\n+        if self.ambient_covariance() {\n+            // Covariance, so we want `for<'a> A <: for<'b...> B` --\n+            // therefore we replace all of the `'b...` regions with\n+            // placeholders and then replace `'a...` with\n+            // existentials. We then check if any instantiation of A\n+            // can match against the placeholders in B.\n+\n+            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n+            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n+\n+            self.b_scopes.push(b_scope);\n+            self.a_scopes.push(a_scope);\n+\n+            // FIXME -- to be fully correct, we would set the ambient\n+            // variance to Covariant here. As is, we will sometimes\n+            // propagate down an ambient variance of Equal -- this in\n+            // turn causes us to report errors in some cases where\n+            // types perhaps *ought* to be equal. See the\n+            // `hr-fn-aau-eq-abu.rs` test for an example. Fixing this\n+            // though is a bit nontrivial: in particular, it would\n+            // require a more involved handling of canonical\n+            // variables, since we would no longer be able to rely on\n+            // having an `==` relationship for canonical variables.\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        if self.ambient_contravariance() {\n+            // Contravariance, so we want `for<'a> A :> for<'b...> B`\n+            // -- do the opposite, therefore, of covariant. Replace\n+            // the `'a...` placeholders with `'b...` variables.\n+\n+            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n+            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n+\n+            self.a_scopes.push(a_scope);\n+            self.b_scopes.push(b_scope);\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        Ok(a.clone())\n+    }\n+}\n+\n+struct ScopeInstantiator<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    // The debruijn index of the scope we are instantiating.\n+    target_index: ty::DebruijnIndex,\n+    universally_quantified: UniversallyQuantified,\n+    bound_region_scope: &'cx mut BoundRegionScope,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.target_index.shift_in(1);\n+        t.super_visit_with(self);\n+        self.target_index.shift_out(1);\n+\n+        false\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        let ScopeInstantiator {\n+            infcx,\n+            universally_quantified,\n+            ..\n+        } = *self;\n+\n+        match r {\n+            ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n+                self.bound_region_scope.map.entry(*br).or_insert_with(|| {\n+                    let origin = if universally_quantified.0 {\n+                        NLLRegionVariableOrigin::BoundRegion(infcx.create_subuniverse())\n+                    } else {\n+                        NLLRegionVariableOrigin::Existential\n+                    };\n+                    infcx.next_nll_region_var(origin).to_region_vid()\n+                });\n+            }\n+\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+}"}, {"sha": "84c305f5907d102a44064cb924a643ada33e39bb", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning either argument CANNOT be upcast to one\n+// that returns always its first argument.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn make_it() -> for<'a> fn(&'a u32, &'a u32) -> &'a u32 {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+    //~^ ERROR higher-ranked subtype error\n+    drop(a);\n+}"}, {"sha": "e08d848b471407d8697a65afd9d50762b23e49ce", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hr-fn-aaa-as-aba.rs:24:58\n+   |\n+LL |     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+   |                                                          ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d62354fece6dbadb22d4a56ad3cfadff46a36835", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test an interesting corner case: a fn that takes two arguments that\n+// are references with the same lifetime is in fact equivalent to a fn\n+// that takes two references with distinct lifetimes. This is true\n+// because the two functions can call one another -- effectively, the\n+// single lifetime `'a` is just inferred to be the intersection of the\n+// two distinct lifetimes.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+use std::cell::Cell;\n+\n+fn make_cell_aa() -> Cell<for<'a> fn(&'a u32, &'a u32)> {\n+    panic!()\n+}\n+\n+fn aa_eq_ab() {\n+    let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n+    //~^ ERROR higher-ranked subtype error\n+    //\n+    // FIXME -- this .. arguably ought to be accepted. However, the\n+    // current leak check also rejects this example, and it's kind of\n+    // a pain to support it. There are some comments in `relate_tys`\n+    drop(a);\n+}\n+\n+fn main() { }"}, {"sha": "6ba969ab0ef599099491a836fd5ac9379dfdb6ac", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hr-fn-aau-eq-abu.rs:29:53\n+   |\n+LL |     let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n+   |                                                     ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4f73ca3a53921dbf25ed73b93ab89d9ea6226dae", "filename": "src/test/ui/nll/relate_tys/hr-fn-aba-as-aaa.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aba-as-aaa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9afd2bb38eed6f82b2b3b862b83125a44f69044/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aba-as-aaa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aba-as-aaa.rs?ref=d9afd2bb38eed6f82b2b3b862b83125a44f69044", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning always its first argument can be upcast to one\n+// that returns either first or second argument.\n+//\n+// compile-pass\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn make_it() -> for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: for<'a> fn(&'a u32, &'a u32) -> &'a u32 = make_it();\n+    drop(a);\n+}"}]}