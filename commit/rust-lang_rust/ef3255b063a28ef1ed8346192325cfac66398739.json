{"sha": "ef3255b063a28ef1ed8346192325cfac66398739", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMzI1NWIwNjNhMjhlZjFlZDgzNDYxOTIzMjVjZmFjNjYzOTg3Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-26T00:27:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-26T00:27:00Z"}, "message": "Auto merge of #27991 - bluss:chain-rev, r=alexcrichton\n\nCorrect iterator adaptor Chain\r\n\r\nThe iterator protocol specifies that the iteration ends with the return\r\nvalue `None` from `.next()` (or `.next_back()`) and it is unspecified\r\nwhat further calls return. The chain adaptor must account for this in\r\nits DoubleEndedIterator implementation.\r\n\r\nIt uses three states:\r\n\r\n- Both `a` and `b` are valid\r\n- Only the Front iterator (`a`) is valid\r\n- Only the Back iterator (`b`) is valid\r\n\r\nThe fourth state (neither iterator is valid) only occurs after Chain has\r\nreturned None once, so we don't need to store this state.\r\n\r\nFixes #26316", "tree": {"sha": "67a26718b02c4bf22d79fa7a2d0e4390e8129d72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67a26718b02c4bf22d79fa7a2d0e4390e8129d72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef3255b063a28ef1ed8346192325cfac66398739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3255b063a28ef1ed8346192325cfac66398739", "html_url": "https://github.com/rust-lang/rust/commit/ef3255b063a28ef1ed8346192325cfac66398739", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef3255b063a28ef1ed8346192325cfac66398739/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14b7591ee578042da43f6a9968034f4998cf291c", "url": "https://api.github.com/repos/rust-lang/rust/commits/14b7591ee578042da43f6a9968034f4998cf291c", "html_url": "https://github.com/rust-lang/rust/commit/14b7591ee578042da43f6a9968034f4998cf291c"}, {"sha": "35eb3e8b79c60ec18e724c7a68625d7cdf9300c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/35eb3e8b79c60ec18e724c7a68625d7cdf9300c0", "html_url": "https://github.com/rust-lang/rust/commit/35eb3e8b79c60ec18e724c7a68625d7cdf9300c0"}], "stats": {"total": 116, "additions": 91, "deletions": 25}, "files": [{"sha": "98d885e8dd34dfe15d88862e77e579533fe9cb79", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 71, "deletions": 25, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ef3255b063a28ef1ed8346192325cfac66398739/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3255b063a28ef1ed8346192325cfac66398739/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ef3255b063a28ef1ed8346192325cfac66398739", "patch": "@@ -184,7 +184,7 @@ pub trait Iterator {\n     fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter> where\n         Self: Sized, U: IntoIterator<Item=Self::Item>,\n     {\n-        Chain{a: self, b: other.into_iter(), flag: false}\n+        Chain{a: self, b: other.into_iter(), state: ChainState::Both}\n     }\n \n     /// Creates an iterator that iterates over both this and the specified\n@@ -1277,7 +1277,30 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n pub struct Chain<A, B> {\n     a: A,\n     b: B,\n-    flag: bool,\n+    state: ChainState,\n+}\n+\n+// The iterator protocol specifies that iteration ends with the return value\n+// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n+// further calls return. The chain adaptor must account for this since it uses\n+// two subiterators.\n+//\n+//  It uses three states:\n+//\n+//  - Both: `a` and `b` are remaining\n+//  - Front: `a` remaining\n+//  - Back: `b` remaining\n+//\n+//  The fourth state (neither iterator is remaining) only occurs after Chain has\n+//  returned None once, so we don't need to store this state.\n+#[derive(Clone)]\n+enum ChainState {\n+    // both front and back iterator are remaining\n+    Both,\n+    // only front is remaining\n+    Front,\n+    // only back is remaining\n+    Back,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1289,42 +1312,58 @@ impl<A, B> Iterator for Chain<A, B> where\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n-        if self.flag {\n-            self.b.next()\n-        } else {\n-            match self.a.next() {\n-                Some(x) => return Some(x),\n-                _ => ()\n-            }\n-            self.flag = true;\n-            self.b.next()\n+        match self.state {\n+            ChainState::Both => match self.a.next() {\n+                elt @ Some(..) => return elt,\n+                None => {\n+                    self.state = ChainState::Back;\n+                    self.b.next()\n+                }\n+            },\n+            ChainState::Front => self.a.next(),\n+            ChainState::Back => self.b.next(),\n         }\n     }\n \n     #[inline]\n     fn count(self) -> usize {\n-        (if !self.flag { self.a.count() } else { 0 }) + self.b.count()\n+        match self.state {\n+            ChainState::Both => self.a.count() + self.b.count(),\n+            ChainState::Front => self.a.count(),\n+            ChainState::Back => self.b.count(),\n+        }\n     }\n \n     #[inline]\n     fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n-        if !self.flag {\n-            for x in self.a.by_ref() {\n-                if n == 0 {\n-                    return Some(x)\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                for x in self.a.by_ref() {\n+                    if n == 0 {\n+                        return Some(x)\n+                    }\n+                    n -= 1;\n+                }\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n                 }\n-                n -= 1;\n             }\n-            self.flag = true;\n+            ChainState::Back => {}\n+        }\n+        if let ChainState::Back = self.state {\n+            self.b.nth(n)\n+        } else {\n+            None\n         }\n-        self.b.nth(n)\n     }\n \n     #[inline]\n     fn last(self) -> Option<A::Item> {\n-        let a_last = if self.flag { None } else { self.a.last() };\n-        let b_last = self.b.last();\n-        b_last.or(a_last)\n+        match self.state {\n+            ChainState::Both => self.b.last().or(self.a.last()),\n+            ChainState::Front => self.a.last(),\n+            ChainState::Back => self.b.last()\n+        }\n     }\n \n     #[inline]\n@@ -1350,9 +1389,16 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n-        match self.b.next_back() {\n-            Some(x) => Some(x),\n-            None => self.a.next_back()\n+        match self.state {\n+            ChainState::Both => match self.b.next_back() {\n+                elt @ Some(..) => return elt,\n+                None => {\n+                    self.state = ChainState::Front;\n+                    self.a.next_back()\n+                }\n+            },\n+            ChainState::Front => self.a.next_back(),\n+            ChainState::Back => self.b.next_back(),\n         }\n     }\n }"}, {"sha": "87e69581c54b39b44184896669dda77a94c98d72", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef3255b063a28ef1ed8346192325cfac66398739/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3255b063a28ef1ed8346192325cfac66398739/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=ef3255b063a28ef1ed8346192325cfac66398739", "patch": "@@ -729,6 +729,26 @@ fn test_double_ended_chain() {\n     assert_eq!(it.next_back().unwrap(), &5);\n     assert_eq!(it.next_back().unwrap(), &7);\n     assert_eq!(it.next_back(), None);\n+\n+\n+    // test that .chain() is well behaved with an unfused iterator\n+    struct CrazyIterator(bool);\n+    impl CrazyIterator { fn new() -> CrazyIterator { CrazyIterator(false) } }\n+    impl Iterator for CrazyIterator {\n+        type Item = i32;\n+        fn next(&mut self) -> Option<i32> {\n+            if self.0 { Some(99) } else { self.0 = true; None }\n+        }\n+    }\n+\n+    impl DoubleEndedIterator for CrazyIterator {\n+        fn next_back(&mut self) -> Option<i32> {\n+            self.next()\n+        }\n+    }\n+\n+    assert_eq!(CrazyIterator::new().chain(0..10).rev().last(), Some(0));\n+    assert!((0..10).chain(CrazyIterator::new()).rev().any(|i| i == 0));\n }\n \n #[test]"}]}