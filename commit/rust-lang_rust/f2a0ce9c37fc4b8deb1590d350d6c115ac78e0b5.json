{"sha": "f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYTBjZTljMzdmYzRiOGRlYjE1OTBkMzUwZDZjMTE1YWM3OGUwYjU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-21T23:42:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-21T23:42:28Z"}, "message": "Rollup merge of #60971 - rbtcollins:docs-perf, r=rbtcollins,GuillaumeGomez\n\nAdd DocFS layer to rustdoc\n\n* Move fs::create_dir_all calls into DocFS to provide a clean\n  extension point if async extension there is needed.\n* Convert callsites of create_dir_all to ensure_dir to reduce syscalls.\n* Convert fs::write usage to DocFS.write\n  (which also removes a lot of try_err! usage for easier reading)\n* Convert File::create calls to use Vec buffers and then DocFS.write\n  in order to both consistently reduce syscalls as well as make\n  deferring to threads cleaner.\n* Convert OpenOptions usage similarly - I could find no discussion on\n  the use of create_new for that one output file vs all the other\n  files render creates, if link redirection attacks are a concern\n  DocFS will provide a good central point to introduce systematic\n  create_new usage.\n* DocFS::write defers to rayon for IO on Windows producing a modest\n  speedup: before this patch on my development workstation:\n\n$ time cargo +mystg1 doc -p winapi:0.3.7\n Documenting winapi v0.3.7\n    Finished dev [unoptimized + debuginfo] target(s) in 6m 11s\n\nreal    6m11.734s\nuser    0m0.015s\nsys     0m0.000s\n\nAfterwards:\n$ time cargo +mystg1 doc -p winapi:0.3.7\n   Compiling winapi v0.3.7\n Documenting winapi v0.3.7\n    Finished dev [unoptimized + debuginfo] target(s) in 49.53s\n\nreal    0m49.643s\nuser    0m0.000s\nsys     0m0.015s\n\nI haven't measured how much time is in the compilation logic vs in the\nIO and outputting etc, but this takes it from frustating to tolerable\nfor me, at least for now.", "tree": {"sha": "df40253bd598a0026f3edf31e93997dead723c53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df40253bd598a0026f3edf31e93997dead723c53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdDWtkCRBK7hj4Ov3rIwAAdHIIABnCfpiDiyAF8gOQe2xLJZXY\n2lgZK8qsIOpBGDz3l+GFroqMXbEekctR0zy2RYtXawUiqMyKCzRs8yzekYBYtqOZ\nicWcVq3GUXcVHdK9PrRoeuC2iAKy45cBhYZJ9u9p7NXwVBdPfzgvQENcGrCE6oDL\n9x/U+lahKrSDYKXpFxdKiHWN2jcvekl6qJ0kAFGg9RdnHJZOVTl0jGwx1WHa+4hz\nXsKJv5w7SPv0OkXjDhNUyvPONeorZR1kheA2LCXqxXK4zin4XiCBUF0J+1/8Ok5s\ndQ0QjP0a2wTWx43Uq4GydDaDR15iIrTW4/eWlNLoUMYy37wzRJTopRY2oJJ11Bo=\n=vDKr\n-----END PGP SIGNATURE-----\n", "payload": "tree df40253bd598a0026f3edf31e93997dead723c53\nparent 929b48ec98aaff2239257574b5897f419cec2647\nparent 65f12950b64cbea42e97f1425952c77cf024d5ed\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1561160548 +0200\ncommitter GitHub <noreply@github.com> 1561160548 +0200\n\nRollup merge of #60971 - rbtcollins:docs-perf, r=rbtcollins,GuillaumeGomez\n\nAdd DocFS layer to rustdoc\n\n* Move fs::create_dir_all calls into DocFS to provide a clean\n  extension point if async extension there is needed.\n* Convert callsites of create_dir_all to ensure_dir to reduce syscalls.\n* Convert fs::write usage to DocFS.write\n  (which also removes a lot of try_err! usage for easier reading)\n* Convert File::create calls to use Vec buffers and then DocFS.write\n  in order to both consistently reduce syscalls as well as make\n  deferring to threads cleaner.\n* Convert OpenOptions usage similarly - I could find no discussion on\n  the use of create_new for that one output file vs all the other\n  files render creates, if link redirection attacks are a concern\n  DocFS will provide a good central point to introduce systematic\n  create_new usage.\n* DocFS::write defers to rayon for IO on Windows producing a modest\n  speedup: before this patch on my development workstation:\n\n$ time cargo +mystg1 doc -p winapi:0.3.7\n Documenting winapi v0.3.7\n    Finished dev [unoptimized + debuginfo] target(s) in 6m 11s\n\nreal    6m11.734s\nuser    0m0.015s\nsys     0m0.000s\n\nAfterwards:\n$ time cargo +mystg1 doc -p winapi:0.3.7\n   Compiling winapi v0.3.7\n Documenting winapi v0.3.7\n    Finished dev [unoptimized + debuginfo] target(s) in 49.53s\n\nreal    0m49.643s\nuser    0m0.000s\nsys     0m0.015s\n\nI haven't measured how much time is in the compilation logic vs in the\nIO and outputting etc, but this takes it from frustating to tolerable\nfor me, at least for now.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "html_url": "https://github.com/rust-lang/rust/commit/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "929b48ec98aaff2239257574b5897f419cec2647", "url": "https://api.github.com/repos/rust-lang/rust/commits/929b48ec98aaff2239257574b5897f419cec2647", "html_url": "https://github.com/rust-lang/rust/commit/929b48ec98aaff2239257574b5897f419cec2647"}, {"sha": "65f12950b64cbea42e97f1425952c77cf024d5ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/65f12950b64cbea42e97f1425952c77cf024d5ed", "html_url": "https://github.com/rust-lang/rust/commit/65f12950b64cbea42e97f1425952c77cf024d5ed"}], "stats": {"total": 423, "additions": 286, "deletions": 137}, "files": [{"sha": "40b8cf507e97c5b95ec70ca58237359ead967f37", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "patch": "@@ -3254,6 +3254,7 @@ dependencies = [\n  \"minifier 0.0.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "3158ec3832aed5d20d99462761e2bd93833f0744", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "patch": "@@ -11,5 +11,6 @@ path = \"lib.rs\"\n [dependencies]\n pulldown-cmark = { version = \"0.5.2\", default-features = false }\n minifier = \"0.0.30\"\n+rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n tempfile = \"3\"\n parking_lot = \"0.7\""}, {"sha": "740947fc3e37e8d1f20700d21d8bb6b24dfb1127", "filename": "src/librustdoc/docfs.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "patch": "@@ -0,0 +1,116 @@\n+//! Rustdoc's FileSystem abstraction module.\n+//!\n+//! On Windows this indirects IO into threads to work around performance issues\n+//! with Defender (and other similar virus scanners that do blocking operations).\n+//! On other platforms this is a thin shim to fs.\n+//!\n+//! Only calls needed to permit this workaround have been abstracted: thus\n+//! fs::read is still done directly via the fs module; if in future rustdoc\n+//! needs to read-after-write from a file, then it would be added to this\n+//! abstraction.\n+\n+use errors;\n+\n+use std::fs;\n+use std::io;\n+use std::path::Path;\n+use std::sync::Arc;\n+use std::sync::mpsc::{channel, Receiver, Sender};\n+\n+macro_rules! try_err {\n+    ($e:expr, $file:expr) => {{\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(E::new(e, $file)),\n+        }\n+    }};\n+}\n+\n+pub trait PathError {\n+    fn new<P: AsRef<Path>>(e: io::Error, path: P) -> Self;\n+}\n+\n+pub struct ErrorStorage {\n+    sender: Option<Sender<Option<String>>>,\n+    receiver: Receiver<Option<String>>,\n+}\n+\n+impl ErrorStorage {\n+    pub fn new() -> ErrorStorage {\n+        let (sender, receiver) = channel();\n+        ErrorStorage {\n+            sender: Some(sender),\n+            receiver,\n+        }\n+    }\n+\n+    /// Prints all stored errors. Returns the number of printed errors.\n+    pub fn write_errors(&mut self, diag: &errors::Handler) -> usize {\n+        let mut printed = 0;\n+        // In order to drop the sender part of the channel.\n+        self.sender = None;\n+\n+        for msg in self.receiver.iter() {\n+            if let Some(ref error) = msg {\n+                diag.struct_err(&error).emit();\n+                printed += 1;\n+            }\n+        }\n+        printed\n+    }\n+}\n+\n+pub struct DocFS {\n+    sync_only: bool,\n+    errors: Arc<ErrorStorage>,\n+}\n+\n+impl DocFS {\n+    pub fn new(errors: &Arc<ErrorStorage>) -> DocFS {\n+        DocFS {\n+            sync_only: false,\n+            errors: Arc::clone(errors),\n+        }\n+    }\n+\n+    pub fn set_sync_only(&mut self, sync_only: bool) {\n+        self.sync_only = sync_only;\n+    }\n+\n+    pub fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        // For now, dir creation isn't a huge time consideration, do it\n+        // synchronously, which avoids needing ordering between write() actions\n+        // and directory creation.\n+        fs::create_dir_all(path)\n+    }\n+\n+    pub fn write<P, C, E>(&self, path: P, contents: C) -> Result<(), E>\n+    where\n+        P: AsRef<Path>,\n+        C: AsRef<[u8]>,\n+        E: PathError,\n+    {\n+        if !self.sync_only && cfg!(windows) {\n+            // A possible future enhancement after more detailed profiling would\n+            // be to create the file sync so errors are reported eagerly.\n+            let contents = contents.as_ref().to_vec();\n+            let path = path.as_ref().to_path_buf();\n+            let sender = self.errors.sender.clone().unwrap();\n+            rayon::spawn(move || {\n+                match fs::write(&path, &contents) {\n+                    Ok(_) => {\n+                        sender.send(None)\n+                            .expect(&format!(\"failed to send error on \\\"{}\\\"\", path.display()));\n+                    }\n+                    Err(e) => {\n+                        sender.send(Some(format!(\"\\\"{}\\\": {}\", path.display(), e)))\n+                            .expect(&format!(\"failed to send non-error on \\\"{}\\\"\", path.display()));\n+                    }\n+                }\n+            });\n+            Ok(())\n+        } else {\n+            Ok(try_err!(fs::write(&path, contents), path))\n+        }\n+    }\n+}"}, {"sha": "f0aff961c675170874e8a1429effc63505c789f0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 167, "deletions": 137, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "patch": "@@ -35,9 +35,9 @@ use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter, Write as FmtWrite};\n use std::ffi::OsStr;\n-use std::fs::{self, File, OpenOptions};\n+use std::fs::{self, File};\n use std::io::prelude::*;\n-use std::io::{self, BufWriter, BufReader};\n+use std::io::{self, BufReader};\n use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n@@ -61,6 +61,7 @@ use rustc_data_structures::flock;\n \n use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, Mutability};\n use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n@@ -89,6 +90,58 @@ impl<'a> Display for SlashChecker<'a> {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct Error {\n+    pub file: PathBuf,\n+    pub error: io::Error,\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &str {\n+        self.error.description()\n+    }\n+}\n+\n+impl Display for Error {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        let file = self.file.display().to_string();\n+        if file.is_empty() {\n+            write!(f, \"{}\", self.error)\n+        } else {\n+            write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n+        }\n+    }\n+}\n+\n+impl PathError for Error {\n+    fn new<P: AsRef<Path>>(e: io::Error, path: P) -> Error {\n+        Error {\n+            file: path.as_ref().to_path_buf(),\n+            error: e,\n+        }\n+    }\n+}\n+\n+macro_rules! try_none {\n+    ($e:expr, $file:expr) => ({\n+        use std::io;\n+        match $e {\n+            Some(e) => e,\n+            None => return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"),\n+                                          $file))\n+        }\n+    })\n+}\n+\n+macro_rules! try_err {\n+    ($e:expr, $file:expr) => ({\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(Error::new(e, $file)),\n+        }\n+    })\n+}\n+\n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n /// how the current page is being rendered.\n@@ -156,13 +209,15 @@ struct SharedContext {\n     pub generate_search_filter: bool,\n     /// Option disabled by default to generate files used by RLS and some other tools.\n     pub generate_redirect_pages: bool,\n+    /// The fs handle we are working with.\n+    pub fs: DocFS,\n }\n \n impl SharedContext {\n-    fn ensure_dir(&self, dst: &Path) -> io::Result<()> {\n+    fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n-            fs::create_dir_all(dst)?;\n+            try_err!(self.fs.create_dir_all(dst), dst);\n             dirs.insert(dst.to_path_buf());\n         }\n \n@@ -216,53 +271,6 @@ impl Impl {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct Error {\n-    pub file: PathBuf,\n-    pub error: io::Error,\n-}\n-\n-impl error::Error for Error {\n-    fn description(&self) -> &str {\n-        self.error.description()\n-    }\n-}\n-\n-impl Display for Error {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n-    }\n-}\n-\n-impl Error {\n-    pub fn new(e: io::Error, file: &Path) -> Error {\n-        Error {\n-            file: file.to_path_buf(),\n-            error: e,\n-        }\n-    }\n-}\n-\n-macro_rules! try_none {\n-    ($e:expr, $file:expr) => ({\n-        use std::io;\n-        match $e {\n-            Some(e) => e,\n-            None => return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"),\n-                                          $file))\n-        }\n-    })\n-}\n-\n-macro_rules! try_err {\n-    ($e:expr, $file:expr) => ({\n-        match $e {\n-            Ok(e) => e,\n-            Err(e) => return Err(Error::new(e, $file)),\n-        }\n-    })\n-}\n-\n /// This cache is used to store information about the `clean::Crate` being\n /// rendered in order to provide more useful documentation. This contains\n /// information like all implementors of a trait, all traits a type implements,\n@@ -544,6 +552,7 @@ pub fn run(mut krate: clean::Crate,\n         },\n         _ => PathBuf::new(),\n     };\n+    let mut errors = Arc::new(ErrorStorage::new());\n     let mut scx = SharedContext {\n         src_root,\n         passes,\n@@ -564,6 +573,7 @@ pub fn run(mut krate: clean::Crate,\n         static_root_path,\n         generate_search_filter,\n         generate_redirect_pages,\n+        fs: DocFS::new(&errors),\n     };\n \n     // If user passed in `--playground-url` arg, we fill in crate name here\n@@ -601,9 +611,9 @@ pub fn run(mut krate: clean::Crate,\n         }\n     }\n     let dst = output;\n-    try_err!(fs::create_dir_all(&dst), &dst);\n+    scx.ensure_dir(&dst)?;\n     krate = render_sources(&dst, &mut scx, krate)?;\n-    let cx = Context {\n+    let mut cx = Context {\n         current: Vec::new(),\n         dst,\n         render_redirect_pages: false,\n@@ -705,10 +715,21 @@ pub fn run(mut krate: clean::Crate,\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n+    // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n     write_shared(&cx, &krate, &*cache, index, &md_opts, diag)?;\n+    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n \n     // And finally render the whole crate's documentation\n-    cx.krate(krate)\n+    let ret = cx.krate(krate);\n+    let nb_errors = Arc::get_mut(&mut errors).map_or_else(|| 0, |errors| errors.write_errors(diag));\n+    if ret.is_err() {\n+        ret\n+    } else if nb_errors > 0 {\n+        Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+    } else {\n+        Ok(())\n+    }\n }\n \n /// Builds the search index from the collected metadata\n@@ -797,13 +818,13 @@ fn write_shared(\n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n \n-    write_minify(cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"rustdoc{}.css\", cx.shared.resource_suffix)),\n                  static_files::RUSTDOC_CSS,\n                  options.enable_minification)?;\n-    write_minify(cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.css\", cx.shared.resource_suffix)),\n                  static_files::SETTINGS_CSS,\n                  options.enable_minification)?;\n-    write_minify(cx.dst.join(&format!(\"noscript{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"noscript{}.css\", cx.shared.resource_suffix)),\n                  static_files::NOSCRIPT_CSS,\n                  options.enable_minification)?;\n \n@@ -815,11 +836,13 @@ fn write_shared(\n         let content = try_err!(fs::read(&entry), &entry);\n         let theme = try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry);\n         let extension = try_none!(try_none!(entry.extension(), &entry).to_str(), &entry);\n-        write(cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n-              content.as_slice())?;\n+        cx.shared.fs.write(\n+            cx.dst.join(format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension)),\n+            content.as_slice())?;\n         themes.insert(theme.to_owned());\n     }\n \n+    let write = |p, c| { cx.shared.fs.write(p, c) };\n     if (*cx.shared).layout.logo.is_empty() {\n         write(cx.dst.join(&format!(\"rust-logo{}.png\", cx.shared.resource_suffix)),\n               static_files::RUST_LOGO)?;\n@@ -834,11 +857,11 @@ fn write_shared(\n           static_files::WHEEL_SVG)?;\n     write(cx.dst.join(&format!(\"down-arrow{}.svg\", cx.shared.resource_suffix)),\n           static_files::DOWN_ARROW_SVG)?;\n-    write_minify(cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"light{}.css\", cx.shared.resource_suffix)),\n                  static_files::themes::LIGHT,\n                  options.enable_minification)?;\n     themes.insert(\"light\".to_owned());\n-    write_minify(cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"dark{}.css\", cx.shared.resource_suffix)),\n                  static_files::themes::DARK,\n                  options.enable_minification)?;\n     themes.insert(\"dark\".to_owned());\n@@ -847,8 +870,7 @@ fn write_shared(\n     themes.sort();\n     // To avoid theme switch latencies as much as possible, we put everything theme related\n     // at the beginning of the html files into another js file.\n-    write(cx.dst.join(&format!(\"theme{}.js\", cx.shared.resource_suffix)),\n-          format!(\n+    let theme_js = format!(\n r#\"var themes = document.getElementById(\"theme-choices\");\n var themePicker = document.getElementById(\"theme-picker\");\n \n@@ -891,39 +913,45 @@ themePicker.onblur = handleThemeButtonsBlur;\n                  themes.iter()\n                        .map(|s| format!(\"\\\"{}\\\"\", s))\n                        .collect::<Vec<String>>()\n-                       .join(\",\")).as_bytes(),\n+                       .join(\",\"));\n+    write(cx.dst.join(&format!(\"theme{}.js\", cx.shared.resource_suffix)),\n+          theme_js.as_bytes()\n     )?;\n \n-    write_minify(cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"main{}.js\", cx.shared.resource_suffix)),\n                  static_files::MAIN_JS,\n                  options.enable_minification)?;\n-    write_minify(cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"settings{}.js\", cx.shared.resource_suffix)),\n                  static_files::SETTINGS_JS,\n                  options.enable_minification)?;\n     if cx.shared.include_sources {\n-        write_minify(cx.dst.join(&format!(\"source-script{}.js\", cx.shared.resource_suffix)),\n-                     static_files::sidebar::SOURCE_SCRIPT,\n-                     options.enable_minification)?;\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.dst.join(&format!(\"source-script{}.js\", cx.shared.resource_suffix)),\n+            static_files::sidebar::SOURCE_SCRIPT,\n+            options.enable_minification)?;\n     }\n \n     {\n-        write_minify(cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n-                     &format!(\"var resourcesSuffix = \\\"{}\\\";{}\",\n-                              cx.shared.resource_suffix,\n-                              static_files::STORAGE_JS),\n-                     options.enable_minification)?;\n+        write_minify(\n+            &cx.shared.fs,\n+            cx.dst.join(&format!(\"storage{}.js\", cx.shared.resource_suffix)),\n+            &format!(\"var resourcesSuffix = \\\"{}\\\";{}\",\n+                     cx.shared.resource_suffix,\n+                     static_files::STORAGE_JS),\n+            options.enable_minification)?;\n     }\n \n     if let Some(ref css) = cx.shared.css_file_extension {\n         let out = cx.dst.join(&format!(\"theme{}.css\", cx.shared.resource_suffix));\n+        let buffer = try_err!(fs::read_to_string(css), css);\n         if !options.enable_minification {\n-            try_err!(fs::copy(css, out), css);\n+            cx.shared.fs.write(&out, &buffer)?;\n         } else {\n-            let buffer = try_err!(fs::read_to_string(css), css);\n-            write_minify(out, &buffer, options.enable_minification)?;\n+            write_minify(&cx.shared.fs, out, &buffer, options.enable_minification)?;\n         }\n     }\n-    write_minify(cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n+    write_minify(&cx.shared.fs, cx.dst.join(&format!(\"normalize{}.css\", cx.shared.resource_suffix)),\n                  static_files::NORMALIZE_CSS,\n                  options.enable_minification)?;\n     write(cx.dst.join(\"FiraSans-Regular.woff\"),\n@@ -999,7 +1027,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n     let dst = cx.dst.join(&format!(\"aliases{}.js\", cx.shared.resource_suffix));\n     {\n         let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n-        let mut w = try_err!(File::create(&dst), &dst);\n         let mut output = String::with_capacity(100);\n         for (alias, items) in &cache.aliases {\n             if items.is_empty() {\n@@ -1014,10 +1041,12 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n         all_aliases.push(format!(\"ALIASES[\\\"{}\\\"] = {{{}}};\", krate.name, output));\n         all_aliases.sort();\n-        try_err!(writeln!(&mut w, \"var ALIASES = {{}};\"), &dst);\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v, \"var ALIASES = {{}};\"), &dst);\n         for aliases in &all_aliases {\n-            try_err!(writeln!(&mut w, \"{}\", aliases), &dst);\n+            try_err!(writeln!(&mut v, \"{}\", aliases), &dst);\n         }\n+        cx.shared.fs.write(&dst, &v)?;\n     }\n \n     use std::ffi::OsString;\n@@ -1101,11 +1130,12 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                  &krate.name,\n                                  hierarchy.to_json_string()));\n         all_sources.sort();\n-        let mut w = try_err!(File::create(&dst), &dst);\n-        try_err!(writeln!(&mut w,\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v,\n                           \"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\",\n                           all_sources.join(\"\\n\")),\n                  &dst);\n+        cx.shared.fs.write(&dst, &v)?;\n     }\n \n     // Update the search index\n@@ -1119,14 +1149,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n     // Sort the indexes by crate so the file will be generated identically even\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n-    let mut w = try_err!(File::create(&dst), &dst);\n-    try_err!(writeln!(&mut w, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n-    try_err!(write_minify_replacer(&mut w,\n-                                   &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n-                                   options.enable_minification),\n-             &dst);\n-    try_err!(write!(&mut w, \"initSearch(searchIndex);addSearchOptions(searchIndex);\"), &dst);\n-\n+    {\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n+        try_err!(write_minify_replacer(\n+            &mut v,\n+            &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n+            options.enable_minification),\n+            &dst);\n+        try_err!(write!(&mut v, \"initSearch(searchIndex);addSearchOptions(searchIndex);\"), &dst);\n+        cx.shared.fs.write(&dst, &v)?;\n+    }\n     if options.enable_index_page {\n         if let Some(index_page) = options.index_page.clone() {\n             let mut md_opts = options.clone();\n@@ -1136,7 +1169,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n             crate::markdown::render(index_page, md_opts, diag, cx.edition);\n         } else {\n             let dst = cx.dst.join(\"index.html\");\n-            let mut w = BufWriter::new(try_err!(File::create(&dst), &dst));\n             let page = layout::Page {\n                 title: \"Index of crates\",\n                 css_class: \"mod\",\n@@ -1163,12 +1195,13 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                                 SlashChecker(s), s)\n                                     })\n                                     .collect::<String>());\n-            try_err!(layout::render(&mut w, &cx.shared.layout,\n+            let mut v = Vec::new();\n+            try_err!(layout::render(&mut v, &cx.shared.layout,\n                                     &page, &(\"\"), &content,\n                                     cx.shared.css_file_extension.is_some(),\n                                     &cx.shared.themes,\n                                     cx.shared.generate_search_filter), &dst);\n-            try_err!(w.flush(), &dst);\n+            cx.shared.fs.write(&dst, &v)?;\n         }\n     }\n \n@@ -1220,7 +1253,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part);\n         }\n-        try_err!(fs::create_dir_all(&mydst), &mydst);\n+        cx.shared.ensure_dir(&mydst)?;\n         mydst.push(&format!(\"{}.{}.js\",\n                             remote_item_type.css_class(),\n                             remote_path[remote_path.len() - 1]));\n@@ -1233,19 +1266,20 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // identically even with rustdoc running in parallel.\n         all_implementors.sort();\n \n-        let mut f = try_err!(File::create(&mydst), &mydst);\n-        try_err!(writeln!(&mut f, \"(function() {{var implementors = {{}};\"), &mydst);\n+        let mut v = Vec::new();\n+        try_err!(writeln!(&mut v, \"(function() {{var implementors = {{}};\"), &mydst);\n         for implementor in &all_implementors {\n-            try_err!(writeln!(&mut f, \"{}\", *implementor), &mydst);\n+            try_err!(writeln!(&mut v, \"{}\", *implementor), &mydst);\n         }\n-        try_err!(writeln!(&mut f, \"{}\", r\"\n+        try_err!(writeln!(&mut v, \"{}\", r\"\n             if (window.register_implementors) {\n                 window.register_implementors(implementors);\n             } else {\n                 window.pending_implementors = implementors;\n             }\n         \"), &mydst);\n-        try_err!(writeln!(&mut f, r\"}})()\"), &mydst);\n+        try_err!(writeln!(&mut v, r\"}})()\"), &mydst);\n+        cx.shared.fs.write(&mydst, &v)?;\n     }\n     Ok(())\n }\n@@ -1254,30 +1288,25 @@ fn render_sources(dst: &Path, scx: &mut SharedContext,\n                   krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n     let dst = dst.join(\"src\").join(&krate.name);\n-    try_err!(fs::create_dir_all(&dst), &dst);\n+    scx.ensure_dir(&dst)?;\n     let mut folder = SourceCollector {\n         dst,\n         scx,\n     };\n     Ok(folder.fold_crate(krate))\n }\n \n-/// Writes the entire contents of a string to a destination, not attempting to\n-/// catch any errors.\n-fn write(dst: PathBuf, contents: &[u8]) -> Result<(), Error> {\n-    Ok(try_err!(fs::write(&dst, contents), &dst))\n-}\n-\n-fn write_minify(dst: PathBuf, contents: &str, enable_minification: bool) -> Result<(), Error> {\n+fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bool\n+                ) -> Result<(), Error> {\n     if enable_minification {\n         if dst.extension() == Some(&OsStr::new(\"css\")) {\n             let res = try_none!(minifier::css::minify(contents).ok(), &dst);\n-            write(dst, res.as_bytes())\n+            fs.write(dst, res.as_bytes())\n         } else {\n-            write(dst, minifier::js::minify(contents).as_bytes())\n+            fs.write(dst, minifier::js::minify(contents).as_bytes())\n         }\n     } else {\n-        write(dst, contents.as_bytes())\n+        fs.write(dst, contents.as_bytes())\n     }\n }\n \n@@ -1439,7 +1468,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n \n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &FileName) -> io::Result<()> {\n+    fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n         let p = match *filename {\n             FileName::Real(ref file) => file,\n             _ => return Ok(()),\n@@ -1449,7 +1478,7 @@ impl<'a> SourceCollector<'a> {\n             return Ok(());\n         }\n \n-        let contents = fs::read_to_string(&p)?;\n+        let contents = try_err!(fs::read_to_string(&p), &p);\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\u{feff}\") {\n@@ -1468,15 +1497,15 @@ impl<'a> SourceCollector<'a> {\n             href.push_str(&component.to_string_lossy());\n             href.push('/');\n         });\n-        fs::create_dir_all(&cur)?;\n+        self.scx.ensure_dir(&cur)?;\n         let mut fname = p.file_name()\n                          .expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n         cur.push(&fname);\n         href.push_str(&fname.to_string_lossy());\n \n-        let mut w = BufWriter::new(File::create(&cur)?);\n+        let mut v = Vec::new();\n         let title = format!(\"{} -- source\", cur.file_name().expect(\"failed to get file name\")\n                                                .to_string_lossy());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n@@ -1491,12 +1520,12 @@ impl<'a> SourceCollector<'a> {\n             extra_scripts: &[&format!(\"source-files{}\", self.scx.resource_suffix)],\n             static_extra_scripts: &[&format!(\"source-script{}\", self.scx.resource_suffix)],\n         };\n-        layout::render(&mut w, &self.scx.layout,\n+        try_err!(layout::render(&mut v, &self.scx.layout,\n                        &page, &(\"\"), &Source(contents),\n                        self.scx.css_file_extension.is_some(),\n                        &self.scx.themes,\n-                       self.scx.generate_search_filter)?;\n-        w.flush()?;\n+                       self.scx.generate_search_filter), &cur);\n+        self.scx.fs.write(&cur, &v)?;\n         self.scx.local_sources.insert(p.clone(), href);\n         Ok(())\n     }\n@@ -2073,7 +2102,6 @@ impl Context {\n             }\n         }\n \n-        let mut w = BufWriter::new(try_err!(File::create(&final_file), &final_file));\n         let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n         if !root_path.ends_with('/') {\n             root_path.push('/');\n@@ -2099,12 +2127,14 @@ impl Context {\n         } else {\n             String::new()\n         };\n-        try_err!(layout::render(&mut w, &self.shared.layout,\n+        let mut v = Vec::new();\n+        try_err!(layout::render(&mut v, &self.shared.layout,\n                                 &page, &sidebar, &all,\n                                 self.shared.css_file_extension.is_some(),\n                                 &self.shared.themes,\n                                 self.shared.generate_search_filter),\n                  &final_file);\n+        self.shared.fs.write(&final_file, &v)?;\n \n         // Generating settings page.\n         let settings = Settings::new(self.shared.static_root_path.deref().unwrap_or(\"./\"),\n@@ -2113,17 +2143,18 @@ impl Context {\n         page.description = \"Settings of Rustdoc\";\n         page.root_path = \"./\";\n \n-        let mut w = BufWriter::new(try_err!(File::create(&settings_file), &settings_file));\n         let mut themes = self.shared.themes.clone();\n         let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n         themes.push(PathBuf::from(\"settings.css\"));\n         let layout = self.shared.layout.clone();\n-        try_err!(layout::render(&mut w, &layout,\n+        let mut v = Vec::new();\n+        try_err!(layout::render(&mut v, &layout,\n                                 &page, &sidebar, &settings,\n                                 self.shared.css_file_extension.is_some(),\n                                 &themes,\n                                 self.shared.generate_search_filter),\n                  &settings_file);\n+        self.shared.fs.write(&settings_file, &v)?;\n \n         Ok(())\n     }\n@@ -2223,16 +2254,17 @@ impl Context {\n             // recurse into the items of the module as well.\n             let name = item.name.as_ref().unwrap().to_string();\n             let mut item = Some(item);\n+            let scx = self.shared.clone();\n             self.recurse(name, |this| {\n                 let item = item.take().unwrap();\n \n                 let mut buf = Vec::new();\n                 this.render_item(&mut buf, &item, false).unwrap();\n                 // buf will be empty if the module is stripped and there is no redirect for it\n                 if !buf.is_empty() {\n-                    try_err!(this.shared.ensure_dir(&this.dst), &this.dst);\n+                    this.shared.ensure_dir(&this.dst)?;\n                     let joint_dst = this.dst.join(\"index.html\");\n-                    try_err!(fs::write(&joint_dst, buf), &joint_dst);\n+                    scx.fs.write(&joint_dst, buf)?;\n                 }\n \n                 let m = match item.inner {\n@@ -2245,9 +2277,10 @@ impl Context {\n                 if !this.render_redirect_pages {\n                     let items = this.build_sidebar_items(&m);\n                     let js_dst = this.dst.join(\"sidebar-items.js\");\n-                    let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n-                    try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n+                    let mut v = Vec::new();\n+                    try_err!(write!(&mut v, \"initSidebarItems({});\",\n                                     as_json(&items)), &js_dst);\n+                    scx.fs.write(&js_dst, &v)?;\n                 }\n \n                 for item in m.items {\n@@ -2264,9 +2297,9 @@ impl Context {\n                 let name = item.name.as_ref().unwrap();\n                 let item_type = item.type_();\n                 let file_name = &item_path(item_type, name);\n-                try_err!(self.shared.ensure_dir(&self.dst), &self.dst);\n+                self.shared.ensure_dir(&self.dst)?;\n                 let joint_dst = self.dst.join(file_name);\n-                try_err!(fs::write(&joint_dst, buf), &joint_dst);\n+                self.shared.fs.write(&joint_dst, buf)?;\n \n                 if !self.render_redirect_pages {\n                     all.append(full_path(self, &item), &item_type);\n@@ -2276,21 +2309,18 @@ impl Context {\n                     // URL for the page.\n                     let redir_name = format!(\"{}.{}.html\", name, item_type.name_space());\n                     let redir_dst = self.dst.join(redir_name);\n-                    if let Ok(redirect_out) = OpenOptions::new().create_new(true)\n-                                                                .write(true)\n-                                                                .open(&redir_dst) {\n-                        let mut redirect_out = BufWriter::new(redirect_out);\n-                        try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n-                    }\n+                    let mut v = Vec::new();\n+                    try_err!(layout::redirect(&mut v, file_name), &redir_dst);\n+                    self.shared.fs.write(&redir_dst, &v)?;\n                 }\n                 // If the item is a macro, redirect from the old macro URL (with !)\n                 // to the new one (without).\n                 if item_type == ItemType::Macro {\n                     let redir_name = format!(\"{}.{}!.html\", item_type, name);\n                     let redir_dst = self.dst.join(redir_name);\n-                    let redirect_out = try_err!(File::create(&redir_dst), &redir_dst);\n-                    let mut redirect_out = BufWriter::new(redirect_out);\n-                    try_err!(layout::redirect(&mut redirect_out, file_name), &redir_dst);\n+                    let mut v = Vec::new();\n+                    try_err!(layout::redirect(&mut v, file_name), &redir_dst);\n+                    self.shared.fs.write(&redir_dst, &v)?;\n                 }\n             }\n         }"}, {"sha": "7a8b088020c5320c32a8e41accbdb026dae955cd", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f2a0ce9c37fc4b8deb1590d350d6c115ac78e0b5", "patch": "@@ -59,6 +59,7 @@ mod externalfiles;\n mod clean;\n mod config;\n mod core;\n+mod docfs;\n mod doctree;\n mod fold;\n pub mod html {"}]}