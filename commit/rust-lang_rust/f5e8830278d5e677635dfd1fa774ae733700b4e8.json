{"sha": "f5e8830278d5e677635dfd1fa774ae733700b4e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZTg4MzAyNzhkNWU2Nzc2MzVkZmQxZmE3NzRhZTczMzcwMGI0ZTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-19T15:11:23Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-28T10:21:41Z"}, "message": "validity in non-const mode relies on ref_to_mplace checking bounds; (de)reference hooks work on places", "tree": {"sha": "b1cdac699325246020c53a6fe3ad8417d3de7080", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1cdac699325246020c53a6fe3ad8417d3de7080"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5e8830278d5e677635dfd1fa774ae733700b4e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e8830278d5e677635dfd1fa774ae733700b4e8", "html_url": "https://github.com/rust-lang/rust/commit/f5e8830278d5e677635dfd1fa774ae733700b4e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5e8830278d5e677635dfd1fa774ae733700b4e8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "048900c5b6bd8d5f6499b60703b3b5773b614608", "url": "https://api.github.com/repos/rust-lang/rust/commits/048900c5b6bd8d5f6499b60703b3b5773b614608", "html_url": "https://github.com/rust-lang/rust/commit/048900c5b6bd8d5f6499b60703b3b5773b614608"}], "stats": {"total": 240, "additions": 119, "deletions": 121}, "files": [{"sha": "3a4f4b36dd5893e96513a4d8d1962155e743facd", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=f5e8830278d5e677635dfd1fa774ae733700b4e8", "patch": "@@ -20,8 +20,8 @@ use rustc::hir::{self, def_id::DefId};\n use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n-use rustc::ty::{self, Ty, TyCtxt, Instance, query::TyCtxtAt};\n-use rustc::ty::layout::{self, Size, LayoutOf, TyLayout};\n+use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n+use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -32,7 +32,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Value, Pointer, Scalar, ConstValue,\n+    PlaceTy, MemPlace, OpTy, Operand, Value, Scalar, ConstValue,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -465,28 +465,6 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n             &ecx.stack[..],\n         )\n     }\n-\n-    #[inline(always)]\n-    fn tag_reference(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _pointee_ty: Ty<'tcx>,\n-        _pointee_size: Size,\n-        _borrow_kind: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Self::PointerTag> {\n-        Ok(())\n-    }\n-\n-    #[inline(always)]\n-    fn tag_dereference(\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _pointee_ty: Ty<'tcx>,\n-        _pointee_size: Size,\n-        _borrow_kind: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Self::PointerTag> {\n-        Ok(())\n-    }\n }\n \n /// Project to a field of a (variant of a) const"}, {"sha": "3d45728f4ec3e5ecd46c00273e2b0643c88f4244", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=f5e8830278d5e677635dfd1fa774ae733700b4e8", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{self, Ty, layout::{Size, TyLayout}, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar,\n-    EvalContext, PlaceTy, OpTy, Pointer, MemoryKind,\n+    EvalContext, PlaceTy, OpTy, Pointer, MemPlace, MemoryKind,\n };\n \n /// Classifying memory accesses\n@@ -205,26 +205,32 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     }\n \n     /// Executed when evaluating the `&` operator: Creating a new reference.\n-    /// This has the chance to adjust the tag.\n+    /// This has the chance to adjust the tag.  It should not change anything else!\n     /// `mutability` can be `None` in case a raw ptr is being created.\n+    #[inline]\n     fn tag_reference(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-        pointee_ty: Ty<'tcx>,\n-        pointee_size: Size,\n-        mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Self::PointerTag>;\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        place: MemPlace<Self::PointerTag>,\n+        _ty: Ty<'tcx>,\n+        _size: Size,\n+        _mutability: Option<hir::Mutability>,\n+    ) -> EvalResult<'tcx, MemPlace<Self::PointerTag>> {\n+        Ok(place)\n+    }\n \n     /// Executed when evaluating the `*` operator: Following a reference.\n-    /// This has the change to adjust the tag.\n+    /// This has the change to adjust the tag.  It should not change anything else!\n     /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n+    #[inline]\n     fn tag_dereference(\n-        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n-        pointee_ty: Ty<'tcx>,\n-        pointee_size: Size,\n-        mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Self::PointerTag>;\n+        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        place: MemPlace<Self::PointerTag>,\n+        _ty: Ty<'tcx>,\n+        _size: Size,\n+        _mutability: Option<hir::Mutability>,\n+    ) -> EvalResult<'tcx, MemPlace<Self::PointerTag>> {\n+        Ok(place)\n+    }\n \n     /// Execute a validation operation\n     #[inline]"}, {"sha": "bbdda8ed68d83459d0d0483e2f00594157542fc5", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f5e8830278d5e677635dfd1fa774ae733700b4e8", "patch": "@@ -276,26 +276,25 @@ where\n \n         let align = layout.align;\n         let meta = val.to_meta()?;\n-\n-        let ptr = match val.to_scalar_ptr()? {\n-            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n-                // Machine might want to track the `*` operator\n-                let (size, _) = self.size_and_align_of(meta, layout)?\n-                    .expect(\"ref_to_mplace cannot determine size\");\n-                let mutbl = match val.layout.ty.sty {\n-                    // `builtin_deref` considers boxes immutable, that's useless for our purposes\n-                    ty::Ref(_, _, mutbl) => Some(mutbl),\n-                    ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n-                    ty::RawPtr(_) => None,\n-                    _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n-                };\n-                let tag = M::tag_dereference(self, ptr, pointee_type, size, mutbl)?;\n-                Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n-            }\n-            other => other,\n+        let ptr = val.to_scalar_ptr()?;\n+        let mplace = MemPlace { ptr, align, meta };\n+        // Pointer tag tracking might want to adjust the tag.\n+        let mplace = if M::ENABLE_PTR_TRACKING_HOOKS {\n+            let (size, _) = self.size_and_align_of(meta, layout)?\n+                // for extern types, just cover what we can\n+                .unwrap_or_else(|| layout.size_and_align());\n+            let mutbl = match val.layout.ty.sty {\n+                // `builtin_deref` considers boxes immutable, that's useless for our purposes\n+                ty::Ref(_, _, mutbl) => Some(mutbl),\n+                ty::Adt(def, _) if def.is_box() => Some(hir::MutMutable),\n+                ty::RawPtr(_) => None,\n+                _ => bug!(\"Unexpected pointer type {}\", val.layout.ty.sty),\n+            };\n+            M::tag_dereference(self, mplace, pointee_type, size, mutbl)?\n+        } else {\n+            mplace\n         };\n-\n-        Ok(MPlaceTy { mplace: MemPlace { ptr, align, meta }, layout })\n+        Ok(MPlaceTy { mplace, layout })\n     }\n \n     /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n@@ -305,24 +304,25 @@ where\n         place: MPlaceTy<'tcx, M::PointerTag>,\n         borrow_kind: Option<mir::BorrowKind>,\n     ) -> EvalResult<'tcx, Value<M::PointerTag>> {\n-        let ptr = match place.ptr {\n-            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n-                // Machine might want to track the `&` operator\n-                let (size, _) = self.size_and_align_of_mplace(place)?\n-                    .expect(\"create_ref cannot determine size\");\n-                let mutbl = match borrow_kind {\n-                    Some(mir::BorrowKind::Mut { .. }) => Some(hir::MutMutable),\n-                    Some(_) => Some(hir::MutImmutable),\n-                    None => None,\n-                };\n-                let tag = M::tag_reference(self, ptr, place.layout.ty, size, mutbl)?;\n-                Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n-            },\n-            other => other,\n+        // Pointer tag tracking might want to adjust the tag\n+        let place = if M::ENABLE_PTR_TRACKING_HOOKS {\n+            let (size, _) = self.size_and_align_of_mplace(place)?\n+                // for extern types, just cover what we can\n+                .unwrap_or_else(|| place.layout.size_and_align());\n+            let mutbl = match borrow_kind {\n+                Some(mir::BorrowKind::Mut { .. }) |\n+                Some(mir::BorrowKind::Unique) =>\n+                    Some(hir::MutMutable),\n+                Some(_) => Some(hir::MutImmutable),\n+                None => None,\n+            };\n+            M::tag_reference(self, *place, place.layout.ty, size, mutbl)?\n+        } else {\n+            *place\n         };\n         Ok(match place.meta {\n-            None => Value::Scalar(ptr.into()),\n-            Some(meta) => Value::ScalarPair(ptr.into(), meta.into()),\n+            None => Value::Scalar(place.ptr.into()),\n+            Some(meta) => Value::ScalarPair(place.ptr.into(), meta.into()),\n         })\n     }\n "}, {"sha": "226717538a29484e9e793af4bb882751d43549cc", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e8830278d5e677635dfd1fa774ae733700b4e8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=f5e8830278d5e677635dfd1fa774ae733700b4e8", "patch": "@@ -12,7 +12,7 @@ use std::fmt::Write;\n use std::hash::Hash;\n \n use syntax_pos::symbol::Symbol;\n-use rustc::ty::layout::{self, Size, Align, TyLayout};\n+use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n@@ -176,19 +176,27 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // undef. We should fix that, but let's start low.\n                 }\n             }\n-            _ if ty.is_box() || ty.is_region_ptr() || ty.is_unsafe_ptr() => {\n-                // Handle fat pointers. We also check fat raw pointers,\n-                // their metadata must be valid!\n-                // This also checks that the ptr itself is initialized, which\n-                // seems reasonable even for raw pointers.\n-                let place = try_validation!(self.ref_to_mplace(value),\n-                    \"undefined data in pointer\", path);\n+            ty::RawPtr(..) => {\n+                // No undef allowed here.  Eventually this should be consistent with\n+                // the integer types.\n+                let _ptr = try_validation!(value.to_scalar_ptr(),\n+                    \"undefined address in pointer\", path);\n+                let _meta = try_validation!(value.to_meta(),\n+                    \"uninitialized data in fat pointer metadata\", path);\n+            }\n+            _ if ty.is_box() || ty.is_region_ptr() => {\n+                // Handle fat pointers.\n                 // Check metadata early, for better diagnostics\n-                if place.layout.is_unsized() {\n-                    let tail = self.tcx.struct_tail(place.layout.ty);\n+                let ptr = try_validation!(value.to_scalar_ptr(),\n+                    \"undefined address in pointer\", path);\n+                let meta = try_validation!(value.to_meta(),\n+                    \"uninitialized data in fat pointer metadata\", path);\n+                let layout = self.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n+                if layout.is_unsized() {\n+                    let tail = self.tcx.struct_tail(layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n-                            let vtable = try_validation!(place.meta.unwrap().to_ptr(),\n+                            let vtable = try_validation!(meta.unwrap().to_ptr(),\n                                 \"non-pointer vtable in fat pointer\", path);\n                             try_validation!(self.read_drop_type_from_vtable(vtable),\n                                 \"invalid drop fn in vtable\", path);\n@@ -197,7 +205,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n-                            try_validation!(place.meta.unwrap().to_usize(self),\n+                            try_validation!(meta.unwrap().to_usize(self),\n                                 \"non-integer slice length in fat pointer\", path);\n                         }\n                         ty::Foreign(..) => {\n@@ -207,59 +215,65 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             bug!(\"Unexpected unsized type tail: {:?}\", tail),\n                     }\n                 }\n-                // for safe ptrs, also check the ptr values itself\n-                if !ty.is_unsafe_ptr() {\n-                    // Make sure this is non-NULL and aligned\n-                    let (size, align) = self.size_and_align_of(place.meta, place.layout)?\n-                        // for the purpose of validity, consider foreign types to have\n-                        // alignment and size determined by the layout (size will be 0,\n-                        // alignment should take attributes into account).\n-                        .unwrap_or_else(|| place.layout.size_and_align());\n-                    match self.memory.check_align(place.ptr, align) {\n-                        Ok(_) => {},\n-                        Err(err) => match err.kind {\n+                // Make sure this is non-NULL and aligned\n+                let (size, align) = self.size_and_align_of(meta, layout)?\n+                    // for the purpose of validity, consider foreign types to have\n+                    // alignment and size determined by the layout (size will be 0,\n+                    // alignment should take attributes into account).\n+                    .unwrap_or_else(|| layout.size_and_align());\n+                match self.memory.check_align(ptr, align) {\n+                    Ok(_) => {},\n+                    Err(err) => {\n+                        error!(\"{:?} is not aligned to {:?}\", ptr, align);\n+                        match err.kind {\n                             EvalErrorKind::InvalidNullPointerUsage =>\n                                 return validation_failure!(\"NULL reference\", path),\n                             EvalErrorKind::AlignmentCheckFailed { .. } =>\n                                 return validation_failure!(\"unaligned reference\", path),\n                             _ =>\n                                 return validation_failure!(\n                                     \"dangling (out-of-bounds) reference (might be NULL at \\\n-                                     run-time)\",\n+                                        run-time)\",\n                                     path\n                                 ),\n                         }\n                     }\n-                    // non-ZST also have to be dereferenceable\n+                }\n+                // Turn ptr into place.\n+                // `ref_to_mplace` also calls the machine hook for (re)activating the tag,\n+                // which in turn will (in full miri) check if the pointer is dereferencable.\n+                let place = self.ref_to_mplace(value)?;\n+                // Recursive checking\n+                if let Some(ref_tracking) = ref_tracking {\n+                    assert!(const_mode, \"We should only do recursie checking in const mode\");\n                     if size != Size::ZERO {\n+                        // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n                             \"integer pointer in non-ZST reference\", path);\n-                        if const_mode {\n-                            // Skip validation entirely for some external statics\n-                            let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                            if let Some(AllocType::Static(did)) = alloc_kind {\n-                                // `extern static` cannot be validated as they have no body.\n-                                // FIXME: Statics from other crates are also skipped.\n-                                // They might be checked at a different type, but for now we\n-                                // want to avoid recursing too deeply.  This is not sound!\n-                                if !did.is_local() || self.tcx.is_foreign_item(did) {\n-                                    return Ok(());\n-                                }\n+                        // Skip validation entirely for some external statics\n+                        let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                        if let Some(AllocType::Static(did)) = alloc_kind {\n+                            // `extern static` cannot be validated as they have no body.\n+                            // FIXME: Statics from other crates are also skipped.\n+                            // They might be checked at a different type, but for now we\n+                            // want to avoid recursing too deeply.  This is not sound!\n+                            if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                                return Ok(());\n                             }\n                         }\n+                        // Maintain the invariant that the place we are checking is\n+                        // already verified to be in-bounds.\n                         try_validation!(self.memory.check_bounds(ptr, size, false),\n                             \"dangling (not entirely in bounds) reference\", path);\n                     }\n-                    if let Some(ref_tracking) = ref_tracking {\n-                        // Check if we have encountered this pointer+layout combination\n-                        // before.  Proceed recursively even for integer pointers, no\n-                        // reason to skip them! They are (recursively) valid for some ZST,\n-                        // but not for others (e.g. `!` is a ZST).\n-                        let op = place.into();\n-                        if ref_tracking.seen.insert(op) {\n-                            trace!(\"Recursing below ptr {:#?}\", *op);\n-                            ref_tracking.todo.push((op, path_clone_and_deref(path)));\n-                        }\n+                    // Check if we have encountered this pointer+layout combination\n+                    // before.  Proceed recursively even for integer pointers, no\n+                    // reason to skip them! They are (recursively) valid for some ZST,\n+                    // but not for others (e.g. `!` is a ZST).\n+                    let op = place.into();\n+                    if ref_tracking.seen.insert(op) {\n+                        trace!(\"Recursing below ptr {:#?}\", *op);\n+                        ref_tracking.todo.push((op, path_clone_and_deref(path)));\n                     }\n                 }\n             }"}]}