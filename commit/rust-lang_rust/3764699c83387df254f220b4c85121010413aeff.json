{"sha": "3764699c83387df254f220b4c85121010413aeff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NjQ2OTljODMzODdkZjI1NGYyMjBiNGM4NTEyMTAxMDQxM2FlZmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-11T15:25:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T18:02:38Z"}, "message": "Refactor collect to separate out the computation of the type scheme\nand predicates. Try to document how things work. More cleanup is\nneeded here but I had to draw the line somewhere gosh darn it.", "tree": {"sha": "822d98989c0455f3af8c34bf32214e9f599be5db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/822d98989c0455f3af8c34bf32214e9f599be5db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3764699c83387df254f220b4c85121010413aeff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3764699c83387df254f220b4c85121010413aeff", "html_url": "https://github.com/rust-lang/rust/commit/3764699c83387df254f220b4c85121010413aeff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3764699c83387df254f220b4c85121010413aeff/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1630970deaf3fce2b0c4671acaeb8edfd07bc7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1630970deaf3fce2b0c4671acaeb8edfd07bc7e", "html_url": "https://github.com/rust-lang/rust/commit/d1630970deaf3fce2b0c4671acaeb8edfd07bc7e"}], "stats": {"total": 922, "additions": 558, "deletions": 364}, "files": [{"sha": "3ee3eb87b95a70313001764d8027e8b91e28316e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 558, "deletions": 364, "changes": 922, "blob_url": "https://github.com/rust-lang/rust/blob/3764699c83387df254f220b4c85121010413aeff/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3764699c83387df254f220b4c85121010413aeff/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3764699c83387df254f220b4c85121010413aeff", "patch": "@@ -20,28 +20,83 @@ current crate: we assume that after the collect phase, the types of\n all local items will be present in the table.\n \n Unlike most of the types that are present in Rust, the types computed\n-for each item are in fact polytypes.  In \"layman's terms\", this means\n-that they are generic types that may have type parameters (more\n-mathematically phrased, they are universally quantified over a set of\n-type parameters).  TypeSchemes are represented by an instance of\n-`ty::TypeScheme`.  This combines the core type along with a list of the\n-bounds for each parameter.  Type parameters themselves are represented\n-as `ty_param()` instances.\n+for each item are in fact type schemes. This means that they are\n+generic types that may have type parameters. TypeSchemes are\n+represented by an instance of `ty::TypeScheme`.  This combines the\n+core type along with a list of the bounds for each parameter. Type\n+parameters themselves are represented as `ty_param()` instances.\n+\n+The phasing of type conversion is somewhat complicated. There are a\n+number of possible cycles that can arise.\n+\n+Converting types can require:\n+\n+1. `Foo<X>` where `Foo` is a type alias, or trait requires knowing:\n+   - number of region / type parameters\n+   - for type parameters, `T:'a` annotations to control defaults for object lifetimes\n+   - defaults for type parameters (which are themselves types!)\n+2. `Foo<X>` where `Foo` is a type alias requires knowing what `Foo` expands to\n+3. Translating `SomeTrait` with no explicit lifetime bound requires knowing\n+   - supertraits of `SomeTrait`\n+4. Translating `T::X` (vs `<T as Trait>::X`) requires knowing\n+   - bounds on `T`\n+   - supertraits of those bounds\n+\n+So as you can see, in general translating types requires knowing the\n+trait hierarchy. But this gets a bit tricky because translating the\n+trait hierarchy requires convering the types that appear in trait\n+references. One potential saving grace is that in general knowing the\n+trait hierarchy is only necessary for shorthands like `T::X` or\n+handling omitted lifetime bounds on object types. Therefore, if we are\n+lazy about expanding out the trait hierachy, users can sever cycles if\n+necessary. Lazy expansion is also needed for type aliases.\n+\n+This system is not perfect yet. Currently, we \"convert\" types and\n+traits in three phases (note that conversion only affects the types of\n+items / enum variants / methods; it does not e.g. compute the types of\n+individual expressions):\n+\n+0. Intrinsics\n+1. Trait definitions\n+2. Type definitions\n+\n+Conversion itself is done by simply walking each of the items in turn\n+and invoking an appropriate function (e.g., `trait_def_of_item` or\n+`convert_item`). However, it is possible that while converting an\n+item, we may need to compute the *type scheme* or *trait definition*\n+for other items. This is a kind of shallow conversion that is\n+triggered on demand by calls to `AstConv::get_item_type_scheme` or\n+`AstConv::lookup_trait_def`. It is possible for cycles to result from\n+this (e.g., `type A = B; type B = A;`), in which case astconv\n+(currently) reports the error.\n+\n+There are some shortcomings in this design:\n+\n+- Cycles through trait definitions (e.g. supertraits) are not currently\n+  detected by astconv. (#12511)\n+- Because the type scheme includes defaults, cycles through type\n+  parameter defaults are illegal even if those defaults are never\n+  employed. This is not necessarily a bug.\n+- The phasing of trait definitions before type definitions does not\n+  seem to be necessary, sufficient, or particularly helpful, given that\n+  processing a trait definition can trigger processing a type def and\n+  vice versa. However, if I remove it, I get ICEs, so some more work is\n+  needed in that area. -nmatsakis\n \n */\n+\n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n-use metadata::csearch;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n-use middle::subst::{Substs, TypeSpace};\n+use middle::subst::{Substs, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n-use no_params;\n use rscope::*;\n+use util::common::memoized;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n@@ -130,11 +185,11 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n-        convert(self.ccx, i);\n+        convert_item(self.ccx, i);\n         visit::walk_item(self, i);\n     }\n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        convert_foreign(self.ccx, i);\n+        convert_foreign_item(self.ccx, i);\n         visit::walk_foreign_item(self, i);\n     }\n }\n@@ -157,16 +212,16 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n \n     fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n-            return csearch::get_type(self.tcx, id)\n+            return ty::lookup_item_type(self.tcx, id);\n         }\n \n         match self.tcx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => {\n-                ty_of_item(self, &*item)\n+                type_scheme_of_item(self, &*item)\n             }\n             Some(ast_map::NodeForeignItem(foreign_item)) => {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n-                ty_of_foreign_item(self, &*foreign_item, abi)\n+                type_scheme_of_foreign_item(self, &*foreign_item, abi)\n             }\n             x => {\n                 self.tcx.sess.bug(&format!(\"unexpected sort of node \\\n@@ -181,7 +236,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        span_err!(self.tcx.sess, span, E0121,\n+        span_err!(self.tcx().sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n         self.tcx().types.err\n     }\n@@ -192,14 +247,14 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        ty::mk_projection(self.tcx, trait_ref, item_name)\n+        ty::mk_projection(self.tcx(), trait_ref, item_name)\n     }\n }\n \n fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                        enum_ty: Ty<'tcx>,\n-                                        variants: &[P<ast::Variant>],\n-                                        generics: &ast::Generics) {\n+                                    enum_scheme: ty::TypeScheme<'tcx>,\n+                                    enum_predicates: ty::GenericPredicates<'tcx>,\n+                                    variants: &[P<ast::Variant>]) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -212,38 +267,35 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_ty)\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n-                enum_ty\n+                enum_scheme.ty\n             }\n \n             ast::StructVariantKind(ref struct_def) => {\n-                let scheme = TypeScheme {\n-                    generics: ty_generics_for_type_or_impl(ccx, generics),\n-                    ty: enum_ty\n-                };\n-\n-                convert_struct(ccx, &**struct_def, scheme, variant.node.id);\n-                enum_ty\n+                convert_struct(ccx, &**struct_def, enum_scheme.clone(),\n+                               enum_predicates.clone(), variant.node.id);\n+                enum_scheme.ty\n             }\n         };\n \n-        let scheme = TypeScheme {\n-            generics: ty_generics_for_type_or_impl(ccx, generics),\n+        let variant_scheme = TypeScheme {\n+            generics: enum_scheme.generics.clone(),\n             ty: result_ty\n         };\n \n-        tcx.tcache.borrow_mut().insert(variant_def_id, scheme);\n-\n+        tcx.tcache.borrow_mut().insert(variant_def_id, variant_scheme.clone());\n+        tcx.predicates.borrow_mut().insert(variant_def_id, enum_predicates.clone());\n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n }\n \n fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n-                                   trait_def: &ty::TraitDef<'tcx>) {\n+                                   trait_def: &ty::TraitDef<'tcx>,\n+                                   trait_predicates: &ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n     if let ast_map::NodeItem(item) = tcx.map.get(trait_id) {\n         if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n@@ -259,6 +311,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n+                                    &trait_predicates,\n                                     &trait_items[],\n                                     &m.id,\n                                     &m.ident.name,\n@@ -273,6 +326,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n+                                    &trait_predicates,\n                                     &trait_items[],\n                                     &m.id,\n                                     &m.pe_ident().name,\n@@ -342,12 +396,17 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             m.def_id,\n             TypeScheme {\n                 generics: m.generics.clone(),\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone())) });\n+                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone()))\n+            });\n+        ccx.tcx.predicates.borrow_mut().insert(\n+            m.def_id,\n+            m.predicates.clone());\n     }\n \n     fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n+                                           trait_bounds: &ty::GenericPredicates<'tcx>,\n                                            _trait_items: &[ast::TraitItem],\n                                            m_id: &ast::NodeId,\n                                            m_name: &ast::Name,\n@@ -358,10 +417,15 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            m_decl: &ast::FnDecl)\n                                            -> ty::Method<'tcx> {\n         let ty_generics =\n-            ty_generics_for_fn_or_method(\n-                ccx,\n-                m_generics,\n-                (*trait_generics).clone());\n+            ty_generics_for_fn_or_method(ccx,\n+                                         m_generics,\n+                                         trait_generics.clone());\n+\n+        let ty_bounds =\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               m_generics,\n+                                               &ty_generics,\n+                                               trait_bounds.clone());\n \n         let (fty, explicit_self_category) = {\n             let trait_self_ty = ty::mk_self_type(ccx.tcx);\n@@ -376,6 +440,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ty::Method::new(\n             *m_name,\n             ty_generics,\n+            ty_bounds,\n             fty,\n             explicit_self_category,\n             // assume public, because this is only invoked on trait methods\n@@ -389,16 +454,20 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                 struct_generics: &ty::Generics<'tcx>,\n+                                struct_predicates: &ty::GenericPredicates<'tcx>,\n                                 v: &ast::StructField,\n                                 origin: ast::DefId) -> ty::field_ty {\n     let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n+\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n                                        ty::TypeScheme {\n                                            generics: struct_generics.clone(),\n                                            ty: tt\n                                        });\n+    ccx.tcx.predicates.borrow_mut().insert(local_def(v.node.id),\n+                                           struct_predicates.clone());\n \n     match v.node.kind {\n         ast::NamedField(ident, visibility) => {\n@@ -442,6 +511,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n+                                 rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n                                  where I: Iterator<Item=&'i ast::Method> {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n@@ -456,11 +526,13 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n         }\n \n         let m_def_id = local_def(m.id);\n+\n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n                                        m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n+                                       rcvr_ty_predicates,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, Some(m_def_id), tcx.mk_bare_fn(mty.fty.clone()));\n         debug!(\"method {} (id {}) has type {}\",\n@@ -473,6 +545,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                 generics: mty.generics.clone(),\n                 ty: fty\n             });\n+        tcx.predicates.borrow_mut().insert(m_def_id, mty.predicates.clone());\n \n         write_ty_to_tcx(tcx, m.id, fty);\n \n@@ -489,13 +562,19 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n                               rcvr_ty_generics: &ty::Generics<'tcx>,\n+                              rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                               rcvr_visibility: ast::Visibility)\n                               -> ty::Method<'tcx> {\n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(\n-                ccx,\n-                m.pe_generics(),\n-                (*rcvr_ty_generics).clone());\n+            ty_generics_for_fn_or_method(ccx,\n+                                         m.pe_generics(),\n+                                         rcvr_ty_generics.clone());\n+\n+        let m_ty_bounds =\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               m.pe_generics(),\n+                                               &m_ty_generics,\n+                                               rcvr_ty_predicates.clone());\n \n         let (fty, explicit_self_category) = astconv::ty_of_method(ccx,\n                                                                   m.pe_unsafety(),\n@@ -512,6 +591,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n \n         ty::Method::new(m.pe_ident().name,\n                         m_ty_generics,\n+                        m_ty_bounds,\n                         fty,\n                         explicit_self_category,\n                         method_vis,\n@@ -550,39 +630,43 @@ fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n     }\n }\n \n-fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n+fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n         // These don't define types.\n         ast::ItemExternCrate(_) | ast::ItemUse(_) |\n-        ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n-        ast::ItemEnum(ref enum_definition, ref generics) => {\n-            let scheme = ty_of_item(ccx, it);\n+        ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {\n+        }\n+        ast::ItemEnum(ref enum_definition, _) => {\n+            let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n             get_enum_variant_types(ccx,\n-                                   scheme.ty,\n-                                   &enum_definition.variants,\n-                                   generics);\n+                                   scheme,\n+                                   predicates,\n+                                   &enum_definition.variants);\n         },\n         ast::ItemImpl(_, _,\n                       ref generics,\n                       ref opt_trait_ref,\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n+\n+            debug!(\"convert: ast_generics={:?}\", generics);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n+            let ty_predicates = ty_generic_bounds_for_type_or_impl(ccx, &ty_generics, generics);\n+\n+            debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n             let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.tcache\n-               .borrow_mut()\n-               .insert(local_def(it.id),\n-                       TypeScheme {\n-                        generics: ty_generics.clone(),\n-                        ty: selfty,\n-                       });\n+            tcx.tcache.borrow_mut().insert(local_def(it.id),\n+                                           TypeScheme { generics: ty_generics.clone(),\n+                                                        ty: selfty });\n+            tcx.predicates.borrow_mut().insert(local_def(it.id),\n+                                               ty_predicates.clone());\n \n             // If there is a trait reference, treat the methods as always public.\n             // This is to work around some incorrect behavior in privacy checking:\n@@ -614,14 +698,14 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                         }\n \n                         let typ = ccx.to_ty(&ExplicitRscope, &*typedef.typ);\n-                        tcx.tcache\n-                           .borrow_mut()\n-                           .insert(local_def(typedef.id),\n-                                   TypeScheme {\n-                                    generics: ty::Generics::empty(),\n-                                    ty: typ,\n-                                   });\n-                        write_ty_to_tcx(ccx.tcx, typedef.id, typ);\n+                        tcx.tcache.borrow_mut().insert(local_def(typedef.id),\n+                                                       TypeScheme {\n+                                                           generics: ty::Generics::empty(),\n+                                                           ty: typ,\n+                                                       });\n+                        tcx.predicates.borrow_mut().insert(local_def(typedef.id),\n+                                                           ty::GenericPredicates::empty());\n+                        write_ty_to_tcx(tcx, typedef.id, typ);\n \n                         let associated_type = Rc::new(ty::AssociatedType {\n                             name: typedef.ident.name,\n@@ -642,6 +726,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                             methods.into_iter(),\n                             selfty,\n                             &ty_generics,\n+                            &ty_predicates,\n                             parent_visibility);\n \n             if let Some(ref trait_ref) = *opt_trait_ref {\n@@ -652,16 +737,16 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                                                None);\n             }\n \n-            enforce_impl_ty_params_are_constrained(ccx.tcx,\n+            enforce_impl_ty_params_are_constrained(tcx,\n                                                    generics,\n                                                    local_def(it.id));\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n+            convert_trait_predicates(ccx, it);\n+            let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n \n-            debug!(\"trait_def: ident={} trait_def={}\",\n-                   it.ident.repr(ccx.tcx),\n-                   trait_def.repr(ccx.tcx));\n+            debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n             for trait_method in trait_methods {\n                 let self_type = ty::mk_self_type(tcx);\n@@ -700,47 +785,46 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                             }),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n+                            &trait_predicates,\n                             it.vis);\n \n             // We need to do this *after* converting methods, since\n             // convert_methods produces a tcache entry that is wrong for\n             // static trait methods. This is somewhat unfortunate.\n-            collect_trait_methods(ccx, it.id, &*trait_def);\n+            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n-            let scheme = ty_of_item(ccx, it);\n+            let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-\n-            convert_struct(ccx, &**struct_def, scheme, it.id);\n+            convert_struct(ccx, &**struct_def, scheme, predicates, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            let tpt = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            let (scheme, _) = convert_typed_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n         },\n         _ => {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let scheme = ty_of_item(ccx, it);\n+            let (scheme, _) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n         },\n     }\n }\n \n fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                struct_def: &ast::StructDef,\n-                                scheme: ty::TypeScheme<'tcx>,\n-                                id: ast::NodeId) {\n+                            struct_def: &ast::StructDef,\n+                            scheme: ty::TypeScheme<'tcx>,\n+                            predicates: ty::GenericPredicates<'tcx>,\n+                            id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let field_tys = struct_def.fields.iter().map(|f| {\n-        let result = convert_field(ccx, &scheme.generics, f, local_def(id));\n+        let result = convert_field(ccx, &scheme.generics, &predicates, f, local_def(id));\n \n         if result.name != special_idents::unnamed_field.name {\n             let dup = match seen_fields.get(&result.name) {\n@@ -778,6 +862,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id), scheme);\n+                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> = struct_def.fields.iter().map(\n@@ -789,44 +874,30 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n-                                  TypeScheme {\n-                    generics: scheme.generics,\n-                    ty: ctor_fn_ty\n-                });\n+                                               TypeScheme {\n+                                                   generics: scheme.generics,\n+                                                   ty: ctor_fn_ty\n+                                               });\n+                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             }\n         }\n     }\n }\n \n-fn convert_foreign(ccx: &CollectCtxt, i: &ast::ForeignItem) {\n-    // As above, this call populates the type table with the converted\n-    // type of the foreign item. We simply write it into the node type\n-    // table.\n-\n-    // For reasons I cannot fully articulate, I do so hate the AST\n-    // map, and I regard each time that I use it as a personal and\n-    // moral failing, but at the moment it seems like the only\n-    // convenient way to extract the ABI. - ndm\n-    let abi = ccx.tcx.map.get_foreign_abi(i.id);\n-\n-    let scheme = ty_of_foreign_item(ccx, i, abi);\n-    write_ty_to_tcx(ccx.tcx, i.id, scheme.ty);\n-\n-    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), scheme);\n-}\n-\n fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                            trait_id: ast::DefId)\n                            -> Rc<ty::TraitDef<'tcx>> {\n+    let tcx = ccx.tcx;\n+\n     if trait_id.krate != ast::LOCAL_CRATE {\n-        return ty::lookup_trait_def(ccx.tcx, trait_id)\n+        return ty::lookup_trait_def(tcx, trait_id)\n     }\n \n-    match ccx.tcx.map.get(trait_id.node) {\n+    match tcx.map.get(trait_id.node) {\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n-            ccx.tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n-                                     trait_id.node)[])\n+            tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n+                                  trait_id.node)[])\n         }\n     }\n }\n@@ -837,6 +908,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n+\n     if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n         return def.clone();\n     }\n@@ -868,16 +940,13 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, generics));\n \n-    let ty_generics = ty_generics_for_trait(ccx,\n-                                            it.id,\n-                                            substs,\n-                                            generics,\n-                                            items);\n+    let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n \n-    let self_param_ty = ty::ParamTy::for_self();\n+    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n \n+    // supertraits:\n     let bounds = compute_bounds(ccx,\n-                                self_param_ty.to_ty(ccx.tcx),\n+                                self_param_ty,\n                                 bounds,\n                                 SizedByDefault::No,\n                                 it.span);\n@@ -890,11 +959,11 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                      ast::TypeTraitItem(ref data) => Some(data.ty_param.ident.name),\n                  }\n              })\n-            .collect();\n+             .collect();\n \n     let trait_ref = Rc::new(ty::TraitRef {\n         def_id: def_id,\n-        substs: substs\n+        substs: substs,\n     });\n \n     let trait_def = Rc::new(ty::TraitDef {\n@@ -905,6 +974,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n     });\n+\n     tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n \n     return trait_def;\n@@ -913,6 +983,8 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n                                  -> subst::Substs<'tcx>\n     {\n+        let tcx = ccx.tcx;\n+\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n             generics.lifetimes\n@@ -929,137 +1001,293 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n+                    .map(|(i, def)| ty::mk_param(tcx, subst::TypeSpace,\n                                                  i as u32, def.ident.name))\n                     .collect();\n \n         // ...and also create the `Self` parameter.\n-        let self_ty = ty::mk_self_type(ccx.tcx);\n+        let self_ty = ty::mk_self_type(tcx);\n \n         subst::Substs::new_trait(types, regions, self_ty)\n     }\n }\n \n-fn ty_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item)\n-                            -> ty::TypeScheme<'tcx> {\n-    let def_id = local_def(it.id);\n+fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item) {\n     let tcx = ccx.tcx;\n-    if let Some(scheme) = tcx.tcache.borrow().get(&def_id) {\n-        return scheme.clone();\n+    let trait_def = trait_def_of_item(ccx, it);\n+\n+    let def_id = local_def(it.id);\n+\n+    let (generics, items) = match it.node {\n+        ast::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n+        ref s => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n+        }\n+    };\n+\n+    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n+\n+    let super_predicates = ty::predicates(ccx.tcx, self_param_ty, &trait_def.bounds);\n+\n+    let assoc_predicates = predicates_for_associated_types(ccx, &trait_def.trait_ref, items);\n+\n+    // `ty_generic_bounds` below will consider the bounds on the type\n+    // parameters (including `Self`) and the explicit where-clauses,\n+    // but to get the full set of predicates on a trait we need to add\n+    // in the supertrait bounds and anything declared on the\n+    // associated types.\n+    let mut base_predicates =\n+        ty::GenericPredicates {\n+            predicates: VecPerParamSpace::new(super_predicates, vec![], vec![])\n+        };\n+    base_predicates.predicates.extend(subst::TypeSpace, assoc_predicates.into_iter());\n+\n+    let self_bounds = &trait_def.generics.types.get_self().unwrap().bounds;\n+    base_predicates.predicates.extend(\n+        subst::SelfSpace,\n+        ty::predicates(ccx.tcx, self_param_ty, self_bounds).into_iter());\n+\n+    // add in the explicit where-clauses\n+    let trait_predicates =\n+        ty_generic_bounds(ccx,\n+                          subst::TypeSpace,\n+                          &trait_def.generics,\n+                          base_predicates,\n+                          &generics.where_clause);\n+\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n+    assert!(prev_predicates.is_none());\n+\n+    return;\n+\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+                                                 trait_items: &[ast::TraitItem])\n+                                                 -> Vec<ty::Predicate<'tcx>>\n+    {\n+        trait_items\n+            .iter()\n+            .flat_map(|trait_item| {\n+                let assoc_type_def = match *trait_item {\n+                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n+                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n+                        return vec!().into_iter();\n+                    }\n+                };\n+\n+                let assoc_ty = ty::mk_projection(ccx.tcx,\n+                                                 self_trait_ref.clone(),\n+                                                 assoc_type_def.ident.name);\n+\n+                let bounds = compute_bounds(ccx,\n+                                            assoc_ty,\n+                                            &*assoc_type_def.bounds,\n+                                            SizedByDefault::Yes,\n+                                            assoc_type_def.span);\n+\n+                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n+            })\n+            .collect()\n     }\n+}\n+\n+fn type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                it: &ast::Item)\n+                                -> ty::TypeScheme<'tcx>\n+{\n+    memoized(&ccx.tcx.tcache,\n+             local_def(it.id),\n+             |_| compute_type_scheme_of_item(ccx, it))\n+}\n+\n+\n+fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                              it: &ast::Item)\n+                                              -> ty::TypeScheme<'tcx>\n+{\n+    let tcx = ccx.tcx;\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n-            let typ = ccx.to_ty(&ExplicitRscope, &**t);\n-            let scheme = no_params(typ);\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n+            ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(ccx,\n                                                            generics,\n                                                            ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(ccx, unsafety, abi, &**decl);\n-            let scheme = TypeScheme {\n-                generics: ty_generics,\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), ccx.tcx.mk_bare_fn(tofd))\n-            };\n-            debug!(\"type of {} (id {}) is {}\",\n-                    token::get_ident(it.ident),\n-                    it.id,\n-                    scheme.repr(tcx));\n-\n-            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n+            ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n-            match tcx.tcache.borrow_mut().get(&local_def(it.id)) {\n-                Some(scheme) => return scheme.clone(),\n-                None => { }\n-            }\n-\n-            let scheme = {\n-                let ty = ccx.to_ty(&ExplicitRscope, &**t);\n-                TypeScheme {\n-                    generics: ty_generics_for_type_or_impl(ccx, generics),\n-                    ty: ty\n-                }\n-            };\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n+            ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let scheme = TypeScheme {\n-                generics: ty_generics,\n-                ty: t\n-            };\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n-        }\n-        ast::ItemTrait(..) => {\n-            tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n+            ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let scheme = TypeScheme {\n-                generics: ty_generics,\n-                ty: t\n-            };\n-\n-            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n-            return scheme;\n+            ty::TypeScheme { ty: t, generics: ty_generics }\n+        }\n+        ast::ItemTrait(..) |\n+        ast::ItemImpl(..) |\n+        ast::ItemMod(..) |\n+        ast::ItemForeignMod(..) |\n+        ast::ItemExternCrate(..) |\n+        ast::ItemUse(..) |\n+        ast::ItemMac(..) => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                        it.node).as_slice());\n         }\n-        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n-        ast::ItemImpl(..) | ast::ItemMod(_) |\n-        ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n     }\n }\n \n-fn ty_of_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                    it: &ast::ForeignItem,\n-                                    abi: abi::Abi) -> ty::TypeScheme<'tcx>\n+fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                                it: &ast::Item)\n+                                -> (ty::TypeScheme<'tcx>, ty::GenericPredicates<'tcx>)\n+{\n+    let tcx = ccx.tcx;\n+\n+    let tag = type_scheme_of_item(ccx, it);\n+    let scheme = TypeScheme { generics: tag.generics, ty: tag.ty };\n+    let predicates = match it.node {\n+        ast::ItemStatic(..) | ast::ItemConst(..) => {\n+            ty::GenericPredicates::empty()\n+        }\n+        ast::ItemFn(_, _, _, ref ast_generics, _) => {\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               ast_generics,\n+                                               &scheme.generics,\n+                                               ty::GenericPredicates::empty())\n+        }\n+        ast::ItemTy(_, ref generics) => {\n+            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+        }\n+        ast::ItemEnum(_, ref generics) => {\n+            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+        }\n+        ast::ItemStruct(_, ref generics) => {\n+            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+        }\n+        ast::ItemTrait(..) |\n+        ast::ItemExternCrate(..) |\n+        ast::ItemUse(..) |\n+        ast::ItemImpl(..) |\n+        ast::ItemMod(..) |\n+        ast::ItemForeignMod(..) |\n+        ast::ItemMac(..) => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                        it.node).as_slice());\n+        }\n+    };\n+\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(local_def(it.id),\n+                                                             predicates.clone());\n+    assert!(prev_predicates.is_none());\n+\n+    return (scheme, predicates);\n+\n+}\n+\n+fn type_scheme_of_foreign_item<'a, 'tcx>(\n+    ccx: &CollectCtxt<'a, 'tcx>,\n+    it: &ast::ForeignItem,\n+    abi: abi::Abi)\n+    -> ty::TypeScheme<'tcx>\n+{\n+    memoized(&ccx.tcx().tcache,\n+             local_def(it.id),\n+             |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n+}\n+\n+fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n+    ccx: &CollectCtxt<'a, 'tcx>,\n+    it: &ast::ForeignItem,\n+    abi: abi::Abi)\n+    -> ty::TypeScheme<'tcx>\n {\n     match it.node {\n         ast::ForeignItemFn(ref fn_decl, ref generics) => {\n-            ty_of_foreign_fn_decl(ccx,\n-                                  &**fn_decl,\n-                                  local_def(it.id),\n-                                  generics,\n-                                  abi)\n+            compute_type_scheme_of_foreign_fn_decl(ccx, fn_decl, generics, abi)\n         }\n         ast::ForeignItemStatic(ref t, _) => {\n             ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &**t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n             }\n         }\n     }\n }\n \n+fn convert_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+                                  it: &ast::ForeignItem)\n+{\n+    // For reasons I cannot fully articulate, I do so hate the AST\n+    // map, and I regard each time that I use it as a personal and\n+    // moral failing, but at the moment it seems like the only\n+    // convenient way to extract the ABI. - ndm\n+    let tcx = ccx.tcx;\n+    let abi = tcx.map.get_foreign_abi(it.id);\n+\n+    let scheme = type_scheme_of_foreign_item(ccx, it, abi);\n+    write_ty_to_tcx(ccx.tcx, it.id, scheme.ty);\n+\n+    let predicates = match it.node {\n+        ast::ForeignItemFn(_, ref generics) => {\n+            ty_generic_bounds_for_fn_or_method(ccx,\n+                                               generics,\n+                                               &scheme.generics,\n+                                               ty::GenericPredicates::empty())\n+        }\n+        ast::ForeignItemStatic(..) => {\n+            ty::GenericPredicates::empty()\n+        }\n+    };\n+\n+    let prev_predicates = tcx.predicates.borrow_mut().insert(local_def(it.id), predicates);\n+    assert!(prev_predicates.is_none());\n+}\n+\n fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 &generics.lifetimes[],\n                 &generics.ty_params[],\n-                ty::Generics::empty(),\n-                &generics.where_clause)\n+                ty::Generics::empty())\n+}\n+\n+fn ty_generic_bounds_for_type_or_impl<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                               ty_generics: &ty::Generics<'tcx>,\n+                                               generics: &ast::Generics)\n+                                               -> ty::GenericPredicates<'tcx>\n+{\n+    ty_generic_bounds(ccx,\n+                      subst::TypeSpace,\n+                      ty_generics,\n+                      ty::GenericPredicates::empty(),\n+                      &generics.where_clause)\n }\n \n fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n-                                   ast_generics: &ast::Generics,\n-                                   trait_items: &[ast::TraitItem])\n+                                   ast_generics: &ast::Generics)\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n@@ -1070,8 +1298,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                     subst::TypeSpace,\n                     &ast_generics.lifetimes[],\n                     &ast_generics.ty_params[],\n-                    ty::Generics::empty(),\n-                    &ast_generics.where_clause);\n+                    ty::Generics::empty());\n \n     // Add in the self type parameter.\n     //\n@@ -1101,49 +1328,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     generics.types.push(subst::SelfSpace, def);\n \n-    generics.predicates.push(subst::SelfSpace, self_trait_ref.as_predicate());\n-\n-    let assoc_predicates = predicates_for_associated_types(ccx,\n-                                                           &self_trait_ref,\n-                                                           trait_items);\n-\n-    debug!(\"ty_generics_for_trait: assoc_predicates={}\", assoc_predicates.repr(ccx.tcx));\n-\n-    for assoc_predicate in assoc_predicates {\n-        generics.predicates.push(subst::TypeSpace, assoc_predicate);\n-    }\n-\n     return generics;\n-\n-    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n-                                                 trait_items: &[ast::TraitItem])\n-                                                 -> Vec<ty::Predicate<'tcx>>\n-    {\n-        trait_items\n-            .iter()\n-            .flat_map(|trait_item| {\n-                let assoc_type_def = match *trait_item {\n-                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n-                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n-                        return vec!().into_iter();\n-                    }\n-                };\n-\n-                let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                                 self_trait_ref.clone(),\n-                                                 assoc_type_def.ident.name);\n-\n-                let bounds = compute_bounds(ccx,\n-                                            assoc_ty,\n-                                            &*assoc_type_def.bounds,\n-                                            SizedByDefault::Yes,\n-                                            assoc_type_def.span);\n-\n-                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n-            })\n-            .collect()\n-    }\n }\n \n fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n@@ -1156,8 +1341,20 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 subst::FnSpace,\n                 &early_lifetimes[],\n                 &generics.ty_params[],\n-                base_generics,\n-                &generics.where_clause)\n+                base_generics)\n+}\n+\n+fn ty_generic_bounds_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                               generics: &ast::Generics,\n+                                               ty_generics: &ty::Generics<'tcx>,\n+                                               base: ty::GenericPredicates<'tcx>)\n+                                               -> ty::GenericPredicates<'tcx>\n+{\n+    ty_generic_bounds(ccx,\n+                      subst::FnSpace,\n+                      ty_generics,\n+                      base,\n+                      &generics.where_clause)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n@@ -1207,47 +1404,29 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                        space: subst::ParamSpace,\n-                        lifetime_defs: &[ast::LifetimeDef],\n-                        types: &[ast::TyParam],\n-                        base_generics: ty::Generics<'tcx>,\n-                        where_clause: &ast::WhereClause)\n-                        -> ty::Generics<'tcx>\n+fn ty_generic_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                              space: subst::ParamSpace,\n+                              generics: &ty::Generics<'tcx>,\n+                              base: ty::GenericPredicates<'tcx>,\n+                              where_clause: &ast::WhereClause)\n+                              -> ty::GenericPredicates<'tcx>\n {\n-    let mut result = base_generics;\n-\n-    for (i, l) in lifetime_defs.iter().enumerate() {\n-        let bounds = l.bounds.iter()\n-                             .map(|l| ast_region_to_region(ccx.tcx, l))\n-                             .collect();\n-        let def = ty::RegionParameterDef { name: l.lifetime.name,\n-                                           space: space,\n-                                           index: i as u32,\n-                                           def_id: local_def(l.lifetime.id),\n-                                           bounds: bounds };\n-        debug!(\"ty_generics: def for region param: {:?}\", def);\n-        result.regions.push(space, def);\n+    let tcx = ccx.tcx;\n+    let mut result = base;\n+\n+    // For now, scrape the bounds out of parameters from Generics. This is not great.\n+    for def in generics.regions.get_slice(space) {\n+        let r_a = def.to_early_bound_region();\n+        for &r_b in &def.bounds {\n+            let outlives = ty::Binder(ty::OutlivesPredicate(r_a, r_b));\n+            result.predicates.push(def.space, ty::Predicate::RegionOutlives(outlives));\n+        }\n     }\n-\n-    assert!(result.types.is_empty_in(space));\n-\n-    // Now create the real type parameters.\n-    for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(ccx,\n-                                                   space,\n-                                                   param,\n-                                                   i as u32);\n-        debug!(\"ty_generics: def for type param: {}, {:?}\",\n-               def.repr(ccx.tcx),\n-               space);\n-        result.types.push(space, def);\n+    for def in generics.types.get_slice(space) {\n+        let t = ty::mk_param_from_def(ccx.tcx, def);\n+        result.predicates.extend(def.space, ty::predicates(ccx.tcx, t, &def.bounds).into_iter());\n     }\n \n-    // Just for fun, also push the bounds from the type parameters\n-    // into the predicates list. This is currently kind of non-DRY.\n-    create_predicates(ccx.tcx, &mut result, space);\n-\n     // Add the bounds not associated with a type parameter\n     for predicate in &where_clause.predicates {\n         match predicate {\n@@ -1275,7 +1454,7 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                         }\n \n                         &ast::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = ast_region_to_region(ccx.tcx, lifetime);\n+                            let region = ast_region_to_region(tcx, lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             result.predicates.push(space, ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1284,49 +1463,60 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n             }\n \n             &ast::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = ast_region_to_region(ccx.tcx, &region_pred.lifetime);\n+                let r1 = ast_region_to_region(tcx, &region_pred.lifetime);\n                 for bound in &region_pred.bounds {\n-                    let r2 = ast_region_to_region(ccx.tcx, bound);\n+                    let r2 = ast_region_to_region(tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n             &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                 // FIXME(#20041)\n-                ccx.tcx.sess.span_bug(eq_pred.span,\n-                                         \"Equality constraints are not yet \\\n-                                            implemented (#20041)\")\n+                tcx.sess.span_bug(eq_pred.span,\n+                                    \"Equality constraints are not yet \\\n+                                        implemented (#20041)\")\n             }\n         }\n     }\n \n     return result;\n+}\n \n-    fn create_predicates<'tcx>(\n-        tcx: &ty::ctxt<'tcx>,\n-        result: &mut ty::Generics<'tcx>,\n-        space: subst::ParamSpace)\n-    {\n-        for type_param_def in result.types.get_slice(space) {\n-            let param_ty = ty::mk_param_from_def(tcx, type_param_def);\n-            for predicate in ty::predicates(tcx, param_ty, &type_param_def.bounds) {\n-                result.predicates.push(space, predicate);\n-            }\n-        }\n+fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                        space: subst::ParamSpace,\n+                        lifetime_defs: &[ast::LifetimeDef],\n+                        types: &[ast::TyParam],\n+                        base_generics: ty::Generics<'tcx>)\n+                        -> ty::Generics<'tcx>\n+{\n+    let tcx = ccx.tcx;\n+    let mut result = base_generics;\n \n-        for region_param_def in result.regions.get_slice(space) {\n-            let region = region_param_def.to_early_bound_region();\n-            for &bound_region in &region_param_def.bounds {\n-                // account for new binder introduced in the predicate below; no need\n-                // to shift `region` because it is never a late-bound region\n-                let bound_region = ty_fold::shift_region(bound_region, 1);\n-                result.predicates.push(\n-                    space,\n-                    ty::Binder(ty::OutlivesPredicate(region, bound_region)).as_predicate());\n-            }\n-        }\n+    for (i, l) in lifetime_defs.iter().enumerate() {\n+        let bounds = l.bounds.iter()\n+                             .map(|l| ast_region_to_region(tcx, l))\n+                             .collect();\n+        let def = ty::RegionParameterDef { name: l.lifetime.name,\n+                                           space: space,\n+                                           index: i as u32,\n+                                           def_id: local_def(l.lifetime.id),\n+                                           bounds: bounds };\n+        // debug!(\"ty_generics: def for region param: {:?}\",\n+        //        def.repr(tcx));\n+        result.regions.push(space, def);\n+    }\n+\n+    assert!(result.types.is_empty_in(space));\n+\n+    // Now create the real type parameters.\n+    for (i, param) in types.iter().enumerate() {\n+        let def = get_or_create_type_parameter_def(ccx, space, param, i as u32);\n+        debug!(\"ty_generics: def for type param: {:?}, {:?}\", def, space);\n+        result.types.push(space, def);\n     }\n+\n+    result\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n@@ -1335,8 +1525,9 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                              index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n {\n-    match ccx.tcx.ty_param_defs.borrow().get(&param.id) {\n-        Some(d) => { return (*d).clone(); }\n+    let tcx = ccx.tcx;\n+    match tcx.ty_param_defs.borrow().get(&param.id) {\n+        Some(d) => { return d.clone(); }\n         None => { }\n     }\n \n@@ -1355,9 +1546,9 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n             ty::walk_ty(ty, |t| {\n                 match t.sty {\n                     ty::ty_param(p) => if p.idx > cur_idx {\n-                        span_err!(ccx.tcx.sess, path.span, E0128,\n+                        span_err!(tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n-                                   forward declared identifiers\");\n+                                  forward declared identifiers\");\n                         },\n                         _ => {}\n                     }\n@@ -1376,7 +1567,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n         default: default\n     };\n \n-    ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+    tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n     def\n }\n@@ -1404,7 +1595,7 @@ fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                           ast_bounds,\n                           span);\n \n-        check_bounds_compatible(ccx.tcx,\n+        check_bounds_compatible(ccx,\n                                 param_ty,\n                                 &param_bounds,\n                                 span);\n@@ -1415,24 +1606,22 @@ fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     param_bounds\n }\n \n-fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 param_ty: Ty<'tcx>,\n-                                 param_bounds: &ty::ParamBounds<'tcx>,\n-                                 span: Span) {\n-    // Currently the only bound which is incompatible with other bounds is\n-    // Sized/Unsized.\n+fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+                                    param_ty: Ty<'tcx>,\n+                                    param_bounds: &ty::ParamBounds<'tcx>,\n+                                    span: Span) {\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n-            tcx,\n+            ccx.tcx,\n             &param_bounds.trait_bounds[],\n             |trait_ref| {\n-                let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n+                let trait_def = ccx.get_trait_def(trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n-                    span_err!(tcx.sess, span, E0129,\n+                    span_err!(ccx.tcx.sess, span, E0129,\n                               \"incompatible bounds on `{}`, \\\n                                bound `{}` does not allow unsized type\",\n-                              param_ty.user_string(tcx),\n-                              trait_ref.user_string(tcx));\n+                              param_ty.user_string(ccx.tcx),\n+                              trait_ref.user_string(ccx.tcx));\n                 }\n                 true\n             });\n@@ -1445,10 +1634,12 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n {\n-    let astconv::PartitionedBounds { builtin_bounds,\n-                                     trait_bounds,\n-                                     region_bounds } =\n-        astconv::partition_bounds(ccx.tcx, span, ast_bounds);\n+    let tcx = ccx.tcx;\n+    let astconv::PartitionedBounds {\n+        builtin_bounds,\n+        trait_bounds,\n+        region_bounds\n+    } = astconv::partition_bounds(tcx, span, ast_bounds.as_slice());\n \n     let mut projection_bounds = Vec::new();\n \n@@ -1461,11 +1652,13 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                                 Some(param_ty),\n                                                 &mut projection_bounds)\n         })\n-        .collect();\n+    .collect();\n+\n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()\n-        .map(|r| ast_region_to_region(ccx.tcx, r))\n-        .collect();\n+                     .map(|r| ast_region_to_region(ccx.tcx, r))\n+                     .collect();\n+\n     ty::ParamBounds {\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n@@ -1474,13 +1667,14 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                       decl: &ast::FnDecl,\n-                                       def_id: ast::DefId,\n-                                       ast_generics: &ast::Generics,\n-                                       abi: abi::Abi)\n-                                       -> ty::TypeScheme<'tcx> {\n-    for i in &decl.inputs {\n+fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n+    ccx: &CollectCtxt<'a, 'tcx>,\n+    decl: &ast::FnDecl,\n+    ast_generics: &ast::Generics,\n+    abi: abi::Abi)\n+    -> ty::TypeScheme<'tcx>\n+{\n+    for i in decl.inputs.iter() {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n             ast::PatWild(ast::PatWildSingle) => (),\n@@ -1491,9 +1685,8 @@ fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let ty_generics_for_fn_or_method = ty_generics_for_fn_or_method(ccx,\n-                                                                    ast_generics,\n-                                                                    ty::Generics::empty());\n+    let ty_generics = ty_generics_for_fn_or_method(ccx, ast_generics, ty::Generics::empty());\n+\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n@@ -1519,13 +1712,11 @@ fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                        output: output,\n                                        variadic: decl.variadic}),\n         }));\n-    let scheme = TypeScheme {\n-        generics: ty_generics_for_fn_or_method,\n-        ty: t_fn\n-    };\n \n-    ccx.tcx.tcache.borrow_mut().insert(def_id, scheme.clone());\n-    return scheme;\n+    ty::TypeScheme {\n+        generics: ty_generics,\n+        ty: t_fn\n+    }\n }\n \n fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n@@ -1556,6 +1747,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n+    let tcx = ccx.tcx;\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n         let typ = ccx.to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n@@ -1573,35 +1765,36 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let required_type_free =\n             liberate_early_bound_regions(\n-                ccx.tcx, body_scope,\n+                tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    ccx.tcx, body_scope, &ty::Binder(required_type)));\n+                    tcx, body_scope, &ty::Binder(required_type)));\n \n         // The \"base type\" comes from the impl. It too may have late-bound\n         // regions from the method.\n         assert!(!base_type.has_regions_escaping_depth(1));\n         let base_type_free =\n             liberate_early_bound_regions(\n-                ccx.tcx, body_scope,\n+                tcx, body_scope,\n                 &ty::liberate_late_bound_regions(\n-                    ccx.tcx, body_scope, &ty::Binder(base_type)));\n-\n-        debug!(\"required_type={} required_type_free={} \\\n-                base_type={} base_type_free={}\",\n-               required_type.repr(ccx.tcx),\n-               required_type_free.repr(ccx.tcx),\n-               base_type.repr(ccx.tcx),\n-               base_type_free.repr(ccx.tcx));\n-        let infcx = infer::new_infer_ctxt(ccx.tcx);\n-        drop(::require_same_types(ccx.tcx,\n+                    tcx, body_scope, &ty::Binder(base_type)));\n+\n+        //debug!(\"required_type={} required_type_free={} \\\n+                //base_type={} base_type_free={}\",\n+               //required_type.repr(tcx),\n+               //required_type_free.repr(tcx),\n+               //base_type.repr(tcx),\n+               //base_type_free.repr(tcx));\n+\n+        let infcx = infer::new_infer_ctxt(tcx);\n+        drop(::require_same_types(tcx,\n                                   Some(&infcx),\n                                   false,\n                                   explicit_self.span,\n                                   base_type_free,\n                                   required_type_free,\n                                   || {\n                 format!(\"mismatched self type: expected `{}`\",\n-                        ppaux::ty_to_string(ccx.tcx, required_type))\n+                        ppaux::ty_to_string(tcx, required_type))\n         }));\n         infcx.resolve_regions_and_report_errors(body_id);\n     }\n@@ -1639,6 +1832,7 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                 impl_def_id: ast::DefId)\n {\n     let impl_scheme = ty::lookup_item_type(tcx, impl_def_id);\n+    let impl_predicates = ty::lookup_predicates(tcx, impl_def_id);\n     let impl_trait_ref = ty::impl_trait_ref(tcx, impl_def_id);\n \n     // The trait reference is an input, so find all type parameters\n@@ -1656,18 +1850,18 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let num_inputs = input_parameters.len();\n \n         let projection_predicates =\n-            impl_scheme.generics.predicates\n-            .iter()\n-            .filter_map(|predicate| {\n-                match *predicate {\n-                    // Ignore higher-ranked binders. For the purposes\n-                    // of this check, they don't matter because they\n-                    // only affect named regions, and we're just\n-                    // concerned about type parameters here.\n-                    ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n-                    _ => None,\n-                }\n-            });\n+            impl_predicates.predicates\n+                           .iter()\n+                           .filter_map(|predicate| {\n+                               match *predicate {\n+                                   // Ignore higher-ranked binders. For the purposes\n+                                   // of this check, they don't matter because they\n+                                   // only affect named regions, and we're just\n+                                   // concerned about type parameters here.\n+                                   ty::Predicate::Projection(ref data) => Some(data.0.clone()),\n+                                   _ => None,\n+                               }\n+                           });\n \n         for projection in projection_predicates {\n             // Special case: watch out for some kind of sneaky attempt"}]}