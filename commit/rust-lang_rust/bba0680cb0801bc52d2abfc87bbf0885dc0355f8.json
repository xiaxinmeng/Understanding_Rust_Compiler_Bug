{"sha": "bba0680cb0801bc52d2abfc87bbf0885dc0355f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYTA2ODBjYjA4MDFiYzUyZDJhYmZjODdiYmYwODg1ZGMwMzU1Zjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T05:51:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:58Z"}, "message": "libstd: Remove mutable fields from future and par", "tree": {"sha": "d07a1c2cb00a575a29397a349b7f37abc9e31faf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d07a1c2cb00a575a29397a349b7f37abc9e31faf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bba0680cb0801bc52d2abfc87bbf0885dc0355f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bba0680cb0801bc52d2abfc87bbf0885dc0355f8", "html_url": "https://github.com/rust-lang/rust/commit/bba0680cb0801bc52d2abfc87bbf0885dc0355f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bba0680cb0801bc52d2abfc87bbf0885dc0355f8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92d2ec4d32c7f7722569b1463cba31c6402f7513", "url": "https://api.github.com/repos/rust-lang/rust/commits/92d2ec4d32c7f7722569b1463cba31c6402f7513", "html_url": "https://github.com/rust-lang/rust/commit/92d2ec4d32c7f7722569b1463cba31c6402f7513"}], "stats": {"total": 81, "additions": 58, "deletions": 23}, "files": [{"sha": "209859e30961e6040f15b2f69c58850788440a5a", "filename": "src/libstd/future.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bba0680cb0801bc52d2abfc87bbf0885dc0355f8/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba0680cb0801bc52d2abfc87bbf0885dc0355f8/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=bba0680cb0801bc52d2abfc87bbf0885dc0355f8", "patch": "@@ -29,7 +29,7 @@ use core::task;\n \n #[doc = \"The future type\"]\n pub struct Future<A> {\n-    priv mut state: FutureState<A>,\n+    priv state: FutureState<A>,\n }\n \n // FIXME(#2829) -- futures should not be copyable, because they close\n@@ -47,33 +47,68 @@ priv enum FutureState<A> {\n \n /// Methods on the `future` type\n pub impl<A:Copy> Future<A> {\n-    fn get(&self) -> A {\n+    fn get(&mut self) -> A {\n         //! Get the value of the future\n         *(self.get_ref())\n     }\n }\n \n pub impl<A> Future<A> {\n+    #[cfg(stage0)]\n     fn get_ref<'a>(&'a self) -> &'a A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as\n         * the future.\n         */\n         unsafe {\n-            match self.state {\n-                Forced(ref mut v) => { return cast::transmute(v); }\n-                Evaluating => fail!(~\"Recursive forcing of future!\"),\n-                Pending(_) => {}\n+            {\n+                match self.state {\n+                    Forced(ref mut v) => { return cast::transmute(v); }\n+                    Evaluating => fail!(~\"Recursive forcing of future!\"),\n+                    Pending(_) => {}\n+                }\n+            }\n+            {\n+                let mut state = Evaluating;\n+                self.state <-> state;\n+                match state {\n+                    Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n+                    Pending(f) => {\n+                        self.state = Forced(f());\n+                        cast::transmute(self.get_ref())\n+                    }\n+                }\n             }\n+        }\n+    }\n \n-            let mut state = Evaluating;\n-            self.state <-> state;\n-            match state {\n-                Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n-                Pending(f) => {\n-                    self.state = Forced(f());\n-                    self.get_ref()\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_ref<'a>(&'a mut self) -> &'a A {\n+        /*!\n+        * Executes the future's closure and then returns a borrowed\n+        * pointer to the result.  The borrowed pointer lasts as long as\n+        * the future.\n+        */\n+        unsafe {\n+            {\n+                match self.state {\n+                    Forced(ref mut v) => { return cast::transmute(v); }\n+                    Evaluating => fail!(~\"Recursive forcing of future!\"),\n+                    Pending(_) => {}\n+                }\n+            }\n+            {\n+                let mut state = Evaluating;\n+                self.state <-> state;\n+                match state {\n+                    Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n+                    Pending(f) => {\n+                        self.state = Forced(f());\n+                        cast::transmute(self.get_ref())\n+                    }\n                 }\n             }\n         }\n@@ -150,54 +185,54 @@ mod test {\n \n     #[test]\n     fn test_from_value() {\n-        let f = from_value(~\"snail\");\n+        let mut f = from_value(~\"snail\");\n         assert!(f.get() == ~\"snail\");\n     }\n \n     #[test]\n     fn test_from_port() {\n         let (po, ch) = oneshot();\n         send_one(ch, ~\"whale\");\n-        let f = from_port(po);\n+        let mut f = from_port(po);\n         assert!(f.get() == ~\"whale\");\n     }\n \n     #[test]\n     fn test_from_fn() {\n-        let f = from_fn(|| ~\"brail\");\n+        let mut f = from_fn(|| ~\"brail\");\n         assert!(f.get() == ~\"brail\");\n     }\n \n     #[test]\n     fn test_interface_get() {\n-        let f = from_value(~\"fail\");\n+        let mut f = from_value(~\"fail\");\n         assert!(f.get() == ~\"fail\");\n     }\n \n     #[test]\n     fn test_get_ref_method() {\n-        let f = from_value(22);\n+        let mut f = from_value(22);\n         assert!(*f.get_ref() == 22);\n     }\n \n     #[test]\n     fn test_spawn() {\n-        let f = spawn(|| ~\"bale\");\n+        let mut f = spawn(|| ~\"bale\");\n         assert!(f.get() == ~\"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n     fn test_futurefail() {\n-        let f = spawn(|| fail!());\n+        let mut f = spawn(|| fail!());\n         let _x: ~str = f.get();\n     }\n \n     #[test]\n     fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n-        let f = do spawn { copy expected };\n+        let mut f = do spawn { copy expected };\n         do task::spawn || {\n             let actual = f.get();\n             assert!(actual == expected);"}, {"sha": "cf0eba9d30cea1a890cf0fd096f44b1dd4dcb959", "filename": "src/libstd/par.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba0680cb0801bc52d2abfc87bbf0885dc0355f8/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba0680cb0801bc52d2abfc87bbf0885dc0355f8/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=bba0680cb0801bc52d2abfc87bbf0885dc0355f8", "patch": "@@ -73,10 +73,10 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n         info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n         assert!((num_tasks == futures.len()));\n \n-        let r = do futures.map() |ys| {\n+        let r = do vec::map_consume(futures) |ys| {\n+            let mut ys = ys;\n             ys.get()\n         };\n-        assert!((r.len() == futures.len()));\n         r\n     }\n }"}]}