{"sha": "12b2607572d6233a1d4b4f7592573e49b505771e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYjI2MDc1NzJkNjIzM2ExZDRiNGY3NTkyNTczZTQ5YjUwNTc3MWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T08:11:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T08:11:39Z"}, "message": "auto merge of #12602 : alexcrichton/rust/backtrace, r=brson\n\nWhenever a failure happens, if a program is run with\r\n`RUST_LOG=std::rt::backtrace` a backtrace will be printed to the task's stderr\r\nhandle. Stack traces are uncondtionally printed on double-failure and\r\nrtabort!().\r\n\r\nThis ended up having a nontrivial implementation, and here's some highlights of\r\nit:\r\n\r\n* We're bundling libbacktrace for everything but OSX and Windows\r\n* We use libgcc_s and its libunwind apis to get a backtrace of instruction\r\n  pointers\r\n* On OSX we use dladdr() to go from an instruction pointer to a symbol\r\n* On unix that isn't OSX, we use libbacktrace to get symbols\r\n* Windows, as usual, has an entirely separate implementation\r\n\r\nLots more fun details and comments can be found in the source itself.\r\n\r\nCloses #10128", "tree": {"sha": "fe0125830b682b441cc97b4ad24cc11bb2882d38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe0125830b682b441cc97b4ad24cc11bb2882d38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12b2607572d6233a1d4b4f7592573e49b505771e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12b2607572d6233a1d4b4f7592573e49b505771e", "html_url": "https://github.com/rust-lang/rust/commit/12b2607572d6233a1d4b4f7592573e49b505771e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12b2607572d6233a1d4b4f7592573e49b505771e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c", "html_url": "https://github.com/rust-lang/rust/commit/6cbba7c54e4e1e02d4ff3ffacf46d15d0f3a039c"}, {"sha": "829df69f9f7a0dd0adbf072a47fd7c7600e75211", "url": "https://api.github.com/repos/rust-lang/rust/commits/829df69f9f7a0dd0adbf072a47fd7c7600e75211", "html_url": "https://github.com/rust-lang/rust/commit/829df69f9f7a0dd0adbf072a47fd7c7600e75211"}], "stats": {"total": 39915, "additions": 39814, "deletions": 101}, "files": [{"sha": "16485b9e6b52990d05493a7ee4f1e5d5fb3779e2", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -55,7 +55,7 @@ HOST_CRATES := syntax rustc rustdoc fourcc hexfloat\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n-DEPS_std := native:rustrt native:compiler-rt\n+DEPS_std := native:rustrt native:compiler-rt native:backtrace\n DEPS_extra := std term sync serialize getopts collections time rand\n DEPS_green := std rand native:context_switch\n DEPS_rustuv := std native:uv native:uv_support"}, {"sha": "01667352c676d5b0291a3d5b1643edcbc453afc0", "filename": "mk/rt.mk", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -249,6 +249,73 @@ $$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS)\n \t\ttriple-runtime\n \t$$(Q)cp $$(COMPRT_BUILD_DIR_$(1))/triple/runtime/libcompiler_rt.a $$(COMPRT_LIB_$(1))\n \n+################################################################################\n+# libbacktrace\n+#\n+# We use libbacktrace on linux to get symbols in backtraces, but only on linux.\n+# Elsewhere we use other system utilities, so this library is only built on\n+# linux.\n+################################################################################\n+\n+BACKTRACE_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),backtrace)\n+BACKTRACE_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(BACKTRACE_NAME_$(1))\n+BACKTRACE_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/libbacktrace\n+\n+ifeq ($$(findstring darwin,$$(OSTYPE_$(1))),darwin)\n+\n+# We don't use this on platforms that aren't linux-based, so just make the file\n+# available, the compilation of libstd won't actually build it.\n+$$(BACKTRACE_LIB_$(1)):\n+\ttouch $$@\n+\n+else\n+ifeq ($$(CFG_WINDOWSY_$(1)),1)\n+$$(BACKTRACE_LIB_$(1)):\n+\ttouch $$@\n+else\n+\n+ifdef CFG_ENABLE_FAST_MAKE\n+BACKTRACE_DEPS := $(S)/.gitmodules\n+else\n+BACKTRACE_DEPS := $(wildcard $(S)src/libbacktrace/*)\n+endif\n+\n+# We need to export CFLAGS because otherwise it doesn't pick up cross compile\n+# builds. If libbacktrace doesn't realize this, it will attempt to read 64-bit\n+# elf headers when compiled for a 32-bit system, yielding blank backtraces.\n+#\n+# This also removes the -Werror flag specifically to prevent errors during\n+# configuration.\n+#\n+# Down below you'll also see echos into the config.h generated by the\n+# ./configure script. This is done to force libbacktrace to *not* use the\n+# atomic/sync functionality because it pulls in unnecessary dependencies and we\n+# never use it anyway.\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: \\\n+\t\texport CFLAGS:=$$(CFG_GCCISH_CFLAGS_$(1):-Werror=) \\\n+\t\t\t\t-fno-stack-protector\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: export CC:=$$(CC_$(1))\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: export AR:=$$(AR_$(1))\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: export RANLIB:=$$(AR_$(1)) s\n+$$(BACKTRACE_BUILD_DIR_$(1))/Makefile: $$(BACKTRACE_DEPS) $$(MKFILE_DEPS)\n+\t$$(Q)rm -rf $$(BACKTRACE_BUILD_DIR_$(1))\n+\t$$(Q)mkdir -p $$(BACKTRACE_BUILD_DIR_$(1))\n+\t$$(Q)(cd $$(BACKTRACE_BUILD_DIR_$(1)) && \\\n+\t      $(S)src/libbacktrace/configure --target=$(1) --host=$(CFG_BUILD))\n+\t$$(Q)echo '#undef HAVE_ATOMIC_FUNCTIONS' >> \\\n+\t      $$(BACKTRACE_BUILD_DIR_$(1))/config.h\n+\t$$(Q)echo '#undef HAVE_SYNC_FUNCTIONS' >> \\\n+\t      $$(BACKTRACE_BUILD_DIR_$(1))/config.h\n+\n+$$(BACKTRACE_LIB_$(1)): $$(BACKTRACE_BUILD_DIR_$(1))/Makefile $$(MKFILE_DEPS)\n+\t@$$(call E, make: libbacktrace)\n+\t$$(Q)$$(MAKE) -C $$(BACKTRACE_BUILD_DIR_$(1)) \\\n+\t\tINCDIR=$(S)src/libbacktrace\n+\t$$(Q)cp $$(BACKTRACE_BUILD_DIR_$(1))/.libs/libbacktrace.a $$@\n+\n+endif # endif for windowsy\n+endif # endif for darwin\n+\n endef\n \n # Instantiate template for all stages/targets"}, {"sha": "22d686b1b0e24a6ae94f23a65a22d4b9a583f107", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -240,6 +240,7 @@ tidy:\n \t\t| grep '^$(S)src/libuv' -v \\\n \t\t| grep '^$(S)src/llvm' -v \\\n \t\t| grep '^$(S)src/gyp' -v \\\n+\t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n \t\t$(Q)find $(S)src/etc -name '*.py' \\\n \t\t| xargs -n 10 $(CFG_PYTHON) $(S)src/etc/tidy.py\n@@ -266,6 +267,7 @@ tidy:\n \t\t| grep '^$(S)src/etc' -v \\\n \t\t| grep '^$(S)src/doc' -v \\\n \t\t| grep '^$(S)src/compiler-rt' -v \\\n+\t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n \n endif"}, {"sha": "5ad616228e495c5f53118337197e62a42c4049a3", "filename": "src/libbacktrace/ChangeLog", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FChangeLog", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,408 @@\n+2014-02-07  Misty De Meo  <misty@brew.sh>\n+\n+\tPR target/58710\n+\t* configure.ac: Use AC_LINK_IFELSE in check for\n+\t_Unwind_GetIPInfo.\n+\t* configure: Regenerate.\n+\n+2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tUpdate copyright years\n+\n+2013-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* elf.c (ET_DYN): Undefine and define again.\n+\t(elf_add): Add exe argument, if true and ehdr.e_type is ET_DYN,\n+\treturn early -1 without closing the descriptor.\n+\t(struct phdr_data): Add exe_descriptor.\n+\t(phdr_callback): If pd->exe_descriptor is not -1, for very first\n+\tcall if dlpi_name is NULL just call elf_add with the exe_descriptor,\n+\totherwise backtrace_close the exe_descriptor if not -1.  Adjust\n+\tcall to elf_add.\n+\t(backtrace_initialize): Adjust call to elf_add.  If it returns\n+\t-1, set pd.exe_descriptor to descriptor, otherwise set it to -1.\n+\n+2013-12-05  Ian Lance Taylor  <iant@google.com>\n+\n+\t* alloc.c (backtrace_vector_finish): Add error_callback and data\n+\tparameters.  Call backtrace_vector_release.  Return address base.\n+\t* mmap.c (backtrace_vector_finish): Add error_callback and data\n+\tparameters.  Return address base.\n+\t* dwarf.c (read_function_info): Get new address base from\n+\tbacktrace_vector_finish.\n+\t* internal.h (backtrace_vector_finish): Update declaration.\n+\n+2013-11-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (find_address_ranges): New static function, broken out\n+\tof build_address_map.\n+\t(build_address_map): Call it.\n+\t* btest.c (check): Check for missing filename or function, rather\n+\tthan crashing.\n+\t(f3): Check that enough frames were returned.\n+\n+2013-11-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* backtrace.h (backtrace_syminfo_callback): Add symsize argument.\n+\t* elf.c (elf_syminfo): Pass 0 or sym->size to the callback as\n+\tlast argument.\n+\t* btest.c (struct symdata): Add size field.\n+\t(callback_three): Add symsize argument.  Copy it to the data->size\n+\tfield.\n+\t(f23): Set symdata.size to 0.\n+\t(test5): Likewise.  If sizeof (int) > 1, lookup address of\n+\t((uintptr_t) &global) + 1.  Verify symdata.val and symdata.size\n+\tvalues.\n+\n+\t* atomic.c: Include sys/types.h.\n+\n+2013-11-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Check for support of __atomic extensions.\n+\t* internal.h: Declare or #define atomic functions for use in\n+\tbacktrace code.\n+\t* atomic.c: New file.\n+\t* dwarf.c (dwarf_lookup_pc): Use atomic functions.\n+\t(dwarf_fileline, backtrace_dwarf_add): Likewise.\n+\t* elf.c (elf_add_syminfo_data, elf_syminfo): Likewise.\n+\t(backtrace_initialize): Likewise.\n+\t* fileline.c (fileline_initialize): Likewise.\n+\t* Makefile.am (libbacktrace_la_SOURCES): Add atomic.c.\n+\t* configure, config.h.in, Makefile.in: Rebuild.\n+\n+2013-11-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* elf.c (SHN_UNDEF): Define.\n+\t(elf_initialize_syminfo): Add base_address argument.  Ignore symbols\n+\twith st_shndx == SHN_UNDEF.  Add base_address to address fields.\n+\t(elf_add): Adjust caller.\n+\n+\t* elf.c (phdr_callback): Process info->dlpi_addr == 0 normally.\n+\n+2013-11-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* backtrace.h (backtrace_create_state): Correct comment about\n+\tthreading.\n+\n+2013-11-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* backtrace.h (backtrace_syminfo): Update comment and parameter\n+\tname to take any address, not just a PC value.\n+\t* elf.c (STT_OBJECT): Define.\n+\t(elf_nosyms): Rename parameter pc to addr.\n+\t(elf_symbol_search): Rename local variable pc to addr.\n+\t(elf_initialize_syminfo): Add STT_OBJECT symbols to elf_symbols.\n+\t(elf_syminfo): Rename parameter pc to addr.\n+\t* btest.c (global): New global variable.\n+\t(test5): New test.\n+\t(main): Call test5.\n+\n+2013-10-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* elf.c (elf_add): Don't get the wrong offsets if a debug section\n+\tis missing.\n+\n+2013-10-15  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* configure.ac: Add --enable-host-shared, setting up\n+\tpre-existing PIC_FLAG variable within Makefile.am et al.\n+\t* configure: Regenerate.\n+\n+2013-09-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* configure: Regenerate.\n+\n+2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* elf.c (elf_syminfo): Loop over the elf_syminfo_data chain.\n+\n+2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* elf.c (backtrace_initialize): Pass elf_fileline_fn to\n+\tdl_iterate_phdr callbacks.\n+\n+2013-03-25  Ian Lance Taylor  <iant@google.com>\n+\n+\t* alloc.c: #include <sys/types.h>.\n+\t* mmap.c: Likewise.\n+\n+2013-01-31  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_function_info): Permit fvec parameter to be NULL.\n+\t(dwarf_lookup_pc): Don't use ddata->fvec if threaded.\n+\n+2013-01-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/56076\n+\t* dwarf.c (read_line_header): Don't crash if DW_AT_comp_dir\n+\tattribute was not seen.\n+\n+2013-01-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (struct unit): Add filename and abs_filename fields.\n+\t(build_address_map): Set new fields when reading unit.\n+\t(dwarf_lookup_pc): If we don't find an entry in the line table,\n+\tjust return the main file name.\n+\n+2013-01-14  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tUpdate copyright years.\n+\n+2013-01-01  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54834\n+\t* Makefile.am (AM_CPPFLAGS): Remove -I ../gcc/include and -I\n+\t$(MULTIBUILDTOP)/../../gcc/include.\n+\t* Makefile.in: Rebuild.\n+\n+2013-01-01  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/55536\n+\t* mmap.c (backtrace_alloc): Don't call sync functions if not\n+\tthreaded.\n+\t(backtrace_free): Likewise.\n+\n+2012-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* mmapio.c: Define MAP_FAILED if not defined.\n+\n+2012-12-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/54926\n+\t* Makefile.am (AM_CFLAGS): Remove -frandom-seed=$@.\n+\t* configure.ac: If --with-target-subdir, add -frandom-seed=$@\n+\tto EXTRA_FLAGS unconditionally, otherwise check whether the compiler\n+\taccepts it.\n+\t* Makefile.in: Regenerated.\n+\t* configure: Regenerated.\n+\n+2012-12-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/54926\n+\t* Makefile.am (AM_CFLAGS): Add -frandom-seed=$@.\n+\t* Makefile.in: Regenerated.\n+\n+2012-11-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_attribute): Always clear val.\n+\n+2012-11-13  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/55312\n+\t* configure.ac: Only add -Werror if building a target library.\n+\t* configure: Rebuild.\n+\n+2012-11-12  Ian Lance Taylor  <iant@google.com>\n+\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\t    Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* configure.ac: Check for getexecname.\n+\t* fileline.c: #include <errno.h>.  Define getexecname if not\n+\tavailable.\n+\t(fileline_initialize): Try to find the executable in a few\n+\tdifferent ways.\n+\t* print.c (error_callback): Only print the filename if it came\n+\tfrom the backtrace state.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-10-29  Ian Lance Taylor  <iant@google.com>\n+\n+\t* mmap.c (backtrace_vector_release): Correct last patch: add\n+\taligned, not size.\n+\n+2012-10-29  Ian Lance Taylor  <iant@google.com>\n+\n+\t* mmap.c (backtrace_vector_release): Make sure freed block is\n+\taligned on 8-byte boundary.\n+\n+2012-10-26  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/55087\n+\t* posix.c (backtrace_open): Add does_not_exist parameter.\n+\t* elf.c (phdr_callback): Do not warn if shared library could not\n+\tbe opened.\n+\t* fileline.c (fileline_initialize): Update calls to\n+\tbacktrace_open.\n+\t* internal.h (backtrace_open): Update declaration.\n+\n+2012-10-26  Jack Howarth  <howarth@bromo.med.uc.edu>\n+\n+\tPR target/55061\n+\t* configure.ac: Check for _Unwind_GetIPInfo function declaration.\n+\t* configure: Regenerate.\n+\n+2012-10-24  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR target/55061\n+\t* configure.ac: Check whether -funwind-tables option works.\n+\t* configure: Rebuild.\n+\n+2012-10-11  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Do not use dl_iterate_phdr on Solaris 10.\n+\t* configure: Rebuild.\n+\n+2012-10-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* elf.c: Rename all Elf typedefs to start with b_elf, and be all\n+\tlower case.\n+\n+2012-10-10  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* elf.c (elf_add_syminfo_data): Add casts to avoid warning.\n+\n+2012-10-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (dwarf_fileline): Add cast to avoid warning.\n+\t(backtrace_dwarf_add): Likewise.\n+\n+2012-10-09  Ian Lance Taylor  <iant@google.com>\n+\n+\tAdd support for tracing through shared libraries.\n+\t* configure.ac: Check for link.h and dl_iterate_phdr.\n+\t* elf.c: #include <link.h> if system has dl_iterate_phdr.  #undef\n+\tELF macros before #defining them.\n+\t(dl_phdr_info, dl_iterate_phdr): Define if system does not have\n+\tdl_iterate_phdr.\n+\t(struct elf_syminfo_data): Add next field.\n+\t(elf_initialize_syminfo): Initialize next field.\n+\t(elf_add_syminfo_data): New static function.\n+\t(elf_add): New static function, broken out of\n+\tbacktrace_initialize.  Call backtrace_dwarf_add instead of\n+\tbacktrace_dwarf_initialize.\n+\t(struct phdr_data): Define.\n+\t(phdr_callback): New static function.\n+\t(backtrace_initialize): Call elf_add.\n+\t* dwarf.c (struct dwarf_data): Add next and base_address fields.\n+\t(add_unit_addr): Add base_address parameter.  Change all callers.\n+\t(add_unit_ranges, build_address_map): Likewise.\n+\t(add_line): Add ddata parameter.  Change all callers.\n+\t(read_line_program, add_function_range): Likewise.\n+\t(dwarf_lookup_pc): New static function, broken out of\n+\tdwarf_fileline.\n+\t(dwarf_fileline): Call dwarf_lookup_pc.\n+\t(build_dwarf_data): New static function.\n+\t(backtrace_dwarf_add): New function.\n+\t(backtrace_dwarf_initialize): Remove.\n+\t* internal.h (backtrace_dwarf_initialize): Don't declare.\n+\t(backtrace_dwarf_add): Declare.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-10-04  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* btest.c (f23): Avoid uninitialized variable warning.\n+\n+2012-10-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c: If the system header files do not declare strnlen,\n+\tprovide our own version.\n+\n+2012-10-03  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_uleb128): Fix overflow test.\n+\t(read_sleb128): Likewise.\n+\t(build_address_map): Don't change unit_buf.start.\n+\n+2012-10-02  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR other/54761\n+\t* configure.ac (EXTRA_FLAGS): New.\n+\t* Makefile.am (AM_FLAGS): Add $(EXTRA_FLAGS).\n+\t* configure, Makefile.in: Regenerate.\n+\n+2012-09-29  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/54749\n+\t* fileline.c (fileline_initialize): Pass errnum as -1 when\n+\treporting that we could not read executable information after a\n+\tprevious failure.\n+\n+2012-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54732\n+\t* configure.ac: Add no-dependencies to AM_INIT_AUTOMAKE.\n+\t* Makefile.am: Add dependencies for all objects.\n+\t* configure, aclocal.m4, Makefile.in: Rebuild.\n+\n+2012-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/54726\n+\t* elf.c (backtrace_initialize): Set *fileln_fn, not\n+\tstate->fileln_fn.\n+\n+2012-09-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Only use GCC_CHECK_UNWIND_GETIPINFO when compiled\n+\tas a target library.\n+\t* configure: Rebuild.\n+\n+2012-09-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\t    Ian Lance Taylor  <iant@google.com>\n+\n+        * configure.ac (GCC_HEADER_STDINT): Invoke.\n+        * backtrace.h: If we can't find <stdint.h>, use \"gstdint.h\".\n+        * btest.c: Don't include <stdint.h>.\n+        * dwarf.c: Likewise.\n+        * configure, aclocal.m4, Makefile.in, config.h.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54623\n+\t* Makefile.am (AM_CPPFLAGS): Define.\n+\t(AM_CFLAGS): Remove -I options.\n+\t* Makefile.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* posix.c (O_BINARY): Define if not defined.\n+\t(backtrace_open): Pass O_BINARY to open.  Only call fcntl if\n+\tHAVE_FCNTL is defined.\n+\t* configure.ac: Test for the fcntl function.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* btest.c (test1, test2, test3, test4): Add the unused attribute.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c: Correct test of HAVE_DECL_STRNLEN.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Add AC_USE_SYSTEM_EXTENSIONS.\n+\t* mmapio.c: Don't define _GNU_SOURCE.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Check whether strnlen is declared.\n+\t* dwarf.c: Declare strnlen if not declared.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-09-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* fileline.c: Include <stdlib.h>.\n+\t* mmap.c: Likewise.\n+\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54611\n+\t* nounwind.c (backtrace_full): Rename from backtrace.  Add state\n+\tparameter.\n+\n+2012-09-17  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\tPR bootstrap/54611\n+\t* nounwind.c (backtrace_simple): Add state parameter.\n+\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54609\n+\t* unknown.c (unknown_fileline): Add state parameter, remove\n+\tfileline_data parameter, name error_callback parameter.\n+\t(backtrace_initialize): Add state parameter.\n+\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Initial implementation."}, {"sha": "6add85d7341513eddaa249f477fc51e3799343b7", "filename": "src/libbacktrace/Makefile.am", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.am?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,126 @@\n+# Makefile.am -- Backtrace Makefile.\n+# Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer. \n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.  \n+\n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+AM_CPPFLAGS = -I $(top_srcdir)/../include -I $(top_srcdir)/../libgcc \\\n+\t-I ../libgcc\n+\n+AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG)\n+\n+noinst_LTLIBRARIES = libbacktrace.la\n+\n+libbacktrace_la_SOURCES = \\\n+\tbacktrace.h \\\n+\tatomic.c \\\n+\tdwarf.c \\\n+\tfileline.c \\\n+\tinternal.h \\\n+\tposix.c \\\n+\tprint.c \\\n+\tstate.c\n+\n+BACKTRACE_FILES = \\\n+\tbacktrace.c \\\n+\tsimple.c \\\n+\tnounwind.c\n+\n+FORMAT_FILES = \\\n+\telf.c \\\n+\tunknown.c\n+\n+VIEW_FILES = \\\n+\tread.c \\\n+\tmmapio.c\n+\n+ALLOC_FILES = \\\n+\talloc.c \\\n+\tmmap.c\n+\n+EXTRA_libbacktrace_la_SOURCES = \\\n+\t$(BACKTRACE_FILES) \\\n+\t$(FORMAT_FILES) \\\n+\t$(VIEW_FILES) \\\n+\t$(ALLOC_FILES)\n+\n+libbacktrace_la_LIBADD = \\\n+\t$(BACKTRACE_FILE) \\\n+\t$(FORMAT_FILE) \\\n+\t$(VIEW_FILE) \\\n+\t$(ALLOC_FILE)\n+\n+libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n+\n+# Testsuite.\n+\n+check_PROGRAMS =\n+\n+TESTS = $(check_PROGRAMS)\n+\n+if NATIVE\n+\n+btest_SOURCES = btest.c\n+btest_CFLAGS = $(AM_CFLAGS) -g -O\n+btest_LDADD = libbacktrace.la\n+\n+check_PROGRAMS += btest\n+\n+endif NATIVE\n+\n+# We can't use automake's automatic dependency tracking, because it\n+# breaks when using bootstrap-lean.  Automatic dependency tracking\n+# with GCC bootstrap will cause some of the objects to depend on\n+# header files in prev-gcc/include, e.g., stddef.h and stdarg.h.  When\n+# using bootstrap-lean, prev-gcc is removed after each stage.  When\n+# running \"make install\", those header files will be gone, causing the\n+# library to be rebuilt at install time.  That may not succeed.\n+\n+# These manual dependencies do not include dependencies on unwind.h,\n+# even though that is part of GCC, because where to find it depends on\n+# whether we are being built as a host library or a target library.\n+\n+INCDIR = $(top_srcdir)/../include\n+alloc.lo: config.h backtrace.h internal.h\n+backtrace.lo: config.h backtrace.h\n+btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n+dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n+\t$(INCDIR)/filenames.h backtrace.h internal.h\n+elf.lo: config.h backtrace.h internal.h\n+fileline.lo: config.h backtrace.h internal.h\n+mmap.lo: config.h backtrace.h internal.h\n+mmapio.lo: config.h backtrace.h internal.h\n+nounwind.lo: config.h internal.h\n+posix.lo: config.h backtrace.h internal.h\n+print.lo: config.h backtrace.h internal.h\n+read.lo: config.h backtrace.h internal.h\n+simple.lo: config.h backtrace.h internal.h\n+state.lo: config.h backtrace.h backtrace-supported.h internal.h\n+unknown.lo: config.h backtrace.h internal.h"}, {"sha": "18c1ecaca545fc1274ecdd967035143738ec32ee", "filename": "src/libbacktrace/Makefile.in", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.in?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,730 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+# Makefile.am -- Backtrace Makefile.\n+# Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer. \n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.  \n+\n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+check_PROGRAMS = $(am__EXEEXT_1)\n+@NATIVE_TRUE@am__append_1 = btest\n+subdir = .\n+DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n+\t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n+\t$(am__configure_deps) $(srcdir)/config.h.in \\\n+\t$(srcdir)/../mkinstalldirs $(srcdir)/backtrace-supported.h.in\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../config/stdint.m4 \\\n+\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n+\t$(top_srcdir)/../config/warnings.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n+\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n+\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = config.h\n+CONFIG_CLEAN_FILES = backtrace-supported.h\n+CONFIG_CLEAN_VPATH_FILES =\n+LTLIBRARIES = $(noinst_LTLIBRARIES)\n+am__DEPENDENCIES_1 =\n+am_libbacktrace_la_OBJECTS = atomic.lo dwarf.lo fileline.lo posix.lo \\\n+\tprint.lo state.lo\n+libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n+@NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT)\n+@NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT)\n+btest_OBJECTS = $(am_btest_OBJECTS)\n+@NATIVE_TRUE@btest_DEPENDENCIES = libbacktrace.la\n+btest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(btest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp =\n+am__depfiles_maybe =\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n+\t$(btest_SOURCES)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+ETAGS = etags\n+CTAGS = ctags\n+am__tty_colors = \\\n+red=; grn=; lgn=; blu=; std=\n+ACLOCAL = @ACLOCAL@\n+ALLOC_FILE = @ALLOC_FILE@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+BACKTRACE_FILE = @BACKTRACE_FILE@\n+BACKTRACE_SUPPORTED = @BACKTRACE_SUPPORTED@\n+BACKTRACE_SUPPORTS_THREADS = @BACKTRACE_SUPPORTS_THREADS@\n+BACKTRACE_USES_MALLOC = @BACKTRACE_USES_MALLOC@\n+CC = @CC@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+EXTRA_FLAGS = @EXTRA_FLAGS@\n+FGREP = @FGREP@\n+FORMAT_FILE = @FORMAT_FILE@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PIC_FLAG = @PIC_FLAG@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+VIEW_FILE = @VIEW_FILE@\n+WARN_FLAGS = @WARN_FLAGS@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__leading_dot = @am__leading_dot@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+AM_CPPFLAGS = -I $(top_srcdir)/../include -I $(top_srcdir)/../libgcc \\\n+\t-I ../libgcc\n+\n+AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG)\n+noinst_LTLIBRARIES = libbacktrace.la\n+libbacktrace_la_SOURCES = \\\n+\tbacktrace.h \\\n+\tatomic.c \\\n+\tdwarf.c \\\n+\tfileline.c \\\n+\tinternal.h \\\n+\tposix.c \\\n+\tprint.c \\\n+\tstate.c\n+\n+BACKTRACE_FILES = \\\n+\tbacktrace.c \\\n+\tsimple.c \\\n+\tnounwind.c\n+\n+FORMAT_FILES = \\\n+\telf.c \\\n+\tunknown.c\n+\n+VIEW_FILES = \\\n+\tread.c \\\n+\tmmapio.c\n+\n+ALLOC_FILES = \\\n+\talloc.c \\\n+\tmmap.c\n+\n+EXTRA_libbacktrace_la_SOURCES = \\\n+\t$(BACKTRACE_FILES) \\\n+\t$(FORMAT_FILES) \\\n+\t$(VIEW_FILES) \\\n+\t$(ALLOC_FILES)\n+\n+libbacktrace_la_LIBADD = \\\n+\t$(BACKTRACE_FILE) \\\n+\t$(FORMAT_FILE) \\\n+\t$(VIEW_FILE) \\\n+\t$(ALLOC_FILE)\n+\n+libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n+TESTS = $(check_PROGRAMS)\n+@NATIVE_TRUE@btest_SOURCES = btest.c\n+@NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n+@NATIVE_TRUE@btest_LDADD = libbacktrace.la\n+\n+# We can't use automake's automatic dependency tracking, because it\n+# breaks when using bootstrap-lean.  Automatic dependency tracking\n+# with GCC bootstrap will cause some of the objects to depend on\n+# header files in prev-gcc/include, e.g., stddef.h and stdarg.h.  When\n+# using bootstrap-lean, prev-gcc is removed after each stage.  When\n+# running \"make install\", those header files will be gone, causing the\n+# library to be rebuilt at install time.  That may not succeed.\n+\n+# These manual dependencies do not include dependencies on unwind.h,\n+# even though that is part of GCC, because where to find it depends on\n+# whether we are being built as a host library or a target library.\n+INCDIR = $(top_srcdir)/../include\n+all: config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign --ignore-deps'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign --ignore-deps \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign --ignore-deps Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+\n+config.h: stamp-h1\n+\t@if test ! -f $@; then \\\n+\t  rm -f stamp-h1; \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n+\telse :; fi\n+\n+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n+\t@rm -f stamp-h1\n+\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n+\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n+\trm -f stamp-h1\n+\ttouch $@\n+\n+distclean-hdr:\n+\t-rm -f config.h stamp-h1\n+backtrace-supported.h: $(top_builddir)/config.status $(srcdir)/backtrace-supported.h.in\n+\tcd $(top_builddir) && $(SHELL) ./config.status $@\n+\n+clean-noinstLTLIBRARIES:\n+\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n+\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) \n+\t$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)\n+\n+clean-checkPROGRAMS:\n+\t@list='$(check_PROGRAMS)'; test -n \"$$list\" || exit 0; \\\n+\techo \" rm -f\" $$list; \\\n+\trm -f $$list || exit $$?; \\\n+\ttest -n \"$(EXEEXT)\" || exit 0; \\\n+\tlist=`for p in $$list; do echo \"$$p\"; done | sed 's/$(EXEEXT)$$//'`; \\\n+\techo \" rm -f\" $$list; \\\n+\trm -f $$list\n+btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) \n+\t@rm -f btest$(EXEEXT)\n+\t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+.c.o:\n+\t$(COMPILE) -c $<\n+\n+.c.obj:\n+\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+\t$(LTCOMPILE) -c -o $@ $<\n+\n+btest-btest.o: btest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n+\n+btest-btest.obj: btest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+check-TESTS: $(TESTS)\n+\t@failed=0; all=0; xfail=0; xpass=0; skip=0; \\\n+\tsrcdir=$(srcdir); export srcdir; \\\n+\tlist=' $(TESTS) '; \\\n+\t$(am__tty_colors); \\\n+\tif test -n \"$$list\"; then \\\n+\t  for tst in $$list; do \\\n+\t    if test -f ./$$tst; then dir=./; \\\n+\t    elif test -f $$tst; then dir=; \\\n+\t    else dir=\"$(srcdir)/\"; fi; \\\n+\t    if $(TESTS_ENVIRONMENT) $${dir}$$tst; then \\\n+\t      all=`expr $$all + 1`; \\\n+\t      case \" $(XFAIL_TESTS) \" in \\\n+\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n+\t\txpass=`expr $$xpass + 1`; \\\n+\t\tfailed=`expr $$failed + 1`; \\\n+\t\tcol=$$red; res=XPASS; \\\n+\t      ;; \\\n+\t      *) \\\n+\t\tcol=$$grn; res=PASS; \\\n+\t      ;; \\\n+\t      esac; \\\n+\t    elif test $$? -ne 77; then \\\n+\t      all=`expr $$all + 1`; \\\n+\t      case \" $(XFAIL_TESTS) \" in \\\n+\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n+\t\txfail=`expr $$xfail + 1`; \\\n+\t\tcol=$$lgn; res=XFAIL; \\\n+\t      ;; \\\n+\t      *) \\\n+\t\tfailed=`expr $$failed + 1`; \\\n+\t\tcol=$$red; res=FAIL; \\\n+\t      ;; \\\n+\t      esac; \\\n+\t    else \\\n+\t      skip=`expr $$skip + 1`; \\\n+\t      col=$$blu; res=SKIP; \\\n+\t    fi; \\\n+\t    echo \"$${col}$$res$${std}: $$tst\"; \\\n+\t  done; \\\n+\t  if test \"$$all\" -eq 1; then \\\n+\t    tests=\"test\"; \\\n+\t    All=\"\"; \\\n+\t  else \\\n+\t    tests=\"tests\"; \\\n+\t    All=\"All \"; \\\n+\t  fi; \\\n+\t  if test \"$$failed\" -eq 0; then \\\n+\t    if test \"$$xfail\" -eq 0; then \\\n+\t      banner=\"$$All$$all $$tests passed\"; \\\n+\t    else \\\n+\t      if test \"$$xfail\" -eq 1; then failures=failure; else failures=failures; fi; \\\n+\t      banner=\"$$All$$all $$tests behaved as expected ($$xfail expected $$failures)\"; \\\n+\t    fi; \\\n+\t  else \\\n+\t    if test \"$$xpass\" -eq 0; then \\\n+\t      banner=\"$$failed of $$all $$tests failed\"; \\\n+\t    else \\\n+\t      if test \"$$xpass\" -eq 1; then passes=pass; else passes=passes; fi; \\\n+\t      banner=\"$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)\"; \\\n+\t    fi; \\\n+\t  fi; \\\n+\t  dashes=\"$$banner\"; \\\n+\t  skipped=\"\"; \\\n+\t  if test \"$$skip\" -ne 0; then \\\n+\t    if test \"$$skip\" -eq 1; then \\\n+\t      skipped=\"($$skip test was not run)\"; \\\n+\t    else \\\n+\t      skipped=\"($$skip tests were not run)\"; \\\n+\t    fi; \\\n+\t    test `echo \"$$skipped\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n+\t      dashes=\"$$skipped\"; \\\n+\t  fi; \\\n+\t  report=\"\"; \\\n+\t  if test \"$$failed\" -ne 0 && test -n \"$(PACKAGE_BUGREPORT)\"; then \\\n+\t    report=\"Please report to $(PACKAGE_BUGREPORT)\"; \\\n+\t    test `echo \"$$report\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n+\t      dashes=\"$$report\"; \\\n+\t  fi; \\\n+\t  dashes=`echo \"$$dashes\" | sed s/./=/g`; \\\n+\t  if test \"$$failed\" -eq 0; then \\\n+\t    echo \"$$grn$$dashes\"; \\\n+\t  else \\\n+\t    echo \"$$red$$dashes\"; \\\n+\t  fi; \\\n+\t  echo \"$$banner\"; \\\n+\t  test -z \"$$skipped\" || echo \"$$skipped\"; \\\n+\t  test -z \"$$report\" || echo \"$$report\"; \\\n+\t  echo \"$$dashes$$std\"; \\\n+\t  test \"$$failed\" -eq 0; \\\n+\telse :; fi\n+check-am: all-am\n+\t$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)\n+\t$(MAKE) $(AM_MAKEFLAGS) check-TESTS\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES) all-multi config.h\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am clean-multi\n+\n+clean-am: clean-checkPROGRAMS clean-generic clean-libtool \\\n+\tclean-noinstLTLIBRARIES mostlyclean-am\n+\n+distclean: distclean-am distclean-multi\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-multi\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am maintainer-clean-multi\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am mostlyclean-multi\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: all all-multi check-am clean-multi distclean-multi install-am \\\n+\tinstall-multi install-strip maintainer-clean-multi \\\n+\tmostlyclean-multi\n+\n+.PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-TESTS \\\n+\tcheck-am clean clean-checkPROGRAMS clean-generic clean-libtool \\\n+\tclean-multi clean-noinstLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-hdr \\\n+\tdistclean-libtool distclean-multi distclean-tags dvi dvi-am \\\n+\thtml html-am info info-am install install-am install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-multi install-pdf \\\n+\tinstall-pdf-am install-ps install-ps-am install-strip \\\n+\tinstallcheck installcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tmostlyclean-multi pdf pdf-am ps ps-am tags uninstall \\\n+\tuninstall-am\n+\n+alloc.lo: config.h backtrace.h internal.h\n+backtrace.lo: config.h backtrace.h\n+btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n+dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n+\t$(INCDIR)/filenames.h backtrace.h internal.h\n+elf.lo: config.h backtrace.h internal.h\n+fileline.lo: config.h backtrace.h internal.h\n+mmap.lo: config.h backtrace.h internal.h\n+mmapio.lo: config.h backtrace.h internal.h\n+nounwind.lo: config.h internal.h\n+posix.lo: config.h backtrace.h internal.h\n+print.lo: config.h backtrace.h internal.h\n+read.lo: config.h backtrace.h internal.h\n+simple.lo: config.h backtrace.h internal.h\n+state.lo: config.h backtrace.h backtrace-supported.h internal.h\n+unknown.lo: config.h backtrace.h internal.h\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "e8b225745c9c639e67ea4f6fa0f97041ba978276", "filename": "src/libbacktrace/README", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FREADME?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,23 @@\n+The libbacktrace library\n+Initially written by Ian Lance Taylor <iant@google.com>\n+\n+The libbacktrace library may be linked into a program or library and\n+used to produce symbolic backtraces.  Sample uses would be to print a\n+detailed backtrace when an error occurs or to gather detailed\n+profiling information.\n+\n+The libbacktrace library is provided under a BSD license.  See the\n+source files for the exact license text.\n+\n+The public functions are declared and documented in the header file\n+backtrace.h, which should be #include'd by a user of the library.\n+\n+Building libbacktrace will generate a file backtrace-supported.h,\n+which a user of the library may use to determine whether backtraces\n+will work.  See the source file backtrace-supported.h.in for the\n+macros that it defines.\n+\n+As of September 2012, libbacktrace only supports ELF executables with\n+DWARF debugging information.  The library is written to make it\n+straightforward to add support for other object file and debugging\n+formats."}, {"sha": "42214c2233ac87437820fa06383933884281d3c4", "filename": "src/libbacktrace/aclocal.m4", "status": "added", "additions": 667, "deletions": 0, "changes": 667, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Faclocal.m4?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,667 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless `enable' is passed literally.\n+# For symmetry, `disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n+\t\t\t  (and sometimes confusing) to the casual installer],\n+      [USE_MAINTAINER_MODE=$enableval],\n+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../config/stdint.m4])\n+m4_include([../config/unwind_ipinfo.m4])\n+m4_include([../config/warnings.m4])\n+m4_include([../libtool.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])"}, {"sha": "37eca65349ee10a409af63e45e8740492cdd3e1a", "filename": "src/libbacktrace/alloc.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Falloc.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Falloc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Falloc.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,152 @@\n+/* alloc.c -- Memory allocation without mmap.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Allocation routines to use on systems that do not support anonymous\n+   mmap.  This implementation just uses malloc, which means that the\n+   backtrace functions may not be safely invoked from a signal\n+   handler.  */\n+\n+/* Allocate memory like malloc.  */\n+\n+void *\n+backtrace_alloc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t size_t size, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  void *ret;\n+\n+  ret = malloc (size);\n+  if (ret == NULL)\n+    error_callback (data, \"malloc\", errno);\n+  return ret;\n+}\n+\n+/* Free memory.  */\n+\n+void\n+backtrace_free (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\tvoid *p, size_t size ATTRIBUTE_UNUSED,\n+\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  free (p);\n+}\n+\n+/* Grow VEC by SIZE bytes.  */\n+\n+void *\n+backtrace_vector_grow (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t       size_t size, backtrace_error_callback error_callback,\n+\t\t       void *data, struct backtrace_vector *vec)\n+{\n+  void *ret;\n+\n+  if (size > vec->alc)\n+    {\n+      size_t alc;\n+      void *base;\n+\n+      if (vec->size == 0)\n+\talc = 32 * size;\n+      else if (vec->size >= 4096)\n+\talc = vec->size + 4096;\n+      else\n+\talc = 2 * vec->size;\n+\n+      if (alc < vec->size + size)\n+\talc = vec->size + size;\n+\n+      base = realloc (vec->base, alc);\n+      if (base == NULL)\n+\t{\n+\t  error_callback (data, \"realloc\", errno);\n+\t  return NULL;\n+\t}\n+\n+      vec->base = base;\n+      vec->alc = alc - vec->size;\n+    }\n+\n+  ret = (char *) vec->base + vec->size;\n+  vec->size += size;\n+  vec->alc -= size;\n+  return ret;\n+}\n+\n+/* Finish the current allocation on VEC.  */\n+\n+void *\n+backtrace_vector_finish (struct backtrace_state *state,\n+\t\t\t struct backtrace_vector *vec,\n+\t\t\t backtrace_error_callback error_callback,\n+\t\t\t void *data)\n+{\n+  void *ret;\n+\n+  /* With this allocator we call realloc in backtrace_vector_grow,\n+     which means we can't easily reuse the memory here.  So just\n+     release it.  */\n+  if (!backtrace_vector_release (state, vec, error_callback, data))\n+    return NULL;\n+  ret = vec->base;\n+  vec->base = NULL;\n+  vec->size = 0;\n+  vec->alc = 0;\n+  return ret;\n+}\n+\n+/* Release any extra space allocated for VEC.  */\n+\n+int\n+backtrace_vector_release (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\t  struct backtrace_vector *vec,\n+\t\t\t  backtrace_error_callback error_callback,\n+\t\t\t  void *data)\n+{\n+  vec->base = realloc (vec->base, vec->size);\n+  if (vec->base == NULL)\n+    {\n+      error_callback (data, \"realloc\", errno);\n+      return 0;\n+    }\n+  vec->alc = 0;\n+  return 1;\n+}"}, {"sha": "0fb23bba792dbb30d852723b9ac9a5d337e3aedc", "filename": "src/libbacktrace/ansidecl.h", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fansidecl.h", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fansidecl.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fansidecl.h?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,313 @@\n+/* ANSI and traditional C compatability macros\n+   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,\n+   2002, 2003, 2004, 2005, 2006, 2007, 2009, 2010, 2013\n+   Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+/* ANSI and traditional C compatibility macros\n+\n+   ANSI C is assumed if __STDC__ is #defined.\n+\n+   Macro\t\tANSI C definition\tTraditional C definition\n+   -----\t\t---- - ----------\t----------- - ----------\n+   PTR\t\t\t`void *'\t\t`char *'\n+   const\t\tnot defined\t\t`'\n+   volatile\t\tnot defined\t\t`'\n+   signed\t\tnot defined\t\t`'\n+\n+   For ease of writing code which uses GCC extensions but needs to be\n+   portable to other compilers, we provide the GCC_VERSION macro that\n+   simplifies testing __GNUC__ and __GNUC_MINOR__ together, and various\n+   wrappers around __attribute__.  Also, __extension__ will be #defined\n+   to nothing if it doesn't work.  See below.  */\n+\n+#ifndef\t_ANSIDECL_H\n+#define _ANSIDECL_H\t1\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Every source file includes this file,\n+   so they will all get the switch for lint.  */\n+/* LINTLIBRARY */\n+\n+/* Using MACRO(x,y) in cpp #if conditionals does not work with some\n+   older preprocessors.  Thus we can't define something like this:\n+\n+#define HAVE_GCC_VERSION(MAJOR, MINOR) \\\n+  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))\n+\n+and then test \"#if HAVE_GCC_VERSION(2,7)\".\n+\n+So instead we use the macro below and test it against specific values.  */\n+\n+/* This macro simplifies testing whether we are using gcc, and if it\n+   is of a particular minimum version. (Both major & minor numbers are\n+   significant.)  This macro will evaluate to 0 if we are not using\n+   gcc at all.  */\n+#ifndef GCC_VERSION\n+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif /* GCC_VERSION */\n+\n+#if defined (__STDC__) || defined(__cplusplus) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)\n+/* All known AIX compilers implement these things (but don't always\n+   define __STDC__).  The RISC/OS MIPS compiler defines these things\n+   in SVR4 mode, but does not define __STDC__.  */\n+/* eraxxon@alumni.rice.edu: The Compaq C++ compiler, unlike many other\n+   C++ compilers, does not define __STDC__, though it acts as if this\n+   was so. (Verified versions: 5.7, 6.2, 6.3, 6.5) */\n+\n+#define PTR\t\tvoid *\n+\n+#undef const\n+#undef volatile\n+#undef signed\n+\n+/* inline requires special treatment; it's in C99, and GCC >=2.7 supports\n+   it too, but it's not in C89.  */\n+#undef inline\n+#if __STDC_VERSION__ >= 199901L || defined(__cplusplus) || (defined(__SUNPRO_C) && defined(__C99FEATURES__))\n+/* it's a keyword */\n+#else\n+# if GCC_VERSION >= 2007\n+#  define inline __inline__   /* __inline__ prevents -pedantic warnings */\n+# else\n+#  define inline  /* nothing */\n+# endif\n+#endif\n+\n+#else\t/* Not ANSI C.  */\n+\n+#define PTR\t\tchar *\n+\n+/* some systems define these in header files for non-ansi mode */\n+#undef const\n+#undef volatile\n+#undef signed\n+#undef inline\n+#define const\n+#define volatile\n+#define signed\n+#define inline\n+\n+#endif\t/* ANSI C.  */\n+\n+/* Define macros for some gcc attributes.  This permits us to use the\n+   macros freely, and know that they will come into play for the\n+   version of gcc in which they are supported.  */\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+/* Attribute __malloc__ on functions was valid as of gcc 2.96. */\n+#ifndef ATTRIBUTE_MALLOC\n+# if (GCC_VERSION >= 2096)\n+#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n+# else\n+#  define ATTRIBUTE_MALLOC\n+# endif /* GNUC >= 2.96 */\n+#endif /* ATTRIBUTE_MALLOC */\n+\n+/* Attributes on labels were valid as of gcc 2.93 and g++ 4.5.  For\n+   g++ an attribute on a label must be followed by a semicolon.  */\n+#ifndef ATTRIBUTE_UNUSED_LABEL\n+# ifndef __cplusplus\n+#  if GCC_VERSION >= 2093\n+#   define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED\n+#  else\n+#   define ATTRIBUTE_UNUSED_LABEL\n+#  endif\n+# else\n+#  if GCC_VERSION >= 4005\n+#   define ATTRIBUTE_UNUSED_LABEL ATTRIBUTE_UNUSED ;\n+#  else\n+#   define ATTRIBUTE_UNUSED_LABEL\n+#  endif\n+# endif\n+#endif\n+\n+/* Similarly to ARG_UNUSED below.  Prior to GCC 3.4, the C++ frontend\n+   couldn't parse attributes placed after the identifier name, and now\n+   the entire compiler is built with C++.  */\n+#ifndef ATTRIBUTE_UNUSED\n+#if GCC_VERSION >= 3004\n+#  define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+#endif /* ATTRIBUTE_UNUSED */\n+\n+/* Before GCC 3.4, the C++ frontend couldn't parse attributes placed after the\n+   identifier name.  */\n+#if ! defined(__cplusplus) || (GCC_VERSION >= 3004)\n+# define ARG_UNUSED(NAME) NAME ATTRIBUTE_UNUSED\n+#else /* !__cplusplus || GNUC >= 3.4 */\n+# define ARG_UNUSED(NAME) NAME\n+#endif /* !__cplusplus || GNUC >= 3.4 */\n+\n+#ifndef ATTRIBUTE_NORETURN\n+#define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))\n+#endif /* ATTRIBUTE_NORETURN */\n+\n+/* Attribute `nonnull' was valid as of gcc 3.3.  */\n+#ifndef ATTRIBUTE_NONNULL\n+# if (GCC_VERSION >= 3003)\n+#  define ATTRIBUTE_NONNULL(m) __attribute__ ((__nonnull__ (m)))\n+# else\n+#  define ATTRIBUTE_NONNULL(m)\n+# endif /* GNUC >= 3.3 */\n+#endif /* ATTRIBUTE_NONNULL */\n+\n+/* Attribute `returns_nonnull' was valid as of gcc 4.9.  */\n+#ifndef ATTRIBUTE_RETURNS_NONNULL\n+# if (GCC_VERSION >= 4009)\n+#  define ATTRIBUTE_RETURNS_NONNULL __attribute__ ((__returns_nonnull__))\n+# else\n+#  define ATTRIBUTE_RETURNS_NONNULL\n+# endif /* GNUC >= 4.9 */\n+#endif /* ATTRIBUTE_RETURNS_NONNULL */\n+\n+/* Attribute `pure' was valid as of gcc 3.0.  */\n+#ifndef ATTRIBUTE_PURE\n+# if (GCC_VERSION >= 3000)\n+#  define ATTRIBUTE_PURE __attribute__ ((__pure__))\n+# else\n+#  define ATTRIBUTE_PURE\n+# endif /* GNUC >= 3.0 */\n+#endif /* ATTRIBUTE_PURE */\n+\n+/* Use ATTRIBUTE_PRINTF when the format specifier must not be NULL.\n+   This was the case for the `printf' format attribute by itself\n+   before GCC 3.3, but as of 3.3 we need to add the `nonnull'\n+   attribute to retain this behavior.  */\n+#ifndef ATTRIBUTE_PRINTF\n+#define ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n))) ATTRIBUTE_NONNULL(m)\n+#define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)\n+#define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)\n+#define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)\n+#define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)\n+#define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)\n+#endif /* ATTRIBUTE_PRINTF */\n+\n+/* Use ATTRIBUTE_FPTR_PRINTF when the format attribute is to be set on\n+   a function pointer.  Format attributes were allowed on function\n+   pointers as of gcc 3.1.  */\n+#ifndef ATTRIBUTE_FPTR_PRINTF\n+# if (GCC_VERSION >= 3001)\n+#  define ATTRIBUTE_FPTR_PRINTF(m, n) ATTRIBUTE_PRINTF(m, n)\n+# else\n+#  define ATTRIBUTE_FPTR_PRINTF(m, n)\n+# endif /* GNUC >= 3.1 */\n+# define ATTRIBUTE_FPTR_PRINTF_1 ATTRIBUTE_FPTR_PRINTF(1, 2)\n+# define ATTRIBUTE_FPTR_PRINTF_2 ATTRIBUTE_FPTR_PRINTF(2, 3)\n+# define ATTRIBUTE_FPTR_PRINTF_3 ATTRIBUTE_FPTR_PRINTF(3, 4)\n+# define ATTRIBUTE_FPTR_PRINTF_4 ATTRIBUTE_FPTR_PRINTF(4, 5)\n+# define ATTRIBUTE_FPTR_PRINTF_5 ATTRIBUTE_FPTR_PRINTF(5, 6)\n+#endif /* ATTRIBUTE_FPTR_PRINTF */\n+\n+/* Use ATTRIBUTE_NULL_PRINTF when the format specifier may be NULL.  A\n+   NULL format specifier was allowed as of gcc 3.3.  */\n+#ifndef ATTRIBUTE_NULL_PRINTF\n+# if (GCC_VERSION >= 3003)\n+#  define ATTRIBUTE_NULL_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n)))\n+# else\n+#  define ATTRIBUTE_NULL_PRINTF(m, n)\n+# endif /* GNUC >= 3.3 */\n+# define ATTRIBUTE_NULL_PRINTF_1 ATTRIBUTE_NULL_PRINTF(1, 2)\n+# define ATTRIBUTE_NULL_PRINTF_2 ATTRIBUTE_NULL_PRINTF(2, 3)\n+# define ATTRIBUTE_NULL_PRINTF_3 ATTRIBUTE_NULL_PRINTF(3, 4)\n+# define ATTRIBUTE_NULL_PRINTF_4 ATTRIBUTE_NULL_PRINTF(4, 5)\n+# define ATTRIBUTE_NULL_PRINTF_5 ATTRIBUTE_NULL_PRINTF(5, 6)\n+#endif /* ATTRIBUTE_NULL_PRINTF */\n+\n+/* Attribute `sentinel' was valid as of gcc 3.5.  */\n+#ifndef ATTRIBUTE_SENTINEL\n+# if (GCC_VERSION >= 3005)\n+#  define ATTRIBUTE_SENTINEL __attribute__ ((__sentinel__))\n+# else\n+#  define ATTRIBUTE_SENTINEL\n+# endif /* GNUC >= 3.5 */\n+#endif /* ATTRIBUTE_SENTINEL */\n+\n+\n+#ifndef ATTRIBUTE_ALIGNED_ALIGNOF\n+# if (GCC_VERSION >= 3000)\n+#  define ATTRIBUTE_ALIGNED_ALIGNOF(m) __attribute__ ((__aligned__ (__alignof__ (m))))\n+# else\n+#  define ATTRIBUTE_ALIGNED_ALIGNOF(m)\n+# endif /* GNUC >= 3.0 */\n+#endif /* ATTRIBUTE_ALIGNED_ALIGNOF */\n+\n+/* Useful for structures whose layout must much some binary specification\n+   regardless of the alignment and padding qualities of the compiler.  */\n+#ifndef ATTRIBUTE_PACKED\n+# define ATTRIBUTE_PACKED __attribute__ ((packed))\n+#endif\n+\n+/* Attribute `hot' and `cold' was valid as of gcc 4.3.  */\n+#ifndef ATTRIBUTE_COLD\n+# if (GCC_VERSION >= 4003)\n+#  define ATTRIBUTE_COLD __attribute__ ((__cold__))\n+# else\n+#  define ATTRIBUTE_COLD\n+# endif /* GNUC >= 4.3 */\n+#endif /* ATTRIBUTE_COLD */\n+#ifndef ATTRIBUTE_HOT\n+# if (GCC_VERSION >= 4003)\n+#  define ATTRIBUTE_HOT __attribute__ ((__hot__))\n+# else\n+#  define ATTRIBUTE_HOT\n+# endif /* GNUC >= 4.3 */\n+#endif /* ATTRIBUTE_HOT */\n+\n+/* We use __extension__ in some places to suppress -pedantic warnings\n+   about GCC extensions.  This feature didn't work properly before\n+   gcc 2.8.  */\n+#if GCC_VERSION < 2008\n+#define __extension__\n+#endif\n+\n+/* This is used to declare a const variable which should be visible\n+   outside of the current compilation unit.  Use it as\n+     EXPORTED_CONST int i = 1;\n+   This is because the semantics of const are different in C and C++.\n+   \"extern const\" is permitted in C but it looks strange, and gcc\n+   warns about it when -Wc++-compat is not used.  */\n+#ifdef __cplusplus\n+#define EXPORTED_CONST extern const\n+#else\n+#define EXPORTED_CONST const\n+#endif\n+\n+/* Be conservative and only use enum bitfields with C++ or GCC.\n+   FIXME: provide a complete autoconf test for buggy enum bitfields.  */\n+\n+#ifdef __cplusplus\n+#define ENUM_BITFIELD(TYPE) enum TYPE\n+#elif (GCC_VERSION > 2000)\n+#define ENUM_BITFIELD(TYPE) __extension__ enum TYPE\n+#else\n+#define ENUM_BITFIELD(TYPE) unsigned int\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\t/* ansidecl.h\t*/"}, {"sha": "f139d74aa5f373fa54a646792c3a772f9db48b55", "filename": "src/libbacktrace/atomic.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fatomic.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fatomic.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fatomic.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,113 @@\n+/* atomic.c -- Support for atomic functions if not present.\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+#include \"internal.h\"\n+\n+/* This file holds implementations of the atomic functions that are\n+   used if the host compiler has the sync functions but not the atomic\n+   functions, as is true of versions of GCC before 4.7.  */\n+\n+#if !defined (HAVE_ATOMIC_FUNCTIONS) && defined (HAVE_SYNC_FUNCTIONS)\n+\n+/* Do an atomic load of a pointer.  */\n+\n+void *\n+backtrace_atomic_load_pointer (void *arg)\n+{\n+  void **pp;\n+  void *p;\n+\n+  pp = (void **) arg;\n+  p = *pp;\n+  while (!__sync_bool_compare_and_swap (pp, p, p))\n+    p = *pp;\n+  return p;\n+}\n+\n+/* Do an atomic load of an int.  */\n+\n+int\n+backtrace_atomic_load_int (int *p)\n+{\n+  int i;\n+\n+  i = *p;\n+  while (!__sync_bool_compare_and_swap (p, i, i))\n+    i = *p;\n+  return i;\n+}\n+\n+/* Do an atomic store of a pointer.  */\n+\n+void\n+backtrace_atomic_store_pointer (void *arg, void *p)\n+{\n+  void **pp;\n+  void *old;\n+\n+  pp = (void **) arg;\n+  old = *pp;\n+  while (!__sync_bool_compare_and_swap (pp, old, p))\n+    old = *pp;\n+}\n+\n+/* Do an atomic store of a size_t value.  */\n+\n+void\n+backtrace_atomic_store_size_t (size_t *p, size_t v)\n+{\n+  size_t old;\n+\n+  old = *p;\n+  while (!__sync_bool_compare_and_swap (p, old, v))\n+    old = *p;\n+}\n+\n+/* Do an atomic store of a int value.  */\n+\n+void\n+backtrace_atomic_store_int (int *p, int v)\n+{\n+  size_t old;\n+\n+  old = *p;\n+  while (!__sync_bool_compare_and_swap (p, old, v))\n+    old = *p;\n+}\n+\n+#endif"}, {"sha": "901e3f72a431bf732a8dd21dccc4f604ab568b05", "filename": "src/libbacktrace/backtrace-supported.h.in", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace-supported.h.in?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,61 @@\n+/* backtrace-supported.h.in -- Whether stack backtrace is supported.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* The file backtrace-supported.h.in is used by configure to generate\n+   the file backtrace-supported.h.  The file backtrace-supported.h may\n+   be #include'd to see whether the backtrace library will be able to\n+   get a backtrace and produce symbolic information.  */\n+\n+\n+/* BACKTRACE_SUPPORTED will be #define'd as 1 if the backtrace library\n+   should work, 0 if it will not.  Libraries may #include this to make\n+   other arrangements.  */\n+\n+#define BACKTRACE_SUPPORTED @BACKTRACE_SUPPORTED@\n+\n+/* BACKTRACE_USES_MALLOC will be #define'd as 1 if the backtrace\n+   library will call malloc as it works, 0 if it will call mmap\n+   instead.  This may be used to determine whether it is safe to call\n+   the backtrace functions from a signal handler.  In general this\n+   only applies to calls like backtrace and backtrace_pcinfo.  It does\n+   not apply to backtrace_simple, which never calls malloc.  It does\n+   not apply to backtrace_print, which always calls fprintf and\n+   therefore malloc.  */\n+\n+#define BACKTRACE_USES_MALLOC @BACKTRACE_USES_MALLOC@\n+\n+/* BACKTRACE_SUPPORTS_THREADS will be #define'd as 1 if the backtrace\n+   library is configured with threading support, 0 if not.  If this is\n+   0, the threaded parameter to backtrace_create_state must be passed\n+   as 0.  */\n+\n+#define BACKTRACE_SUPPORTS_THREADS @BACKTRACE_SUPPORTS_THREADS@"}, {"sha": "cc3105c06cb19b592641853daa576f9ebe322045", "filename": "src/libbacktrace/backtrace.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbacktrace.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,108 @@\n+/* backtrace.c -- Entry point for stack backtrace library.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include \"unwind.h\"\n+#include \"backtrace.h\"\n+\n+/* The main backtrace_full routine.  */\n+\n+/* Data passed through _Unwind_Backtrace.  */\n+\n+struct backtrace_data\n+{\n+  /* Number of frames to skip.  */\n+  int skip;\n+  /* Library state.  */\n+  struct backtrace_state *state;\n+  /* Callback routine.  */\n+  backtrace_full_callback callback;\n+  /* Error callback routine.  */\n+  backtrace_error_callback error_callback;\n+  /* Data to pass to callback routines.  */\n+  void *data;\n+  /* Value to return from backtrace_full.  */\n+  int ret;\n+};\n+\n+/* Unwind library callback routine.  This is passed to\n+   _Unwind_Backtrace.  */\n+\n+static _Unwind_Reason_Code\n+unwind (struct _Unwind_Context *context, void *vdata)\n+{\n+  struct backtrace_data *bdata = (struct backtrace_data *) vdata;\n+  uintptr_t pc;\n+  int ip_before_insn = 0;\n+\n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  pc = _Unwind_GetIP (context);\n+#endif\n+\n+  if (bdata->skip > 0)\n+    {\n+      --bdata->skip;\n+      return _URC_NO_REASON;\n+    }\n+\n+  if (!ip_before_insn)\n+    --pc;\n+\n+  bdata->ret = backtrace_pcinfo (bdata->state, pc, bdata->callback,\n+\t\t\t\t bdata->error_callback, bdata->data);\n+  if (bdata->ret != 0)\n+    return _URC_END_OF_STACK;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+/* Get a stack backtrace.  */\n+\n+int\n+backtrace_full (struct backtrace_state *state, int skip,\n+\t\tbacktrace_full_callback callback,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  struct backtrace_data bdata;\n+\n+  bdata.skip = skip + 1;\n+  bdata.state = state;\n+  bdata.callback = callback;\n+  bdata.error_callback = error_callback;\n+  bdata.data = data;\n+  bdata.ret = 0;\n+  _Unwind_Backtrace (unwind, &bdata);\n+  return bdata.ret;\n+}"}, {"sha": "03b5479081d31e4aecb2a58f76ad3f92b33d1619", "filename": "src/libbacktrace/backtrace.h", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.h?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,199 @@\n+/* backtrace.h -- Public header file for stack backtrace library.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef BACKTRACE_H\n+#define BACKTRACE_H\n+\n+#include <stddef.h>\n+#include <stdio.h>\n+\n+/* We want to get a definition for uintptr_t, but we still care about\n+   systems that don't have <stdint.h>.  */\n+#if defined(__GLIBC__) && __GLIBC__ >= 2\n+\n+#include <stdint.h>\n+\n+#elif defined(HAVE_STDINT_H)\n+\n+#include <stdint.h>\n+\n+#else\n+\n+/* Systems that don't have <stdint.h> must provide gstdint.h, e.g.,\n+   from GCC_HEADER_STDINT in configure.ac.  */\n+#include \"gstdint.h\"\n+\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The backtrace state.  This struct is intentionally not defined in\n+   the public interface.  */\n+\n+struct backtrace_state;\n+\n+/* The type of the error callback argument to backtrace functions.\n+   This function, if not NULL, will be called for certain error cases.\n+   The DATA argument is passed to the function that calls this one.\n+   The MSG argument is an error message.  The ERRNUM argument, if\n+   greater than 0, holds an errno value.  The MSG buffer may become\n+   invalid after this function returns.\n+\n+   As a special case, the ERRNUM argument will be passed as -1 if no\n+   debug info can be found for the executable, but the function\n+   requires debug info (e.g., backtrace_full, backtrace_pcinfo).  The\n+   MSG in this case will be something along the lines of \"no debug\n+   info\".  Similarly, ERRNUM will be passed as -1 if there is no\n+   symbol table, but the function requires a symbol table (e.g.,\n+   backtrace_syminfo).  This may be used as a signal that some other\n+   approach should be tried.  */\n+\n+typedef void (*backtrace_error_callback) (void *data, const char *msg,\n+\t\t\t\t\t  int errnum);\n+\n+/* Create state information for the backtrace routines.  This must be\n+   called before any of the other routines, and its return value must\n+   be passed to all of the other routines.  FILENAME is the path name\n+   of the executable file; if it is NULL the library will try\n+   system-specific path names.  If not NULL, FILENAME must point to a\n+   permanent buffer.  If THREADED is non-zero the state may be\n+   accessed by multiple threads simultaneously, and the library will\n+   use appropriate atomic operations.  If THREADED is zero the state\n+   may only be accessed by one thread at a time.  This returns a state\n+   pointer on success, NULL on error.  If an error occurs, this will\n+   call the ERROR_CALLBACK routine.  */\n+\n+extern struct backtrace_state *backtrace_create_state (\n+    const char *filename, int threaded,\n+    backtrace_error_callback error_callback, void *data);\n+\n+/* The type of the callback argument to the backtrace_full function.\n+   DATA is the argument passed to backtrace_full.  PC is the program\n+   counter.  FILENAME is the name of the file containing PC, or NULL\n+   if not available.  LINENO is the line number in FILENAME containing\n+   PC, or 0 if not available.  FUNCTION is the name of the function\n+   containing PC, or NULL if not available.  This should return 0 to\n+   continuing tracing.  The FILENAME and FUNCTION buffers may become\n+   invalid after this function returns.  */\n+\n+typedef int (*backtrace_full_callback) (void *data, uintptr_t pc,\n+\t\t\t\t\tconst char *filename, int lineno,\n+\t\t\t\t\tconst char *function);\n+\n+/* Get a full stack backtrace.  SKIP is the number of frames to skip;\n+   passing 0 will start the trace with the function calling\n+   backtrace_full.  DATA is passed to the callback routine.  If any\n+   call to CALLBACK returns a non-zero value, the stack backtrace\n+   stops, and backtrace returns that value; this may be used to limit\n+   the number of stack frames desired.  If all calls to CALLBACK\n+   return 0, backtrace returns 0.  The backtrace_full function will\n+   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   function requires debug info for the executable.  */\n+\n+extern int backtrace_full (struct backtrace_state *state, int skip,\n+\t\t\t   backtrace_full_callback callback,\n+\t\t\t   backtrace_error_callback error_callback,\n+\t\t\t   void *data);\n+\n+/* The type of the callback argument to the backtrace_simple function.\n+   DATA is the argument passed to simple_backtrace.  PC is the program\n+   counter.  This should return 0 to continue tracing.  */\n+\n+typedef int (*backtrace_simple_callback) (void *data, uintptr_t pc);\n+\n+/* Get a simple backtrace.  SKIP is the number of frames to skip, as\n+   in backtrace.  DATA is passed to the callback routine.  If any call\n+   to CALLBACK returns a non-zero value, the stack backtrace stops,\n+   and backtrace_simple returns that value.  Otherwise\n+   backtrace_simple returns 0.  The backtrace_simple function will\n+   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   function does not require any debug info for the executable.  */\n+\n+extern int backtrace_simple (struct backtrace_state *state, int skip,\n+\t\t\t     backtrace_simple_callback callback,\n+\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t     void *data);\n+\n+/* Print the current backtrace in a user readable format to a FILE.\n+   SKIP is the number of frames to skip, as in backtrace_full.  Any\n+   error messages are printed to stderr.  This function requires debug\n+   info for the executable.  */\n+\n+extern void backtrace_print (struct backtrace_state *state, int skip, FILE *);\n+\n+/* Given PC, a program counter in the current program, call the\n+   callback function with filename, line number, and function name\n+   information.  This will normally call the callback function exactly\n+   once.  However, if the PC happens to describe an inlined call, and\n+   the debugging information contains the necessary information, then\n+   this may call the callback function multiple times.  This will make\n+   at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   returns the first non-zero value returned by CALLBACK, or 0.  */\n+\n+extern int backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t     backtrace_full_callback callback,\n+\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t     void *data);\n+\n+/* The type of the callback argument to backtrace_syminfo.  DATA and\n+   PC are the arguments passed to backtrace_syminfo.  SYMNAME is the\n+   name of the symbol for the corresponding code.  SYMVAL is the\n+   value and SYMSIZE is the size of the symbol.  SYMNAME will be NULL\n+   if no error occurred but the symbol could not be found.  */\n+\n+typedef void (*backtrace_syminfo_callback) (void *data, uintptr_t pc,\n+\t\t\t\t\t    const char *symname,\n+\t\t\t\t\t    uintptr_t symval,\n+\t\t\t\t\t    uintptr_t symsize);\n+\n+/* Given ADDR, an address or program counter in the current program,\n+   call the callback information with the symbol name and value\n+   describing the function or variable in which ADDR may be found.\n+   This will call either CALLBACK or ERROR_CALLBACK exactly once.\n+   This returns 1 on success, 0 on failure.  This function requires\n+   the symbol table but does not require the debug info.  Note that if\n+   the symbol table is present but ADDR could not be found in the\n+   table, CALLBACK will be called with a NULL SYMNAME argument.\n+   Returns 1 on success, 0 on error.  */\n+\n+extern int backtrace_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t\t\t      backtrace_syminfo_callback callback,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data);\n+\n+#ifdef __cplusplus\n+} /* End extern \"C\".  */\n+#endif\n+\n+#endif"}, {"sha": "4b67c3d8bd0c763d3ded1b1dd8ae82a1c509230f", "filename": "src/libbacktrace/btest.c", "status": "added", "additions": 715, "deletions": 0, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbtest.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbtest.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,715 @@\n+/* btest.c -- Test for libbacktrace library\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* This program tests the externally visible interfaces of the\n+   libbacktrace library.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+/* Portable attribute syntax.  Actually some of these tests probably\n+   won't work if the attributes are not recognized.  */\n+\n+#ifndef GCC_VERSION\n+# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef ATTRIBUTE_UNUSED\n+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#endif\n+\n+/* Used to collect backtrace info.  */\n+\n+struct info\n+{\n+  char *filename;\n+  int lineno;\n+  char *function;\n+};\n+\n+/* Passed to backtrace callback function.  */\n+\n+struct bdata\n+{\n+  struct info *all;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_simple callback function.  */\n+\n+struct sdata\n+{\n+  uintptr_t *addrs;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_syminfo callback function.  */\n+\n+struct symdata\n+{\n+  const char *name;\n+  uintptr_t val, size;\n+  int failed;\n+};\n+\n+/* The backtrace state.  */\n+\n+static void *state;\n+\n+/* The number of failures.  */\n+\n+static int failures;\n+\n+/* Return the base name in a path.  */\n+\n+static const char *\n+base (const char *p)\n+{\n+  const char *last;\n+  const char *s;\n+\n+  last = NULL;\n+  for (s = p; *s != '\\0'; ++s)\n+    {\n+      if (IS_DIR_SEPARATOR (*s))\n+\tlast = s + 1;\n+    }\n+  return last != NULL ? last : p;\n+}\n+\n+/* Check an entry in a struct info array.  */\n+\n+static void\n+check (const char *name, int index, const struct info *all, int want_lineno,\n+       const char *want_function, int *failed)\n+{\n+  if (*failed)\n+    return;\n+  if (all[index].filename == NULL || all[index].function == NULL)\n+    {\n+      fprintf (stderr, \"%s: [%d]: missing file name or function name\\n\",\n+\t       name, index);\n+      *failed = 1;\n+      return;\n+    }\n+  if (strcmp (base (all[index].filename), \"btest.c\") != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected test.c\\n\", name, index,\n+\t       all[index].filename);\n+      *failed = 1;\n+    }\n+  if (all[index].lineno != want_lineno)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %d expected %d\\n\", name, index,\n+\t       all[index].lineno, want_lineno);\n+      *failed = 1;\n+    }\n+  if (strcmp (all[index].function, want_function) != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n+\t       all[index].function, want_function);\n+      *failed = 1;\n+    }\n+}\n+\n+/* The backtrace callback function.  */\n+\n+static int\n+callback_one (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      const char *filename, int lineno, const char *function)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+  struct info *p;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_one: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  p = &data->all[data->index];\n+  if (filename == NULL)\n+    p->filename = NULL;\n+  else\n+    {\n+      p->filename = strdup (filename);\n+      assert (p->filename != NULL);\n+    }\n+  p->lineno = lineno;\n+  if (function == NULL)\n+    p->function = NULL;\n+  else\n+    {\n+      p->function = strdup (function);\n+      assert (p->function != NULL);\n+    }\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace.  */\n+\n+static void\n+error_callback_one (void *vdata, const char *msg, int errnum)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_simple callback function.  */\n+\n+static int\n+callback_two (void *vdata, uintptr_t pc)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_two: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  data->addrs[data->index] = pc;\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace_simple.  */\n+\n+static void\n+error_callback_two (void *vdata, const char *msg, int errnum)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_syminfo callback function.  */\n+\n+static void\n+callback_three (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t\tconst char *symname, uintptr_t symval,\n+\t\tuintptr_t symsize)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  if (symname == NULL)\n+    data->name = NULL;\n+  else\n+    {\n+      data->name = strdup (symname);\n+      assert (data->name != NULL);\n+    }\n+  data->val = symval;\n+  data->size = symsize;\n+}\n+\n+/* The backtrace_syminfo error callback function.  */\n+\n+static void\n+error_callback_three (void *vdata, const char *msg, int errnum)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* Test the backtrace function with non-inlined functions.  */\n+\n+static int test1 (void) __attribute__ ((noinline, unused));\n+static int f2 (int) __attribute__ ((noinline));\n+static int f3 (int, int) __attribute__ ((noinline));\n+\n+static int\n+test1 (void)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return f2 (__LINE__) + 1;\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+\t       data.index);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test1\", 0, all, f3line, \"f3\", &data.failed);\n+  check (\"test1\", 1, all, f2line, \"f2\", &data.failed);\n+  check (\"test1\", 2, all, f1line, \"test1\", &data.failed);\n+\n+  printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace function with inlined functions.  */\n+\n+static inline int test2 (void) __attribute__ ((always_inline, unused));\n+static inline int f12 (int) __attribute__ ((always_inline));\n+static inline int f13 (int, int) __attribute__ ((always_inline));\n+\n+static inline int\n+test2 (void)\n+{\n+  return f12 (__LINE__) + 1;\n+}\n+\n+static inline int\n+f12 (int f1line)\n+{\n+  return f13 (f1line, __LINE__) + 2;\n+}\n+\n+static inline int\n+f13 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test2: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test2\", 0, all, f3line, \"f13\", &data.failed);\n+  check (\"test2\", 1, all, f2line, \"f12\", &data.failed);\n+  check (\"test2\", 2, all, f1line, \"test2\", &data.failed);\n+\n+  printf (\"%s: backtrace_full inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with non-inlined functions.  */\n+\n+static int test3 (void) __attribute__ ((noinline, unused));\n+static int f22 (int) __attribute__ ((noinline));\n+static int f23 (int, int) __attribute__ ((noinline));\n+\n+static int\n+test3 (void)\n+{\n+  return f22 (__LINE__) + 1;\n+}\n+\n+static int\n+f22 (int f1line)\n+{\n+  return f23 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f23 (int f1line, int f2line)\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int f3line;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      struct info all[20];\n+      struct bdata bdata;\n+      int j;\n+\n+      bdata.all = &all[0];\n+      bdata.index = 0;\n+      bdata.max = 20;\n+      bdata.failed = 0;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  i = backtrace_pcinfo (state, addrs[j], callback_one,\n+\t\t\t\terror_callback_one, &bdata);\n+\t  if (i != 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: unexpected return value \"\n+\t\t\t\"from backtrace_pcinfo %d\\n\"),\n+\t\t       i);\n+\t      bdata.failed = 1;\n+\t    }\n+\t  if (!bdata.failed && bdata.index != (size_t) (j + 1))\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"wrong number of calls from backtrace_pcinfo \"\n+\t\t\t\"got %u expected %d\\n\"),\n+\t\t       (unsigned int) bdata.index, j + 1);\n+\t      bdata.failed = 1;\n+\t    }\n+\t}      \n+\n+      check (\"test3\", 0, all, f3line, \"f23\", &bdata.failed);\n+      check (\"test3\", 1, all, f2line, \"f22\", &bdata.failed);\n+      check (\"test3\", 2, all, f1line, \"test3\", &bdata.failed);\n+\n+      if (bdata.failed)\n+\tdata.failed = 1;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  struct symdata symdata;\n+\n+\t  symdata.name = NULL;\n+\t  symdata.val = 0;\n+\t  symdata.size = 0;\n+\t  symdata.failed = 0;\n+\n+\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n+\t\t\t\t error_callback_three, &symdata);\n+\t  if (i == 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: [%d]: unexpected return value \"\n+\t\t\t\"from backtrace_syminfo %d\\n\"),\n+\t\t       j, i);\n+\t      symdata.failed = 1;\n+\t    }\n+\n+\t  if (!symdata.failed)\n+\t    {\n+\t      const char *expected;\n+\n+\t      switch (j)\n+\t\t{\n+\t\tcase 0:\n+\t\t  expected = \"f23\";\n+\t\t  break;\n+\t\tcase 1:\n+\t\t  expected = \"f22\";\n+\t\t  break;\n+\t\tcase 2:\n+\t\t  expected = \"test3\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  assert (0);\n+\t\t}\n+\n+\t      if (symdata.name == NULL)\n+\t\t{\n+\t\t  fprintf (stderr, \"test3: [%d]: NULL syminfo name\\n\", j);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t      /* Use strncmp, not strcmp, because GCC might create a\n+\t\t clone.  */\n+\t      else if (strncmp (symdata.name, expected, strlen (expected))\n+\t\t       != 0)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   (\"test3: [%d]: unexpected syminfo name \"\n+\t\t\t    \"got %s expected %s\\n\"),\n+\t\t\t   j, symdata.name, expected);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t    }\n+\n+\t  if (symdata.failed)\n+\t    data.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_simple noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with inlined functions.  */\n+\n+static inline int test4 (void) __attribute__ ((always_inline, unused));\n+static inline int f32 (int) __attribute__ ((always_inline));\n+static inline int f33 (int, int) __attribute__ ((always_inline));\n+\n+static inline int\n+test4 (void)\n+{\n+  return f32 (__LINE__) + 1;\n+}\n+\n+static inline int\n+f32 (int f1line)\n+{\n+  return f33 (f1line, __LINE__) + 2;\n+}\n+\n+static inline int\n+f33 (int f1line, int f2line)\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int f3line;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      struct info all[20];\n+      struct bdata bdata;\n+\n+      bdata.all = &all[0];\n+      bdata.index = 0;\n+      bdata.max = 20;\n+      bdata.failed = 0;\n+\n+      i = backtrace_pcinfo (state, addrs[0], callback_one, error_callback_one,\n+\t\t\t    &bdata);\n+      if (i != 0)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   (\"test4: unexpected return value \"\n+\t\t    \"from backtrace_pcinfo %d\\n\"),\n+\t\t   i);\n+\t  bdata.failed = 1;\n+\t}\n+\n+      check (\"test4\", 0, all, f3line, \"f33\", &bdata.failed);\n+      check (\"test4\", 1, all, f2line, \"f32\", &bdata.failed);\n+      check (\"test4\", 2, all, f1line, \"test4\", &bdata.failed);\n+\n+      if (bdata.failed)\n+\tdata.failed = 1;\n+    }\n+\n+  printf (\"%s: backtrace_simple inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+int global = 1;\n+\n+static int\n+test5 (void)\n+{\n+  struct symdata symdata;\n+  int i;\n+  uintptr_t addr = (uintptr_t) &global;\n+\n+  if (sizeof (global) > 1)\n+    addr += 1;\n+\n+  symdata.name = NULL;\n+  symdata.val = 0;\n+  symdata.size = 0;\n+  symdata.failed = 0;\n+\n+  i = backtrace_syminfo (state, addr, callback_three,\n+\t\t\t error_callback_three, &symdata);\n+  if (i == 0)\n+    {\n+      fprintf (stderr,\n+\t       \"test5: unexpected return value from backtrace_syminfo %d\\n\",\n+\t       i);\n+      symdata.failed = 1;\n+    }\n+\n+  if (!symdata.failed)\n+    {\n+      if (symdata.name == NULL)\n+\t{\n+\t  fprintf (stderr, \"test5: NULL syminfo name\\n\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (strcmp (symdata.name, \"global\") != 0)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo name got %s expected %s\\n\",\n+\t\t   symdata.name, \"global\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.val != (uintptr_t) &global)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo value got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.val,\n+\t\t   (unsigned long) (uintptr_t) &global);\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.size != sizeof (global))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo size got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.size,\n+\t\t   (unsigned long) sizeof (global));\n+\t  symdata.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_syminfo variable\\n\",\n+\t  symdata.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (symdata.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+static void\n+error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n+\t\t       int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}\n+\n+/* Run all the tests.  */\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+#if BACKTRACE_SUPPORTED\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  test5 ();\n+#endif\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"}, {"sha": "b79252d6b1034cbcce18ed21d4ed21a405f987e9", "filename": "src/libbacktrace/config.guess", "status": "added", "additions": 1558, "deletions": 0, "changes": 1558, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfig.guess", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfig.guess", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.guess?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,1558 @@\n+#! /bin/sh\n+# Attempt to guess a canonical system name.\n+#   Copyright 1992-2013 Free Software Foundation, Inc.\n+\n+timestamp='2013-06-10'\n+\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, see <http://www.gnu.org/licenses/>.\n+#\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that\n+# program.  This Exception is an additional permission under section 7\n+# of the GNU General Public License, version 3 (\"GPLv3\").\n+#\n+# Originally written by Per Bothner.\n+#\n+# You can get the latest version of this script from:\n+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD\n+#\n+# Please send patches with a ChangeLog entry to config-patches@gnu.org.\n+\n+\n+me=`echo \"$0\" | sed -e 's,.*/,,'`\n+\n+usage=\"\\\n+Usage: $0 [OPTION]\n+\n+Output the configuration name of the system \\`$me' is run on.\n+\n+Operation modes:\n+  -h, --help         print this help, then exit\n+  -t, --time-stamp   print date of last modification, then exit\n+  -v, --version      print version number, then exit\n+\n+Report bugs and patches to <config-patches@gnu.org>.\"\n+\n+version=\"\\\n+GNU config.guess ($timestamp)\n+\n+Originally written by Per Bothner.\n+Copyright 1992-2013 Free Software Foundation, Inc.\n+\n+This is free software; see the source for copying conditions.  There is NO\n+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n+\n+help=\"\n+Try \\`$me --help' for more information.\"\n+\n+# Parse command line\n+while test $# -gt 0 ; do\n+  case $1 in\n+    --time-stamp | --time* | -t )\n+       echo \"$timestamp\" ; exit ;;\n+    --version | -v )\n+       echo \"$version\" ; exit ;;\n+    --help | --h* | -h )\n+       echo \"$usage\"; exit ;;\n+    -- )     # Stop option processing\n+       shift; break ;;\n+    - )\t# Use stdin as input.\n+       break ;;\n+    -* )\n+       echo \"$me: invalid option $1$help\" >&2\n+       exit 1 ;;\n+    * )\n+       break ;;\n+  esac\n+done\n+\n+if test $# != 0; then\n+  echo \"$me: too many arguments$help\" >&2\n+  exit 1\n+fi\n+\n+trap 'exit 1' 1 2 15\n+\n+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a\n+# compiler to aid in system detection is discouraged as it requires\n+# temporary files to be created and, as you can see below, it is a\n+# headache to deal with in a portable fashion.\n+\n+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still\n+# use `HOST_CC' if defined, but it is deprecated.\n+\n+# Portable tmp directory creation inspired by the Autoconf team.\n+\n+set_cc_for_build='\n+trap \"exitcode=\\$?; (rm -f \\$tmpfiles 2>/dev/null; rmdir \\$tmp 2>/dev/null) && exit \\$exitcode\" 0 ;\n+trap \"rm -f \\$tmpfiles 2>/dev/null; rmdir \\$tmp 2>/dev/null; exit 1\" 1 2 13 15 ;\n+: ${TMPDIR=/tmp} ;\n+ { tmp=`(umask 077 && mktemp -d \"$TMPDIR/cgXXXXXX\") 2>/dev/null` && test -n \"$tmp\" && test -d \"$tmp\" ; } ||\n+ { test -n \"$RANDOM\" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||\n+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo \"Warning: creating insecure temp directory\" >&2 ; } ||\n+ { echo \"$me: cannot create a temporary directory in $TMPDIR\" >&2 ; exit 1 ; } ;\n+dummy=$tmp/dummy ;\n+tmpfiles=\"$dummy.c $dummy.o $dummy.rel $dummy\" ;\n+case $CC_FOR_BUILD,$HOST_CC,$CC in\n+ ,,)    echo \"int x;\" > $dummy.c ;\n+\tfor c in cc gcc c89 c99 ; do\n+\t  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then\n+\t     CC_FOR_BUILD=\"$c\"; break ;\n+\t  fi ;\n+\tdone ;\n+\tif test x\"$CC_FOR_BUILD\" = x ; then\n+\t  CC_FOR_BUILD=no_compiler_found ;\n+\tfi\n+\t;;\n+ ,,*)   CC_FOR_BUILD=$CC ;;\n+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;\n+esac ; set_cc_for_build= ;'\n+\n+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.\n+# (ghazi@noc.rutgers.edu 1994-08-24)\n+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then\n+\tPATH=$PATH:/.attbin ; export PATH\n+fi\n+\n+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown\n+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown\n+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown\n+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown\n+\n+case \"${UNAME_SYSTEM}\" in\n+Linux|GNU|GNU/*)\n+\t# If the system lacks a compiler, then just pick glibc.\n+\t# We could probably try harder.\n+\tLIBC=gnu\n+\n+\teval $set_cc_for_build\n+\tcat <<-EOF > $dummy.c\n+\t#include <features.h>\n+\t#if defined(__UCLIBC__)\n+\tLIBC=uclibc\n+\t#elif defined(__dietlibc__)\n+\tLIBC=dietlibc\n+\t#else\n+\tLIBC=gnu\n+\t#endif\n+\tEOF\n+\teval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`\n+\t;;\n+esac\n+\n+# Note: order is significant - the case branches are not exclusive.\n+\n+case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n+    *:NetBSD:*:*)\n+\t# NetBSD (nbsd) targets should (where applicable) match one or\n+\t# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,\n+\t# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently\n+\t# switched to ELF, *-*-netbsd* would select the old\n+\t# object file format.  This provides both forward\n+\t# compatibility and a consistent mechanism for selecting the\n+\t# object file format.\n+\t#\n+\t# Note: NetBSD doesn't particularly care about the vendor\n+\t# portion of the name.  We always set it to \"unknown\".\n+\tsysctl=\"sysctl -n hw.machine_arch\"\n+\tUNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \\\n+\t    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    armeb) machine=armeb-unknown ;;\n+\t    arm*) machine=arm-unknown ;;\n+\t    sh3el) machine=shl-unknown ;;\n+\t    sh3eb) machine=sh-unknown ;;\n+\t    sh5el) machine=sh5le-unknown ;;\n+\t    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;\n+\tesac\n+\t# The Operating System including object format, if it has switched\n+\t# to ELF recently, or will in the future.\n+\tcase \"${UNAME_MACHINE_ARCH}\" in\n+\t    arm*|i386|m68k|ns32k|sh3*|sparc|vax)\n+\t\teval $set_cc_for_build\n+\t\tif echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t\t\t| grep -q __ELF__\n+\t\tthen\n+\t\t    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).\n+\t\t    # Return netbsd for either.  FIX?\n+\t\t    os=netbsd\n+\t\telse\n+\t\t    os=netbsdelf\n+\t\tfi\n+\t\t;;\n+\t    *)\n+\t\tos=netbsd\n+\t\t;;\n+\tesac\n+\t# The OS release\n+\t# Debian GNU/NetBSD machines have a different userland, and\n+\t# thus, need a distinct triplet. However, they do not need\n+\t# kernel version information, so it can be replaced with a\n+\t# suitable tag, in the style of linux-gnu.\n+\tcase \"${UNAME_VERSION}\" in\n+\t    Debian*)\n+\t\trelease='-gnu'\n+\t\t;;\n+\t    *)\n+\t\trelease=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\\./'`\n+\t\t;;\n+\tesac\n+\t# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:\n+\t# contains redundant information, the shorter form:\n+\t# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.\n+\techo \"${machine}-${os}${release}\"\n+\texit ;;\n+    *:Bitrig:*:*)\n+\tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n+\techo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}\n+\texit ;;\n+    *:OpenBSD:*:*)\n+\tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n+\techo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}\n+\texit ;;\n+    *:ekkoBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}\n+\texit ;;\n+    *:SolidBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}\n+\texit ;;\n+    macppc:MirBSD:*:*)\n+\techo powerpc-unknown-mirbsd${UNAME_RELEASE}\n+\texit ;;\n+    *:MirBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}\n+\texit ;;\n+    alpha:OSF1:*:*)\n+\tcase $UNAME_RELEASE in\n+\t*4.0)\n+\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`\n+\t\t;;\n+\t*5.*)\n+\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`\n+\t\t;;\n+\tesac\n+\t# According to Compaq, /usr/sbin/psrinfo has been available on\n+\t# OSF/1 and Tru64 systems produced since 1995.  I hope that\n+\t# covers most systems running today.  This code pipes the CPU\n+\t# types through head -n 1, so we only detect the type of CPU 0.\n+\tALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \\(.*\\) processor.*$/\\1/p' | head -n 1`\n+\tcase \"$ALPHA_CPU_TYPE\" in\n+\t    \"EV4 (21064)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"EV4.5 (21064)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"LCA4 (21066/21068)\")\n+\t\tUNAME_MACHINE=\"alpha\" ;;\n+\t    \"EV5 (21164)\")\n+\t\tUNAME_MACHINE=\"alphaev5\" ;;\n+\t    \"EV5.6 (21164A)\")\n+\t\tUNAME_MACHINE=\"alphaev56\" ;;\n+\t    \"EV5.6 (21164PC)\")\n+\t\tUNAME_MACHINE=\"alphapca56\" ;;\n+\t    \"EV5.7 (21164PC)\")\n+\t\tUNAME_MACHINE=\"alphapca57\" ;;\n+\t    \"EV6 (21264)\")\n+\t\tUNAME_MACHINE=\"alphaev6\" ;;\n+\t    \"EV6.7 (21264A)\")\n+\t\tUNAME_MACHINE=\"alphaev67\" ;;\n+\t    \"EV6.8CB (21264C)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.8AL (21264B)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.8CX (21264D)\")\n+\t\tUNAME_MACHINE=\"alphaev68\" ;;\n+\t    \"EV6.9A (21264/EV69A)\")\n+\t\tUNAME_MACHINE=\"alphaev69\" ;;\n+\t    \"EV7 (21364)\")\n+\t\tUNAME_MACHINE=\"alphaev7\" ;;\n+\t    \"EV7.9 (21364A)\")\n+\t\tUNAME_MACHINE=\"alphaev79\" ;;\n+\tesac\n+\t# A Pn.n version is a patched version.\n+\t# A Vn.n version is a released version.\n+\t# A Tn.n version is a released field test version.\n+\t# A Xn.n version is an unreleased experimental baselevel.\n+\t# 1.2 uses \"1.2\" for uname -r.\n+\techo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+\t# Reset EXIT trap before exiting to avoid spurious non-zero exit code.\n+\texitcode=$?\n+\ttrap '' 0\n+\texit $exitcode ;;\n+    Alpha\\ *:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# Should we change UNAME_MACHINE based on the output of uname instead\n+\t# of the specific Alpha model?\n+\techo alpha-pc-interix\n+\texit ;;\n+    21064:Windows_NT:50:3)\n+\techo alpha-dec-winnt3.5\n+\texit ;;\n+    Amiga*:UNIX_System_V:4.0:*)\n+\techo m68k-unknown-sysv4\n+\texit ;;\n+    *:[Aa]miga[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-amigaos\n+\texit ;;\n+    *:[Mm]orph[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-morphos\n+\texit ;;\n+    *:OS/390:*:*)\n+\techo i370-ibm-openedition\n+\texit ;;\n+    *:z/VM:*:*)\n+\techo s390-ibm-zvmoe\n+\texit ;;\n+    *:OS400:*:*)\n+\techo powerpc-ibm-os400\n+\texit ;;\n+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)\n+\techo arm-acorn-riscix${UNAME_RELEASE}\n+\texit ;;\n+    arm*:riscos:*:*|arm*:RISCOS:*:*)\n+\techo arm-unknown-riscos\n+\texit ;;\n+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)\n+\techo hppa1.1-hitachi-hiuxmpp\n+\texit ;;\n+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)\n+\t# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.\n+\tif test \"`(/bin/universe) 2>/dev/null`\" = att ; then\n+\t\techo pyramid-pyramid-sysv3\n+\telse\n+\t\techo pyramid-pyramid-bsd\n+\tfi\n+\texit ;;\n+    NILE*:*:*:dcosx)\n+\techo pyramid-pyramid-svr4\n+\texit ;;\n+    DRS?6000:unix:4.0:6*)\n+\techo sparc-icl-nx6\n+\texit ;;\n+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)\n+\tcase `/usr/bin/uname -p` in\n+\t    sparc) echo sparc-icl-nx7; exit ;;\n+\tesac ;;\n+    s390x:SunOS:*:*)\n+\techo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4H:SunOS:5.*:*)\n+\techo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)\n+\techo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n+\techo i386-pc-auroraux${UNAME_RELEASE}\n+\texit ;;\n+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n+\teval $set_cc_for_build\n+\tSUN_ARCH=\"i386\"\n+\t# If there is a compiler, see if it is configured for 64-bit objects.\n+\t# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.\n+\t# This test works for both compilers.\n+\tif [ \"$CC_FOR_BUILD\" != 'no_compiler_found' ]; then\n+\t    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \\\n+\t\t(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \\\n+\t\tgrep IS_64BIT_ARCH >/dev/null\n+\t    then\n+\t\tSUN_ARCH=\"x86_64\"\n+\t    fi\n+\tfi\n+\techo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:6*:*)\n+\t# According to config.sub, this is the proper way to canonicalize\n+\t# SunOS6.  Hard to guess exactly what SunOS6 will be like, but\n+\t# it's likely to be more like Solaris than SunOS4.\n+\techo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    sun4*:SunOS:*:*)\n+\tcase \"`/usr/bin/arch -k`\" in\n+\t    Series*|S4*)\n+\t\tUNAME_RELEASE=`uname -v`\n+\t\t;;\n+\tesac\n+\t# Japanese Language versions have a version number like `4.1.3-JL'.\n+\techo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`\n+\texit ;;\n+    sun3*:SunOS:*:*)\n+\techo m68k-sun-sunos${UNAME_RELEASE}\n+\texit ;;\n+    sun*:*:4.2BSD:*)\n+\tUNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`\n+\ttest \"x${UNAME_RELEASE}\" = \"x\" && UNAME_RELEASE=3\n+\tcase \"`/bin/arch`\" in\n+\t    sun3)\n+\t\techo m68k-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\t    sun4)\n+\t\techo sparc-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\tesac\n+\texit ;;\n+    aushp:SunOS:*:*)\n+\techo sparc-auspex-sunos${UNAME_RELEASE}\n+\texit ;;\n+    # The situation for MiNT is a little confusing.  The machine name\n+    # can be virtually everything (everything which is not\n+    # \"atarist\" or \"atariste\" at least should have a processor\n+    # > m68000).  The system name ranges from \"MiNT\" over \"FreeMiNT\"\n+    # to the lowercase version \"mint\" (or \"freemint\").  Finally\n+    # the system name \"TOS\" denotes a system which is actually not\n+    # MiNT.  But MiNT is downward compatible to TOS, so this should\n+    # be no problem.\n+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+\texit ;;\n+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)\n+\techo m68k-milan-mint${UNAME_RELEASE}\n+\texit ;;\n+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)\n+\techo m68k-hades-mint${UNAME_RELEASE}\n+\texit ;;\n+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)\n+\techo m68k-unknown-mint${UNAME_RELEASE}\n+\texit ;;\n+    m68k:machten:*:*)\n+\techo m68k-apple-machten${UNAME_RELEASE}\n+\texit ;;\n+    powerpc:machten:*:*)\n+\techo powerpc-apple-machten${UNAME_RELEASE}\n+\texit ;;\n+    RISC*:Mach:*:*)\n+\techo mips-dec-mach_bsd4.3\n+\texit ;;\n+    RISC*:ULTRIX:*:*)\n+\techo mips-dec-ultrix${UNAME_RELEASE}\n+\texit ;;\n+    VAX*:ULTRIX*:*:*)\n+\techo vax-dec-ultrix${UNAME_RELEASE}\n+\texit ;;\n+    2020:CLIX:*:* | 2430:CLIX:*:*)\n+\techo clipper-intergraph-clix${UNAME_RELEASE}\n+\texit ;;\n+    mips:*:*:UMIPS | mips:*:*:RISCos)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+#ifdef __cplusplus\n+#include <stdio.h>  /* for printf() prototype */\n+\tint main (int argc, char *argv[]) {\n+#else\n+\tint main (argc, argv) int argc; char *argv[]; {\n+#endif\n+\t#if defined (host_mips) && defined (MIPSEB)\n+\t#if defined (SYSTYPE_SYSV)\n+\t  printf (\"mips-mips-riscos%ssysv\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_SVR4)\n+\t  printf (\"mips-mips-riscos%ssvr4\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)\n+\t  printf (\"mips-mips-riscos%sbsd\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#endif\n+\t  exit (-1);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD -o $dummy $dummy.c &&\n+\t  dummyarg=`echo \"${UNAME_RELEASE}\" | sed -n 's/\\([0-9]*\\).*/\\1/p'` &&\n+\t  SYSTEM_NAME=`$dummy $dummyarg` &&\n+\t    { echo \"$SYSTEM_NAME\"; exit; }\n+\techo mips-mips-riscos${UNAME_RELEASE}\n+\texit ;;\n+    Motorola:PowerMAX_OS:*:*)\n+\techo powerpc-motorola-powermax\n+\texit ;;\n+    Motorola:*:4.3:PL8-*)\n+\techo powerpc-harris-powermax\n+\texit ;;\n+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)\n+\techo powerpc-harris-powermax\n+\texit ;;\n+    Night_Hawk:Power_UNIX:*:*)\n+\techo powerpc-harris-powerunix\n+\texit ;;\n+    m88k:CX/UX:7*:*)\n+\techo m88k-harris-cxux7\n+\texit ;;\n+    m88k:*:4*:R4*)\n+\techo m88k-motorola-sysv4\n+\texit ;;\n+    m88k:*:3*:R3*)\n+\techo m88k-motorola-sysv3\n+\texit ;;\n+    AViiON:dgux:*:*)\n+\t# DG/UX returns AViiON for all architectures\n+\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n+\tif [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]\n+\tthen\n+\t    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \\\n+\t       [ ${TARGET_BINARY_INTERFACE}x = x ]\n+\t    then\n+\t\techo m88k-dg-dgux${UNAME_RELEASE}\n+\t    else\n+\t\techo m88k-dg-dguxbcs${UNAME_RELEASE}\n+\t    fi\n+\telse\n+\t    echo i586-dg-dgux${UNAME_RELEASE}\n+\tfi\n+\texit ;;\n+    M88*:DolphinOS:*:*)\t# DolphinOS (SVR3)\n+\techo m88k-dolphin-sysv3\n+\texit ;;\n+    M88*:*:R3*:*)\n+\t# Delta 88k system running SVR3\n+\techo m88k-motorola-sysv3\n+\texit ;;\n+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)\n+\techo m88k-tektronix-sysv3\n+\texit ;;\n+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)\n+\techo m68k-tektronix-bsd\n+\texit ;;\n+    *:IRIX*:*:*)\n+\techo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`\n+\texit ;;\n+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.\n+\techo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id\n+\texit ;;               # Note that: echo \"'`uname -s`'\" gives 'AIX '\n+    i*86:AIX:*:*)\n+\techo i386-ibm-aix\n+\texit ;;\n+    ia64:AIX:*:*)\n+\tif [ -x /usr/bin/oslevel ] ; then\n+\t\tIBM_REV=`/usr/bin/oslevel`\n+\telse\n+\t\tIBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}\n+\tfi\n+\techo ${UNAME_MACHINE}-ibm-aix${IBM_REV}\n+\texit ;;\n+    *:AIX:2:3)\n+\tif grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\teval $set_cc_for_build\n+\t\tsed 's/^\t\t//' << EOF >$dummy.c\n+\t\t#include <sys/systemcfg.h>\n+\n+\t\tmain()\n+\t\t\t{\n+\t\t\tif (!__power_pc())\n+\t\t\t\texit(1);\n+\t\t\tputs(\"powerpc-ibm-aix3.2.5\");\n+\t\t\texit(0);\n+\t\t\t}\n+EOF\n+\t\tif $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`\n+\t\tthen\n+\t\t\techo \"$SYSTEM_NAME\"\n+\t\telse\n+\t\t\techo rs6000-ibm-aix3.2.5\n+\t\tfi\n+\telif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\techo rs6000-ibm-aix3.2.4\n+\telse\n+\t\techo rs6000-ibm-aix3.2\n+\tfi\n+\texit ;;\n+    *:AIX:*:[4567])\n+\tIBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`\n+\tif /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then\n+\t\tIBM_ARCH=rs6000\n+\telse\n+\t\tIBM_ARCH=powerpc\n+\tfi\n+\tif [ -x /usr/bin/oslevel ] ; then\n+\t\tIBM_REV=`/usr/bin/oslevel`\n+\telse\n+\t\tIBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}\n+\tfi\n+\techo ${IBM_ARCH}-ibm-aix${IBM_REV}\n+\texit ;;\n+    *:AIX:*:*)\n+\techo rs6000-ibm-aix\n+\texit ;;\n+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)\n+\techo romp-ibm-bsd4.4\n+\texit ;;\n+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and\n+\techo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to\n+\texit ;;                             # report: romp-ibm BSD 4.3\n+    *:BOSX:*:*)\n+\techo rs6000-bull-bosx\n+\texit ;;\n+    DPX/2?00:B.O.S.:*:*)\n+\techo m68k-bull-sysv3\n+\texit ;;\n+    9000/[34]??:4.3bsd:1.*:*)\n+\techo m68k-hp-bsd\n+\texit ;;\n+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)\n+\techo m68k-hp-bsd4.4\n+\texit ;;\n+    9000/[34678]??:HP-UX:*:*)\n+\tHPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`\n+\tcase \"${UNAME_MACHINE}\" in\n+\t    9000/31? )            HP_ARCH=m68000 ;;\n+\t    9000/[34]?? )         HP_ARCH=m68k ;;\n+\t    9000/[678][0-9][0-9])\n+\t\tif [ -x /usr/bin/getconf ]; then\n+\t\t    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`\n+\t\t    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`\n+\t\t    case \"${sc_cpu_version}\" in\n+\t\t      523) HP_ARCH=\"hppa1.0\" ;; # CPU_PA_RISC1_0\n+\t\t      528) HP_ARCH=\"hppa1.1\" ;; # CPU_PA_RISC1_1\n+\t\t      532)                      # CPU_PA_RISC2_0\n+\t\t\tcase \"${sc_kernel_bits}\" in\n+\t\t\t  32) HP_ARCH=\"hppa2.0n\" ;;\n+\t\t\t  64) HP_ARCH=\"hppa2.0w\" ;;\n+\t\t\t  '') HP_ARCH=\"hppa2.0\" ;;   # HP-UX 10.20\n+\t\t\tesac ;;\n+\t\t    esac\n+\t\tfi\n+\t\tif [ \"${HP_ARCH}\" = \"\" ]; then\n+\t\t    eval $set_cc_for_build\n+\t\t    sed 's/^\t\t//' << EOF >$dummy.c\n+\n+\t\t#define _HPUX_SOURCE\n+\t\t#include <stdlib.h>\n+\t\t#include <unistd.h>\n+\n+\t\tint main ()\n+\t\t{\n+\t\t#if defined(_SC_KERNEL_BITS)\n+\t\t    long bits = sysconf(_SC_KERNEL_BITS);\n+\t\t#endif\n+\t\t    long cpu  = sysconf (_SC_CPU_VERSION);\n+\n+\t\t    switch (cpu)\n+\t\t\t{\n+\t\t\tcase CPU_PA_RISC1_0: puts (\"hppa1.0\"); break;\n+\t\t\tcase CPU_PA_RISC1_1: puts (\"hppa1.1\"); break;\n+\t\t\tcase CPU_PA_RISC2_0:\n+\t\t#if defined(_SC_KERNEL_BITS)\n+\t\t\t    switch (bits)\n+\t\t\t\t{\n+\t\t\t\tcase 64: puts (\"hppa2.0w\"); break;\n+\t\t\t\tcase 32: puts (\"hppa2.0n\"); break;\n+\t\t\t\tdefault: puts (\"hppa2.0\"); break;\n+\t\t\t\t} break;\n+\t\t#else  /* !defined(_SC_KERNEL_BITS) */\n+\t\t\t    puts (\"hppa2.0\"); break;\n+\t\t#endif\n+\t\t\tdefault: puts (\"hppa1.0\"); break;\n+\t\t\t}\n+\t\t    exit (0);\n+\t\t}\n+EOF\n+\t\t    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`\n+\t\t    test -z \"$HP_ARCH\" && HP_ARCH=hppa\n+\t\tfi ;;\n+\tesac\n+\tif [ ${HP_ARCH} = \"hppa2.0w\" ]\n+\tthen\n+\t    eval $set_cc_for_build\n+\n+\t    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating\n+\t    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler\n+\t    # generating 64-bit code.  GNU and HP use different nomenclature:\n+\t    #\n+\t    # $ CC_FOR_BUILD=cc ./config.guess\n+\t    # => hppa2.0w-hp-hpux11.23\n+\t    # $ CC_FOR_BUILD=\"cc +DA2.0w\" ./config.guess\n+\t    # => hppa64-hp-hpux11.23\n+\n+\t    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |\n+\t\tgrep -q __LP64__\n+\t    then\n+\t\tHP_ARCH=\"hppa2.0w\"\n+\t    else\n+\t\tHP_ARCH=\"hppa64\"\n+\t    fi\n+\tfi\n+\techo ${HP_ARCH}-hp-hpux${HPUX_REV}\n+\texit ;;\n+    ia64:HP-UX:*:*)\n+\tHPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`\n+\techo ia64-hp-hpux${HPUX_REV}\n+\texit ;;\n+    3050*:HI-UX:*:*)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#include <unistd.h>\n+\tint\n+\tmain ()\n+\t{\n+\t  long cpu = sysconf (_SC_CPU_VERSION);\n+\t  /* The order matters, because CPU_IS_HP_MC68K erroneously returns\n+\t     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct\n+\t     results, however.  */\n+\t  if (CPU_IS_PA_RISC (cpu))\n+\t    {\n+\t      switch (cpu)\n+\t\t{\n+\t\t  case CPU_PA_RISC1_0: puts (\"hppa1.0-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC1_1: puts (\"hppa1.1-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC2_0: puts (\"hppa2.0-hitachi-hiuxwe2\"); break;\n+\t\t  default: puts (\"hppa-hitachi-hiuxwe2\"); break;\n+\t\t}\n+\t    }\n+\t  else if (CPU_IS_HP_MC68K (cpu))\n+\t    puts (\"m68k-hitachi-hiuxwe2\");\n+\t  else puts (\"unknown-hitachi-hiuxwe2\");\n+\t  exit (0);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&\n+\t\t{ echo \"$SYSTEM_NAME\"; exit; }\n+\techo unknown-hitachi-hiuxwe2\n+\texit ;;\n+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )\n+\techo hppa1.1-hp-bsd\n+\texit ;;\n+    9000/8??:4.3bsd:*:*)\n+\techo hppa1.0-hp-bsd\n+\texit ;;\n+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)\n+\techo hppa1.0-hp-mpeix\n+\texit ;;\n+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )\n+\techo hppa1.1-hp-osf\n+\texit ;;\n+    hp8??:OSF1:*:*)\n+\techo hppa1.0-hp-osf\n+\texit ;;\n+    i*86:OSF1:*:*)\n+\tif [ -x /usr/sbin/sysversion ] ; then\n+\t    echo ${UNAME_MACHINE}-unknown-osf1mk\n+\telse\n+\t    echo ${UNAME_MACHINE}-unknown-osf1\n+\tfi\n+\texit ;;\n+    parisc*:Lites*:*:*)\n+\techo hppa1.1-hp-lites\n+\texit ;;\n+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)\n+\techo c1-convex-bsd\n+\texit ;;\n+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+\texit ;;\n+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)\n+\techo c34-convex-bsd\n+\texit ;;\n+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)\n+\techo c38-convex-bsd\n+\texit ;;\n+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)\n+\techo c4-convex-bsd\n+\texit ;;\n+    CRAY*Y-MP:*:*:*)\n+\techo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*[A-Z]90:*:*:*)\n+\techo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \\\n+\t| sed -e 's/CRAY.*\\([A-Z]90\\)/\\1/' \\\n+\t      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \\\n+\t      -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*TS:*:*:*)\n+\techo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*T3E:*:*:*)\n+\techo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    CRAY*SV1:*:*:*)\n+\techo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    *:UNICOS/mp:*:*)\n+\techo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\\.[^.]*$/.X/'\n+\texit ;;\n+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)\n+\tFUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+\tFUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\\///'`\n+\tFUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`\n+\techo \"${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\"\n+\texit ;;\n+    5000:UNIX_System_V:4.*:*)\n+\tFUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\\///'`\n+\tFUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`\n+\techo \"sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\"\n+\texit ;;\n+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\\ Embedded/OS:*:*)\n+\techo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    sparc*:BSD/OS:*:*)\n+\techo sparc-unknown-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    *:BSD/OS:*:*)\n+\techo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}\n+\texit ;;\n+    *:FreeBSD:*:*)\n+\tUNAME_PROCESSOR=`/usr/bin/uname -p`\n+\tcase ${UNAME_PROCESSOR} in\n+\t    amd64)\n+\t\techo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\t    *)\n+\t\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\tesac\n+\texit ;;\n+    i*:CYGWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-cygwin\n+\texit ;;\n+    *:MINGW64*:*)\n+\techo ${UNAME_MACHINE}-pc-mingw64\n+\texit ;;\n+    *:MINGW*:*)\n+\techo ${UNAME_MACHINE}-pc-mingw32\n+\texit ;;\n+    i*:MSYS*:*)\n+\techo ${UNAME_MACHINE}-pc-msys\n+\texit ;;\n+    i*:windows32*:*)\n+\t# uname -m includes \"-pc\" on this system.\n+\techo ${UNAME_MACHINE}-mingw32\n+\texit ;;\n+    i*:PW*:*)\n+\techo ${UNAME_MACHINE}-pc-pw32\n+\texit ;;\n+    *:Interix*:*)\n+\tcase ${UNAME_MACHINE} in\n+\t    x86)\n+\t\techo i586-pc-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\t    authenticamd | genuineintel | EM64T)\n+\t\techo x86_64-unknown-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\t    IA64)\n+\t\techo ia64-unknown-interix${UNAME_RELEASE}\n+\t\texit ;;\n+\tesac ;;\n+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)\n+\techo i${UNAME_MACHINE}-pc-mks\n+\texit ;;\n+    8664:Windows_NT:*)\n+\techo x86_64-pc-mks\n+\texit ;;\n+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we\n+\t# UNAME_MACHINE based on the output of uname instead of i386?\n+\techo i586-pc-interix\n+\texit ;;\n+    i*:UWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-uwin\n+\texit ;;\n+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)\n+\techo x86_64-unknown-cygwin\n+\texit ;;\n+    p*:CYGWIN*:*)\n+\techo powerpcle-unknown-cygwin\n+\texit ;;\n+    prep*:SunOS:5.*:*)\n+\techo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit ;;\n+    *:GNU:*:*)\n+\t# the GNU system\n+\techo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`\n+\texit ;;\n+    *:GNU/*:*:*)\n+\t# other systems with GNU libc and userland\n+\techo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}\n+\texit ;;\n+    i*86:Minix:*:*)\n+\techo ${UNAME_MACHINE}-pc-minix\n+\texit ;;\n+    aarch64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    aarch64_be:Linux:*:*)\n+\tUNAME_MACHINE=aarch64_be\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    alpha:Linux:*:*)\n+\tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' < /proc/cpuinfo` in\n+\t  EV5)   UNAME_MACHINE=alphaev5 ;;\n+\t  EV56)  UNAME_MACHINE=alphaev56 ;;\n+\t  PCA56) UNAME_MACHINE=alphapca56 ;;\n+\t  PCA57) UNAME_MACHINE=alphapca56 ;;\n+\t  EV6)   UNAME_MACHINE=alphaev6 ;;\n+\t  EV67)  UNAME_MACHINE=alphaev67 ;;\n+\t  EV68*) UNAME_MACHINE=alphaev68 ;;\n+\tesac\n+\tobjdump --private-headers /bin/sh | grep -q ld.so.1\n+\tif test \"$?\" = 0 ; then LIBC=\"gnulibc1\" ; fi\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    arc:Linux:*:* | arceb:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    arm*:Linux:*:*)\n+\teval $set_cc_for_build\n+\tif echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t    | grep -q __ARM_EABI__\n+\tthen\n+\t    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\telse\n+\t    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \\\n+\t\t| grep -q __ARM_PCS_VFP\n+\t    then\n+\t\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi\n+\t    else\n+\t\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf\n+\t    fi\n+\tfi\n+\texit ;;\n+    avr32*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    cris:Linux:*:*)\n+\techo ${UNAME_MACHINE}-axis-linux-${LIBC}\n+\texit ;;\n+    crisv32:Linux:*:*)\n+\techo ${UNAME_MACHINE}-axis-linux-${LIBC}\n+\texit ;;\n+    frv:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    hexagon:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    i*86:Linux:*:*)\n+\techo ${UNAME_MACHINE}-pc-linux-${LIBC}\n+\texit ;;\n+    ia64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    m32r*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    m68*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    mips:Linux:*:* | mips64:Linux:*:*)\n+\teval $set_cc_for_build\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#undef CPU\n+\t#undef ${UNAME_MACHINE}\n+\t#undef ${UNAME_MACHINE}el\n+\t#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)\n+\tCPU=${UNAME_MACHINE}el\n+\t#else\n+\t#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)\n+\tCPU=${UNAME_MACHINE}\n+\t#else\n+\tCPU=\n+\t#endif\n+\t#endif\n+EOF\n+\teval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`\n+\ttest x\"${CPU}\" != x && { echo \"${CPU}-unknown-linux-${LIBC}\"; exit; }\n+\t;;\n+    or1k:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    or32:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    padre:Linux:*:*)\n+\techo sparc-unknown-linux-${LIBC}\n+\texit ;;\n+    parisc64:Linux:*:* | hppa64:Linux:*:*)\n+\techo hppa64-unknown-linux-${LIBC}\n+\texit ;;\n+    parisc:Linux:*:* | hppa:Linux:*:*)\n+\t# Look for CPU level\n+\tcase `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in\n+\t  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;\n+\t  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;\n+\t  *)    echo hppa-unknown-linux-${LIBC} ;;\n+\tesac\n+\texit ;;\n+    ppc64:Linux:*:*)\n+\techo powerpc64-unknown-linux-${LIBC}\n+\texit ;;\n+    ppc:Linux:*:*)\n+\techo powerpc-unknown-linux-${LIBC}\n+\texit ;;\n+    ppc64le:Linux:*:*)\n+\techo powerpc64le-unknown-linux-${LIBC}\n+\texit ;;\n+    ppcle:Linux:*:*)\n+\techo powerpcle-unknown-linux-${LIBC}\n+\texit ;;\n+    s390:Linux:*:* | s390x:Linux:*:*)\n+\techo ${UNAME_MACHINE}-ibm-linux-${LIBC}\n+\texit ;;\n+    sh64*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    sh*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    sparc:Linux:*:* | sparc64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    tile*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    vax:Linux:*:*)\n+\techo ${UNAME_MACHINE}-dec-linux-${LIBC}\n+\texit ;;\n+    x86_64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    xtensa*:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    i*86:DYNIX/ptx:4*:*)\n+\t# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.\n+\t# earlier versions are messed up and put the nodename in both\n+\t# sysname and nodename.\n+\techo i386-sequent-sysv4\n+\texit ;;\n+    i*86:UNIX_SV:4.2MP:2.*)\n+\t# Unixware is an offshoot of SVR4, but it has its own version\n+\t# number series starting with 2...\n+\t# I am not positive that other SVR4 systems won't match this,\n+\t# I just have to hope.  -- rms.\n+\t# Use sysv4.2uw... so that sysv4* matches it.\n+\techo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}\n+\texit ;;\n+    i*86:OS/2:*:*)\n+\t# If we were able to find `uname', then EMX Unix compatibility\n+\t# is probably installed.\n+\techo ${UNAME_MACHINE}-pc-os2-emx\n+\texit ;;\n+    i*86:XTS-300:*:STOP)\n+\techo ${UNAME_MACHINE}-unknown-stop\n+\texit ;;\n+    i*86:atheos:*:*)\n+\techo ${UNAME_MACHINE}-unknown-atheos\n+\texit ;;\n+    i*86:syllable:*:*)\n+\techo ${UNAME_MACHINE}-pc-syllable\n+\texit ;;\n+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)\n+\techo i386-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    i*86:*DOS:*:*)\n+\techo ${UNAME_MACHINE}-pc-msdosdjgpp\n+\texit ;;\n+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)\n+\tUNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\\/MP$//'`\n+\tif grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then\n+\t\techo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}\n+\tfi\n+\texit ;;\n+    i*86:*:5:[678]*)\n+\t# UnixWare 7.x, OpenUNIX and OpenServer 6.\n+\tcase `/bin/uname -X | grep \"^Machine\"` in\n+\t    *486*)\t     UNAME_MACHINE=i486 ;;\n+\t    *Pentium)\t     UNAME_MACHINE=i586 ;;\n+\t    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;\n+\tesac\n+\techo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}\n+\texit ;;\n+    i*86:*:3.2:*)\n+\tif test -f /usr/options/cb.name; then\n+\t\tUNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`\n+\t\techo ${UNAME_MACHINE}-pc-isc$UNAME_REL\n+\telif /bin/uname -X 2>/dev/null >/dev/null ; then\n+\t\tUNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`\n+\t\t(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486\n+\t\t(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i586\n+\t\t(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\t(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\techo ${UNAME_MACHINE}-pc-sco$UNAME_REL\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv32\n+\tfi\n+\texit ;;\n+    pc:*:*:*)\n+\t# Left here for compatibility:\n+\t# uname -m prints for DJGPP always 'pc', but it prints nothing about\n+\t# the processor, so we play safe by assuming i586.\n+\t# Note: whatever this is, it MUST be the same as what config.sub\n+\t# prints for the \"djgpp\" host, or else GDB configury will decide that\n+\t# this is a cross-build.\n+\techo i586-pc-msdosdjgpp\n+\texit ;;\n+    Intel:Mach:3*:*)\n+\techo i386-pc-mach3\n+\texit ;;\n+    paragon:*:*:*)\n+\techo i860-intel-osf1\n+\texit ;;\n+    i860:*:4.*:*) # i860-SVR4\n+\tif grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then\n+\t  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4\n+\telse # Add other i860-SVR4 vendors below as they are discovered.\n+\t  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4\n+\tfi\n+\texit ;;\n+    mini*:CTIX:SYS*5:*)\n+\t# \"miniframe\"\n+\techo m68010-convergent-sysv\n+\texit ;;\n+    mc68k:UNIX:SYSTEM5:3.51m)\n+\techo m68k-convergent-sysv\n+\texit ;;\n+    M680?0:D-NIX:5.3:*)\n+\techo m68k-diab-dnix\n+\texit ;;\n+    M68*:*:R3V[5678]*:*)\n+\ttest -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;\n+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)\n+\tOS_REL=''\n+\ttest -r /etc/.relid \\\n+\t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }\n+\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n+\t  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;\n+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t  && { echo i486-ncr-sysv4; exit; } ;;\n+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)\n+\tOS_REL='.3'\n+\ttest -r /etc/.relid \\\n+\t    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }\n+\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n+\t    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }\n+\t/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \\\n+\t    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;\n+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)\n+\techo m68k-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    mc68030:UNIX_System_V:4.*:*)\n+\techo m68k-atari-sysv4\n+\texit ;;\n+    TSUNAMI:LynxOS:2.*:*)\n+\techo sparc-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    rs6000:LynxOS:2.*:*)\n+\techo rs6000-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)\n+\techo powerpc-unknown-lynxos${UNAME_RELEASE}\n+\texit ;;\n+    SM[BE]S:UNIX_SV:*:*)\n+\techo mips-dde-sysv${UNAME_RELEASE}\n+\texit ;;\n+    RM*:ReliantUNIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit ;;\n+    RM*:SINIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit ;;\n+    *:SINIX-*:*:*)\n+\tif uname -p 2>/dev/null >/dev/null ; then\n+\t\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n+\t\techo ${UNAME_MACHINE}-sni-sysv4\n+\telse\n+\t\techo ns32k-sni-sysv\n+\tfi\n+\texit ;;\n+    PENTIUM:*:4.0*:*)\t# Unisys `ClearPath HMP IX 4000' SVR4/MP effort\n+\t\t\t# says <Richard.M.Bartel@ccMail.Census.GOV>\n+\techo i586-unisys-sysv4\n+\texit ;;\n+    *:UNIX_System_V:4*:FTX*)\n+\t# From Gerald Hewes <hewes@openmarket.com>.\n+\t# How about differentiating between stratus architectures? -djm\n+\techo hppa1.1-stratus-sysv4\n+\texit ;;\n+    *:*:*:FTX*)\n+\t# From seanf@swdc.stratus.com.\n+\techo i860-stratus-sysv4\n+\texit ;;\n+    i*86:VOS:*:*)\n+\t# From Paul.Green@stratus.com.\n+\techo ${UNAME_MACHINE}-stratus-vos\n+\texit ;;\n+    *:VOS:*:*)\n+\t# From Paul.Green@stratus.com.\n+\techo hppa1.1-stratus-vos\n+\texit ;;\n+    mc68*:A/UX:*:*)\n+\techo m68k-apple-aux${UNAME_RELEASE}\n+\texit ;;\n+    news*:NEWS-OS:6*:*)\n+\techo mips-sony-newsos6\n+\texit ;;\n+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)\n+\tif [ -d /usr/nec ]; then\n+\t\techo mips-nec-sysv${UNAME_RELEASE}\n+\telse\n+\t\techo mips-unknown-sysv${UNAME_RELEASE}\n+\tfi\n+\texit ;;\n+    BeBox:BeOS:*:*)\t# BeOS running on hardware made by Be, PPC only.\n+\techo powerpc-be-beos\n+\texit ;;\n+    BeMac:BeOS:*:*)\t# BeOS running on Mac or Mac clone, PPC only.\n+\techo powerpc-apple-beos\n+\texit ;;\n+    BePC:BeOS:*:*)\t# BeOS running on Intel PC compatible.\n+\techo i586-pc-beos\n+\texit ;;\n+    BePC:Haiku:*:*)\t# Haiku running on Intel PC compatible.\n+\techo i586-pc-haiku\n+\texit ;;\n+    x86_64:Haiku:*:*)\n+\techo x86_64-unknown-haiku\n+\texit ;;\n+    SX-4:SUPER-UX:*:*)\n+\techo sx4-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-5:SUPER-UX:*:*)\n+\techo sx5-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-6:SUPER-UX:*:*)\n+\techo sx6-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-7:SUPER-UX:*:*)\n+\techo sx7-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-8:SUPER-UX:*:*)\n+\techo sx8-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    SX-8R:SUPER-UX:*:*)\n+\techo sx8r-nec-superux${UNAME_RELEASE}\n+\texit ;;\n+    Power*:Rhapsody:*:*)\n+\techo powerpc-apple-rhapsody${UNAME_RELEASE}\n+\texit ;;\n+    *:Rhapsody:*:*)\n+\techo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}\n+\texit ;;\n+    *:Darwin:*:*)\n+\tUNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown\n+\teval $set_cc_for_build\n+\tif test \"$UNAME_PROCESSOR\" = unknown ; then\n+\t    UNAME_PROCESSOR=powerpc\n+\tfi\n+\tif [ \"$CC_FOR_BUILD\" != 'no_compiler_found' ]; then\n+\t    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \\\n+\t\t(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \\\n+\t\tgrep IS_64BIT_ARCH >/dev/null\n+\t    then\n+\t\tcase $UNAME_PROCESSOR in\n+\t\t    i386) UNAME_PROCESSOR=x86_64 ;;\n+\t\t    powerpc) UNAME_PROCESSOR=powerpc64 ;;\n+\t\tesac\n+\t    fi\n+\tfi\n+\techo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}\n+\texit ;;\n+    *:procnto*:*:* | *:QNX:[0123456789]*:*)\n+\tUNAME_PROCESSOR=`uname -p`\n+\tif test \"$UNAME_PROCESSOR\" = \"x86\"; then\n+\t\tUNAME_PROCESSOR=i386\n+\t\tUNAME_MACHINE=pc\n+\tfi\n+\techo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}\n+\texit ;;\n+    *:QNX:*:4*)\n+\techo i386-pc-qnx\n+\texit ;;\n+    NEO-?:NONSTOP_KERNEL:*:*)\n+\techo neo-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    NSE-*:NONSTOP_KERNEL:*:*)\n+\techo nse-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    NSR-?:NONSTOP_KERNEL:*:*)\n+\techo nsr-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n+    *:NonStop-UX:*:*)\n+\techo mips-compaq-nonstopux\n+\texit ;;\n+    BS2000:POSIX*:*:*)\n+\techo bs2000-siemens-sysv\n+\texit ;;\n+    DS/*:UNIX_System_V:*:*)\n+\techo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}\n+\texit ;;\n+    *:Plan9:*:*)\n+\t# \"uname -m\" is not consistent, so use $cputype instead. 386\n+\t# is converted to i386 for consistency with other x86\n+\t# operating systems.\n+\tif test \"$cputype\" = \"386\"; then\n+\t    UNAME_MACHINE=i386\n+\telse\n+\t    UNAME_MACHINE=\"$cputype\"\n+\tfi\n+\techo ${UNAME_MACHINE}-unknown-plan9\n+\texit ;;\n+    *:TOPS-10:*:*)\n+\techo pdp10-unknown-tops10\n+\texit ;;\n+    *:TENEX:*:*)\n+\techo pdp10-unknown-tenex\n+\texit ;;\n+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)\n+\techo pdp10-dec-tops20\n+\texit ;;\n+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)\n+\techo pdp10-xkl-tops20\n+\texit ;;\n+    *:TOPS-20:*:*)\n+\techo pdp10-unknown-tops20\n+\texit ;;\n+    *:ITS:*:*)\n+\techo pdp10-unknown-its\n+\texit ;;\n+    SEI:*:*:SEIUX)\n+\techo mips-sei-seiux${UNAME_RELEASE}\n+\texit ;;\n+    *:DragonFly:*:*)\n+\techo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`\n+\texit ;;\n+    *:*VMS:*:*)\n+\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n+\tcase \"${UNAME_MACHINE}\" in\n+\t    A*) echo alpha-dec-vms ; exit ;;\n+\t    I*) echo ia64-dec-vms ; exit ;;\n+\t    V*) echo vax-dec-vms ; exit ;;\n+\tesac ;;\n+    *:XENIX:*:SysV)\n+\techo i386-pc-xenix\n+\texit ;;\n+    i*86:skyos:*:*)\n+\techo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'\n+\texit ;;\n+    i*86:rdos:*:*)\n+\techo ${UNAME_MACHINE}-pc-rdos\n+\texit ;;\n+    i*86:AROS:*:*)\n+\techo ${UNAME_MACHINE}-pc-aros\n+\texit ;;\n+    x86_64:VMkernel:*:*)\n+\techo ${UNAME_MACHINE}-unknown-esx\n+\texit ;;\n+esac\n+\n+eval $set_cc_for_build\n+cat >$dummy.c <<EOF\n+#ifdef _SEQUENT_\n+# include <sys/types.h>\n+# include <sys/utsname.h>\n+#endif\n+main ()\n+{\n+#if defined (sony)\n+#if defined (MIPSEB)\n+  /* BFD wants \"bsd\" instead of \"newsos\".  Perhaps BFD should be changed,\n+     I don't know....  */\n+  printf (\"mips-sony-bsd\\n\"); exit (0);\n+#else\n+#include <sys/param.h>\n+  printf (\"m68k-sony-newsos%s\\n\",\n+#ifdef NEWSOS4\n+\t\"4\"\n+#else\n+\t\"\"\n+#endif\n+\t); exit (0);\n+#endif\n+#endif\n+\n+#if defined (__arm) && defined (__acorn) && defined (__unix)\n+  printf (\"arm-acorn-riscix\\n\"); exit (0);\n+#endif\n+\n+#if defined (hp300) && !defined (hpux)\n+  printf (\"m68k-hp-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (NeXT)\n+#if !defined (__ARCHITECTURE__)\n+#define __ARCHITECTURE__ \"m68k\"\n+#endif\n+  int version;\n+  version=`(hostinfo | sed -n 's/.*NeXT Mach \\([0-9]*\\).*/\\1/p') 2>/dev/null`;\n+  if (version < 4)\n+    printf (\"%s-next-nextstep%d\\n\", __ARCHITECTURE__, version);\n+  else\n+    printf (\"%s-next-openstep%d\\n\", __ARCHITECTURE__, version);\n+  exit (0);\n+#endif\n+\n+#if defined (MULTIMAX) || defined (n16)\n+#if defined (UMAXV)\n+  printf (\"ns32k-encore-sysv\\n\"); exit (0);\n+#else\n+#if defined (CMU)\n+  printf (\"ns32k-encore-mach\\n\"); exit (0);\n+#else\n+  printf (\"ns32k-encore-bsd\\n\"); exit (0);\n+#endif\n+#endif\n+#endif\n+\n+#if defined (__386BSD__)\n+  printf (\"i386-pc-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (sequent)\n+#if defined (i386)\n+  printf (\"i386-sequent-dynix\\n\"); exit (0);\n+#endif\n+#if defined (ns32000)\n+  printf (\"ns32k-sequent-dynix\\n\"); exit (0);\n+#endif\n+#endif\n+\n+#if defined (_SEQUENT_)\n+    struct utsname un;\n+\n+    uname(&un);\n+\n+    if (strncmp(un.version, \"V2\", 2) == 0) {\n+\tprintf (\"i386-sequent-ptx2\\n\"); exit (0);\n+    }\n+    if (strncmp(un.version, \"V1\", 2) == 0) { /* XXX is V1 correct? */\n+\tprintf (\"i386-sequent-ptx1\\n\"); exit (0);\n+    }\n+    printf (\"i386-sequent-ptx\\n\"); exit (0);\n+\n+#endif\n+\n+#if defined (vax)\n+# if !defined (ultrix)\n+#  include <sys/param.h>\n+#  if defined (BSD)\n+#   if BSD == 43\n+      printf (\"vax-dec-bsd4.3\\n\"); exit (0);\n+#   else\n+#    if BSD == 199006\n+      printf (\"vax-dec-bsd4.3reno\\n\"); exit (0);\n+#    else\n+      printf (\"vax-dec-bsd\\n\"); exit (0);\n+#    endif\n+#   endif\n+#  else\n+    printf (\"vax-dec-bsd\\n\"); exit (0);\n+#  endif\n+# else\n+    printf (\"vax-dec-ultrix\\n\"); exit (0);\n+# endif\n+#endif\n+\n+#if defined (alliant) && defined (i860)\n+  printf (\"i860-alliant-bsd\\n\"); exit (0);\n+#endif\n+\n+  exit (1);\n+}\n+EOF\n+\n+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&\n+\t{ echo \"$SYSTEM_NAME\"; exit; }\n+\n+# Apollos put the system type in the environment.\n+\n+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }\n+\n+# Convex versions that predate uname can use getsysinfo(1)\n+\n+if [ -x /usr/convex/getsysinfo ]\n+then\n+    case `getsysinfo -f cpu_type` in\n+    c1*)\n+\techo c1-convex-bsd\n+\texit ;;\n+    c2*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+\texit ;;\n+    c34*)\n+\techo c34-convex-bsd\n+\texit ;;\n+    c38*)\n+\techo c38-convex-bsd\n+\texit ;;\n+    c4*)\n+\techo c4-convex-bsd\n+\texit ;;\n+    esac\n+fi\n+\n+cat >&2 <<EOF\n+$0: unable to guess system type\n+\n+This script, last modified $timestamp, has failed to recognize\n+the operating system you are using. It is advised that you\n+download the most up to date version of the config scripts from\n+\n+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD\n+and\n+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD\n+\n+If the version you run ($0) is already up to date, please\n+send the following data and any information you think might be\n+pertinent to <config-patches@gnu.org> in order to provide the needed\n+information to handle your system.\n+\n+config.guess timestamp = $timestamp\n+\n+uname -m = `(uname -m) 2>/dev/null || echo unknown`\n+uname -r = `(uname -r) 2>/dev/null || echo unknown`\n+uname -s = `(uname -s) 2>/dev/null || echo unknown`\n+uname -v = `(uname -v) 2>/dev/null || echo unknown`\n+\n+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`\n+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`\n+\n+hostinfo               = `(hostinfo) 2>/dev/null`\n+/bin/universe          = `(/bin/universe) 2>/dev/null`\n+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`\n+/bin/arch              = `(/bin/arch) 2>/dev/null`\n+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`\n+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`\n+\n+UNAME_MACHINE = ${UNAME_MACHINE}\n+UNAME_RELEASE = ${UNAME_RELEASE}\n+UNAME_SYSTEM  = ${UNAME_SYSTEM}\n+UNAME_VERSION = ${UNAME_VERSION}\n+EOF\n+\n+exit 1\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"timestamp='\"\n+# time-stamp-format: \"%:y-%02m-%02d\"\n+# time-stamp-end: \"'\"\n+# End:"}, {"sha": "87cb805984d4f06782ed96a509fe18a290377f33", "filename": "src/libbacktrace/config.h.in", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.h.in?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,134 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* ELF size: 32 or 64 */\n+#undef BACKTRACE_ELF_SIZE\n+\n+/* Define to 1 if you have the __atomic functions */\n+#undef HAVE_ATOMIC_FUNCTIONS\n+\n+/* Define to 1 if you have the declaration of `strnlen', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_STRNLEN\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define if dl_iterate_phdr is available. */\n+#undef HAVE_DL_ITERATE_PHDR\n+\n+/* Define to 1 if you have the fcntl function */\n+#undef HAVE_FCNTL\n+\n+/* Define if getexecname is available. */\n+#undef HAVE_GETEXECNAME\n+\n+/* Define if _Unwind_GetIPInfo is available. */\n+#undef HAVE_GETIPINFO\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <link.h> header file. */\n+#undef HAVE_LINK_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the __sync functions */\n+#undef HAVE_SYNC_FUNCTIONS\n+\n+/* Define to 1 if you have the <sys/mman.h> header file. */\n+#undef HAVE_SYS_MMAN_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* The size of `char', as computed by sizeof. */\n+#undef SIZEOF_CHAR\n+\n+/* The size of `int', as computed by sizeof. */\n+#undef SIZEOF_INT\n+\n+/* The size of `long', as computed by sizeof. */\n+#undef SIZEOF_LONG\n+\n+/* The size of `short', as computed by sizeof. */\n+#undef SIZEOF_SHORT\n+\n+/* The size of `void *', as computed by sizeof. */\n+#undef SIZEOF_VOID_P\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Enable extensions on AIX 3, Interix.  */\n+#ifndef _ALL_SOURCE\n+# undef _ALL_SOURCE\n+#endif\n+/* Enable GNU extensions on systems that have them.  */\n+#ifndef _GNU_SOURCE\n+# undef _GNU_SOURCE\n+#endif\n+/* Enable threading extensions on Solaris.  */\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# undef _POSIX_PTHREAD_SEMANTICS\n+#endif\n+/* Enable extensions on HP NonStop.  */\n+#ifndef _TANDEM_SOURCE\n+# undef _TANDEM_SOURCE\n+#endif\n+/* Enable general extensions on Solaris.  */\n+#ifndef __EXTENSIONS__\n+# undef __EXTENSIONS__\n+#endif\n+\n+\n+/* Define to 1 if on MINIX. */\n+#undef _MINIX\n+\n+/* Define to 2 if the system does not provide POSIX.1 features except with\n+   this defined. */\n+#undef _POSIX_1_SOURCE\n+\n+/* Define to 1 if you need to in order for `stat' and other things to work. */\n+#undef _POSIX_SOURCE"}, {"sha": "61cb4bc22db8e0a490b5ea5bffe6575c10ff92e0", "filename": "src/libbacktrace/config.sub", "status": "added", "additions": 1793, "deletions": 0, "changes": 1793, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.sub?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,1793 @@\n+#! /bin/sh\n+# Configuration validation subroutine script.\n+#   Copyright 1992-2013 Free Software Foundation, Inc.\n+\n+timestamp='2013-10-01'\n+\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, see <http://www.gnu.org/licenses/>.\n+#\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that\n+# program.  This Exception is an additional permission under section 7\n+# of the GNU General Public License, version 3 (\"GPLv3\").\n+\n+\n+# Please send patches with a ChangeLog entry to config-patches@gnu.org.\n+#\n+# Configuration subroutine to validate and canonicalize a configuration type.\n+# Supply the specified configuration type as an argument.\n+# If it is invalid, we print an error message on stderr and exit with code 1.\n+# Otherwise, we print the canonical config type on stdout and succeed.\n+\n+# You can get the latest version of this script from:\n+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD\n+\n+# This file is supposed to be the same for all GNU packages\n+# and recognize all the CPU types, system types and aliases\n+# that are meaningful with *any* GNU software.\n+# Each package is responsible for reporting which valid configurations\n+# it does not support.  The user should be able to distinguish\n+# a failure to support a valid configuration from a meaningless\n+# configuration.\n+\n+# The goal of this file is to map all the various variations of a given\n+# machine specification into a single specification in the form:\n+#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n+# or in some cases, the newer four-part form:\n+#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n+# It is wrong to echo any other type of specification.\n+\n+me=`echo \"$0\" | sed -e 's,.*/,,'`\n+\n+usage=\"\\\n+Usage: $0 [OPTION] CPU-MFR-OPSYS\n+       $0 [OPTION] ALIAS\n+\n+Canonicalize a configuration name.\n+\n+Operation modes:\n+  -h, --help         print this help, then exit\n+  -t, --time-stamp   print date of last modification, then exit\n+  -v, --version      print version number, then exit\n+\n+Report bugs and patches to <config-patches@gnu.org>.\"\n+\n+version=\"\\\n+GNU config.sub ($timestamp)\n+\n+Copyright 1992-2013 Free Software Foundation, Inc.\n+\n+This is free software; see the source for copying conditions.  There is NO\n+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\"\n+\n+help=\"\n+Try \\`$me --help' for more information.\"\n+\n+# Parse command line\n+while test $# -gt 0 ; do\n+  case $1 in\n+    --time-stamp | --time* | -t )\n+       echo \"$timestamp\" ; exit ;;\n+    --version | -v )\n+       echo \"$version\" ; exit ;;\n+    --help | --h* | -h )\n+       echo \"$usage\"; exit ;;\n+    -- )     # Stop option processing\n+       shift; break ;;\n+    - )\t# Use stdin as input.\n+       break ;;\n+    -* )\n+       echo \"$me: invalid option $1$help\"\n+       exit 1 ;;\n+\n+    *local*)\n+       # First pass through any local machine types.\n+       echo $1\n+       exit ;;\n+\n+    * )\n+       break ;;\n+  esac\n+done\n+\n+case $# in\n+ 0) echo \"$me: missing argument$help\" >&2\n+    exit 1;;\n+ 1) ;;\n+ *) echo \"$me: too many arguments$help\" >&2\n+    exit 1;;\n+esac\n+\n+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).\n+# Here we must recognize all the valid KERNEL-OS combinations.\n+maybe_os=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\2/'`\n+case $maybe_os in\n+  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \\\n+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \\\n+  knetbsd*-gnu* | netbsd*-gnu* | \\\n+  kopensolaris*-gnu* | \\\n+  storm-chaos* | os2-emx* | rtmk-nova*)\n+    os=-$maybe_os\n+    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`\n+    ;;\n+  android-linux)\n+    os=-linux-android\n+    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`-unknown\n+    ;;\n+  *)\n+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`\n+    if [ $basic_machine != $1 ]\n+    then os=`echo $1 | sed 's/.*-/-/'`\n+    else os=; fi\n+    ;;\n+esac\n+\n+### Let's recognize common machines as not being operating systems so\n+### that things like config.sub decstation-3100 work.  We also\n+### recognize some manufacturers as not being operating systems, so we\n+### can provide default operating systems below.\n+case $os in\n+\t-sun*os*)\n+\t\t# Prevent following clause from handling this invalid input.\n+\t\t;;\n+\t-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \\\n+\t-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \\\n+\t-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \\\n+\t-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\\\n+\t-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \\\n+\t-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \\\n+\t-apple | -axis | -knuth | -cray | -microblaze*)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-bluegene*)\n+\t\tos=-cnk\n+\t\t;;\n+\t-sim | -cisco | -oki | -wec | -winbond)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-scout)\n+\t\t;;\n+\t-wrs)\n+\t\tos=-vxworks\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-chorusos*)\n+\t\tos=-chorusos\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-chorusrdb)\n+\t\tos=-chorusrdb\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-hiux*)\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\t-sco6)\n+\t\tos=-sco5v6\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco5)\n+\t\tos=-sco3.2v5\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco4)\n+\t\tos=-sco3.2v4\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2.[4-9]*)\n+\t\tos=`echo $os | sed -e 's/sco3.2./sco3.2v/'`\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2v[4-9]*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco5v6*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco*)\n+\t\tos=-sco3.2v2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-udk*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-isc)\n+\t\tos=-isc2.2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-clix*)\n+\t\tbasic_machine=clipper-intergraph\n+\t\t;;\n+\t-isc*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-lynx*178)\n+\t\tos=-lynxos178\n+\t\t;;\n+\t-lynx*5)\n+\t\tos=-lynxos5\n+\t\t;;\n+\t-lynx*)\n+\t\tos=-lynxos\n+\t\t;;\n+\t-ptx*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`\n+\t\t;;\n+\t-windowsnt*)\n+\t\tos=`echo $os | sed -e 's/windowsnt/winnt/'`\n+\t\t;;\n+\t-psos*)\n+\t\tos=-psos\n+\t\t;;\n+\t-mint | -mint[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+esac\n+\n+# Decode aliases for certain CPU-COMPANY combinations.\n+case $basic_machine in\n+\t# Recognize the basic CPU types without company name.\n+\t# Some are omitted here because they have special meanings below.\n+\t1750a | 580 \\\n+\t| a29k \\\n+\t| aarch64 | aarch64_be \\\n+\t| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \\\n+\t| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \\\n+\t| am33_2.0 \\\n+\t| arc | arceb \\\n+\t| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \\\n+\t| avr | avr32 \\\n+\t| be32 | be64 \\\n+\t| bfin \\\n+\t| c4x | c8051 | clipper \\\n+\t| d10v | d30v | dlx | dsp16xx \\\n+\t| epiphany \\\n+\t| fido | fr30 | frv \\\n+\t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n+\t| hexagon \\\n+\t| i370 | i860 | i960 | ia64 \\\n+\t| ip2k | iq2000 \\\n+\t| k1om \\\n+\t| le32 | le64 \\\n+\t| lm32 \\\n+\t| m32c | m32r | m32rle | m68000 | m68k | m88k \\\n+\t| maxq | mb | microblaze | microblazeel | mcore | mep | metag \\\n+\t| mips | mipsbe | mipseb | mipsel | mipsle \\\n+\t| mips16 \\\n+\t| mips64 | mips64el \\\n+\t| mips64octeon | mips64octeonel \\\n+\t| mips64orion | mips64orionel \\\n+\t| mips64r5900 | mips64r5900el \\\n+\t| mips64vr | mips64vrel \\\n+\t| mips64vr4100 | mips64vr4100el \\\n+\t| mips64vr4300 | mips64vr4300el \\\n+\t| mips64vr5000 | mips64vr5000el \\\n+\t| mips64vr5900 | mips64vr5900el \\\n+\t| mipsisa32 | mipsisa32el \\\n+\t| mipsisa32r2 | mipsisa32r2el \\\n+\t| mipsisa64 | mipsisa64el \\\n+\t| mipsisa64r2 | mipsisa64r2el \\\n+\t| mipsisa64sb1 | mipsisa64sb1el \\\n+\t| mipsisa64sr71k | mipsisa64sr71kel \\\n+\t| mipsr5900 | mipsr5900el \\\n+\t| mipstx39 | mipstx39el \\\n+\t| mn10200 | mn10300 \\\n+\t| moxie \\\n+\t| mt \\\n+\t| msp430 \\\n+\t| nds32 | nds32le | nds32be \\\n+\t| nios | nios2 | nios2eb | nios2el \\\n+\t| ns16k | ns32k \\\n+\t| open8 \\\n+\t| or1k | or32 \\\n+\t| pdp10 | pdp11 | pj | pjl \\\n+\t| powerpc | powerpc64 | powerpc64le | powerpcle \\\n+\t| pyramid \\\n+\t| rl78 | rx \\\n+\t| score \\\n+\t| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \\\n+\t| sh64 | sh64le \\\n+\t| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \\\n+\t| sparcv8 | sparcv9 | sparcv9b | sparcv9v \\\n+\t| spu \\\n+\t| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \\\n+\t| ubicom32 \\\n+\t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n+\t| we32k \\\n+\t| x86 | xc16x | xstormy16 | xtensa \\\n+\t| z8k | z80)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\tc54x)\n+\t\tbasic_machine=tic54x-unknown\n+\t\t;;\n+\tc55x)\n+\t\tbasic_machine=tic55x-unknown\n+\t\t;;\n+\tc6x)\n+\t\tbasic_machine=tic6x-unknown\n+\t\t;;\n+\tm6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-none\n+\t\t;;\n+\tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)\n+\t\t;;\n+\tms1)\n+\t\tbasic_machine=mt-unknown\n+\t\t;;\n+\n+\tstrongarm | thumb | xscale)\n+\t\tbasic_machine=arm-unknown\n+\t\t;;\n+\txgate)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-none\n+\t\t;;\n+\txscaleeb)\n+\t\tbasic_machine=armeb-unknown\n+\t\t;;\n+\n+\txscaleel)\n+\t\tbasic_machine=armel-unknown\n+\t\t;;\n+\n+\t# We use `pc' rather than `unknown'\n+\t# because (1) that's what they normally are, and\n+\t# (2) the word \"unknown\" tends to confuse beginning users.\n+\ti*86 | x86_64)\n+\t  basic_machine=$basic_machine-pc\n+\t  ;;\n+\t# Object if more than one company name word.\n+\t*-*-*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+\t# Recognize the basic CPU types with company name.\n+\t580-* \\\n+\t| a29k-* \\\n+\t| aarch64-* | aarch64_be-* \\\n+\t| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \\\n+\t| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \\\n+\t| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \\\n+\t| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \\\n+\t| avr-* | avr32-* \\\n+\t| be32-* | be64-* \\\n+\t| bfin-* | bs2000-* \\\n+\t| c[123]* | c30-* | [cjt]90-* | c4x-* \\\n+\t| c8051-* | clipper-* | craynv-* | cydra-* \\\n+\t| d10v-* | d30v-* | dlx-* \\\n+\t| elxsi-* \\\n+\t| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \\\n+\t| h8300-* | h8500-* \\\n+\t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n+\t| hexagon-* \\\n+\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| ip2k-* | iq2000-* \\\n+\t| k1om-* \\\n+\t| le32-* | le64-* \\\n+\t| lm32-* \\\n+\t| m32c-* | m32r-* | m32rle-* \\\n+\t| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \\\n+\t| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \\\n+\t| microblaze-* | microblazeel-* \\\n+\t| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \\\n+\t| mips16-* \\\n+\t| mips64-* | mips64el-* \\\n+\t| mips64octeon-* | mips64octeonel-* \\\n+\t| mips64orion-* | mips64orionel-* \\\n+\t| mips64r5900-* | mips64r5900el-* \\\n+\t| mips64vr-* | mips64vrel-* \\\n+\t| mips64vr4100-* | mips64vr4100el-* \\\n+\t| mips64vr4300-* | mips64vr4300el-* \\\n+\t| mips64vr5000-* | mips64vr5000el-* \\\n+\t| mips64vr5900-* | mips64vr5900el-* \\\n+\t| mipsisa32-* | mipsisa32el-* \\\n+\t| mipsisa32r2-* | mipsisa32r2el-* \\\n+\t| mipsisa64-* | mipsisa64el-* \\\n+\t| mipsisa64r2-* | mipsisa64r2el-* \\\n+\t| mipsisa64sb1-* | mipsisa64sb1el-* \\\n+\t| mipsisa64sr71k-* | mipsisa64sr71kel-* \\\n+\t| mipsr5900-* | mipsr5900el-* \\\n+\t| mipstx39-* | mipstx39el-* \\\n+\t| mmix-* \\\n+\t| mt-* \\\n+\t| msp430-* \\\n+\t| nds32-* | nds32le-* | nds32be-* \\\n+\t| nios-* | nios2-* | nios2eb-* | nios2el-* \\\n+\t| none-* | np1-* | ns16k-* | ns32k-* \\\n+\t| open8-* \\\n+\t| orion-* \\\n+\t| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \\\n+\t| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \\\n+\t| pyramid-* \\\n+\t| rl78-* | romp-* | rs6000-* | rx-* \\\n+\t| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \\\n+\t| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \\\n+\t| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \\\n+\t| sparclite-* \\\n+\t| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \\\n+\t| tahoe-* \\\n+\t| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \\\n+\t| tile*-* \\\n+\t| tron-* \\\n+\t| ubicom32-* \\\n+\t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n+\t| vax-* \\\n+\t| we32k-* \\\n+\t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n+\t| xstormy16-* | xtensa*-* \\\n+\t| ymp-* \\\n+\t| z8k-* | z80-*)\n+\t\t;;\n+\t# Recognize the basic CPU types without company name, with glob match.\n+\txtensa*)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\t# Recognize the various machine names and aliases which stand\n+\t# for a CPU type and a company and sometimes even an OS.\n+\t386bsd)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-bsd\n+\t\t;;\n+\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n+\t\tbasic_machine=m68000-att\n+\t\t;;\n+\t3b*)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\ta29khif)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tabacus)\n+\t\tbasic_machine=abacus-unknown\n+\t\t;;\n+\tadobe68k)\n+\t\tbasic_machine=m68010-adobe\n+\t\tos=-scout\n+\t\t;;\n+\talliant | fx80)\n+\t\tbasic_machine=fx80-alliant\n+\t\t;;\n+\taltos | altos3068)\n+\t\tbasic_machine=m68k-altos\n+\t\t;;\n+\tam29k)\n+\t\tbasic_machine=a29k-none\n+\t\tos=-bsd\n+\t\t;;\n+\tamd64)\n+\t\tbasic_machine=x86_64-pc\n+\t\t;;\n+\tamd64-*)\n+\t\tbasic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tamdahl)\n+\t\tbasic_machine=580-amdahl\n+\t\tos=-sysv\n+\t\t;;\n+\tamiga | amiga-*)\n+\t\tbasic_machine=m68k-unknown\n+\t\t;;\n+\tamigaos | amigados)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-amigaos\n+\t\t;;\n+\tamigaunix | amix)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-sysv4\n+\t\t;;\n+\tapollo68)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-sysv\n+\t\t;;\n+\tapollo68bsd)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-bsd\n+\t\t;;\n+\taros)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-aros\n+\t\t;;\n+\taux)\n+\t\tbasic_machine=m68k-apple\n+\t\tos=-aux\n+\t\t;;\n+\tbalance)\n+\t\tbasic_machine=ns32k-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tblackfin)\n+\t\tbasic_machine=bfin-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tblackfin-*)\n+\t\tbasic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tbluegene*)\n+\t\tbasic_machine=powerpc-ibm\n+\t\tos=-cnk\n+\t\t;;\n+\tc54x-*)\n+\t\tbasic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tc55x-*)\n+\t\tbasic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tc6x-*)\n+\t\tbasic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tc90)\n+\t\tbasic_machine=c90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tcegcc)\n+\t\tbasic_machine=arm-unknown\n+\t\tos=-cegcc\n+\t\t;;\n+\tconvex-c1)\n+\t\tbasic_machine=c1-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c2)\n+\t\tbasic_machine=c2-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c32)\n+\t\tbasic_machine=c32-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c34)\n+\t\tbasic_machine=c34-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c38)\n+\t\tbasic_machine=c38-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tcray | j90)\n+\t\tbasic_machine=j90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tcraynv)\n+\t\tbasic_machine=craynv-cray\n+\t\tos=-unicosmp\n+\t\t;;\n+\tcr16 | cr16-*)\n+\t\tbasic_machine=cr16-unknown\n+\t\tos=-elf\n+\t\t;;\n+\tcrds | unos)\n+\t\tbasic_machine=m68k-crds\n+\t\t;;\n+\tcrisv32 | crisv32-* | etraxfs*)\n+\t\tbasic_machine=crisv32-axis\n+\t\t;;\n+\tcris | cris-* | etrax*)\n+\t\tbasic_machine=cris-axis\n+\t\t;;\n+\tcrx)\n+\t\tbasic_machine=crx-unknown\n+\t\tos=-elf\n+\t\t;;\n+\tda30 | da30-*)\n+\t\tbasic_machine=m68k-da30\n+\t\t;;\n+\tdecstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)\n+\t\tbasic_machine=mips-dec\n+\t\t;;\n+\tdecsystem10* | dec10*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops10\n+\t\t;;\n+\tdecsystem20* | dec20*)\n+\t\tbasic_machine=pdp10-dec\n+\t\tos=-tops20\n+\t\t;;\n+\tdelta | 3300 | motorola-3300 | motorola-delta \\\n+\t      | 3300-motorola | delta-motorola)\n+\t\tbasic_machine=m68k-motorola\n+\t\t;;\n+\tdelta88)\n+\t\tbasic_machine=m88k-motorola\n+\t\tos=-sysv3\n+\t\t;;\n+\tdicos)\n+\t\tbasic_machine=i686-pc\n+\t\tos=-dicos\n+\t\t;;\n+\tdjgpp)\n+\t\tbasic_machine=i586-pc\n+\t\tos=-msdosdjgpp\n+\t\t;;\n+\tdpx20 | dpx20-*)\n+\t\tbasic_machine=rs6000-bull\n+\t\tos=-bosx\n+\t\t;;\n+\tdpx2* | dpx2*-bull)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv3\n+\t\t;;\n+\tebmon29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-ebmon\n+\t\t;;\n+\telxsi)\n+\t\tbasic_machine=elxsi-elxsi\n+\t\tos=-bsd\n+\t\t;;\n+\tencore | umax | mmax)\n+\t\tbasic_machine=ns32k-encore\n+\t\t;;\n+\tes1800 | OSE68k | ose68k | ose | OSE)\n+\t\tbasic_machine=m68k-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tfx2800)\n+\t\tbasic_machine=i860-alliant\n+\t\t;;\n+\tgenix)\n+\t\tbasic_machine=ns32k-ns\n+\t\t;;\n+\tgmicro)\n+\t\tbasic_machine=tron-gmicro\n+\t\tos=-sysv\n+\t\t;;\n+\tgo32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-go32\n+\t\t;;\n+\th3050r* | hiux*)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\th8300hms)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\th8300xray)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-xray\n+\t\t;;\n+\th8500hms)\n+\t\tbasic_machine=h8500-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tharris)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-sysv3\n+\t\t;;\n+\thp300-*)\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp300bsd)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-bsd\n+\t\t;;\n+\thp300hpux)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-hpux\n+\t\t;;\n+\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k2[0-9][0-9] | hp9k31[0-9])\n+\t\tbasic_machine=m68000-hp\n+\t\t;;\n+\thp9k3[2-9][0-9])\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k78[0-9] | hp78[0-9])\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][13679] | hp8[0-9][13679])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thppa-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+\thppaosf)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-osf\n+\t\t;;\n+\thppro)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-proelf\n+\t\t;;\n+\ti370-ibm* | ibm*)\n+\t\tbasic_machine=i370-ibm\n+\t\t;;\n+\ti*86v32)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv32\n+\t\t;;\n+\ti*86v4*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv4\n+\t\t;;\n+\ti*86v)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv\n+\t\t;;\n+\ti*86sol2)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-solaris2\n+\t\t;;\n+\ti386mach)\n+\t\tbasic_machine=i386-mach\n+\t\tos=-mach\n+\t\t;;\n+\ti386-vsta | vsta)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-vsta\n+\t\t;;\n+\tiris | iris4d)\n+\t\tbasic_machine=mips-sgi\n+\t\tcase $os in\n+\t\t    -irix*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-irix4\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tisi68 | isi)\n+\t\tbasic_machine=m68k-isi\n+\t\tos=-sysv\n+\t\t;;\n+\tm68knommu)\n+\t\tbasic_machine=m68k-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tm68knommu-*)\n+\t\tbasic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tm88k-omron*)\n+\t\tbasic_machine=m88k-omron\n+\t\t;;\n+\tmagnum | m3230)\n+\t\tbasic_machine=mips-mips\n+\t\tos=-sysv\n+\t\t;;\n+\tmerlin)\n+\t\tbasic_machine=ns32k-utek\n+\t\tos=-sysv\n+\t\t;;\n+\tmicroblaze*)\n+\t\tbasic_machine=microblaze-xilinx\n+\t\t;;\n+\tmingw64)\n+\t\tbasic_machine=x86_64-pc\n+\t\tos=-mingw64\n+\t\t;;\n+\tmingw32)\n+\t\tbasic_machine=i686-pc\n+\t\tos=-mingw32\n+\t\t;;\n+\tmingw32ce)\n+\t\tbasic_machine=arm-unknown\n+\t\tos=-mingw32ce\n+\t\t;;\n+\tminiframe)\n+\t\tbasic_machine=m68000-convergent\n+\t\t;;\n+\t*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+\tmips3*-*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`\n+\t\t;;\n+\tmips3*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown\n+\t\t;;\n+\tmonitor)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\tmorphos)\n+\t\tbasic_machine=powerpc-unknown\n+\t\tos=-morphos\n+\t\t;;\n+\tmsdos)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-msdos\n+\t\t;;\n+\tms1-*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`\n+\t\t;;\n+\tmsys)\n+\t\tbasic_machine=i686-pc\n+\t\tos=-msys\n+\t\t;;\n+\tmvs)\n+\t\tbasic_machine=i370-ibm\n+\t\tos=-mvs\n+\t\t;;\n+\tnacl)\n+\t\tbasic_machine=le32-unknown\n+\t\tos=-nacl\n+\t\t;;\n+\tncr3000)\n+\t\tbasic_machine=i486-ncr\n+\t\tos=-sysv4\n+\t\t;;\n+\tnetbsd386)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-netbsd\n+\t\t;;\n+\tnetwinder)\n+\t\tbasic_machine=armv4l-rebel\n+\t\tos=-linux\n+\t\t;;\n+\tnews | news700 | news800 | news900)\n+\t\tbasic_machine=m68k-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews1000)\n+\t\tbasic_machine=m68030-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews-3600 | risc-news)\n+\t\tbasic_machine=mips-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnecv70)\n+\t\tbasic_machine=v70-nec\n+\t\tos=-sysv\n+\t\t;;\n+\tnext | m*-next )\n+\t\tbasic_machine=m68k-next\n+\t\tcase $os in\n+\t\t    -nextstep* )\n+\t\t\t;;\n+\t\t    -ns2*)\n+\t\t      os=-nextstep2\n+\t\t\t;;\n+\t\t    *)\n+\t\t      os=-nextstep3\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tnh3000)\n+\t\tbasic_machine=m68k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnh[45]000)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnindy960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-nindy\n+\t\t;;\n+\tmon960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-mon960\n+\t\t;;\n+\tnonstopux)\n+\t\tbasic_machine=mips-compaq\n+\t\tos=-nonstopux\n+\t\t;;\n+\tnp1)\n+\t\tbasic_machine=np1-gould\n+\t\t;;\n+\tneo-tandem)\n+\t\tbasic_machine=neo-tandem\n+\t\t;;\n+\tnse-tandem)\n+\t\tbasic_machine=nse-tandem\n+\t\t;;\n+\tnsr-tandem)\n+\t\tbasic_machine=nsr-tandem\n+\t\t;;\n+\top50n-* | op60c-*)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\tos=-proelf\n+\t\t;;\n+\topenrisc | openrisc-*)\n+\t\tbasic_machine=or32-unknown\n+\t\t;;\n+\tos400)\n+\t\tbasic_machine=powerpc-ibm\n+\t\tos=-os400\n+\t\t;;\n+\tOSE68000 | ose68000)\n+\t\tbasic_machine=m68000-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tos68k)\n+\t\tbasic_machine=m68k-none\n+\t\tos=-os68k\n+\t\t;;\n+\tpa-hitachi)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\tparagon)\n+\t\tbasic_machine=i860-intel\n+\t\tos=-osf\n+\t\t;;\n+\tparisc)\n+\t\tbasic_machine=hppa-unknown\n+\t\tos=-linux\n+\t\t;;\n+\tparisc-*)\n+\t\tbasic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\tos=-linux\n+\t\t;;\n+\tpbd)\n+\t\tbasic_machine=sparc-tti\n+\t\t;;\n+\tpbb)\n+\t\tbasic_machine=m68k-tti\n+\t\t;;\n+\tpc532 | pc532-*)\n+\t\tbasic_machine=ns32k-pc532\n+\t\t;;\n+\tpc98)\n+\t\tbasic_machine=i386-pc\n+\t\t;;\n+\tpc98-*)\n+\t\tbasic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentium | p5 | k5 | k6 | nexgen | viac3)\n+\t\tbasic_machine=i586-pc\n+\t\t;;\n+\tpentiumpro | p6 | 6x86 | athlon | athlon_*)\n+\t\tbasic_machine=i686-pc\n+\t\t;;\n+\tpentiumii | pentium2 | pentiumiii | pentium3)\n+\t\tbasic_machine=i686-pc\n+\t\t;;\n+\tpentium4)\n+\t\tbasic_machine=i786-pc\n+\t\t;;\n+\tpentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)\n+\t\tbasic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumpro-* | p6-* | 6x86-* | athlon-*)\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentium4-*)\n+\t\tbasic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpn)\n+\t\tbasic_machine=pn-gould\n+\t\t;;\n+\tpower)\tbasic_machine=power-ibm\n+\t\t;;\n+\tppc | ppcbe)\tbasic_machine=powerpc-unknown\n+\t\t;;\n+\tppc-* | ppcbe-*)\n+\t\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppcle | powerpclittle | ppc-le | powerpc-little)\n+\t\tbasic_machine=powerpcle-unknown\n+\t\t;;\n+\tppcle-* | powerpclittle-*)\n+\t\tbasic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppc64)\tbasic_machine=powerpc64-unknown\n+\t\t;;\n+\tppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppc64le | powerpc64little | ppc64-le | powerpc64-little)\n+\t\tbasic_machine=powerpc64le-unknown\n+\t\t;;\n+\tppc64le-* | powerpc64little-*)\n+\t\tbasic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tps2)\n+\t\tbasic_machine=i386-ibm\n+\t\t;;\n+\tpw32)\n+\t\tbasic_machine=i586-unknown\n+\t\tos=-pw32\n+\t\t;;\n+\trdos | rdos64)\n+\t\tbasic_machine=x86_64-pc\n+\t\tos=-rdos\n+\t\t;;\n+\trdos32)\n+\t\tbasic_machine=i386-pc\n+\t\tos=-rdos\n+\t\t;;\n+\trom68k)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\trm[46]00)\n+\t\tbasic_machine=mips-siemens\n+\t\t;;\n+\trtpc | rtpc-*)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\ts390 | s390-*)\n+\t\tbasic_machine=s390-ibm\n+\t\t;;\n+\ts390x | s390x-*)\n+\t\tbasic_machine=s390x-ibm\n+\t\t;;\n+\tsa29200)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tsb1)\n+\t\tbasic_machine=mipsisa64sb1-unknown\n+\t\t;;\n+\tsb1el)\n+\t\tbasic_machine=mipsisa64sb1el-unknown\n+\t\t;;\n+\tsde)\n+\t\tbasic_machine=mipsisa32-sde\n+\t\tos=-elf\n+\t\t;;\n+\tsei)\n+\t\tbasic_machine=mips-sei\n+\t\tos=-seiux\n+\t\t;;\n+\tsequent)\n+\t\tbasic_machine=i386-sequent\n+\t\t;;\n+\tsh)\n+\t\tbasic_machine=sh-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tsh5el)\n+\t\tbasic_machine=sh5le-unknown\n+\t\t;;\n+\tsh64)\n+\t\tbasic_machine=sh64-unknown\n+\t\t;;\n+\tsparclite-wrs | simso-wrs)\n+\t\tbasic_machine=sparclite-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tsps7)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv2\n+\t\t;;\n+\tspur)\n+\t\tbasic_machine=spur-unknown\n+\t\t;;\n+\tst2000)\n+\t\tbasic_machine=m68k-tandem\n+\t\t;;\n+\tstratus)\n+\t\tbasic_machine=i860-stratus\n+\t\tos=-sysv4\n+\t\t;;\n+\tstrongarm-* | thumb-*)\n+\t\tbasic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tsun2)\n+\t\tbasic_machine=m68000-sun\n+\t\t;;\n+\tsun2os3)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun2os4)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun3os3)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun3os4)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4os3)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun4os4)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4sol2)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-solaris2\n+\t\t;;\n+\tsun3 | sun3-*)\n+\t\tbasic_machine=m68k-sun\n+\t\t;;\n+\tsun4)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+\tsun386 | sun386i | roadrunner)\n+\t\tbasic_machine=i386-sun\n+\t\t;;\n+\tsv1)\n+\t\tbasic_machine=sv1-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tsymmetry)\n+\t\tbasic_machine=i386-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tt3e)\n+\t\tbasic_machine=alphaev5-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tt90)\n+\t\tbasic_machine=t90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\ttile*)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\tos=-linux-gnu\n+\t\t;;\n+\ttx39)\n+\t\tbasic_machine=mipstx39-unknown\n+\t\t;;\n+\ttx39el)\n+\t\tbasic_machine=mipstx39el-unknown\n+\t\t;;\n+\ttoad1)\n+\t\tbasic_machine=pdp10-xkl\n+\t\tos=-tops20\n+\t\t;;\n+\ttower | tower-32)\n+\t\tbasic_machine=m68k-ncr\n+\t\t;;\n+\ttpf)\n+\t\tbasic_machine=s390x-ibm\n+\t\tos=-tpf\n+\t\t;;\n+\tudi29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tultra3)\n+\t\tbasic_machine=a29k-nyu\n+\t\tos=-sym1\n+\t\t;;\n+\tv810 | necv810)\n+\t\tbasic_machine=v810-nec\n+\t\tos=-none\n+\t\t;;\n+\tvaxv)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-sysv\n+\t\t;;\n+\tvms)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-vms\n+\t\t;;\n+\tvpp*|vx|vx-*)\n+\t\tbasic_machine=f301-fujitsu\n+\t\t;;\n+\tvxworks960)\n+\t\tbasic_machine=i960-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks68)\n+\t\tbasic_machine=m68k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks29k)\n+\t\tbasic_machine=a29k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tw65*)\n+\t\tbasic_machine=w65-wdc\n+\t\tos=-none\n+\t\t;;\n+\tw89k-*)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\tos=-proelf\n+\t\t;;\n+\txbox)\n+\t\tbasic_machine=i686-pc\n+\t\tos=-mingw32\n+\t\t;;\n+\txps | xps100)\n+\t\tbasic_machine=xps100-honeywell\n+\t\t;;\n+\txscale-* | xscalee[bl]-*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`\n+\t\t;;\n+\tymp)\n+\t\tbasic_machine=ymp-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tz8k-*-coff)\n+\t\tbasic_machine=z8k-unknown\n+\t\tos=-sim\n+\t\t;;\n+\tz80-*-coff)\n+\t\tbasic_machine=z80-unknown\n+\t\tos=-sim\n+\t\t;;\n+\tnone)\n+\t\tbasic_machine=none-none\n+\t\tos=-none\n+\t\t;;\n+\n+# Here we handle the default manufacturer of certain CPU types.  It is in\n+# some cases the only manufacturer, in others, it is the most popular.\n+\tw89k)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\t;;\n+\top50n)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\top60c)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\tromp)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\tmmix)\n+\t\tbasic_machine=mmix-knuth\n+\t\t;;\n+\trs6000)\n+\t\tbasic_machine=rs6000-ibm\n+\t\t;;\n+\tvax)\n+\t\tbasic_machine=vax-dec\n+\t\t;;\n+\tpdp10)\n+\t\t# there are many clones, so DEC is not a safe bet\n+\t\tbasic_machine=pdp10-unknown\n+\t\t;;\n+\tpdp11)\n+\t\tbasic_machine=pdp11-dec\n+\t\t;;\n+\twe32k)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\tsh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)\n+\t\tbasic_machine=sh-unknown\n+\t\t;;\n+\tsparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+\tcydra)\n+\t\tbasic_machine=cydra-cydrome\n+\t\t;;\n+\torion)\n+\t\tbasic_machine=orion-highlevel\n+\t\t;;\n+\torion105)\n+\t\tbasic_machine=clipper-highlevel\n+\t\t;;\n+\tmac | mpw | mac-mpw)\n+\t\tbasic_machine=m68k-apple\n+\t\t;;\n+\tpmac | pmac-mpw)\n+\t\tbasic_machine=powerpc-apple\n+\t\t;;\n+\t*-unknown)\n+\t\t# Make sure to match an already-canonicalized machine name.\n+\t\t;;\n+\t*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+\n+# Here we canonicalize certain aliases for manufacturers.\n+case $basic_machine in\n+\t*-digital*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`\n+\t\t;;\n+\t*-commodore*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`\n+\t\t;;\n+\t*)\n+\t\t;;\n+esac\n+\n+# Decode manufacturer-specific aliases for certain operating systems.\n+\n+if [ x\"$os\" != x\"\" ]\n+then\n+case $os in\n+\t# First match some system type aliases\n+\t# that might get confused with valid system types.\n+\t# -solaris* is a basic system type, with this one exception.\n+\t-auroraux)\n+\t\tos=-auroraux\n+\t\t;;\n+\t-solaris1 | -solaris1.*)\n+\t\tos=`echo $os | sed -e 's|solaris1|sunos4|'`\n+\t\t;;\n+\t-solaris)\n+\t\tos=-solaris2\n+\t\t;;\n+\t-svr4*)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-unixware*)\n+\t\tos=-sysv4.2uw\n+\t\t;;\n+\t-gnu/linux*)\n+\t\tos=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`\n+\t\t;;\n+\t# First accept the basic system types.\n+\t# The portable systems comes first.\n+\t# Each alternative MUST END IN A *, to match a version number.\n+\t# -sysv* is not here because it comes later, after sysvr4.\n+\t-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \\\n+\t      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\\\n+\t      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \\\n+\t      | -sym* | -kopensolaris* | -plan9* \\\n+\t      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \\\n+\t      | -aos* | -aros* \\\n+\t      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \\\n+\t      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \\\n+\t      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \\\n+\t      | -bitrig* | -openbsd* | -solidbsd* \\\n+\t      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \\\n+\t      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \\\n+\t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n+\t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n+\t      | -chorusos* | -chorusrdb* | -cegcc* \\\n+\t      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n+\t      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \\\n+\t      | -linux-newlib* | -linux-musl* | -linux-uclibc* \\\n+\t      | -uxpv* | -beos* | -mpeix* | -udk* \\\n+\t      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \\\n+\t      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \\\n+\t      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \\\n+\t      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \\\n+\t      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \\\n+\t      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \\\n+\t      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)\n+\t# Remember, each alternative MUST END IN *, to match a version number.\n+\t\t;;\n+\t-qnx*)\n+\t\tcase $basic_machine in\n+\t\t    x86-* | i*86-*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-nto$os\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\t-nto-qnx*)\n+\t\t;;\n+\t-nto*)\n+\t\tos=`echo $os | sed -e 's|nto|nto-qnx|'`\n+\t\t;;\n+\t-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \\\n+\t      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \\\n+\t      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)\n+\t\t;;\n+\t-mac*)\n+\t\tos=`echo $os | sed -e 's|mac|macos|'`\n+\t\t;;\n+\t-linux-dietlibc)\n+\t\tos=-linux-dietlibc\n+\t\t;;\n+\t-linux*)\n+\t\tos=`echo $os | sed -e 's|linux|linux-gnu|'`\n+\t\t;;\n+\t-sunos5*)\n+\t\tos=`echo $os | sed -e 's|sunos5|solaris2|'`\n+\t\t;;\n+\t-sunos6*)\n+\t\tos=`echo $os | sed -e 's|sunos6|solaris3|'`\n+\t\t;;\n+\t-opened*)\n+\t\tos=-openedition\n+\t\t;;\n+\t-os400*)\n+\t\tos=-os400\n+\t\t;;\n+\t-wince*)\n+\t\tos=-wince\n+\t\t;;\n+\t-osfrose*)\n+\t\tos=-osfrose\n+\t\t;;\n+\t-osf*)\n+\t\tos=-osf\n+\t\t;;\n+\t-utek*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-dynix*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-acis*)\n+\t\tos=-aos\n+\t\t;;\n+\t-atheos*)\n+\t\tos=-atheos\n+\t\t;;\n+\t-syllable*)\n+\t\tos=-syllable\n+\t\t;;\n+\t-386bsd)\n+\t\tos=-bsd\n+\t\t;;\n+\t-ctix* | -uts*)\n+\t\tos=-sysv\n+\t\t;;\n+\t-nova*)\n+\t\tos=-rtmk-nova\n+\t\t;;\n+\t-ns2 )\n+\t\tos=-nextstep2\n+\t\t;;\n+\t-nsk*)\n+\t\tos=-nsk\n+\t\t;;\n+\t# Preserve the version number of sinix5.\n+\t-sinix5.*)\n+\t\tos=`echo $os | sed -e 's|sinix|sysv|'`\n+\t\t;;\n+\t-sinix*)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-tpf*)\n+\t\tos=-tpf\n+\t\t;;\n+\t-triton*)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-oss*)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-svr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-svr3)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-sysvr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t# This must come after -sysvr4.\n+\t-sysv*)\n+\t\t;;\n+\t-ose*)\n+\t\tos=-ose\n+\t\t;;\n+\t-es1800*)\n+\t\tos=-ose\n+\t\t;;\n+\t-xenix)\n+\t\tos=-xenix\n+\t\t;;\n+\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n+\t\tos=-mint\n+\t\t;;\n+\t-aros*)\n+\t\tos=-aros\n+\t\t;;\n+\t-zvmoe)\n+\t\tos=-zvmoe\n+\t\t;;\n+\t-dicos*)\n+\t\tos=-dicos\n+\t\t;;\n+\t-nacl*)\n+\t\t;;\n+\t-none)\n+\t\t;;\n+\t*)\n+\t\t# Get rid of the `-' at the beginning of $os.\n+\t\tos=`echo $os | sed 's/[^-]*-//'`\n+\t\techo Invalid configuration \\`$1\\': system \\`$os\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+else\n+\n+# Here we handle the default operating systems that come with various machines.\n+# The value should be what the vendor currently ships out the door with their\n+# machine or put another way, the most popular os provided with the machine.\n+\n+# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n+# \"-sun\"), then you have to tell the case statement up towards the top\n+# that MANUFACTURER isn't an operating system.  Otherwise, code above\n+# will signal an error saying that MANUFACTURER isn't an operating\n+# system, and we'll never get to this point.\n+\n+case $basic_machine in\n+\tscore-*)\n+\t\tos=-elf\n+\t\t;;\n+\tspu-*)\n+\t\tos=-elf\n+\t\t;;\n+\t*-acorn)\n+\t\tos=-riscix1.2\n+\t\t;;\n+\tarm*-rebel)\n+\t\tos=-linux\n+\t\t;;\n+\tarm*-semi)\n+\t\tos=-aout\n+\t\t;;\n+\tc4x-* | tic4x-*)\n+\t\tos=-coff\n+\t\t;;\n+\tc8051-*)\n+\t\tos=-elf\n+\t\t;;\n+\thexagon-*)\n+\t\tos=-elf\n+\t\t;;\n+\ttic54x-*)\n+\t\tos=-coff\n+\t\t;;\n+\ttic55x-*)\n+\t\tos=-coff\n+\t\t;;\n+\ttic6x-*)\n+\t\tos=-coff\n+\t\t;;\n+\t# This must come before the *-dec entry.\n+\tpdp10-*)\n+\t\tos=-tops20\n+\t\t;;\n+\tpdp11-*)\n+\t\tos=-none\n+\t\t;;\n+\t*-dec | vax-*)\n+\t\tos=-ultrix4.2\n+\t\t;;\n+\tm68*-apollo)\n+\t\tos=-domain\n+\t\t;;\n+\ti386-sun)\n+\t\tos=-sunos4.0.2\n+\t\t;;\n+\tm68000-sun)\n+\t\tos=-sunos3\n+\t\t;;\n+\tm68*-cisco)\n+\t\tos=-aout\n+\t\t;;\n+\tmep-*)\n+\t\tos=-elf\n+\t\t;;\n+\tmips*-cisco)\n+\t\tos=-elf\n+\t\t;;\n+\tmips*-*)\n+\t\tos=-elf\n+\t\t;;\n+\tor1k-*)\n+\t\tos=-elf\n+\t\t;;\n+\tor32-*)\n+\t\tos=-coff\n+\t\t;;\n+\t*-tti)\t# must be before sparc entry or we get the wrong os.\n+\t\tos=-sysv3\n+\t\t;;\n+\tsparc-* | *-sun)\n+\t\tos=-sunos4.1.1\n+\t\t;;\n+\t*-be)\n+\t\tos=-beos\n+\t\t;;\n+\t*-haiku)\n+\t\tos=-haiku\n+\t\t;;\n+\t*-ibm)\n+\t\tos=-aix\n+\t\t;;\n+\t*-knuth)\n+\t\tos=-mmixware\n+\t\t;;\n+\t*-wec)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-winbond)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-oki)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-hp)\n+\t\tos=-hpux\n+\t\t;;\n+\t*-hitachi)\n+\t\tos=-hiux\n+\t\t;;\n+\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n+\t\tos=-sysv\n+\t\t;;\n+\t*-cbm)\n+\t\tos=-amigaos\n+\t\t;;\n+\t*-dg)\n+\t\tos=-dgux\n+\t\t;;\n+\t*-dolphin)\n+\t\tos=-sysv3\n+\t\t;;\n+\tm68k-ccur)\n+\t\tos=-rtu\n+\t\t;;\n+\tm88k-omron*)\n+\t\tos=-luna\n+\t\t;;\n+\t*-next )\n+\t\tos=-nextstep\n+\t\t;;\n+\t*-sequent)\n+\t\tos=-ptx\n+\t\t;;\n+\t*-crds)\n+\t\tos=-unos\n+\t\t;;\n+\t*-ns)\n+\t\tos=-genix\n+\t\t;;\n+\ti370-*)\n+\t\tos=-mvs\n+\t\t;;\n+\t*-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+\t*-gould)\n+\t\tos=-sysv\n+\t\t;;\n+\t*-highlevel)\n+\t\tos=-bsd\n+\t\t;;\n+\t*-encore)\n+\t\tos=-bsd\n+\t\t;;\n+\t*-sgi)\n+\t\tos=-irix\n+\t\t;;\n+\t*-siemens)\n+\t\tos=-sysv4\n+\t\t;;\n+\t*-masscomp)\n+\t\tos=-rtu\n+\t\t;;\n+\tf30[01]-fujitsu | f700-fujitsu)\n+\t\tos=-uxpv\n+\t\t;;\n+\t*-rom68k)\n+\t\tos=-coff\n+\t\t;;\n+\t*-*bug)\n+\t\tos=-coff\n+\t\t;;\n+\t*-apple)\n+\t\tos=-macos\n+\t\t;;\n+\t*-atari*)\n+\t\tos=-mint\n+\t\t;;\n+\t*)\n+\t\tos=-none\n+\t\t;;\n+esac\n+fi\n+\n+# Here we handle the case where we know the os, and the CPU type, but not the\n+# manufacturer.  We pick the logical manufacturer.\n+vendor=unknown\n+case $basic_machine in\n+\t*-unknown)\n+\t\tcase $os in\n+\t\t\t-riscix*)\n+\t\t\t\tvendor=acorn\n+\t\t\t\t;;\n+\t\t\t-sunos*)\n+\t\t\t\tvendor=sun\n+\t\t\t\t;;\n+\t\t\t-cnk*|-aix*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-beos*)\n+\t\t\t\tvendor=be\n+\t\t\t\t;;\n+\t\t\t-hpux*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-mpeix*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-hiux*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-unos*)\n+\t\t\t\tvendor=crds\n+\t\t\t\t;;\n+\t\t\t-dgux*)\n+\t\t\t\tvendor=dg\n+\t\t\t\t;;\n+\t\t\t-luna*)\n+\t\t\t\tvendor=omron\n+\t\t\t\t;;\n+\t\t\t-genix*)\n+\t\t\t\tvendor=ns\n+\t\t\t\t;;\n+\t\t\t-mvs* | -opened*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-os400*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-ptx*)\n+\t\t\t\tvendor=sequent\n+\t\t\t\t;;\n+\t\t\t-tpf*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-vxsim* | -vxworks* | -windiss*)\n+\t\t\t\tvendor=wrs\n+\t\t\t\t;;\n+\t\t\t-aux*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-hms*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-mpw* | -macos*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)\n+\t\t\t\tvendor=atari\n+\t\t\t\t;;\n+\t\t\t-vos*)\n+\t\t\t\tvendor=stratus\n+\t\t\t\t;;\n+\t\tesac\n+\t\tbasic_machine=`echo $basic_machine | sed \"s/unknown/$vendor/\"`\n+\t\t;;\n+esac\n+\n+echo $basic_machine$os\n+exit\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"timestamp='\"\n+# time-stamp-format: \"%:y-%02m-%02d\"\n+# time-stamp-end: \"'\"\n+# End:"}, {"sha": "f4f9d058ec8e1a30589dab39a269274ec9a0fcd0", "filename": "src/libbacktrace/configure", "status": "added", "additions": 15156, "deletions": 0, "changes": 15156, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=12b2607572d6233a1d4b4f7592573e49b505771e"}, {"sha": "878bd2c15806c61790f4928e8140bbb041ae301c", "filename": "src/libbacktrace/configure.ac", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,391 @@\n+# configure.ac -- Backtrace configure script.\n+# Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer. \n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.  \n+    \n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+AC_PREREQ(2.64)\n+AC_INIT(package-unused, version-unused,, libbacktrace)\n+AC_CONFIG_SRCDIR(backtrace.h)\n+AC_CONFIG_HEADER(config.h)\n+\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+\n+AC_USE_SYSTEM_EXTENSIONS\n+\n+libtool_VERSION=1:0:0\n+AC_SUBST(libtool_VERSION)\n+\n+# 1.11.1: Require that version of automake.\n+# foreign: Don't require README, INSTALL, NEWS, etc.\n+# no-define: Don't define PACKAGE and VERSION.\n+# no-dependencies: Don't generate automatic dependencies.\n+#    (because it breaks when using bootstrap-lean, since some of the\n+#    headers are gone at \"make install\" time).\n+# -Wall: Issue all automake warnings.\n+# -Wno-portability: Don't warn about constructs supported by GNU make.\n+#    (because GCC requires GNU make anyhow).\n+AM_INIT_AUTOMAKE([1.11.1 foreign no-dist no-define no-dependencies -Wall -Wno-portability])\n+\n+AM_MAINTAINER_MODE\n+\n+AC_ARG_WITH(target-subdir,\n+[  --with-target-subdir=SUBDIR      Configuring in a subdirectory for target])\n+\n+# We must force CC to /not/ be precious variables; otherwise\n+# the wrong, non-multilib-adjusted value will be used in multilibs.\n+# As a side effect, we have to subst CFLAGS ourselves.\n+m4_rename([_AC_ARG_VAR_PRECIOUS],[backtrace_PRECIOUS])\n+m4_define([_AC_ARG_VAR_PRECIOUS],[])\n+AC_PROG_CC\n+m4_rename_force([backtrace_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n+\n+AC_SUBST(CFLAGS)\n+\n+AC_PROG_RANLIB\n+\n+AC_PROG_AWK\n+case \"$AWK\" in\n+\"\") AC_MSG_ERROR([can't build without awk]) ;;\n+esac\n+\n+LT_INIT([disable-shared])\n+AM_PROG_LIBTOOL\n+\n+backtrace_supported=yes\n+\n+if test -n \"${with_target_subdir}\"; then\n+  # We are compiling a GCC library.  We can assume that the unwind\n+  # library exists.\n+  AM_ENABLE_MULTILIB(, ..)\n+  BACKTRACE_FILE=\"backtrace.lo simple.lo\"\n+else\n+  AC_CHECK_HEADER([unwind.h],\n+    [AC_CHECK_FUNC([_Unwind_Backtrace],\n+\t           [BACKTRACE_FILE=\"backtrace.lo simple.lo\"],\n+\t\t   [BACKTRACE_FILE=\"nounwind.lo\"\n+                    backtrace_supported=no])],\n+    [BACKTRACE_FILE=\"nounwind.lo\"\n+     backtrace_supported=no])\n+fi\n+AC_SUBST(BACKTRACE_FILE)\n+\n+EXTRA_FLAGS=\n+if test -n \"${with_target_subdir}\"; then\n+  EXTRA_FLAGS=\"-funwind-tables -frandom-seed=\\$@\"\n+else\n+  AC_CACHE_CHECK([for -funwind-tables option],\n+    [libbacktrace_cv_c_unwind_tables],\n+    [CFLAGS_hold=\"$CFLAGS\"\n+     CFLAGS=\"$CFLAGS -funwind-tables\"\n+     AC_COMPILE_IFELSE(\n+       [AC_LANG_PROGRAM([static int f() { return 0; }], [return f();])],\n+       [libbacktrace_cv_c_unwind_tables=yes],\n+       [libbacktrace_cv_c_unwind_tables=no])\n+     CFLAGS=\"$CFLAGS_hold\"])\n+  if test \"$libbacktrace_cv_c_unwind_tables\" = \"yes\"; then\n+    EXTRA_FLAGS=-funwind-tables\n+  fi\n+  AC_CACHE_CHECK([for -frandom-seed=string option],\n+    [libbacktrace_cv_c_random_seed_string],\n+    [CFLAGS_hold=\"$CFLAGS\"\n+     CFLAGS=\"$CFLAGS -frandom-seed=conftest.lo\"\n+     AC_COMPILE_IFELSE(\n+       [AC_LANG_PROGRAM([], [return 0;])],\n+       [libbacktrace_cv_c_random_seed_string=yes],\n+       [libbacktrace_cv_c_random_seed_string=no])\n+     CFLAGS=\"$CFLAGS_hold\"])\n+  if test \"$libbacktrace_cv_c_random_seed_string\" = \"yes\"; then\n+    EXTRA_FLAGS=\"$EXTRA_FLAGS -frandom-seed=\\$@\"\n+  fi\n+fi\n+AC_SUBST(EXTRA_FLAGS)\n+\n+ACX_PROG_CC_WARNING_OPTS([-W -Wall -Wwrite-strings -Wstrict-prototypes \\\n+\t\t\t  -Wmissing-prototypes -Wold-style-definition \\\n+\t\t\t  -Wmissing-format-attribute -Wcast-qual],\n+\t\t\t  [WARN_FLAGS])\n+\n+if test -n \"${with_target_subdir}\"; then\n+  WARN_FLAGS=\"$WARN_FLAGS -Werror\"\n+fi\n+\n+AC_SUBST(WARN_FLAGS)\n+\n+if test -n \"${with_target_subdir}\"; then\n+  GCC_CHECK_UNWIND_GETIPINFO\n+else\n+  ac_save_CFFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror-implicit-function-declaration\"\n+  AC_MSG_CHECKING([for _Unwind_GetIPInfo])\n+  AC_LINK_IFELSE(\n+    [AC_LANG_PROGRAM(\n+       [#include \"unwind.h\"\n+\tstruct _Unwind_Context *context;\n+\tint ip_before_insn = 0;],\n+\t[return _Unwind_GetIPInfo (context, &ip_before_insn);])],\n+\t[have_unwind_getipinfo=yes], [have_unwind_getipinfo=no])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+  AC_MSG_RESULT([$have_unwind_getipinfo])\n+  if test \"$have_unwind_getipinfo\" = \"yes\"; then\n+    AC_DEFINE(HAVE_GETIPINFO, 1, [Define if _Unwind_GetIPInfo is available.])\n+  fi\n+fi\n+\n+# When building as a target library, shared libraries may want to link\n+# this in.  We don't want to provide another shared library to\n+# complicate dependencies.  Instead, we just compile with -fPIC.\n+PIC_FLAG=\n+if test -n \"${with_target_subdir}\"; then\n+  PIC_FLAG=-fPIC\n+fi\n+# Similarly, use -fPIC with --enable-host-shared:\n+AC_ARG_ENABLE(host-shared,\n+[AS_HELP_STRING([--enable-host-shared],\n+\t\t[build host code as shared libraries])],\n+[PIC_FLAG=-fPIC], [])\n+AC_SUBST(PIC_FLAG)\n+\n+# Test for __sync support.\n+AC_CACHE_CHECK([__sync extensions],\n+[libbacktrace_cv_sys_sync],\n+[if test -n \"${with_target_subdir}\"; then\n+   libbacktrace_cv_sys_sync=yes\n+ else\n+   AC_LINK_IFELSE(\n+     [AC_LANG_PROGRAM([int i;],\n+                      [__sync_bool_compare_and_swap (&i, i, i);\n+                       __sync_lock_test_and_set (&i, 1);\n+                       __sync_lock_release (&i);])],\n+     [libbacktrace_cv_sys_sync=yes],\n+     [libbacktrace_cv_sys_sync=no])\n+ fi])\n+BACKTRACE_SUPPORTS_THREADS=0\n+if test \"$libbacktrace_cv_sys_sync\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_THREADS=1\n+  AC_DEFINE([HAVE_SYNC_FUNCTIONS], 1,\n+\t    [Define to 1 if you have the __sync functions])\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTS_THREADS)\n+\n+# Test for __atomic support.\n+AC_CACHE_CHECK([__atomic extensions],\n+[libbacktrace_cv_sys_atomic],\n+[if test -n \"${with_target_subdir}\"; then\n+   libbacktrace_cv_sys_atomic=yes\n+ else\n+   AC_LINK_IFELSE(\n+     [AC_LANG_PROGRAM([int i;],\n+     \t\t      [__atomic_load_n (&i, __ATOMIC_ACQUIRE);\n+\t\t       __atomic_store_n (&i, 1, __ATOMIC_RELEASE);])],\n+     [libbacktrace_cv_sys_atomic=yes],\n+     [libbacktrace_cv_sys_atomic=no])\n+ fi])\n+if test \"$libbacktrace_cv_sys_atomic\" = \"yes\"; then\n+  AC_DEFINE([HAVE_ATOMIC_FUNCTIONS], 1,\n+\t    [Define to 1 if you have the __atomic functions])\n+fi\n+\n+# The library needs to be able to read the executable itself.  Compile\n+# a file to determine the executable format.  The awk script\n+# filetype.awk prints out the file type.\n+AC_CACHE_CHECK([output filetype],\n+[libbacktrace_cv_sys_filetype],\n+[filetype=\n+AC_COMPILE_IFELSE(\n+  [AC_LANG_PROGRAM([int i;], [int j;])],\n+  [filetype=`${AWK} -f $srcdir/filetype.awk conftest.$ac_objext`],\n+  [AC_MSG_FAILURE([compiler failed])])\n+libbacktrace_cv_sys_filetype=$filetype])\n+\n+# Match the file type to decide what files to compile.\n+FORMAT_FILE=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+elf*) FORMAT_FILE=\"elf.lo\" ;;\n+*) AC_MSG_WARN([could not determine output file type])\n+   FORMAT_FILE=\"unknown.lo\"\n+   backtrace_supported=no\n+   ;;\n+esac\n+AC_SUBST(FORMAT_FILE)\n+\n+# ELF defines.\n+elfsize=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+elf32) elfsize=32 ;;\n+elf64) elfsize=64 ;;\n+esac\n+AC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n+\n+BACKTRACE_SUPPORTED=0\n+if test \"$backtrace_supported\" = \"yes\"; then\n+  BACKTRACE_SUPPORTED=1\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTED)\n+\n+GCC_HEADER_STDINT(gstdint.h)\n+\n+AC_CHECK_HEADERS(sys/mman.h)\n+if test \"$ac_cv_header_sys_mman_h\" = \"no\"; then\n+  have_mmap=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.  We\n+    # simply assume that if we have mman.h, we have mmap.\n+    have_mmap=yes\n+  else\n+    AC_CHECK_FUNC(mmap, [have_mmap=yes], [have_mmap=no])\n+  fi\n+fi\n+if test \"$have_mmap\" = \"no\"; then\n+  VIEW_FILE=read.lo\n+  ALLOC_FILE=alloc.lo\n+else\n+  VIEW_FILE=mmapio.lo\n+  AC_PREPROC_IFELSE([\n+#include <sys/mman.h>\n+#if !defined(MAP_ANONYMOUS) && !defined(MAP_ANON)\n+  #error no MAP_ANONYMOUS\n+#endif\n+], [ALLOC_FILE=mmap.lo], [ALLOC_FILE=alloc.lo])\n+fi\n+AC_SUBST(VIEW_FILE)\n+AC_SUBST(ALLOC_FILE)\n+\n+BACKTRACE_USES_MALLOC=0\n+if test \"$ALLOC_FILE\" = \"alloc.lo\"; then\n+  BACKTRACE_USES_MALLOC=1\n+fi\n+AC_SUBST(BACKTRACE_USES_MALLOC)\n+\n+# Check for dl_iterate_phdr.\n+AC_CHECK_HEADERS(link.h)\n+if test \"$ac_cv_header_link_h\" = \"no\"; then\n+  have_dl_iterate_phdr=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.\n+    AC_EGREP_HEADER([dl_iterate_phdr], [link.h], [have_dl_iterate_phdr=yes],\n+\t\t    [have_dl_iterate_phdr=no])\n+    case \"${host}\" in\n+    *-*-solaris2.10*)\n+        # Avoid dl_iterate_phdr on Solaris 10, where it is in the\n+    \t# header file but is only in -ldl.\n+\thave_dl_iterate_phdr=no ;;\n+    esac\n+  else\n+    AC_CHECK_FUNC([dl_iterate_phdr], [have_dl_iterate_phdr=yes],\n+\t\t  [have_dl_iterate_phdr=no])\n+  fi\n+fi\n+if test \"$have_dl_iterate_phdr\" = \"yes\"; then\n+  AC_DEFINE(HAVE_DL_ITERATE_PHDR, 1, [Define if dl_iterate_phdr is available.])\n+fi\n+\n+# Check for the fcntl function.\n+if test -n \"${with_target_subdir}\"; then\n+   case \"${host}\" in\n+   *-*-mingw*) have_fcntl=no ;;\n+   *) have_fcntl=yes ;;\n+   esac\n+else\n+  AC_CHECK_FUNC(fcntl, [have_fcntl=yes], [have_fcntl=no])\n+fi\n+if test \"$have_fcntl\" = \"yes\"; then\n+  AC_DEFINE([HAVE_FCNTL], 1,\n+\t    [Define to 1 if you have the fcntl function])\n+fi\n+\n+AC_CHECK_DECLS(strnlen)\n+\n+# Check for getexecname function.\n+if test -n \"${with_target_subdir}\"; then\n+   case \"${host}\" in\n+   *-*-solaris2*) have_getexecname=yes ;;\n+   *) have_getexecname=no ;;\n+   esac\n+else\n+  AC_CHECK_FUNC(getexecname, [have_getexecname=yes], [have_getexecname=no])\n+fi\n+if test \"$have_getexecname\" = \"yes\"; then\n+  AC_DEFINE(HAVE_GETEXECNAME, 1, [Define if getexecname is available.])\n+fi\n+\n+AC_CACHE_CHECK([whether tests can run],\n+  [libbacktrace_cv_sys_native],\n+  [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],\n+     [libbacktrace_cv_sys_native=yes],\n+     [libbacktrace_cv_sys_native=no],\n+     [libbacktrace_cv_sys_native=no])])\n+AM_CONDITIONAL(NATIVE, test \"$libbacktrace_cv_sys_native\" = \"yes\")\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+AC_CONFIG_FILES(Makefile backtrace-supported.h)\n+\n+# We need multilib support, but only if configuring for the target.\n+AC_CONFIG_COMMANDS([default],\n+[if test -n \"$CONFIG_FILES\"; then\n+   if test -n \"${with_target_subdir}\"; then\n+     # Multilibs need MULTISUBDIR defined correctly in certain makefiles so\n+     # that multilib installs will end up installed in the correct place.\n+     # The testsuite needs it for multilib-aware ABI baseline files.\n+     # To work around this not being passed down from config-ml.in ->\n+     # srcdir/Makefile.am -> srcdir/{src,libsupc++,...}/Makefile.am, manually\n+     # append it here.  Only modify Makefiles that have just been created.\n+     #\n+     # Also, get rid of this simulated-VPATH thing that automake does.\n+     cat > vpsed << \\_EOF\n+  s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+     for i in $SUBDIRS; do\n+      case $CONFIG_FILES in\n+       *${i}/Makefile*)\n+\t #echo \"Adding MULTISUBDIR to $i/Makefile\"\n+\t sed -f vpsed $i/Makefile > tmp\n+\t grep '^MULTISUBDIR =' Makefile >> tmp\n+\t mv tmp $i/Makefile\n+\t ;;\n+      esac\n+     done\n+     rm vpsed\n+   fi\n+ fi\n+],\n+[\n+# Variables needed in config.status (file generation) which aren't already\n+# passed by autoconf.\n+SUBDIRS=\"$SUBDIRS\"\n+])\n+\n+AC_OUTPUT"}, {"sha": "ad52d73b752e51c4be990c17cda0709c42d21fe2", "filename": "src/libbacktrace/dwarf.c", "status": "added", "additions": 3021, "deletions": 0, "changes": 3021, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fdwarf.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e"}, {"sha": "71a37b30c9f87b429bab08a4a420caa9a6385503", "filename": "src/libbacktrace/dwarf2.def", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fdwarf2.def", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.def?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,688 @@\n+/* -*- c -*-\n+   Declarations and definitions of codes relating to the DWARF2 and\n+   DWARF3 symbolic debugging information formats.\n+   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002,\n+   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n+   Free Software Foundation, Inc.\n+\n+   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n+   Office (AJPO), Florida State University and Silicon Graphics Inc.\n+   provided support for this effort -- June 21, 1995.\n+\n+   Derived from the DWARF 1 implementation written by Ron Guilmette\n+   (rfg@netcom.com), November 1990.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file is derived from the DWARF specification (a public document)\n+   Revision 2.0.0 (July 27, 1993) developed by the UNIX International\n+   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n+   by UNIX International.  Copies of this specification are available from\n+   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n+\n+   This file also now contains definitions from the DWARF 3 specification\n+   published Dec 20, 2005, available from: http://dwarf.freestandards.org.\n+\n+   This file also now contains definitions from the DWARF 4\n+   specification, available from: http://dwarfstd.org/ */\n+\n+/* This file declares various DWARF-related constants using a set of\n+   macros which can be redefined by the including file.\n+   \n+   The macros are in sections.  Each section corresponds to a single\n+   set of DWARF constants and has a corresponding key.  The key is\n+   used in all the macro names.\n+   \n+   The sections are TAG (for DW_TAG_ constants), FORM (DW_FORM_), AT\n+   (DW_AT_), OP (DW_OP_), ATE (DW_ATE_), and CFA (DW_CFA_).\n+   \n+   Using TAG as an example, the following macros may be used for each\n+   key:\n+   \n+   DW_FIRST_TAG(name, value) - Introduce the first DW_TAG constant.\n+   \n+   DW_TAG(name, value) - Define a subsequent constant.\n+   \n+   DW_TAG_DUP(name, value) - Define a subsequent constant whose value\n+   is a duplicate of some other constant.  Not all keys use the _DUP\n+   macro form.  If more than one name shares a value, then the base\n+   (DW_TAG) form will be the preferred name and DW_TAG_DUP will hold\n+   any alternate names.\n+   \n+   DW_END_TAG - Invoked at the end of the DW_TAG constants.  */\n+\n+DW_FIRST_TAG (DW_TAG_padding, 0x00)\n+DW_TAG (DW_TAG_array_type, 0x01)\n+DW_TAG (DW_TAG_class_type, 0x02)\n+DW_TAG (DW_TAG_entry_point, 0x03)\n+DW_TAG (DW_TAG_enumeration_type, 0x04)\n+DW_TAG (DW_TAG_formal_parameter, 0x05)\n+DW_TAG (DW_TAG_imported_declaration, 0x08)\n+DW_TAG (DW_TAG_label, 0x0a)\n+DW_TAG (DW_TAG_lexical_block, 0x0b)\n+DW_TAG (DW_TAG_member, 0x0d)\n+DW_TAG (DW_TAG_pointer_type, 0x0f)\n+DW_TAG (DW_TAG_reference_type, 0x10)\n+DW_TAG (DW_TAG_compile_unit, 0x11)\n+DW_TAG (DW_TAG_string_type, 0x12)\n+DW_TAG (DW_TAG_structure_type, 0x13)\n+DW_TAG (DW_TAG_subroutine_type, 0x15)\n+DW_TAG (DW_TAG_typedef, 0x16)\n+DW_TAG (DW_TAG_union_type, 0x17)\n+DW_TAG (DW_TAG_unspecified_parameters, 0x18)\n+DW_TAG (DW_TAG_variant, 0x19)\n+DW_TAG (DW_TAG_common_block, 0x1a)\n+DW_TAG (DW_TAG_common_inclusion, 0x1b)\n+DW_TAG (DW_TAG_inheritance, 0x1c)\n+DW_TAG (DW_TAG_inlined_subroutine, 0x1d)\n+DW_TAG (DW_TAG_module, 0x1e)\n+DW_TAG (DW_TAG_ptr_to_member_type, 0x1f)\n+DW_TAG (DW_TAG_set_type, 0x20)\n+DW_TAG (DW_TAG_subrange_type, 0x21)\n+DW_TAG (DW_TAG_with_stmt, 0x22)\n+DW_TAG (DW_TAG_access_declaration, 0x23)\n+DW_TAG (DW_TAG_base_type, 0x24)\n+DW_TAG (DW_TAG_catch_block, 0x25)\n+DW_TAG (DW_TAG_const_type, 0x26)\n+DW_TAG (DW_TAG_constant, 0x27)\n+DW_TAG (DW_TAG_enumerator, 0x28)\n+DW_TAG (DW_TAG_file_type, 0x29)\n+DW_TAG (DW_TAG_friend, 0x2a)\n+DW_TAG (DW_TAG_namelist, 0x2b)\n+DW_TAG (DW_TAG_namelist_item, 0x2c)\n+DW_TAG (DW_TAG_packed_type, 0x2d)\n+DW_TAG (DW_TAG_subprogram, 0x2e)\n+DW_TAG (DW_TAG_template_type_param, 0x2f)\n+DW_TAG (DW_TAG_template_value_param, 0x30)\n+DW_TAG (DW_TAG_thrown_type, 0x31)\n+DW_TAG (DW_TAG_try_block, 0x32)\n+DW_TAG (DW_TAG_variant_part, 0x33)\n+DW_TAG (DW_TAG_variable, 0x34)\n+DW_TAG (DW_TAG_volatile_type, 0x35)\n+/* DWARF 3.  */\n+DW_TAG (DW_TAG_dwarf_procedure, 0x36)\n+DW_TAG (DW_TAG_restrict_type, 0x37)\n+DW_TAG (DW_TAG_interface_type, 0x38)\n+DW_TAG (DW_TAG_namespace, 0x39)\n+DW_TAG (DW_TAG_imported_module, 0x3a)\n+DW_TAG (DW_TAG_unspecified_type, 0x3b)\n+DW_TAG (DW_TAG_partial_unit, 0x3c)\n+DW_TAG (DW_TAG_imported_unit, 0x3d)\n+DW_TAG (DW_TAG_condition, 0x3f)\n+DW_TAG (DW_TAG_shared_type, 0x40)\n+/* DWARF 4.  */\n+DW_TAG (DW_TAG_type_unit, 0x41)\n+DW_TAG (DW_TAG_rvalue_reference_type, 0x42)\n+DW_TAG (DW_TAG_template_alias, 0x43)\n+\n+DW_TAG_DUP (DW_TAG_lo_user, 0x4080)\n+DW_TAG_DUP (DW_TAG_hi_user, 0xffff)\n+\n+/* SGI/MIPS Extensions.  */\n+DW_TAG (DW_TAG_MIPS_loop, 0x4081)\n+\n+/* HP extensions.  See: ftp://ftp.hp.com/pub/lang/tools/WDB/wdb-4.0.tar.gz .  */\n+DW_TAG (DW_TAG_HP_array_descriptor, 0x4090)\n+DW_TAG (DW_TAG_HP_Bliss_field, 0x4091)\n+DW_TAG (DW_TAG_HP_Bliss_field_set, 0x4092)\n+\n+/* GNU extensions.  */\n+DW_TAG (DW_TAG_format_label, 0x4101)\t/* For FORTRAN 77 and Fortran 90.  */\n+DW_TAG (DW_TAG_function_template, 0x4102)\t/* For C++.  */\n+DW_TAG (DW_TAG_class_template, 0x4103)\t/* For C++.  */\n+DW_TAG (DW_TAG_GNU_BINCL, 0x4104)\n+DW_TAG (DW_TAG_GNU_EINCL, 0x4105)\n+/* Template template parameter.\n+   See http://gcc.gnu.org/wiki/TemplateParmsDwarf .  */\n+DW_TAG (DW_TAG_GNU_template_template_param, 0x4106)\n+\n+/* Template parameter pack extension, specified at\n+   http://wiki.dwarfstd.org/index.php?title=C%2B%2B0x:_Variadic_templates\n+   The values of these two TAGS are in the DW_TAG_GNU_* space until the tags\n+   are properly part of DWARF 5.  */\n+DW_TAG (DW_TAG_GNU_template_parameter_pack, 0x4107)\n+DW_TAG (DW_TAG_GNU_formal_parameter_pack, 0x4108)\n+/* The GNU call site extension, specified at\n+   http://www.dwarfstd.org/ShowIssue.php?issue=100909.2&type=open .\n+   The values of these two TAGS are in the DW_TAG_GNU_* space until the tags\n+   are properly part of DWARF 5.  */\n+DW_TAG (DW_TAG_GNU_call_site, 0x4109)\n+DW_TAG (DW_TAG_GNU_call_site_parameter, 0x410a)\n+/* Extensions for UPC.  See: http://dwarfstd.org/doc/DWARF4.pdf.  */\n+DW_TAG (DW_TAG_upc_shared_type, 0x8765)\n+DW_TAG (DW_TAG_upc_strict_type, 0x8766)\n+DW_TAG (DW_TAG_upc_relaxed_type, 0x8767)\n+/* PGI (STMicroelectronics) extensions.  No documentation available.  */\n+DW_TAG (DW_TAG_PGI_kanji_type, 0xA000)\n+DW_TAG (DW_TAG_PGI_interface_block, 0xA020)\n+DW_END_TAG\n+\n+DW_FIRST_FORM (DW_FORM_addr, 0x01)\n+DW_FORM (DW_FORM_block2, 0x03)\n+DW_FORM (DW_FORM_block4, 0x04)\n+DW_FORM (DW_FORM_data2, 0x05)\n+DW_FORM (DW_FORM_data4, 0x06)\n+DW_FORM (DW_FORM_data8, 0x07)\n+DW_FORM (DW_FORM_string, 0x08)\n+DW_FORM (DW_FORM_block, 0x09)\n+DW_FORM (DW_FORM_block1, 0x0a)\n+DW_FORM (DW_FORM_data1, 0x0b)\n+DW_FORM (DW_FORM_flag, 0x0c)\n+DW_FORM (DW_FORM_sdata, 0x0d)\n+DW_FORM (DW_FORM_strp, 0x0e)\n+DW_FORM (DW_FORM_udata, 0x0f)\n+DW_FORM (DW_FORM_ref_addr, 0x10)\n+DW_FORM (DW_FORM_ref1, 0x11)\n+DW_FORM (DW_FORM_ref2, 0x12)\n+DW_FORM (DW_FORM_ref4, 0x13)\n+DW_FORM (DW_FORM_ref8, 0x14)\n+DW_FORM (DW_FORM_ref_udata, 0x15)\n+DW_FORM (DW_FORM_indirect, 0x16)\n+/* DWARF 4.  */\n+DW_FORM (DW_FORM_sec_offset, 0x17)\n+DW_FORM (DW_FORM_exprloc, 0x18)\n+DW_FORM (DW_FORM_flag_present, 0x19)\n+DW_FORM (DW_FORM_ref_sig8, 0x20)\n+/* Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n+DW_FORM (DW_FORM_GNU_addr_index, 0x1f01)\n+DW_FORM (DW_FORM_GNU_str_index, 0x1f02)\n+/* Extensions for DWZ multifile.\n+   See http://www.dwarfstd.org/ShowIssue.php?issue=120604.1&type=open .  */\n+DW_FORM (DW_FORM_GNU_ref_alt, 0x1f20)\n+DW_FORM (DW_FORM_GNU_strp_alt, 0x1f21)\n+DW_END_FORM\n+\n+DW_FIRST_AT (DW_AT_sibling, 0x01)\n+DW_AT (DW_AT_location, 0x02)\n+DW_AT (DW_AT_name, 0x03)\n+DW_AT (DW_AT_ordering, 0x09)\n+DW_AT (DW_AT_subscr_data, 0x0a)\n+DW_AT (DW_AT_byte_size, 0x0b)\n+DW_AT (DW_AT_bit_offset, 0x0c)\n+DW_AT (DW_AT_bit_size, 0x0d)\n+DW_AT (DW_AT_element_list, 0x0f)\n+DW_AT (DW_AT_stmt_list, 0x10)\n+DW_AT (DW_AT_low_pc, 0x11)\n+DW_AT (DW_AT_high_pc, 0x12)\n+DW_AT (DW_AT_language, 0x13)\n+DW_AT (DW_AT_member, 0x14)\n+DW_AT (DW_AT_discr, 0x15)\n+DW_AT (DW_AT_discr_value, 0x16)\n+DW_AT (DW_AT_visibility, 0x17)\n+DW_AT (DW_AT_import, 0x18)\n+DW_AT (DW_AT_string_length, 0x19)\n+DW_AT (DW_AT_common_reference, 0x1a)\n+DW_AT (DW_AT_comp_dir, 0x1b)\n+DW_AT (DW_AT_const_value, 0x1c)\n+DW_AT (DW_AT_containing_type, 0x1d)\n+DW_AT (DW_AT_default_value, 0x1e)\n+DW_AT (DW_AT_inline, 0x20)\n+DW_AT (DW_AT_is_optional, 0x21)\n+DW_AT (DW_AT_lower_bound, 0x22)\n+DW_AT (DW_AT_producer, 0x25)\n+DW_AT (DW_AT_prototyped, 0x27)\n+DW_AT (DW_AT_return_addr, 0x2a)\n+DW_AT (DW_AT_start_scope, 0x2c)\n+DW_AT (DW_AT_bit_stride, 0x2e)\n+DW_AT (DW_AT_upper_bound, 0x2f)\n+DW_AT (DW_AT_abstract_origin, 0x31)\n+DW_AT (DW_AT_accessibility, 0x32)\n+DW_AT (DW_AT_address_class, 0x33)\n+DW_AT (DW_AT_artificial, 0x34)\n+DW_AT (DW_AT_base_types, 0x35)\n+DW_AT (DW_AT_calling_convention, 0x36)\n+DW_AT (DW_AT_count, 0x37)\n+DW_AT (DW_AT_data_member_location, 0x38)\n+DW_AT (DW_AT_decl_column, 0x39)\n+DW_AT (DW_AT_decl_file, 0x3a)\n+DW_AT (DW_AT_decl_line, 0x3b)\n+DW_AT (DW_AT_declaration, 0x3c)\n+DW_AT (DW_AT_discr_list, 0x3d)\n+DW_AT (DW_AT_encoding, 0x3e)\n+DW_AT (DW_AT_external, 0x3f)\n+DW_AT (DW_AT_frame_base, 0x40)\n+DW_AT (DW_AT_friend, 0x41)\n+DW_AT (DW_AT_identifier_case, 0x42)\n+DW_AT (DW_AT_macro_info, 0x43)\n+DW_AT (DW_AT_namelist_items, 0x44)\n+DW_AT (DW_AT_priority, 0x45)\n+DW_AT (DW_AT_segment, 0x46)\n+DW_AT (DW_AT_specification, 0x47)\n+DW_AT (DW_AT_static_link, 0x48)\n+DW_AT (DW_AT_type, 0x49)\n+DW_AT (DW_AT_use_location, 0x4a)\n+DW_AT (DW_AT_variable_parameter, 0x4b)\n+DW_AT (DW_AT_virtuality, 0x4c)\n+DW_AT (DW_AT_vtable_elem_location, 0x4d)\n+/* DWARF 3 values.  */\n+DW_AT (DW_AT_allocated, 0x4e)\n+DW_AT (DW_AT_associated, 0x4f)\n+DW_AT (DW_AT_data_location, 0x50)\n+DW_AT (DW_AT_byte_stride, 0x51)\n+DW_AT (DW_AT_entry_pc, 0x52)\n+DW_AT (DW_AT_use_UTF8, 0x53)\n+DW_AT (DW_AT_extension, 0x54)\n+DW_AT (DW_AT_ranges, 0x55)\n+DW_AT (DW_AT_trampoline, 0x56)\n+DW_AT (DW_AT_call_column, 0x57)\n+DW_AT (DW_AT_call_file, 0x58)\n+DW_AT (DW_AT_call_line, 0x59)\n+DW_AT (DW_AT_description, 0x5a)\n+DW_AT (DW_AT_binary_scale, 0x5b)\n+DW_AT (DW_AT_decimal_scale, 0x5c)\n+DW_AT (DW_AT_small, 0x5d)\n+DW_AT (DW_AT_decimal_sign, 0x5e)\n+DW_AT (DW_AT_digit_count, 0x5f)\n+DW_AT (DW_AT_picture_string, 0x60)\n+DW_AT (DW_AT_mutable, 0x61)\n+DW_AT (DW_AT_threads_scaled, 0x62)\n+DW_AT (DW_AT_explicit, 0x63)\n+DW_AT (DW_AT_object_pointer, 0x64)\n+DW_AT (DW_AT_endianity, 0x65)\n+DW_AT (DW_AT_elemental, 0x66)\n+DW_AT (DW_AT_pure, 0x67)\n+DW_AT (DW_AT_recursive, 0x68)\n+/* DWARF 4.  */\n+DW_AT (DW_AT_signature, 0x69)\n+DW_AT (DW_AT_main_subprogram, 0x6a)\n+DW_AT (DW_AT_data_bit_offset, 0x6b)\n+DW_AT (DW_AT_const_expr, 0x6c)\n+DW_AT (DW_AT_enum_class, 0x6d)\n+DW_AT (DW_AT_linkage_name, 0x6e)\n+\n+DW_AT_DUP (DW_AT_lo_user, 0x2000) /* Implementation-defined range start.  */\n+DW_AT_DUP (DW_AT_hi_user, 0x3fff) /* Implementation-defined range end.  */\n+\n+/* SGI/MIPS extensions.  */\n+DW_AT (DW_AT_MIPS_fde, 0x2001)\n+DW_AT (DW_AT_MIPS_loop_begin, 0x2002)\n+DW_AT (DW_AT_MIPS_tail_loop_begin, 0x2003)\n+DW_AT (DW_AT_MIPS_epilog_begin, 0x2004)\n+DW_AT (DW_AT_MIPS_loop_unroll_factor, 0x2005)\n+DW_AT (DW_AT_MIPS_software_pipeline_depth, 0x2006)\n+DW_AT (DW_AT_MIPS_linkage_name, 0x2007)\n+DW_AT (DW_AT_MIPS_stride, 0x2008)\n+DW_AT (DW_AT_MIPS_abstract_name, 0x2009)\n+DW_AT (DW_AT_MIPS_clone_origin, 0x200a)\n+DW_AT (DW_AT_MIPS_has_inlines, 0x200b)\n+/* HP extensions.  */\n+DW_AT (DW_AT_HP_block_index, 0x2000)\n+DW_AT_DUP (DW_AT_HP_unmodifiable, 0x2001) /* Same as DW_AT_MIPS_fde.  */\n+DW_AT_DUP (DW_AT_HP_prologue, 0x2005) /* Same as DW_AT_MIPS_loop_unroll.  */\n+DW_AT_DUP (DW_AT_HP_epilogue, 0x2008) /* Same as DW_AT_MIPS_stride.  */\n+DW_AT (DW_AT_HP_actuals_stmt_list, 0x2010)\n+DW_AT (DW_AT_HP_proc_per_section, 0x2011)\n+DW_AT (DW_AT_HP_raw_data_ptr, 0x2012)\n+DW_AT (DW_AT_HP_pass_by_reference, 0x2013)\n+DW_AT (DW_AT_HP_opt_level, 0x2014)\n+DW_AT (DW_AT_HP_prof_version_id, 0x2015)\n+DW_AT (DW_AT_HP_opt_flags, 0x2016)\n+DW_AT (DW_AT_HP_cold_region_low_pc, 0x2017)\n+DW_AT (DW_AT_HP_cold_region_high_pc, 0x2018)\n+DW_AT (DW_AT_HP_all_variables_modifiable, 0x2019)\n+DW_AT (DW_AT_HP_linkage_name, 0x201a)\n+DW_AT (DW_AT_HP_prof_flags, 0x201b)  /* In comp unit of procs_info for -g.  */\n+DW_AT (DW_AT_HP_unit_name, 0x201f)\n+DW_AT (DW_AT_HP_unit_size, 0x2020)\n+DW_AT (DW_AT_HP_widened_byte_size, 0x2021)\n+DW_AT (DW_AT_HP_definition_points, 0x2022)\n+DW_AT (DW_AT_HP_default_location, 0x2023)\n+DW_AT (DW_AT_HP_is_result_param, 0x2029)\n+\n+/* GNU extensions.  */\n+DW_AT (DW_AT_sf_names, 0x2101)\n+DW_AT (DW_AT_src_info, 0x2102)\n+DW_AT (DW_AT_mac_info, 0x2103)\n+DW_AT (DW_AT_src_coords, 0x2104)\n+DW_AT (DW_AT_body_begin, 0x2105)\n+DW_AT (DW_AT_body_end, 0x2106)\n+DW_AT (DW_AT_GNU_vector, 0x2107)\n+/* Thread-safety annotations.\n+   See http://gcc.gnu.org/wiki/ThreadSafetyAnnotation .  */\n+DW_AT (DW_AT_GNU_guarded_by, 0x2108)\n+DW_AT (DW_AT_GNU_pt_guarded_by, 0x2109)\n+DW_AT (DW_AT_GNU_guarded, 0x210a)\n+DW_AT (DW_AT_GNU_pt_guarded, 0x210b)\n+DW_AT (DW_AT_GNU_locks_excluded, 0x210c)\n+DW_AT (DW_AT_GNU_exclusive_locks_required, 0x210d)\n+DW_AT (DW_AT_GNU_shared_locks_required, 0x210e)\n+/* One-definition rule violation detection.\n+   See http://gcc.gnu.org/wiki/DwarfSeparateTypeInfo .  */\n+DW_AT (DW_AT_GNU_odr_signature, 0x210f)\n+/* Template template argument name.\n+   See http://gcc.gnu.org/wiki/TemplateParmsDwarf .  */\n+DW_AT (DW_AT_GNU_template_name, 0x2110)\n+/* The GNU call site extension.\n+   See http://www.dwarfstd.org/ShowIssue.php?issue=100909.2&type=open .  */\n+DW_AT (DW_AT_GNU_call_site_value, 0x2111)\n+DW_AT (DW_AT_GNU_call_site_data_value, 0x2112)\n+DW_AT (DW_AT_GNU_call_site_target, 0x2113)\n+DW_AT (DW_AT_GNU_call_site_target_clobbered, 0x2114)\n+DW_AT (DW_AT_GNU_tail_call, 0x2115)\n+DW_AT (DW_AT_GNU_all_tail_call_sites, 0x2116)\n+DW_AT (DW_AT_GNU_all_call_sites, 0x2117)\n+DW_AT (DW_AT_GNU_all_source_call_sites, 0x2118)\n+/* Section offset into .debug_macro section.  */\n+DW_AT (DW_AT_GNU_macros, 0x2119)\n+/* Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n+DW_AT (DW_AT_GNU_dwo_name, 0x2130)\n+DW_AT (DW_AT_GNU_dwo_id, 0x2131)\n+DW_AT (DW_AT_GNU_ranges_base, 0x2132)\n+DW_AT (DW_AT_GNU_addr_base, 0x2133)\n+DW_AT (DW_AT_GNU_pubnames, 0x2134)\n+DW_AT (DW_AT_GNU_pubtypes, 0x2135)\n+/* Attribute for discriminator.\n+   See http://gcc.gnu.org/wiki/Discriminator  */\n+DW_AT (DW_AT_GNU_discriminator, 0x2136)\n+/* VMS extensions.  */\n+DW_AT (DW_AT_VMS_rtnbeg_pd_address, 0x2201)\n+/* GNAT extensions.  */\n+/* GNAT descriptive type.\n+   See http://gcc.gnu.org/wiki/DW_AT_GNAT_descriptive_type .  */\n+DW_AT (DW_AT_use_GNAT_descriptive_type, 0x2301)\n+DW_AT (DW_AT_GNAT_descriptive_type, 0x2302)\n+/* UPC extension.  */\n+DW_AT (DW_AT_upc_threads_scaled, 0x3210)\n+/* PGI (STMicroelectronics) extensions.  */\n+DW_AT (DW_AT_PGI_lbase, 0x3a00)\n+DW_AT (DW_AT_PGI_soffset, 0x3a01)\n+DW_AT (DW_AT_PGI_lstride, 0x3a02)\n+DW_END_AT\n+\n+DW_FIRST_OP (DW_OP_addr, 0x03)\n+DW_OP (DW_OP_deref, 0x06)\n+DW_OP (DW_OP_const1u, 0x08)\n+DW_OP (DW_OP_const1s, 0x09)\n+DW_OP (DW_OP_const2u, 0x0a)\n+DW_OP (DW_OP_const2s, 0x0b)\n+DW_OP (DW_OP_const4u, 0x0c)\n+DW_OP (DW_OP_const4s, 0x0d)\n+DW_OP (DW_OP_const8u, 0x0e)\n+DW_OP (DW_OP_const8s, 0x0f)\n+DW_OP (DW_OP_constu, 0x10)\n+DW_OP (DW_OP_consts, 0x11)\n+DW_OP (DW_OP_dup, 0x12)\n+DW_OP (DW_OP_drop, 0x13)\n+DW_OP (DW_OP_over, 0x14)\n+DW_OP (DW_OP_pick, 0x15)\n+DW_OP (DW_OP_swap, 0x16)\n+DW_OP (DW_OP_rot, 0x17)\n+DW_OP (DW_OP_xderef, 0x18)\n+DW_OP (DW_OP_abs, 0x19)\n+DW_OP (DW_OP_and, 0x1a)\n+DW_OP (DW_OP_div, 0x1b)\n+DW_OP (DW_OP_minus, 0x1c)\n+DW_OP (DW_OP_mod, 0x1d)\n+DW_OP (DW_OP_mul, 0x1e)\n+DW_OP (DW_OP_neg, 0x1f)\n+DW_OP (DW_OP_not, 0x20)\n+DW_OP (DW_OP_or, 0x21)\n+DW_OP (DW_OP_plus, 0x22)\n+DW_OP (DW_OP_plus_uconst, 0x23)\n+DW_OP (DW_OP_shl, 0x24)\n+DW_OP (DW_OP_shr, 0x25)\n+DW_OP (DW_OP_shra, 0x26)\n+DW_OP (DW_OP_xor, 0x27)\n+DW_OP (DW_OP_bra, 0x28)\n+DW_OP (DW_OP_eq, 0x29)\n+DW_OP (DW_OP_ge, 0x2a)\n+DW_OP (DW_OP_gt, 0x2b)\n+DW_OP (DW_OP_le, 0x2c)\n+DW_OP (DW_OP_lt, 0x2d)\n+DW_OP (DW_OP_ne, 0x2e)\n+DW_OP (DW_OP_skip, 0x2f)\n+DW_OP (DW_OP_lit0, 0x30)\n+DW_OP (DW_OP_lit1, 0x31)\n+DW_OP (DW_OP_lit2, 0x32)\n+DW_OP (DW_OP_lit3, 0x33)\n+DW_OP (DW_OP_lit4, 0x34)\n+DW_OP (DW_OP_lit5, 0x35)\n+DW_OP (DW_OP_lit6, 0x36)\n+DW_OP (DW_OP_lit7, 0x37)\n+DW_OP (DW_OP_lit8, 0x38)\n+DW_OP (DW_OP_lit9, 0x39)\n+DW_OP (DW_OP_lit10, 0x3a)\n+DW_OP (DW_OP_lit11, 0x3b)\n+DW_OP (DW_OP_lit12, 0x3c)\n+DW_OP (DW_OP_lit13, 0x3d)\n+DW_OP (DW_OP_lit14, 0x3e)\n+DW_OP (DW_OP_lit15, 0x3f)\n+DW_OP (DW_OP_lit16, 0x40)\n+DW_OP (DW_OP_lit17, 0x41)\n+DW_OP (DW_OP_lit18, 0x42)\n+DW_OP (DW_OP_lit19, 0x43)\n+DW_OP (DW_OP_lit20, 0x44)\n+DW_OP (DW_OP_lit21, 0x45)\n+DW_OP (DW_OP_lit22, 0x46)\n+DW_OP (DW_OP_lit23, 0x47)\n+DW_OP (DW_OP_lit24, 0x48)\n+DW_OP (DW_OP_lit25, 0x49)\n+DW_OP (DW_OP_lit26, 0x4a)\n+DW_OP (DW_OP_lit27, 0x4b)\n+DW_OP (DW_OP_lit28, 0x4c)\n+DW_OP (DW_OP_lit29, 0x4d)\n+DW_OP (DW_OP_lit30, 0x4e)\n+DW_OP (DW_OP_lit31, 0x4f)\n+DW_OP (DW_OP_reg0, 0x50)\n+DW_OP (DW_OP_reg1, 0x51)\n+DW_OP (DW_OP_reg2, 0x52)\n+DW_OP (DW_OP_reg3, 0x53)\n+DW_OP (DW_OP_reg4, 0x54)\n+DW_OP (DW_OP_reg5, 0x55)\n+DW_OP (DW_OP_reg6, 0x56)\n+DW_OP (DW_OP_reg7, 0x57)\n+DW_OP (DW_OP_reg8, 0x58)\n+DW_OP (DW_OP_reg9, 0x59)\n+DW_OP (DW_OP_reg10, 0x5a)\n+DW_OP (DW_OP_reg11, 0x5b)\n+DW_OP (DW_OP_reg12, 0x5c)\n+DW_OP (DW_OP_reg13, 0x5d)\n+DW_OP (DW_OP_reg14, 0x5e)\n+DW_OP (DW_OP_reg15, 0x5f)\n+DW_OP (DW_OP_reg16, 0x60)\n+DW_OP (DW_OP_reg17, 0x61)\n+DW_OP (DW_OP_reg18, 0x62)\n+DW_OP (DW_OP_reg19, 0x63)\n+DW_OP (DW_OP_reg20, 0x64)\n+DW_OP (DW_OP_reg21, 0x65)\n+DW_OP (DW_OP_reg22, 0x66)\n+DW_OP (DW_OP_reg23, 0x67)\n+DW_OP (DW_OP_reg24, 0x68)\n+DW_OP (DW_OP_reg25, 0x69)\n+DW_OP (DW_OP_reg26, 0x6a)\n+DW_OP (DW_OP_reg27, 0x6b)\n+DW_OP (DW_OP_reg28, 0x6c)\n+DW_OP (DW_OP_reg29, 0x6d)\n+DW_OP (DW_OP_reg30, 0x6e)\n+DW_OP (DW_OP_reg31, 0x6f)\n+DW_OP (DW_OP_breg0, 0x70)\n+DW_OP (DW_OP_breg1, 0x71)\n+DW_OP (DW_OP_breg2, 0x72)\n+DW_OP (DW_OP_breg3, 0x73)\n+DW_OP (DW_OP_breg4, 0x74)\n+DW_OP (DW_OP_breg5, 0x75)\n+DW_OP (DW_OP_breg6, 0x76)\n+DW_OP (DW_OP_breg7, 0x77)\n+DW_OP (DW_OP_breg8, 0x78)\n+DW_OP (DW_OP_breg9, 0x79)\n+DW_OP (DW_OP_breg10, 0x7a)\n+DW_OP (DW_OP_breg11, 0x7b)\n+DW_OP (DW_OP_breg12, 0x7c)\n+DW_OP (DW_OP_breg13, 0x7d)\n+DW_OP (DW_OP_breg14, 0x7e)\n+DW_OP (DW_OP_breg15, 0x7f)\n+DW_OP (DW_OP_breg16, 0x80)\n+DW_OP (DW_OP_breg17, 0x81)\n+DW_OP (DW_OP_breg18, 0x82)\n+DW_OP (DW_OP_breg19, 0x83)\n+DW_OP (DW_OP_breg20, 0x84)\n+DW_OP (DW_OP_breg21, 0x85)\n+DW_OP (DW_OP_breg22, 0x86)\n+DW_OP (DW_OP_breg23, 0x87)\n+DW_OP (DW_OP_breg24, 0x88)\n+DW_OP (DW_OP_breg25, 0x89)\n+DW_OP (DW_OP_breg26, 0x8a)\n+DW_OP (DW_OP_breg27, 0x8b)\n+DW_OP (DW_OP_breg28, 0x8c)\n+DW_OP (DW_OP_breg29, 0x8d)\n+DW_OP (DW_OP_breg30, 0x8e)\n+DW_OP (DW_OP_breg31, 0x8f)\n+DW_OP (DW_OP_regx, 0x90)\n+DW_OP (DW_OP_fbreg, 0x91)\n+DW_OP (DW_OP_bregx, 0x92)\n+DW_OP (DW_OP_piece, 0x93)\n+DW_OP (DW_OP_deref_size, 0x94)\n+DW_OP (DW_OP_xderef_size, 0x95)\n+DW_OP (DW_OP_nop, 0x96)\n+/* DWARF 3 extensions.  */\n+DW_OP (DW_OP_push_object_address, 0x97)\n+DW_OP (DW_OP_call2, 0x98)\n+DW_OP (DW_OP_call4, 0x99)\n+DW_OP (DW_OP_call_ref, 0x9a)\n+DW_OP (DW_OP_form_tls_address, 0x9b)\n+DW_OP (DW_OP_call_frame_cfa, 0x9c)\n+DW_OP (DW_OP_bit_piece, 0x9d)\n+\n+/* DWARF 4 extensions.  */\n+DW_OP (DW_OP_implicit_value, 0x9e)\n+DW_OP (DW_OP_stack_value, 0x9f)\n+\n+DW_OP_DUP (DW_OP_lo_user, 0xe0)\t/* Implementation-defined range start.  */\n+DW_OP_DUP (DW_OP_hi_user, 0xff)\t/* Implementation-defined range end.  */\n+\n+/* GNU extensions.  */\n+DW_OP (DW_OP_GNU_push_tls_address, 0xe0)\n+/* The following is for marking variables that are uninitialized.  */\n+DW_OP (DW_OP_GNU_uninit, 0xf0)\n+DW_OP (DW_OP_GNU_encoded_addr, 0xf1)\n+/* The GNU implicit pointer extension.\n+   See http://www.dwarfstd.org/ShowIssue.php?issue=100831.1&type=open .  */\n+DW_OP (DW_OP_GNU_implicit_pointer, 0xf2)\n+/* The GNU entry value extension.\n+   See http://www.dwarfstd.org/ShowIssue.php?issue=100909.1&type=open .  */\n+DW_OP (DW_OP_GNU_entry_value, 0xf3)\n+/* The GNU typed stack extension.\n+   See http://www.dwarfstd.org/doc/040408.1.html .  */\n+DW_OP (DW_OP_GNU_const_type, 0xf4)\n+DW_OP (DW_OP_GNU_regval_type, 0xf5)\n+DW_OP (DW_OP_GNU_deref_type, 0xf6)\n+DW_OP (DW_OP_GNU_convert, 0xf7)\n+DW_OP (DW_OP_GNU_reinterpret, 0xf9)\n+/* The GNU parameter ref extension.  */\n+DW_OP (DW_OP_GNU_parameter_ref, 0xfa)\n+/* Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n+DW_OP (DW_OP_GNU_addr_index, 0xfb)\n+DW_OP (DW_OP_GNU_const_index, 0xfc)\n+/* HP extensions.  */\n+DW_OP_DUP (DW_OP_HP_unknown, 0xe0) /* Ouch, the same as GNU_push_tls_address.  */\n+DW_OP (DW_OP_HP_is_value, 0xe1)\n+DW_OP (DW_OP_HP_fltconst4, 0xe2)\n+DW_OP (DW_OP_HP_fltconst8, 0xe3)\n+DW_OP (DW_OP_HP_mod_range, 0xe4)\n+DW_OP (DW_OP_HP_unmod_range, 0xe5)\n+DW_OP (DW_OP_HP_tls, 0xe6)\n+/* PGI (STMicroelectronics) extensions.  */\n+DW_OP (DW_OP_PGI_omp_thread_num, 0xf8)\n+DW_END_OP\n+\n+DW_FIRST_ATE (DW_ATE_void, 0x0)\n+DW_ATE (DW_ATE_address, 0x1)\n+DW_ATE (DW_ATE_boolean, 0x2)\n+DW_ATE (DW_ATE_complex_float, 0x3)\n+DW_ATE (DW_ATE_float, 0x4)\n+DW_ATE (DW_ATE_signed, 0x5)\n+DW_ATE (DW_ATE_signed_char, 0x6)\n+DW_ATE (DW_ATE_unsigned, 0x7)\n+DW_ATE (DW_ATE_unsigned_char, 0x8)\n+/* DWARF 3.  */\n+DW_ATE (DW_ATE_imaginary_float, 0x9)\n+DW_ATE (DW_ATE_packed_decimal, 0xa)\n+DW_ATE (DW_ATE_numeric_string, 0xb)\n+DW_ATE (DW_ATE_edited, 0xc)\n+DW_ATE (DW_ATE_signed_fixed, 0xd)\n+DW_ATE (DW_ATE_unsigned_fixed, 0xe)\n+DW_ATE (DW_ATE_decimal_float, 0xf)\n+/* DWARF 4.  */\n+DW_ATE (DW_ATE_UTF, 0x10)\n+\n+DW_ATE_DUP (DW_ATE_lo_user, 0x80)\n+DW_ATE_DUP (DW_ATE_hi_user, 0xff)\n+\n+/* HP extensions.  */\n+DW_ATE (DW_ATE_HP_float80, 0x80) /* Floating-point (80 bit).  */\n+DW_ATE (DW_ATE_HP_complex_float80, 0x81) /* Complex floating-point (80 bit).  */\n+DW_ATE (DW_ATE_HP_float128, 0x82) /* Floating-point (128 bit).  */\n+DW_ATE (DW_ATE_HP_complex_float128, 0x83) /* Complex fp (128 bit).  */\n+DW_ATE (DW_ATE_HP_floathpintel, 0x84) /* Floating-point (82 bit IA64).  */\n+DW_ATE (DW_ATE_HP_imaginary_float80, 0x85)\n+DW_ATE (DW_ATE_HP_imaginary_float128, 0x86)\n+DW_ATE (DW_ATE_HP_VAX_float, 0x88) /* F or G floating.  */\n+DW_ATE (DW_ATE_HP_VAX_float_d, 0x89) /* D floating.  */\n+DW_ATE (DW_ATE_HP_packed_decimal, 0x8a) /* Cobol.  */\n+DW_ATE (DW_ATE_HP_zoned_decimal, 0x8b) /* Cobol.  */\n+DW_ATE (DW_ATE_HP_edited, 0x8c) /* Cobol.  */\n+DW_ATE (DW_ATE_HP_signed_fixed, 0x8d) /* Cobol.  */\n+DW_ATE (DW_ATE_HP_unsigned_fixed, 0x8e) /* Cobol.  */\n+DW_ATE (DW_ATE_HP_VAX_complex_float, 0x8f) /* F or G floating complex.  */\n+DW_ATE (DW_ATE_HP_VAX_complex_float_d, 0x90) /* D floating complex.  */\n+\n+DW_END_ATE\n+\n+DW_FIRST_CFA (DW_CFA_advance_loc, 0x40)\n+DW_CFA (DW_CFA_offset, 0x80)\n+DW_CFA (DW_CFA_restore, 0xc0)\n+DW_CFA (DW_CFA_nop, 0x00)\n+DW_CFA (DW_CFA_set_loc, 0x01)\n+DW_CFA (DW_CFA_advance_loc1, 0x02)\n+DW_CFA (DW_CFA_advance_loc2, 0x03)\n+DW_CFA (DW_CFA_advance_loc4, 0x04)\n+DW_CFA (DW_CFA_offset_extended, 0x05)\n+DW_CFA (DW_CFA_restore_extended, 0x06)\n+DW_CFA (DW_CFA_undefined, 0x07)\n+DW_CFA (DW_CFA_same_value, 0x08)\n+DW_CFA (DW_CFA_register, 0x09)\n+DW_CFA (DW_CFA_remember_state, 0x0a)\n+DW_CFA (DW_CFA_restore_state, 0x0b)\n+DW_CFA (DW_CFA_def_cfa, 0x0c)\n+DW_CFA (DW_CFA_def_cfa_register, 0x0d)\n+DW_CFA (DW_CFA_def_cfa_offset, 0x0e)\n+/* DWARF 3.  */\n+DW_CFA (DW_CFA_def_cfa_expression, 0x0f)\n+DW_CFA (DW_CFA_expression, 0x10)\n+DW_CFA (DW_CFA_offset_extended_sf, 0x11)\n+DW_CFA (DW_CFA_def_cfa_sf, 0x12)\n+DW_CFA (DW_CFA_def_cfa_offset_sf, 0x13)\n+DW_CFA (DW_CFA_val_offset, 0x14)\n+DW_CFA (DW_CFA_val_offset_sf, 0x15)\n+DW_CFA (DW_CFA_val_expression, 0x16)\n+\n+DW_CFA (DW_CFA_lo_user, 0x1c)\n+DW_CFA (DW_CFA_hi_user, 0x3f)\n+\n+/* SGI/MIPS specific.  */\n+DW_CFA (DW_CFA_MIPS_advance_loc8, 0x1d)\n+/* GNU extensions.  */\n+DW_CFA (DW_CFA_GNU_window_save, 0x2d)\n+DW_CFA (DW_CFA_GNU_args_size, 0x2e)\n+DW_CFA (DW_CFA_GNU_negative_offset_extended, 0x2f)\n+\n+DW_END_CFA"}, {"sha": "120e2c16b4820f823c75ab8b2aa7c00bab6291fa", "filename": "src/libbacktrace/dwarf2.h", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fdwarf2.h", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.h?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,426 @@\n+/* Declarations and definitions of codes relating to the DWARF2 and\n+   DWARF3 symbolic debugging information formats.\n+   Copyright (C) 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001, 2002,\n+   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n+   Free Software Foundation, Inc.\n+\n+   Written by Gary Funck (gary@intrepid.com) The Ada Joint Program\n+   Office (AJPO), Florida State University and Silicon Graphics Inc.\n+   provided support for this effort -- June 21, 1995.\n+\n+   Derived from the DWARF 1 implementation written by Ron Guilmette\n+   (rfg@netcom.com), November 1990.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file is derived from the DWARF specification (a public document)\n+   Revision 2.0.0 (July 27, 1993) developed by the UNIX International\n+   Programming Languages Special Interest Group (UI/PLSIG) and distributed\n+   by UNIX International.  Copies of this specification are available from\n+   UNIX International, 20 Waterview Boulevard, Parsippany, NJ, 07054.\n+\n+   This file also now contains definitions from the DWARF 3 specification\n+   published Dec 20, 2005, available from: http://dwarf.freestandards.org.  */\n+\n+#ifndef _DWARF2_H\n+#define _DWARF2_H\n+\n+#define DW_TAG(name, value) , name = value\n+#define DW_TAG_DUP(name, value) , name = value\n+#define DW_FORM(name, value) , name = value\n+#define DW_AT(name, value) , name = value\n+#define DW_AT_DUP(name, value) , name = value\n+#define DW_OP(name, value) , name = value\n+#define DW_OP_DUP(name, value) , name = value\n+#define DW_ATE(name, value) , name = value\n+#define DW_ATE_DUP(name, value) , name = value\n+#define DW_CFA(name, value) , name = value\n+\n+#define DW_FIRST_TAG(name, value) enum dwarf_tag { \\\n+  name = value\n+#define DW_END_TAG };\n+#define DW_FIRST_FORM(name, value) enum dwarf_form { \\\n+  name = value\n+#define DW_END_FORM };\n+#define DW_FIRST_AT(name, value) enum dwarf_attribute { \\\n+  name = value\n+#define DW_END_AT };\n+#define DW_FIRST_OP(name, value) enum dwarf_location_atom { \\\n+  name = value\n+#define DW_END_OP };\n+#define DW_FIRST_ATE(name, value) enum dwarf_type { \\\n+  name = value\n+#define DW_END_ATE };\n+#define DW_FIRST_CFA(name, value) enum dwarf_call_frame_info { \\\n+  name = value\n+#define DW_END_CFA };\n+\n+#include \"dwarf2.def\"\n+\n+#undef DW_FIRST_TAG\n+#undef DW_END_TAG\n+#undef DW_FIRST_FORM\n+#undef DW_END_FORM\n+#undef DW_FIRST_AT\n+#undef DW_END_AT\n+#undef DW_FIRST_OP\n+#undef DW_END_OP\n+#undef DW_FIRST_ATE\n+#undef DW_END_ATE\n+#undef DW_FIRST_CFA\n+#undef DW_END_CFA\n+\n+#undef DW_TAG\n+#undef DW_TAG_DUP\n+#undef DW_FORM\n+#undef DW_AT\n+#undef DW_AT_DUP\n+#undef DW_OP\n+#undef DW_OP_DUP\n+#undef DW_ATE\n+#undef DW_ATE_DUP\n+#undef DW_CFA\n+\n+/* Flag that tells whether entry has a child or not.  */\n+#define DW_children_no   0\n+#define\tDW_children_yes  1\n+\n+#define DW_AT_stride_size   DW_AT_bit_stride  /* Note: The use of DW_AT_stride_size is deprecated.  */\n+#define DW_AT_stride   DW_AT_byte_stride  /* Note: The use of DW_AT_stride is deprecated.  */\n+\n+/* Decimal sign encodings.  */\n+enum dwarf_decimal_sign_encoding\n+  {\n+    /* DWARF 3.  */\n+    DW_DS_unsigned = 0x01,\n+    DW_DS_leading_overpunch = 0x02,\n+    DW_DS_trailing_overpunch = 0x03,\n+    DW_DS_leading_separate = 0x04,\n+    DW_DS_trailing_separate = 0x05\n+  };\n+\n+/* Endianity encodings.  */\n+enum dwarf_endianity_encoding\n+  {\n+    /* DWARF 3.  */\n+    DW_END_default = 0x00,\n+    DW_END_big = 0x01,\n+    DW_END_little = 0x02,\n+\n+    DW_END_lo_user = 0x40,\n+    DW_END_hi_user = 0xff\n+  };\n+\n+/* Array ordering names and codes.  */\n+enum dwarf_array_dim_ordering\n+  {\n+    DW_ORD_row_major = 0,\n+    DW_ORD_col_major = 1\n+  };\n+\n+/* Access attribute.  */\n+enum dwarf_access_attribute\n+  {\n+    DW_ACCESS_public = 1,\n+    DW_ACCESS_protected = 2,\n+    DW_ACCESS_private = 3\n+  };\n+\n+/* Visibility.  */\n+enum dwarf_visibility_attribute\n+  {\n+    DW_VIS_local = 1,\n+    DW_VIS_exported = 2,\n+    DW_VIS_qualified = 3\n+  };\n+\n+/* Virtuality.  */\n+enum dwarf_virtuality_attribute\n+  {\n+    DW_VIRTUALITY_none = 0,\n+    DW_VIRTUALITY_virtual = 1,\n+    DW_VIRTUALITY_pure_virtual = 2\n+  };\n+\n+/* Case sensitivity.  */\n+enum dwarf_id_case\n+  {\n+    DW_ID_case_sensitive = 0,\n+    DW_ID_up_case = 1,\n+    DW_ID_down_case = 2,\n+    DW_ID_case_insensitive = 3\n+  };\n+\n+/* Calling convention.  */\n+enum dwarf_calling_convention\n+  {\n+    DW_CC_normal = 0x1,\n+    DW_CC_program = 0x2,\n+    DW_CC_nocall = 0x3,\n+\n+    DW_CC_lo_user = 0x40,\n+    DW_CC_hi_user = 0xff,\n+\n+    DW_CC_GNU_renesas_sh = 0x40,\n+    DW_CC_GNU_borland_fastcall_i386 = 0x41,\n+\n+    /* This DW_CC_ value is not currently generated by any toolchain.  It is\n+       used internally to GDB to indicate OpenCL C functions that have been\n+       compiled with the IBM XL C for OpenCL compiler and use a non-platform\n+       calling convention for passing OpenCL C vector types.  This value may\n+       be changed freely as long as it does not conflict with any other DW_CC_\n+       value defined here.  */\n+    DW_CC_GDB_IBM_OpenCL = 0xff\n+  };\n+\n+/* Inline attribute.  */\n+enum dwarf_inline_attribute\n+  {\n+    DW_INL_not_inlined = 0,\n+    DW_INL_inlined = 1,\n+    DW_INL_declared_not_inlined = 2,\n+    DW_INL_declared_inlined = 3\n+  };\n+\n+/* Discriminant lists.  */\n+enum dwarf_discrim_list\n+  {\n+    DW_DSC_label = 0,\n+    DW_DSC_range = 1\n+  };\n+\n+/* Line number opcodes.  */\n+enum dwarf_line_number_ops\n+  {\n+    DW_LNS_extended_op = 0,\n+    DW_LNS_copy = 1,\n+    DW_LNS_advance_pc = 2,\n+    DW_LNS_advance_line = 3,\n+    DW_LNS_set_file = 4,\n+    DW_LNS_set_column = 5,\n+    DW_LNS_negate_stmt = 6,\n+    DW_LNS_set_basic_block = 7,\n+    DW_LNS_const_add_pc = 8,\n+    DW_LNS_fixed_advance_pc = 9,\n+    /* DWARF 3.  */\n+    DW_LNS_set_prologue_end = 10,\n+    DW_LNS_set_epilogue_begin = 11,\n+    DW_LNS_set_isa = 12\n+  };\n+\n+/* Line number extended opcodes.  */\n+enum dwarf_line_number_x_ops\n+  {\n+    DW_LNE_end_sequence = 1,\n+    DW_LNE_set_address = 2,\n+    DW_LNE_define_file = 3,\n+    DW_LNE_set_discriminator = 4,\n+    /* HP extensions.  */\n+    DW_LNE_HP_negate_is_UV_update      = 0x11,\n+    DW_LNE_HP_push_context             = 0x12,\n+    DW_LNE_HP_pop_context              = 0x13,\n+    DW_LNE_HP_set_file_line_column     = 0x14,\n+    DW_LNE_HP_set_routine_name         = 0x15,\n+    DW_LNE_HP_set_sequence             = 0x16,\n+    DW_LNE_HP_negate_post_semantics    = 0x17,\n+    DW_LNE_HP_negate_function_exit     = 0x18,\n+    DW_LNE_HP_negate_front_end_logical = 0x19,\n+    DW_LNE_HP_define_proc              = 0x20,\n+    DW_LNE_HP_source_file_correlation  = 0x80,\n+\n+    DW_LNE_lo_user = 0x80,\n+    DW_LNE_hi_user = 0xff\n+  };\n+\n+/* Sub-opcodes for DW_LNE_HP_source_file_correlation.  */\n+enum dwarf_line_number_hp_sfc_ops\n+  {\n+    DW_LNE_HP_SFC_formfeed = 1,\n+    DW_LNE_HP_SFC_set_listing_line = 2,\n+    DW_LNE_HP_SFC_associate = 3\n+  };\n+\n+/* Type codes for location list entries.\n+   Extension for Fission.  See http://gcc.gnu.org/wiki/DebugFission.  */\n+\n+enum dwarf_location_list_entry_type\n+  {\n+    DW_LLE_GNU_end_of_list_entry = 0,\n+    DW_LLE_GNU_base_address_selection_entry = 1,\n+    DW_LLE_GNU_start_end_entry = 2,\n+    DW_LLE_GNU_start_length_entry = 3\n+  };\n+\n+#define DW_CIE_ID\t  0xffffffff\n+#define DW64_CIE_ID\t  0xffffffffffffffffULL\n+#define DW_CIE_VERSION\t  1\n+\n+#define DW_CFA_extended   0\n+\n+#define DW_CHILDREN_no\t\t     0x00\n+#define DW_CHILDREN_yes\t\t     0x01\n+\n+#define DW_ADDR_none\t\t0\n+\n+/* Source language names and codes.  */\n+enum dwarf_source_language\n+  {\n+    DW_LANG_C89 = 0x0001,\n+    DW_LANG_C = 0x0002,\n+    DW_LANG_Ada83 = 0x0003,\n+    DW_LANG_C_plus_plus = 0x0004,\n+    DW_LANG_Cobol74 = 0x0005,\n+    DW_LANG_Cobol85 = 0x0006,\n+    DW_LANG_Fortran77 = 0x0007,\n+    DW_LANG_Fortran90 = 0x0008,\n+    DW_LANG_Pascal83 = 0x0009,\n+    DW_LANG_Modula2 = 0x000a,\n+    /* DWARF 3.  */\n+    DW_LANG_Java = 0x000b,\n+    DW_LANG_C99 = 0x000c,\n+    DW_LANG_Ada95 = 0x000d,\n+    DW_LANG_Fortran95 = 0x000e,\n+    DW_LANG_PLI = 0x000f,\n+    DW_LANG_ObjC = 0x0010,\n+    DW_LANG_ObjC_plus_plus = 0x0011,\n+    DW_LANG_UPC = 0x0012,\n+    DW_LANG_D = 0x0013,\n+    /* DWARF 4.  */\n+    DW_LANG_Python = 0x0014,\n+    /* DWARF 5.  */\n+    DW_LANG_Go = 0x0016,\n+\n+    DW_LANG_lo_user = 0x8000,\t/* Implementation-defined range start.  */\n+    DW_LANG_hi_user = 0xffff,\t/* Implementation-defined range start.  */\n+\n+    /* MIPS.  */\n+    DW_LANG_Mips_Assembler = 0x8001,\n+    /* UPC.  */\n+    DW_LANG_Upc = 0x8765,\n+    /* HP extensions.  */\n+    DW_LANG_HP_Bliss     = 0x8003,\n+    DW_LANG_HP_Basic91   = 0x8004,\n+    DW_LANG_HP_Pascal91  = 0x8005,\n+    DW_LANG_HP_IMacro    = 0x8006,\n+    DW_LANG_HP_Assembler = 0x8007\n+  };\n+\n+/* Names and codes for macro information.  */\n+enum dwarf_macinfo_record_type\n+  {\n+    DW_MACINFO_define = 1,\n+    DW_MACINFO_undef = 2,\n+    DW_MACINFO_start_file = 3,\n+    DW_MACINFO_end_file = 4,\n+    DW_MACINFO_vendor_ext = 255\n+  };\n+\n+/* Names and codes for new style macro information.  */\n+enum dwarf_macro_record_type\n+  {\n+    DW_MACRO_GNU_define = 1,\n+    DW_MACRO_GNU_undef = 2,\n+    DW_MACRO_GNU_start_file = 3,\n+    DW_MACRO_GNU_end_file = 4,\n+    DW_MACRO_GNU_define_indirect = 5,\n+    DW_MACRO_GNU_undef_indirect = 6,\n+    DW_MACRO_GNU_transparent_include = 7,\n+    /* Extensions for DWZ multifile.\n+       See http://www.dwarfstd.org/ShowIssue.php?issue=120604.1&type=open .  */\n+    DW_MACRO_GNU_define_indirect_alt = 8,\n+    DW_MACRO_GNU_undef_indirect_alt = 9,\n+    DW_MACRO_GNU_transparent_include_alt = 10,\n+    DW_MACRO_GNU_lo_user = 0xe0,\n+    DW_MACRO_GNU_hi_user = 0xff\n+  };\n+\f\n+/* @@@ For use with GNU frame unwind information.  */\n+\n+#define DW_EH_PE_absptr\t\t0x00\n+#define DW_EH_PE_omit\t\t0xff\n+\n+#define DW_EH_PE_uleb128\t0x01\n+#define DW_EH_PE_udata2\t\t0x02\n+#define DW_EH_PE_udata4\t\t0x03\n+#define DW_EH_PE_udata8\t\t0x04\n+#define DW_EH_PE_sleb128\t0x09\n+#define DW_EH_PE_sdata2\t\t0x0A\n+#define DW_EH_PE_sdata4\t\t0x0B\n+#define DW_EH_PE_sdata8\t\t0x0C\n+#define DW_EH_PE_signed\t\t0x08\n+\n+#define DW_EH_PE_pcrel\t\t0x10\n+#define DW_EH_PE_textrel\t0x20\n+#define DW_EH_PE_datarel\t0x30\n+#define DW_EH_PE_funcrel\t0x40\n+#define DW_EH_PE_aligned\t0x50\n+\n+#define DW_EH_PE_indirect\t0x80\n+\n+/* Codes for the debug sections in a dwarf package (.dwp) file.\n+   Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFissionDWP.  */\n+enum dwarf_sect\n+  {\n+    DW_SECT_INFO = 1,\n+    DW_SECT_TYPES = 2,\n+    DW_SECT_ABBREV = 3,\n+    DW_SECT_LINE = 4,\n+    DW_SECT_LOC = 5,\n+    DW_SECT_STR_OFFSETS = 6,\n+    DW_SECT_MACINFO = 7,\n+    DW_SECT_MACRO = 8,\n+    DW_SECT_MAX = 8\n+  };\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+/* Return the name of a DW_TAG_ constant, or NULL if the value is not\n+   recognized.  */\n+extern const char *get_DW_TAG_name (unsigned int tag);\n+\n+/* Return the name of a DW_AT_ constant, or NULL if the value is not\n+   recognized.  */\n+extern const char *get_DW_AT_name (unsigned int attr);\n+\n+/* Return the name of a DW_FORM_ constant, or NULL if the value is not\n+   recognized.  */\n+extern const char *get_DW_FORM_name (unsigned int form);\n+\n+/* Return the name of a DW_OP_ constant, or NULL if the value is not\n+   recognized.  */\n+extern const char *get_DW_OP_name (unsigned int op);\n+\n+/* Return the name of a DW_ATE_ constant, or NULL if the value is not\n+   recognized.  */\n+extern const char *get_DW_ATE_name (unsigned int enc);\n+\n+/* Return the name of a DW_CFA_ constant, or NULL if the value is not\n+   recognized.  */\n+extern const char *get_DW_CFA_name (unsigned int opc);\n+\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif /* _DWARF2_H */"}, {"sha": "6c5b179e90d05596ccb0b0daf6638aaddf64e331", "filename": "src/libbacktrace/elf.c", "status": "added", "additions": 976, "deletions": 0, "changes": 976, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Felf.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Felf.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,976 @@\n+/* elf.c -- Get debug data from an ELF file for backtraces.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#ifdef HAVE_DL_ITERATE_PHDR\n+#include <link.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef HAVE_DL_ITERATE_PHDR\n+\n+/* Dummy version of dl_iterate_phdr for systems that don't have it.  */\n+\n+#define dl_phdr_info x_dl_phdr_info\n+#define dl_iterate_phdr x_dl_iterate_phdr\n+\n+struct dl_phdr_info\n+{\n+  uintptr_t dlpi_addr;\n+  const char *dlpi_name;\n+};\n+\n+static int\n+dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n+\t\t\t\t  size_t, void *) ATTRIBUTE_UNUSED,\n+\t\t void *data ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+#endif /* ! defined (HAVE_DL_ITERATE_PHDR) */\n+\n+/* The configure script must tell us whether we are 32-bit or 64-bit\n+   ELF.  We could make this code test and support either possibility,\n+   but there is no point.  This code only works for the currently\n+   running executable, which means that we know the ELF mode at\n+   configure mode.  */\n+\n+#if BACKTRACE_ELF_SIZE != 32 && BACKTRACE_ELF_SIZE != 64\n+#error \"Unknown BACKTRACE_ELF_SIZE\"\n+#endif\n+\n+/* <link.h> might #include <elf.h> which might define our constants\n+   with slightly different values.  Undefine them to be safe.  */\n+\n+#undef EI_NIDENT\n+#undef EI_MAG0\n+#undef EI_MAG1\n+#undef EI_MAG2\n+#undef EI_MAG3\n+#undef EI_CLASS\n+#undef EI_DATA\n+#undef EI_VERSION\n+#undef ELF_MAG0\n+#undef ELF_MAG1\n+#undef ELF_MAG2\n+#undef ELF_MAG3\n+#undef ELFCLASS32\n+#undef ELFCLASS64\n+#undef ELFDATA2LSB\n+#undef ELFDATA2MSB\n+#undef EV_CURRENT\n+#undef ET_DYN\n+#undef SHN_LORESERVE\n+#undef SHN_XINDEX\n+#undef SHN_UNDEF\n+#undef SHT_SYMTAB\n+#undef SHT_STRTAB\n+#undef SHT_DYNSYM\n+#undef STT_OBJECT\n+#undef STT_FUNC\n+\n+/* Basic types.  */\n+\n+typedef uint16_t b_elf_half;    /* Elf_Half.  */\n+typedef uint32_t b_elf_word;    /* Elf_Word.  */\n+typedef int32_t  b_elf_sword;   /* Elf_Sword.  */\n+\n+#if BACKTRACE_ELF_SIZE == 32\n+\n+typedef uint32_t b_elf_addr;    /* Elf_Addr.  */\n+typedef uint32_t b_elf_off;     /* Elf_Off.  */\n+\n+typedef uint32_t b_elf_wxword;  /* 32-bit Elf_Word, 64-bit ELF_Xword.  */\n+\n+#else\n+\n+typedef uint64_t b_elf_addr;    /* Elf_Addr.  */\n+typedef uint64_t b_elf_off;     /* Elf_Off.  */\n+typedef uint64_t b_elf_xword;   /* Elf_Xword.  */\n+typedef int64_t  b_elf_sxword;  /* Elf_Sxword.  */\n+\n+typedef uint64_t b_elf_wxword;  /* 32-bit Elf_Word, 64-bit ELF_Xword.  */\n+\n+#endif\n+\n+/* Data structures and associated constants.  */\n+\n+#define EI_NIDENT 16\n+\n+typedef struct {\n+  unsigned char\te_ident[EI_NIDENT];\t/* ELF \"magic number\" */\n+  b_elf_half\te_type;\t\t\t/* Identifies object file type */\n+  b_elf_half\te_machine;\t\t/* Specifies required architecture */\n+  b_elf_word\te_version;\t\t/* Identifies object file version */\n+  b_elf_addr\te_entry;\t\t/* Entry point virtual address */\n+  b_elf_off\te_phoff;\t\t/* Program header table file offset */\n+  b_elf_off\te_shoff;\t\t/* Section header table file offset */\n+  b_elf_word\te_flags;\t\t/* Processor-specific flags */\n+  b_elf_half\te_ehsize;\t\t/* ELF header size in bytes */\n+  b_elf_half\te_phentsize;\t\t/* Program header table entry size */\n+  b_elf_half\te_phnum;\t\t/* Program header table entry count */\n+  b_elf_half\te_shentsize;\t\t/* Section header table entry size */\n+  b_elf_half\te_shnum;\t\t/* Section header table entry count */\n+  b_elf_half\te_shstrndx;\t\t/* Section header string table index */\n+} b_elf_ehdr;  /* Elf_Ehdr.  */\n+\n+#define EI_MAG0 0\n+#define EI_MAG1 1\n+#define EI_MAG2 2\n+#define EI_MAG3 3\n+#define EI_CLASS 4\n+#define EI_DATA 5\n+#define EI_VERSION 6\n+\n+#define ELFMAG0 0x7f\n+#define ELFMAG1 'E'\n+#define ELFMAG2 'L'\n+#define ELFMAG3 'F'\n+\n+#define ELFCLASS32 1\n+#define ELFCLASS64 2\n+\n+#define ELFDATA2LSB 1\n+#define ELFDATA2MSB 2\n+\n+#define EV_CURRENT 1\n+\n+#define ET_DYN 3\n+\n+typedef struct {\n+  b_elf_word\tsh_name;\t\t/* Section name, index in string tbl */\n+  b_elf_word\tsh_type;\t\t/* Type of section */\n+  b_elf_wxword\tsh_flags;\t\t/* Miscellaneous section attributes */\n+  b_elf_addr\tsh_addr;\t\t/* Section virtual addr at execution */\n+  b_elf_off\tsh_offset;\t\t/* Section file offset */\n+  b_elf_wxword\tsh_size;\t\t/* Size of section in bytes */\n+  b_elf_word\tsh_link;\t\t/* Index of another section */\n+  b_elf_word\tsh_info;\t\t/* Additional section information */\n+  b_elf_wxword\tsh_addralign;\t\t/* Section alignment */\n+  b_elf_wxword\tsh_entsize;\t\t/* Entry size if section holds table */\n+} b_elf_shdr;  /* Elf_Shdr.  */\n+\n+#define SHN_UNDEF\t0x0000\t\t/* Undefined section */\n+#define SHN_LORESERVE\t0xFF00\t\t/* Begin range of reserved indices */\n+#define SHN_XINDEX\t0xFFFF\t\t/* Section index is held elsewhere */\n+\n+#define SHT_SYMTAB 2\n+#define SHT_STRTAB 3\n+#define SHT_DYNSYM 11\n+\n+#if BACKTRACE_ELF_SIZE == 32\n+\n+typedef struct\n+{\n+  b_elf_word\tst_name;\t\t/* Symbol name, index in string tbl */\n+  b_elf_addr\tst_value;\t\t/* Symbol value */\n+  b_elf_word\tst_size;\t\t/* Symbol size */\n+  unsigned char\tst_info;\t\t/* Symbol binding and type */\n+  unsigned char\tst_other;\t\t/* Visibility and other data */\n+  b_elf_half\tst_shndx;\t\t/* Symbol section index */\n+} b_elf_sym;  /* Elf_Sym.  */\n+\n+#else /* BACKTRACE_ELF_SIZE != 32 */\n+\n+typedef struct\n+{\n+  b_elf_word\tst_name;\t\t/* Symbol name, index in string tbl */\n+  unsigned char\tst_info;\t\t/* Symbol binding and type */\n+  unsigned char\tst_other;\t\t/* Visibility and other data */\n+  b_elf_half\tst_shndx;\t\t/* Symbol section index */\n+  b_elf_addr\tst_value;\t\t/* Symbol value */\n+  b_elf_xword\tst_size;\t\t/* Symbol size */\n+} b_elf_sym;  /* Elf_Sym.  */\n+\n+#endif /* BACKTRACE_ELF_SIZE != 32 */\n+\n+#define STT_OBJECT 1\n+#define STT_FUNC 2\n+\n+/* An index of ELF sections we care about.  */\n+\n+enum debug_section\n+{\n+  DEBUG_INFO,\n+  DEBUG_LINE,\n+  DEBUG_ABBREV,\n+  DEBUG_RANGES,\n+  DEBUG_STR,\n+  DEBUG_MAX\n+};\n+\n+/* Names of sections, indexed by enum elf_section.  */\n+\n+static const char * const debug_section_names[DEBUG_MAX] =\n+{\n+  \".debug_info\",\n+  \".debug_line\",\n+  \".debug_abbrev\",\n+  \".debug_ranges\",\n+  \".debug_str\"\n+};\n+\n+/* Information we gather for the sections we care about.  */\n+\n+struct debug_section_info\n+{\n+  /* Section file offset.  */\n+  off_t offset;\n+  /* Section size.  */\n+  size_t size;\n+  /* Section contents, after read from file.  */\n+  const unsigned char *data;\n+};\n+\n+/* Information we keep for an ELF symbol.  */\n+\n+struct elf_symbol\n+{\n+  /* The name of the symbol.  */\n+  const char *name;\n+  /* The address of the symbol.  */\n+  uintptr_t address;\n+  /* The size of the symbol.  */\n+  size_t size;\n+};\n+\n+/* Information to pass to elf_syminfo.  */\n+\n+struct elf_syminfo_data\n+{\n+  /* Symbols for the next module.  */\n+  struct elf_syminfo_data *next;\n+  /* The ELF symbols, sorted by address.  */\n+  struct elf_symbol *symbols;\n+  /* The number of symbols.  */\n+  size_t count;\n+};\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+elf_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t     uintptr_t pc ATTRIBUTE_UNUSED,\n+\t     backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t     backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in ELF executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+elf_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t    uintptr_t addr ATTRIBUTE_UNUSED,\n+\t    backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t    backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in ELF executable\", -1);\n+}\n+\n+/* Compare struct elf_symbol for qsort.  */\n+\n+static int\n+elf_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct elf_symbol *e1 = (const struct elf_symbol *) v1;\n+  const struct elf_symbol *e2 = (const struct elf_symbol *) v2;\n+\n+  if (e1->address < e2->address)\n+    return -1;\n+  else if (e1->address > e2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare an ADDR against an elf_symbol for bsearch.  We allocate one\n+   extra entry in the array so that this can look safely at the next\n+   entry.  */\n+\n+static int\n+elf_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct elf_symbol *entry = (const struct elf_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if (addr >= entry->address + entry->size)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Initialize the symbol table info for elf_syminfo.  */\n+\n+static int\n+elf_initialize_syminfo (struct backtrace_state *state,\n+\t\t\tuintptr_t base_address,\n+\t\t\tconst unsigned char *symtab_data, size_t symtab_size,\n+\t\t\tconst unsigned char *strtab, size_t strtab_size,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data, struct elf_syminfo_data *sdata)\n+{\n+  size_t sym_count;\n+  const b_elf_sym *sym;\n+  size_t elf_symbol_count;\n+  size_t elf_symbol_size;\n+  struct elf_symbol *elf_symbols;\n+  size_t i;\n+  unsigned int j;\n+\n+  sym_count = symtab_size / sizeof (b_elf_sym);\n+\n+  /* We only care about function symbols.  Count them.  */\n+  sym = (const b_elf_sym *) symtab_data;\n+  elf_symbol_count = 0;\n+  for (i = 0; i < sym_count; ++i, ++sym)\n+    {\n+      int info;\n+\n+      info = sym->st_info & 0xf;\n+      if ((info == STT_FUNC || info == STT_OBJECT)\n+\t  && sym->st_shndx != SHN_UNDEF)\n+\t++elf_symbol_count;\n+    }\n+\n+  elf_symbol_size = elf_symbol_count * sizeof (struct elf_symbol);\n+  elf_symbols = ((struct elf_symbol *)\n+\t\t backtrace_alloc (state, elf_symbol_size, error_callback,\n+\t\t\t\t  data));\n+  if (elf_symbols == NULL)\n+    return 0;\n+\n+  sym = (const b_elf_sym *) symtab_data;\n+  j = 0;\n+  for (i = 0; i < sym_count; ++i, ++sym)\n+    {\n+      int info;\n+\n+      info = sym->st_info & 0xf;\n+      if (info != STT_FUNC && info != STT_OBJECT)\n+\tcontinue;\n+      if (sym->st_shndx == SHN_UNDEF)\n+\tcontinue;\n+      if (sym->st_name >= strtab_size)\n+\t{\n+\t  error_callback (data, \"symbol string index out of range\", 0);\n+\t  backtrace_free (state, elf_symbols, elf_symbol_size, error_callback,\n+\t\t\t  data);\n+\t  return 0;\n+\t}\n+      elf_symbols[j].name = (const char *) strtab + sym->st_name;\n+      elf_symbols[j].address = sym->st_value + base_address;\n+      elf_symbols[j].size = sym->st_size;\n+      ++j;\n+    }\n+\n+  qsort (elf_symbols, elf_symbol_count, sizeof (struct elf_symbol),\n+\t elf_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = elf_symbols;\n+  sdata->count = elf_symbol_count;\n+\n+  return 1;\n+}\n+\n+/* Add EDATA to the list in STATE.  */\n+\n+static void\n+elf_add_syminfo_data (struct backtrace_state *state,\n+\t\t      struct elf_syminfo_data *edata)\n+{\n+  if (!state->threaded)\n+    {\n+      struct elf_syminfo_data **pp;\n+\n+      for (pp = (struct elf_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = edata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct elf_syminfo_data **pp;\n+\n+\t  pp = (struct elf_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct elf_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, edata))\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* Return the symbol name and value for an ADDR.  */\n+\n+static void\n+elf_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t     backtrace_syminfo_callback callback,\n+\t     backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t     void *data)\n+{\n+  struct elf_syminfo_data *edata;\n+  struct elf_symbol *sym = NULL;\n+\n+  if (!state->threaded)\n+    {\n+      for (edata = (struct elf_syminfo_data *) state->syminfo_data;\n+\t   edata != NULL;\n+\t   edata = edata->next)\n+\t{\n+\t  sym = ((struct elf_symbol *)\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n+\t\t\t  sizeof (struct elf_symbol), elf_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct elf_syminfo_data **pp;\n+\n+      pp = (struct elf_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  edata = backtrace_atomic_load_pointer (pp);\n+\t  if (edata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct elf_symbol *)\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n+\t\t\t  sizeof (struct elf_symbol), elf_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &edata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->address, sym->size);\n+}\n+\n+/* Add the backtrace data for one ELF file.  Returns 1 on success,\n+   0 on failure (in both cases descriptor is closed) or -1 if exe\n+   is non-zero and the ELF file is ET_DYN, which tells the caller that\n+   elf_add will need to be called on the descriptor again after\n+   base_address is determined.  */\n+\n+static int\n+elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n+\t backtrace_error_callback error_callback, void *data,\n+\t fileline *fileline_fn, int *found_sym, int *found_dwarf, int exe)\n+{\n+  struct backtrace_view ehdr_view;\n+  b_elf_ehdr ehdr;\n+  off_t shoff;\n+  unsigned int shnum;\n+  unsigned int shstrndx;\n+  struct backtrace_view shdrs_view;\n+  int shdrs_view_valid;\n+  const b_elf_shdr *shdrs;\n+  const b_elf_shdr *shstrhdr;\n+  size_t shstr_size;\n+  off_t shstr_off;\n+  struct backtrace_view names_view;\n+  int names_view_valid;\n+  const char *names;\n+  unsigned int symtab_shndx;\n+  unsigned int dynsym_shndx;\n+  unsigned int i;\n+  struct debug_section_info sections[DEBUG_MAX];\n+  struct backtrace_view symtab_view;\n+  int symtab_view_valid;\n+  struct backtrace_view strtab_view;\n+  int strtab_view_valid;\n+  off_t min_offset;\n+  off_t max_offset;\n+  struct backtrace_view debug_view;\n+  int debug_view_valid;\n+\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  shdrs_view_valid = 0;\n+  names_view_valid = 0;\n+  symtab_view_valid = 0;\n+  strtab_view_valid = 0;\n+  debug_view_valid = 0;\n+\n+  if (!backtrace_get_view (state, descriptor, 0, sizeof ehdr, error_callback,\n+\t\t\t   data, &ehdr_view))\n+    goto fail;\n+\n+  memcpy (&ehdr, ehdr_view.data, sizeof ehdr);\n+\n+  backtrace_release_view (state, &ehdr_view, error_callback, data);\n+\n+  if (ehdr.e_ident[EI_MAG0] != ELFMAG0\n+      || ehdr.e_ident[EI_MAG1] != ELFMAG1\n+      || ehdr.e_ident[EI_MAG2] != ELFMAG2\n+      || ehdr.e_ident[EI_MAG3] != ELFMAG3)\n+    {\n+      error_callback (data, \"executable file is not ELF\", 0);\n+      goto fail;\n+    }\n+  if (ehdr.e_ident[EI_VERSION] != EV_CURRENT)\n+    {\n+      error_callback (data, \"executable file is unrecognized ELF version\", 0);\n+      goto fail;\n+    }\n+\n+#if BACKTRACE_ELF_SIZE == 32\n+#define BACKTRACE_ELFCLASS ELFCLASS32\n+#else\n+#define BACKTRACE_ELFCLASS ELFCLASS64\n+#endif\n+\n+  if (ehdr.e_ident[EI_CLASS] != BACKTRACE_ELFCLASS)\n+    {\n+      error_callback (data, \"executable file is unexpected ELF class\", 0);\n+      goto fail;\n+    }\n+\n+  if (ehdr.e_ident[EI_DATA] != ELFDATA2LSB\n+      && ehdr.e_ident[EI_DATA] != ELFDATA2MSB)\n+    {\n+      error_callback (data, \"executable file has unknown endianness\", 0);\n+      goto fail;\n+    }\n+\n+  /* If the executable is ET_DYN, it is either a PIE, or we are running\n+     directly a shared library with .interp.  We need to wait for\n+     dl_iterate_phdr in that case to determine the actual base_address.  */\n+  if (exe && ehdr.e_type == ET_DYN)\n+    return -1;\n+\n+  shoff = ehdr.e_shoff;\n+  shnum = ehdr.e_shnum;\n+  shstrndx = ehdr.e_shstrndx;\n+\n+  if ((shnum == 0 || shstrndx == SHN_XINDEX)\n+      && shoff != 0)\n+    {\n+      struct backtrace_view shdr_view;\n+      const b_elf_shdr *shdr;\n+\n+      if (!backtrace_get_view (state, descriptor, shoff, sizeof shdr,\n+\t\t\t       error_callback, data, &shdr_view))\n+\tgoto fail;\n+\n+      shdr = (const b_elf_shdr *) shdr_view.data;\n+\n+      if (shnum == 0)\n+\tshnum = shdr->sh_size;\n+\n+      if (shstrndx == SHN_XINDEX)\n+\t{\n+\t  shstrndx = shdr->sh_link;\n+\n+\t  /* Versions of the GNU binutils between 2.12 and 2.18 did\n+\t     not handle objects with more than SHN_LORESERVE sections\n+\t     correctly.  All large section indexes were offset by\n+\t     0x100.  There is more information at\n+\t     http://sourceware.org/bugzilla/show_bug.cgi?id-5900 .\n+\t     Fortunately these object files are easy to detect, as the\n+\t     GNU binutils always put the section header string table\n+\t     near the end of the list of sections.  Thus if the\n+\t     section header string table index is larger than the\n+\t     number of sections, then we know we have to subtract\n+\t     0x100 to get the real section index.  */\n+\t  if (shstrndx >= shnum && shstrndx >= SHN_LORESERVE + 0x100)\n+\t    shstrndx -= 0x100;\n+\t}\n+\n+      backtrace_release_view (state, &shdr_view, error_callback, data);\n+    }\n+\n+  /* To translate PC to file/line when using DWARF, we need to find\n+     the .debug_info and .debug_line sections.  */\n+\n+  /* Read the section headers, skipping the first one.  */\n+\n+  if (!backtrace_get_view (state, descriptor, shoff + sizeof (b_elf_shdr),\n+\t\t\t   (shnum - 1) * sizeof (b_elf_shdr),\n+\t\t\t   error_callback, data, &shdrs_view))\n+    goto fail;\n+  shdrs_view_valid = 1;\n+  shdrs = (const b_elf_shdr *) shdrs_view.data;\n+\n+  /* Read the section names.  */\n+\n+  shstrhdr = &shdrs[shstrndx - 1];\n+  shstr_size = shstrhdr->sh_size;\n+  shstr_off = shstrhdr->sh_offset;\n+\n+  if (!backtrace_get_view (state, descriptor, shstr_off, shstr_size,\n+\t\t\t   error_callback, data, &names_view))\n+    goto fail;\n+  names_view_valid = 1;\n+  names = (const char *) names_view.data;\n+\n+  symtab_shndx = 0;\n+  dynsym_shndx = 0;\n+\n+  memset (sections, 0, sizeof sections);\n+\n+  /* Look for the symbol table.  */\n+  for (i = 1; i < shnum; ++i)\n+    {\n+      const b_elf_shdr *shdr;\n+      unsigned int sh_name;\n+      const char *name;\n+      int j;\n+\n+      shdr = &shdrs[i - 1];\n+\n+      if (shdr->sh_type == SHT_SYMTAB)\n+\tsymtab_shndx = i;\n+      else if (shdr->sh_type == SHT_DYNSYM)\n+\tdynsym_shndx = i;\n+\n+      sh_name = shdr->sh_name;\n+      if (sh_name >= shstr_size)\n+\t{\n+\t  error_callback (data, \"ELF section name out of range\", 0);\n+\t  goto fail;\n+\t}\n+\n+      name = names + sh_name;\n+\n+      for (j = 0; j < (int) DEBUG_MAX; ++j)\n+\t{\n+\t  if (strcmp (name, debug_section_names[j]) == 0)\n+\t    {\n+\t      sections[j].offset = shdr->sh_offset;\n+\t      sections[j].size = shdr->sh_size;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (symtab_shndx == 0)\n+    symtab_shndx = dynsym_shndx;\n+  if (symtab_shndx != 0)\n+    {\n+      const b_elf_shdr *symtab_shdr;\n+      unsigned int strtab_shndx;\n+      const b_elf_shdr *strtab_shdr;\n+      struct elf_syminfo_data *sdata;\n+\n+      symtab_shdr = &shdrs[symtab_shndx - 1];\n+      strtab_shndx = symtab_shdr->sh_link;\n+      if (strtab_shndx >= shnum)\n+\t{\n+\t  error_callback (data,\n+\t\t\t  \"ELF symbol table strtab link out of range\", 0);\n+\t  goto fail;\n+\t}\n+      strtab_shdr = &shdrs[strtab_shndx - 1];\n+\n+      if (!backtrace_get_view (state, descriptor, symtab_shdr->sh_offset,\n+\t\t\t       symtab_shdr->sh_size, error_callback, data,\n+\t\t\t       &symtab_view))\n+\tgoto fail;\n+      symtab_view_valid = 1;\n+\n+      if (!backtrace_get_view (state, descriptor, strtab_shdr->sh_offset,\n+\t\t\t       strtab_shdr->sh_size, error_callback, data,\n+\t\t\t       &strtab_view))\n+\tgoto fail;\n+      strtab_view_valid = 1;\n+\n+      sdata = ((struct elf_syminfo_data *)\n+\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+      if (sdata == NULL)\n+\tgoto fail;\n+\n+      if (!elf_initialize_syminfo (state, base_address,\n+\t\t\t\t   symtab_view.data, symtab_shdr->sh_size,\n+\t\t\t\t   strtab_view.data, strtab_shdr->sh_size,\n+\t\t\t\t   error_callback, data, sdata))\n+\t{\n+\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      /* We no longer need the symbol table, but we hold on to the\n+\t string table permanently.  */\n+      backtrace_release_view (state, &symtab_view, error_callback, data);\n+\n+      *found_sym = 1;\n+\n+      elf_add_syminfo_data (state, sdata);\n+    }\n+\n+  /* FIXME: Need to handle compressed debug sections.  */\n+\n+  backtrace_release_view (state, &shdrs_view, error_callback, data);\n+  shdrs_view_valid = 0;\n+  backtrace_release_view (state, &names_view, error_callback, data);\n+  names_view_valid = 0;\n+\n+  /* Read all the debug sections in a single view, since they are\n+     probably adjacent in the file.  We never release this view.  */\n+\n+  min_offset = 0;\n+  max_offset = 0;\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      off_t end;\n+\n+      if (sections[i].size == 0)\n+\tcontinue;\n+      if (min_offset == 0 || sections[i].offset < min_offset)\n+\tmin_offset = sections[i].offset;\n+      end = sections[i].offset + sections[i].size;\n+      if (end > max_offset)\n+\tmax_offset = end;\n+    }\n+  if (min_offset == 0 || max_offset == 0)\n+    {\n+      if (!backtrace_close (descriptor, error_callback, data))\n+\tgoto fail;\n+      *fileline_fn = elf_nodebug;\n+      return 1;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, min_offset,\n+\t\t\t   max_offset - min_offset,\n+\t\t\t   error_callback, data, &debug_view))\n+    goto fail;\n+  debug_view_valid = 1;\n+\n+  /* We've read all we need from the executable.  */\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      if (sections[i].size == 0)\n+\tsections[i].data = NULL;\n+      else\n+\tsections[i].data = ((const unsigned char *) debug_view.data\n+\t\t\t    + (sections[i].offset - min_offset));\n+    }\n+\n+  if (!backtrace_dwarf_add (state, base_address,\n+\t\t\t    sections[DEBUG_INFO].data,\n+\t\t\t    sections[DEBUG_INFO].size,\n+\t\t\t    sections[DEBUG_LINE].data,\n+\t\t\t    sections[DEBUG_LINE].size,\n+\t\t\t    sections[DEBUG_ABBREV].data,\n+\t\t\t    sections[DEBUG_ABBREV].size,\n+\t\t\t    sections[DEBUG_RANGES].data,\n+\t\t\t    sections[DEBUG_RANGES].size,\n+\t\t\t    sections[DEBUG_STR].data,\n+\t\t\t    sections[DEBUG_STR].size,\n+\t\t\t    ehdr.e_ident[EI_DATA] == ELFDATA2MSB,\n+\t\t\t    error_callback, data, fileline_fn))\n+    goto fail;\n+\n+  *found_dwarf = 1;\n+\n+  return 1;\n+\n+ fail:\n+  if (shdrs_view_valid)\n+    backtrace_release_view (state, &shdrs_view, error_callback, data);\n+  if (names_view_valid)\n+    backtrace_release_view (state, &names_view, error_callback, data);\n+  if (symtab_view_valid)\n+    backtrace_release_view (state, &symtab_view, error_callback, data);\n+  if (strtab_view_valid)\n+    backtrace_release_view (state, &strtab_view, error_callback, data);\n+  if (debug_view_valid)\n+    backtrace_release_view (state, &debug_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Data passed to phdr_callback.  */\n+\n+struct phdr_data\n+{\n+  struct backtrace_state *state;\n+  backtrace_error_callback error_callback;\n+  void *data;\n+  fileline *fileline_fn;\n+  int *found_sym;\n+  int *found_dwarf;\n+  int exe_descriptor;\n+};\n+\n+/* Callback passed to dl_iterate_phdr.  Load debug info from shared\n+   libraries.  */\n+\n+static int\n+phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n+\t       void *pdata)\n+{\n+  struct phdr_data *pd = (struct phdr_data *) pdata;\n+  int descriptor;\n+  int does_not_exist;\n+  fileline elf_fileline_fn;\n+  int found_dwarf;\n+\n+  /* There is not much we can do if we don't have the module name,\n+     unless executable is ET_DYN, where we expect the very first\n+     phdr_callback to be for the PIE.  */\n+  if (info->dlpi_name == NULL || info->dlpi_name[0] == '\\0')\n+    {\n+      if (pd->exe_descriptor == -1)\n+\treturn 0;\n+      descriptor = pd->exe_descriptor;\n+      pd->exe_descriptor = -1;\n+    }\n+  else\n+    {\n+      if (pd->exe_descriptor != -1)\n+\t{\n+\t  backtrace_close (pd->exe_descriptor, pd->error_callback, pd->data);\n+\t  pd->exe_descriptor = -1;\n+\t}\n+\n+      descriptor = backtrace_open (info->dlpi_name, pd->error_callback,\n+\t\t\t\t   pd->data, &does_not_exist);\n+      if (descriptor < 0)\n+\treturn 0;\n+    }\n+\n+  if (elf_add (pd->state, descriptor, info->dlpi_addr, pd->error_callback,\n+\t       pd->data, &elf_fileline_fn, pd->found_sym, &found_dwarf, 0))\n+    {\n+      if (found_dwarf)\n+\t{\n+\t  *pd->found_dwarf = 1;\n+\t  *pd->fileline_fn = elf_fileline_fn;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Initialize the backtrace data we need from an ELF executable.  At\n+   the ELF level, all we need to do is find the debug info\n+   sections.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  int found_sym;\n+  int found_dwarf;\n+  fileline elf_fileline_fn;\n+  struct phdr_data pd;\n+\n+  ret = elf_add (state, descriptor, 0, error_callback, data, &elf_fileline_fn,\n+\t\t &found_sym, &found_dwarf, 1);\n+  if (!ret)\n+    return 0;\n+\n+  pd.state = state;\n+  pd.error_callback = error_callback;\n+  pd.data = data;\n+  pd.fileline_fn = &elf_fileline_fn;\n+  pd.found_sym = &found_sym;\n+  pd.found_dwarf = &found_dwarf;\n+  pd.exe_descriptor = ret < 0 ? descriptor : -1;\n+\n+  dl_iterate_phdr (phdr_callback, (void *) &pd);\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = elf_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = elf_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, elf_syminfo);\n+      else\n+\t__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, elf_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == elf_nodebug)\n+\t*fileline_fn = elf_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == elf_nodebug)\n+\t*fileline_fn = elf_fileline_fn;\n+    }\n+\n+  return 1;\n+}"}, {"sha": "bab5351cab38d9935f336b652e6ba0d29c8b7ec5", "filename": "src/libbacktrace/fileline.c", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Ffileline.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffileline.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,194 @@\n+/* fileline.c -- Get file and line number information in a backtrace.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdlib.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef HAVE_GETEXECNAME\n+#define getexecname() NULL\n+#endif\n+\n+/* Initialize the fileline information from the executable.  Returns 1\n+   on success, 0 on failure.  */\n+\n+static int\n+fileline_initialize (struct backtrace_state *state,\n+\t\t     backtrace_error_callback error_callback, void *data)\n+{\n+  int failed;\n+  fileline fileline_fn;\n+  int pass;\n+  int called_error_callback;\n+  int descriptor;\n+\n+  if (!state->threaded)\n+    failed = state->fileline_initialization_failed;\n+  else\n+    failed = backtrace_atomic_load_int (&state->fileline_initialization_failed);\n+\n+  if (failed)\n+    {\n+      error_callback (data, \"failed to read executable information\", -1);\n+      return 0;\n+    }\n+\n+  if (!state->threaded)\n+    fileline_fn = state->fileline_fn;\n+  else\n+    fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+  if (fileline_fn != NULL)\n+    return 1;\n+\n+  /* We have not initialized the information.  Do it now.  */\n+\n+  descriptor = -1;\n+  called_error_callback = 0;\n+  for (pass = 0; pass < 4; ++pass)\n+    {\n+      const char *filename;\n+      int does_not_exist;\n+\n+      switch (pass)\n+\t{\n+\tcase 0:\n+\t  filename = state->filename;\n+\t  break;\n+\tcase 1:\n+\t  filename = getexecname ();\n+\t  break;\n+\tcase 2:\n+\t  filename = \"/proc/self/exe\";\n+\t  break;\n+\tcase 3:\n+\t  filename = \"/proc/curproc/file\";\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      if (filename == NULL)\n+\tcontinue;\n+\n+      descriptor = backtrace_open (filename, error_callback, data,\n+\t\t\t\t   &does_not_exist);\n+      if (descriptor < 0 && !does_not_exist)\n+\t{\n+\t  called_error_callback = 1;\n+\t  break;\n+\t}\n+      if (descriptor >= 0)\n+\tbreak;\n+    }\n+\n+  if (descriptor < 0)\n+    {\n+      if (!called_error_callback)\n+\t{\n+\t  if (state->filename != NULL)\n+\t    error_callback (data, state->filename, ENOENT);\n+\t  else\n+\t    error_callback (data,\n+\t\t\t    \"libbacktrace could not find executable to open\",\n+\t\t\t    0);\n+\t}\n+      failed = 1;\n+    }\n+\n+  if (!failed)\n+    {\n+      if (!backtrace_initialize (state, descriptor, error_callback, data,\n+\t\t\t\t &fileline_fn))\n+\tfailed = 1;\n+    }\n+\n+  if (failed)\n+    {\n+      if (!state->threaded)\n+\tstate->fileline_initialization_failed = 1;\n+      else\n+\tbacktrace_atomic_store_int (&state->fileline_initialization_failed, 1);\n+      return 0;\n+    }\n+\n+  if (!state->threaded)\n+    state->fileline_fn = fileline_fn;\n+  else\n+    {\n+      backtrace_atomic_store_pointer (&state->fileline_fn, fileline_fn);\n+\n+      /* Note that if two threads initialize at once, one of the data\n+\t sets may be leaked.  */\n+    }\n+\n+  return 1;\n+}\n+\n+/* Given a PC, find the file name, line number, and function name.  */\n+\n+int\n+backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t  backtrace_full_callback callback,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  if (!fileline_initialize (state, error_callback, data))\n+    return 0;\n+\n+  if (state->fileline_initialization_failed)\n+    return 0;\n+\n+  return state->fileline_fn (state, pc, callback, error_callback, data);\n+}\n+\n+/* Given a PC, find the symbol for it, and its value.  */\n+\n+int\n+backtrace_syminfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t   backtrace_syminfo_callback callback,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  if (!fileline_initialize (state, error_callback, data))\n+    return 0;\n+\n+  if (state->fileline_initialization_failed)\n+    return 0;\n+\n+  state->syminfo_fn (state, pc, callback, error_callback, data);\n+  return 1;\n+}"}, {"sha": "e799a51b6ad014d74581da6d92ce337be896c86a", "filename": "src/libbacktrace/filenames.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Ffilenames.h", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Ffilenames.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffilenames.h?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,97 @@\n+/* Macros for taking apart, interpreting and processing file names.\n+\n+   These are here because some non-Posix (a.k.a. DOSish) systems have\n+   drive letter brain-damage at the beginning of an absolute file name,\n+   use forward- and back-slash in path names interchangeably, and\n+   some of them have case-insensitive file names.\n+\n+   Copyright 2000, 2001, 2007, 2010 Free Software Foundation, Inc.\n+\n+This file is part of BFD, the Binary File Descriptor library.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+#ifndef FILENAMES_H\n+#define FILENAMES_H\n+\n+#include \"hashtab.h\" /* for hashval_t */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)\n+#  ifndef HAVE_DOS_BASED_FILE_SYSTEM\n+#    define HAVE_DOS_BASED_FILE_SYSTEM 1\n+#  endif\n+#  ifndef HAVE_CASE_INSENSITIVE_FILE_SYSTEM\n+#    define HAVE_CASE_INSENSITIVE_FILE_SYSTEM 1\n+#  endif\n+#  define HAS_DRIVE_SPEC(f) HAS_DOS_DRIVE_SPEC (f)\n+#  define IS_DIR_SEPARATOR(c) IS_DOS_DIR_SEPARATOR (c)\n+#  define IS_ABSOLUTE_PATH(f) IS_DOS_ABSOLUTE_PATH (f)\n+#else /* not DOSish */\n+#  if defined(__APPLE__)\n+#    ifndef HAVE_CASE_INSENSITIVE_FILE_SYSTEM\n+#      define HAVE_CASE_INSENSITIVE_FILE_SYSTEM 1\n+#    endif\n+#  endif /* __APPLE__ */\n+#  define HAS_DRIVE_SPEC(f) (0)\n+#  define IS_DIR_SEPARATOR(c) IS_UNIX_DIR_SEPARATOR (c)\n+#  define IS_ABSOLUTE_PATH(f) IS_UNIX_ABSOLUTE_PATH (f)\n+#endif\n+\n+#define IS_DIR_SEPARATOR_1(dos_based, c)\t\t\t\t\\\n+  (((c) == '/')\t\t\t\t\t\t\t\t\\\n+   || (((c) == '\\\\') && (dos_based)))\n+\n+#define HAS_DRIVE_SPEC_1(dos_based, f)\t\t\t\\\n+  ((f)[0] && ((f)[1] == ':') && (dos_based))\n+\n+/* Remove the drive spec from F, assuming HAS_DRIVE_SPEC (f).\n+   The result is a pointer to the remainder of F.  */\n+#define STRIP_DRIVE_SPEC(f)\t((f) + 2)\n+\n+#define IS_DOS_DIR_SEPARATOR(c) IS_DIR_SEPARATOR_1 (1, c)\n+#define IS_DOS_ABSOLUTE_PATH(f) IS_ABSOLUTE_PATH_1 (1, f)\n+#define HAS_DOS_DRIVE_SPEC(f) HAS_DRIVE_SPEC_1 (1, f)\n+\n+#define IS_UNIX_DIR_SEPARATOR(c) IS_DIR_SEPARATOR_1 (0, c)\n+#define IS_UNIX_ABSOLUTE_PATH(f) IS_ABSOLUTE_PATH_1 (0, f)\n+\n+/* Note that when DOS_BASED is true, IS_ABSOLUTE_PATH accepts d:foo as\n+   well, although it is only semi-absolute.  This is because the users\n+   of IS_ABSOLUTE_PATH want to know whether to prepend the current\n+   working directory to a file name, which should not be done with a\n+   name like d:foo.  */\n+#define IS_ABSOLUTE_PATH_1(dos_based, f)\t\t \\\n+  (IS_DIR_SEPARATOR_1 (dos_based, (f)[0])\t\t \\\n+   || HAS_DRIVE_SPEC_1 (dos_based, f))\n+\n+extern int filename_cmp (const char *s1, const char *s2);\n+#define FILENAME_CMP(s1, s2)\tfilename_cmp(s1, s2)\n+\n+extern int filename_ncmp (const char *s1, const char *s2,\n+\t\t\t  size_t n);\n+\n+extern hashval_t filename_hash (const void *s);\n+\n+extern int filename_eq (const void *s1, const void *s2);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* FILENAMES_H */"}, {"sha": "0a656f75ba1f2e029785eb31427562fdd2162e91", "filename": "src/libbacktrace/filetype.awk", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffiletype.awk?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,3 @@\n+# An awk script to determine the type of a file.\n+/\\177ELF\\001/ { if (NR == 1) { print \"elf32\"; exit } }\n+/\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }"}, {"sha": "f6bb8975223a9f9f11514e76c5e1e427f15d6b76", "filename": "src/libbacktrace/gstdint.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fgstdint.h", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fgstdint.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fgstdint.h?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,47 @@\n+/* generated for  gcc (GCC) 4.8.2 20140206 (prerelease) */\n+\n+#ifndef GCC_GENERATED_STDINT_H\n+#define GCC_GENERATED_STDINT_H 1\n+\n+#include <sys/types.h>\n+#include <stdint.h>\n+/* glibc uses these symbols as guards to prevent redefinitions.  */\n+#ifdef __int8_t_defined\n+#define _INT8_T\n+#define _INT16_T\n+#define _INT32_T\n+#endif\n+#ifdef __uint32_t_defined\n+#define _UINT32_T\n+#endif\n+\n+\n+/* Some systems have guard macros to prevent redefinitions, define them.  */\n+#ifndef _INT8_T\n+#define _INT8_T\n+#endif\n+#ifndef _INT16_T\n+#define _INT16_T\n+#endif\n+#ifndef _INT32_T\n+#define _INT32_T\n+#endif\n+#ifndef _UINT8_T\n+#define _UINT8_T\n+#endif\n+#ifndef _UINT16_T\n+#define _UINT16_T\n+#endif\n+#ifndef _UINT32_T\n+#define _UINT32_T\n+#endif\n+\n+/* system headers have good uint64_t and int64_t */\n+#ifndef _INT64_T\n+#define _INT64_T\n+#endif\n+#ifndef _UINT64_T\n+#define _UINT64_T\n+#endif\n+\n+#endif /* GCC_GENERATED_STDINT_H */"}, {"sha": "4bb65d6c7a2b4135b8526ca5ec4255987934ed6d", "filename": "src/libbacktrace/hashtab.h", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fhashtab.h", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fhashtab.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fhashtab.h?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,209 @@\n+/* An expandable hash tables datatype.  \n+   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2009, 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Vladimir Makarov (vmakarov@cygnus.com).\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2 of the License, or\n+(at your option) any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+/* This package implements basic hash table functionality.  It is possible\n+   to search for an entry, create an entry and destroy an entry.\n+\n+   Elements in the table are generic pointers.\n+\n+   The size of the table is not fixed; if the occupancy of the table\n+   grows too high the hash table will be expanded.\n+\n+   The abstract data implementation is based on generalized Algorithm D\n+   from Knuth's book \"The art of computer programming\".  Hash table is\n+   expanded by creation of new hash table and transferring elements from\n+   the old table to the new table.  */\n+\n+#ifndef __HASHTAB_H__\n+#define __HASHTAB_H__\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+#include \"ansidecl.h\"\n+\n+#ifndef GTY\n+#define GTY(X)\n+#endif\n+\n+/* The type for a hash code.  */\n+typedef unsigned int hashval_t;\n+\n+/* Callback function pointer types.  */\n+\n+/* Calculate hash of a table entry.  */\n+typedef hashval_t (*htab_hash) (const void *);\n+\n+/* Compare a table entry with a possible entry.  The entry already in\n+   the table always comes first, so the second element can be of a\n+   different type (but in this case htab_find and htab_find_slot\n+   cannot be used; instead the variants that accept a hash value\n+   must be used).  */\n+typedef int (*htab_eq) (const void *, const void *);\n+\n+/* Cleanup function called whenever a live element is removed from\n+   the hash table.  */\n+typedef void (*htab_del) (void *);\n+  \n+/* Function called by htab_traverse for each live element.  The first\n+   arg is the slot of the element (which can be passed to htab_clear_slot\n+   if desired), the second arg is the auxiliary pointer handed to\n+   htab_traverse.  Return 1 to continue scan, 0 to stop.  */\n+typedef int (*htab_trav) (void **, void *);\n+\n+/* Memory-allocation function, with the same functionality as calloc().\n+   Iff it returns NULL, the hash table implementation will pass an error\n+   code back to the user, so if your code doesn't handle errors,\n+   best if you use xcalloc instead.  */\n+typedef void *(*htab_alloc) (size_t, size_t);\n+\n+/* We also need a free() routine.  */\n+typedef void (*htab_free) (void *);\n+\n+/* Memory allocation and deallocation; variants which take an extra\n+   argument.  */\n+typedef void *(*htab_alloc_with_arg) (void *, size_t, size_t);\n+typedef void (*htab_free_with_arg) (void *, void *);\n+\n+/* This macro defines reserved value for empty table entry.  */\n+\n+#define HTAB_EMPTY_ENTRY    ((PTR) 0)\n+\n+/* This macro defines reserved value for table entry which contained\n+   a deleted element. */\n+\n+#define HTAB_DELETED_ENTRY  ((PTR) 1)\n+\n+/* Hash tables are of the following type.  The structure\n+   (implementation) of this type is not needed for using the hash\n+   tables.  All work with hash table should be executed only through\n+   functions mentioned below.  The size of this structure is subject to\n+   change.  */\n+\n+struct GTY(()) htab {\n+  /* Pointer to hash function.  */\n+  htab_hash hash_f;\n+\n+  /* Pointer to comparison function.  */\n+  htab_eq eq_f;\n+\n+  /* Pointer to cleanup function.  */\n+  htab_del del_f;\n+\n+  /* Table itself.  */\n+  void ** GTY ((use_param, length (\"%h.size\"))) entries;\n+\n+  /* Current size (in entries) of the hash table.  */\n+  size_t size;\n+\n+  /* Current number of elements including also deleted elements.  */\n+  size_t n_elements;\n+\n+  /* Current number of deleted elements in the table.  */\n+  size_t n_deleted;\n+\n+  /* The following member is used for debugging. Its value is number\n+     of all calls of `htab_find_slot' for the hash table. */\n+  unsigned int searches;\n+\n+  /* The following member is used for debugging.  Its value is number\n+     of collisions fixed for time of work with the hash table. */\n+  unsigned int collisions;\n+\n+  /* Pointers to allocate/free functions.  */\n+  htab_alloc alloc_f;\n+  htab_free free_f;\n+\n+  /* Alternate allocate/free functions, which take an extra argument.  */\n+  void * GTY((skip)) alloc_arg;\n+  htab_alloc_with_arg alloc_with_arg_f;\n+  htab_free_with_arg free_with_arg_f;\n+\n+  /* Current size (in entries) of the hash table, as an index into the\n+     table of primes.  */\n+  unsigned int size_prime_index;\n+};\n+\n+typedef struct htab *htab_t;\n+\n+/* An enum saying whether we insert into the hash table or not.  */\n+enum insert_option {NO_INSERT, INSERT};\n+\n+/* The prototypes of the package functions. */\n+\n+extern htab_t\thtab_create_alloc  (size_t, htab_hash,\n+                                    htab_eq, htab_del,\n+                                    htab_alloc, htab_free);\n+\n+extern htab_t\thtab_create_alloc_ex (size_t, htab_hash,\n+                                      htab_eq, htab_del,\n+                                      void *, htab_alloc_with_arg,\n+                                      htab_free_with_arg);\n+\n+extern htab_t  htab_create_typed_alloc (size_t, htab_hash, htab_eq, htab_del,\n+\t\t\t\t\thtab_alloc, htab_alloc, htab_free);\n+\n+/* Backward-compatibility functions.  */\n+extern htab_t htab_create (size_t, htab_hash, htab_eq, htab_del);\n+extern htab_t htab_try_create (size_t, htab_hash, htab_eq, htab_del);\n+\n+extern void\thtab_set_functions_ex (htab_t, htab_hash,\n+                                       htab_eq, htab_del,\n+                                       void *, htab_alloc_with_arg,\n+                                       htab_free_with_arg);\n+\n+extern void\thtab_delete (htab_t);\n+extern void\thtab_empty (htab_t);\n+\n+extern void *\thtab_find (htab_t, const void *);\n+extern void **\thtab_find_slot (htab_t, const void *, enum insert_option);\n+extern void *\thtab_find_with_hash (htab_t, const void *, hashval_t);\n+extern void **\thtab_find_slot_with_hash (htab_t, const void *,\n+\t\t\t\t\t  hashval_t, enum insert_option);\n+extern void\thtab_clear_slot\t(htab_t, void **);\n+extern void\thtab_remove_elt\t(htab_t, void *);\n+extern void\thtab_remove_elt_with_hash (htab_t, void *, hashval_t);\n+\n+extern void\thtab_traverse (htab_t, htab_trav, void *);\n+extern void\thtab_traverse_noresize (htab_t, htab_trav, void *);\n+\n+extern size_t\thtab_size (htab_t);\n+extern size_t\thtab_elements (htab_t);\n+extern double\thtab_collisions\t(htab_t);\n+\n+/* A hash function for pointers.  */\n+extern htab_hash htab_hash_pointer;\n+\n+/* An equality function for pointers.  */\n+extern htab_eq htab_eq_pointer;\n+\n+/* A hash function for null-terminated strings.  */\n+extern hashval_t htab_hash_string (const void *);\n+\n+/* An iterative hash function for arbitrary data.  */\n+extern hashval_t iterative_hash (const void *, size_t, hashval_t);\n+/* Shorthand for hashing something with an intrinsic size.  */\n+#define iterative_hash_object(OB,INIT) iterative_hash (&OB, sizeof (OB), INIT)\n+\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif /* __HASHTAB_H */"}, {"sha": "6781b987bdbcbc23efe6bbe1654a1e3637b9af07", "filename": "src/libbacktrace/install-sh", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finstall-sh?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,520 @@\n+#!/bin/sh\n+# install - install a program, script, or datafile\n+\n+scriptversion=2009-04-28.21; # UTC\n+\n+# This originates from X11R5 (mit/util/scripts/install.sh), which was\n+# later released in X11R6 (xc/config/util/install.sh) with the\n+# following copyright and license.\n+#\n+# Copyright (C) 1994 X Consortium\n+#\n+# Permission is hereby granted, free of charge, to any person obtaining a copy\n+# of this software and associated documentation files (the \"Software\"), to\n+# deal in the Software without restriction, including without limitation the\n+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+# sell copies of the Software, and to permit persons to whom the Software is\n+# furnished to do so, subject to the following conditions:\n+#\n+# The above copyright notice and this permission notice shall be included in\n+# all copies or substantial portions of the Software.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-\n+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+#\n+# Except as contained in this notice, the name of the X Consortium shall not\n+# be used in advertising or otherwise to promote the sale, use or other deal-\n+# ings in this Software without prior written authorization from the X Consor-\n+# tium.\n+#\n+#\n+# FSF changes to this file are in the public domain.\n+#\n+# Calling this script install-sh is preferred over install.sh, to prevent\n+# `make' implicit rules from creating a file called install from it\n+# when there is no Makefile.\n+#\n+# This script is compatible with the BSD install script, but was written\n+# from scratch.\n+\n+nl='\n+'\n+IFS=\" \"\"\t$nl\"\n+\n+# set DOITPROG to echo to test this script\n+\n+# Don't use :- since 4.3BSD and earlier shells don't like it.\n+doit=${DOITPROG-}\n+if test -z \"$doit\"; then\n+  doit_exec=exec\n+else\n+  doit_exec=$doit\n+fi\n+\n+# Put in absolute file names if you don't have them in your path;\n+# or use environment vars.\n+\n+chgrpprog=${CHGRPPROG-chgrp}\n+chmodprog=${CHMODPROG-chmod}\n+chownprog=${CHOWNPROG-chown}\n+cmpprog=${CMPPROG-cmp}\n+cpprog=${CPPROG-cp}\n+mkdirprog=${MKDIRPROG-mkdir}\n+mvprog=${MVPROG-mv}\n+rmprog=${RMPROG-rm}\n+stripprog=${STRIPPROG-strip}\n+\n+posix_glob='?'\n+initialize_posix_glob='\n+  test \"$posix_glob\" != \"?\" || {\n+    if (set -f) 2>/dev/null; then\n+      posix_glob=\n+    else\n+      posix_glob=:\n+    fi\n+  }\n+'\n+\n+posix_mkdir=\n+\n+# Desired mode of installed file.\n+mode=0755\n+\n+chgrpcmd=\n+chmodcmd=$chmodprog\n+chowncmd=\n+mvcmd=$mvprog\n+rmcmd=\"$rmprog -f\"\n+stripcmd=\n+\n+src=\n+dst=\n+dir_arg=\n+dst_arg=\n+\n+copy_on_change=false\n+no_target_directory=\n+\n+usage=\"\\\n+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE\n+   or: $0 [OPTION]... SRCFILES... DIRECTORY\n+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...\n+   or: $0 [OPTION]... -d DIRECTORIES...\n+\n+In the 1st form, copy SRCFILE to DSTFILE.\n+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.\n+In the 4th, create DIRECTORIES.\n+\n+Options:\n+     --help     display this help and exit.\n+     --version  display version info and exit.\n+\n+  -c            (ignored)\n+  -C            install only if different (preserve the last data modification time)\n+  -d            create directories instead of installing files.\n+  -g GROUP      $chgrpprog installed files to GROUP.\n+  -m MODE       $chmodprog installed files to MODE.\n+  -o USER       $chownprog installed files to USER.\n+  -s            $stripprog installed files.\n+  -t DIRECTORY  install into DIRECTORY.\n+  -T            report an error if DSTFILE is a directory.\n+\n+Environment variables override the default commands:\n+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG\n+  RMPROG STRIPPROG\n+\"\n+\n+while test $# -ne 0; do\n+  case $1 in\n+    -c) ;;\n+\n+    -C) copy_on_change=true;;\n+\n+    -d) dir_arg=true;;\n+\n+    -g) chgrpcmd=\"$chgrpprog $2\"\n+\tshift;;\n+\n+    --help) echo \"$usage\"; exit $?;;\n+\n+    -m) mode=$2\n+\tcase $mode in\n+\t  *' '* | *'\t'* | *'\n+'*\t  | *'*'* | *'?'* | *'['*)\n+\t    echo \"$0: invalid mode: $mode\" >&2\n+\t    exit 1;;\n+\tesac\n+\tshift;;\n+\n+    -o) chowncmd=\"$chownprog $2\"\n+\tshift;;\n+\n+    -s) stripcmd=$stripprog;;\n+\n+    -t) dst_arg=$2\n+\tshift;;\n+\n+    -T) no_target_directory=true;;\n+\n+    --version) echo \"$0 $scriptversion\"; exit $?;;\n+\n+    --)\tshift\n+\tbreak;;\n+\n+    -*)\techo \"$0: invalid option: $1\" >&2\n+\texit 1;;\n+\n+    *)  break;;\n+  esac\n+  shift\n+done\n+\n+if test $# -ne 0 && test -z \"$dir_arg$dst_arg\"; then\n+  # When -d is used, all remaining arguments are directories to create.\n+  # When -t is used, the destination is already specified.\n+  # Otherwise, the last argument is the destination.  Remove it from $@.\n+  for arg\n+  do\n+    if test -n \"$dst_arg\"; then\n+      # $@ is not empty: it contains at least $arg.\n+      set fnord \"$@\" \"$dst_arg\"\n+      shift # fnord\n+    fi\n+    shift # arg\n+    dst_arg=$arg\n+  done\n+fi\n+\n+if test $# -eq 0; then\n+  if test -z \"$dir_arg\"; then\n+    echo \"$0: no input file specified.\" >&2\n+    exit 1\n+  fi\n+  # It's OK to call `install-sh -d' without argument.\n+  # This can happen when creating conditional directories.\n+  exit 0\n+fi\n+\n+if test -z \"$dir_arg\"; then\n+  trap '(exit $?); exit' 1 2 13 15\n+\n+  # Set umask so as not to create temps with too-generous modes.\n+  # However, 'strip' requires both read and write access to temps.\n+  case $mode in\n+    # Optimize common cases.\n+    *644) cp_umask=133;;\n+    *755) cp_umask=22;;\n+\n+    *[0-7])\n+      if test -z \"$stripcmd\"; then\n+\tu_plus_rw=\n+      else\n+\tu_plus_rw='% 200'\n+      fi\n+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;\n+    *)\n+      if test -z \"$stripcmd\"; then\n+\tu_plus_rw=\n+      else\n+\tu_plus_rw=,u+rw\n+      fi\n+      cp_umask=$mode$u_plus_rw;;\n+  esac\n+fi\n+\n+for src\n+do\n+  # Protect names starting with `-'.\n+  case $src in\n+    -*) src=./$src;;\n+  esac\n+\n+  if test -n \"$dir_arg\"; then\n+    dst=$src\n+    dstdir=$dst\n+    test -d \"$dstdir\"\n+    dstdir_status=$?\n+  else\n+\n+    # Waiting for this to be detected by the \"$cpprog $src $dsttmp\" command\n+    # might cause directories to be created, which would be especially bad\n+    # if $src (and thus $dsttmp) contains '*'.\n+    if test ! -f \"$src\" && test ! -d \"$src\"; then\n+      echo \"$0: $src does not exist.\" >&2\n+      exit 1\n+    fi\n+\n+    if test -z \"$dst_arg\"; then\n+      echo \"$0: no destination specified.\" >&2\n+      exit 1\n+    fi\n+\n+    dst=$dst_arg\n+    # Protect names starting with `-'.\n+    case $dst in\n+      -*) dst=./$dst;;\n+    esac\n+\n+    # If destination is a directory, append the input filename; won't work\n+    # if double slashes aren't ignored.\n+    if test -d \"$dst\"; then\n+      if test -n \"$no_target_directory\"; then\n+\techo \"$0: $dst_arg: Is a directory\" >&2\n+\texit 1\n+      fi\n+      dstdir=$dst\n+      dst=$dstdir/`basename \"$src\"`\n+      dstdir_status=0\n+    else\n+      # Prefer dirname, but fall back on a substitute if dirname fails.\n+      dstdir=`\n+\t(dirname \"$dst\") 2>/dev/null ||\n+\texpr X\"$dst\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n+\t     X\"$dst\" : 'X\\(//\\)[^/]' \\| \\\n+\t     X\"$dst\" : 'X\\(//\\)$' \\| \\\n+\t     X\"$dst\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n+\techo X\"$dst\" |\n+\t    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t /^X\\(\\/\\/\\)[^/].*/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t /^X\\(\\/\\/\\)$/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t /^X\\(\\/\\).*/{\n+\t\t   s//\\1/\n+\t\t   q\n+\t\t }\n+\t\t s/.*/./; q'\n+      `\n+\n+      test -d \"$dstdir\"\n+      dstdir_status=$?\n+    fi\n+  fi\n+\n+  obsolete_mkdir_used=false\n+\n+  if test $dstdir_status != 0; then\n+    case $posix_mkdir in\n+      '')\n+\t# Create intermediate dirs using mode 755 as modified by the umask.\n+\t# This is like FreeBSD 'install' as of 1997-10-28.\n+\tumask=`umask`\n+\tcase $stripcmd.$umask in\n+\t  # Optimize common cases.\n+\t  *[2367][2367]) mkdir_umask=$umask;;\n+\t  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;\n+\n+\t  *[0-7])\n+\t    mkdir_umask=`expr $umask + 22 \\\n+\t      - $umask % 100 % 40 + $umask % 20 \\\n+\t      - $umask % 10 % 4 + $umask % 2\n+\t    `;;\n+\t  *) mkdir_umask=$umask,go-w;;\n+\tesac\n+\n+\t# With -d, create the new directory with the user-specified mode.\n+\t# Otherwise, rely on $mkdir_umask.\n+\tif test -n \"$dir_arg\"; then\n+\t  mkdir_mode=-m$mode\n+\telse\n+\t  mkdir_mode=\n+\tfi\n+\n+\tposix_mkdir=false\n+\tcase $umask in\n+\t  *[123567][0-7][0-7])\n+\t    # POSIX mkdir -p sets u+wx bits regardless of umask, which\n+\t    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.\n+\t    ;;\n+\t  *)\n+\t    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$\n+\t    trap 'ret=$?; rmdir \"$tmpdir/d\" \"$tmpdir\" 2>/dev/null; exit $ret' 0\n+\n+\t    if (umask $mkdir_umask &&\n+\t\texec $mkdirprog $mkdir_mode -p -- \"$tmpdir/d\") >/dev/null 2>&1\n+\t    then\n+\t      if test -z \"$dir_arg\" || {\n+\t\t   # Check for POSIX incompatibilities with -m.\n+\t\t   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or\n+\t\t   # other-writeable bit of parent directory when it shouldn't.\n+\t\t   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.\n+\t\t   ls_ld_tmpdir=`ls -ld \"$tmpdir\"`\n+\t\t   case $ls_ld_tmpdir in\n+\t\t     d????-?r-*) different_mode=700;;\n+\t\t     d????-?--*) different_mode=755;;\n+\t\t     *) false;;\n+\t\t   esac &&\n+\t\t   $mkdirprog -m$different_mode -p -- \"$tmpdir\" && {\n+\t\t     ls_ld_tmpdir_1=`ls -ld \"$tmpdir\"`\n+\t\t     test \"$ls_ld_tmpdir\" = \"$ls_ld_tmpdir_1\"\n+\t\t   }\n+\t\t }\n+\t      then posix_mkdir=:\n+\t      fi\n+\t      rmdir \"$tmpdir/d\" \"$tmpdir\"\n+\t    else\n+\t      # Remove any dirs left behind by ancient mkdir implementations.\n+\t      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null\n+\t    fi\n+\t    trap '' 0;;\n+\tesac;;\n+    esac\n+\n+    if\n+      $posix_mkdir && (\n+\tumask $mkdir_umask &&\n+\t$doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\"\n+      )\n+    then :\n+    else\n+\n+      # The umask is ridiculous, or mkdir does not conform to POSIX,\n+      # or it failed possibly due to a race condition.  Create the\n+      # directory the slow way, step by step, checking for races as we go.\n+\n+      case $dstdir in\n+\t/*) prefix='/';;\n+\t-*) prefix='./';;\n+\t*)  prefix='';;\n+      esac\n+\n+      eval \"$initialize_posix_glob\"\n+\n+      oIFS=$IFS\n+      IFS=/\n+      $posix_glob set -f\n+      set fnord $dstdir\n+      shift\n+      $posix_glob set +f\n+      IFS=$oIFS\n+\n+      prefixes=\n+\n+      for d\n+      do\n+\ttest -z \"$d\" && continue\n+\n+\tprefix=$prefix$d\n+\tif test -d \"$prefix\"; then\n+\t  prefixes=\n+\telse\n+\t  if $posix_mkdir; then\n+\t    (umask=$mkdir_umask &&\n+\t     $doit_exec $mkdirprog $mkdir_mode -p -- \"$dstdir\") && break\n+\t    # Don't fail if two instances are running concurrently.\n+\t    test -d \"$prefix\" || exit 1\n+\t  else\n+\t    case $prefix in\n+\t      *\\'*) qprefix=`echo \"$prefix\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;;\n+\t      *) qprefix=$prefix;;\n+\t    esac\n+\t    prefixes=\"$prefixes '$qprefix'\"\n+\t  fi\n+\tfi\n+\tprefix=$prefix/\n+      done\n+\n+      if test -n \"$prefixes\"; then\n+\t# Don't fail if two instances are running concurrently.\n+\t(umask $mkdir_umask &&\n+\t eval \"\\$doit_exec \\$mkdirprog $prefixes\") ||\n+\t  test -d \"$dstdir\" || exit 1\n+\tobsolete_mkdir_used=true\n+      fi\n+    fi\n+  fi\n+\n+  if test -n \"$dir_arg\"; then\n+    { test -z \"$chowncmd\" || $doit $chowncmd \"$dst\"; } &&\n+    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dst\"; } &&\n+    { test \"$obsolete_mkdir_used$chowncmd$chgrpcmd\" = false ||\n+      test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dst\"; } || exit 1\n+  else\n+\n+    # Make a couple of temp file names in the proper directory.\n+    dsttmp=$dstdir/_inst.$$_\n+    rmtmp=$dstdir/_rm.$$_\n+\n+    # Trap to clean up those temp files at exit.\n+    trap 'ret=$?; rm -f \"$dsttmp\" \"$rmtmp\" && exit $ret' 0\n+\n+    # Copy the file name to the temp name.\n+    (umask $cp_umask && $doit_exec $cpprog \"$src\" \"$dsttmp\") &&\n+\n+    # and set any options; do chmod last to preserve setuid bits.\n+    #\n+    # If any of these fail, we abort the whole thing.  If we want to\n+    # ignore errors from any of these, just make sure not to ignore\n+    # errors from the above \"$doit $cpprog $src $dsttmp\" command.\n+    #\n+    { test -z \"$chowncmd\" || $doit $chowncmd \"$dsttmp\"; } &&\n+    { test -z \"$chgrpcmd\" || $doit $chgrpcmd \"$dsttmp\"; } &&\n+    { test -z \"$stripcmd\" || $doit $stripcmd \"$dsttmp\"; } &&\n+    { test -z \"$chmodcmd\" || $doit $chmodcmd $mode \"$dsttmp\"; } &&\n+\n+    # If -C, don't bother to copy if it wouldn't change the file.\n+    if $copy_on_change &&\n+       old=`LC_ALL=C ls -dlL \"$dst\"\t2>/dev/null` &&\n+       new=`LC_ALL=C ls -dlL \"$dsttmp\"\t2>/dev/null` &&\n+\n+       eval \"$initialize_posix_glob\" &&\n+       $posix_glob set -f &&\n+       set X $old && old=:$2:$4:$5:$6 &&\n+       set X $new && new=:$2:$4:$5:$6 &&\n+       $posix_glob set +f &&\n+\n+       test \"$old\" = \"$new\" &&\n+       $cmpprog \"$dst\" \"$dsttmp\" >/dev/null 2>&1\n+    then\n+      rm -f \"$dsttmp\"\n+    else\n+      # Rename the file to the real destination.\n+      $doit $mvcmd -f \"$dsttmp\" \"$dst\" 2>/dev/null ||\n+\n+      # The rename failed, perhaps because mv can't rename something else\n+      # to itself, or perhaps because mv is so ancient that it does not\n+      # support -f.\n+      {\n+\t# Now remove or move aside any old file at destination location.\n+\t# We try this two ways since rm can't unlink itself on some\n+\t# systems and the destination file might be busy for other\n+\t# reasons.  In this case, the final cleanup might fail but the new\n+\t# file should still install successfully.\n+\t{\n+\t  test ! -f \"$dst\" ||\n+\t  $doit $rmcmd -f \"$dst\" 2>/dev/null ||\n+\t  { $doit $mvcmd -f \"$dst\" \"$rmtmp\" 2>/dev/null &&\n+\t    { $doit $rmcmd -f \"$rmtmp\" 2>/dev/null; :; }\n+\t  } ||\n+\t  { echo \"$0: cannot unlink or rename $dst\" >&2\n+\t    (exit 1); exit 1\n+\t  }\n+\t} &&\n+\n+\t# Now rename the file to the real destination.\n+\t$doit $mvcmd \"$dsttmp\" \"$dst\"\n+      }\n+    fi || exit 1\n+\n+    trap '' 0\n+  fi\n+done\n+\n+# Local variables:\n+# eval: (add-hook 'write-file-hooks 'time-stamp)\n+# time-stamp-start: \"scriptversion=\"\n+# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n+# time-stamp-time-zone: \"UTC\"\n+# time-stamp-end: \"; # UTC\"\n+# End:"}, {"sha": "dd109db24aed900a6fe66191cd81be6b31500496", "filename": "src/libbacktrace/internal.h", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finternal.h?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,287 @@\n+/* internal.h -- Internal header file for stack backtrace library.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef BACKTRACE_INTERNAL_H\n+#define BACKTRACE_INTERNAL_H\n+\n+/* We assume that <sys/types.h> and \"backtrace.h\" have already been\n+   included.  */\n+\n+#ifndef GCC_VERSION\n+# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef ATTRIBUTE_UNUSED\n+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#endif\n+\n+#ifndef ATTRIBUTE_MALLOC\n+# if (GCC_VERSION >= 2096)\n+#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n+# else\n+#  define ATTRIBUTE_MALLOC\n+# endif\n+#endif\n+\n+#ifndef HAVE_SYNC_FUNCTIONS\n+\n+/* Define out the sync functions.  These should never be called if\n+   they are not available.  */\n+\n+#define __sync_bool_compare_and_swap(A, B, C) (abort(), 1)\n+#define __sync_lock_test_and_set(A, B) (abort(), 0)\n+#define __sync_lock_release(A) abort()\n+\n+#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n+\n+#ifdef HAVE_ATOMIC_FUNCTIONS\n+\n+/* We have the atomic builtin functions.  */\n+\n+#define backtrace_atomic_load_pointer(p) \\\n+    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n+#define backtrace_atomic_load_int(p) \\\n+    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n+#define backtrace_atomic_store_pointer(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+#define backtrace_atomic_store_size_t(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+#define backtrace_atomic_store_int(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+\n+#else /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n+#ifdef HAVE_SYNC_FUNCTIONS\n+\n+/* We have the sync functions but not the atomic functions.  Define\n+   the atomic ones in terms of the sync ones.  */\n+\n+extern void *backtrace_atomic_load_pointer (void *);\n+extern int backtrace_atomic_load_int (int *);\n+extern void backtrace_atomic_store_pointer (void *, void *);\n+extern void backtrace_atomic_store_size_t (size_t *, size_t);\n+extern void backtrace_atomic_store_int (int *, int);\n+\n+#else /* !defined (HAVE_SYNC_FUNCTIONS) */\n+\n+/* We have neither the sync nor the atomic functions.  These will\n+   never be called.  */\n+\n+#define backtrace_atomic_load_pointer(p) (abort(), 0)\n+#define backtrace_atomic_load_int(p) (abort(), 0)\n+#define backtrace_atomic_store_pointer(p, v) abort()\n+#define backtrace_atomic_store_size_t(p, v) abort()\n+#define backtrace_atomic_store_int(p, v) abort()\n+\n+#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n+#endif /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n+\n+/* The type of the function that collects file/line information.  This\n+   is like backtrace_pcinfo.  */\n+\n+typedef int (*fileline) (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t backtrace_full_callback callback,\n+\t\t\t backtrace_error_callback error_callback, void *data);\n+\n+/* The type of the function that collects symbol information.  This is\n+   like backtrace_syminfo.  */\n+\n+typedef void (*syminfo) (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t backtrace_syminfo_callback callback,\n+\t\t\t backtrace_error_callback error_callback, void *data);\n+\n+/* What the backtrace state pointer points to.  */\n+\n+struct backtrace_state\n+{\n+  /* The name of the executable.  */\n+  const char *filename;\n+  /* Non-zero if threaded.  */\n+  int threaded;\n+  /* The master lock for fileline_fn, fileline_data, syminfo_fn,\n+     syminfo_data, fileline_initialization_failed and everything the\n+     data pointers point to.  */\n+  void *lock;\n+  /* The function that returns file/line information.  */\n+  fileline fileline_fn;\n+  /* The data to pass to FILELINE_FN.  */\n+  void *fileline_data;\n+  /* The function that returns symbol information.  */\n+  syminfo syminfo_fn;\n+  /* The data to pass to SYMINFO_FN.  */\n+  void *syminfo_data;\n+  /* Whether initializing the file/line information failed.  */\n+  int fileline_initialization_failed;\n+  /* The lock for the freelist.  */\n+  int lock_alloc;\n+  /* The freelist when using mmap.  */\n+  struct backtrace_freelist_struct *freelist;\n+};\n+\n+/* Open a file for reading.  Returns -1 on error.  If DOES_NOT_EXIST\n+   is not NULL, *DOES_NOT_EXIST will be set to 0 normally and set to 1\n+   if the file does not exist.  If the file does not exist and\n+   DOES_NOT_EXIST is not NULL, the function will return -1 and will\n+   not call ERROR_CALLBACK.  On other errors, or if DOES_NOT_EXIST is\n+   NULL, the function will call ERROR_CALLBACK before returning.  */\n+extern int backtrace_open (const char *filename,\n+\t\t\t   backtrace_error_callback error_callback,\n+\t\t\t   void *data,\n+\t\t\t   int *does_not_exist);\n+\n+/* A view of the contents of a file.  This supports mmap when\n+   available.  A view will remain in memory even after backtrace_close\n+   is called on the file descriptor from which the view was\n+   obtained.  */\n+\n+struct backtrace_view\n+{\n+  /* The data that the caller requested.  */\n+  const void *data;\n+  /* The base of the view.  */\n+  void *base;\n+  /* The total length of the view.  */\n+  size_t len;\n+};\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  Store the\n+   result in *VIEW.  Returns 1 on success, 0 on error.  */\n+extern int backtrace_get_view (struct backtrace_state *state, int descriptor,\n+\t\t\t       off_t offset, size_t size,\n+\t\t\t       backtrace_error_callback error_callback,\n+\t\t\t       void *data, struct backtrace_view *view);\n+\n+/* Release a view created by backtrace_get_view.  */\n+extern void backtrace_release_view (struct backtrace_state *state,\n+\t\t\t\t    struct backtrace_view *view,\n+\t\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t\t    void *data);\n+\n+/* Close a file opened by backtrace_open.  Returns 1 on success, 0 on\n+   error.  */\n+\n+extern int backtrace_close (int descriptor,\n+\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t    void *data);\n+\n+/* Allocate memory.  This is like malloc.  */\n+\n+extern void *backtrace_alloc (struct backtrace_state *state, size_t size,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data) ATTRIBUTE_MALLOC;\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+extern void backtrace_free (struct backtrace_state *state, void *mem,\n+\t\t\t    size_t size,\n+\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t    void *data);\n+\n+/* A growable vector of some struct.  This is used for more efficient\n+   allocation when we don't know the final size of some group of data\n+   that we want to represent as an array.  */\n+\n+struct backtrace_vector\n+{\n+  /* The base of the vector.  */\n+  void *base;\n+  /* The number of bytes in the vector.  */\n+  size_t size;\n+  /* The number of bytes available at the current allocation.  */\n+  size_t alc;\n+};\n+\n+/* Grow VEC by SIZE bytes.  Return a pointer to the newly allocated\n+   bytes.  Note that this may move the entire vector to a new memory\n+   location.  Returns NULL on failure.  */\n+\n+extern void *backtrace_vector_grow (struct backtrace_state *state, size_t size,\n+\t\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t\t    void *data,\n+\t\t\t\t    struct backtrace_vector *vec);\n+\n+/* Finish the current allocation on VEC.  Prepare to start a new\n+   allocation.  The finished allocation will never be freed.  Returns\n+   a pointer to the base of the finished entries, or NULL on\n+   failure.  */\n+\n+extern void* backtrace_vector_finish (struct backtrace_state *state,\n+\t\t\t\t      struct backtrace_vector *vec,\n+\t\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t\t      void *data);\n+\n+/* Release any extra space allocated for VEC.  This may change\n+   VEC->base.  Returns 1 on success, 0 on failure.  */\n+\n+extern int backtrace_vector_release (struct backtrace_state *state,\n+\t\t\t\t     struct backtrace_vector *vec,\n+\t\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t\t     void *data);\n+\n+/* Read initial debug data from a descriptor, and set the\n+   fileline_data, syminfo_fn, and syminfo_data fields of STATE.\n+   Return the fileln_fn field in *FILELN_FN--this is done this way so\n+   that the synchronization code is only implemented once.  This is\n+   called after the descriptor has first been opened.  It will close\n+   the descriptor if it is no longer needed.  Returns 1 on success, 0\n+   on error.  There will be multiple implementations of this function,\n+   for different file formats.  Each system will compile the\n+   appropriate one.  */\n+\n+extern int backtrace_initialize (struct backtrace_state *state,\n+\t\t\t\t int descriptor,\n+\t\t\t\t backtrace_error_callback error_callback,\n+\t\t\t\t void *data,\n+\t\t\t\t fileline *fileline_fn);\n+\n+/* Add file/line information for a DWARF module.  */\n+\n+extern int backtrace_dwarf_add (struct backtrace_state *state,\n+\t\t\t\tuintptr_t base_address,\n+\t\t\t\tconst unsigned char* dwarf_info,\n+\t\t\t\tsize_t dwarf_info_size,\n+\t\t\t\tconst unsigned char *dwarf_line,\n+\t\t\t\tsize_t dwarf_line_size,\n+\t\t\t\tconst unsigned char *dwarf_abbrev,\n+\t\t\t\tsize_t dwarf_abbrev_size,\n+\t\t\t\tconst unsigned char *dwarf_ranges,\n+\t\t\t\tsize_t dwarf_range_size,\n+\t\t\t\tconst unsigned char *dwarf_str,\n+\t\t\t\tsize_t dwarf_str_size,\n+\t\t\t\tint is_bigendian,\n+\t\t\t\tbacktrace_error_callback error_callback,\n+\t\t\t\tvoid *data, fileline *fileline_fn);\n+\n+#endif"}, {"sha": "9503ec85d709d8f7fdad222ef3c4d8d85fdc6cd1", "filename": "src/libbacktrace/ltmain.sh", "status": "added", "additions": 8636, "deletions": 0, "changes": 8636, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fltmain.sh?ref=12b2607572d6233a1d4b4f7592573e49b505771e"}, {"sha": "b530e38238820084f87949e24111576922810f52", "filename": "src/libbacktrace/mmap.c", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fmmap.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmap.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,271 @@\n+/* mmap.c -- Memory allocation with mmap.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/mman.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Memory allocation on systems that provide anonymous mmap.  This\n+   permits the backtrace functions to be invoked from a signal\n+   handler, assuming that mmap is async-signal safe.  */\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+/* A list of free memory blocks.  */\n+\n+struct backtrace_freelist_struct\n+{\n+  /* Next on list.  */\n+  struct backtrace_freelist_struct *next;\n+  /* Size of this block, including this structure.  */\n+  size_t size;\n+};\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+static void\n+backtrace_free_locked (struct backtrace_state *state, void *addr, size_t size)\n+{\n+  /* Just leak small blocks.  We don't have to be perfect.  */\n+  if (size >= sizeof (struct backtrace_freelist_struct))\n+    {\n+      struct backtrace_freelist_struct *p;\n+\n+      p = (struct backtrace_freelist_struct *) addr;\n+      p->next = state->freelist;\n+      p->size = size;\n+      state->freelist = p;\n+    }\n+}\n+\n+/* Allocate memory like malloc.  */\n+\n+void *\n+backtrace_alloc (struct backtrace_state *state,\n+\t\t size_t size, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  void *ret;\n+  int locked;\n+  struct backtrace_freelist_struct **pp;\n+  size_t pagesize;\n+  size_t asksize;\n+  void *page;\n+\n+  ret = NULL;\n+\n+  /* If we can acquire the lock, then see if there is space on the\n+     free list.  If we can't acquire the lock, drop straight into\n+     using mmap.  __sync_lock_test_and_set returns the old state of\n+     the lock, so we have acquired it if it returns 0.  */\n+\n+  if (!state->threaded)\n+    locked = 1;\n+  else\n+    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n+\n+  if (locked)\n+    {\n+      for (pp = &state->freelist; *pp != NULL; pp = &(*pp)->next)\n+\t{\n+\t  if ((*pp)->size >= size)\n+\t    {\n+\t      struct backtrace_freelist_struct *p;\n+\n+\t      p = *pp;\n+\t      *pp = p->next;\n+\n+\t      /* Round for alignment; we assume that no type we care about\n+\t\t is more than 8 bytes.  */\n+\t      size = (size + 7) & ~ (size_t) 7;\n+\t      if (size < p->size)\n+\t\tbacktrace_free_locked (state, (char *) p + size,\n+\t\t\t\t       p->size - size);\n+\n+\t      ret = (void *) p;\n+\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (state->threaded)\n+\t__sync_lock_release (&state->lock_alloc);\n+    }\n+\n+  if (ret == NULL)\n+    {\n+      /* Allocate a new page.  */\n+\n+      pagesize = getpagesize ();\n+      asksize = (size + pagesize - 1) & ~ (pagesize - 1);\n+      page = mmap (NULL, asksize, PROT_READ | PROT_WRITE,\n+\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+      if (page == NULL)\n+\terror_callback (data, \"mmap\", errno);\n+      else\n+\t{\n+\t  size = (size + 7) & ~ (size_t) 7;\n+\t  if (size < asksize)\n+\t    backtrace_free (state, (char *) page + size, asksize - size,\n+\t\t\t    error_callback, data);\n+\n+\t  ret = page;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+void\n+backtrace_free (struct backtrace_state *state, void *addr, size_t size,\n+\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  int locked;\n+\n+  /* If we can acquire the lock, add the new space to the free list.\n+     If we can't acquire the lock, just leak the memory.\n+     __sync_lock_test_and_set returns the old state of the lock, so we\n+     have acquired it if it returns 0.  */\n+\n+  if (!state->threaded)\n+    locked = 1;\n+  else\n+    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n+\n+  if (locked)\n+    {\n+      backtrace_free_locked (state, addr, size);\n+\n+      if (state->threaded)\n+\t__sync_lock_release (&state->lock_alloc);\n+    }\n+}\n+\n+/* Grow VEC by SIZE bytes.  */\n+\n+void *\n+backtrace_vector_grow (struct backtrace_state *state,size_t size,\n+\t\t       backtrace_error_callback error_callback,\n+\t\t       void *data, struct backtrace_vector *vec)\n+{\n+  void *ret;\n+\n+  if (size > vec->alc)\n+    {\n+      size_t pagesize;\n+      size_t alc;\n+      void *base;\n+\n+      pagesize = getpagesize ();\n+      alc = vec->size + size;\n+      if (vec->size == 0)\n+\talc = 16 * size;\n+      else if (alc < pagesize)\n+\t{\n+\t  alc *= 2;\n+\t  if (alc > pagesize)\n+\t    alc = pagesize;\n+\t}\n+      else\n+\talc = (alc + pagesize - 1) & ~ (pagesize - 1);\n+      base = backtrace_alloc (state, alc, error_callback, data);\n+      if (base == NULL)\n+\treturn NULL;\n+      if (vec->base != NULL)\n+\t{\n+\t  memcpy (base, vec->base, vec->size);\n+\t  backtrace_free (state, vec->base, vec->alc, error_callback, data);\n+\t}\n+      vec->base = base;\n+      vec->alc = alc - vec->size;\n+    }\n+\n+  ret = (char *) vec->base + vec->size;\n+  vec->size += size;\n+  vec->alc -= size;\n+  return ret;\n+}\n+\n+/* Finish the current allocation on VEC.  */\n+\n+void *\n+backtrace_vector_finish (\n+  struct backtrace_state *state ATTRIBUTE_UNUSED,\n+  struct backtrace_vector *vec,\n+  backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+  void *data ATTRIBUTE_UNUSED)\n+{\n+  void *ret;\n+\n+  ret = vec->base;\n+  vec->base = (char *) vec->base + vec->size;\n+  vec->size = 0;\n+  return ret;\n+}\n+\n+/* Release any extra space allocated for VEC.  */\n+\n+int\n+backtrace_vector_release (struct backtrace_state *state,\n+\t\t\t  struct backtrace_vector *vec,\n+\t\t\t  backtrace_error_callback error_callback,\n+\t\t\t  void *data)\n+{\n+  size_t size;\n+  size_t alc;\n+  size_t aligned;\n+\n+  /* Make sure that the block that we free is aligned on an 8-byte\n+     boundary.  */\n+  size = vec->size;\n+  alc = vec->alc;\n+  aligned = (size + 7) & ~ (size_t) 7;\n+  alc -= aligned - size;\n+\n+  backtrace_free (state, (char *) vec->base + aligned, alc,\n+\t\t  error_callback, data);\n+  vec->alc = 0;\n+  return 1;\n+}"}, {"sha": "72940b403a3d04962436442eb24c2201d43718d9", "filename": "src/libbacktrace/mmapio.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fmmapio.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fmmapio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmapio.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,100 @@\n+/* mmapio.c -- File views using mmap.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef MAP_FAILED\n+#define MAP_FAILED ((void *)-1)\n+#endif\n+\n+/* This file implements file views and memory allocation when mmap is\n+   available.  */\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n+\n+int\n+backtrace_get_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t    int descriptor, off_t offset, size_t size,\n+\t\t    backtrace_error_callback error_callback,\n+\t\t    void *data, struct backtrace_view *view)\n+{\n+  size_t pagesize;\n+  unsigned int inpage;\n+  off_t pageoff;\n+  void *map;\n+\n+  pagesize = getpagesize ();\n+  inpage = offset % pagesize;\n+  pageoff = offset - inpage;\n+\n+  size += inpage;\n+  size = (size + (pagesize - 1)) & ~ (pagesize - 1);\n+\n+  map = mmap (NULL, size, PROT_READ, MAP_PRIVATE, descriptor, pageoff);\n+  if (map == MAP_FAILED)\n+    {\n+      error_callback (data, \"mmap\", errno);\n+      return 0;\n+    }\n+\n+  view->data = (char *) map + inpage;\n+  view->base = map;\n+  view->len = size;\n+\n+  return 1;\n+}\n+\n+/* Release a view read by backtrace_get_view.  */\n+\n+void\n+backtrace_release_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\tstruct backtrace_view *view,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  union {\n+    const void *cv;\n+    void *v;\n+  } const_cast;\n+\n+  const_cast.cv = view->base;\n+  if (munmap (const_cast.v, view->len) < 0)\n+    error_callback (data, \"munmap\", errno);\n+}"}, {"sha": "0097966b422b4165f7028883a103cae399bd429d", "filename": "src/libbacktrace/nounwind.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fnounwind.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fnounwind.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fnounwind.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,66 @@\n+/* backtrace.c -- Entry point for stack backtrace library.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+\n+#include \"internal.h\"\n+\n+/* This source file is compiled if the unwind library is not\n+   available.  */\n+\n+int\n+backtrace_full (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\tint skip ATTRIBUTE_UNUSED,\n+\t\tbacktrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data,\n+\t\t  \"no stack trace because unwind library not available\",\n+\t\t  0);\n+  return 0;\n+}\n+\n+int\n+backtrace_simple (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t  int skip ATTRIBUTE_UNUSED,\n+\t\t  backtrace_simple_callback callback ATTRIBUTE_UNUSED,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data,\n+\t\t  \"no stack trace because unwind library not available\",\n+\t\t  0);\n+  return 0;\n+}"}, {"sha": "dba9e525e082611eedcdefd9c26dff7c0c59d14e", "filename": "src/libbacktrace/posix.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fposix.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fposix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fposix.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,100 @@\n+/* posix.c -- POSIX file I/O routines for the backtrace library.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+#ifndef O_CLOEXEC\n+#define O_CLOEXEC 0\n+#endif\n+\n+#ifndef FD_CLOEXEC\n+#define FD_CLOEXEC 1\n+#endif\n+\n+/* Open a file for reading.  */\n+\n+int\n+backtrace_open (const char *filename, backtrace_error_callback error_callback,\n+\t\tvoid *data, int *does_not_exist)\n+{\n+  int descriptor;\n+\n+  if (does_not_exist != NULL)\n+    *does_not_exist = 0;\n+\n+  descriptor = open (filename, O_RDONLY | O_BINARY | O_CLOEXEC);\n+  if (descriptor < 0)\n+    {\n+      if (does_not_exist != NULL && errno == ENOENT)\n+\t*does_not_exist = 1;\n+      else\n+\terror_callback (data, filename, errno);\n+      return -1;\n+    }\n+\n+#ifdef HAVE_FCNTL\n+  /* Set FD_CLOEXEC just in case the kernel does not support\n+     O_CLOEXEC. It doesn't matter if this fails for some reason.\n+     FIXME: At some point it should be safe to only do this if\n+     O_CLOEXEC == 0.  */\n+  fcntl (descriptor, F_SETFD, FD_CLOEXEC);\n+#endif\n+\n+  return descriptor;\n+}\n+\n+/* Close DESCRIPTOR.  */\n+\n+int\n+backtrace_close (int descriptor, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  if (close (descriptor) < 0)\n+    {\n+      error_callback (data, \"close\", errno);\n+      return 0;\n+    }\n+  return 1;\n+}"}, {"sha": "bd224e6bf4d7db2d396078325392667ce165659c", "filename": "src/libbacktrace/print.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fprint.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fprint.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fprint.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,92 @@\n+/* print.c -- Print the current backtrace.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Passed to callbacks.  */\n+\n+struct print_data\n+{\n+  struct backtrace_state *state;\n+  FILE *f;\n+};\n+\n+/* Print one level of a backtrace.  */\n+\n+static int\n+print_callback (void *data, uintptr_t pc, const char *filename, int lineno,\n+\t\tconst char *function)\n+{\n+  struct print_data *pdata = (struct print_data *) data;\n+\n+  fprintf (pdata->f, \"0x%lx %s\\n\\t%s:%d\\n\",\n+\t   (unsigned long) pc,\n+\t   function == NULL ? \"???\" : function,\n+\t   filename == NULL ? \"???\" : filename,\n+\t   lineno);\n+  return 0;\n+}\n+\n+/* Print errors to stderr.  */\n+\n+static void\n+error_callback (void *data, const char *msg, int errnum)\n+{\n+  struct print_data *pdata = (struct print_data *) data;\n+\n+  if (pdata->state->filename != NULL)\n+    fprintf (stderr, \"%s: \", pdata->state->filename);\n+  fprintf (stderr, \"libbacktrace: %s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fputc ('\\n', stderr);\n+}\n+\n+/* Print a backtrace.  */\n+\n+void\n+backtrace_print (struct backtrace_state *state, int skip, FILE *f)\n+{\n+  struct print_data data;\n+\n+  data.state = state;\n+  data.f = f;\n+  backtrace_full (state, skip + 1, print_callback, error_callback,\n+\t\t  (void *) &data);\n+}"}, {"sha": "c618a50b36d3fd6f270e87debf2d83740fd28941", "filename": "src/libbacktrace/read.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fread.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fread.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fread.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,96 @@\n+/* read.c -- File views without mmap.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* This file implements file views when mmap is not available.  */\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n+\n+int\n+backtrace_get_view (struct backtrace_state *state, int descriptor,\n+\t\t    off_t offset, size_t size,\n+\t\t    backtrace_error_callback error_callback,\n+\t\t    void *data, struct backtrace_view *view)\n+{\n+  ssize_t got;\n+\n+  if (lseek (descriptor, offset, SEEK_SET) < 0)\n+    {\n+      error_callback (data, \"lseek\", errno);\n+      return 0;\n+    }\n+\n+  view->base = backtrace_alloc (state, size, error_callback, data);\n+  if (view->base == NULL)\n+    return 0;\n+  view->data = view->base;\n+  view->len = size;\n+\n+  got = read (descriptor, view->base, size);\n+  if (got < 0)\n+    {\n+      error_callback (data, \"read\", errno);\n+      free (view->base);\n+      return 0;\n+    }\n+\n+  if ((size_t) got < size)\n+    {\n+      error_callback (data, \"file too short\", 0);\n+      free (view->base);\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Release a view read by backtrace_get_view.  */\n+\n+void\n+backtrace_release_view (struct backtrace_state *state,\n+\t\t\tstruct backtrace_view *view,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  backtrace_free (state, view->base, view->len, error_callback, data);\n+  view->data = NULL;\n+  view->base = NULL;\n+}"}, {"sha": "efa8b6fc639df802ce99dcdcae58e47959f7bb5e", "filename": "src/libbacktrace/simple.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fsimple.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fsimple.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsimple.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,108 @@\n+/* simple.c -- The backtrace_simple function.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include \"unwind.h\"\n+#include \"backtrace.h\"\n+\n+/* The simple_backtrace routine.  */\n+\n+/* Data passed through _Unwind_Backtrace.  */\n+\n+struct backtrace_simple_data\n+{\n+  /* Number of frames to skip.  */\n+  int skip;\n+  /* Library state.  */\n+  struct backtrace_state *state;\n+  /* Callback routine.  */\n+  backtrace_simple_callback callback;\n+  /* Error callback routine.  */\n+  backtrace_error_callback error_callback;\n+  /* Data to pass to callback routine.  */\n+  void *data;\n+  /* Value to return from backtrace.  */\n+  int ret;\n+};\n+\n+/* Unwind library callback routine.  This is passd to\n+   _Unwind_Backtrace.  */\n+\n+static _Unwind_Reason_Code\n+simple_unwind (struct _Unwind_Context *context, void *vdata)\n+{\n+  struct backtrace_simple_data *bdata = (struct backtrace_simple_data *) vdata;\n+  uintptr_t pc;\n+  int ip_before_insn = 0;\n+\n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  pc = _Unwind_GetIP (context);\n+#endif\n+\n+  if (bdata->skip > 0)\n+    {\n+      --bdata->skip;\n+      return _URC_NO_REASON;\n+    }\n+\n+  if (!ip_before_insn)\n+    --pc;\n+\n+  bdata->ret = bdata->callback (bdata->data, pc);\n+\n+  if (bdata->ret != 0)\n+    return _URC_END_OF_STACK;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+/* Get a simple stack backtrace.  */\n+\n+int\n+backtrace_simple (struct backtrace_state *state, int skip,\n+\t\t  backtrace_simple_callback callback,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  struct backtrace_simple_data bdata;\n+\n+  bdata.skip = skip + 1;\n+  bdata.state = state;\n+  bdata.callback = callback;\n+  bdata.error_callback = error_callback;\n+  bdata.data = data;\n+  bdata.ret = 0;\n+  _Unwind_Backtrace (simple_unwind, &bdata);\n+  return bdata.ret;\n+}"}, {"sha": "a7d4e07d1a5574ea07b7fdc42572724d0c29747a", "filename": "src/libbacktrace/state.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fstate.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Fstate.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstate.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,72 @@\n+/* state.c -- Create the backtrace state.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+#include \"internal.h\"\n+\n+/* Create the backtrace state.  This will then be passed to all the\n+   other routines.  */\n+\n+struct backtrace_state *\n+backtrace_create_state (const char *filename, int threaded,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  struct backtrace_state init_state;\n+  struct backtrace_state *state;\n+\n+#ifndef HAVE_SYNC_FUNCTIONS\n+  if (threaded)\n+    {\n+      error_callback (data, \"backtrace library does not support threads\", 0);\n+      return NULL;\n+    }\n+#endif\n+\n+  memset (&init_state, 0, sizeof init_state);\n+  init_state.filename = filename;\n+  init_state.threaded = threaded;\n+\n+  state = ((struct backtrace_state *)\n+\t   backtrace_alloc (&init_state, sizeof *state, error_callback, data));\n+  if (state == NULL)\n+    return NULL;\n+  *state = init_state;\n+\n+  return state;\n+}"}, {"sha": "c1fe8811d477f02608d02e42c5ea8f1d7d4501c4", "filename": "src/libbacktrace/unknown.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Funknown.c", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibbacktrace%2Funknown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Funknown.c?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,64 @@\n+/* unknown.c -- used when backtrace configury does not know file format.\n+   Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer. \n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.  \n+    \n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* A trivial routine that always fails to find fileline data.  */\n+\n+static int\n+unknown_fileline (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t  uintptr_t pc, backtrace_full_callback callback,\n+\t\t  backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\t  void *data)\n+\n+{\n+  return callback (data, pc, NULL, 0, NULL);\n+}\n+\n+/* Initialize the backtrace data when we don't know how to read the\n+   debug info.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t      int descriptor ATTRIBUTE_UNUSED,\n+\t\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\t      void *data ATTRIBUTE_UNUSED, fileline *fileline_fn)\n+{\n+  state->fileline_data = NULL;\n+  *fileline_fn = unknown_fileline;\n+  return 1;\n+}"}, {"sha": "fc91d8189f017baba88d08338fe5938a1e2513d8", "filename": "src/libstd/rt/backtrace.rs", "status": "added", "additions": 714, "deletions": 0, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,714 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(non_camel_case_types)];\n+\n+use char::Char;\n+use container::Container;\n+use from_str::from_str;\n+use io::{IoResult, Writer};\n+use iter::Iterator;\n+use option::{Some, None};\n+use result::{Ok, Err};\n+use str::StrSlice;\n+\n+pub use self::imp::write;\n+\n+// This function is defined in this module so that the way to enable logging of\n+// backtraces has the word 'backtrace' in it: std::rt::backtrace.\n+pub fn log_enabled() -> bool {\n+    log_enabled!(::logging::DEBUG)\n+}\n+\n+#[cfg(target_word_size = \"64\")] static HEX_WIDTH: uint = 18;\n+#[cfg(target_word_size = \"32\")] static HEX_WIDTH: uint = 10;\n+\n+// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n+// assemblers, however, can't handle these characters in symbol names. To get\n+// around this, we use C++-style mangling. The mangling method is:\n+//\n+// 1. Prefix the symbol with \"_ZN\"\n+// 2. For each element of the path, emit the length plus the element\n+// 3. End the path with \"E\"\n+//\n+// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3bar\" => \"foo::bar\".\n+//\n+// We're the ones printing our backtraces, so we can't rely on anything else to\n+// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n+// this function is implemented to give us nice pretty output.\n+//\n+// Note that this demangler isn't quite as fancy as it could be. We have lots\n+// of other information in our symbols like hashes, version, type information,\n+// etc. Additionally, this doesn't handle glue symbols at all.\n+fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n+    // First validate the symbol. If it doesn't look like anything we're\n+    // expecting, we just print it literally. Note that we must handle non-rust\n+    // symbols because we could have any function in the backtrace.\n+    let mut valid = true;\n+    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n+        let mut chars = s.slice(3, s.len() - 1).chars();\n+        while valid {\n+            let mut i = 0;\n+            for c in chars {\n+                if c.is_digit() {\n+                    i = i * 10 + c as uint - '0' as uint;\n+                } else {\n+                    break\n+                }\n+            }\n+            if i == 0 {\n+                valid = chars.next().is_none();\n+                break\n+            } else if chars.by_ref().take(i - 1).len() != i - 1 {\n+                valid = false;\n+            }\n+        }\n+    } else {\n+        valid = false;\n+    }\n+\n+    // Alright, let's do this.\n+    if !valid {\n+        try!(writer.write_str(s));\n+    } else {\n+        let mut s = s.slice_from(3);\n+        let mut first = true;\n+        while s.len() > 1 {\n+            if !first {\n+                try!(writer.write_str(\"::\"));\n+            } else {\n+                first = false;\n+            }\n+            let mut rest = s;\n+            while rest.char_at(0).is_digit() {\n+                rest = rest.slice_from(1);\n+            }\n+            let i: uint = from_str(s.slice_to(s.len() - rest.len())).unwrap();\n+            try!(writer.write_str(rest.slice_to(i)));\n+            s = rest.slice_from(i);\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Backtrace support built on libgcc with some extra OS-specific support\n+///\n+/// Some methods of getting a backtrace:\n+///\n+/// * The backtrace() functions on unix. It turns out this doesn't work very\n+///   well for green threads on OSX, and the address to symbol portion of it\n+///   suffers problems that are described below.\n+///\n+/// * Using libunwind. This is more difficult than it sounds because libunwind\n+///   isn't installed everywhere by default. It's also a bit of a hefty library,\n+///   so possibly not the best option. When testing, libunwind was excellent at\n+///   getting both accurate backtraces and accurate symbols across platforms.\n+///   This route was not chosen in favor of the next option, however.\n+///\n+/// * We're already using libgcc_s for exceptions in rust (triggering task\n+///   unwinding and running destructors on the stack), and it turns out that it\n+///   conveniently comes with a function that also gives us a backtrace. All of\n+///   these functions look like _Unwind_*, but it's not quite the full\n+///   repertoire of the libunwind API. Due to it already being in use, this was\n+///   the chosen route of getting a backtrace.\n+///\n+/// After choosing libgcc_s for backtraces, the sad part is that it will only\n+/// give us a stack trace of instruction pointers. Thankfully these instruction\n+/// pointers are accurate (they work for green and native threads), but it's\n+/// then up to us again to figure out how to translate these addresses to\n+/// symbols. As with before, we have a few options. Before, that, a little bit\n+/// of an interlude about symbols. This is my very limited knowledge about\n+/// symbol tables, and this information is likely slightly wrong, but the\n+/// general idea should be correct.\n+///\n+/// When talking about symbols, it's helpful to know a few things about where\n+/// symbols are located. Some symbols are located in the dynamic symbol table\n+/// of the executable which in theory means that they're available for dynamic\n+/// linking and lookup. Other symbols end up only in the local symbol table of\n+/// the file. This loosely corresponds to pub and priv functions in Rust.\n+///\n+/// Armed with this knowledge, we know that our solution for address to symbol\n+/// translation will need to consult both the local and dynamic symbol tables.\n+/// With that in mind, here's our options of translating an address to\n+/// a symbol.\n+///\n+/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n+///   behind the scenes to translate, and this is why backtrace() was not used.\n+///   Conveniently, this method works fantastically on OSX. It appears dladdr()\n+///   uses magic to consult the local symbol table, or we're putting everything\n+///   in the dynamic symbol table anyway. Regardless, for OSX, this is the\n+///   method used for translation. It's provided by the system and easy to do.o\n+///\n+///   Sadly, all other systems have a dladdr() implementation that does not\n+///   consult the local symbol table. This means that most functions are blank\n+///   because they don't have symbols. This means that we need another solution.\n+///\n+/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n+///   libgcc_s version of the libunwind api), but involves taking a dependency\n+///   to libunwind. We may pursue this route in the future if we bundle\n+///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n+///   this time to provide this functionality.\n+///\n+/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n+///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n+///   so in theory it could invoke readelf, parse the output, and consult the\n+///   local/dynamic symbol tables from there. This ended up not getting chosen\n+///   due to the craziness of the idea plus the advent of the next option.\n+///\n+/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n+///   the gcc repository which provides backtrace and symbol translation\n+///   functionality. All we really need from it is the backtrace functionality,\n+///   and we only really need this on everything that's not OSX, so this is the\n+///   chosen route for now.\n+///\n+/// In summary, the current situation uses libgcc_s to get a trace of stack\n+/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n+/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n+/// all unix platforms we support right now, so it at least gets the job done.\n+#[cfg(unix)]\n+mod imp {\n+    use c_str::CString;\n+    use cast;\n+    use io::{IoResult, IoError, Writer};\n+    use libc;\n+    use option::{Some, None, Option};\n+    use result::{Ok, Err};\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use uw = rt::libunwind;\n+\n+    struct Context<'a> {\n+        idx: int,\n+        writer: &'a mut Writer,\n+        last_error: Option<IoError>,\n+    }\n+\n+    #[inline(never)] // if we know this is a function call, we can skip it when\n+                     // tracing\n+    pub fn write(w: &mut Writer) -> IoResult<()> {\n+        // When using libbacktrace, we use some necessary global state, so we\n+        // need to prevent more than one thread from entering this block. This\n+        // is semi-reasonable in terms of printing anyway, and we know that all\n+        // I/O done here is blocking I/O, not green I/O, so we don't have to\n+        // worry about this being a native vs green mutex.\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        let _g = unsafe { LOCK.lock() };\n+\n+        try!(writeln!(w, \"stack backtrace:\"));\n+\n+        let mut cx = Context { writer: w, last_error: None, idx: 0 };\n+        return match unsafe {\n+            uw::_Unwind_Backtrace(trace_fn,\n+                                  &mut cx as *mut Context as *libc::c_void)\n+        } {\n+            uw::_URC_NO_REASON => {\n+                match cx.last_error {\n+                    Some(err) => Err(err),\n+                    None => Ok(())\n+                }\n+            }\n+            _ => Ok(()),\n+        };\n+\n+        extern fn trace_fn(ctx: *uw::_Unwind_Context,\n+                           arg: *libc::c_void) -> uw::_Unwind_Reason_Code {\n+            let cx: &mut Context = unsafe { cast::transmute(arg) };\n+            let ip = unsafe { uw::_Unwind_GetIP(ctx) as *libc::c_void };\n+            // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+            // it appears to work fine without it, so we only use\n+            // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+            // slightly more accurate stack trace in the process.\n+            //\n+            // This is often because failure involves the last instruction of a\n+            // function being \"call std::rt::begin_unwind\", with no ret\n+            // instructions after it. This means that the return instruction\n+            // pointer points *outside* of the calling function, and by\n+            // unwinding it we go back to the original function.\n+            let ip = if cfg!(target_os = \"macos\") {\n+                ip\n+            } else {\n+                unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+            };\n+\n+            // Don't print out the first few frames (they're not user frames)\n+            cx.idx += 1;\n+            if cx.idx <= 0 { return uw::_URC_NO_REASON }\n+            // Don't print ginormous backtraces\n+            if cx.idx > 100 {\n+                match write!(cx.writer, \" ... <frames omitted>\\n\") {\n+                    Ok(()) => {}\n+                    Err(e) => { cx.last_error = Some(e); }\n+                }\n+                return uw::_URC_FAILURE\n+            }\n+\n+            // Once we hit an error, stop trying to print more frames\n+            if cx.last_error.is_some() { return uw::_URC_FAILURE }\n+\n+            match print(cx.writer, cx.idx, ip) {\n+                Ok(()) => {}\n+                Err(e) => { cx.last_error = Some(e); }\n+            }\n+\n+            // keep going\n+            return uw::_URC_NO_REASON\n+        }\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n+        use intrinsics;\n+        struct Dl_info {\n+            dli_fname: *libc::c_char,\n+            dli_fbase: *libc::c_void,\n+            dli_sname: *libc::c_char,\n+            dli_saddr: *libc::c_void,\n+        }\n+        extern {\n+            fn dladdr(addr: *libc::c_void,\n+                      info: *mut Dl_info) -> libc::c_int;\n+        }\n+\n+        let mut info: Dl_info = unsafe { intrinsics::init() };\n+        if unsafe { dladdr(addr, &mut info) == 0 } {\n+            output(w, idx,addr, None)\n+        } else {\n+            output(w, idx, addr, Some(unsafe {\n+                CString::new(info.dli_sname, false)\n+            }))\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"macos\"))]\n+    fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n+        use container::Container;\n+        use iter::Iterator;\n+        use os;\n+        use path::GenericPath;\n+        use ptr::RawPtr;\n+        use ptr;\n+        use vec::{ImmutableVector, MutableVector};\n+\n+        ////////////////////////////////////////////////////////////////////////\n+        // libbacktrace.h API\n+        ////////////////////////////////////////////////////////////////////////\n+        type backtrace_syminfo_callback =\n+            extern \"C\" fn(data: *mut libc::c_void,\n+                          pc: libc::uintptr_t,\n+                          symname: *libc::c_char,\n+                          symval: libc::uintptr_t,\n+                          symsize: libc::uintptr_t);\n+        type backtrace_error_callback =\n+            extern \"C\" fn(data: *mut libc::c_void,\n+                          msg: *libc::c_char,\n+                          errnum: libc::c_int);\n+        enum backtrace_state {}\n+        #[link(name = \"backtrace\", kind = \"static\")]\n+        extern {\n+            fn backtrace_create_state(filename: *libc::c_char,\n+                                      threaded: libc::c_int,\n+                                      error: backtrace_error_callback,\n+                                      data: *mut libc::c_void)\n+                                            -> *mut backtrace_state;\n+            fn backtrace_syminfo(state: *mut backtrace_state,\n+                                 addr: libc::uintptr_t,\n+                                 cb: backtrace_syminfo_callback,\n+                                 error: backtrace_error_callback,\n+                                 data: *mut libc::c_void) -> libc::c_int;\n+        }\n+\n+        ////////////////////////////////////////////////////////////////////////\n+        // helper callbacks\n+        ////////////////////////////////////////////////////////////////////////\n+\n+        extern fn error_cb(_data: *mut libc::c_void, _msg: *libc::c_char,\n+                           _errnum: libc::c_int) {\n+            // do nothing for now\n+        }\n+        extern fn syminfo_cb(data: *mut libc::c_void,\n+                             _pc: libc::uintptr_t,\n+                             symname: *libc::c_char,\n+                             _symval: libc::uintptr_t,\n+                             _symsize: libc::uintptr_t) {\n+            let slot = data as *mut *libc::c_char;\n+            unsafe { *slot = symname; }\n+        }\n+\n+        // The libbacktrace API supports creating a state, but it does not\n+        // support destroying a state. I personally take this to mean that a\n+        // state is meant to be created and then live forever.\n+        //\n+        // I would love to register an at_exit() handler which cleans up this\n+        // state, but libbacktrace provides no way to do so.\n+        //\n+        // With these constraints, this function has a statically cached state\n+        // that is calculated the first time this is requested. Remember that\n+        // backtracing all happens serially (one global lock).\n+        //\n+        // An additionally oddity in this function is that we initialize the\n+        // filename via self_exe_name() to pass to libbacktrace. It turns out\n+        // that on linux libbacktrace seamlessly gets the filename of the\n+        // current executable, but this fails on freebsd. by always providing\n+        // it, we make sure that libbacktrace never has a reason to not look up\n+        // the symbols. The libbacktrace API also states that the filename must\n+        // be in \"permanent memory\", so we copy it to a static and then use the\n+        // static as the pointer.\n+        unsafe fn init_state() -> *mut backtrace_state {\n+            static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n+            static mut LAST_FILENAME: [libc::c_char, ..256] = [0, ..256];\n+            if !STATE.is_null() { return STATE }\n+            let selfname = if cfg!(target_os = \"freebsd\") {\n+                os::self_exe_name()\n+            } else {\n+                None\n+            };\n+            let filename = match selfname {\n+                Some(path) => {\n+                    let bytes = path.as_vec();\n+                    if bytes.len() < LAST_FILENAME.len() {\n+                        let i = bytes.iter();\n+                        for (slot, val) in LAST_FILENAME.mut_iter().zip(i) {\n+                            *slot = *val as libc::c_char;\n+                        }\n+                        LAST_FILENAME.as_ptr()\n+                    } else {\n+                        ptr::null()\n+                    }\n+                }\n+                None => ptr::null(),\n+            };\n+            STATE = backtrace_create_state(filename, 0, error_cb,\n+                                           ptr::mut_null());\n+            return STATE\n+        }\n+\n+        ////////////////////////////////////////////////////////////////////////\n+        // translation\n+        ////////////////////////////////////////////////////////////////////////\n+\n+        // backtrace errors are currently swept under the rug, only I/O\n+        // errors are reported\n+        let state = unsafe { init_state() };\n+        if state.is_null() {\n+            return output(w, idx, addr, None)\n+        }\n+        let mut data = 0 as *libc::c_char;\n+        let data_addr = &mut data as *mut *libc::c_char;\n+        let ret = unsafe {\n+            backtrace_syminfo(state, addr as libc::uintptr_t,\n+                              syminfo_cb, error_cb,\n+                              data_addr as *mut libc::c_void)\n+        };\n+        if ret == 0 || data.is_null() {\n+            output(w, idx, addr, None)\n+        } else {\n+            output(w, idx, addr, Some(unsafe { CString::new(data, false) }))\n+        }\n+    }\n+\n+    // Finally, after all that work above, we can emit a symbol.\n+    fn output(w: &mut Writer, idx: int, addr: *libc::c_void,\n+              s: Option<CString>) -> IoResult<()> {\n+        try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, super::HEX_WIDTH));\n+        match s.as_ref().and_then(|c| c.as_str()) {\n+            Some(string) => try!(super::demangle(w, string)),\n+            None => try!(write!(w, \"<unknown>\")),\n+        }\n+        w.write(['\\n' as u8])\n+    }\n+}\n+\n+/// As always, windows has something very different than unix, we mainly want\n+/// to avoid having to depend too much on libunwind for windows.\n+///\n+/// If you google around, you'll find a fair bit of references to built-in\n+/// functions to get backtraces on windows. It turns out that most of these are\n+/// in an external library called dbghelp. I was unable to find this library\n+/// via `-ldbghelp`, but it is apparently normal to do the `dlopen` equivalent\n+/// of it.\n+///\n+/// You'll also find that there's a function called CaptureStackBackTrace\n+/// mentioned frequently (which is also easy to use), but sadly I didn't have a\n+/// copy of that function in my mingw install (maybe it was broken?). Instead,\n+/// this takes the route of using StackWalk64 in order to walk the stack.\n+#[cfg(windows)]\n+#[allow(dead_code, uppercase_variables)]\n+mod imp {\n+    use c_str::CString;\n+    use container::Container;\n+    use io::{IoResult, Writer};\n+    use iter::Iterator;\n+    use libc;\n+    use mem;\n+    use ops::Drop;\n+    use option::{Some, None};\n+    use path::Path;\n+    use result::{Ok, Err};\n+    use str::StrSlice;\n+    use unstable::dynamic_lib::DynamicLibrary;\n+    use intrinsics;\n+    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use vec::ImmutableVector;\n+\n+    extern \"system\" {\n+        fn GetCurrentProcess() -> libc::HANDLE;\n+        fn GetCurrentThread() -> libc::HANDLE;\n+        fn RtlCaptureContext(ctx: *mut arch::CONTEXT);\n+    }\n+\n+    type SymFromAddrFn =\n+        extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n+                           *mut SYMBOL_INFO) -> libc::BOOL;\n+    type SymInitializeFn =\n+        extern \"system\" fn(libc::HANDLE, *libc::c_void,\n+                           libc::BOOL) -> libc::BOOL;\n+    type SymCleanupFn =\n+        extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n+\n+    type StackWalk64Fn =\n+        extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n+                           *mut STACKFRAME64, *mut arch::CONTEXT,\n+                           *libc::c_void, *libc::c_void,\n+                           *libc::c_void, *libc::c_void) -> libc::BOOL;\n+\n+    static MAX_SYM_NAME: uint = 2000;\n+    static IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n+    static IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n+    static IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n+\n+    #[packed]\n+    struct SYMBOL_INFO {\n+        SizeOfStruct: libc::c_ulong,\n+        TypeIndex: libc::c_ulong,\n+        Reserved: [u64, ..2],\n+        Index: libc::c_ulong,\n+        Size: libc::c_ulong,\n+        ModBase: u64,\n+        Flags: libc::c_ulong,\n+        Value: u64,\n+        Address: u64,\n+        Register: libc::c_ulong,\n+        Scope: libc::c_ulong,\n+        Tag: libc::c_ulong,\n+        NameLen: libc::c_ulong,\n+        MaxNameLen: libc::c_ulong,\n+        // note that windows has this as 1, but it basically just means that\n+        // the name is inline at the end of the struct. For us, we just bump\n+        // the struct size up to MAX_SYM_NAME.\n+        Name: [libc::c_char, ..MAX_SYM_NAME],\n+    }\n+\n+    #[repr(C)]\n+    enum ADDRESS_MODE {\n+        AddrMode1616,\n+        AddrMode1632,\n+        AddrModeReal,\n+        AddrModeFlat,\n+    }\n+\n+    struct ADDRESS64 {\n+        Offset: u64,\n+        Segment: u16,\n+        Mode: ADDRESS_MODE,\n+    }\n+\n+    struct STACKFRAME64 {\n+        AddrPC: ADDRESS64,\n+        AddrReturn: ADDRESS64,\n+        AddrFrame: ADDRESS64,\n+        AddrStack: ADDRESS64,\n+        AddrBStore: ADDRESS64,\n+        FuncTableEntry: *libc::c_void,\n+        Params: [u64, ..4],\n+        Far: libc::BOOL,\n+        Virtual: libc::BOOL,\n+        Reserved: [u64, ..3],\n+        KdHelp: KDHELP64,\n+    }\n+\n+    struct KDHELP64 {\n+        Thread: u64,\n+        ThCallbackStack: libc::DWORD,\n+        ThCallbackBStore: libc::DWORD,\n+        NextCallback: libc::DWORD,\n+        FramePointer: libc::DWORD,\n+        KiCallUserMode: u64,\n+        KeUserCallbackDispatcher: u64,\n+        SystemRangeStart: u64,\n+        KiUserExceptionDispatcher: u64,\n+        StackBase: u64,\n+        StackLimit: u64,\n+        Reserved: [u64, ..5],\n+    }\n+\n+    #[cfg(target_arch = \"x86\")]\n+    mod arch {\n+        use libc;\n+\n+        static MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n+\n+        pub struct CONTEXT {\n+            ContextFlags: libc::DWORD,\n+            Dr0: libc::DWORD,\n+            Dr1: libc::DWORD,\n+            Dr2: libc::DWORD,\n+            Dr3: libc::DWORD,\n+            Dr6: libc::DWORD,\n+            Dr7: libc::DWORD,\n+            FloatSave: FLOATING_SAVE_AREA,\n+            SegGs: libc::DWORD,\n+            SegFs: libc::DWORD,\n+            SegEs: libc::DWORD,\n+            SegDs: libc::DWORD,\n+            Edi: libc::DWORD,\n+            Esi: libc::DWORD,\n+            Ebx: libc::DWORD,\n+            Edx: libc::DWORD,\n+            Ecx: libc::DWORD,\n+            Eax: libc::DWORD,\n+            Ebp: libc::DWORD,\n+            Eip: libc::DWORD,\n+            SegCs: libc::DWORD,\n+            EFlags: libc::DWORD,\n+            Esp: libc::DWORD,\n+            SegSs: libc::DWORD,\n+            ExtendedRegisters: [u8, ..MAXIMUM_SUPPORTED_EXTENSION],\n+        }\n+\n+        pub struct FLOATING_SAVE_AREA {\n+            ControlWord: libc::DWORD,\n+            StatusWord: libc::DWORD,\n+            TagWord: libc::DWORD,\n+            ErrorOffset: libc::DWORD,\n+            ErrorSelector: libc::DWORD,\n+            DataOffset: libc::DWORD,\n+            DataSelector: libc::DWORD,\n+            RegisterArea: [u8, ..80],\n+            Cr0NpxState: libc::DWORD,\n+        }\n+\n+        pub fn init_frame(frame: &mut super::STACKFRAME64,\n+                          ctx: &CONTEXT) -> libc::DWORD {\n+            frame.AddrPC.Offset = ctx.Eip as u64;\n+            frame.AddrPC.Mode = super::AddrModeFlat;\n+            frame.AddrStack.Offset = ctx.Esp as u64;\n+            frame.AddrStack.Mode = super::AddrModeFlat;\n+            frame.AddrFrame.Offset = ctx.Ebp as u64;\n+            frame.AddrFrame.Mode = super::AddrModeFlat;\n+            super::IMAGE_FILE_MACHINE_I386\n+        }\n+    }\n+\n+    struct Cleanup {\n+        handle: libc::HANDLE,\n+        SymCleanup: SymCleanupFn,\n+    }\n+\n+    impl Drop for Cleanup {\n+        fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n+    }\n+\n+    pub fn write(w: &mut Writer) -> IoResult<()> {\n+        // According to windows documentation, all dbghelp functions are\n+        // single-threaded.\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        let _g = unsafe { LOCK.lock() };\n+\n+        // Open up dbghelp.dll, we don't link to it explicitly because it can't\n+        // always be found. Additionally, it's nice having fewer dependencies.\n+        let path = Path::new(\"dbghelp.dll\");\n+        let lib = match DynamicLibrary::open(Some(&path)) {\n+            Ok(lib) => lib,\n+            Err(..) => return Ok(()),\n+        };\n+\n+        macro_rules! sym( ($e:expr, $t:ident) => (\n+            match unsafe { lib.symbol::<$t>($e) } {\n+                Ok(f) => f,\n+                Err(..) => return Ok(())\n+            }\n+        ) )\n+\n+        // Fetch the symbols necessary from dbghelp.dll\n+        let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n+        let SymInitialize = sym!(\"SymInitialize\", SymInitializeFn);\n+        let SymCleanup = sym!(\"SymCleanup\", SymCleanupFn);\n+        let StackWalk64 = sym!(\"StackWalk64\", StackWalk64Fn);\n+\n+        // Allocate necessary structures for doing the stack walk\n+        let process = unsafe { GetCurrentProcess() };\n+        let thread = unsafe { GetCurrentThread() };\n+        let mut context: arch::CONTEXT = unsafe { intrinsics::init() };\n+        unsafe { RtlCaptureContext(&mut context); }\n+        let mut frame: STACKFRAME64 = unsafe { intrinsics::init() };\n+        let image = arch::init_frame(&mut frame, &context);\n+\n+        // Initialize this process's symbols\n+        let ret = SymInitialize(process, 0 as *libc::c_void, libc::TRUE);\n+        if ret != libc::TRUE { return Ok(()) }\n+        let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n+\n+        // And now that we're done with all the setup, do the stack walking!\n+        let mut i = 0;\n+        try!(write!(w, \"stack backtrace:\\n\"));\n+        while StackWalk64(image, process, thread, &mut frame, &mut context,\n+                          0 as *libc::c_void, 0 as *libc::c_void,\n+                          0 as *libc::c_void, 0 as *libc::c_void) == libc::TRUE{\n+            let addr = frame.AddrPC.Offset;\n+            if addr == frame.AddrReturn.Offset || addr == 0 ||\n+               frame.AddrReturn.Offset == 0 { break }\n+\n+            i += 1;\n+            try!(write!(w, \"  {:2}: {:#2$x}\", i, addr, super::HEX_WIDTH));\n+            let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n+            info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n+            info.SizeOfStruct = (mem::size_of::<SYMBOL_INFO>() -\n+                                 info.Name.len() + 1) as libc::c_ulong;\n+\n+            let mut displacement = 0u64;\n+            let ret = SymFromAddr(process, addr as u64, &mut displacement,\n+                                  &mut info);\n+\n+            if ret == libc::TRUE {\n+                try!(write!(w, \" - \"));\n+                let cstr = unsafe { CString::new(info.Name.as_ptr(), false) };\n+                let bytes = cstr.as_bytes();\n+                match cstr.as_str() {\n+                    Some(s) => try!(super::demangle(w, s)),\n+                    None => try!(w.write(bytes.slice_to(bytes.len() - 1))),\n+                }\n+            }\n+            try!(w.write(['\\n' as u8]));\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use io::MemWriter;\n+    use str;\n+\n+    #[test]\n+    fn demangle() {\n+        macro_rules! t( ($a:expr, $b:expr) => ({\n+            let mut m = MemWriter::new();\n+            super::demangle(&mut m, $a);\n+            assert_eq!(str::from_utf8_owned(m.unwrap()).unwrap(), $b.to_owned());\n+        }) )\n+\n+        t!(\"test\", \"test\");\n+        t!(\"_ZN4testE\", \"test\");\n+        t!(\"_ZN4test\", \"_ZN4test\");\n+        t!(\"_ZN4test1a2bcE\", \"test::a::bc\");\n+    }\n+}"}, {"sha": "bdb049fbb5f7fe30b4a8c6a646785e4d60580252", "filename": "src/libstd/rt/libunwind.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unwind library interface\n+\n+#[allow(non_camel_case_types)];\n+#[allow(dead_code)]; // these are just bindings\n+\n+use libc;\n+\n+#[cfg(not(target_arch = \"arm\"))]\n+#[repr(C)]\n+pub enum _Unwind_Action\n+{\n+    _UA_SEARCH_PHASE = 1,\n+    _UA_CLEANUP_PHASE = 2,\n+    _UA_HANDLER_FRAME = 4,\n+    _UA_FORCE_UNWIND = 8,\n+    _UA_END_OF_STACK = 16,\n+}\n+\n+#[cfg(target_arch = \"arm\")]\n+#[repr(C)]\n+pub enum _Unwind_State\n+{\n+  _US_VIRTUAL_UNWIND_FRAME = 0,\n+  _US_UNWIND_FRAME_STARTING = 1,\n+  _US_UNWIND_FRAME_RESUME = 2,\n+  _US_ACTION_MASK = 3,\n+  _US_FORCE_UNWIND = 8,\n+  _US_END_OF_STACK = 16\n+}\n+\n+#[repr(C)]\n+pub enum _Unwind_Reason_Code {\n+    _URC_NO_REASON = 0,\n+    _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+    _URC_FATAL_PHASE2_ERROR = 2,\n+    _URC_FATAL_PHASE1_ERROR = 3,\n+    _URC_NORMAL_STOP = 4,\n+    _URC_END_OF_STACK = 5,\n+    _URC_HANDLER_FOUND = 6,\n+    _URC_INSTALL_CONTEXT = 7,\n+    _URC_CONTINUE_UNWIND = 8,\n+    _URC_FAILURE = 9, // used only by ARM EABI\n+}\n+\n+pub type _Unwind_Exception_Class = u64;\n+\n+pub type _Unwind_Word = libc::uintptr_t;\n+\n+#[cfg(target_arch = \"x86\")]\n+pub static unwinder_private_data_size: int = 5;\n+\n+#[cfg(target_arch = \"x86_64\")]\n+pub static unwinder_private_data_size: int = 2;\n+\n+#[cfg(target_arch = \"arm\")]\n+pub static unwinder_private_data_size: int = 20;\n+\n+pub struct _Unwind_Exception {\n+    exception_class: _Unwind_Exception_Class,\n+    exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n+    private: [_Unwind_Word, ..unwinder_private_data_size],\n+}\n+\n+pub enum _Unwind_Context {}\n+\n+pub type _Unwind_Exception_Cleanup_Fn =\n+        extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n+                      exception: *_Unwind_Exception);\n+\n+pub type _Unwind_Trace_Fn =\n+        extern \"C\" fn(ctx: *_Unwind_Context,\n+                      arg: *libc::c_void) -> _Unwind_Reason_Code;\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"win32\")]\n+#[link(name = \"gcc_s\")]\n+extern {}\n+\n+#[cfg(target_os = \"android\")]\n+#[link(name = \"gcc\")]\n+extern {}\n+\n+extern \"C\" {\n+    pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)\n+                -> _Unwind_Reason_Code;\n+    pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n+    pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n+                             trace_argument: *libc::c_void)\n+                -> _Unwind_Reason_Code;\n+    #[cfg(not(target_os = \"android\"))]\n+    pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;\n+    #[cfg(not(target_os = \"android\"))]\n+    pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void;\n+}\n+\n+// On android, the function _Unwind_GetIP is a macro, and this is the expansion\n+// of the macro. This is all copy/pasted directly from the header file with the\n+// definition of _Unwind_GetIP.\n+#[cfg(target_os = \"android\")]\n+pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t {\n+    #[repr(C)]\n+    enum _Unwind_VRS_Result {\n+        _UVRSR_OK = 0,\n+        _UVRSR_NOT_IMPLEMENTED = 1,\n+        _UVRSR_FAILED = 2,\n+    }\n+    #[repr(C)]\n+    enum _Unwind_VRS_RegClass {\n+        _UVRSC_CORE = 0,\n+        _UVRSC_VFP = 1,\n+        _UVRSC_FPA = 2,\n+        _UVRSC_WMMXD = 3,\n+        _UVRSC_WMMXC = 4,\n+    }\n+    #[repr(C)]\n+    enum _Unwind_VRS_DataRepresentation {\n+        _UVRSD_UINT32 = 0,\n+        _UVRSD_VFPX = 1,\n+        _UVRSD_FPAX = 2,\n+        _UVRSD_UINT64 = 3,\n+        _UVRSD_FLOAT = 4,\n+        _UVRSD_DOUBLE = 5,\n+    }\n+\n+    type _Unwind_Word = libc::c_uint;\n+    extern {\n+        fn _Unwind_VRS_Get(ctx: *_Unwind_Context,\n+                           klass: _Unwind_VRS_RegClass,\n+                           word: _Unwind_Word,\n+                           repr: _Unwind_VRS_DataRepresentation,\n+                           data: *mut libc::c_void) -> _Unwind_VRS_Result;\n+    }\n+\n+    let mut val: _Unwind_Word = 0;\n+    let ptr = &mut val as *mut _Unwind_Word;\n+    let _ = _Unwind_VRS_Get(ctx, _UVRSC_CORE, 15, _UVRSD_UINT32,\n+                            ptr as *mut libc::c_void);\n+    (val & !1) as libc::uintptr_t\n+}\n+\n+// This function also doesn't exist on android, so make it a no-op\n+#[cfg(target_os = \"android\")]\n+pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void) -> *libc::c_void{\n+    pc\n+}"}, {"sha": "a58826daa494e24f4d385cbd428ae9cf88e39ca8", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -119,6 +119,12 @@ mod thread_local_storage;\n /// Stack unwinding\n pub mod unwind;\n \n+/// The interface to libunwind that rust is using.\n+mod libunwind;\n+\n+/// Simple backtrace functionality (to print on failure)\n+pub mod backtrace;\n+\n /// Just stuff\n mod util;\n "}, {"sha": "3a06075ce484568faee7200188128fb396cc2168", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 22, "deletions": 89, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -65,99 +65,14 @@ use option::{Some, None, Option};\n use prelude::drop;\n use ptr::RawPtr;\n use result::{Err, Ok};\n+use rt::backtrace;\n use rt::local::Local;\n use rt::task::Task;\n use str::Str;\n use task::TaskResult;\n use intrinsics;\n \n-use uw = self::libunwind;\n-\n-#[allow(dead_code)]\n-mod libunwind {\n-    //! Unwind library interface\n-\n-    #[allow(non_camel_case_types)];\n-    #[allow(dead_code)]; // these are just bindings\n-\n-    use libc::{uintptr_t};\n-\n-    #[cfg(not(target_arch = \"arm\"))]\n-    #[repr(C)]\n-    pub enum _Unwind_Action\n-    {\n-        _UA_SEARCH_PHASE = 1,\n-        _UA_CLEANUP_PHASE = 2,\n-        _UA_HANDLER_FRAME = 4,\n-        _UA_FORCE_UNWIND = 8,\n-        _UA_END_OF_STACK = 16,\n-    }\n-\n-    #[cfg(target_arch = \"arm\")]\n-    #[repr(C)]\n-    pub enum _Unwind_State\n-    {\n-      _US_VIRTUAL_UNWIND_FRAME = 0,\n-      _US_UNWIND_FRAME_STARTING = 1,\n-      _US_UNWIND_FRAME_RESUME = 2,\n-      _US_ACTION_MASK = 3,\n-      _US_FORCE_UNWIND = 8,\n-      _US_END_OF_STACK = 16\n-    }\n-\n-    #[repr(C)]\n-    pub enum _Unwind_Reason_Code {\n-        _URC_NO_REASON = 0,\n-        _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n-        _URC_FATAL_PHASE2_ERROR = 2,\n-        _URC_FATAL_PHASE1_ERROR = 3,\n-        _URC_NORMAL_STOP = 4,\n-        _URC_END_OF_STACK = 5,\n-        _URC_HANDLER_FOUND = 6,\n-        _URC_INSTALL_CONTEXT = 7,\n-        _URC_CONTINUE_UNWIND = 8,\n-        _URC_FAILURE = 9, // used only by ARM EABI\n-    }\n-\n-    pub type _Unwind_Exception_Class = u64;\n-\n-    pub type _Unwind_Word = uintptr_t;\n-\n-    #[cfg(target_arch = \"x86\")]\n-    pub static unwinder_private_data_size: int = 5;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub static unwinder_private_data_size: int = 2;\n-\n-    #[cfg(target_arch = \"arm\")]\n-    pub static unwinder_private_data_size: int = 20;\n-\n-    pub struct _Unwind_Exception {\n-        exception_class: _Unwind_Exception_Class,\n-        exception_cleanup: _Unwind_Exception_Cleanup_Fn,\n-        private: [_Unwind_Word, ..unwinder_private_data_size],\n-    }\n-\n-    pub enum _Unwind_Context {}\n-\n-    pub type _Unwind_Exception_Cleanup_Fn = extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n-                                                          exception: *_Unwind_Exception);\n-\n-    #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"freebsd\")]\n-    #[cfg(target_os = \"win32\")]\n-    #[link(name = \"gcc_s\")]\n-    extern {}\n-\n-    #[cfg(target_os = \"android\")]\n-    #[link(name = \"gcc\")]\n-    extern {}\n-\n-    extern \"C\" {\n-        pub fn _Unwind_RaiseException(exception: *_Unwind_Exception) -> _Unwind_Reason_Code;\n-        pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n-    }\n-}\n+use uw = rt::libunwind;\n \n pub struct Unwinder {\n     priv unwinding: bool,\n@@ -282,7 +197,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n #[doc(hidden)]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = super::libunwind;\n+    use uw = rt::libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -336,7 +251,7 @@ pub mod eabi {\n #[cfg(target_arch = \"arm\", not(test))]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = super::libunwind;\n+    use uw = rt::libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -480,6 +395,10 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n             Some(t) => t,\n             None => {\n                 rterrln!(\"failed at '{}', {}:{}\", msg_s, file, line);\n+                if backtrace::log_enabled() {\n+                    let mut err = ::rt::util::Stderr;\n+                    let _err = backtrace::write(&mut err);\n+                }\n                 unsafe { intrinsics::abort() }\n             }\n         };\n@@ -499,6 +418,9 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n                     let _err = format_args!(|args| ::fmt::writeln(stderr, args),\n                                             \"task '{}' failed at '{}', {}:{}\",\n                                             n, msg_s, file, line);\n+                    if backtrace::log_enabled() {\n+                        let _err = backtrace::write(stderr);\n+                    }\n                     task = Local::take();\n \n                     match mem::replace(&mut task.stderr, Some(stderr)) {\n@@ -513,6 +435,10 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n                 None => {\n                     rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s,\n                              file, line);\n+                    if backtrace::log_enabled() {\n+                        let mut err = ::rt::util::Stderr;\n+                        let _err = backtrace::write(&mut err);\n+                    }\n                 }\n             }\n         }\n@@ -525,6 +451,13 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n             // unwinding or otherwise exiting the task cleanly.\n             rterrln!(\"task failed during unwinding (double-failure - total drag!)\")\n             rterrln!(\"rust must abort now. so sorry.\");\n+\n+            // Don't print the backtrace twice (it would have already been\n+            // printed if logging was enabled).\n+            if !backtrace::log_enabled() {\n+                let mut err = ::rt::util::Stderr;\n+                let _err = backtrace::write(&mut err);\n+            }\n             unsafe { intrinsics::abort() }\n         }\n     }"}, {"sha": "6fe4db5494463cdbca291dc266c339aaeee2797a", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -12,6 +12,7 @@ use container::Container;\n use fmt;\n use from_str::FromStr;\n use io::IoResult;\n+use io;\n use iter::Iterator;\n use libc;\n use option::{Some, None, Option};\n@@ -70,20 +71,20 @@ pub fn default_sched_threads() -> uint {\n     }\n }\n \n-pub fn dumb_println(args: &fmt::Arguments) {\n-    use io;\n+pub struct Stderr;\n \n-    struct Stderr;\n-    impl io::Writer for Stderr {\n-        fn write(&mut self, data: &[u8]) -> IoResult<()> {\n-            unsafe {\n-                libc::write(libc::STDERR_FILENO,\n-                            data.as_ptr() as *libc::c_void,\n-                            data.len() as libc::size_t);\n-            }\n-            Ok(()) // yes, we're lying\n+impl io::Writer for Stderr {\n+    fn write(&mut self, data: &[u8]) -> IoResult<()> {\n+        unsafe {\n+            libc::write(libc::STDERR_FILENO,\n+                        data.as_ptr() as *libc::c_void,\n+                        data.len() as libc::size_t);\n         }\n+        Ok(()) // yes, we're lying\n     }\n+}\n+\n+pub fn dumb_println(args: &fmt::Arguments) {\n     let mut w = Stderr;\n     let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n }\n@@ -140,6 +141,10 @@ memory and partly incapable of presentation to others.\",\n     rterrln!(\"{}\", \"\");\n     rterrln!(\"fatal runtime error: {}\", msg);\n \n+    {\n+        let mut err = Stderr;\n+        let _err = ::rt::backtrace::write(&mut err);\n+    }\n     abort();\n \n     fn abort() -> ! {"}, {"sha": "0e3b33a91d4dc3e99422b8d514fa8a1c5550adc5", "filename": "src/test/run-pass/backtrace.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b2607572d6233a1d4b4f7592573e49b505771e/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=12b2607572d6233a1d4b4f7592573e49b505771e", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast this is executing itself\n+#[no_uv];\n+\n+extern crate native;\n+\n+use std::os;\n+use std::io::process::{Process, ProcessConfig};\n+use std::unstable::finally::Finally;\n+use std::str;\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+\n+#[inline(never)]\n+fn foo() {\n+    fail!()\n+}\n+\n+#[inline(never)]\n+fn double() {\n+    (|| {\n+        fail!(\"once\");\n+    }).finally(|| {\n+        fail!(\"twice\");\n+    })\n+}\n+\n+fn runtest(me: &str) {\n+    let mut env = os::env();\n+    match env.iter().position(|&(ref s, _)| \"RUST_LOG\" == *s) {\n+        Some(i) => { env.remove(i); }\n+        None => {}\n+    }\n+    env.push((~\"RUST_LOG\", ~\"std::rt::backtrace\"));\n+\n+    // Make sure that the stack trace is printed\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"fail\"],\n+        env: Some(env.as_slice()),\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n+            \"bad output: {}\", s);\n+\n+    // Make sure the stack trace is *not* printed\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"fail\"],\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n+            \"bad output2: {}\", s);\n+\n+    // Make sure a stack trace is printed\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"double-fail\"],\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n+            \"bad output3: {}\", s);\n+\n+    // Make sure a stack trace isn't printed too many times\n+    let mut p = Process::configure(ProcessConfig {\n+        program: me,\n+        args: [~\"double-fail\"],\n+        env: Some(env.as_slice()),\n+        .. ProcessConfig::new()\n+    }).unwrap();\n+    let out = p.wait_with_output();\n+    assert!(!out.status.success());\n+    let s = str::from_utf8(out.error).unwrap();\n+    let mut i = 0;\n+    for _ in range(0, 2) {\n+        i += s.slice_from(i + 10).find_str(\"stack backtrace\").unwrap() + 10;\n+    }\n+    assert!(s.slice_from(i + 10).find_str(\"stack backtrace\").is_none(),\n+            \"bad output4: {}\", s);\n+}\n+\n+fn main() {\n+    let args = os::args();\n+    if args.len() >= 2 && args[1].as_slice() == \"fail\" {\n+        foo();\n+    } else if args.len() >= 2 && args[1].as_slice() == \"double-fail\" {\n+        double();\n+    } else {\n+        runtest(args[0]);\n+    }\n+}"}]}