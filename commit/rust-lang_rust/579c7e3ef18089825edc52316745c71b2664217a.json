{"sha": "579c7e3ef18089825edc52316745c71b2664217a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OWM3ZTNlZjE4MDg5ODI1ZWRjNTIzMTY3NDVjNzFiMjY2NDIxN2E=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-01T16:34:04Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-01T16:34:04Z"}, "message": "Make local variables and methods use underscores not camel case", "tree": {"sha": "047a30ce0811e1af04b121f5b0d22d0845e976cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/047a30ce0811e1af04b121f5b0d22d0845e976cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/579c7e3ef18089825edc52316745c71b2664217a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/579c7e3ef18089825edc52316745c71b2664217a", "html_url": "https://github.com/rust-lang/rust/commit/579c7e3ef18089825edc52316745c71b2664217a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/579c7e3ef18089825edc52316745c71b2664217a/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d30d7ff04b2ec0d9013582ac9d79fdbd64cf7d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d30d7ff04b2ec0d9013582ac9d79fdbd64cf7d6", "html_url": "https://github.com/rust-lang/rust/commit/4d30d7ff04b2ec0d9013582ac9d79fdbd64cf7d6"}], "stats": {"total": 276, "additions": 138, "deletions": 138}, "files": [{"sha": "1f446b51fe8ed2dee5bec463bc41b86fba54b5af", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/579c7e3ef18089825edc52316745c71b2664217a/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579c7e3ef18089825edc52316745c71b2664217a/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=579c7e3ef18089825edc52316745c71b2664217a", "patch": "@@ -174,43 +174,43 @@ const MIN_MERGE: uint = 64;\n const MIN_GALLOP: uint = 7;\n const INITIAL_TMP_STORAGE: uint = 128;\n \n-fn timsort<T: Ord>(array: &[mut T]) {\n+fn tim_sort<T: Ord>(array: &[mut T]) {\n     let size = array.len();\n     if size < 2 {\n         return;\n     }\n \n     if size < MIN_MERGE {\n-        let initRunLen = countRunAndMakeAscending(array);\n-        binarysort(array, initRunLen);\n+        let init_run_len = count_run_ascending(array);\n+        binarysort(array, init_run_len);\n         return;\n     }\n \n     let ms = &MergeState();\n-    let minRun = minRunLength(size);\n+    let min_run = min_run_length(size);\n \n     let mut idx = 0;\n     let mut remaining = size;\n     loop {\n         let arr = vec::mut_view(array, idx, size);\n-        let mut runLen: uint = countRunAndMakeAscending(arr);\n+        let mut run_len: uint = count_run_ascending(arr);\n \n-        if runLen < minRun {\n-            let force = if remaining <= minRun {remaining} else {minRun};\n+        if run_len < min_run {\n+            let force = if remaining <= min_run {remaining} else {min_run};\n             let slice = vec::mut_view(arr, 0, force);\n-            binarysort(slice, runLen);\n-            runLen = force;\n+            binarysort(slice, run_len);\n+            run_len = force;\n         }\n \n-        ms.pushRun(idx, runLen);\n-        ms.mergeCollapse(array);\n+        ms.push_run(idx, run_len);\n+        ms.merge_collapse(array);\n \n-        idx += runLen;\n-        remaining -= runLen;\n+        idx += run_len;\n+        remaining -= run_len;\n         if remaining == 0 { break; }\n     }\n \n-    ms.mergeForceCollapse(array);\n+    ms.merge_force_collapse(array);\n }\n \n fn binarysort<T: Ord>(array: &[mut T], start: uint) {\n@@ -226,8 +226,8 @@ fn binarysort<T: Ord>(array: &[mut T], start: uint) {\n \n     while start < size {\n         unsafe {\n-            let tmpView = vec::mut_view(array, start, start+1);\n-            vec::raw::memmove(pivot, tmpView, 1);\n+            let tmp_view = vec::mut_view(array, start, start+1);\n+            vec::raw::memmove(pivot, tmp_view, 1);\n         }\n         let mut left = 0;\n         let mut right = start;\n@@ -245,7 +245,7 @@ fn binarysort<T: Ord>(array: &[mut T], start: uint) {\n         let mut n = start-left;\n \n         unsafe {\n-            moveVec(array, left+1, array, left, n);\n+            move_vec(array, left+1, array, left, n);\n         }\n         array[left] <-> pivot[0];\n         start += 1;\n@@ -254,15 +254,15 @@ fn binarysort<T: Ord>(array: &[mut T], start: uint) {\n }\n \n /// Reverse the order of elements in a slice, in place\n-fn reverseSlice<T>(v: &[mut T], start: uint, end:uint) {\n+fn reverse_slice<T>(v: &[mut T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n         v[i] <-> v[end - i - 1];\n         i += 1;\n     }\n }\n \n-pure fn minRunLength(n: uint) -> uint {\n+pure fn min_run_length(n: uint) -> uint {\n     let mut n = n;\n     let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n \n@@ -273,7 +273,7 @@ pure fn minRunLength(n: uint) -> uint {\n     return n + r;\n }\n \n-fn countRunAndMakeAscending<T: Ord>(array: &[mut T]) -> uint {\n+fn count_run_ascending<T: Ord>(array: &[mut T]) -> uint {\n     let size = array.len();\n     assert size > 0;\n     if size == 1 { return 1; }\n@@ -283,7 +283,7 @@ fn countRunAndMakeAscending<T: Ord>(array: &[mut T]) -> uint {\n         while run < size && array[run] < array[run-1] {\n             run += 1;\n         }\n-        reverseSlice(array, 0, run);\n+        reverse_slice(array, 0, run);\n     } else {\n         while run < size && array[run] >= array[run-1] {\n             run += 1;\n@@ -293,103 +293,103 @@ fn countRunAndMakeAscending<T: Ord>(array: &[mut T]) -> uint {\n     return run;\n }\n \n-pure fn gallopLeft<T: Ord>(key: &const T, array: &[const T],\n+pure fn gallop_left<T: Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     assert size != 0 && hint < size;\n \n-    let mut lastOfs = 0;\n+    let mut last_ofs = 0;\n     let mut ofs = 1;\n \n     if *key > array[hint] {\n-        // Gallop right until array[hint+lastOfs] < key <= array[hint+ofs]\n-        let maxOfs = size - hint;\n-        while ofs < maxOfs && *key > array[hint+ofs] {\n-            lastOfs = ofs;\n+        // Gallop right until array[hint+last_ofs] < key <= array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key > array[hint+ofs] {\n+            last_ofs = ofs;\n             ofs = (ofs << 1) + 1;\n-            if ofs < lastOfs { ofs = maxOfs; } // uint overflow guard\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n         }\n-        if ofs > maxOfs { ofs = maxOfs; }\n+        if ofs > max_ofs { ofs = max_ofs; }\n \n-        lastOfs += hint;\n+        last_ofs += hint;\n         ofs += hint;\n     } else {\n-        let maxOfs = hint + 1;\n-        while ofs < maxOfs && *key <= array[hint-ofs] {\n-            lastOfs = ofs;\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key <= array[hint-ofs] {\n+            last_ofs = ofs;\n             ofs = (ofs << 1) + 1;\n-            if ofs < lastOfs { ofs = maxOfs; } // uint overflow guard\n+            if ofs < last_ofs { ofs = max_ofs; } // uint overflow guard\n         }\n \n-        if ofs > maxOfs { ofs = maxOfs; }\n+        if ofs > max_ofs { ofs = max_ofs; }\n \n-        let tmp = lastOfs;\n-        lastOfs = hint - ofs;\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n         ofs = hint - tmp;\n     }\n-    assert (lastOfs < ofs || lastOfs+1 < ofs+1) && ofs <= size;\n+    assert (last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size;\n \n-    lastOfs += 1;\n-    while lastOfs < ofs {\n-        let m = lastOfs + ((ofs - lastOfs) >> 1);\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n         if *key > array[m] {\n-            lastOfs = m+1;\n+            last_ofs = m+1;\n         } else {\n             ofs = m;\n         }\n     }\n-    assert lastOfs == ofs;\n+    assert last_ofs == ofs;\n     return ofs;\n }\n \n-pure fn gallopRight<T: Ord>(key: &const T, array: &[const T],\n+pure fn gallop_right<T: Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     assert size != 0 && hint < size;\n \n-    let mut lastOfs = 0;\n+    let mut last_ofs = 0;\n     let mut ofs = 1;\n \n     if *key >= array[hint] {\n-        // Gallop right until array[hint+lastOfs] <= key < array[hint+ofs]\n-        let maxOfs = size - hint;\n-        while ofs < maxOfs && *key >= array[hint+ofs] {\n-            lastOfs = ofs;\n+        // Gallop right until array[hint+last_ofs] <= key < array[hint+ofs]\n+        let max_ofs = size - hint;\n+        while ofs < max_ofs && *key >= array[hint+ofs] {\n+            last_ofs = ofs;\n             ofs = (ofs << 1) + 1;\n-            if ofs < lastOfs { ofs = maxOfs; }\n+            if ofs < last_ofs { ofs = max_ofs; }\n         }\n-        if ofs > maxOfs { ofs = maxOfs; }\n+        if ofs > max_ofs { ofs = max_ofs; }\n \n-        lastOfs += hint;\n+        last_ofs += hint;\n         ofs += hint;\n     } else {\n-        // Gallop left until array[hint-ofs] <= key < array[hint-lastOfs]\n-        let maxOfs = hint + 1;\n-        while ofs < maxOfs && *key < array[hint-ofs] {\n-            lastOfs = ofs;\n+        // Gallop left until array[hint-ofs] <= key < array[hint-last_ofs]\n+        let max_ofs = hint + 1;\n+        while ofs < max_ofs && *key < array[hint-ofs] {\n+            last_ofs = ofs;\n             ofs = (ofs << 1) + 1;\n-            if ofs < lastOfs { ofs = maxOfs; }\n+            if ofs < last_ofs { ofs = max_ofs; }\n         }\n-        if ofs > maxOfs { ofs = maxOfs; }\n+        if ofs > max_ofs { ofs = max_ofs; }\n \n-        let tmp = lastOfs;\n-        lastOfs = hint - ofs;\n+        let tmp = last_ofs;\n+        last_ofs = hint - ofs;\n         ofs = hint - tmp;\n     }\n \n-    assert (lastOfs < ofs || lastOfs+1 < ofs+1) && ofs <= size;\n+    assert (last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size;\n \n-    lastOfs += 1;\n-    while lastOfs < ofs {\n-        let m = lastOfs + ((ofs - lastOfs) >> 1);\n+    last_ofs += 1;\n+    while last_ofs < ofs {\n+        let m = last_ofs + ((ofs - last_ofs) >> 1);\n \n         if *key >= array[m] {\n-            lastOfs = m + 1;\n+            last_ofs = m + 1;\n         } else {\n             ofs = m;\n         }\n     }\n-    assert lastOfs == ofs;\n+    assert last_ofs == ofs;\n     return ofs;\n }\n \n@@ -399,7 +399,7 @@ struct RunState {\n }\n \n struct MergeState<T> {\n-    mut minGallop: uint,\n+    mut min_gallop: uint,\n     mut tmp: ~[T],\n     runs: DVec<RunState>,\n \n@@ -414,19 +414,19 @@ fn MergeState<T>() -> MergeState<T> {\n     let mut tmp = ~[];\n     vec::reserve(&mut tmp, INITIAL_TMP_STORAGE);\n     MergeState {\n-        minGallop: MIN_GALLOP,\n+        min_gallop: MIN_GALLOP,\n         tmp: tmp,\n         runs: DVec(),\n     }\n }\n \n impl<T: Ord> &MergeState<T> {\n-    fn pushRun(runBase: uint, runLen: uint) {\n-        let tmp = RunState{base: runBase, len: runLen};\n+    fn push_run(run_base: uint, run_len: uint) {\n+        let tmp = RunState{base: run_base, len: run_len};\n         self.runs.push(tmp);\n     }\n \n-    fn mergeAt(n: uint, array: &[mut T]) {\n+    fn merge_at(n: uint, array: &[mut T]) {\n         let mut size = self.runs.len();\n         assert size >= 2;\n         assert n == size-2 || n == size-3;\n@@ -448,34 +448,34 @@ impl<T: Ord> &MergeState<T> {\n             }\n \n             let slice = vec::mut_view(array, b1, b1+l1);\n-            let k = gallopRight(&const array[b2], slice, 0);\n+            let k = gallop_right(&const array[b2], slice, 0);\n             b1 += k;\n             l1 -= k;\n             if l1 != 0 {\n                 let slice = vec::mut_view(array, b2, b2+l2);\n-                let l2 = gallopLeft(\n+                let l2 = gallop_left(\n                     &const array[b1+l1-1],slice,l2-1);\n                 if l2 > 0 {\n                     if l1 <= l2 {\n-                        self.mergeLo(array, b1, l1, b2, l2);\n+                        self.merge_lo(array, b1, l1, b2, l2);\n                     } else {\n-                        self.mergeHi(array, b1, l1, b2, l2);\n+                        self.merge_hi(array, b1, l1, b2, l2);\n                     }\n                 }\n             }\n         }\n         self.runs.pop();\n     }\n \n-    fn mergeLo(array: &[mut T], base1: uint, len1: uint,\n+    fn merge_lo(array: &[mut T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n         vec::reserve(&mut self.tmp, len1);\n \n         unsafe {\n             vec::raw::set_len(self.tmp, len1);\n-            moveVec(self.tmp, 0, array, base1, len1);\n+            move_vec(self.tmp, 0, array, base1, len1);\n         }\n \n         let mut c1 = 0;\n@@ -489,25 +489,25 @@ impl<T: Ord> &MergeState<T> {\n \n         if len2 == 0 {\n             unsafe {\n-                moveVec(array, dest, self.tmp, 0, len1);\n+                move_vec(array, dest, self.tmp, 0, len1);\n                 vec::raw::set_len(self.tmp, 0); // Forget the elements\n             }\n             return;\n         }\n         if len1 == 1 {\n             unsafe {\n-                moveVec(array, dest, array, c2, len2);\n+                move_vec(array, dest, array, c2, len2);\n                 array[dest+len2] <-> self.tmp[c1];\n                 vec::raw::set_len(self.tmp, 0); // Forget the element\n             }\n             return;\n         }\n \n-        let mut minGallop = self.minGallop;\n+        let mut min_gallop = self.min_gallop;\n         loop {\n             let mut count1 = 0;\n             let mut count2 = 0;\n-            let mut breakOuter = false;\n+            let mut break_outer = false;\n \n             loop {\n                 assert len1 > 1 && len2 != 0;\n@@ -516,89 +516,89 @@ impl<T: Ord> &MergeState<T> {\n                     dest += 1; c2 += 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 0 {\n-                        breakOuter = true;\n+                        break_outer = true;\n                     }\n                 } else {\n                     array[dest] <-> self.tmp[c1];\n                     dest += 1; c1 += 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 1 {\n-                        breakOuter = true;\n+                        break_outer = true;\n                     }\n                 }\n-                if breakOuter || ((count1 | count2) >= minGallop) {\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n                     break;\n                 }\n             }\n-            if breakOuter { break; }\n+            if break_outer { break; }\n \n             // Start to gallop\n             loop {\n                 assert len1 > 1 && len2 != 0;\n \n-                let tmpView = vec::mut_view(self.tmp, c1, c1+len1);\n-                count1 = gallopRight(&const array[c2], tmpView, 0);\n+                let tmp_view = vec::mut_view(self.tmp, c1, c1+len1);\n+                count1 = gallop_right(&const array[c2], tmp_view, 0);\n                 if count1 != 0 {\n                     unsafe {\n-                        moveVec(array, dest, self.tmp, c1, count1);\n+                        move_vec(array, dest, self.tmp, c1, count1);\n                     }\n                     dest += count1; c1 += count1; len1 -= count1;\n-                    if len1 <= 1 { breakOuter = true; break; }\n+                    if len1 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c2];\n                 dest += 1; c2 += 1; len2 -= 1;\n-                if len2 == 0 { breakOuter = true; break; }\n+                if len2 == 0 { break_outer = true; break; }\n \n-                let tmpView = vec::mut_view(array, c2, c2+len2);\n-                count2 = gallopLeft(&const self.tmp[c1], tmpView, 0);\n+                let tmp_view = vec::mut_view(array, c2, c2+len2);\n+                count2 = gallop_left(&const self.tmp[c1], tmp_view, 0);\n                 if count2 != 0 {\n                     unsafe {\n-                        moveVec(array, dest, array, c2, count2);\n+                        move_vec(array, dest, array, c2, count2);\n                     }\n                     dest += count2; c2 += count2; len2 -= count2;\n-                    if len2 == 0 { breakOuter = true; break; }\n+                    if len2 == 0 { break_outer = true; break; }\n                 }\n                 array[dest] <-> self.tmp[c1];\n                 dest += 1; c1 += 1; len1 -= 1;\n-                if len1 == 1 { breakOuter = true; break; }\n-                minGallop -= 1;\n+                if len1 == 1 { break_outer = true; break; }\n+                min_gallop -= 1;\n                 if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n                     break;\n                 }\n             }\n-            if breakOuter { break; }\n-            if minGallop < 0 { minGallop = 0; }\n-            minGallop += 2; // Penalize for leaving gallop\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n         }\n-        self.minGallop = if minGallop < 1 { 1 } else { minGallop };\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n \n         if len1 == 1 {\n             assert len2 > 0;\n             unsafe {\n-                moveVec(array, dest, array, c2, len2);\n+                move_vec(array, dest, array, c2, len2);\n             }\n             array[dest+len2] <-> self.tmp[c1];\n         } else if len1 == 0 {\n-            fail fmt!(\"Method mergeLo violates its contract! %?\", len1);\n+            fail fmt!(\"Method merge_lo violates its contract! %?\", len1);\n         } else {\n             assert len2 == 0;\n             assert len1 > 1;\n             unsafe {\n-                moveVec(array, dest, self.tmp, c1, len1);\n+                move_vec(array, dest, self.tmp, c1, len1);\n             }\n         }\n         unsafe { vec::raw::set_len(self.tmp, 0); }\n     }\n \n-    fn mergeHi(array: &[mut T], base1: uint, len1: uint,\n+    fn merge_hi(array: &[mut T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n         vec::reserve(&mut self.tmp, len2);\n \n         unsafe {\n             vec::raw::set_len(self.tmp, len2);\n-            moveVec(self.tmp, 0, array, base2, len2);\n+            move_vec(self.tmp, 0, array, base2, len2);\n         }\n \n         let mut c1 = base1 + len1 - 1;\n@@ -612,7 +612,7 @@ impl<T: Ord> &MergeState<T> {\n \n         if len1 == 0 {\n             unsafe {\n-                moveVec(array, dest-(len2-1), self.tmp, 0, len2);\n+                move_vec(array, dest-(len2-1), self.tmp, 0, len2);\n                 vec::raw::set_len(self.tmp, 0); // Forget the elements\n             }\n             return;\n@@ -621,18 +621,18 @@ impl<T: Ord> &MergeState<T> {\n             dest -= len1;\n             c1 -= len1;\n             unsafe {\n-                moveVec(array, dest+1, array, c1+1, len1);\n+                move_vec(array, dest+1, array, c1+1, len1);\n                 array[dest] <-> self.tmp[c2];\n                 vec::raw::set_len(self.tmp, 0); // Forget the element\n             }\n             return;\n         }\n \n-        let mut minGallop = self.minGallop;\n+        let mut min_gallop = self.min_gallop;\n         loop {\n             let mut count1 = 0;\n             let mut count2 = 0;\n-            let mut breakOuter = false;\n+            let mut break_outer = false;\n \n             loop {\n                 assert len1 != 0 && len2 > 1;\n@@ -641,88 +641,88 @@ impl<T: Ord> &MergeState<T> {\n                     dest -= 1; c1 -= 1; len1 -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 0 {\n-                        breakOuter = true;\n+                        break_outer = true;\n                     }\n                 } else {\n                     array[dest] <-> self.tmp[c2];\n                     dest -= 1; c2 -= 1; len2 -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 1 {\n-                        breakOuter = true;\n+                        break_outer = true;\n                     }\n                 }\n-                if breakOuter || ((count1 | count2) >= minGallop) {\n+                if break_outer || ((count1 | count2) >= min_gallop) {\n                     break;\n                 }\n             }\n-            if breakOuter { break; }\n+            if break_outer { break; }\n \n             // Start to gallop\n             loop {\n                 assert len2 > 1 && len1 != 0;\n \n-                let tmpView = vec::mut_view(array, base1, base1+len1);\n-                count1 = len1 - gallopRight(\n-                    &const self.tmp[c2], tmpView, len1-1);\n+                let tmp_view = vec::mut_view(array, base1, base1+len1);\n+                count1 = len1 - gallop_right(\n+                    &const self.tmp[c2], tmp_view, len1-1);\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n                     unsafe {\n-                        moveVec(array, dest+1, array, c1+1, count1);\n+                        move_vec(array, dest+1, array, c1+1, count1);\n                     }\n-                    if len1 == 0 { breakOuter = true; break; }\n+                    if len1 == 0 { break_outer = true; break; }\n                 }\n \n                 array[dest] <-> self.tmp[c2];\n                 dest -= 1; c2 -= 1; len2 -= 1;\n-                if len2 == 1 { breakOuter = true; break; }\n+                if len2 == 1 { break_outer = true; break; }\n \n-                let tmpView = vec::mut_view(self.tmp, 0, len2);\n-                let count2 = len2 - gallopLeft(\n-                    &const array[c1], tmpView, len2-1);\n+                let tmp_view = vec::mut_view(self.tmp, 0, len2);\n+                let count2 = len2 - gallop_left(\n+                    &const array[c1], tmp_view, len2-1);\n                 if count2 != 0 {\n                     dest -= count2; c2 -= count2; len2 -= count2;\n                     unsafe {\n-                        moveVec(array, dest+1, self.tmp, c2+1, count2);\n+                        move_vec(array, dest+1, self.tmp, c2+1, count2);\n                     }\n-                    if len2 <= 1 { breakOuter = true; break; }\n+                    if len2 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c1];\n                 dest -= 1; c1 -= 1; len1 -= 1;\n-                if len1 == 0 { breakOuter = true; break; }\n-                minGallop -= 1;\n+                if len1 == 0 { break_outer = true; break; }\n+                min_gallop -= 1;\n                 if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n                     break;\n                 }\n             }\n \n-            if breakOuter { break; }\n-            if minGallop < 0 { minGallop = 0; }\n-            minGallop += 2; // Penalize for leaving gallop\n+            if break_outer { break; }\n+            if min_gallop < 0 { min_gallop = 0; }\n+            min_gallop += 2; // Penalize for leaving gallop\n         }\n-        self.minGallop = if minGallop < 1 { 1 } else { minGallop };\n+        self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n \n         if len2 == 1 {\n             assert len1 > 0;\n             dest -= len1;\n             c1 -= len1;\n             unsafe {\n-                moveVec(array, dest+1, array, c1+1, len1);\n+                move_vec(array, dest+1, array, c1+1, len1);\n             }\n             array[dest] <-> self.tmp[c2];\n         } else if len2 == 0 {\n-            fail fmt!(\"Method mergeHi violates its contract! %?\", len2);\n+            fail fmt!(\"Method merge_hi violates its contract! %?\", len2);\n         } else {\n             assert len1 == 0;\n             assert len2 != 0;\n             unsafe {\n-                moveVec(array, dest-(len2-1), self.tmp, 0, len2);\n+                move_vec(array, dest-(len2-1), self.tmp, 0, len2);\n             }\n         }\n         unsafe { vec::raw::set_len(self.tmp, 0); }\n     }\n \n-    fn mergeCollapse(array: &[mut T]) {\n+    fn merge_collapse(array: &[mut T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             let chk = do self.runs.borrow |arr| {\n@@ -736,11 +736,11 @@ impl<T: Ord> &MergeState<T> {\n                 }\n             };\n             if !chk { break; }\n-            self.mergeAt(n, array);\n+            self.merge_at(n, array);\n         }\n     }\n \n-    fn mergeForceCollapse(array: &[mut T]) {\n+    fn merge_force_collapse(array: &[mut T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             if n > 0 {\n@@ -750,15 +750,15 @@ impl<T: Ord> &MergeState<T> {\n                     }\n                 }\n             }\n-            self.mergeAt(n, array);\n+            self.merge_at(n, array);\n         }\n     }\n }\n \n // Moves elements to from dest to from\n // Unsafe as it makes the from parameter invalid between s2 and s2+len\n #[inline(always)]\n-unsafe fn moveVec<T>(dest: &[mut T], s1: uint,\n+unsafe fn move_vec<T>(dest: &[mut T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     assert s1+len <= dest.len() && s2+len <= from.len();\n "}]}