{"sha": "f08f3a757643aa16b05ec7dee73ecff216354ddf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwOGYzYTc1NzY0M2FhMTZiMDVlYzdkZWU3M2VjZmYyMTYzNTRkZGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-05T00:06:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-10T23:13:12Z"}, "message": "libstd: Remove `Cell`s that were used because of `finally` by converting\ntheir `finally` blocks to RAII.", "tree": {"sha": "aa525f71c7bace630a6fad4c7cff3b14f1b52c34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa525f71c7bace630a6fad4c7cff3b14f1b52c34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f08f3a757643aa16b05ec7dee73ecff216354ddf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f08f3a757643aa16b05ec7dee73ecff216354ddf", "html_url": "https://github.com/rust-lang/rust/commit/f08f3a757643aa16b05ec7dee73ecff216354ddf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f08f3a757643aa16b05ec7dee73ecff216354ddf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec5603bf13ccb95c311fe5ca193a32efe07147a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5603bf13ccb95c311fe5ca193a32efe07147a2", "html_url": "https://github.com/rust-lang/rust/commit/ec5603bf13ccb95c311fe5ca193a32efe07147a2"}], "stats": {"total": 104, "additions": 63, "deletions": 41}, "files": [{"sha": "01b953051dbd33156c3260d3557682efc58afc2d", "filename": "src/libstd/select.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f08f3a757643aa16b05ec7dee73ecff216354ddf/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08f3a757643aa16b05ec7dee73ecff216354ddf/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=f08f3a757643aa16b05ec7dee73ecff216354ddf", "patch": "@@ -10,18 +10,16 @@\n \n #[allow(missing_doc)];\n \n-use cell::Cell;\n use comm;\n use container::Container;\n use iter::{Iterator, DoubleEndedIterator};\n+use kinds::Send;\n+use ops::Drop;\n use option::*;\n-// use either::{Either, Left, Right};\n-// use rt::kill::BlockedTask;\n use rt::local::Local;\n use rt::rtio::EventLoop;\n use rt::sched::Scheduler;\n use rt::shouldnt_be_public::{SelectInner, SelectPortInner};\n-use unstable::finally::Finally;\n use vec::{OwnedVector, MutableVector};\n \n /// Trait for message-passing primitives that can be select()ed on.\n@@ -32,6 +30,18 @@ pub trait Select : SelectInner { }\n // that implement Select on different types to use select().)\n pub trait SelectPort<T> : SelectPortInner<T> { }\n \n+/// A helper type that throws away a value on a port.\n+struct PortGuard<T> {\n+    port: Option<comm::PortOne<T>>,\n+}\n+\n+#[unsafe_destructor]\n+impl<T:Send> Drop for PortGuard<T> {\n+    fn drop(&mut self) {\n+        let _ = self.port.take_unwrap().recv();\n+    }\n+}\n+\n /// Receive a message from any one of many ports at once. Returns the index of the\n /// port whose data is ready. (If multiple are ready, returns the lowest index.)\n pub fn select<A: Select>(ports: &mut [A]) -> uint {\n@@ -56,11 +66,13 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     // after letting the task get woken up. The and_then closure needs to delay\n     // the task from resuming until all ports have become blocked_on.\n     let (p,c) = comm::oneshot();\n-    let p = Cell::new(p);\n-    let c = Cell::new(c);\n \n-    (|| {\n-        let mut c = Some(c.take());\n+    {\n+        let _guard = PortGuard {\n+            port: Some(p),\n+        };\n+\n+        let mut c = Some(c);\n         let sched: ~Scheduler = Local::take();\n         sched.deschedule_running_task_and_then(|sched, task| {\n             let task_handles = task.make_selectable(ports.len());\n@@ -79,12 +91,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n                 c.send_deferred(())\n             }\n         })\n-    }).finally(|| {\n-        // Unkillable is necessary not because getting killed is dangerous here,\n-        // but to force the recv not to use the same kill-flag that we used for\n-        // selecting. Otherwise a user-sender could spuriously wakeup us here.\n-        p.take().recv();\n-    });\n+    }\n \n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them."}, {"sha": "b66e551c19344e4b95ae3200fba7bfbfc5957ea4", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f08f3a757643aa16b05ec7dee73ecff216354ddf/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08f3a757643aa16b05ec7dee73ecff216354ddf/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=f08f3a757643aa16b05ec7dee73ecff216354ddf", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use cast;\n-use cell::Cell;\n use comm;\n use ptr;\n use option::{Option,Some,None};\n@@ -70,6 +69,35 @@ unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n     cast::transmute(data)\n }\n \n+/// A helper object used by `UnsafeArc::unwrap`.\n+struct ChannelAndDataGuard<T> {\n+    channel: Option<comm::ChanOne<bool>>,\n+    data: Option<~ArcData<T>>,\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for ChannelAndDataGuard<T> {\n+    fn drop(&mut self) {\n+        if task::failing() {\n+            // Killed during wait. Because this might happen while\n+            // someone else still holds a reference, we can't free\n+            // the data now; the \"other\" last refcount will free it.\n+            unsafe {\n+                let channel = self.channel.take_unwrap();\n+                let data = self.data.take_unwrap();\n+                channel.send(false);\n+                cast::forget(data);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> ChannelAndDataGuard<T> {\n+    fn unwrap(mut self) -> (comm::ChanOne<bool>, ~ArcData<T>) {\n+        (self.channel.take_unwrap(), self.data.take_unwrap())\n+    }\n+}\n+\n impl<T: Send> UnsafeArc<T> {\n     pub fn new(data: T) -> UnsafeArc<T> {\n         unsafe { UnsafeArc { data: new_inner(data, 1) } }\n@@ -160,32 +188,19 @@ impl<T: Send> UnsafeArc<T> {\n                     data.data.take_unwrap()\n                 } else {\n                     // The *next* person who sees the refcount hit 0 will wake us.\n-                    let p1 = Cell::new(p1); // argh\n-                    // Unlike the above one, this cell is necessary. It will get\n-                    // taken either in the do block or in the finally block.\n-                    let c2_and_data = Cell::new((c2,data));\n-                    (|| {\n-                        p1.take().recv();\n-                        // Got here. Back in the 'unkillable' without getting killed.\n-                        let (c2, data) = c2_and_data.take();\n-                        c2.send(true);\n-                        // FIXME(#3224): it should be like this\n-                        // let ~ArcData { data: user_data, _ } = data;\n-                        // user_data\n-                        let mut data = data;\n-                        data.data.take_unwrap()\n-                    }).finally(|| {\n-                        if task::failing() {\n-                            // Killed during wait. Because this might happen while\n-                            // someone else still holds a reference, we can't free\n-                            // the data now; the \"other\" last refcount will free it.\n-                            let (c2, data) = c2_and_data.take();\n-                            c2.send(false);\n-                            cast::forget(data);\n-                        } else {\n-                            assert!(c2_and_data.is_empty());\n-                        }\n-                    })\n+                    let c2_and_data = ChannelAndDataGuard {\n+                        channel: Some(c2),\n+                        data: Some(data),\n+                    };\n+                    p1.recv();\n+                    // Got here. Back in the 'unkillable' without getting killed.\n+                    let (c2, data) = c2_and_data.unwrap();\n+                    c2.send(true);\n+                    // FIXME(#3224): it should be like this\n+                    // let ~ArcData { data: user_data, _ } = data;\n+                    // user_data\n+                    let mut data = data;\n+                    data.data.take_unwrap()\n                 }\n             } else {\n                 // If 'put' returns the server end back to us, we were rejected;"}]}