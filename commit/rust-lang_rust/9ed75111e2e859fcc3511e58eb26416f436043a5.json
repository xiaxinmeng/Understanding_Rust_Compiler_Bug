{"sha": "9ed75111e2e859fcc3511e58eb26416f436043a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZDc1MTExZTJlODU5ZmNjMzUxMWU1OGViMjY0MTZmNDM2MDQzYTU=", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2021-02-06T21:13:14Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-02-07T18:46:43Z"}, "message": "deps: apply rustc-ap v705 changes to itemkind variants", "tree": {"sha": "c89f60e339262f5c7526ac2247c642a0927f8dc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c89f60e339262f5c7526ac2247c642a0927f8dc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ed75111e2e859fcc3511e58eb26416f436043a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed75111e2e859fcc3511e58eb26416f436043a5", "html_url": "https://github.com/rust-lang/rust/commit/9ed75111e2e859fcc3511e58eb26416f436043a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ed75111e2e859fcc3511e58eb26416f436043a5/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b80fdf2971201813cd4cc12a0a8d500e5934ce9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b80fdf2971201813cd4cc12a0a8d500e5934ce9d", "html_url": "https://github.com/rust-lang/rust/commit/b80fdf2971201813cd4cc12a0a8d500e5934ce9d"}], "stats": {"total": 339, "additions": 177, "deletions": 162}, "files": [{"sha": "10654a2a5aca7577a84dec86e4d504e8f27d3ce2", "filename": "src/items.rs", "status": "modified", "additions": 69, "deletions": 71, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/9ed75111e2e859fcc3511e58eb26416f436043a5/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed75111e2e859fcc3511e58eb26416f436043a5/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=9ed75111e2e859fcc3511e58eb26416f436043a5", "patch": "@@ -618,8 +618,8 @@ impl<'a> FmtVisitor<'a> {\n             use crate::ast::AssocItemKind::*;\n             fn need_empty_line(a: &ast::AssocItemKind, b: &ast::AssocItemKind) -> bool {\n                 match (a, b) {\n-                    (TyAlias(_, _, _, ref lty), TyAlias(_, _, _, ref rty))\n-                        if both_type(lty, rty) || both_opaque(lty, rty) =>\n+                    (TyAlias(lty), TyAlias(rty))\n+                        if both_type(&lty.3, &rty.3) || both_opaque(&lty.3, &rty.3) =>\n                     {\n                         false\n                     }\n@@ -629,17 +629,17 @@ impl<'a> FmtVisitor<'a> {\n             }\n \n             buffer.sort_by(|(_, a), (_, b)| match (&a.kind, &b.kind) {\n-                (TyAlias(_, _, _, ref lty), TyAlias(_, _, _, ref rty))\n-                    if both_type(lty, rty) || both_opaque(lty, rty) =>\n+                (TyAlias(lty), TyAlias(rty))\n+                    if both_type(&lty.3, &rty.3) || both_opaque(&lty.3, &rty.3) =>\n                 {\n                     a.ident.as_str().cmp(&b.ident.as_str())\n                 }\n                 (Const(..), Const(..)) | (MacCall(..), MacCall(..)) => {\n                     a.ident.as_str().cmp(&b.ident.as_str())\n                 }\n                 (Fn(..), Fn(..)) => a.span.lo().cmp(&b.span.lo()),\n-                (TyAlias(_, _, _, ref ty), _) if is_type(ty) => Ordering::Less,\n-                (_, TyAlias(_, _, _, ref ty)) if is_type(ty) => Ordering::Greater,\n+                (TyAlias(ty), _) if is_type(&ty.3) => Ordering::Less,\n+                (_, TyAlias(ty)) if is_type(&ty.3) => Ordering::Greater,\n                 (TyAlias(..), _) => Ordering::Less,\n                 (_, TyAlias(..)) => Ordering::Greater,\n                 (Const(..), _) => Ordering::Less,\n@@ -675,13 +675,13 @@ pub(crate) fn format_impl(\n     item: &ast::Item,\n     offset: Indent,\n ) -> Option<String> {\n-    if let ast::ItemKind::Impl {\n-        ref generics,\n-        ref self_ty,\n-        ref items,\n-        ..\n-    } = item.kind\n-    {\n+    if let ast::ItemKind::Impl(impl_kind) = &item.kind {\n+        let ast::ImplKind {\n+            ref generics,\n+            ref self_ty,\n+            ref items,\n+            ..\n+        } = **impl_kind;\n         let mut result = String::with_capacity(128);\n         let ref_and_type = format_impl_ref_and_type(context, item, offset)?;\n         let sep = offset.to_string_with_newline(context.config);\n@@ -829,17 +829,17 @@ fn format_impl_ref_and_type(\n     item: &ast::Item,\n     offset: Indent,\n ) -> Option<String> {\n-    if let ast::ItemKind::Impl {\n-        unsafety,\n-        polarity,\n-        defaultness,\n-        constness,\n-        ref generics,\n-        of_trait: ref trait_ref,\n-        ref self_ty,\n-        ..\n-    } = item.kind\n-    {\n+    if let ast::ItemKind::Impl(impl_kind) = &item.kind {\n+        let ast::ImplKind {\n+            unsafety,\n+            polarity,\n+            defaultness,\n+            constness,\n+            ref generics,\n+            of_trait: ref trait_ref,\n+            ref self_ty,\n+            ..\n+        } = **impl_kind;\n         let mut result = String::with_capacity(128);\n \n         result.push_str(&format_visibility(context, &item.vis));\n@@ -1025,14 +1025,9 @@ pub(crate) fn format_trait(\n     item: &ast::Item,\n     offset: Indent,\n ) -> Option<String> {\n-    if let ast::ItemKind::Trait(\n-        is_auto,\n-        unsafety,\n-        ref generics,\n-        ref generic_bounds,\n-        ref trait_items,\n-    ) = item.kind\n-    {\n+    if let ast::ItemKind::Trait(trait_kind) = &item.kind {\n+        let ast::TraitKind(is_auto, unsafety, ref generics, ref generic_bounds, ref trait_items) =\n+            **trait_kind;\n         let mut result = String::with_capacity(128);\n         let header = format!(\n             \"{}{}{}trait \",\n@@ -3119,31 +3114,35 @@ impl Rewrite for ast::ForeignItem {\n         let span = mk_sp(self.span.lo(), self.span.hi() - BytePos(1));\n \n         let item_str = match self.kind {\n-            ast::ForeignItemKind::Fn(defaultness, ref fn_sig, ref generics, Some(ref body)) => {\n-                let mut visitor = FmtVisitor::from_context(context);\n-                visitor.block_indent = shape.indent;\n-                visitor.last_pos = self.span.lo();\n-                let inner_attrs = inner_attributes(&self.attrs);\n-                let fn_ctxt = visit::FnCtxt::Foreign;\n-                visitor.visit_fn(\n-                    visit::FnKind::Fn(fn_ctxt, self.ident, &fn_sig, &self.vis, Some(body)),\n-                    generics,\n-                    &fn_sig.decl,\n-                    self.span,\n-                    defaultness,\n-                    Some(&inner_attrs),\n-                );\n-                Some(visitor.buffer.to_owned())\n+            ast::ForeignItemKind::Fn(ref fn_kind) => {\n+                let ast::FnKind(defaultness, ref fn_sig, ref generics, ref block) = **fn_kind;\n+                if let Some(ref body) = block {\n+                    let mut visitor = FmtVisitor::from_context(context);\n+                    visitor.block_indent = shape.indent;\n+                    visitor.last_pos = self.span.lo();\n+                    let inner_attrs = inner_attributes(&self.attrs);\n+                    let fn_ctxt = visit::FnCtxt::Foreign;\n+                    visitor.visit_fn(\n+                        visit::FnKind::Fn(fn_ctxt, self.ident, &fn_sig, &self.vis, Some(body)),\n+                        generics,\n+                        &fn_sig.decl,\n+                        self.span,\n+                        defaultness,\n+                        Some(&inner_attrs),\n+                    );\n+                    Some(visitor.buffer.to_owned())\n+                } else {\n+                    rewrite_fn_base(\n+                        context,\n+                        shape.indent,\n+                        self.ident,\n+                        &FnSig::from_method_sig(&fn_sig, generics, self.vis.clone()),\n+                        span,\n+                        FnBraceStyle::None,\n+                    )\n+                    .map(|(s, _, _)| format!(\"{};\", s))\n+                }\n             }\n-            ast::ForeignItemKind::Fn(_, ref fn_sig, ref generics, None) => rewrite_fn_base(\n-                context,\n-                shape.indent,\n-                self.ident,\n-                &FnSig::from_method_sig(&fn_sig, generics, self.vis.clone()),\n-                span,\n-                FnBraceStyle::None,\n-            )\n-            .map(|(s, _, _)| format!(\"{};\", s)),\n             ast::ForeignItemKind::Static(ref ty, mutability, _) => {\n                 // FIXME(#21): we're dropping potential comments in between the\n                 // function kw here.\n@@ -3158,21 +3157,20 @@ impl Rewrite for ast::ForeignItem {\n                 // 1 = ;\n                 rewrite_assign_rhs(context, prefix, &**ty, shape.sub_width(1)?).map(|s| s + \";\")\n             }\n-            ast::ForeignItemKind::TyAlias(\n-                _,\n-                ref generics,\n-                ref generic_bounds,\n-                ref type_default,\n-            ) => rewrite_type_alias(\n-                self.ident,\n-                type_default.as_ref(),\n-                generics,\n-                Some(generic_bounds),\n-                &context,\n-                shape.indent,\n-                &self.vis,\n-                self.span,\n-            ),\n+            ast::ForeignItemKind::TyAlias(ref ty_alias_kind) => {\n+                let ast::TyAliasKind(_, ref generics, ref generic_bounds, ref type_default) =\n+                    **ty_alias_kind;\n+                rewrite_type_alias(\n+                    self.ident,\n+                    type_default.as_ref(),\n+                    generics,\n+                    Some(generic_bounds),\n+                    &context,\n+                    shape.indent,\n+                    &self.vis,\n+                    self.span,\n+                )\n+            }\n             ast::ForeignItemKind::MacCall(ref mac) => {\n                 rewrite_macro(mac, None, context, shape, MacroPosition::Item)\n             }"}, {"sha": "34e8536b7ee93f2e094a18fdfb4da4d2137d6c1e", "filename": "src/visitor.rs", "status": "modified", "additions": 108, "deletions": 91, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/9ed75111e2e859fcc3511e58eb26416f436043a5/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ed75111e2e859fcc3511e58eb26416f436043a5/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=9ed75111e2e859fcc3511e58eb26416f436043a5", "patch": "@@ -481,6 +481,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             }\n         };\n \n+        // TODO(calebcartwright): consider enabling box_patterns feature gate\n         if should_visit_node_again {\n             match item.kind {\n                 ast::ItemKind::Use(ref tree) => self.format_import(item, tree),\n@@ -538,66 +539,72 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n                     self.visit_static(&StaticParts::from_item(item));\n                 }\n-                ast::ItemKind::Fn(defaultness, ref fn_signature, ref generics, Some(ref body)) => {\n-                    let inner_attrs = inner_attributes(&item.attrs);\n-                    let fn_ctxt = match fn_signature.header.ext {\n-                        ast::Extern::None => visit::FnCtxt::Free,\n-                        _ => visit::FnCtxt::Foreign,\n-                    };\n-                    self.visit_fn(\n-                        visit::FnKind::Fn(\n-                            fn_ctxt,\n-                            item.ident,\n-                            &fn_signature,\n-                            &item.vis,\n-                            Some(body),\n-                        ),\n-                        generics,\n-                        &fn_signature.decl,\n-                        item.span,\n-                        defaultness,\n-                        Some(&inner_attrs),\n-                    )\n-                }\n-                ast::ItemKind::Fn(_, ref fn_signature, ref generics, None) => {\n-                    let indent = self.block_indent;\n-                    let rewrite = self.rewrite_required_fn(\n-                        indent,\n-                        item.ident,\n-                        &fn_signature,\n-                        generics,\n-                        item.span,\n-                    );\n-\n-                    self.push_rewrite(item.span, rewrite);\n-                }\n-                ast::ItemKind::TyAlias(_, ref generics, ref generic_bounds, ref ty) => match ty {\n-                    Some(ty) => {\n-                        let rewrite = rewrite_type_alias(\n-                            item.ident,\n-                            Some(&*ty),\n+                ast::ItemKind::Fn(ref fn_kind) => {\n+                    let ast::FnKind(defaultness, ref fn_signature, ref generics, ref block) =\n+                        **fn_kind;\n+                    if let Some(ref body) = block {\n+                        let inner_attrs = inner_attributes(&item.attrs);\n+                        let fn_ctxt = match fn_signature.header.ext {\n+                            ast::Extern::None => visit::FnCtxt::Free,\n+                            _ => visit::FnCtxt::Foreign,\n+                        };\n+                        self.visit_fn(\n+                            visit::FnKind::Fn(\n+                                fn_ctxt,\n+                                item.ident,\n+                                &fn_signature,\n+                                &item.vis,\n+                                Some(body),\n+                            ),\n                             generics,\n-                            Some(generic_bounds),\n-                            &self.get_context(),\n-                            self.block_indent,\n-                            &item.vis,\n+                            &fn_signature.decl,\n                             item.span,\n-                        );\n-                        self.push_rewrite(item.span, rewrite);\n-                    }\n-                    None => {\n-                        let rewrite = rewrite_opaque_type(\n-                            &self.get_context(),\n-                            self.block_indent,\n+                            defaultness,\n+                            Some(&inner_attrs),\n+                        )\n+                    } else {\n+                        let indent = self.block_indent;\n+                        let rewrite = self.rewrite_required_fn(\n+                            indent,\n                             item.ident,\n-                            generic_bounds,\n+                            &fn_signature,\n                             generics,\n-                            &item.vis,\n                             item.span,\n                         );\n                         self.push_rewrite(item.span, rewrite);\n                     }\n-                },\n+                }\n+                ast::ItemKind::TyAlias(ref alias_kind) => {\n+                    let ast::TyAliasKind(_, ref generics, ref generic_bounds, ref ty) =\n+                        **alias_kind;\n+                    match ty {\n+                        Some(ty) => {\n+                            let rewrite = rewrite_type_alias(\n+                                item.ident,\n+                                Some(&*ty),\n+                                generics,\n+                                Some(generic_bounds),\n+                                &self.get_context(),\n+                                self.block_indent,\n+                                &item.vis,\n+                                item.span,\n+                            );\n+                            self.push_rewrite(item.span, rewrite);\n+                        }\n+                        None => {\n+                            let rewrite = rewrite_opaque_type(\n+                                &self.get_context(),\n+                                self.block_indent,\n+                                item.ident,\n+                                generic_bounds,\n+                                generics,\n+                                &item.vis,\n+                                item.span,\n+                            );\n+                            self.push_rewrite(item.span, rewrite);\n+                        }\n+                    }\n+                }\n                 ast::ItemKind::GlobalAsm(..) => {\n                     let snippet = Some(self.snippet(item.span).to_owned());\n                     self.push_rewrite(item.span, snippet);\n@@ -627,31 +634,37 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             return;\n         }\n \n+        // TODO(calebcartwright): consider enabling box_patterns feature gate\n         match ti.kind {\n             ast::AssocItemKind::Const(..) => self.visit_static(&StaticParts::from_trait_item(ti)),\n-            ast::AssocItemKind::Fn(_, ref sig, ref generics, None) => {\n-                let indent = self.block_indent;\n-                let rewrite = self.rewrite_required_fn(indent, ti.ident, sig, generics, ti.span);\n-                self.push_rewrite(ti.span, rewrite);\n-            }\n-            ast::AssocItemKind::Fn(defaultness, ref sig, ref generics, Some(ref body)) => {\n-                let inner_attrs = inner_attributes(&ti.attrs);\n-                let vis = ast::Visibility {\n-                    kind: ast::VisibilityKind::Inherited,\n-                    span: DUMMY_SP,\n-                    tokens: None,\n-                };\n-                let fn_ctxt = visit::FnCtxt::Assoc(visit::AssocCtxt::Trait);\n-                self.visit_fn(\n-                    visit::FnKind::Fn(fn_ctxt, ti.ident, sig, &vis, Some(body)),\n-                    generics,\n-                    &sig.decl,\n-                    ti.span,\n-                    defaultness,\n-                    Some(&inner_attrs),\n-                );\n+            ast::AssocItemKind::Fn(ref fn_kind) => {\n+                let ast::FnKind(defaultness, ref sig, ref generics, ref block) = **fn_kind;\n+                if let Some(ref body) = block {\n+                    let inner_attrs = inner_attributes(&ti.attrs);\n+                    let vis = ast::Visibility {\n+                        kind: ast::VisibilityKind::Inherited,\n+                        span: DUMMY_SP,\n+                        tokens: None,\n+                    };\n+                    let fn_ctxt = visit::FnCtxt::Assoc(visit::AssocCtxt::Trait);\n+                    self.visit_fn(\n+                        visit::FnKind::Fn(fn_ctxt, ti.ident, sig, &vis, Some(body)),\n+                        generics,\n+                        &sig.decl,\n+                        ti.span,\n+                        defaultness,\n+                        Some(&inner_attrs),\n+                    );\n+                } else {\n+                    let indent = self.block_indent;\n+                    let rewrite =\n+                        self.rewrite_required_fn(indent, ti.ident, sig, generics, ti.span);\n+                    self.push_rewrite(ti.span, rewrite);\n+                }\n             }\n-            ast::AssocItemKind::TyAlias(_, ref generics, ref generic_bounds, ref type_default) => {\n+            ast::AssocItemKind::TyAlias(ref ty_alias_kind) => {\n+                let ast::TyAliasKind(_, ref generics, ref generic_bounds, ref type_default) =\n+                    **ty_alias_kind;\n                 let rewrite = rewrite_type_alias(\n                     ti.ident,\n                     type_default.as_ref(),\n@@ -679,25 +692,29 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n \n         match ii.kind {\n-            ast::AssocItemKind::Fn(defaultness, ref sig, ref generics, Some(ref body)) => {\n-                let inner_attrs = inner_attributes(&ii.attrs);\n-                let fn_ctxt = visit::FnCtxt::Assoc(visit::AssocCtxt::Impl);\n-                self.visit_fn(\n-                    visit::FnKind::Fn(fn_ctxt, ii.ident, sig, &ii.vis, Some(body)),\n-                    generics,\n-                    &sig.decl,\n-                    ii.span,\n-                    defaultness,\n-                    Some(&inner_attrs),\n-                );\n-            }\n-            ast::AssocItemKind::Fn(_, ref sig, ref generics, None) => {\n-                let indent = self.block_indent;\n-                let rewrite = self.rewrite_required_fn(indent, ii.ident, sig, generics, ii.span);\n-                self.push_rewrite(ii.span, rewrite);\n+            ast::AssocItemKind::Fn(ref fn_kind) => {\n+                let ast::FnKind(defaultness, ref sig, ref generics, ref block) = **fn_kind;\n+                if let Some(ref body) = block {\n+                    let inner_attrs = inner_attributes(&ii.attrs);\n+                    let fn_ctxt = visit::FnCtxt::Assoc(visit::AssocCtxt::Impl);\n+                    self.visit_fn(\n+                        visit::FnKind::Fn(fn_ctxt, ii.ident, sig, &ii.vis, Some(body)),\n+                        generics,\n+                        &sig.decl,\n+                        ii.span,\n+                        defaultness,\n+                        Some(&inner_attrs),\n+                    );\n+                } else {\n+                    let indent = self.block_indent;\n+                    let rewrite =\n+                        self.rewrite_required_fn(indent, ii.ident, sig, generics, ii.span);\n+                    self.push_rewrite(ii.span, rewrite);\n+                }\n             }\n             ast::AssocItemKind::Const(..) => self.visit_static(&StaticParts::from_impl_item(ii)),\n-            ast::AssocItemKind::TyAlias(defaultness, ref generics, _, ref ty) => {\n+            ast::AssocItemKind::TyAlias(ref ty_alias_kind) => {\n+                let ast::TyAliasKind(defaultness, ref generics, _, ref ty) = **ty_alias_kind;\n                 let rewrite_associated = || {\n                     rewrite_associated_impl_type(\n                         ii.ident,"}]}