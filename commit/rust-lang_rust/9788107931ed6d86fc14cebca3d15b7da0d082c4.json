{"sha": "9788107931ed6d86fc14cebca3d15b7da0d082c4", "node_id": "C_kwDOAAsO6NoAKDk3ODgxMDc5MzFlZDZkODZmYzE0Y2ViY2EzZDE1YjdkYTBkMDgyYzQ", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-31T07:06:18Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:48:27Z"}, "message": "Handle future precedence issues in `explicit_auto_deref` + cleanup", "tree": {"sha": "3ece1311c3a64b81215add23165f9bcce9931d37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ece1311c3a64b81215add23165f9bcce9931d37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9788107931ed6d86fc14cebca3d15b7da0d082c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9788107931ed6d86fc14cebca3d15b7da0d082c4", "html_url": "https://github.com/rust-lang/rust/commit/9788107931ed6d86fc14cebca3d15b7da0d082c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9788107931ed6d86fc14cebca3d15b7da0d082c4/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d21b79be90553ef45f58b682b40432cac840b10", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d21b79be90553ef45f58b682b40432cac840b10", "html_url": "https://github.com/rust-lang/rust/commit/6d21b79be90553ef45f58b682b40432cac840b10"}], "stats": {"total": 155, "additions": 89, "deletions": 66}, "files": [{"sha": "e3529d1c9240754aade1e11e9915f99063f60d84", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 89, "deletions": 66, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9788107931ed6d86fc14cebca3d15b7da0d082c4/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9788107931ed6d86fc14cebca3d15b7da0d082c4/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=9788107931ed6d86fc14cebca3d15b7da0d082c4", "patch": "@@ -163,12 +163,12 @@ struct StateData {\n     /// Span of the top level expression\n     span: Span,\n     hir_id: HirId,\n+    position: Position,\n }\n \n struct DerefedBorrow {\n     count: usize,\n     msg: &'static str,\n-    position: Position,\n }\n \n enum State {\n@@ -182,8 +182,8 @@ enum State {\n     },\n     DerefedBorrow(DerefedBorrow),\n     ExplicitDeref {\n-        deref_span: Span,\n-        deref_hir_id: HirId,\n+        // Span and id of the top-level deref expression if the parent expression is a borrow.\n+        deref_span_id: Option<(Span, HirId)>,\n     },\n     ExplicitDerefField {\n         name: Symbol,\n@@ -258,12 +258,12 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         {\n                             self.state = Some((\n                                 State::ExplicitDerefField { name },\n-                                StateData { span: expr.span, hir_id: expr.hir_id },\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n                         } else if position.is_deref_stable() {\n                             self.state = Some((\n-                                State::ExplicitDeref { deref_span: expr.span, deref_hir_id: expr.hir_id },\n-                                StateData { span: expr.span, hir_id: expr.hir_id },\n+                                State::ExplicitDeref { deref_span_id: None },\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n                         }\n                     }\n@@ -284,6 +284,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             StateData {\n                                 span: expr.span,\n                                 hir_id: expr.hir_id,\n+                                position\n                             },\n                         ));\n                     },\n@@ -352,16 +353,16 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     // can't be removed without breaking the code. See earlier comment.\n                                     count: deref_count - required_refs,\n                                     msg,\n-                                    position,\n                                 }),\n-                                StateData { span: expr.span, hir_id: expr.hir_id },\n+                                StateData { span: expr.span, hir_id: expr.hir_id, position },\n                             ));\n                         } else if position.is_deref_stable() {\n                             self.state = Some((\n                                 State::Borrow,\n                                 StateData {\n                                     span: expr.span,\n                                     hir_id: expr.hir_id,\n+                                    position\n                                 },\n                             ));\n                         }\n@@ -403,32 +404,33 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                 ));\n             },\n             (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) => {\n-                let position = state.position;\n+                let position = data.position;\n                 report(cx, expr, State::DerefedBorrow(state), data);\n                 if position.is_deref_stable() {\n                     self.state = Some((\n                         State::Borrow,\n                         StateData {\n                             span: expr.span,\n                             hir_id: expr.hir_id,\n+                            position,\n                         },\n                     ));\n                 }\n             },\n             (Some((State::DerefedBorrow(state), data)), RefOp::Deref) => {\n-                let position = state.position;\n+                let position = data.position;\n                 report(cx, expr, State::DerefedBorrow(state), data);\n                 if let Position::FieldAccess(name) = position\n                     && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n                 {\n                     self.state = Some((\n                         State::ExplicitDerefField { name },\n-                        StateData { span: expr.span, hir_id: expr.hir_id },\n+                        StateData { span: expr.span, hir_id: expr.hir_id, position },\n                     ));\n                 } else if position.is_deref_stable() {\n                     self.state = Some((\n-                        State::ExplicitDeref { deref_span: expr.span, deref_hir_id: expr.hir_id },\n-                        StateData { span: expr.span, hir_id: expr.hir_id },\n+                        State::ExplicitDeref { deref_span_id: None },\n+                        StateData { span: expr.span, hir_id: expr.hir_id, position },\n                     ));\n                 }\n             },\n@@ -445,8 +447,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                 } else {\n                     self.state = Some((\n                         State::ExplicitDeref {\n-                            deref_span: expr.span,\n-                            deref_hir_id: expr.hir_id,\n+                            deref_span_id: Some((expr.span, expr.hir_id)),\n                         },\n                         data,\n                     ));\n@@ -464,8 +465,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n             ) => {\n                 self.state = Some((\n                     State::ExplicitDeref {\n-                        deref_span,\n-                        deref_hir_id,\n+                        deref_span_id: Some((deref_span, deref_hir_id)),\n                     },\n                     data,\n                 ));\n@@ -608,33 +608,38 @@ enum Position {\n     Postfix,\n     Deref,\n     /// Any other location which will trigger auto-deref to a specific time.\n-    DerefStable,\n+    DerefStable(i8),\n     /// Any other location which will trigger auto-reborrowing.\n-    ReborrowStable,\n-    Other,\n+    ReborrowStable(i8),\n+    Other(i8),\n }\n impl Position {\n     fn is_deref_stable(self) -> bool {\n-        matches!(self, Self::DerefStable)\n+        matches!(self, Self::DerefStable(_))\n     }\n \n     fn is_reborrow_stable(self) -> bool {\n-        matches!(self, Self::DerefStable | Self::ReborrowStable)\n+        matches!(self, Self::DerefStable(_) | Self::ReborrowStable(_))\n     }\n \n     fn can_auto_borrow(self) -> bool {\n         matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n     }\n \n     fn lint_explicit_deref(self) -> bool {\n-        matches!(self, Self::Other | Self::DerefStable | Self::ReborrowStable)\n+        matches!(self, Self::Other(_) | Self::DerefStable(_) | Self::ReborrowStable(_))\n     }\n \n-    fn needs_parens(self, precedence: i8) -> bool {\n-        matches!(\n-            self,\n-            Self::MethodReceiver | Self::MethodReceiverRefImpl | Self::Callee | Self::FieldAccess(_) | Self::Postfix\n-        ) && precedence < PREC_POSTFIX\n+    fn precedence(self) -> i8 {\n+        match self {\n+            Self::MethodReceiver\n+            | Self::MethodReceiverRefImpl\n+            | Self::Callee\n+            | Self::FieldAccess(_)\n+            | Self::Postfix => PREC_POSTFIX,\n+            Self::Deref => PREC_PREFIX,\n+            Self::DerefStable(p) | Self::ReborrowStable(p) | Self::Other(p) => p,\n+        }\n     }\n }\n \n@@ -644,6 +649,7 @@ impl Position {\n #[allow(clippy::too_many_lines)]\n fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &'tcx [Adjustment<'tcx>]) {\n     let mut adjustments = [].as_slice();\n+    let mut precedence = 0i8;\n     let ctxt = e.span.ctxt();\n     let position = walk_to_expr_usage(cx, e, &mut |parent, child_id| {\n         // LocalTableInContext returns the wrong lifetime, so go use `expr_adjustments` instead.\n@@ -652,7 +658,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n         }\n         match parent {\n             Node::Local(Local { ty: Some(ty), span, .. }) if span.ctxt() == ctxt => {\n-                Some(binding_ty_auto_deref_stability(ty))\n+                Some(binding_ty_auto_deref_stability(ty, precedence))\n             },\n             Node::Item(&Item {\n                 kind: ItemKind::Static(..) | ItemKind::Const(..),\n@@ -674,9 +680,9 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n             }) if span.ctxt() == ctxt => {\n                 let ty = cx.tcx.type_of(def_id);\n                 Some(if ty.is_ref() {\n-                    Position::Other\n+                    Position::DerefStable(precedence)\n                 } else {\n-                    Position::DerefStable\n+                    Position::Other(precedence)\n                 })\n             },\n \n@@ -700,11 +706,11 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n             }) if span.ctxt() == ctxt => {\n                 let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n                 Some(if !output.is_ref() {\n-                    Position::Other\n+                    Position::Other(precedence)\n                 } else if output.has_placeholders() || output.has_opaque_types() {\n-                    Position::ReborrowStable\n+                    Position::ReborrowStable(precedence)\n                 } else {\n-                    Position::DerefStable\n+                    Position::DerefStable(precedence)\n                 })\n             },\n \n@@ -716,11 +722,11 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         .skip_binder()\n                         .output();\n                     Some(if !output.is_ref() {\n-                        Position::Other\n+                        Position::Other(precedence)\n                     } else if output.has_placeholders() || output.has_opaque_types() {\n-                        Position::ReborrowStable\n+                        Position::ReborrowStable(precedence)\n                     } else {\n-                        Position::DerefStable\n+                        Position::DerefStable(precedence)\n                     })\n                 },\n                 ExprKind::Call(func, _) if func.hir_id == child_id => (child_id == e.hir_id).then(|| Position::Callee),\n@@ -732,8 +738,8 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     .map(|(hir_ty, ty)| match hir_ty {\n                         // Type inference for closures can depend on how they're called. Only go by the explicit\n                         // types here.\n-                        Some(ty) => binding_ty_auto_deref_stability(ty),\n-                        None => param_auto_deref_stability(ty.skip_binder()),\n+                        Some(ty) => binding_ty_auto_deref_stability(ty, precedence),\n+                        None => param_auto_deref_stability(ty.skip_binder(), precedence),\n                     }),\n                 ExprKind::MethodCall(_, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n@@ -745,7 +751,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                             // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n                             //   priority.\n                             if e.hir_id != child_id {\n-                                Position::ReborrowStable\n+                                Position::ReborrowStable(precedence)\n                             } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n                                 && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n                                 && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n@@ -769,7 +775,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                 Position::MethodReceiver\n                             }\n                         } else {\n-                            param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i])\n+                            param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i], precedence)\n                         }\n                     })\n                 },\n@@ -780,7 +786,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         .find(|f| f.expr.hir_id == child_id)\n                         .zip(variant)\n                         .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n-                        .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did)))\n+                        .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did), precedence))\n                 },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n@@ -790,12 +796,16 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 {\n                     Some(Position::Postfix)\n                 },\n+                _ if child_id == e.hir_id => {\n+                    precedence = parent.precedence().order();\n+                    None\n+                },\n                 _ => None,\n             },\n             _ => None,\n         }\n     })\n-    .unwrap_or(Position::Other);\n+    .unwrap_or(Position::Other(precedence));\n     (position, adjustments)\n }\n \n@@ -808,9 +818,9 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n //\n // Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n // switching to auto-dereferencing.\n-fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> Position {\n+fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position {\n     let TyKind::Rptr(_, ty) = &ty.kind else {\n-        return Position::Other;\n+        return Position::Other(precedence);\n     };\n     let mut ty = ty;\n \n@@ -836,9 +846,9 @@ fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> Position {\n                         _ => false,\n                     })\n                 {\n-                    Position::ReborrowStable\n+                    Position::ReborrowStable(precedence)\n                 } else {\n-                    Position::DerefStable\n+                    Position::DerefStable(precedence)\n                 }\n             },\n             TyKind::Slice(_)\n@@ -848,8 +858,11 @@ fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> Position {\n             | TyKind::Tup(_)\n             | TyKind::Ptr(_)\n             | TyKind::TraitObject(..)\n-            | TyKind::Path(_) => Position::DerefStable,\n-            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::Err => Position::ReborrowStable,\n+            | TyKind::Path(_) => Position::DerefStable(precedence),\n+            TyKind::OpaqueDef(..)\n+            | TyKind::Infer\n+            | TyKind::Typeof(..)\n+            | TyKind::Err => Position::ReborrowStable(precedence),\n         };\n     }\n }\n@@ -892,9 +905,9 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n }\n \n // Checks whether a type is stable when switching to auto dereferencing,\n-fn param_auto_deref_stability(ty: Ty<'_>) -> Position {\n+fn param_auto_deref_stability(ty: Ty<'_>, precedence: i8) -> Position {\n     let ty::Ref(_, mut ty, _) = *ty.kind() else {\n-        return Position::Other;\n+        return Position::Other(precedence);\n     };\n \n     loop {\n@@ -920,16 +933,18 @@ fn param_auto_deref_stability(ty: Ty<'_>) -> Position {\n             | ty::GeneratorWitness(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => Position::DerefStable,\n+            | ty::Projection(_) => Position::DerefStable(precedence),\n             ty::Infer(_)\n             | ty::Error(_)\n             | ty::Param(_)\n             | ty::Bound(..)\n             | ty::Opaque(..)\n             | ty::Placeholder(_)\n-            | ty::Dynamic(..) => Position::ReborrowStable,\n-            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => Position::ReborrowStable,\n-            ty::Adt(..) => Position::DerefStable,\n+            | ty::Dynamic(..) => Position::ReborrowStable(precedence),\n+            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => {\n+                Position::ReborrowStable(precedence)\n+            },\n+            ty::Adt(..) => Position::DerefStable(precedence),\n         };\n     }\n }\n@@ -995,24 +1010,26 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n         },\n         State::DerefedBorrow(state) => {\n             let mut app = Applicability::MachineApplicable;\n-            let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n+            let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n             span_lint_hir_and_then(cx, NEEDLESS_BORROW, data.hir_id, data.span, state.msg, |diag| {\n-                let sugg = if state.position.needs_parens(expr.precedence().order()) && !has_enclosing_paren(&snip) {\n+                let sugg = if !snip_is_macro\n+                    && expr.precedence().order() < data.position.precedence()\n+                    && !has_enclosing_paren(&snip)\n+                {\n                     format!(\"({})\", snip)\n                 } else {\n                     snip.into()\n                 };\n                 diag.span_suggestion(data.span, \"change this to\", sugg, app);\n             });\n         },\n-        State::ExplicitDeref {\n-            deref_span,\n-            deref_hir_id,\n-        } => {\n-            let (span, hir_id) = if cx.typeck_results().expr_ty(expr).is_ref() {\n-                (data.span, data.hir_id)\n+        State::ExplicitDeref { deref_span_id } => {\n+            let (span, hir_id, precedence) = if let Some((span, hir_id)) = deref_span_id\n+                && !cx.typeck_results().expr_ty(expr).is_ref()\n+            {\n+                (span, hir_id, PREC_PREFIX)\n             } else {\n-                (deref_span, deref_hir_id)\n+                (data.span, data.hir_id, data.position.precedence())\n             };\n             span_lint_hir_and_then(\n                 cx,\n@@ -1022,8 +1039,14 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n                 \"deref which would be done by auto-deref\",\n                 |diag| {\n                     let mut app = Applicability::MachineApplicable;\n-                    let snip = snippet_with_context(cx, expr.span, span.ctxt(), \"..\", &mut app).0;\n-                    diag.span_suggestion(span, \"try this\", snip.into_owned(), app);\n+                    let (snip, snip_is_macro) = snippet_with_context(cx, expr.span, span.ctxt(), \"..\", &mut app);\n+                    let sugg =\n+                        if !snip_is_macro && expr.precedence().order() < precedence && !has_enclosing_paren(&snip) {\n+                            format!(\"({})\", snip)\n+                        } else {\n+                            snip.into()\n+                        };\n+                    diag.span_suggestion(span, \"try this\", sugg, app);\n                 },\n             );\n         },"}]}