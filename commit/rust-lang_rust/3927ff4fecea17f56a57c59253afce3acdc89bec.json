{"sha": "3927ff4fecea17f56a57c59253afce3acdc89bec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MjdmZjRmZWNlYTE3ZjU2YTU3YzU5MjUzYWZjZTNhY2RjODliZWM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-10T01:15:11Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-10T07:54:49Z"}, "message": "Make the remaining functions in `hir::lowering` methods of `LoweringContext`", "tree": {"sha": "78dc346654d48bbe1e991f26bb887432378a8b76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78dc346654d48bbe1e991f26bb887432378a8b76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3927ff4fecea17f56a57c59253afce3acdc89bec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3927ff4fecea17f56a57c59253afce3acdc89bec", "html_url": "https://github.com/rust-lang/rust/commit/3927ff4fecea17f56a57c59253afce3acdc89bec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3927ff4fecea17f56a57c59253afce3acdc89bec/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "946efcd4cae78640222d855c6c8aafafc0f844ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/946efcd4cae78640222d855c6c8aafafc0f844ef", "html_url": "https://github.com/rust-lang/rust/commit/946efcd4cae78640222d855c6c8aafafc0f844ef"}], "stats": {"total": 794, "additions": 383, "deletions": 411}, "files": [{"sha": "0c7123a570e1449b8ff2839eb978661824f22cdb", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 383, "deletions": 411, "changes": 794, "blob_url": "https://github.com/rust-lang/rust/blob/3927ff4fecea17f56a57c59253afce3acdc89bec/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3927ff4fecea17f56a57c59253afce3acdc89bec/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3927ff4fecea17f56a57c59253afce3acdc89bec", "patch": "@@ -965,87 +965,82 @@ impl<'a> LoweringContext<'a> {\n                     let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n                     let make_call = |this: &mut LoweringContext, p, args| {\n-                        let path = core_path(this, e.span, p);\n-                        let path = expr_path(this, path, None);\n-                        expr_call(this, e.span, path, args, None)\n+                        let path = this.core_path(e.span, p);\n+                        let path = this.expr_path(path, None);\n+                        this.expr_call(e.span, path, args, None)\n                     };\n \n                     let mk_stmt_let = |this: &mut LoweringContext, bind, expr| {\n-                        stmt_let(this, e.span, false, bind, expr, None)\n+                        this.stmt_let(e.span, false, bind, expr, None)\n                     };\n \n                     let mk_stmt_let_mut = |this: &mut LoweringContext, bind, expr| {\n-                        stmt_let(this, e.span, true, bind, expr, None)\n+                        this.stmt_let(e.span, true, bind, expr, None)\n                     };\n \n                     // let placer = <placer_expr> ;\n                     let (s1, placer_binding) = {\n-                        let placer_expr = signal_block_expr(self,\n-                                                            hir_vec![],\n-                                                            placer_expr,\n-                                                            e.span,\n-                                                            hir::PopUnstableBlock,\n-                                                            None);\n+                        let placer_expr = self.signal_block_expr(hir_vec![],\n+                                                                 placer_expr,\n+                                                                 e.span,\n+                                                                 hir::PopUnstableBlock,\n+                                                                 None);\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n                     // let mut place = Placer::make_place(placer);\n                     let (s2, place_binding) = {\n-                        let placer = expr_ident(self, e.span, placer_ident, None, placer_binding);\n+                        let placer = self.expr_ident(e.span, placer_ident, None, placer_binding);\n                         let call = make_call(self, &make_place, hir_vec![placer]);\n                         mk_stmt_let_mut(self, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let (s3, p_ptr_binding) = {\n-                        let agent = expr_ident(self, e.span, place_ident, None, place_binding);\n-                        let args = hir_vec![expr_mut_addr_of(self, e.span, agent, None)];\n+                        let agent = self.expr_ident(e.span, place_ident, None, place_binding);\n+                        let args = hir_vec![self.expr_mut_addr_of(e.span, agent, None)];\n                         let call = make_call(self, &place_pointer, args);\n                         mk_stmt_let(self, p_ptr_ident, call)\n                     };\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n-                        let value_expr = signal_block_expr(self,\n-                                                           hir_vec![],\n-                                                           value_expr,\n-                                                           e.span,\n-                                                           hir::PopUnstableBlock,\n-                                                           None);\n-                        signal_block_expr(self,\n-                                          hir_vec![],\n-                                          value_expr,\n-                                          e.span,\n-                                          hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n+                        let value_expr = self.signal_block_expr(hir_vec![],\n+                                                                value_expr,\n+                                                                e.span,\n+                                                                hir::PopUnstableBlock,\n+                                                                None);\n+                        self.signal_block_expr(hir_vec![],\n+                                               value_expr,\n+                                               e.span,\n+                                               hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     // push_unsafe!({\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n                     let expr = {\n-                        let ptr = expr_ident(self, e.span, p_ptr_ident, None, p_ptr_binding);\n+                        let ptr = self.expr_ident(e.span, p_ptr_ident, None, p_ptr_binding);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n                                 make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                                 self.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                        let place = expr_ident(self, e.span, place_ident, None, place_binding);\n+                        let place = self.expr_ident(e.span, place_ident, None, place_binding);\n                         let call = make_call(self, &inplace_finalize, hir_vec![place]);\n-                        signal_block_expr(self,\n-                                          hir_vec![call_move_val_init],\n-                                          call,\n-                                          e.span,\n-                                          hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n+                        self.signal_block_expr(hir_vec![call_move_val_init],\n+                                               call,\n+                                               e.span,\n+                                               hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n-                    return signal_block_expr(self,\n-                                             hir_vec![s1, s2, s3],\n-                                             expr,\n-                                             e.span,\n-                                             hir::PushUnstableBlock,\n-                                             e.attrs.clone());\n+                    return self.signal_block_expr(hir_vec![s1, s2, s3],\n+                                                  expr,\n+                                                  e.span,\n+                                                  hir::PushUnstableBlock,\n+                                                  e.attrs.clone());\n                 }\n \n                 ExprKind::Vec(ref exprs) => {\n@@ -1110,7 +1105,7 @@ impl<'a> LoweringContext<'a> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                expr_block(self, blk, None)\n+                                self.expr_block(blk, None)\n                             }\n                             _ => self.lower_expr(els),\n                         }\n@@ -1162,47 +1157,42 @@ impl<'a> LoweringContext<'a> {\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n                                    fields: &[(&str, &P<Expr>)]) -> P<hir::Expr> {\n-                        let strs = std_path(this, &iter::once(&\"ops\")\n+                        let strs = this.std_path(&iter::once(&\"ops\")\n                                                         .chain(path)\n                                                         .map(|s| *s)\n                                                         .collect::<Vec<_>>());\n \n-                        let structpath = path_global(ast_expr.span, strs);\n+                        let structpath = this.path_global(ast_expr.span, strs);\n \n                         let hir_expr = if fields.len() == 0 {\n-                            expr_path(this,\n-                                      structpath,\n-                                      ast_expr.attrs.clone())\n+                            this.expr_path(structpath, ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n                                 let expr = this.lower_expr(&e);\n-                                let signal_block = signal_block_expr(this,\n-                                                                     hir_vec![],\n-                                                                     expr,\n-                                                                     e.span,\n-                                                                     hir::PopUnstableBlock,\n-                                                                     None);\n-                                field(token::intern(s), signal_block, ast_expr.span)\n+                                let signal_block = this.signal_block_expr(hir_vec![],\n+                                                                          expr,\n+                                                                          e.span,\n+                                                                          hir::PopUnstableBlock,\n+                                                                          None);\n+                                this.field(token::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n-                            expr_struct(this, ast_expr.span, structpath, fields, None, attrs)\n+                            this.expr_struct(ast_expr.span, structpath, fields, None, attrs)\n                         };\n \n-                        signal_block_expr(this,\n-                                          hir_vec![],\n-                                          hir_expr,\n-                                          ast_expr.span,\n-                                          hir::PushUnstableBlock,\n-                                          None)\n+                        this.signal_block_expr(hir_vec![],\n+                                               hir_expr,\n+                                               ast_expr.span,\n+                                               hir::PushUnstableBlock,\n+                                               None)\n                     }\n \n                     use syntax::ast::RangeLimits::*;\n \n                     return match (e1, e2, lims) {\n                         (&None,         &None,         HalfOpen) =>\n-                            make_struct(self, e, &[\"RangeFull\"],\n-                                                 &[]),\n+                            make_struct(self, e, &[\"RangeFull\"], &[]),\n \n                         (&Some(ref e1), &None,         HalfOpen) =>\n                             make_struct(self, e, &[\"RangeFrom\"],\n@@ -1303,8 +1293,9 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = expr_block(self, body, None);\n-                        arm(hir_vec![self.lower_pat(pat)], body_expr)\n+                        let body_expr = self.expr_block(body, None);\n+                        let pat = self.lower_pat(pat);\n+                        self.arm(hir_vec![pat], body_expr)\n                     };\n \n                     // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n@@ -1317,12 +1308,12 @@ impl<'a> LoweringContext<'a> {\n                                     match els.node {\n                                         // else if\n                                         hir::ExprIf(cond, then, else_opt) => {\n-                                            let pat_under = pat_wild(self, e.span);\n+                                            let pat_under = self.pat_wild(e.span);\n                                             arms.push(hir::Arm {\n                                                 attrs: hir_vec![],\n                                                 pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: expr_block(self, then, None),\n+                                                body: self.expr_block(then, None),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1351,11 +1342,10 @@ impl<'a> LoweringContext<'a> {\n \n                     // `_ => [<else_opt> | ()]`\n                     let else_arm = {\n-                        let pat_under = pat_wild(self, e.span);\n+                        let pat_under = self.pat_wild(e.span);\n                         let else_expr =\n-                            else_opt.unwrap_or_else(\n-                                || expr_tuple(self, e.span, hir_vec![], None));\n-                        arm(hir_vec![pat_under], else_expr)\n+                            else_opt.unwrap_or_else(|| self.expr_tuple(e.span, hir_vec![], None));\n+                        self.arm(hir_vec![pat_under], else_expr)\n                     };\n \n                     let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n@@ -1365,14 +1355,13 @@ impl<'a> LoweringContext<'a> {\n \n                     let sub_expr = self.lower_expr(sub_expr);\n                     // add attributes to the outer returned expr node\n-                    return expr(self,\n-                                e.span,\n-                                hir::ExprMatch(sub_expr,\n-                                               arms.into(),\n-                                               hir::MatchSource::IfLetDesugar {\n-                                                   contains_else_clause: contains_else_clause,\n-                                               }),\n-                                e.attrs.clone());\n+                    return self.expr(e.span,\n+                                     hir::ExprMatch(sub_expr,\n+                                                    arms.into(),\n+                                                    hir::MatchSource::IfLetDesugar {\n+                                                        contains_else_clause: contains_else_clause,\n+                                                    }),\n+                                     e.attrs.clone());\n                 }\n \n                 // Desugar ExprWhileLet\n@@ -1390,29 +1379,29 @@ impl<'a> LoweringContext<'a> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = self.lower_block(body);\n-                        let body_expr = expr_block(self, body, None);\n-                        arm(hir_vec![self.lower_pat(pat)], body_expr)\n+                        let body_expr = self.expr_block(body, None);\n+                        let pat = self.lower_pat(pat);\n+                        self.arm(hir_vec![pat], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n-                        let pat_under = pat_wild(self, e.span);\n-                        let break_expr = expr_break(self, e.span, None);\n-                        arm(hir_vec![pat_under], break_expr)\n+                        let pat_under = self.pat_wild(e.span);\n+                        let break_expr = self.expr_break(e.span, None);\n+                        self.arm(hir_vec![pat_under], break_expr)\n                     };\n \n                     // `match <sub_expr> { ... }`\n                     let arms = hir_vec![pat_arm, break_arm];\n                     let sub_expr = self.lower_expr(sub_expr);\n-                    let match_expr = expr(self,\n-                                          e.span,\n-                                          hir::ExprMatch(sub_expr,\n-                                                         arms,\n-                                                         hir::MatchSource::WhileLetDesugar),\n-                                          None);\n+                    let match_expr = self.expr(e.span,\n+                                               hir::ExprMatch(sub_expr,\n+                                                              arms,\n+                                                              hir::MatchSource::WhileLetDesugar),\n+                                               None);\n \n                     // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(self, match_expr);\n+                    let loop_block = self.block_expr(match_expr);\n                     let loop_expr = hir::ExprLoop(loop_block,\n                                                   opt_ident.map(|ident| self.lower_ident(ident)));\n                     // add attributes to the outer returned expr node\n@@ -1455,84 +1444,81 @@ impl<'a> LoweringContext<'a> {\n                             attrs: None,\n                         });\n                         let pat = self.lower_pat(pat);\n-                        let some_pat = pat_some(self, e.span, pat);\n+                        let some_pat = self.pat_some(e.span, pat);\n \n-                        arm(hir_vec![some_pat], body_expr)\n+                        self.arm(hir_vec![some_pat], body_expr)\n                     };\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = expr_break(self, e.span, None);\n-\n-                        arm(hir_vec![pat_none(self, e.span)], break_expr)\n+                        let break_expr = self.expr_break(e.span, None);\n+                        let pat = self.pat_none(e.span);\n+                        self.arm(hir_vec![pat], break_expr)\n                     };\n \n                     // `mut iter`\n-                    let iter_pat = pat_ident_binding_mode(self, e.span, iter,\n-                                                          hir::BindByValue(hir::MutMutable));\n+                    let iter_pat = self.pat_ident_binding_mode(e.span, iter,\n+                                                               hir::BindByValue(hir::MutMutable));\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n                         let next_path = {\n-                            let strs = std_path(self, &[\"iter\", \"Iterator\", \"next\"]);\n+                            let strs = self.std_path(&[\"iter\", \"Iterator\", \"next\"]);\n \n-                            path_global(e.span, strs)\n+                            self.path_global(e.span, strs)\n                         };\n-                        let iter = expr_ident(self, e.span, iter, None, iter_pat.id);\n-                        let ref_mut_iter = expr_mut_addr_of(self, e.span, iter, None);\n-                        let next_path = expr_path(self, next_path, None);\n-                        let next_expr = expr_call(self,\n-                                                  e.span,\n-                                                  next_path,\n-                                                  hir_vec![ref_mut_iter],\n-                                                  None);\n+                        let iter = self.expr_ident(e.span, iter, None, iter_pat.id);\n+                        let ref_mut_iter = self.expr_mut_addr_of(e.span, iter, None);\n+                        let next_path = self.expr_path(next_path, None);\n+                        let next_expr = self.expr_call(e.span,\n+                                                       next_path,\n+                                                       hir_vec![ref_mut_iter],\n+                                                       None);\n                         let arms = hir_vec![pat_arm, break_arm];\n \n-                        expr(self,\n-                             e.span,\n-                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n-                             None)\n+                        self.expr(e.span,\n+                                  hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n+                                  None)\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n-                    let loop_block = block_expr(self, match_expr);\n+                    let loop_block = self.block_expr(match_expr);\n                     let loop_expr = hir::ExprLoop(loop_block,\n                                                   opt_ident.map(|ident| self.lower_ident(ident)));\n                     let loop_expr =\n                         P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n \n                     // `mut iter => { ... }`\n-                    let iter_arm = arm(hir_vec![iter_pat], loop_expr);\n+                    let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                     let into_iter_expr = {\n                         let into_iter_path = {\n-                            let strs = std_path(self, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+                            let strs = self.std_path(&[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n-                            path_global(e.span, strs)\n+                            self.path_global(e.span, strs)\n                         };\n \n-                        let into_iter = expr_path(self, into_iter_path, None);\n-                        expr_call(self, e.span, into_iter, hir_vec![head], None)\n+                        let into_iter = self.expr_path(into_iter_path, None);\n+                        self.expr_call(e.span, into_iter, hir_vec![head], None)\n                     };\n \n-                    let match_expr = expr_match(self,\n-                                                e.span,\n-                                                into_iter_expr,\n-                                                hir_vec![iter_arm],\n-                                                hir::MatchSource::ForLoopDesugar,\n-                                                None);\n+                    let match_expr = self.expr_match(e.span,\n+                                                     into_iter_expr,\n+                                                     hir_vec![iter_arm],\n+                                                     hir::MatchSource::ForLoopDesugar,\n+                                                     None);\n \n                     // `{ let _result = ...; _result }`\n                     // underscore prevents an unused_variables lint if the head diverges\n                     let result_ident = self.str_to_ident(\"_result\");\n                     let (let_stmt, let_stmt_binding) =\n-                        stmt_let(self, e.span, false, result_ident, match_expr, None);\n+                        self.stmt_let(e.span, false, result_ident, match_expr, None);\n \n-                    let result = expr_ident(self, e.span, result_ident, None, let_stmt_binding);\n-                    let block = block_all(self, e.span, hir_vec![let_stmt], Some(result));\n+                    let result = self.expr_ident(e.span, result_ident, None, let_stmt_binding);\n+                    let block = self.block_all(e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n-                    return expr_block(self, block, e.attrs.clone());\n+                    return self.expr_block(block, e.attrs.clone());\n                 }\n \n                 // Desugar ExprKind::Try\n@@ -1555,40 +1541,40 @@ impl<'a> LoweringContext<'a> {\n                     // Ok(val) => val\n                     let ok_arm = {\n                         let val_ident = self.str_to_ident(\"val\");\n-                        let val_pat = pat_ident(self, e.span, val_ident);\n-                        let val_expr = expr_ident(self, e.span, val_ident, None, val_pat.id);\n-                        let ok_pat = pat_ok(self, e.span, val_pat);\n+                        let val_pat = self.pat_ident(e.span, val_ident);\n+                        let val_expr = self.expr_ident(e.span, val_ident, None, val_pat.id);\n+                        let ok_pat = self.pat_ok(e.span, val_pat);\n \n-                        arm(hir_vec![ok_pat], val_expr)\n+                        self.arm(hir_vec![ok_pat], val_expr)\n                     };\n \n                     // Err(err) => return Err(From::from(err))\n                     let err_arm = {\n                         let err_ident = self.str_to_ident(\"err\");\n-                        let err_local = pat_ident(self, e.span, err_ident);\n+                        let err_local = self.pat_ident(e.span, err_ident);\n                         let from_expr = {\n-                            let path = std_path(self, &[\"convert\", \"From\", \"from\"]);\n-                            let path = path_global(e.span, path);\n-                            let from = expr_path(self, path, None);\n-                            let err_expr = expr_ident(self, e.span, err_ident, None, err_local.id);\n+                            let path = self.std_path(&[\"convert\", \"From\", \"from\"]);\n+                            let path = self.path_global(e.span, path);\n+                            let from = self.expr_path(path, None);\n+                            let err_expr = self.expr_ident(e.span, err_ident, None, err_local.id);\n \n-                            expr_call(self, e.span, from, hir_vec![err_expr], None)\n+                            self.expr_call(e.span, from, hir_vec![err_expr], None)\n                         };\n                         let err_expr = {\n-                            let path = std_path(self, &[\"result\", \"Result\", \"Err\"]);\n-                            let path = path_global(e.span, path);\n-                            let err_ctor = expr_path(self, path, None);\n-                            expr_call(self, e.span, err_ctor, hir_vec![from_expr], None)\n+                            let path = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n+                            let path = self.path_global(e.span, path);\n+                            let err_ctor = self.expr_path(path, None);\n+                            self.expr_call(e.span, err_ctor, hir_vec![from_expr], None)\n                         };\n-                        let err_pat = pat_err(self, e.span, err_local);\n-                        let ret_expr = expr(self, e.span,\n-                                            hir::Expr_::ExprRet(Some(err_expr)), None);\n+                        let err_pat = self.pat_err(e.span, err_local);\n+                        let ret_expr = self.expr(e.span,\n+                                                 hir::Expr_::ExprRet(Some(err_expr)), None);\n \n-                        arm(hir_vec![err_pat], ret_expr)\n+                        self.arm(hir_vec![err_pat], ret_expr)\n                     };\n \n-                    return expr_match(self, e.span, sub_expr, hir_vec![err_arm, ok_arm],\n-                                      hir::MatchSource::TryDesugar, None);\n+                    return self.expr_match(e.span, sub_expr, hir_vec![err_arm, ok_arm],\n+                                           hir::MatchSource::TryDesugar, None);\n                 }\n \n                 ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n@@ -1680,310 +1666,296 @@ impl<'a> LoweringContext<'a> {\n             TraitBoundModifier::Maybe => hir::TraitBoundModifier::Maybe,\n         }\n     }\n-}\n \n-// Helper methods for building HIR.\n+    // Helper methods for building HIR.\n \n-fn arm(pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n-    hir::Arm {\n-        attrs: hir_vec![],\n-        pats: pats,\n-        guard: None,\n-        body: expr,\n+    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+        hir::Arm {\n+            attrs: hir_vec![],\n+            pats: pats,\n+            guard: None,\n+            body: expr,\n+        }\n     }\n-}\n \n-fn field(name: Name, expr: P<hir::Expr>, span: Span) -> hir::Field {\n-    hir::Field {\n-        name: Spanned {\n-            node: name,\n+    fn field(&mut self, name: Name, expr: P<hir::Expr>, span: Span) -> hir::Field {\n+        hir::Field {\n+            name: Spanned {\n+                node: name,\n+                span: span,\n+            },\n             span: span,\n-        },\n-        span: span,\n-        expr: expr,\n+            expr: expr,\n+        }\n     }\n-}\n \n-fn expr_break(lctx: &mut LoweringContext, span: Span,\n-              attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprBreak(None), attrs)\n-}\n+    fn expr_break(&mut self, span: Span, attrs: ThinAttributes) -> P<hir::Expr> {\n+        self.expr(span, hir::ExprBreak(None), attrs)\n+    }\n \n-fn expr_call(lctx: &mut LoweringContext,\n-             span: Span,\n-             e: P<hir::Expr>,\n-             args: hir::HirVec<P<hir::Expr>>,\n-             attrs: ThinAttributes)\n-             -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprCall(e, args), attrs)\n-}\n+    fn expr_call(&mut self,\n+                 span: Span,\n+                 e: P<hir::Expr>,\n+                 args: hir::HirVec<P<hir::Expr>>,\n+                 attrs: ThinAttributes)\n+                 -> P<hir::Expr> {\n+        self.expr(span, hir::ExprCall(e, args), attrs)\n+    }\n \n-fn expr_ident(lctx: &mut LoweringContext, span: Span, id: hir::Ident,\n-              attrs: ThinAttributes, binding: NodeId) -> P<hir::Expr> {\n-    let expr = expr(lctx, span, hir::ExprPath(None, path_ident(span, id)), attrs);\n+    fn expr_ident(&mut self, span: Span, id: hir::Ident, attrs: ThinAttributes, binding: NodeId)\n+                  -> P<hir::Expr> {\n+        let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n+        let expr = self.expr(span, expr_path, attrs);\n \n-    let def = lctx.resolver.definitions().map(|defs| {\n-        Def::Local(defs.local_def_id(binding), binding)\n-    }).unwrap_or(Def::Err);\n-    lctx.resolver.record_resolution(expr.id, def);\n+        let def = self.resolver.definitions().map(|defs| {\n+            Def::Local(defs.local_def_id(binding), binding)\n+        }).unwrap_or(Def::Err);\n+        self.resolver.record_resolution(expr.id, def);\n \n-    expr\n-}\n+        expr\n+    }\n \n-fn expr_mut_addr_of(lctx: &mut LoweringContext, span: Span, e: P<hir::Expr>,\n-                    attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprAddrOf(hir::MutMutable, e), attrs)\n-}\n+    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>, attrs: ThinAttributes)\n+                        -> P<hir::Expr> {\n+        self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), attrs)\n+    }\n \n-fn expr_path(lctx: &mut LoweringContext, path: hir::Path,\n-             attrs: ThinAttributes) -> P<hir::Expr> {\n-    let def = lctx.resolver.resolve_generated_global_path(&path, true);\n-    let expr = expr(lctx, path.span, hir::ExprPath(None, path), attrs);\n-    lctx.resolver.record_resolution(expr.id, def);\n-    expr\n-}\n+    fn expr_path(&mut self, path: hir::Path, attrs: ThinAttributes) -> P<hir::Expr> {\n+        let def = self.resolver.resolve_generated_global_path(&path, true);\n+        let expr = self.expr(path.span, hir::ExprPath(None, path), attrs);\n+        self.resolver.record_resolution(expr.id, def);\n+        expr\n+    }\n \n-fn expr_match(lctx: &mut LoweringContext,\n-              span: Span,\n-              arg: P<hir::Expr>,\n-              arms: hir::HirVec<hir::Arm>,\n-              source: hir::MatchSource,\n-              attrs: ThinAttributes)\n-              -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprMatch(arg, arms, source), attrs)\n-}\n+    fn expr_match(&mut self,\n+                  span: Span,\n+                  arg: P<hir::Expr>,\n+                  arms: hir::HirVec<hir::Arm>,\n+                  source: hir::MatchSource,\n+                  attrs: ThinAttributes)\n+                  -> P<hir::Expr> {\n+        self.expr(span, hir::ExprMatch(arg, arms, source), attrs)\n+    }\n \n-fn expr_block(lctx: &mut LoweringContext, b: P<hir::Block>,\n-              attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, b.span, hir::ExprBlock(b), attrs)\n-}\n+    fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinAttributes) -> P<hir::Expr> {\n+        self.expr(b.span, hir::ExprBlock(b), attrs)\n+    }\n \n-fn expr_tuple(lctx: &mut LoweringContext, sp: Span, exprs: hir::HirVec<P<hir::Expr>>,\n-              attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, sp, hir::ExprTup(exprs), attrs)\n-}\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<P<hir::Expr>>, attrs: ThinAttributes)\n+                  -> P<hir::Expr> {\n+        self.expr(sp, hir::ExprTup(exprs), attrs)\n+    }\n \n-fn expr_struct(lctx: &mut LoweringContext,\n-               sp: Span,\n-               path: hir::Path,\n-               fields: hir::HirVec<hir::Field>,\n-               e: Option<P<hir::Expr>>,\n-               attrs: ThinAttributes) -> P<hir::Expr> {\n-    let def = lctx.resolver.resolve_generated_global_path(&path, false);\n-    let expr = expr(lctx, sp, hir::ExprStruct(path, fields, e), attrs);\n-    lctx.resolver.record_resolution(expr.id, def);\n-    expr\n+    fn expr_struct(&mut self,\n+                   sp: Span,\n+                   path: hir::Path,\n+                   fields: hir::HirVec<hir::Field>,\n+                   e: Option<P<hir::Expr>>,\n+                   attrs: ThinAttributes) -> P<hir::Expr> {\n+        let def = self.resolver.resolve_generated_global_path(&path, false);\n+        let expr = self.expr(sp, hir::ExprStruct(path, fields, e), attrs);\n+        self.resolver.record_resolution(expr.id, def);\n+        expr\n+    }\n \n-}\n+    fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinAttributes) -> P<hir::Expr> {\n+        P(hir::Expr {\n+            id: self.next_id(),\n+            node: node,\n+            span: span,\n+            attrs: attrs,\n+        })\n+    }\n \n-fn expr(lctx: &mut LoweringContext, span: Span, node: hir::Expr_,\n-        attrs: ThinAttributes) -> P<hir::Expr> {\n-    P(hir::Expr {\n-        id: lctx.next_id(),\n-        node: node,\n-        span: span,\n-        attrs: attrs,\n-    })\n-}\n+    fn stmt_let(&mut self,\n+                sp: Span,\n+                mutbl: bool,\n+                ident: hir::Ident,\n+                ex: P<hir::Expr>,\n+                attrs: ThinAttributes)\n+                -> (hir::Stmt, NodeId) {\n+        let pat = if mutbl {\n+            self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n+        } else {\n+            self.pat_ident(sp, ident)\n+        };\n+        let pat_id = pat.id;\n+        let local = P(hir::Local {\n+            pat: pat,\n+            ty: None,\n+            init: Some(ex),\n+            id: self.next_id(),\n+            span: sp,\n+            attrs: attrs,\n+        });\n+        let decl = respan(sp, hir::DeclLocal(local));\n+        (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n+    }\n \n-fn stmt_let(lctx: &mut LoweringContext,\n-            sp: Span,\n-            mutbl: bool,\n-            ident: hir::Ident,\n-            ex: P<hir::Expr>,\n-            attrs: ThinAttributes)\n-            -> (hir::Stmt, NodeId) {\n-    let pat = if mutbl {\n-        pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n-    } else {\n-        pat_ident(lctx, sp, ident)\n-    };\n-    let pat_id = pat.id;\n-    let local = P(hir::Local {\n-        pat: pat,\n-        ty: None,\n-        init: Some(ex),\n-        id: lctx.next_id(),\n-        span: sp,\n-        attrs: attrs,\n-    });\n-    let decl = respan(sp, hir::DeclLocal(local));\n-    (respan(sp, hir::StmtDecl(P(decl), lctx.next_id())), pat_id)\n-}\n+    fn block_expr(&mut self, expr: P<hir::Expr>) -> P<hir::Block> {\n+        self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n+    }\n \n-fn block_expr(lctx: &mut LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n-    block_all(lctx, expr.span, hir::HirVec::new(), Some(expr))\n-}\n+    fn block_all(&mut self, span: Span, stmts: hir::HirVec<hir::Stmt>, expr: Option<P<hir::Expr>>)\n+                 -> P<hir::Block> {\n+        P(hir::Block {\n+            stmts: stmts,\n+            expr: expr,\n+            id: self.next_id(),\n+            rules: hir::DefaultBlock,\n+            span: span,\n+        })\n+    }\n \n-fn block_all(lctx: &mut LoweringContext,\n-             span: Span,\n-             stmts: hir::HirVec<hir::Stmt>,\n-             expr: Option<P<hir::Expr>>)\n-             -> P<hir::Block> {\n-    P(hir::Block {\n-        stmts: stmts,\n-        expr: expr,\n-        id: lctx.next_id(),\n-        rules: hir::DefaultBlock,\n-        span: span,\n-    })\n-}\n+    fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+        let ok = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n+        let path = self.path_global(span, ok);\n+        self.pat_enum(span, path, hir_vec![pat])\n+    }\n \n-fn pat_ok(lctx: &mut LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-    let ok = std_path(lctx, &[\"result\", \"Result\", \"Ok\"]);\n-    let path = path_global(span, ok);\n-    pat_enum(lctx, span, path, hir_vec![pat])\n-}\n+    fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+        let err = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n+        let path = self.path_global(span, err);\n+        self.pat_enum(span, path, hir_vec![pat])\n+    }\n \n-fn pat_err(lctx: &mut LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-    let err = std_path(lctx, &[\"result\", \"Result\", \"Err\"]);\n-    let path = path_global(span, err);\n-    pat_enum(lctx, span, path, hir_vec![pat])\n-}\n+    fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+        let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n+        let path = self.path_global(span, some);\n+        self.pat_enum(span, path, hir_vec![pat])\n+    }\n \n-fn pat_some(lctx: &mut LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-    let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n-    let path = path_global(span, some);\n-    pat_enum(lctx, span, path, hir_vec![pat])\n-}\n+    fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n+        let none = self.std_path(&[\"option\", \"Option\", \"None\"]);\n+        let path = self.path_global(span, none);\n+        self.pat_enum(span, path, hir_vec![])\n+    }\n \n-fn pat_none(lctx: &mut LoweringContext, span: Span) -> P<hir::Pat> {\n-    let none = std_path(lctx, &[\"option\", \"Option\", \"None\"]);\n-    let path = path_global(span, none);\n-    pat_enum(lctx, span, path, hir_vec![])\n-}\n+    fn pat_enum(&mut self, span: Span, path: hir::Path, subpats: hir::HirVec<P<hir::Pat>>)\n+                -> P<hir::Pat> {\n+        let def = self.resolver.resolve_generated_global_path(&path, true);\n+        let pt = if subpats.is_empty() {\n+            hir::PatKind::Path(path)\n+        } else {\n+            hir::PatKind::TupleStruct(path, Some(subpats))\n+        };\n+        let pat = self.pat(span, pt);\n+        self.resolver.record_resolution(pat.id, def);\n+        pat\n+    }\n \n-fn pat_enum(lctx: &mut LoweringContext,\n-            span: Span,\n-            path: hir::Path,\n-            subpats: hir::HirVec<P<hir::Pat>>)\n-            -> P<hir::Pat> {\n-    let def = lctx.resolver.resolve_generated_global_path(&path, true);\n-    let pt = if subpats.is_empty() {\n-        hir::PatKind::Path(path)\n-    } else {\n-        hir::PatKind::TupleStruct(path, Some(subpats))\n-    };\n-    let pat = pat(lctx, span, pt);\n-    lctx.resolver.record_resolution(pat.id, def);\n-    pat\n-}\n+    fn pat_ident(&mut self, span: Span, ident: hir::Ident) -> P<hir::Pat> {\n+        self.pat_ident_binding_mode(span, ident, hir::BindByValue(hir::MutImmutable))\n+    }\n \n-fn pat_ident(lctx: &mut LoweringContext, span: Span, ident: hir::Ident) -> P<hir::Pat> {\n-    pat_ident_binding_mode(lctx, span, ident, hir::BindByValue(hir::MutImmutable))\n-}\n+    fn pat_ident_binding_mode(&mut self, span: Span, ident: hir::Ident, bm: hir::BindingMode)\n+                              -> P<hir::Pat> {\n+        let pat_ident = hir::PatKind::Ident(bm,\n+                                            Spanned {\n+                                                span: span,\n+                                                node: ident,\n+                                            },\n+                                            None);\n \n-fn pat_ident_binding_mode(lctx: &mut LoweringContext,\n-                          span: Span,\n-                          ident: hir::Ident,\n-                          bm: hir::BindingMode)\n-                          -> P<hir::Pat> {\n-    let pat_ident = hir::PatKind::Ident(bm,\n-                                        Spanned {\n-                                            span: span,\n-                                            node: ident,\n-                                        },\n-                                        None);\n-\n-    let pat = pat(lctx, span, pat_ident);\n-\n-    let parent_def = lctx.parent_def;\n-    let def = lctx.resolver.definitions().map(|defs| {\n-        let def_path_data = DefPathData::Binding(ident.name);\n-        let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n-        Def::Local(DefId::local(def_index), pat.id)\n-    }).unwrap_or(Def::Err);\n-    lctx.resolver.record_resolution(pat.id, def);\n-\n-    pat\n-}\n+        let pat = self.pat(span, pat_ident);\n \n-fn pat_wild(lctx: &mut LoweringContext, span: Span) -> P<hir::Pat> {\n-    pat(lctx, span, hir::PatKind::Wild)\n-}\n+        let parent_def = self.parent_def;\n+        let def = self.resolver.definitions().map(|defs| {\n+            let def_path_data = DefPathData::Binding(ident.name);\n+            let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n+            Def::Local(DefId::local(def_index), pat.id)\n+        }).unwrap_or(Def::Err);\n+        self.resolver.record_resolution(pat.id, def);\n \n-fn pat(lctx: &mut LoweringContext, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n-    P(hir::Pat {\n-        id: lctx.next_id(),\n-        node: pat,\n-        span: span,\n-    })\n-}\n+        pat\n+    }\n \n-fn path_ident(span: Span, id: hir::Ident) -> hir::Path {\n-    path(span, vec![id])\n-}\n+    fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n+        self.pat(span, hir::PatKind::Wild)\n+    }\n \n-fn path(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, false, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-}\n+    fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n+        P(hir::Pat {\n+            id: self.next_id(),\n+            node: pat,\n+            span: span,\n+        })\n+    }\n \n-fn path_global(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, true, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-}\n+    fn path_ident(&mut self, span: Span, id: hir::Ident) -> hir::Path {\n+        self.path(span, vec![id])\n+    }\n \n-fn path_all(sp: Span,\n-            global: bool,\n-            mut idents: Vec<hir::Ident>,\n-            lifetimes: hir::HirVec<hir::Lifetime>,\n-            types: hir::HirVec<P<hir::Ty>>,\n-            bindings: hir::HirVec<hir::TypeBinding>)\n-            -> hir::Path {\n-    let last_identifier = idents.pop().unwrap();\n-    let mut segments: Vec<hir::PathSegment> = idents.into_iter()\n-                                                    .map(|ident| {\n-                                                        hir::PathSegment {\n-                                                            identifier: ident,\n-                                                            parameters: hir::PathParameters::none(),\n-                                                        }\n-                                                    })\n-                                                    .collect();\n-    segments.push(hir::PathSegment {\n-        identifier: last_identifier,\n-        parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-            lifetimes: lifetimes,\n-            types: types,\n-            bindings: bindings,\n-        }),\n-    });\n-    hir::Path {\n-        span: sp,\n-        global: global,\n-        segments: segments.into(),\n+    fn path(&mut self, span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n+        self.path_all(span, false, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n     }\n-}\n \n-fn std_path(lctx: &mut LoweringContext, components: &[&str]) -> Vec<hir::Ident> {\n-    let mut v = Vec::new();\n-    if let Some(s) = lctx.crate_root {\n-        v.push(hir::Ident::from_name(token::intern(s)));\n+    fn path_global(&mut self, span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n+        self.path_all(span, true, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n     }\n-    v.extend(components.iter().map(|s| hir::Ident::from_name(token::intern(s))));\n-    return v;\n-}\n \n-// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n-// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-fn core_path(lctx: &mut LoweringContext, span: Span, components: &[&str]) -> hir::Path {\n-    let idents = std_path(lctx, components);\n-    path_global(span, idents)\n-}\n+    fn path_all(&mut self,\n+                sp: Span,\n+                global: bool,\n+                mut idents: Vec<hir::Ident>,\n+                lifetimes: hir::HirVec<hir::Lifetime>,\n+                types: hir::HirVec<P<hir::Ty>>,\n+                bindings: hir::HirVec<hir::TypeBinding>)\n+                -> hir::Path {\n+        let last_identifier = idents.pop().unwrap();\n+        let mut segments: Vec<hir::PathSegment> = idents.into_iter().map(|ident| {\n+            hir::PathSegment {\n+                identifier: ident,\n+                parameters: hir::PathParameters::none(),\n+           }\n+        }).collect();\n \n-fn signal_block_expr(lctx: &mut LoweringContext,\n-                     stmts: hir::HirVec<hir::Stmt>,\n-                     expr: P<hir::Expr>,\n-                     span: Span,\n-                     rule: hir::BlockCheckMode,\n-                     attrs: ThinAttributes)\n-                     -> P<hir::Expr> {\n-    let id = lctx.next_id();\n-    expr_block(lctx,\n-               P(hir::Block {\n-                   rules: rule,\n-                   span: span,\n-                   id: id,\n-                   stmts: stmts,\n-                   expr: Some(expr),\n-               }),\n-               attrs)\n+        segments.push(hir::PathSegment {\n+            identifier: last_identifier,\n+            parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n+                lifetimes: lifetimes,\n+                types: types,\n+                bindings: bindings,\n+            }),\n+        });\n+        hir::Path {\n+            span: sp,\n+            global: global,\n+            segments: segments.into(),\n+        }\n+    }\n+\n+    fn std_path(&mut self, components: &[&str]) -> Vec<hir::Ident> {\n+        let mut v = Vec::new();\n+        if let Some(s) = self.crate_root {\n+            v.push(hir::Ident::from_name(token::intern(s)));\n+        }\n+        v.extend(components.iter().map(|s| hir::Ident::from_name(token::intern(s))));\n+        return v;\n+    }\n+\n+    // Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+    // `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+    fn core_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n+        let idents = self.std_path(components);\n+        self.path_global(span, idents)\n+    }\n+\n+    fn signal_block_expr(&mut self,\n+                         stmts: hir::HirVec<hir::Stmt>,\n+                         expr: P<hir::Expr>,\n+                         span: Span,\n+                         rule: hir::BlockCheckMode,\n+                         attrs: ThinAttributes)\n+                         -> P<hir::Expr> {\n+        let id = self.next_id();\n+        let block = P(hir::Block {\n+            rules: rule,\n+            span: span,\n+            id: id,\n+            stmts: stmts,\n+            expr: Some(expr),\n+        });\n+        self.expr_block(block, attrs)\n+    }\n }"}]}